/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// signed int __usercall sub_10001000@<eax>(int a1@<eax>);
int __thiscall sub_10001070(int this);
unsigned __int64 __thiscall sub_100010F0(int this);
void __thiscall AssetBundleAsset::FlushChanges(AssetBundleAsset *__hidden this); // idb
char __thiscall AssetBundleAsset::WriteBundleFile(AssetBundleAsset *this, void *a2, int a3, int *a4);
unsigned int __thiscall AssetBundleAsset::GetFileSize(AssetBundleAsset *this);
AssetBundleAsset *__thiscall AssetBundleAsset::AssetBundleAsset(AssetBundleAsset *this);
void __thiscall AssetBundleAsset::Clear(AssetBundleAsset *__hidden this); // idb
char __thiscall AssetBundleAsset::ReadBundleFile(AssetBundleAsset *this, void *a2, int a3, int *a4, struct AssetTypeTemplateField *a5, bool a6);
void __thiscall AssetBundleAsset::ReadBundleFile(AssetBundleAsset *this, void *, int, int *, int, bool); // idb
void __thiscall ResourceManagerFile::SetModified(ResourceManagerFile *__hidden this); // idb
bool __thiscall ClassDatabasePackage::IsValid(ClassDatabasePackage *__hidden this); // idb
void __cdecl ASSETBUNDLEASSET_DecreaseIndexRefs(struct AssetBundleAsset *, int); // idb
void __cdecl ASSETBUNDLEASSET_IncreaseIndexRefs(struct AssetBundleAsset *, int); // idb
void __cdecl ASSETBUNDLEASSET_Optimize(size_t); // idb
int __cdecl ASSETBUNDLEASSET_GetRefCount(struct AssetBundleAsset *, int); // idb
int __thiscall AssetBundleAsset::AddContainer(AssetBundleAsset *this, struct ContainerData *); // idb
void __thiscall AssetBundleAsset::UpdatePreloadArray(size_t this, unsigned __int32); // idb
void __thiscall AssetBundleAsset::RemoveContainer(AssetBundleAsset *this, unsigned __int32); // idb
int __thiscall sub_10004290(void *this);
void *__thiscall sub_100042A0(void *this, char a2);
// int __usercall sub_100042D0@<eax>(int a1@<eax>);
// int __usercall sub_10004360@<eax>(int a1@<edi>);
char __thiscall AssetsBundleBlockAndDirectoryList06::Read(AssetsBundleBlockAndDirectoryList06 *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4, void (__cdecl *a5)(char *));
void __thiscall AssetsBundleBlockAndDirectoryList06::Free(AssetsBundleBlockAndDirectoryList06 *__hidden this); // idb
char __thiscall AssetsBundleBlockAndDirectoryList06::Write(AssetsBundleBlockAndDirectoryList06 *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 *a4, void (__cdecl *a5)(char *));
bool __thiscall AssetsBundleHeader06::ReadInitial(AssetsBundleHeader06 *this, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32, void (__cdecl *)(char *)); // idb
char __thiscall AssetsBundleHeader06::Read(AssetsBundleHeader06 *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, void (__cdecl *a4)(char *));
char __thiscall AssetsBundleHeader06::Write(AssetsBundleHeader06 *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 *a4, void (__cdecl *a5)(char *));
char __thiscall AssetsBundleHeader03::Read(AssetsBundleHeader03 *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, void (__cdecl *a4)(char *));
char __thiscall AssetsBundleHeader03::Write(AssetsBundleHeader03 *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 *a4, void (__cdecl *a5)(char *));
unsigned __int64 __thiscall AssetsBundleDirectoryInfo06::GetAbsolutePos(AssetsBundleDirectoryInfo06 *this, struct AssetsBundleFile *); // idb
int __thiscall AssetsBundleEntry::GetAbsolutePos(AssetsBundleEntry *this, struct AssetsBundleFile *a2);
char __thiscall AssetsList::Read(AssetsList *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 *a4, void (__cdecl *a5)(char *));
void __thiscall AssetsList::Free(AssetsList *__hidden this); // idb
bool __thiscall AssetsList::Write(AssetsList *this, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32), __int32, unsigned __int64 *, void (__cdecl *)(char *)); // idb
char __thiscall AssetsList::Write(AssetsList *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5, bool a6, unsigned __int64 *a7, unsigned __int64 *a8, void (__cdecl *a9)(char *));
int __cdecl AssetsBundle_AssetsFileReader(unsigned __int64 a1, unsigned __int64 a2, void *a3, __int32 a4);
AssetsBundleFile *__thiscall AssetsBundleFile::AssetsBundleFile(AssetsBundleFile *this);
void __thiscall AssetsBundleFile::Close(AssetsBundleFile *__hidden this); // idb
void __cdecl sub_10006560(int a1, void *a2);
// signed int __usercall sub_10006580@<eax>(int a1@<edx>, int (__cdecl *a2)(_DWORD, _DWORD, int, _DWORD, void *, int)@<ecx>, _DWORD *a3, unsigned __int64 a4, int (__cdecl *a5)(_DWORD, _DWORD, _DWORD, unsigned int, void *, int), int a6, int a7);
char __cdecl sub_10006940(_DWORD *a1, _DWORD *a2, unsigned __int64 a3, int (__cdecl *a4)(_DWORD, _DWORD, int, int, _BYTE *, int), int a5, int (__cdecl *a6)(_DWORD, _DWORD, char *, _DWORD, void *, int), int a7);
char __thiscall AssetsBundleFile::Unpack(AssetsBundleFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5);
signed int __cdecl sub_10007820(int a1, int a2, int *a3);
int __cdecl sub_10007870(int a1, int a2, int a3);
char __thiscall AssetsBundleFile::Pack(AssetsBundleFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5);
char __thiscall AssetsBundleFile::Write(AssetsBundleFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5, struct BundleReplacer **a6, unsigned int a7, void (__cdecl *a8)(char *), struct ClassDatabaseFile *a9);
char __thiscall AssetsBundleFile::Read(AssetsBundleFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, void (__cdecl *a4)(char *), bool a5);
bool __thiscall AssetsBundleFile::IsAssetsFile(AssetsBundleFile *this, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32, struct AssetsBundleDirectoryInfo06 *); // idb
char __thiscall AssetsBundleFile::IsAssetsFile(AssetsBundleFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, struct AssetsBundleEntry *a4);
int (__cdecl *__thiscall AssetsBundleFile::MakeAssetsFileReader(AssetsBundleFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 *a3, struct AssetsBundleDirectoryInfo06 *a4))(unsigned __int64 a1, unsigned __int64 a2, void *a3, __int32 a4);
int (__cdecl *__thiscall AssetsBundleFile::MakeAssetsFileReader(AssetsBundleFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 *a3, struct AssetsBundleEntry *a4))(unsigned __int64 a1, unsigned __int64 a2, void *a3, __int32 a4);
void __cdecl FreeAssetsBundle_FileReader(__int32 *, unsigned __int64 (__cdecl **)(unsigned __int64, unsigned __int64, void *, __int32)); // idb
// unsigned int __usercall sub_1000A640@<eax>(unsigned int a1@<eax>, int a2@<esi>);
// _DWORD *__userpurge sub_1000A710@<eax>(_DWORD *result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_1000A750@<eax>(unsigned int a1@<eax>, int a2@<edi>);
// _DWORD *__usercall sub_1000A830@<eax>(_DWORD *a1@<eax>, int a2@<edi>);
// unsigned int __usercall sub_1000A890@<eax>(unsigned int a1@<eax>, int a2@<edi>);
// unsigned int __usercall sub_1000A8F0@<eax>(int a1@<ecx>, int a2@<ebx>);
unsigned int __thiscall sub_1000A960(int this);
// unsigned int __usercall sub_1000A9D0@<eax>(int a1@<eax>);
unsigned int __thiscall sub_1000AA30(int this);
unsigned int __thiscall sub_1000AA80(void *this, unsigned int a2);
// void __usercall __noreturn sub_1000AB4F(int a1@<ebp>);
unsigned int __thiscall sub_1000AB70(void *this, unsigned int a2);
// void __usercall __noreturn sub_1000AC41(int a1@<ebp>);
unsigned int __thiscall sub_1000AC60(void *this, unsigned int a2);
// void __usercall __noreturn sub_1000AD10(int a1@<ebp>);
void *__fastcall sub_1000AD30(unsigned int a1);
void *__fastcall sub_1000AD90(unsigned int a1);
void *__fastcall sub_1000ADF0(unsigned int a1);
void *__fastcall sub_1000AE50(unsigned int a1);
// int __usercall sub_1000AEB0@<eax>(int result@<eax>);
__int64 __cdecl sub_1000AF00(int a1, int a2);
int sub_1000AF40(char *Format, ...);
std::exception *__thiscall sub_1000AF60(std::exception *this, const struct std::exception *a2);
// int __usercall sub_1000AF80@<eax>(int result@<eax>, int a2@<edx>);
// int __usercall sub_1000AFA0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1000AFD0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1000B010@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1000B030@<eax>(int a1@<eax>, int a2, int a3);
char *__thiscall AssetFile::GetFileName(AssetFile *this, char *, unsigned int, int); // idb
signed int __cdecl AssetFileInfo::GetSize(unsigned __int32 a1);
unsigned __int64 __thiscall AssetFileInfo::Read(AssetFileInfo *this, unsigned __int32, unsigned __int64, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32, bool); // idb
signed __int64 __thiscall AssetFileInfo::Write(AssetFileInfo *this, unsigned __int32 a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5);
unsigned int __thiscall AssetFileList::GetSizeBytes(AssetFileList *this, unsigned __int32); // idb
int __thiscall AssetFileList::Read(AssetFileList *this, unsigned __int32 a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a5, bool a6);
int __thiscall AssetFileList::Write(AssetFileList *this, unsigned __int32 a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5);
int __thiscall AssetsFileHeader::Read(AssetsFileHeader *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4);
unsigned __int64 __thiscall AssetsFileHeader::Write(AssetsFileHeader *this, unsigned __int64, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32), __int32); // idb
signed int AssetsFileHeader::GetSizeBytes();
int __thiscall TypeField_0D::Read(TypeField_0D *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4, bool a5);
unsigned __int64 __thiscall TypeField_0D::Write(TypeField_0D *this, unsigned __int64, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32), __int32); // idb
char *__thiscall TypeField_0D::GetTypeString(TypeField_0D *this, const char *a2, unsigned int a3);
char *__thiscall TypeField_0D::GetNameString(TypeField_0D *this, const char *a2, unsigned int a3);
int __thiscall Type_0D::Write(Type_0D *this, bool a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5, unsigned __int32 a6);
unsigned int __thiscall Type_0D::Read(Type_0D *this, bool a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a5, unsigned __int32 a6, unsigned __int32 a7, bool a8);
unsigned int __thiscall TypeField_07::Read(TypeField_07 *this, bool a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a5, unsigned __int32 a6, unsigned __int32 a7, bool a8);
unsigned int __thiscall TypeField_07::Write(TypeField_07 *this, bool a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5);
unsigned int __thiscall Type_07::Write(Type_07 *this, bool a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5);
unsigned int __thiscall Type_07::Read(Type_07 *this, bool a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a5, unsigned __int32 a6, unsigned __int32 a7, bool a8);
unsigned int __thiscall TypeTree::Write(TypeTree *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a4, unsigned __int32 a5);
int __thiscall TypeTree::Read(TypeTree *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4, unsigned __int32 a5, bool a6);
int __cdecl sub_1000D590(int a1);
void __thiscall TypeTree::Clear(TypeTree *__hidden this); // idb
unsigned __int64 __thiscall AssetsFileDependency::GUID128::Read(AssetsFileDependency::GUID128 *this, unsigned __int64, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32); // idb
unsigned __int64 __thiscall AssetsFileDependency::GUID128::Write(AssetsFileDependency::GUID128 *this, unsigned __int64, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32), __int32); // idb
int __thiscall AssetsFileDependency::Read(AssetsFileDependency *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4, bool a5);
signed __int64 __thiscall AssetsFileDependency::Write(AssetsFileDependency *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a4);
unsigned int __thiscall AssetsFileDependencyList::Write(AssetsFileDependencyList *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a4, unsigned __int32 a5);
int __thiscall AssetsFileDependencyList::Read(AssetsFileDependencyList *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4, unsigned __int32 a5, bool a6);
unsigned int __thiscall PreloadList::Write(PreloadList *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a4, unsigned __int32 a5);
int __thiscall PreloadList::Read(PreloadList *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4, unsigned __int32 a5, bool a6);
int __thiscall AssetsFile::Write(AssetsFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), void *a3, unsigned __int64 a4, struct AssetsReplacer **a5, unsigned int a6, unsigned __int32 a7, struct ClassDatabaseFile *a8);
AssetsFileHeader *__thiscall AssetsFile::AssetsFile(AssetsFileHeader *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3);
void __thiscall AssetsFile::~AssetsFile(AssetsFile *this);
bool __thiscall AssetsFile::GetAssetFile(AssetsFile *this, unsigned __int64, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), struct AssetFile *, __int32); // idb
unsigned __int64 __thiscall AssetsFile::GetAssetFileOffs(AssetsFile *this, unsigned __int64, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32); // idb
bool __thiscall AssetsFile::GetAssetFileByIndex(AssetsFile *this, unsigned __int64, struct AssetFile *, unsigned int *, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32); // idb
unsigned __int64 __thiscall AssetsFile::GetAssetFileOffsByIndex(AssetsFile *this, unsigned __int64, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32); // idb
bool __thiscall AssetsFile::GetAssetFileByName(AssetsFile *this, const char *, struct AssetFile *, unsigned int *, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32); // idb
unsigned __int64 __thiscall AssetsFile::GetAssetFileOffsByName(AssetsFile *this, const char *, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32); // idb
__int64 __thiscall AssetsFile::GetAssetFileInfoOffs(AssetsFile *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4);
unsigned __int64 __thiscall AssetsFile::GetAssetFileInfoOffsByName(AssetsFile *this, const char *, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32); // idb
unsigned __int64 __thiscall AssetsFile::GetFileList(AssetsFile *this, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32); // idb
unsigned __int32 __cdecl SwapEndians(unsigned __int32); // idb
void __cdecl SwapEndians_(unsigned __int32 *); // idb
char __cdecl StringIsValid(char *a1, int a2);
char __cdecl HasName(unsigned __int32 a1);
char __thiscall AssetsFile::VerifyAssetsFile(AssetsFile *this, void (__cdecl *a2)(char *));
unsigned int __thiscall sub_10010B60(unsigned int *this, unsigned int a2);
// void __usercall __noreturn sub_10010C43(int a1@<ebp>);
unsigned int __thiscall sub_10010C60(unsigned int *this, unsigned int a2);
// void __usercall __noreturn sub_10010D35(int a1@<ebp>);
// char *__usercall sub_10010D50@<eax>(unsigned int a1@<eax>, int a2@<esi>);
unsigned int __thiscall sub_10010DD0(int this);
void *__fastcall sub_10010E50(unsigned int a1);
void *__fastcall sub_10010EB0(unsigned int a1);
// unsigned int __usercall sub_10010F10@<eax>(int a1@<eax>, int a2@<ecx>);
// unsigned int __userpurge sub_10010F70@<eax>(int a1@<esi>, unsigned int a2);
int sub_10010FF0(char *Format, ...);
// void *__usercall sub_10011010@<eax>(void *result@<eax>, const void *a2@<edx>, const void *a3@<ebx>);
// void *__usercall sub_10011040@<eax>(void *result@<eax>, const void *a2@<edx>, const void *a3@<ebx>);
int __thiscall AssetsFileTable::AssetsFileTable(int this, int a2, char a3);
void __thiscall AssetsFileTable::~AssetsFileTable(AssetsFileTable *this);
struct AssetFileInfoEx *__thiscall AssetsFileTable::getAssetInfo(AssetsFileTable *this, unsigned __int64); // idb
struct AssetFileInfoEx *__thiscall AssetsFileTable::getAssetInfo(AssetsFileTable *this, const char *); // idb
struct AssetFileInfoEx *__thiscall AssetsFileTable::getAssetInfo(AssetsFileTable *this, const char *, unsigned __int32); // idb
struct AssetsFile *__thiscall AssetsFileTable::getAssetsFile(AssetsFileTable *__hidden this); // idb
unsigned __int64 (__cdecl *__thiscall AssetsFileTable::getReader(AssetsFileTable *__hidden this))(unsigned __int64, unsigned __int64, void *, __int32); // idb
__int32 __thiscall AssetsFileTable::getReaderPar(AssetsFileTable *__hidden this); // idb
void *__thiscall sub_100117B0(void *this, char a2);
int __thiscall sub_100117E0(int this);
__int64 sub_100117F0();
__int64 __stdcall sub_10011800(__int64 a1, int a2, int a3);
__int64 __thiscall sub_10011810(char *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4);
// int __userpurge sub_100118D0@<eax>(int result@<eax>, int a2@<ecx>, int a3, int a4, int a5, __int16 a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
__int16 __thiscall sub_10011940(int this);
int __thiscall sub_10011950(int this, __int64 a2, void (__cdecl *a3)(_DWORD, _DWORD, _DWORD, _DWORD, char *, int), int a4);
int __thiscall sub_10011AE0(char *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4);
// int __userpurge sub_10011BD0@<eax>(int result@<eax>, int a2@<ecx>, int a3, int a4, int a5, __int16 a6, int a7, int a8, int a9);
void *__thiscall sub_10011C10(int this, char a2);
__int64 __thiscall sub_10011C80(int this);
__int64 __thiscall sub_10011C90(int this, __int64 a2, void (__cdecl *a3)(_DWORD, _DWORD, int, _DWORD, _DWORD, int), int a4);
int __thiscall sub_10011CE0(char *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4);
void *__thiscall sub_10011DE0(int this, char a2);
__int64 __thiscall sub_10011E20(int this);
int __thiscall sub_10011E30(int this, __int64 a2, void (__cdecl *a3)(_DWORD, _DWORD, size_t, unsigned int, char *, int), int a4);
int __thiscall sub_10011FA0(char *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4);
struct AssetsReplacer *__cdecl ReadAssetsReplacer(unsigned __int64 *, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32, bool); // idb
struct AssetsReplacer *__cdecl MakeAssetRemover(unsigned __int32, unsigned __int64, int, unsigned __int16); // idb
struct AssetsReplacer *__cdecl MakeAssetModifierFromReader(unsigned __int32, unsigned __int64, int, unsigned __int16, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32, unsigned __int64, unsigned __int64, unsigned int); // idb
struct AssetsReplacer *__cdecl MakeAssetModifierFromMemory(unsigned __int32, unsigned __int64, int, unsigned __int16, void *, unsigned int, void (__cdecl *)(void *)); // idb
struct AssetsReplacer *__cdecl MakeAssetModifierFromFile(unsigned __int32, unsigned __int64, int, unsigned __int16, struct _iobuf *, unsigned __int64, unsigned __int64, unsigned int, bool); // idb
unsigned __int64 __cdecl AssetsWriterToFile(fpos_t a1, size_t a2, const void *a3, FILE *a4, FILE *a5);
unsigned __int64 __cdecl AssetsReaderFromFile(fpos_t a1, size_t a2, void *a3, FILE *a4, FILE *a5);
void __cdecl AssetsVerifyLoggerFromFile(LPCSTR lpText); // idb
void __cdecl AssetsVerifyLoggerToConsole(char *); // idb
int __cdecl sub_10012550(wchar_t *a1);
wchar_t *__cdecl Create_AssetsReaderFromSplitFileW(const wchar_t *a1);
WCHAR *__cdecl Create_AssetsReaderFromSplitFile(LPCSTR lpMultiByteStr);
void __cdecl Free_AssetsReaderFromSplitFile(__int32); // idb
unsigned int __cdecl AssetsReaderFromSplitFile(unsigned __int64 a1, size_t a2, void *a3, __int32 a4, int a5);
void *__cdecl Create_AssetsReaderFromMemory(void *a1, size_t a2, bool a3);
void __cdecl Free_AssetsReaderFromMemory(void *, bool); // idb
int __cdecl AssetsReaderFromMemory(unsigned __int64 a1, size_t a2, void *a3, __int32 a4, __int32 a5);
_DWORD *__cdecl Create_AssetsWriterToMemory(void *a1, unsigned int a2);
_DWORD *__cdecl Create_AssetsWriterToMemoryDynamic();
void __cdecl Free_AssetsWriterToMemory(void *, bool); // idb
void *__cdecl Get_AssetsWriterToMemory_Buf(__int32, unsigned int *, unsigned int *); // idb
size_t __cdecl AssetsWriterToMemory(unsigned __int64 a1, unsigned __int64 a2, const void *a3, __int32 a4);
_DWORD *__cdecl Create_AssetsWriterOffset(unsigned __int64 (__cdecl *a1)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a2, unsigned __int64 a3);
int __cdecl AssetsWriterOffset(unsigned __int64 a1, unsigned __int64 a2, const void *a3, __int32 a4);
void __cdecl Free_AssetsWriterToMemory_DynMem(void *); // idb
int __cdecl PartialAssetsFileReader(unsigned __int64 a1, size_t a2, void *a3, __int32 a4, int a5);
unsigned __int64 (__cdecl *__cdecl Create_PartialAssetsFileReader(unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32 *, unsigned __int64, unsigned __int64))(unsigned __int64, unsigned __int64, void *, __int32); // idb
void __cdecl Free_PartialAssetsFileReader(void *); // idb
unsigned __int64 (__cdecl *__cdecl Free_PartialAssetsFileReader(__int32 *))(unsigned __int64, unsigned __int64, void *, __int32); // idb
// unsigned int __usercall sub_10012F70@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<ebp>, signed int a4@<edi>);
// void __usercall __noreturn sub_1001307A(int a1@<ebp>);
void *__fastcall sub_100130A0(unsigned int a1);
int sub_10013100(wchar_t *Format, ...);
// int __usercall sub_10013120@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// double __usercall sub_10013150@<st0>(int a1@<eax>);
// double __usercall sub_10013210@<st0>(int a1@<eax>);
int __thiscall AssetTypeValue::AssetTypeValue(AssetTypeValue *this, int a2, void *a3);
void __thiscall AssetTypeValue::Set(AssetTypeValue *this, void *); // idb
_DWORD __thiscall AssetTypeValue::~AssetTypeValue(AssetTypeValue *__hidden this); // idb
void *__thiscall AssetTypeValueField::operator[](int this, const char *a2);
_DWORD *__thiscall AssetTypeValueField::operator[](int this, unsigned int a2);
void __thiscall AssetTypeValueField::Read(AssetTypeValueField *this, struct AssetTypeValue *, struct AssetTypeTemplateField *, unsigned __int32, struct AssetTypeValueField **); // idb
int __thiscall AssetTypeValueField::Write(AssetTypeValueField *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 a4);
unsigned int __thiscall AssetTypeValueField::GetByteSize(AssetTypeValueField *this, unsigned __int64 a2);
BOOL __thiscall AssetTypeValueField::IsDummy(AssetTypeValueField *this);
struct AssetTypeValueField *__cdecl GetDummyAssetTypeField(); // idb
signed int __cdecl GetValueTypeByTypeName(char *a1);
int __cdecl sub_10013BF0(unsigned int a1, void (__cdecl *a2)(unsigned int, unsigned int, signed int, _DWORD, unsigned int *, int), int a3, int a4, int *a5, int *a6, int *a7, int a8);
unsigned int __cdecl sub_10013EA0(int a1, void (__cdecl *a2)(unsigned int, int, unsigned __int32, _DWORD, void *, int), int a3, __int64 a4, int a5, _DWORD *a6, _DWORD *a7, int *a8, void **a9, int a10);
AssetTypeTemplateField *__thiscall AssetTypeTemplateField::AssetTypeTemplateField(AssetTypeTemplateField *this);
void __thiscall AssetTypeTemplateField::Clear(AssetTypeTemplateField *__hidden this); // idb
int __thiscall AssetTypeTemplateField::MakeValue(AssetTypeTemplateField *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 a4, struct AssetTypeValueField **a5, int a6);
char __thiscall AssetTypeTemplateField::From0D(AssetTypeTemplateField *this, struct Type_0D *a2, unsigned __int32 a3);
char __thiscall AssetTypeTemplateField::FromClassDatabase(AssetTypeTemplateField *this, struct ClassDatabaseFile *a2, struct ClassDatabaseType *a3, unsigned __int32 a4);
char __thiscall AssetTypeTemplateField::From07(AssetTypeTemplateField *this, struct TypeField_07 *a2);
struct AssetTypeTemplateField *__thiscall AssetTypeTemplateField::SearchChild(AssetTypeTemplateField *this, const char *); // idb
int __thiscall AssetTypeInstance::AssetTypeInstance(int this, int a2, int a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a5, int a6, unsigned __int64 a7);
bool __thiscall AssetTypeInstance::SetChildList(AssetTypeInstance *this, struct AssetTypeValueField *, struct AssetTypeValueField **, unsigned __int32, bool); // idb
char __thiscall AssetTypeInstance::AddTempMemory(AssetTypeInstance *this, void *a2);
void __thiscall AssetTypeInstance::~AssetTypeInstance(AssetTypeInstance *this);
void *__thiscall sub_10014DF0(void *this, char a2);
// int __userpurge sub_10014E20@<eax>(const char *a1@<ebx>, int a2, int a3);
void *__thiscall sub_10014EA0(int this, char a2);
signed int sub_10014EE0();
__int64 __thiscall sub_10014EF0(void *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4);
char sub_10014FA0();
int __fastcall sub_10014FB0(int a1, const char *a2, int a3, const char *a4, char a5);
int __thiscall sub_10015070(int this, char a2);
signed int sub_100150C0();
int __thiscall sub_10015110(int this);
signed __int64 sub_10015120();
char __stdcall sub_10015130(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
__int64 __thiscall sub_10015140(void *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4);
char __thiscall sub_10015260(int this);
// int __userpurge sub_10015270@<eax>(char a1@<al>, const char *a2@<edx>, const char *a3@<ecx>, int a4@<esi>, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
void *__thiscall sub_100152C0(void *this, char a2);
void __stdcall sub_100152F0(int a1);
__int64 __thiscall sub_10015390(int this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, _DWORD, _DWORD, char *, int), int a4);
int __thiscall sub_100154C0(void *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4);
void *__thiscall sub_10015600(void *this, char a2);
void __stdcall sub_10015630(int a1);
__int64 __thiscall sub_100156D0(int this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, int), int a4);
int __thiscall sub_10015700(void *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4);
void *__thiscall sub_10015850(void *this, char a2);
void __stdcall sub_10015880(int a1);
signed __int64 __thiscall sub_10015960(int this);
char __thiscall sub_10015B80(void *this, int a2, int a3, void *a4, int a5, int a6, int a7, int a8, int a9);
void __thiscall sub_10015CC0(int this);
int __thiscall sub_10015D10(int this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, const void *, __int32), void *a4);
int __thiscall sub_10015D50(void *this, __int64 a2, int (__cdecl *a3)(_DWORD, unsigned int, signed int, _DWORD, int *, int), int a4);
struct AssetsReplacer **__thiscall BundleEntryModifierFromAssets::GetReplacers(BundleEntryModifierFromAssets *this, unsigned int *); // idb
struct AssetsFile *__thiscall BundleEntryModifierFromAssets::GetAssignedAssetsFile(BundleEntryModifierFromAssets *__hidden this); // idb
struct BundleReplacer *__cdecl ReadBundleReplacer(unsigned __int64 *, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32, bool); // idb
struct BundleReplacer *__cdecl MakeBundleEntryRemover(const char *, unsigned int); // idb
struct BundleReplacer *__cdecl MakeBundleEntryRenamer(const char *, const char *, bool, unsigned int); // idb
struct BundleReplacer *__cdecl MakeBundleEntryModifier(const char *, const char *, bool, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32, void (__cdecl *)(unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32), unsigned __int64, unsigned __int64, unsigned int, unsigned int); // idb
struct BundleReplacer *__cdecl MakeBundleEntryModifierFromMem(const char *, const char *, bool, void *, unsigned int, unsigned int, void (__cdecl *)(void *)); // idb
struct BundleReplacer *__cdecl MakeBundleEntryModifierFromAssets(const char *, const char *, struct AssetsFile *, struct AssetsReplacer **, unsigned int, unsigned __int32, unsigned int); // idb
void __cdecl FreeBundleReplacer(struct BundleReplacer *); // idb
void *__cdecl sub_10016720(int a1, size_t a2);
const char *__thiscall ClassDatabaseFileString::GetString(ClassDatabaseFileString *this, struct ClassDatabaseFile *); // idb
unsigned __int64 __thiscall ClassDatabaseFileString::Read(ClassDatabaseFileString *this, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32, unsigned __int64); // idb
unsigned __int64 __thiscall ClassDatabaseFileString::Write(ClassDatabaseFileString *this, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32), __int32, unsigned __int64); // idb
AssetFile *__thiscall AssetFile::GetFileData(AssetFile *this);
ClassDatabaseTypeField *__thiscall ClassDatabaseTypeField::ClassDatabaseTypeField(ClassDatabaseTypeField *this, const struct ClassDatabaseTypeField *a2);
signed __int64 __thiscall ClassDatabaseTypeField::Read(ClassDatabaseTypeField *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 a4, int a5);
signed __int64 __thiscall ClassDatabaseTypeField::Write(ClassDatabaseTypeField *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 a4, int a5);
int __thiscall ClassDatabaseType::ClassDatabaseType(int this);
void __thiscall ClassDatabaseType::~ClassDatabaseType(ClassDatabaseType *this);
unsigned __int64 __thiscall ClassDatabaseType::Read(ClassDatabaseType *__hidden this, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32, unsigned __int64, _DWORD); // weak
unsigned int __thiscall ClassDatabaseType::Write(ClassDatabaseType *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 a4, int a5);
BYTE *__thiscall ClassDatabaseType::MakeTypeHash(_DWORD *this, BYTE *a2, int a3);
signed __int64 __thiscall ClassDatabaseFileHeader::Read(ClassDatabaseFileHeader *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 a4);
signed __int64 __thiscall ClassDatabaseFileHeader::Write(ClassDatabaseFileHeader *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 a4);
int __thiscall ClassDatabaseFile::Read(ClassDatabaseFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), void *a3, unsigned __int64 a4);
bool __thiscall ClassDatabaseFile::Read(ClassDatabaseFile *this, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), void *); // idb
char __stdcall sub_100179D0(int a1, int a2, unsigned int a3);
// int __userpurge sub_10017B50@<eax>(int a1@<edi>, char *a2, char a3);
__int64 __thiscall ClassDatabaseFile::Write(ClassDatabaseFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 a4, int a5, unsigned __int32 a6, bool a7);
char __thiscall ClassDatabaseFile::InsertFrom(ClassDatabaseFile *this, struct ClassDatabaseFile *a2, struct ClassDatabaseType *a3);
ClassDatabaseFile *__thiscall ClassDatabaseFile::ClassDatabaseFile(ClassDatabaseFile *this);
void __thiscall ClassDatabaseFile::Clear(ClassDatabaseFile *__hidden this); // idb
void __thiscall ClassDatabaseFile::~ClassDatabaseFile(ClassDatabaseFile *this);
unsigned __int64 __thiscall ClassDatabasePackageHeader::Read(ClassDatabasePackageHeader *this, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32, unsigned __int64); // idb
unsigned __int64 __thiscall ClassDatabasePackageHeader::Write(ClassDatabasePackageHeader *this, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32), __int32, unsigned __int64); // idb
void __thiscall ClassDatabasePackage::Clear(ClassDatabasePackage *__hidden this); // idb
ClassDatabaseFile *__stdcall sub_10018F00(ClassDatabaseFile *a1);
char __thiscall ClassDatabasePackage::Read(ClassDatabasePackage *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3);
int __thiscall ClassDatabasePackage::Write(ClassDatabasePackage *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 a4, int a5, unsigned __int32 a6);
char __thiscall ClassDatabasePackage::RemoveFile(ClassDatabasePackage *this, unsigned __int32 a2);
char __thiscall ClassDatabasePackage::ImportFile(ClassDatabasePackage *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3);
void *__thiscall ClassDatabasePackage::ClassDatabasePackage(void *this);
void __thiscall ClassDatabasePackage::~ClassDatabasePackage(ClassDatabasePackage *this);
unsigned int __fastcall sub_10019C00(unsigned int a1, int a2);
// void __usercall __noreturn sub_10019CAA(int a1@<ebp>);
// _DWORD *__usercall sub_10019CD0@<eax>(unsigned int a1@<eax>, int a2@<edi>);
// void __usercall sub_10019D40(int a1@<esi>);
unsigned int __thiscall sub_10019D80(void *this, unsigned int a2);
// void __usercall __noreturn sub_10019E46(int a1@<ebp>);
// int __usercall sub_10019E60@<eax>(unsigned int a1@<eax>, int a2@<edi>);
// _DWORD *__userpurge sub_10019EF0@<eax>(_DWORD *result@<eax>, int a2@<edi>, int a3);
_DWORD *__stdcall sub_10019F40(int a1, _DWORD *a2, void *a3, const void *a4);
unsigned int __fastcall sub_10019F90(int a1, int a2);
void *__fastcall sub_10019FF0(unsigned int a1);
unsigned int __fastcall sub_1001A050(int a1, int a2);
// int __usercall sub_1001A0B0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1001A0F0@<eax>(int result@<eax>, char *a2@<edx>);
void __cdecl sub_1001A120(int a1);
// _DWORD *__usercall sub_1001A1E0@<eax>(int a1@<eax>, _DWORD *a2@<ecx>, int a3);
// int __usercall sub_1001A230@<eax>(int result@<eax>, int a2@<ebx>);
int __stdcall sub_1001A270(int a1, int a2);
// char __usercall sub_1001A380@<al>(unsigned int a1@<eax>, int a2@<edi>);
int __cdecl sub_1001A3C0(int a1, int a2);
// void __usercall sub_1001A450(int a1@<esi>);
// void *__usercall sub_1001A480@<eax>(void *result@<eax>, const void *a2@<edx>, const void *a3@<ebx>);
// void *__usercall sub_1001A4A0@<eax>(void *result@<eax>, const void *a2@<edx>, const void *a3@<ebx>);
unsigned __int32 __cdecl TestTexToolWrap(); // idb
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
char __thiscall ResourceManagerFile::Write(ResourceManagerFile *this, void *a2, int a3, int *a4);
int __thiscall ResourceManagerFile::GetFileSize(ResourceManagerFile *__hidden this); // idb
int __thiscall ResourceManagerFile::ResourceManagerFile(int this);
void __thiscall ResourceManagerFile::Clear(ResourceManagerFile *__hidden this); // idb
void __thiscall ResourceManagerFile::Read(ResourceManagerFile *this, void *, int, int *, int, bool); // idb
int __thiscall ResourceManagerFile::AddContainer(ResourceManagerFile *this, struct ResourceManager_ContainerData *); // idb
void __thiscall ResourceManagerFile::RemoveContainer(ResourceManagerFile *this, int); // idb
// double __usercall sub_1001B230@<st0>(_WORD *a1@<eax>);
__int16 __stdcall sub_1001B270(int a1, float a2);
char __cdecl ReadTextureFile(struct TextureFile *a1, struct AssetTypeValueField *a2);
int __cdecl WriteTextureFile(struct TextureFile *a1, struct AssetTypeTemplateField *a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a4);
char __cdecl WriteTextureFile(struct TextureFile *a1, struct AssetTypeValueField *a2);
int __fastcall sub_1001C5A0(int a1, int a2);
// char __userpurge sub_1001C660@<al>(unsigned int a1@<eax>, int a2, unsigned int a3, unsigned int a4);
// char __userpurge sub_1001C700@<al>(int a1@<ecx>, int a2@<esi>, unsigned int a3, unsigned int a4);
void *__cdecl sub_1001CB90(void *a1, size_t a2, int a3, char a4);
size_t __cdecl sub_1001CC40(void *a1);
int (*sub_1001CC60())();
// int __usercall sub_1001CCB0@<eax>(int *a1@<edi>, int a2);
// int __usercall sub_1001CD90@<eax>(size_t a1@<ecx>, int *a2@<esi>, void *a3);
void *__cdecl sub_1001CE80(void *a1);
// signed int __usercall sub_1001CF10@<eax>(int a1@<eax>);
// int __usercall sub_1001CF60@<eax>(int result@<eax>, unsigned int a2@<edx>);
// char __usercall sub_1001CFC0@<al>(unsigned int a1@<edx>, int a2@<edi>, int a3);
int sub_1001D090(); // weak
void __thiscall sub_1001D0B0(void *); // idb
// void *__usercall sub_1001D160@<eax>(int a1@<esi>);
// char __usercall sub_1001D1D0@<al>(int a1@<ebx>);
char __stdcall sub_1001D260(int a1, int a2);
int __fastcall sub_1001D4B0(int a1, int a2, int a3);
int __fastcall sub_1001D510(int a1, int a2, int a3);
int __stdcall sub_1001D620(int a1);
void __stdcall sub_1001D740(int a1);
// bool __usercall sub_1001D880@<al>(unsigned int a1@<eax>, unsigned int a2@<edx>, int a3@<edi>);
// bool __userpurge sub_1001D8C0@<al>(int a1@<eax>, int a2, unsigned int a3, unsigned int a4);
// bool __userpurge sub_1001D940@<al>(int a1@<edi>, int a2, int a3, int a4, unsigned int a5, unsigned int a6);
// bool __usercall sub_1001DAC0@<al>(int a1@<eax>);
// bool __usercall sub_1001DBC0@<al>(unsigned int a1@<esi>);
char __thiscall sub_1001DC30(unsigned int this);
char __thiscall sub_1001DE30(int this);
char __thiscall sub_1001E190(int this);
char __thiscall sub_1001E2F0(int this);
char __fastcall sub_1001E6B0(unsigned int a1, signed int a2, int a3, int a4, char a5, char a6, unsigned int a7);
char __fastcall sub_1001EA50(int a1, signed int a2, int a3, int a4, char a5, char a6, unsigned int a7);
char __fastcall sub_1001EDD0(int a1, signed int a2, int a3, int a4, char a5, char a6, unsigned int a7);
char __fastcall sub_1001F160(int a1, int a2, int a3, char a4, char a5, signed int a6, unsigned int a7);
// void *__usercall sub_1001F400@<eax>(int a1@<ebx>, unsigned int a2);
// bool __usercall sub_1001F4A0@<al>(_DWORD *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, unsigned int a4@<esi>);
// char __usercall sub_1001F4D0@<al>(void *a1@<edx>, int a2@<esi>);
bool __cdecl sub_1001FC80(int a1, void *a2);
int __cdecl GetCompressedTextureDataSizeCrunch(struct TextureFile *a1);
int __cdecl GetCompressedTextureDataSize(int a1, int a2, int a3);
DWORD __stdcall StartAddress(LPVOID lpThreadParameter); // idb
// void __usercall sub_10020150(int a1@<eax>, int a2, int a3, int a4);
// void __usercall sub_10020290(int a1@<edx>, int a2, void *a3, int *a4, int a5);
bool __cdecl MakeTextureData(struct TextureFile *, void *, bool, int); // idb
char __cdecl GetTextureData(struct TextureFile *a1, void *a2);
int __thiscall sub_100216A0(int this);
// char __usercall sub_100216E0@<al>(unsigned int a1@<ecx>, int a2@<edi>, unsigned int a3@<esi>);
// char __usercall sub_10021740@<al>(unsigned int a1@<ecx>, int a2@<edi>, unsigned int a3@<esi>);
// char __usercall sub_100217A0@<al>(unsigned int a1@<ecx>, int a2@<edi>, unsigned int a3@<esi>);
__int16 __cdecl sub_10021800(float a1);
// int __usercall sub_10021860@<eax>(unsigned int a1@<eax>, _WORD *a2@<edx>, _WORD *a3@<ecx>, unsigned int a4@<edi>);
// char *__usercall sub_100218C0@<eax>(char *result@<eax>, int a2@<edx>, int a3@<edi>, int a4@<esi>);
// char *__usercall sub_100218F0@<eax>(signed int a1@<eax>, void *a2, int a3, int a4, int a5);
// char *__usercall sub_10022560@<eax>(int a1@<edx>, int a2@<ecx>, int a3, signed int a4);
// char *__usercall sub_100225A0@<eax>(int a1@<edx>, _BYTE *a2@<ecx>, void *a3, int a4);
// char *__usercall sub_10022820@<eax>(int a1@<edx>, _BYTE *a2@<ecx>, int a3, void *a4);
signed int __stdcall sub_10022E70(int a1, unsigned int a2, unsigned int a3);
// void __userpurge sub_10023A60(int a1@<esi>, int a2);
// signed int __userpurge sub_10023AE0@<eax>(int a1@<eax>, unsigned int a2@<edi>, unsigned int a3);
// signed int __usercall sub_10023B50@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3);
// int __usercall sub_10024130@<eax>(int a1@<eax>, int a2, void *a3, int a4, int a5);
// int __usercall sub_100243E0@<eax>(int a1@<eax>, void *a2, int a3, void *a4, int a5, int a6);
// int __usercall sub_100246F0@<eax>(int a1@<esi>);
signed int __fastcall sub_10024720(int a1, int a2);
// signed int __usercall sub_10024780@<eax>(int a1@<edx>, int a2@<edi>);
// signed int __usercall sub_10024810@<eax>(int a1@<edx>, int a2@<esi>);
// signed int __usercall sub_100248F0@<eax>(_DWORD *a1@<edx>, void *a2@<ecx>, int *a3@<ebx>, int a4, unsigned int *a5, int a6);
// int __usercall sub_100249F0@<eax>(int result@<eax>);
// _WORD *__usercall sub_10024B20@<eax>(_WORD *result@<eax>);
// signed int __usercall sub_10024B60@<eax>(const void *a1@<eax>, int a2@<ebx>);
// int __usercall sub_10024C60@<eax>(int a1@<esi>);
// int __usercall sub_10024D10@<eax>(int a1@<esi>);
// int __usercall sub_10024DE0@<eax>(int a1@<esi>, unsigned int a2, int a3);
// int __usercall sub_10024EC0@<eax>(unsigned int *a1@<eax>, _WORD *a2@<edi>, int a3);
// int __usercall sub_10024F20@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10024FA0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4);
// int __usercall sub_10025040@<eax>(int a1@<edi>);
// int __usercall sub_10025090@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>);
// int __usercall sub_100250D0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4);
// int __usercall sub_10025130@<eax>(int result@<eax>, int a2@<ecx>, int a3, unsigned int a4);
// int __usercall sub_100251C0@<eax>(int result@<eax>, int a2@<ecx>, int a3, unsigned int a4);
// int __usercall sub_10025240@<eax>(int a1@<eax>, _WORD *a2@<edx>, unsigned int *a3@<ecx>, unsigned int a4);
// unsigned int __usercall sub_10025390@<eax>(int a1@<esi>, int a2, int a3, unsigned int a4, int a5);
// int __usercall sub_10025510@<eax>(int result@<eax>, int a2@<edi>, unsigned int a3);
// int __usercall sub_10025570@<eax>(_DWORD *a1@<esi>, int *a2);
// int __usercall sub_10025610@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
// int __usercall sub_100256D0@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3);
// int __usercall sub_100257C0@<eax>(_DWORD *a1@<ecx>, _DWORD *a2@<ebx>, int a3);
signed int __cdecl sub_10026960(_DWORD *a1, unsigned int *a2);
// int __usercall sub_10026C60@<eax>(int a1@<eax>, int a2);
int __thiscall sub_10026DC0(int this);
// int __usercall sub_10026E10@<eax>(int a1@<edi>, int a2);
int __cdecl sub_10026EC0(int a1);
unsigned int __fastcall sub_10026F50(int a1, int a2);
// int __usercall sub_100271A0@<eax>(int a1@<eax>);
// int __usercall sub_100272A0@<eax>(int a1@<esi>);
// int __usercall sub_10027360@<eax>(_DWORD *a1@<eax>);
// signed int __usercall sub_10027B80@<eax>(int (__cdecl **a1)(_DWORD, _DWORD)@<eax>, int a2@<esi>, int (__cdecl **a3)(_DWORD, _DWORD));
int __fastcall sub_10027D10(int a1, int a2);
// signed int __usercall sub_10027F50@<eax>(int a1@<eax>, int (__cdecl **a2)(_DWORD, _DWORD), int (__cdecl **a3)(_DWORD, _DWORD));
size_t __cdecl sub_10028020(int a1, void *a2, size_t a3);
// int __usercall sub_10028060@<eax>(_DWORD *a1@<eax>);
// signed int __usercall sub_100280A0@<eax>(_DWORD *a1@<ecx>, int a2@<edi>, int a3@<esi>);
// signed int __usercall sub_10028140@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<edi>, int a4@<esi>, int a5);
// signed int __usercall sub_100281D0@<eax>(int a1@<ebx>, int a2@<esi>, int a3);
// int __cdecl unknown_libname_1(int); weak
int __cdecl sub_10028240(int a1);
// void __usercall sub_10028250(int a1@<ecx>, int a2@<esi>);
// void __usercall sub_100282F0(int a1@<eax>, int a2@<ecx>);
// unsigned int __usercall sub_10028340@<eax>(int a1@<eax>);
// signed int __usercall sub_10028410@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4, int a5, int a6);
unsigned int __cdecl sub_100285B0(int a1);
// unsigned int __usercall sub_10028630@<eax>(unsigned int a1@<ecx>, int a2@<esi>);
// int __usercall sub_100286F0@<eax>(_BYTE *a1@<ebx>, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, int a8, int a9, unsigned int a10);
int __cdecl sub_100287C0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, int a8, int a9, unsigned int a10);
_DWORD *__cdecl sub_10028900(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, int a8);
int __cdecl sub_10028A10(int a1, int a2);
signed int __cdecl sub_10028AB0(int a1, int a2);
int __cdecl sub_10028C30(int a1, int a2);
signed int __cdecl sub_10028E00(int a1, int a2);
unsigned int __cdecl sub_10028FD0(int a1, int a2);
unsigned int __cdecl sub_10029050(int a1, int a2);
unsigned int __cdecl sub_100290F0(int a1, int a2);
unsigned int __cdecl sub_100291B0(int a1, int a2);
// int __usercall sub_10029250@<eax>(int result@<eax>, int a2@<ecx>);
// void __usercall sub_100292C0(int a1@<esi>);
// void __usercall sub_10029370(int a1@<esi>);
// DWORD __usercall sub_10029400@<eax>(int a1@<eax>);
// signed int __usercall sub_10029500@<eax>(LONG a1@<edi>, int a2@<esi>, int a3, int a4);
int __cdecl sub_100295C0(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_10029610(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7);
void __cdecl sub_10029670(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7);
void __cdecl sub_100296E0(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7);
// void __usercall sub_10029740(int a1@<ebx>);
// _DWORD *__usercall sub_10029950@<eax>(int a1@<edi>, int a2);
// void __usercall sub_10029B90(char a1@<al>, int a2@<ecx>);
int __stdcall sub_10029C30(int a1);
int __stdcall sub_10029C50(int a1);
// signed int __usercall sub_10029D10@<eax>(int (__cdecl **a1)(_DWORD, _DWORD)@<eax>, int a2@<ecx>, int a3@<ebx>, unsigned int a4, int a5);
int __cdecl sub_10029DF0(int a1);
// unsigned int __usercall sub_10029E90@<eax>(int a1@<edi>);
int __cdecl sub_10029F00(int a1);
int __cdecl sub_10029F20(int a1, unsigned int a2, int a3);
int __cdecl sub_10029F80(int a1, unsigned int a2, int a3);
int __cdecl sub_1002A040(int a1, int a2);
int __cdecl sub_1002A090(int a1, int a2);
int __cdecl sub_1002A130(int a1, int a2);
int __cdecl sub_1002A1E0(int a1, int a2);
int __cdecl sub_1002A2C0(int a1, int a2);
// int __usercall sub_1002A3B0@<eax>(int result@<eax>, int a2@<ecx>);
// DWORD __usercall sub_1002A440@<eax>(int a1@<edx>, int a2@<ecx>, int *a3);
DWORD __cdecl sub_1002A480(_DWORD *a1);
// DWORD __usercall sub_1002A4B0@<eax>(LONG lInitialCount@<ecx>, LONG a2@<eax>, int a3);
int __cdecl sub_1002A4E0(LPCRITICAL_SECTION lpCriticalSection); // idb
// int __usercall sub_1002A570@<eax>(int a1@<edx>, int a2@<ecx>, int a3, __int16 a4);
int __cdecl sub_1002A7A0(int a1, int a2);
// int __usercall sub_1002A820@<eax>(int a1@<edx>, int a2, int a3, int a4, __int16 a5);
// int __usercall sub_1002A950@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, __int16 a5);
// int __usercall sub_1002AB10@<eax>(int a1@<edi>, int a2@<esi>);
// int __userpurge sub_1002ABF0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3);
void __thiscall sub_1002B1D0(int this, int a2);
void __thiscall sub_1002B520(int this, int a2);
// int __usercall sub_1002B9A0@<eax>(int a1@<eax>, int a2, int a3);
// int __usercall sub_1002BA70@<eax>(int result@<eax>, int a2@<esi>);
// int __usercall sub_1002BB70@<eax>(int a1@<edi>, int a2, int a3, int a4);
// int __usercall sub_1002BC90@<eax>(int a1@<eax>, char a2, char a3, int a4);
int __cdecl sub_1002BD20(int a1, int a2, int a3);
int __cdecl sub_1002BE20(int a1, int a2, int a3);
int __cdecl sub_1002BF20(int a1, int a2);
int __cdecl sub_1002C2B0(int a1);
// int __usercall sub_1002C4E0@<eax>(int a1@<ebx>);
// char __usercall sub_1002C590@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4);
// char __usercall sub_1002C6B0@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4);
int __cdecl sub_1002C7D0(int a1, char a2);
// int __usercall sub_1002CAA0@<eax>(int a1@<eax>, int a2@<edi>, int a3@<esi>);
int __thiscall sub_1002CB60(_DWORD *this, int a2);
int __thiscall sub_1002CBF0(_DWORD *this, int a2);
// int __usercall sub_1002CC80@<eax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_1002CDC0@<eax>(int a1@<edi>, int a2@<esi>);
// int __userpurge sub_1002CEE0@<eax>(signed int *a1@<ecx>, int a2@<esi>, int a3);
void *__thiscall sub_1002CFD0(void *this, char a2);
char __fastcall sub_1002D000(int a1, int a2, int a3);
void __thiscall sub_1002D6A0(int this, int a2);
void __thiscall sub_1002F380(int this, int a2);
// int __userpurge sub_10031480@<eax>(unsigned int a1@<eax>, int a2@<edx>, int a3@<esi>, int a4);
int __cdecl sub_10031690(signed int a1, int a2, int a3);
// int __usercall sub_10031CC0@<eax>(int a1@<eax>, int a2);
// bool __usercall sub_100320A0@<al>(int a1@<eax>);
// signed int __usercall sub_100321D0@<eax>(signed int a1@<eax>);
unsigned __int32 AssetFile::GetFileDataIndex();
char __thiscall sub_100322D0(int this);
char sub_100322E0();
void *__thiscall sub_100322F0(int this, char a2);
// int __usercall sub_10032380@<eax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_100323E0@<eax>(int a1@<eax>);
void __thiscall sub_100323F0(int this);
// char __usercall sub_100324C0@<al>(int a1@<esi>);
char __thiscall sub_10032550(int this);
int __thiscall sub_100325C0(int this);
int __thiscall sub_100325D0(int this, void *a2, size_t a3);
size_t __thiscall sub_10032620(int this, void *a2, size_t a3);
char __thiscall sub_10032680(int this);
__int64 __thiscall sub_10032690(int this);
__int64 __thiscall sub_100326B0(int this);
__int64 __thiscall sub_100326D0(int this);
char __thiscall sub_100326F0(int this, __int64 a2, char a3);
void *__thiscall sub_10032760(void *this, char a2);
int __stdcall sub_10032780(int a1);
void __stdcall sub_10032890(int a1);
void __stdcall sub_100328F0(int a1);
void __stdcall sub_10032BC0(int a1);
void __stdcall sub_10032D20(int a1);
// int __usercall sub_10032EC0@<eax>(int result@<eax>, int a2@<ebx>);
void __thiscall sub_10032F10(int this, unsigned int a2);
// void *__usercall sub_10033010@<eax>(int a1@<edi>, unsigned int a2@<esi>);
// void __usercall sub_10033060(int a1@<esi>);
// int __usercall sub_100330F0@<eax>(int result@<eax>, int a2@<ecx>);
PSINGLE_LIST_ENTRY __stdcall sub_10033100(PSLIST_HEADER ListHead);
// char __usercall sub_100331D0@<al>(int a1@<edi>, int a2@<esi>);
// PSINGLE_LIST_ENTRY __usercall sub_10033230@<eax>(PSINGLE_LIST_ENTRY result@<eax>);
// int __usercall sub_10033300@<eax>(int a1@<esi>);
// signed int __userpurge sub_10033380@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>, int a4);
// int __usercall sub_100333F0@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_10033490@<eax>(int result@<eax>, int a2@<ecx>);
int __cdecl sub_100334F0(int a1, int a2);
void __thiscall sub_100336C0(void *); // idb
int __thiscall sub_100336F0(int this);
// void __usercall sub_10033720(int a1@<edi>, unsigned int a2@<esi>);
// void __usercall sub_100337A0(void (__thiscall ***a1)(_DWORD, _DWORD)@<ebx>);
int sub_100337E0();
// char __usercall sub_10033810@<al>(signed int a1@<eax>);
// bool __usercall sub_10033870@<al>(int a1@<eax>);
// signed int __usercall sub_10033890@<eax>(signed int a1@<eax>);
// signed int __usercall sub_10033900@<eax>(signed int a1@<eax>);
// int __userpurge sub_100339C0@<eax>(int result@<eax>, int a2@<ecx>, int a3, char a4);
int __thiscall sub_100339F0(int this);
// int __userpurge sub_10033A50@<eax>(int result@<eax>, int a2@<ecx>, int a3, char a4);
int __thiscall sub_10033A80(void *this, int a2);
void __stdcall sub_10033BD0(int a1);
// int __userpurge sub_10033C70@<eax>(int a1@<ebx>, int a2);
// unsigned int __usercall sub_10033D30@<eax>(int a1@<esi>);
void __thiscall sub_10033E00(int this);
void __thiscall sub_10033EE0(int this);
// char __userpurge sub_10033F70@<al>(char *a1@<eax>, int a2@<esi>, void *a3, int a4, int a5, int a6);
// char __userpurge sub_10034090@<al>(int a1@<ebx>, unsigned int a2, unsigned int a3, int a4);
// void __usercall sub_10034290(int a1@<esi>);
// int __usercall sub_100342E0@<eax>(int result@<eax>, int a2@<edi>);
// char __usercall sub_10034340@<al>(int a1@<edi>, unsigned int a2@<esi>);
// void *__userpurge sub_10034380@<eax>(int a1@<esi>, void *a2, int a3);
int __cdecl sub_100343F0(int a1);
// void __usercall sub_10034460(int a1@<ebx>);
// void __usercall sub_100344C0(int *a1@<ebx>);
int sub_10034520();
int __cdecl sub_10034570(int *a1, int *a2);
int __stdcall sub_100345E0(int a1, int a2, int a3, int a4);
// int __usercall sub_10034680@<eax>(int a1@<ecx>, int a2@<edi>);
int __stdcall sub_100346C0(int a1, unsigned int a2);
unsigned __int8 *__fastcall sub_10034890(int a1, int a2, unsigned int a3);
// unsigned int __userpurge sub_100349A0@<eax>(int a1@<esi>, unsigned int a2);
// int __userpurge sub_10034B30@<eax>(int result@<eax>, unsigned int a2);
// unsigned int __userpurge sub_10034C20@<eax>(int a1@<edi>, unsigned int a2);
// unsigned int __userpurge sub_10034D70@<eax>(int a1@<edi>, unsigned int a2);
int __stdcall sub_10034EC0(int a1, int a2);
int __stdcall sub_10034F80(int a1, int a2);
// int __userpurge sub_10035010@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, char a4);
// int __usercall sub_10035120@<eax>(int a1@<ecx>, int a2@<esi>, float a3, float a4);
// int __userpurge sub_100352F0@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<ebx>, _DWORD *a4);
// int __usercall sub_100353E0@<eax>(int result@<eax>, int a2@<edi>);
void __thiscall sub_10035440(int this);
void __thiscall sub_10035540(int this);
void __thiscall sub_10035640(int this, unsigned int a2);
void __thiscall sub_10035740(int this);
// int __userpurge sub_10035840@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<ebx>, _BYTE *a4);
// void __usercall sub_10035930(int a1@<edi>, unsigned int a2@<esi>);
// unsigned int __usercall sub_100359B0@<eax>(int *a1@<eax>, int a2@<edx>);
// char __userpurge sub_10035A10@<al>(int a1@<edi>, int a2@<esi>, int *a3, _DWORD *a4);
// int __usercall sub_10035AD0@<eax>(int result@<eax>, int a2@<edi>);
// int __usercall sub_10035B30@<eax>(int result@<eax>, int a2@<edi>);
// char __userpurge sub_10035B90@<al>(int a1@<edi>, int a2@<esi>, int *a3, _BYTE *a4);
void __fastcall sub_10035C50(unsigned int a1, int a2, int a3);
int sub_10035DA0(); // weak
// unsigned int __usercall sub_10035ED0@<eax>(int a1@<edi>, unsigned int a2@<esi>);
// unsigned int __usercall sub_10035F30@<eax>(int a1@<edx>, int a2@<edi>);
int sub_10035F90(); // weak
// signed int __usercall sub_10035FE0@<eax>(int a1@<eax>, int a2@<edx>, int a3, float *a4);
// int __usercall sub_10036230@<eax>(int result@<eax>, int a2@<ecx>);
void *sub_10036280();
void __thiscall sub_10036310(int this, unsigned int a2);
// int __usercall sub_10036410@<eax>(int result@<eax>, int a2@<ebx>);
// int __usercall sub_10036480@<eax>(int a1@<eax>, int a2@<esi>);
// int __usercall sub_10036540@<eax>(int a1@<eax>, int a2@<esi>);
int __fastcall sub_100365F0(int a1, int a2, float a3, float a4);
// void *__usercall sub_100366C0@<eax>(int a1@<edi>, unsigned int a2@<esi>);
// char __usercall sub_10036710@<al>(int a1@<edi>, unsigned int a2@<esi>);
int __cdecl sub_10036770(int *a1, int *a2, int *a3, int *a4, int *a5, float *a6, float *a7, int *a8, int *a9, int *a10, float *a11, float *a12);
unsigned int __thiscall sub_10036820(int this);
// int __usercall sub_10036840@<eax>(int result@<eax>);
void *__thiscall sub_100368C0(void *this, char a2);
const char *sub_100368E0();
int __thiscall sub_100368F0(char *this);
void *__thiscall sub_10036900(void *this, char a2);
// int unknown_libname_2(); weak
void __stdcall sub_10036930(int a1);
// int __usercall sub_10036A10@<eax>(unsigned int a1@<edi>, int a2@<esi>);
void __thiscall sub_10036A70(int this, unsigned int a2);
// char *__usercall sub_10036B80@<eax>(int a1@<edi>, unsigned int a2@<esi>);
// unsigned int __usercall sub_10036BD0@<eax>(int a1@<edi>, unsigned int a2@<esi>);
// unsigned int __usercall sub_10036C30@<eax>(int a1@<edi>, unsigned int a2@<esi>);
// int __usercall sub_10036C90@<eax>(int result@<eax>, int a2@<ebx>);
// char *__usercall sub_10036CF0@<eax>(void *a1@<ecx>, int a2@<eax>);
void *sub_10036D30();
int __thiscall sub_10036D40(char *this);
void *__thiscall sub_10036D50(void *this, char a2);
// unsigned int __usercall sub_10036D80@<eax>(int a1@<ebx>, int a2@<esi>);
void __stdcall sub_10036E20(int a1);
void __thiscall sub_10036FD0(void *); // idb
// bool __usercall sub_10037150@<al>(int a1@<eax>, int a2@<edx>);
void __thiscall sub_100371F0(void *); // idb
// void __usercall sub_10037230(int a1@<esi>);
// void __userpurge sub_10037280(int a1@<edi>, unsigned int a2@<esi>, char a3);
// void __usercall sub_10037300(int a1@<esi>);
// char __userpurge sub_100373C0@<al>(int a1@<eax>, int a2, int a3);
void __thiscall sub_10037AF0(void *this, int a2, signed int a3);
// unsigned int __usercall sub_10037D10@<eax>(int a1@<edi>, unsigned int a2@<esi>);
// void __usercall sub_10037D80(int *a1@<eax>);
// void __usercall sub_10037DB0(int a1@<eax>);
bool __stdcall sub_10037E90(int a1, int a2, unsigned int a3, int a4, int a5, int a6);
void __stdcall sub_100388E0(int a1);
// int __usercall sub_10038970@<eax>(int a1@<edi>);
// int __userpurge sub_10038A20@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, _DWORD *a4);
void __thiscall sub_10038B00(int this, unsigned int a2);
void __thiscall sub_10038C00(void *); // idb
// int __usercall sub_10038C30@<eax>(int result@<eax>, int a2@<ecx>);
void __thiscall sub_10038C90(void *); // idb
// void __userpurge sub_10038CE0(int a1@<esi>, unsigned int a2);
void __thiscall sub_10038DF0(int this);
// void __userpurge sub_10038EA0(int a1@<eax>, int a2);
void __thiscall sub_10039830(int this, unsigned int a2);
// void __usercall sub_10039940(int a1@<esi>);
// void __usercall sub_10039990(int a1@<esi>);
int __cdecl sub_10039AA0(int, int); // weak
void __thiscall sub_10039AE0(int this, int a2, int a3, int a4);
int __thiscall sub_10039C90(int this);
// void __usercall sub_10039CE0(int a1@<esi>);
// char __userpurge sub_10039DA0@<al>(int a1@<ebx>, unsigned int a2, int (__cdecl *a3)(unsigned int, int), int a4);
void __thiscall sub_1003A360(void *this, int a2, signed int a3);
// void __userpurge sub_1003A580(int a1@<esi>, unsigned int a2);
// unsigned int __userpurge sub_1003A680@<eax>(int a1@<ebx>, int a2);
// char __userpurge sub_1003A730@<al>(int a1@<eax>, int a2, int a3, _DWORD *a4);
int __stdcall sub_1003A860(int a1, int a2);
// void __userpurge sub_1003A940(int a1@<ebx>, int a2);
// int __userpurge sub_1003A9D0@<eax>(int a1@<esi>, int *a2, int a3, int a4);
int __stdcall sub_1003AC90(int *a1, int a2, int a3, int a4);
// int __usercall sub_1003B760@<eax>(int result@<eax>, int a2@<ebx>);
int __cdecl sub_1003B7E0(int a1, int a2, int a3);
int __stdcall sub_1003B850(int a1, int a2);
// void __usercall sub_1003B900(int a1@<edi>, unsigned int a2@<esi>);
int __thiscall sub_1003B960(int this, void *a2, int a3, int a4);
// void *__userpurge sub_1003C100@<eax>(int a1@<ebx>, int a2@<edi>, float *a3, int a4, _DWORD *a5, int a6);
int sub_1003C200(); // weak
void __thiscall sub_1003C210(int this);
// void __usercall sub_1003C2C0(int a1@<eax>, int a2@<ecx>);
int __stdcall sub_1003C840(int a1, int a2);
// void __usercall sub_1003C8F0(int a1@<esi>);
// void __usercall sub_1003C940(int a1@<esi>);
// void __userpurge sub_1003C990(int a1@<esi>, unsigned int a2);
// int __usercall sub_1003CAA0@<eax>(_DWORD *a1@<ebx>, int a2@<edi>, int a3@<esi>);
void __fastcall sub_1003CB20(unsigned int a1, int a2, int a3);
// double __usercall sub_1003CC80@<st0>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_1003CD10@<eax>(int result@<eax>, int a2@<ecx>);
// int __userpurge sub_1003CD80@<eax>(int result@<eax>, float a2);
// int __usercall sub_1003CDE0@<eax>(int result@<eax>, int a2@<ecx>, float a3);
int sub_1003CE50(); // weak
// void __userpurge sub_1003CF70(int a1@<ebx>, int a2);
int __stdcall sub_1003D000(int *a1, int a2, int a3, int a4);
int __stdcall sub_1003D200(int *a1, int a2, int a3, int a4);
int __stdcall sub_1003DAF0(int a1, int a2);
// void __usercall sub_1003DBA0(int a1@<edi>, unsigned int a2@<esi>);
// unsigned int __usercall sub_1003DC00@<eax>(int a1@<edx>, int a2@<esi>);
// void __usercall sub_1003DC70(int a1@<edi>, unsigned int a2@<esi>);
// double __usercall sub_1003DCF0@<st0>(int a1@<esi>);
int __cdecl sub_1003DD80(int a1, int a2, int a3);
// int __usercall sub_1003DDC0@<eax>(int result@<eax>, int a2@<ecx>);
// double __usercall sub_1003DE10@<st0>(float *a1@<eax>, float *a2@<edx>);
// int __usercall sub_1003DE90@<eax>(int a1@<eax>, int a2, int a3);
// double __usercall sub_1003DF20@<st0>(float *a1@<eax>);
// double __usercall sub_1003DF90@<st0>(int a1@<eax>, int a2@<edx>);
// double __usercall sub_1003E090@<st0>(float *a1@<esi>);
// int __usercall sub_1003E110@<eax>(int a1@<edi>, int a2@<esi>);
int sub_1003E1A0(); // weak
// int __usercall sub_1003E2C0@<eax>(int a1@<eax>, int a2, int a3);
// int __usercall sub_1003E350@<eax>(int a1@<edi>, int a2@<esi>);
void __cdecl sub_1003E3D0(int a1, int a2, int a3);
// void __usercall sub_1003E4E0(int a1@<eax>, int *a2@<ecx>);
// void __usercall sub_1003E530(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_1003E580@<eax>(int a1@<eax>, int a2@<ecx>);
void __cdecl sub_1003E5E0(char *a1, unsigned int *a2, signed int a3);
int __cdecl sub_1003E6B0(int a1, char *a2, unsigned int a3);
// int __usercall sub_1003E7F0@<eax>(char *a1@<ecx>, int *a2@<esi>, char *a3);
// int __usercall sub_1003E910@<eax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_1003E9B0@<eax>(int a1@<eax>, int a2@<ecx>, char *a3@<esi>);
// void __usercall sub_1003EA00(signed int a1@<ebx>, unsigned int *a2);
// int __usercall sub_1003EA70@<eax>(int a1@<edx>, int a2@<ecx>, int *a3@<ebx>, int a4);
void __stdcall sub_1003EAE0(int a1);
// void __usercall sub_1003EC70(int a1@<esi>);
// char __userpurge sub_1003ED30@<al>(int a1@<eax>, int a2, int a3);
void __thiscall sub_1003F290(void *this, int a2, signed int a3);
// unsigned int __usercall sub_1003F4C0@<eax>(int a1@<edi>, unsigned int a2@<esi>);
void __stdcall sub_1003F520(int a1);
// int __userpurge sub_1003F5E0@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3@<ebx>, _BYTE *a4);
// int unknown_libname_3(); weak
void __thiscall sub_1003F710(int this);
// void __userpurge sub_1003F7D0(int a1@<eax>, int a2);
void __thiscall sub_1003FE70(int this, unsigned int a2);
// void __usercall sub_1003FF80(int a1@<esi>);
// void __usercall sub_1003FFD0(int a1@<esi>);
// char __userpurge sub_100400E0@<al>(_DWORD *a1@<eax>, int a2@<edi>, int a3@<esi>, _BYTE *a4);
// void __userpurge sub_100401C0(int a1@<ebx>, int a2);
int __fastcall sub_10040260(int a1, int a2, int *a3, int a4, int a5);
int __stdcall sub_10040410(int *a1, int a2, int a3, int a4);
// int __usercall sub_100409D0@<eax>(int result@<eax>, int a2@<ebx>);
int sub_10040A40(); // weak
int __stdcall sub_10040A90(int a1, int a2);
// void __usercall sub_10040B40(int a1@<edi>, unsigned int a2@<esi>);
void __fastcall sub_10040BA0(unsigned int a1, int a2, int a3);
int sub_10040D00(); // weak
// unsigned int __usercall sub_10040E20@<eax>(int a1@<edx>, int a2@<esi>);
// unsigned int __usercall sub_10040E90@<eax>(int a1@<edi>, unsigned int a2@<esi>);
// int __usercall sub_10040EF0@<eax>(int a1@<edi>, int a2@<esi>);
int sub_10040F70(); // weak
// void __usercall sub_10040FD0(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_10041020@<eax>(int result@<eax>, int a2@<ecx>);
void __thiscall sub_10041070(void *this, int a2, int a3, int a4);
int __thiscall sub_100410C0(int this);
void *__thiscall sub_10041130(void *this, char a2);
// int __usercall sub_10041150@<eax>(_BYTE *a1@<edi>, int a2@<esi>);
// char __usercall sub_100411B0@<al>(int a1@<eax>);
// int __usercall sub_10041230@<eax>(int result@<eax>, int a2@<esi>);
// int __usercall sub_10041300@<eax>(int a1@<eax>, int a2@<edx>);
int __thiscall sub_10041360(int this, char a2);
// char __usercall sub_100413B0@<al>(int a1@<edi>, unsigned int a2@<esi>);
char __stdcall sub_100413F0(int a1, int a2, int a3, int a4, int a5);
void __stdcall sub_10041440(int a1);
void __stdcall sub_10041510(int a1);
void __stdcall sub_100415E0(int a1);
void __stdcall sub_10041640(int a1);
void __stdcall sub_100416A0(int a1);
void __stdcall sub_10041700(int a1);
void __stdcall sub_100417D0(int a1);
void __stdcall sub_100418A0(int a1);
void __stdcall sub_10041900(int a1);
void __stdcall sub_10041960(int a1);
void __stdcall sub_10041A30(int a1);
// void *__userpurge sub_10041A90@<eax>(unsigned int a1@<ebx>, int a2);
// void *__userpurge sub_10041B10@<eax>(unsigned int a1@<ebx>, int a2);
// void __usercall sub_10041BD0(int a1@<esi>);
int __stdcall sub_10041C10(int a1);
char __stdcall sub_10041CA0(int a1, unsigned int a2);
// int __userpurge sub_10042140@<eax>(int a1@<esi>, int a2);
// int __usercall sub_10042350@<eax>(int a1@<ebx>);
// int __userpurge sub_10042410@<eax>(int a1@<eax>, int a2@<ecx>, unsigned int a3);
// char __userpurge sub_100424D0@<al>(int a1@<eax>, int a2, unsigned int a3);
// unsigned int __userpurge sub_10042BA0@<eax>(int a1@<eax>, int a2);
// int __usercall sub_10042C60@<eax>(int a1@<ebx>);
char __stdcall sub_10042D20(int a1);
// int __usercall sub_10043260@<eax>(int a1@<ebx>);
char __stdcall sub_10043320(int a1);
// int __usercall sub_10043810@<eax>(int a1@<ebx>);
char __stdcall sub_100438D0(int a1, unsigned int a2);
void __stdcall sub_10043E90(int a1, int a2);
// void __userpurge sub_10044D10(int a1@<esi>, unsigned int a2);
// char __userpurge sub_10044E20@<al>(int a1@<ebx>, int a2);
void __stdcall sub_10044ED0(int a1, int a2);
// void __userpurge sub_10046720(int a1@<esi>, unsigned int a2);
void __stdcall sub_10046830(int a1, int a2);
// void __usercall sub_10047BC0(int a1@<esi>);
// void __usercall sub_10047C10(int a1@<esi>);
// int __userpurge sub_10047D20@<eax>(int a1@<ebx>, int a2);
void __stdcall sub_10047DD0(int a1, int a2);
// void __usercall sub_10048910(int a1@<esi>);
// char __usercall sub_10048A20@<al>(int a1@<eax>, float *a2@<ecx>);
void __stdcall sub_10048A60(int a1, int a2);
// void __userpurge sub_10049CF0(int a1@<esi>, unsigned int a2);
// char __userpurge sub_10049E00@<al>(int a1@<ebx>, int a2);
void __thiscall sub_10049EA0(int this, unsigned int a2);
void __thiscall sub_10049FB0(int this, unsigned int a2);
int sub_1004A0C0(); // weak
int sub_1004A100(); // weak
int sub_1004A140(); // weak
// int *__userpurge sub_1004A2C0@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<esi>, _DWORD *a4, _DWORD *a5);
int __stdcall sub_1004A370(int a1, int a2);
// void __usercall sub_1004A470(int a1@<edi>, unsigned int a2@<esi>);
// int *__userpurge sub_1004A4D0@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<esi>, _DWORD *a4, _DWORD *a5);
int __stdcall sub_1004A580(int a1, int a2);
// void __usercall sub_1004A630(int a1@<edi>, unsigned int a2@<esi>);
// int *__userpurge sub_1004A690@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<esi>, _DWORD *a4, _DWORD *a5);
int __stdcall sub_1004A740(int a1, int a2);
// int __usercall sub_1004A840@<eax>(int a1@<edi>, unsigned int a2@<esi>);
// int *__userpurge sub_1004A8B0@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<esi>, _DWORD *a4, _DWORD *a5);
int __stdcall sub_1004A960(int a1, int a2);
// void __usercall sub_1004AA50(int a1@<edi>, unsigned int a2@<esi>);
int __cdecl sub_1004AAB0(int a1, int a2, int a3);
// int *__userpurge sub_1004AAF0@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<esi>, _DWORD *a4, _DWORD *a5);
int __stdcall sub_1004ABA0(int a1, int a2);
// void __usercall sub_1004ACA0(int a1@<edi>, unsigned int a2@<esi>);
// int __usercall sub_1004AD00@<eax>(int result@<eax>);
// int __usercall sub_1004AD50@<eax>(int result@<eax>);
// int __usercall sub_1004ADA0@<eax>(int result@<eax>);
// int __usercall sub_1004ADF0@<eax>(int result@<eax>, int a2@<edi>);
// int __usercall sub_1004AE90@<eax>(int result@<eax>);
// int __usercall sub_1004AEE0@<eax>(int result@<eax>, int a2@<edi>);
// int __usercall sub_1004AF70@<eax>(int result@<eax>);
// int __userpurge sub_1004AFC0@<eax>(int result@<eax>, float a2);
int *__stdcall sub_1004B030(int a1, int *a2, int a3);
// int __usercall sub_1004B2B0@<eax>(int a1@<edi>);
int sub_1004B300(); // weak
int *__stdcall sub_1004B470(int a1, int *a2, int a3);
// int __usercall sub_1004B6F0@<eax>(int a1@<edi>);
int sub_1004B740(); // weak
int *__stdcall sub_1004B8C0(int a1, int *a2, int a3);
// int __usercall sub_1004BB40@<eax>(int a1@<edi>);
int sub_1004BB90(); // weak
int *__stdcall sub_1004BD00(int a1, int *a2, int a3);
// int __usercall sub_1004BF80@<eax>(int a1@<edi>);
int sub_1004BFD0(); // weak
int *__stdcall sub_1004C160(int a1, int *a2, int a3);
// int __usercall sub_1004C3E0@<eax>(int a1@<edi>);
int sub_1004C430(); // weak
int sub_1004C600(); // weak
int sub_1004C650(); // weak
// int __usercall sub_1004C690@<eax>(int a1@<ebx>, int a2@<edi>);
void __stdcall sub_1004C6F0(void *a1);
int __thiscall sub_1004C730(int this, int a2);
int __thiscall sub_1004C780(_DWORD *this, int a2);
// int __usercall sub_1004C7D0@<eax>(int result@<eax>);
void __stdcall sub_1004C7F0(void *a1);
int __thiscall sub_1004C830(int this, int a2);
int __thiscall sub_1004C880(_DWORD *this, int a2);
// int __usercall sub_1004C8D0@<eax>(int result@<eax>);
void __stdcall sub_1004C8F0(void *a1);
int __thiscall sub_1004C930(int this, int a2);
int __thiscall sub_1004C980(_DWORD *this, int a2);
// int __usercall sub_1004C9D0@<eax>(int result@<eax>);
void __stdcall sub_1004C9F0(void *a1);
int __thiscall sub_1004CA30(int this, int a2);
int __thiscall sub_1004CA80(_DWORD *this, int a2);
// int __usercall sub_1004CAD0@<eax>(int result@<eax>);
void __stdcall sub_1004CAF0(void *a1);
int __thiscall sub_1004CB30(int this, int a2);
int __thiscall sub_1004CB80(_DWORD *this, int a2);
// int __usercall sub_1004CBD0@<eax>(int result@<eax>);
// int __usercall sub_1004CBF0@<eax>(int a1@<eax>, int a2@<esi>);
// int __usercall sub_1004CC60@<eax>(int a1@<eax>, int a2@<esi>);
// int __usercall sub_1004CCE0@<eax>(int a1@<eax>, int a2@<esi>);
// int __usercall sub_1004CD50@<eax>(int a1@<eax>, int a2@<esi>);
// int __usercall sub_1004CDB0@<eax>(int a1@<eax>, int a2@<esi>);
// int __usercall sub_1004CE10@<eax>(int result@<eax>, int a2@<ecx>);
// void __usercall sub_1004CE50(int a1@<eax>, int *a2@<ecx>);
// void __usercall sub_1004CEA0(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_1004CEF0@<eax>(int result@<eax>, int a2@<ecx>);
// void __usercall sub_1004CF40(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_1004CF90@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_1004CFF0@<eax>(int result@<eax>, int a2@<ecx>);
// char *__usercall sub_1004D040@<eax>(int a1@<eax>, char *a2@<ecx>);
// void *__usercall sub_1004D0A0@<eax>(unsigned int a1@<eax>);
// int __userpurge sub_1004D100@<eax>(int a1@<ebx>, int a2, int a3);
// int __userpurge sub_1004D220@<eax>(int a1@<ebx>, int a2, int a3);
// int __userpurge sub_1004D340@<eax>(int a1@<ebx>, int a2, int a3);
// int __userpurge sub_1004D460@<eax>(int a1@<ebx>, int a2, int a3);
// int __userpurge sub_1004D580@<eax>(int a1@<ebx>, int a2, int a3);
// _DWORD *__userpurge sub_1004D6A0@<eax>(int a1@<eax>, int a2@<edi>, _DWORD *a3, char a4, int a5);
// _DWORD *__userpurge sub_1004D870@<eax>(int a1@<eax>, int a2@<edi>, _DWORD *a3, char a4, int a5);
// _DWORD *__userpurge sub_1004DA40@<eax>(int a1@<eax>, int a2@<edi>, _DWORD *a3, char a4, int a5);
// _DWORD *__userpurge sub_1004DC10@<eax>(int a1@<eax>, int a2@<edi>, _DWORD *a3, char a4, int a5);
// _DWORD *__userpurge sub_1004DDE0@<eax>(int a1@<eax>, int a2@<edi>, _DWORD *a3, char a4, int a5);
// char __usercall sub_1004DFB0@<al>(int a1@<eax>, float *a2@<ecx>);
// char __usercall sub_1004DFF0@<al>(int a1@<eax>, float *a2@<ecx>);
// char __usercall sub_1004E030@<al>(int a1@<eax>, float *a2@<ecx>);
// char __usercall sub_1004E070@<al>(int a1@<eax>, float *a2@<ecx>);
// int __usercall sub_1004E0B0@<eax>(int result@<eax>);
// int __usercall sub_1004E110@<eax>(int result@<eax>);
// int __usercall sub_1004E170@<eax>(int result@<eax>);
// int __usercall sub_1004E1D0@<eax>(int result@<eax>);
// int __usercall sub_1004E230@<eax>(int result@<eax>);
// _DWORD *__usercall sub_1004E290@<eax>(int a1@<edi>, int a2@<esi>);
// _DWORD *__usercall sub_1004E2D0@<eax>(int a1@<edi>, int a2@<esi>);
// _DWORD *__usercall sub_1004E360@<eax>(int a1@<edi>, int a2@<esi>);
// _DWORD *__usercall sub_1004E3E0@<eax>(int a1@<edi>, int a2@<esi>);
// _DWORD *__usercall sub_1004E450@<eax>(int a1@<eax>, int a2@<ebx>);
// void __usercall sub_1004E4D0(int a1@<esi>);
void *sub_1004E560();
// void __usercall sub_1004E5C0(int a1@<ebx>);
int sub_1004E600();
void __stdcall sub_1004E640(int a1);
// void __usercall sub_1004E710(int a1@<eax>, int a2@<edi>);
// int __userpurge sub_1004E7B0@<eax>(int a1@<esi>, unsigned int a2);
// void __usercall sub_1004E880(int a1@<eax>, int a2@<ecx>);
// char __userpurge sub_1004E8B0@<al>(int a1@<edi>, int a2);
// int __userpurge sub_1004E980@<eax>(int a1@<edx>, int a2@<edi>, float a3, float a4, float a5, float a6, float a7, float a8);
int __cdecl sub_1004EBE0(unsigned int *a1, int *a2, signed int a3);
int __cdecl sub_1004ECB0(int a1);
int __cdecl sub_1004EDA0(int a1, unsigned int a2, int *a3);
// int __usercall sub_1004F220@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1004F2B0@<eax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_1004F3B0@<eax>(int a1@<eax>, int a2@<ecx>, char *a3@<esi>);
int __cdecl sub_1004F400(unsigned int *a1, unsigned int *a2);
// int __usercall sub_1004F520@<eax>(int a1@<edi>, int a2, int a3);
// int __usercall sub_1004F630@<eax>(int a1@<eax>, int a2, int a3, int a4);
// int __usercall sub_1004F6F0@<eax>(int a1@<ebx>, int a2, int a3, int a4);
// int __cdecl unknown_libname_4(_DWORD); weak
// int __stdcall `eh vector constructor iterator'(void *, unsigned int, int, int, void (__thiscall *)(void *)); idb
// int __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *)); idb
int sub_1004FE84();
// int __cdecl atexit(void (__cdecl *)());
int (*sub_1004FF48())(void);
// int __cdecl _clean_type_info_names_internal(_DWORD); weak
FARPROC __stdcall sub_100502BE(DWORD a1, DWORD Arguments);
int __cdecl sub_10050500(LPCRITICAL_SECTION lpCriticalSection); // idb
// DWORD __usercall sub_10050690@<eax>(LONG lInitialCount@<ecx>, LONG a2@<eax>, int a3);
// DWORD __usercall sub_10050790@<eax>(int a1@<edx>, int a2@<ecx>, int *a3);
DWORD __cdecl sub_10050860(_DWORD *a1);
int __cdecl sub_10050890(int a1, int a2);
int sub_10050930(); // weak
int sub_10050980(); // weak
int sub_10050A40(); // weak
int sub_10050AA0(); // weak
int sub_10050AB0(); // weak
int sub_10050AE0(); // weak
int sub_10050B40(); // weak
int sub_10050BA0(); // weak
int __cdecl sub_10050C00(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10050D10(int a1);
// void __usercall sub_10050DB0(int a1@<ebx>);
// signed int __usercall sub_10050FA0@<eax>(LONG a1@<edi>, int a2@<esi>, int a3, int a4);
// void __usercall sub_10051050(int a1@<esi>);
// void __usercall sub_100510E0(int a1@<esi>);
// unsigned int __usercall sub_10051190@<eax>(int a1@<edi>);
int __stdcall sub_10051210(int a1);
// DWORD __usercall sub_10051270@<eax>(int a1@<eax>);
int __cdecl sub_10051360(int a1, int a2);
int __cdecl sub_10051450(int a1, int a2);
int __cdecl sub_10051530(int a1, int a2);
int sub_100515E0(); // weak
// unsigned int __usercall sub_10051640@<eax>(int a1@<edi>, unsigned int a2);
// int __usercall sub_100518B0@<eax>(int result@<eax>, int a2@<ecx>);
// void __usercall sub_10051950(char a1@<al>, int a2@<ecx>);
int __stdcall sub_10051A80(int a1);
// signed int __usercall sub_10051B20@<eax>(int a1@<eax>, unsigned int a2@<ecx>, int a3@<ebx>, int a4);
// _DWORD *__usercall sub_10051BF0@<eax>(int a1@<edx>, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, int a8);
int __cdecl sub_10051D20(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, int a8, int a9, unsigned int a10);
// int __usercall sub_10051E80@<eax>(unsigned int a1@<eax>, int a2, int a3, int a4, _BYTE *a5, int a6, unsigned int a7, unsigned int a8, int a9, int a10);
// void __usercall sub_100520A0(int a1@<ecx>, int a2@<esi>);
int sub_10052120(); // weak
int sub_10052130(); // weak
int sub_10052140(); // weak
// unsigned int __usercall sub_10052170@<eax>(int a1@<esi>);
int __cdecl sub_100521C0(int a1);
// unsigned int __usercall sub_100522A0@<eax>(int a1@<eax>);
// void __usercall sub_10052370(int *a1@<eax>);
// signed int __usercall sub_100523D0@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_10052430@<eax>(int a1@<eax>);
// signed int __usercall sub_100524B0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, unsigned int a5);
unsigned int __cdecl sub_10052690(int a1, int a2);
unsigned int __cdecl sub_10052750(int a1, int a2);
unsigned int __cdecl sub_10052830(int a1, int a2);
unsigned int __cdecl sub_100528D0(int a1, int a2);
signed int __cdecl sub_10052950(int a1, int a2);
signed int __cdecl sub_10052B30(int a1, int a2);
signed int __cdecl sub_10052D30(int a1, int a2);
int sub_10052EB0(); // weak
// int __usercall sub_10052F50@<eax>(int result@<eax>, int a2@<ecx>);
signed int __fastcall sub_10052FC0(int a1, int a2);
// signed int __usercall sub_100530F0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3);
// void __usercall sub_100536F0(int a1@<edx>, int a2@<esi>);
signed int __stdcall sub_10053760(int a1, unsigned int a2, unsigned int a3);
// signed int __usercall sub_10054390@<eax>(int a1@<eax>, int a2@<edi>);
// signed int __usercall sub_10054410@<eax>(int a1@<eax>, unsigned int a2@<ebx>, unsigned int a3@<edi>);
// int __usercall sub_100544E0@<eax>(int a1@<eax>, int a2, void *a3, int a4, int a5);
// signed int __usercall sub_100547B0@<eax>(unsigned int *a1@<eax>, int a2@<edx>, int a3, int *a4, void *a5, unsigned int a6, _DWORD *a7);
// signed int __usercall sub_100548D0@<eax>(_DWORD *a1@<eax>, int a2@<edi>, int a3@<esi>);
int sub_10054960(); // weak
// int __usercall sub_10054A30@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3);
// int __usercall sub_10054B00@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
// unsigned int __usercall sub_10054BE0@<eax>(int a1@<esi>, int *a2);
// int __usercall sub_10054D80@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>, int a4);
// int __usercall sub_10054DE0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>);
// int __usercall sub_10054E20@<eax>(int a1@<edi>);
int __cdecl sub_10054F40(int, void *, int); // idb
void *__cdecl sub_10054F80(char *a1);
// int __usercall sub_10054FC0@<eax>(int result@<eax>);
int __fastcall sub_10055100(int a1, int a2);
unsigned int __fastcall sub_10055370(int a1, int a2);
// int __usercall sub_10055550@<eax>(int a1@<edi>);
// signed int __usercall sub_100555E0@<eax>(int a1@<eax>, unsigned int *a2);
// unsigned int __usercall sub_10055960@<eax>(int a1@<ebx>, int a2@<esi>, int a3, unsigned int a4, int a5);
// int __usercall sub_10055AE0@<eax>(int a1@<esi>);
// signed int __usercall sub_10055B90@<eax>(const void *a1@<eax>, int a2@<ebx>);
// int __usercall sub_10055CB0@<eax>(int a1@<eax>);
int __cdecl sub_10055DA0(int a1, int a2, unsigned int *a3);
// int __usercall sub_10057080@<eax>(int a1@<eax>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_100570C0@<eax>(unsigned int *a1@<eax>, _WORD *a2@<edi>, int a3);
// unsigned int __usercall sub_10057120@<eax>(int a1@<eax>, int a2@<ecx>, unsigned int a3@<ebx>);
// int __usercall sub_100571D0@<eax>(int result@<eax>, int a2@<ecx>, int a3, unsigned int a4);
// int __usercall sub_10057260@<eax>(int result@<eax>, int a2, int a3, unsigned int a4);
// int __usercall sub_100572E0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4);
// int __usercall sub_10057380@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10057400@<eax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_100574A0@<eax>(int a1@<eax>, _WORD *a2@<edx>, unsigned int *a3@<ecx>, unsigned int a4);
// int __usercall sub_10057620@<eax>(int a1@<esi>);
int __cdecl sub_100576E0(int a1, int a2);
// int __usercall sub_10057850@<eax>(int a1@<ebx>, int a2);
int __cdecl sub_10057910(int a1);
// signed int __usercall sub_100581B0@<eax>(int a1@<esi>);
// signed int __usercall sub_10058360@<eax>(int a1@<eax>);
// signed int __usercall sub_10058400@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_10058490@<eax>(int a1@<eax>, int a2@<edx>, int *a3@<esi>, int a4, int a5);
signed int __cdecl sub_10058500(int a1, int *a2, int a3, int a4, const void *a5, int a6, _DWORD *a7);
// char __usercall sub_10058590@<al>(int a1@<ebx>, int a2@<edi>, unsigned int a3@<esi>);
char __cdecl sub_10058640(unsigned int a1, int a2, unsigned int a3);
// char __usercall sub_10058820@<al>(int a1@<esi>, unsigned int a2, int a3, unsigned int a4);
// int __usercall sub_10058EC0@<eax>(int a1@<eax>, unsigned int a2, int a3);
// char __usercall sub_100590F0@<al>(unsigned int a1@<eax>, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6);
void __stdcall sub_100593B0(int a1, float a2, float a3, float a4, float a5, float a6, float a7);
void __stdcall sub_10059BB0(int a1, float a2, int a3, int a4, float a5, int a6, int a7);
// bool __userpurge sub_1005A170@<al>(int a1@<edx>, int a2@<edi>, int a3@<esi>, int a4);
int __cdecl sub_1005A5B0(char *); // idb
double __cdecl sub_1005A5F0(double a1);
long double __cdecl sub_1005A6A0(double a1);
double __cdecl sub_1005A6F0(float a1, float a2, float a3);
double __cdecl sub_1005A810(float a1, float a2);
double __cdecl sub_1005A8C0(float a1);
double __cdecl sub_1005A950(float a1);
double __cdecl sub_1005A9C0(float a1);
double __cdecl sub_1005AA00(float a1);
double __cdecl sub_1005AA70(float a1);
double __cdecl sub_1005AB00(float a1);
double __cdecl sub_1005AB90(float a1);
double __cdecl sub_1005AC20(float a1);
double __cdecl sub_1005ACB0(float a1);
double __cdecl sub_1005AD90(float a1);
void __cdecl sub_1005AE60(float a1);
void __cdecl sub_1005AE90(float a1);
void __cdecl sub_1005AEC0(float a1);
void __cdecl sub_1005AEE0(float a1);
void __cdecl sub_1005AF00(float a1);
double __cdecl sub_1005AF20(float a1);
// unsigned int __usercall sub_1005B000@<eax>(signed int a1@<eax>, int a2@<edx>);
// char __userpurge sub_1005B0E0@<al>(unsigned int a1@<eax>, int a2@<edi>, int (__stdcall **a3)(int, int *, int, unsigned int, int, int *, signed int, _DWORD, signed int, signed int, signed int, signed int, int), int a4);
// int __usercall sub_1005B3A0@<eax>(int a1@<eax>, _BYTE *a2@<edx>);
// int __usercall sub_1005B3F0@<eax>(int a1@<eax>, unsigned int a2);
// void __usercall sub_1005B5A0(int a1@<eax>, int a2, int a3, int a4, int a5, int a6, int a7, float a8);
unsigned int __thiscall sub_1005BF60(unsigned int *this);
// void __usercall sub_1005BFA0(int a1@<esi>);
int sub_1005C080(); // weak
// unsigned int __userpurge sub_1005C1B0@<eax>(unsigned int result@<eax>, int a2@<ecx>, unsigned int a3);
// char __userpurge sub_1005C320@<al>(unsigned int a1@<eax>, int a2, int a3, unsigned int a4);
// void __usercall sub_1005C4E0(int a1@<edi>);
void __thiscall sub_1005C5A0(void *); // idb
// int __usercall sub_1005C690@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>);
// int __usercall sub_1005C720@<eax>(int a1@<esi>);
// unsigned int __usercall sub_1005C770@<eax>(__int16 a1@<ax>, unsigned int *a2@<edi>, int a3@<esi>);
// char __usercall sub_1005C810@<al>(unsigned int *a1@<edi>, int a2@<esi>);
// char *__userpurge sub_1005C8A0@<eax>(int a1@<esi>, unsigned int a2);
// char __userpurge sub_1005C930@<al>(unsigned int a1@<esi>, int a2, int a3, unsigned int a4);
// char __usercall sub_1005CB70@<al>(int a1@<esi>);
// int __usercall sub_1005CC00@<eax>(int result@<eax>);
// int __userpurge sub_1005CCA0@<eax>(int a1@<eax>, unsigned int *a2@<ecx>, int a3);
// char __usercall sub_1005D260@<al>(int a1@<eax>);
// bool __userpurge sub_1005D4D0@<al>(int a1@<ebx>, unsigned int a2@<edi>, int a3@<esi>, int a4);
void __thiscall sub_1005D550(int this, int a2, int a3, int a4);
void __thiscall sub_1005D730(int this, int a2, int a3, int a4);
char __stdcall sub_1005D840(int a1);
char __stdcall sub_1005DAE0(int a1);
char __stdcall sub_1005DD50(int a1);
void __thiscall sub_1005DFC0(char *this, int a2, int a3, int a4);
void __stdcall sub_1005E760(int a1);
void __stdcall sub_1005EE00(int a1);
// signed int __usercall sub_1005F570@<eax>(int a1@<esi>);
void __stdcall sub_1005FC60(int a1);
int __stdcall sub_10060150(int a1);
char __stdcall sub_10060390(int a1);
char __stdcall sub_100609B0(int a1);
void __thiscall sub_10060F80(void *this, int a2, int a3, int a4);
// void __userpurge sub_10061520(int a1@<eax>, unsigned int a2@<ecx>, _DWORD *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9, int a10);
bool __stdcall sub_100616D0(int a1, char a2);
// bool __usercall sub_10062740@<al>(int a1@<esi>);
// char __userpurge sub_100627E0@<al>(int a1@<eax>, int a2);
char __stdcall sub_100630D0(int a1);
int __fastcall sub_10063BD0(int a1, int a2, int a3, int a4, int a5, int a6, unsigned int a7, _BYTE *a8);
void __thiscall sub_10063CB0(void *this, int a2, int a3, int a4);
bool __stdcall sub_10064F30(int a1);
void __thiscall sub_10065420(int this, int a2, int a3, int a4);
// bool __usercall sub_10065970@<al>(int a1@<esi>);
// bool __userpurge sub_10065A10@<al>(int a1@<ebx>, int a2, const void *a3, int a4);
// int __userpurge sub_10065C00@<eax>(int result@<eax>, signed int a2@<edx>, float *a3@<ecx>, float a4);
// float *__userpurge sub_10065C80@<eax>(float *result@<eax>, signed int a2@<edx>, int a3@<ecx>, float a4);
// int __userpurge sub_10065CF0@<eax>(int result@<eax>, int a2@<ecx>, float *a3);
// void __usercall sub_10065E00(signed int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// void __usercall sub_10065FB0(int a1@<esi>);
// char __usercall sub_100661C0@<al>(const void *a1@<ebx>, int a2@<esi>);
// int __usercall sub_100663E0@<eax>(int a1@<esi>);
void *__cdecl sub_10066550(int a1, int a2, int a3, int a4, float a5, float a6, float a7);
// int __userpurge sub_100670C0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<esi>, int a5, int a6, int a7, float a8, int a9, int a10, int a11, float a12, float a13, float a14, float a15);
int __thiscall sub_10067950(int this, void *a2, size_t a3, int a4);
_DWORD *__stdcall sub_10067A70(int a1);
// char __usercall sub_10067B70@<al>(int a1@<eax>);
// char __usercall sub_10068220@<al>(int a1@<ecx>, FILE *a2@<edi>, char *a3, int a4);
// char __usercall sub_10068350@<al>(FILE *a1@<edi>, char *a2, char a3);
// size_t __usercall sub_10068370@<eax>(FILE *a1@<ecx>, size_t result@<eax>, int a3@<edx>, int a4, int a5, int a6, int a7, int a8, size_t a9);
// BOOL __usercall sub_10068570@<eax>(const char *a1@<eax>, int a2, int a3, int a4, size_t a5, int a6, int a7, int a8, size_t a9, char *a10, char a11);
// int __usercall sub_100686F0@<eax>(int a1@<ebx>);
// unsigned __int32 __usercall sub_10068790@<eax>(int a1@<edi>);
// int __usercall sub_10068990@<eax>(int result@<eax>, int a2@<ecx>);
// unsigned int __usercall sub_10068A50@<eax>(int a1@<esi>);
// int __usercall sub_10068BB0@<eax>(void *a1@<ecx>, int a2@<eax>, size_t a3, int a4, int a5);
// char __usercall sub_10068C20@<al>(int a1@<eax>, unsigned int a2, int a3, _BYTE *a4);
_DWORD __cdecl sub_10068DB0(unsigned int a1, _DWORD a2, _DWORD a3, _DWORD a4);
double __cdecl sub_10069310(_DWORD, _DWORD, _DWORD, _DWORD); // weak
// bool __usercall sub_10069400@<al>(int a1@<eax>, unsigned int a2@<ecx>, int a3, int *a4, int *a5);
// int __usercall sub_10069990@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>);
// unsigned int __usercall sub_10069B00@<eax>(int a1@<eax>, int a2, int a3);
int __cdecl sub_10069B70(unsigned int a1, int a2, unsigned int a3, unsigned int a4, unsigned __int64 a5);
char __cdecl sub_10069DA0(unsigned int a1, int a2, _DWORD *a3, _DWORD *a4, int a5, int a6);
char __cdecl sub_1006A500(size_t a1, int a2, int a3, int a4, void *a5);
// char __usercall sub_1006AA20@<al>(int a1@<eax>, size_t a2, int a3, int a4, int a5, void *a6);
// unsigned int __usercall sub_1006B0B0@<eax>(unsigned int *a1@<ebx>, _BYTE *a2@<edi>, unsigned int a3@<esi>, int a4, unsigned int *a5, char a6);
// unsigned int __usercall sub_1006B1B0@<eax>(char a1@<al>, int a2@<edx>, int a3);
// char __userpurge sub_1006B290@<al>(unsigned int a1@<ecx>, int a2@<esi>, int a3);
char __cdecl sub_1006B310(int a1, int a2);
int __thiscall sub_1006B380(_DWORD *this, int a2, int a3, int a4);
void __thiscall sub_1006B870(void *this, int a2, int a3, int a4);
void __stdcall sub_1006BE80(int a1);
int __stdcall sub_1006BF60(int a1);
// int __userpurge sub_1006C0C0@<eax>(int a1@<edi>, int a2);
char __stdcall sub_1006C250(int a1, unsigned int a2, int a3);
char __thiscall sub_1006C8E0(void *this, int a2, int a3, const void *a4);
bool __stdcall sub_1006DA30(int a1, int a2, const void *a3);
// char __userpurge sub_1006E250@<al>(unsigned int a1@<ecx>, int a2@<esi>, int a3);
char __cdecl sub_1006E2D0(int a1, int a2);
int __thiscall sub_1006E340(_DWORD *this, int a2, int a3, int a4);
int __stdcall sub_1006E830(int a1);
void __stdcall sub_1006E990(int a1);
// int __userpurge sub_1006EA70@<eax>(int a1@<edi>, int a2);
bool __thiscall sub_1006EC50(int this, unsigned int a2, int a3);
char __stdcall sub_1006F060(int a1, unsigned int a2, int a3, const void *a4);
void __thiscall sub_1006FE20(_DWORD *this, int a2, int a3, int a4);
bool __stdcall sub_10070950(int a1, int a2, int a3, float a4);
int sub_10071190(); // weak
int sub_100711C0(); // weak
int sub_100711F0(); // weak
int __stdcall sub_10071220(int a1);
// char __userpurge sub_100713C0@<al>(int a1@<eax>, int a2, int a3);
void __stdcall sub_10071F50(void *a1);
void __thiscall sub_10072060(int this);
void __thiscall sub_10072140(void *this);
char __thiscall sub_10072150(void *this, int a2);
char __fastcall sub_10072280(int a1, int a2);
char __thiscall sub_10072420(int this, int a2, float *a3);
int sub_10072670(); // weak
int sub_100727B0(); // weak
int sub_100728F0(); // weak
double __cdecl sub_100729A0(int a1, int a2, int a3);
// void __userpurge sub_10072BB0(int a1@<esi>, int a2, int a3, int a4, float a5);
// void __usercall sub_10072EC0(int a1@<edi>, int a2);
// void *__usercall sub_10072F40@<eax>(int a1@<edi>, void *a2, size_t a3);
// void __userpurge sub_10072FB0(int a1@<esi>, int a2, int a3);
void __stdcall sub_100732F0(int a1, int a2);
void __stdcall sub_10073550(int a1, int a2);
// char __usercall sub_100739F0@<al>(int a1@<eax>);
void __thiscall sub_10073FE0(int this, int a2, int a3, int a4);
void __thiscall sub_10074080(int this, int a2, int a3, void *a4);
void __thiscall sub_10074140(int this, int a2, int a3, void *a4);
void __thiscall sub_10074200(int this, int a2, int a3, void *a4);
unsigned int __stdcall sub_100742C0(int a1);
int __stdcall sub_100744C0(int a1);
unsigned int __stdcall sub_10074F00(int a1);
// char __userpurge sub_10075010@<al>(unsigned int a1@<eax>, int a2, int a3, char a4, int a5, int a6, int a7, int a8, int a9);
BOOL __thiscall sub_10075740(int this);
int __stdcall sub_10075AA0(int a1);
char __stdcall sub_10075CE0(int a1);
// char __usercall sub_10076260@<al>(int a1@<edi>);
char __stdcall sub_10076420(int a1, int a2, _DWORD *a3, int a4, int a5, int a6, int a7);
char __thiscall sub_10076610(_DWORD *this, int a2, int a3, int a4, int a5, int a6);
char __thiscall sub_10076E80(int this, int a2, _DWORD *a3, int a4);
char __thiscall sub_10077800(_DWORD *this, int a2, int a3, int a4);
char __thiscall sub_10078240(int this, int a2);
// char __userpurge sub_10078C00@<al>(int a1@<esi>, int a2);
// bool __usercall sub_100795B0@<al>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// bool __usercall sub_10079940@<al>(int a1@<ecx>, int a2@<ebx>);
// bool __usercall sub_10079CA0@<al>(int a1@<eax>);
char __stdcall sub_1007A2D0(int a1);
char __thiscall sub_1007A960(void *this, int a2, float *a3);
// int *__usercall sub_1007AA80@<eax>(int *result@<eax>, int *a2@<ecx>);
unsigned int __fastcall sub_1007AAD0(int *a1, unsigned int *a2);
char __stdcall sub_1007AC30(int a1, int a2, int a3, int a4, unsigned int a5);
// signed int __usercall sub_1007B080@<eax>(unsigned int a1@<eax>, unsigned int a2@<ecx>);
// void __usercall sub_1007B1D0(int a1@<ebx>);
unsigned int __cdecl sub_1007B4C0(int a1, unsigned int a2);
char __cdecl sub_1007B7A0(int a1, int a2, int a3);
char __cdecl sub_1007BF30(int a1, int a2, int a3);
// void __usercall sub_1007C770(int a1@<edi>);
int sub_1007C800(void); // weak
void __thiscall sub_1007C810(int this, unsigned int a2);
int __stdcall sub_1007C9D0(int a1, int a2, int a3, int a4);
// int __userpurge sub_1007D390@<eax>(int a1@<edi>, int a2@<esi>, int a3, float a4, int a5);
// int __userpurge sub_1007D4E0@<eax>(int a1@<ebx>, unsigned int a2, int a3);
// int __userpurge sub_1007D660@<eax>(int a1@<esi>, int a2);
// void __usercall sub_1007D8F0(int a1@<edi>);
char __stdcall sub_1007D9A0(unsigned int a1);
int __stdcall sub_1007DB20(int a1);
// char __userpurge sub_1007DD40@<al>(_DWORD *a1@<eax>, int a2, int a3, char a4, int a5, unsigned __int8 a6);
char __stdcall sub_1007E440(int a1, int a2, int a3, char a4, int a5, unsigned __int8 a6);
// char __userpurge sub_1007ED40@<al>(_DWORD *a1@<eax>, char a2@<dl>, unsigned __int8 a3@<cl>, unsigned int a4, int a5);
char __thiscall sub_1007EE30(void *this, unsigned int a2);
void __stdcall sub_1007FCF0(unsigned int a1);
// char __usercall sub_10080720@<al>(unsigned int a1@<esi>);
char __stdcall sub_10080840(unsigned int a1);
char __stdcall sub_10080E70(unsigned int a1);
// char __userpurge sub_10081850@<al>(int a1@<eax>, int a2@<ecx>, unsigned int a3);
char __stdcall sub_10082300(unsigned int a1, int a2, int a3);
// bool __usercall sub_10083D40@<al>(unsigned int a1@<eax>);
// char __userpurge sub_10084780@<al>(int a1@<eax>, int a2, int a3);
char __stdcall sub_10084890(int a1);
// char __usercall sub_10084D30@<al>(int a1@<eax>);
// unsigned int __userpurge sub_10084DC0@<eax>(int a1@<esi>, int a2);
// unsigned int __userpurge sub_10084EF0@<eax>(int a1@<ebx>, int a2);
// int __usercall sub_10085020@<eax>(int a1@<esi>);
// int __usercall sub_10085090@<eax>(int result@<eax>, int a2@<edi>);
// char __usercall sub_100851E0@<al>(int a1@<eax>);
char __stdcall sub_10085310(int a1);
// char __userpurge sub_10085450@<al>(int a1@<eax>, int a2@<ecx>, int a3@<edi>, int a4);
char __stdcall sub_100855F0(int a1, int a2, int a3, int a4);
// char __userpurge sub_100859B0@<al>(int a1@<edi>, int a2);
char __stdcall sub_10085BA0(int a1, int a2, int a3, int a4, int a5, int a6);
void __thiscall sub_100864E0(_DWORD *this, int a2, int a3, int a4);
// char __userpurge sub_10086840@<al>(int a1@<eax>, int a2, int a3, int a4, int a5);
// char __usercall sub_10086A20@<al>(int a1@<eax>);
double __fastcall sub_10086A70(_DWORD, _DWORD); // weak
// char __usercall sub_10086B50@<al>(int a1@<eax>);
// char __usercall sub_10086BE0@<al>(int a1@<eax>);
// int __usercall sub_10086CC0@<eax>(int a1@<eax>, int a2@<ecx>);
void __stdcall sub_10086E20(int a1);
// void __usercall sub_10087040(int a1@<edi>);
void __stdcall sub_10087290(int a1);
// signed int __userpurge sub_100873F0@<eax>(int a1@<eax>, int a2@<esi>, signed int a3, int a4);
// char __userpurge sub_10087550@<al>(int a1@<edi>, int a2@<esi>, int a3, int a4);
void *__stdcall sub_10087610(int a1, int a2, int a3, int a4, int a5, int a6, void *a7);
// int __usercall sub_10087B40@<eax>(int result@<eax>, int a2@<esi>);
// int __usercall sub_10087B90@<eax>(int a1@<ecx>, int a2@<esi>);
int __stdcall sub_10087C90(int a1, int a2);
char __stdcall sub_10087F90(int a1, int a2, int a3, int a4, const void *a5, signed int a6);
char __stdcall sub_10088740(int a1, int a2, int a3, unsigned int a4, char *a5);
char __stdcall sub_10088920(int a1, int a2);
// char __userpurge sub_10089610@<al>(int a1@<eax>, int a2, int a3, int a4, int a5);
// char __userpurge sub_1008A020@<al>(int a1@<eax>, int a2, int a3);
// char __userpurge sub_1008A9C0@<al>(int a1@<eax>, int a2, int a3, signed int a4, const void *a5, int a6);
// char __userpurge sub_1008AC40@<al>(int a1@<ecx>, int a2@<esi>, int a3, int a4, int a5);
// char __userpurge sub_1008B0C0@<al>(int a1@<esi>, signed int a2, const void *a3);
char __stdcall sub_1008B1D0(int a1, signed int a2, const void *a3);
char __stdcall sub_1008B4D0(int a1, signed int a2, int a3);
// signed int __usercall sub_1008B750@<eax>(int a1@<eax>);
signed int __fastcall sub_1008B7D0(signed int a1);
// int __usercall sub_1008B8C0@<eax>(char *a1@<eax>, int a2);
unsigned int __cdecl sub_1008BC80(int a1, int a2);
int __cdecl sub_1008BF90(int a1, int a2, unsigned __int8 a3, int a4);
char sub_1008C280();
// unsigned int __usercall sub_1008C470@<eax>(unsigned __int16 a1@<ax>, int a2, unsigned __int16 a3);
// signed int __usercall sub_1008C5B0@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<esi>);
char __stdcall sub_1008C960(int a1, int a2, int a3, int a4);
char __stdcall sub_1008D380(int a1, int a2, int a3, int a4);
char __stdcall sub_1008D7C0(int a1);
// signed int __usercall sub_1008DCE0@<eax>(int a1@<eax>, int a2@<edx>, unsigned __int16 a3);
// char __usercall sub_1008DE60@<al>(int a1@<eax>, int a2@<esi>, unsigned __int16 a3, unsigned __int16 a4);
// signed int __usercall sub_1008DFF0@<eax>(int a1@<eax>, int a2@<edx>, unsigned __int16 a3);
// unsigned int __usercall sub_1008E180@<eax>(int a1@<eax>, int *a2@<ecx>, int a3);
// char __usercall sub_1008EAC0@<al>(int a1@<eax>, int a2@<edi>, char a3);
unsigned int sub_1008F500();
// int __usercall sub_1008F630@<eax>(int a1@<edx>, int a2);
// bool __usercall sub_1008F790@<al>(int a1@<eax>, unsigned int a2@<ecx>, __int16 *a3, __int16 *a4);
// int __usercall sub_1008FB30@<eax>(int a1@<eax>, int a2@<edx>, char a3);
int __cdecl sub_100903E0(int a1, int a2, int a3);
int __cdecl sub_10090490(int a1, int a2, int a3);
int sub_10090550();
int __cdecl sub_10090640(_BYTE *a1, _WORD *a2, _WORD *a3);
// signed int __usercall sub_10090C80@<eax>(unsigned __int16 a1@<ax>, int a2@<ecx>, unsigned __int16 a3);
int __cdecl sub_10090D20(int a1, int a2);
// void __usercall sub_10090EE0(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// void __usercall sub_10090F60(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
void sub_10091080();
int __stdcall sub_10091130(int a1);
LONG __stdcall sub_100911E0(LPLONG Target);
int __stdcall sub_10091370(int a1);
void __stdcall sub_10091500(int a1);
// char __userpurge sub_100916A0@<al>(int a1@<eax>, int a2@<ecx>, int a3, int a4, int a5);
// PSLIST_HEADER __usercall sub_10091720@<eax>(int a1@<edi>);
// char __usercall sub_100917D0@<al>(unsigned int a1@<eax>, int a2@<ecx>);
// int __usercall sub_10091840@<eax>(int a1@<edi>);
BOOL __stdcall sub_100918E0(int a1);
int __thiscall sub_10091980(void *this, __int64 a2);
bool sub_10091A40(int a1, ...);
// BOOL __userpurge sub_10091B60@<eax>(unsigned int a1@<eax>, int a2@<edi>, char a3);
// void __usercall sub_10091CF0(int a1@<esi>);
// void __userpurge sub_10091D50(int a1@<eax>, int a2);
int __fastcall sub_10091F40(const char *a1, int a2, va_list ArgList);
// int __userpurge sub_10091FD0@<eax>(int a1@<eax>, int a2);
// int __userpurge sub_10092080@<eax>(int a1@<eax>, void *a2);
double __thiscall sub_10092180(_DWORD); // weak
// signed int __usercall sub_10092230@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_100923C0@<eax>(int a1@<eax>, char a2);
// signed int __usercall sub_100924B0@<eax>(unsigned __int16 a1@<ax>, int a2@<ecx>, unsigned __int16 a3);
// signed int __usercall sub_10092630@<eax>(int a1@<eax>, unsigned __int16 a2@<cx>, unsigned __int16 a3);
// int __usercall sub_10092740@<eax>(signed int a1@<eax>, signed int a2@<edx>, signed int a3@<ecx>);
// void __usercall sub_100927E0(int a1@<eax>);
size_t __cdecl sub_10092850(void *a1);
void *__cdecl sub_10092870(void *a1, size_t a2, int a3, char a4);
// void __usercall sub_10092970(int a1@<eax>);
// int __usercall sub_100929A0@<eax>(void *a1@<ecx>, unsigned int a2@<eax>, int *a3@<esi>, int a4);
// int __usercall sub_10092A10@<eax>(int a1@<eax>, int *a2@<edi>);
// int __usercall sub_10092A80@<eax>(int a1@<eax>);
// const char *__usercall sub_10092B10@<eax>(int a1@<eax>);
int sub_10092B90(); // weak
int sub_10092BC0(); // weak
// void *__usercall sub_10092BE0@<eax>(float *a1@<ebx>, _DWORD *a2@<esi>, int a3, int a4, _DWORD *a5);
unsigned int __thiscall sub_10092CD0(int this, int a2, int a3, int a4);
// void __usercall sub_10092F70(int a1@<esi>);
void __stdcall sub_10093050(int a1);
void __thiscall sub_100930F0(int this, int a2, int a3, int a4);
// char __userpurge sub_100935B0@<al>(int a1@<eax>, int a2);
void sub_10093750();
// double __usercall sub_100937C0@<st0>(int a1@<esi>);
int __stdcall sub_10093880(int a1, int a2, int a3);
char __stdcall sub_10093A30(int a1, int a2, int a3);
int __stdcall sub_10093EF0(int a1);
void __cdecl sub_10093FC0(int a1, void *a2);
int __cdecl sub_10093FF0(int a1, int a2);
signed int __stdcall sub_10094000(int a1, int *a2, void *a3, unsigned int *a4, int a5, unsigned int a6);
signed int __stdcall sub_10094030(int a1, int *a2, int a3, int a4, int a5, _DWORD *a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
void __cdecl sub_10094100(char *Format, va_list ArgList);
void sub_10094320(char *Format, ...);
void sub_10094340(char *Format, ...);
void sub_10094360(char *Format, ...);
void sub_10094380(char *Format, ...);
void sub_100943A0(char *Format, ...);
// char __userpurge sub_100943C0@<al>(unsigned int a1@<eax>, void (__cdecl *a2)(int, _DWORD, _DWORD)@<ecx>, int a3, char a4, unsigned int a5, char a6);
char __cdecl sub_10094540(int a1, int a2);
int __cdecl sub_10094EB0(int a1);
char __cdecl sub_10094F40(int a1, int a2, _DWORD *a3, float *a4);
// char __usercall sub_10095650@<al>(int a1@<eax>, int a2, int a3);
// char __usercall sub_10095B80@<al>(int a1@<eax>, int a2@<ecx>, int a3, int a4, _DWORD *a5, float *a6);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memset(void *, int, size_t);
// double __cdecl floor(double);
// int __cdecl CxxThrowException(_DWORD, _DWORD); weak
// int __thiscall _CxxFrameHandler3(_DWORD); weak
int sub_1009603F();
// void __usercall sub_10096050(int a1@<ebp>);
// void __usercall sub_1009605D(int a1@<ebp>);
// void __usercall sub_10096068(int a1@<ebp>);
// void __usercall sub_10096073(int a1@<ebp>);
// void __usercall sub_1009607E(int a1@<ebp>);
// void __usercall sub_10096089(int a1@<ebp>);
// void __usercall sub_10096096(int a1@<ebp>);
// void __usercall sub_100960A4(int a1@<ebp>);
// void __usercall sub_100960B1(int a1@<ebp>);
// void __usercall sub_100960BE(int a1@<ebp>);
// void __usercall sub_100960CB(int a1@<ebp>);
// void __usercall sub_100960D8(int a1@<ebp>);
// void __usercall sub_100960E5(int a1@<ebp>);
int __thiscall SEH_100328F0(void *this);
// void __usercall sub_10096130(int a1@<ebp>);
int __cdecl sub_10096138(int a1, int a2);
int __cdecl sub_10096160(int a1, int a2);
// void __usercall sub_10096180(int a1@<ebp>);
int __cdecl sub_10096188(int a1, int a2);
int __cdecl sub_100961B0(int a1, int a2);
int __cdecl sub_100961D0(int a1, int a2);
int __cdecl sub_100961F0(int a1, int a2);
int __cdecl sub_10096210(int a1, int a2);
// void __usercall sub_10096230(int a1@<ebp>);
int __thiscall SEH_1004E640(void *this);
// void __usercall sub_10096250(int a1@<ebp>);
int __thiscall SEH_100415E0(void *this);
// void __usercall sub_10096270(int a1@<ebp>);
int __thiscall SEH_10093050(void *this);
// void __usercall sub_10096285(int a1@<ebp>);
int __thiscall sub_1009628D(void *this);
// void __usercall sub_10096297(int a1@<ebp>);
int __thiscall SEH_100593B0(void *this);
// void __usercall sub_100962AC(int a1@<ebp>);
// void __usercall sub_100962B7(int a1@<ebp>);
// void __usercall sub_100962C2(int a1@<ebp>);
int __thiscall sub_100962CD(void *this);
// void __usercall sub_100962D7(int a1@<ebp>);
// void __usercall sub_100962E2(int a1@<ebp>);
int __thiscall SEH_1005C5A0(void *this);
// LONG __usercall sub_100962F7@<eax>(int a1@<ebp>);
void sub_100962FF();
int __thiscall SEH_1005DFC0(void *this);
// void __usercall sub_10096311(int a1@<ebp>);
// void __usercall sub_1009631E(int a1@<ebp>);
// void __usercall sub_10096329(int a1@<ebp>);
// void __usercall sub_10096334(int a1@<ebp>);
// void __usercall sub_1009633F(int a1@<ebp>);
// void __usercall sub_1009634A(int a1@<ebp>);
// void __usercall sub_10096357(int a1@<ebp>);
// void __usercall sub_10096365(int a1@<ebp>);
// void __usercall sub_10096372(int a1@<ebp>);
// void __usercall sub_1009637F(int a1@<ebp>);
// void __usercall sub_1009638C(int a1@<ebp>);
// void __usercall sub_10096399(int a1@<ebp>);
// void __usercall sub_100963A6(int a1@<ebp>);
// void __usercall sub_100963B3(int a1@<ebp>);
int __thiscall SEH_1007DB20(void *this);
// HANDLE __usercall sub_100963CC@<eax>(int a1@<ebp>);
// void __usercall sub_100963D7(int a1@<ebp>);
int __thiscall SEH_100918E0(void *this);
// void __usercall sub_100963EC(int a1@<ebp>);
int __thiscall sub_100963F4(void *this);
// void __usercall sub_100963FE(int a1@<ebp>);
// void __usercall sub_10096409(int a1@<ebp>);
// void __usercall sub_10096416(int a1@<ebp>);
// void __usercall sub_10096421(int a1@<ebp>);
// void __usercall sub_1009642C(int a1@<ebp>);
int __thiscall sub_10096437(void *this);
// void __usercall sub_10096441(int a1@<ebp>);
int __thiscall SEH_1005C930(void *this);
// void __usercall sub_10096456(int a1@<ebp>);
// int __usercall sub_10096463@<eax>(int a1@<ebp>);
// void __usercall sub_1009647B(int a1@<ebp>);
// void __usercall sub_10096489(int a1@<ebp>);
// void __usercall sub_10096497(int a1@<ebp>);
// void __usercall sub_100964A4(int a1@<ebp>);
// void __usercall sub_100964B1(int a1@<ebp>);
// void __usercall sub_100964BF(int a1@<ebp>);
// void __usercall sub_100964CD(int a1@<ebp>);
// void __usercall sub_100964DB(int a1@<ebp>);
// void __usercall sub_100964E9(int a1@<ebp>);
// void __usercall sub_100964F6(int a1@<ebp>);
// void __usercall sub_10096503(int a1@<ebp>);
// void __usercall sub_10096510(int a1@<ebp>);
// void __usercall sub_1009651D(int a1@<ebp>);
// void __usercall sub_1009652A(int a1@<ebp>);
// void __usercall sub_10096537(int a1@<ebp>);
// void __usercall sub_10096544(int a1@<ebp>);
// void __usercall sub_10096551(int a1@<ebp>);
// void __usercall sub_1009655E(int a1@<ebp>);
int __thiscall SEH_1005FC60(void *this);
// void __usercall sub_10096575(int a1@<ebp>);
int __thiscall SEH_10060150(void *this);
// int __usercall sub_1009658C@<eax>(int a1@<ebp>);
int __thiscall SEH_1006B380(void *this);
// int __usercall sub_100965A9@<eax>(int a1@<ebp>);
int __thiscall SEH_1006E340(void *this);
// void __usercall sub_100965C6(int a1@<ebp>);
// BOOL __usercall sub_100965CE@<eax>(int a1@<ebp>);
// int __usercall sub_100965DB@<eax>(int a1@<ebp>);
// void __usercall sub_100965F1(int a1@<ebp>);
// void __usercall sub_100965FE(int a1@<ebp>);
// int __usercall sub_1009660B@<eax>(int a1@<ebp>);
// int __usercall sub_10096623@<eax>(int a1@<ebp>);
// void __usercall sub_1009663B(int a1@<ebp>);
// void __usercall sub_10096648(int a1@<ebp>);
// void __usercall sub_10096656(int a1@<ebp>);
// void __usercall sub_10096665(int a1@<ebp>);
// void __usercall sub_10096673(int a1@<ebp>);
// int __usercall sub_10096681@<eax>(int a1@<ebp>);
// int __usercall sub_10096699@<eax>(int a1@<ebp>);
// int __usercall sub_100966B1@<eax>(int a1@<ebp>);
// int __usercall sub_100966C9@<eax>(int a1@<ebp>);
// int __usercall sub_100966E1@<eax>(int a1@<ebp>);
// void __usercall sub_100966F9(int a1@<ebp>);
// void __usercall sub_10096707(int a1@<ebp>);
// void __usercall sub_10096715(int a1@<ebp>);
// void __usercall sub_10096723(int a1@<ebp>);
int __thiscall SEH_10075740(void *this);
// void __usercall sub_1009673B(int a1@<ebp>);
// BOOL __usercall sub_10096743@<eax>(int a1@<ebp>);
// int __usercall sub_10096750@<eax>(int a1@<ebp>);
// void __usercall sub_10096766(int a1@<ebp>);
// void __usercall sub_10096773(int a1@<ebp>);
// int __usercall sub_10096780@<eax>(int a1@<ebp>);
// int __usercall sub_10096798@<eax>(int a1@<ebp>);
// void __usercall sub_100967B0(int a1@<ebp>);
// void __usercall sub_100967BD(int a1@<ebp>);
// void __usercall sub_100967CB(int a1@<ebp>);
// void __usercall sub_100967DA(int a1@<ebp>);
// void __usercall sub_100967E8(int a1@<ebp>);
// int __usercall sub_100967F6@<eax>(int a1@<ebp>);
// int __usercall sub_1009680E@<eax>(int a1@<ebp>);
// int __usercall sub_10096826@<eax>(int a1@<ebp>);
// int __usercall sub_1009683E@<eax>(int a1@<ebp>);
int __thiscall SEH_10075AA0(void *this);
// BOOL __usercall sub_10096860@<eax>(int a1@<ebp>);
// void __usercall sub_1009686D(int a1@<ebp>);
// void __usercall sub_1009687A(int a1@<ebp>);
// void __usercall sub_10096885(int a1@<ebp>);
int __thiscall SEH_1007B7A0(void *this);
// int __usercall sub_1009689A@<eax>(int a1@<ebp>);
int __thiscall SEH_1007BF30(void *this);
int sub_100968BA();
int __thiscall SEH_1007C810(void *this);
// void __usercall sub_100968CC(int a1@<ebp>);
// void __usercall sub_100968D7(int a1@<ebp>);
// void __usercall sub_100968E2(int a1@<ebp>);
// void __usercall sub_100968ED(int a1@<ebp>);
// int __usercall sub_100968F8@<eax>(int a1@<ebp>);
int __thiscall SEH_10093EF0(void *this);
// void __usercall sub_10096910(int a1@<ebp>);
// void __usercall sub_10096918(int a1@<ebp>);
// void __usercall sub_10096923(int a1@<ebp>);
int __thiscall SEH_10087290(void *this);
void sub_10096938();
int __thiscall SEH_10091A40(void *this);
// void __usercall sub_1009694A(int a1@<ebp>);
int sub_10096955();
int __thiscall SEH_10059BB0(void *this);
// void __usercall sub_1009696A(int a1@<ebp>);
// void __usercall sub_10096975(int a1@<ebp>);
// void __usercall sub_10096980(int a1@<ebp>);
int __thiscall sub_1009698B(void *this);
// void __usercall sub_10096995(int a1@<ebp>);
// void __usercall sub_100969A0(int a1@<ebp>);
int __thiscall SEH_10060390(void *this);
// void __usercall sub_100969B5(int a1@<ebp>);
// void __usercall sub_100969C0(int a1@<ebp>);
int __thiscall SEH_100609B0(void *this);
// void __usercall sub_100969D5(int a1@<ebp>);
// void __usercall sub_100969E0(int a1@<ebp>);
// void __usercall sub_100969EB(int a1@<ebp>);
// void __usercall sub_100969F6(int a1@<ebp>);
// void __usercall sub_10096A01(int a1@<ebp>);
// void __usercall sub_10096A0C(int a1@<ebp>);
int sub_10096A17();
// void __usercall sub_10096A1F(int a1@<ebp>);
int __thiscall SEH_10060F80(void *this);
// void __usercall sub_10096A36(int a1@<ebp>);
// void __usercall sub_10096A41(int a1@<ebp>);
// void __usercall sub_10096A4C(int a1@<ebp>);
// void __usercall sub_10096A57(int a1@<ebp>);
int sub_10096A62();
// void __usercall sub_10096A6D(int a1@<ebp>);
int __thiscall sub_10096A7A(void *this);
// void __usercall sub_10096A84(int a1@<ebp>);
// void __usercall sub_10096A8F(int a1@<ebp>);
// void __usercall sub_10096A9A(int a1@<ebp>);
// void __usercall sub_10096AA5(int a1@<ebp>);
// void __usercall sub_10096AB0(int a1@<ebp>);
// void __usercall sub_10096ABB(int a1@<ebp>);
int sub_10096AC6();
// void __usercall sub_10096ACE(int a1@<ebp>);
int __thiscall SEH_1006B870(void *this);
// void __usercall sub_10096AE5(int a1@<ebp>);
// void __usercall sub_10096AF4(int a1@<ebp>);
// int __usercall sub_10096B02@<eax>(int a1@<ebp>);
// int __usercall sub_10096B0F@<eax>(int a1@<ebp>);
int __thiscall SEH_1006BE80(void *this);
// void __usercall sub_10096B34(int a1@<ebp>);
// void __usercall sub_10096B43(int a1@<ebp>);
// void __usercall sub_10096B51(int a1@<ebp>);
// int __usercall sub_10096B5E@<eax>(int a1@<ebp>);
int __thiscall SEH_1006E990(void *this);
// void __usercall sub_10096B83(int a1@<ebp>);
// void __usercall sub_10096B92(int a1@<ebp>);
// void __usercall sub_10096BA0(int a1@<ebp>);
int __thiscall SEH_1006EA70(void *this);
// void __usercall sub_10096BB7(int a1@<ebp>);
// void __usercall sub_10096BBF(int a1@<ebp>);
// void __usercall sub_10096BCC(int a1@<ebp>);
// void __usercall sub_10096BD9(int a1@<ebp>);
int __thiscall SEH_10071220(void *this);
// void __usercall sub_10096BEE(int a1@<ebp>);
int __thiscall SEH_10075CE0(void *this);
// void __usercall sub_10096C03(int a1@<ebp>);
void sub_10096C0E();
int __thiscall SEH_10094100(void *this);
// void __usercall sub_10096C28(int a1@<ebp>);
int __thiscall SEH_10087610(void *this);
// void __usercall sub_10096C45(int a1@<ebp>);
int __thiscall SEH_10087B90(void *this);
// int __usercall sub_10096C57@<eax>(int a1@<ebp>);
// void __usercall sub_10096C6D(int a1@<ebp>);
int __thiscall SEH_10094540(void *this);
int __thiscall SEH_10094EB0(void *this);
// void __usercall sub_10096C96(int a1@<ebp>);
// int __usercall sub_10096CA3@<eax>(int a1@<ebp>);
int __thiscall SEH_100616D0(void *this);
// void __usercall sub_10096CC3(int a1@<ebp>);
// void __usercall sub_10096CD0(int a1@<ebp>);
// void __usercall sub_10096CDD(int a1@<ebp>);
// void __usercall sub_10096CEA(int a1@<ebp>);
// void __usercall sub_10096CF7(int a1@<ebp>);
// void __usercall sub_10096D04(int a1@<ebp>);
int __thiscall sub_10096D11(void *this);
// void __usercall sub_10096D1B(int a1@<ebp>);
// void __usercall sub_10096D28(int a1@<ebp>);
// void __usercall sub_10096D33(int a1@<ebp>);
int __thiscall SEH_100630D0(void *this);
// void __usercall sub_10096D4A(int a1@<ebp>);
// void __usercall sub_10096D59(int a1@<ebp>);
// void __usercall sub_10096D67(int a1@<ebp>);
int __thiscall SEH_1006C0C0(void *this);
// void __usercall sub_10096D7E(int a1@<ebp>);
int __thiscall SEH_1006EC50(void *this);
// void __usercall sub_10096D90(int a1@<ebp>);
// void __usercall sub_10096D9B(int a1@<ebp>);
int __thiscall SEH_1006F060(void *this);
// int __usercall sub_10096DB2@<eax>(int a1@<ebp>);
// void __usercall sub_10096DC8(int a1@<ebp>);
// void __usercall sub_10096DD3(int a1@<ebp>);
int __thiscall sub_10096DDE(void *this);
// void __usercall sub_10096DE8(int a1@<ebp>);
// void __usercall sub_10096DF0(int a1@<ebp>);
// void __usercall sub_10096DFD(int a1@<ebp>);
// void __usercall sub_10096E0A(int a1@<ebp>);
// BOOL __usercall sub_10096E15@<eax>(int a1@<ebp>);
int __thiscall SEH_10072060(void *this);
// void __usercall sub_10096E2E(int a1@<ebp>);
// void __usercall sub_10096E36(int a1@<ebp>);
// void __usercall sub_10096E3E(int a1@<ebp>);
// void __usercall sub_10096E46(int a1@<ebp>);
int __thiscall SEH_10076260(void *this);
// void __usercall sub_10096E5A(int a1@<ebp>);
// void __usercall sub_10096E62(int a1@<ebp>);
// void __usercall sub_10096E6A(int a1@<ebp>);
// void __usercall sub_10096E72(int a1@<ebp>);
int __thiscall SEH_10076420(void *this);
// void __usercall sub_10096E86(int a1@<ebp>);
// void __usercall sub_10096E91(int a1@<ebp>);
// void __usercall sub_10096E9C(int a1@<ebp>);
// void __usercall sub_10096EA7(int a1@<ebp>);
// void __usercall sub_10096EB2(int a1@<ebp>);
// void __usercall sub_10096EBD(int a1@<ebp>);
// void __usercall sub_10096EC8(int a1@<ebp>);
// void __usercall sub_10096ED3(int a1@<ebp>);
int __thiscall SEH_10076610(void *this);
// void __usercall sub_10096EEA(int a1@<ebp>);
// void __usercall sub_10096EF5(int a1@<ebp>);
// void __usercall sub_10096F00(int a1@<ebp>);
// void __usercall sub_10096F0B(int a1@<ebp>);
// void __usercall sub_10096F16(int a1@<ebp>);
// void __usercall sub_10096F21(int a1@<ebp>);
// void __usercall sub_10096F2C(int a1@<ebp>);
// void __usercall sub_10096F37(int a1@<ebp>);
int __thiscall SEH_10076E80(void *this);
// void __usercall sub_10096F4E(int a1@<ebp>);
// int __usercall sub_10096F59@<eax>(int a1@<ebp>);
// void __usercall sub_10096F6F(int a1@<ebp>);
// int __usercall sub_10096F7A@<eax>(int a1@<ebp>);
// void __usercall sub_10096F90(int a1@<ebp>);
// void __usercall sub_10096F9B(int a1@<ebp>);
// void __usercall sub_10096FA6(int a1@<ebp>);
// void __usercall sub_10096FB1(int a1@<ebp>);
int __thiscall SEH_10077800(void *this);
int __thiscall SEH_10087C90(void *this);
// void __usercall sub_10096FD7(int a1@<ebp>);
// int __usercall sub_10096FE2@<eax>(int a1@<ebp>);
int __thiscall SEH_10063CB0(void *this);
// int __usercall sub_10097002@<eax>(int a1@<ebp>);
// int __usercall sub_10097018@<eax>(int a1@<ebp>);
// void __usercall sub_1009702B(int a1@<ebp>);
int __thiscall SEH_1006C250(void *this);
// void __usercall sub_10097040(int a1@<ebp>);
// void __usercall sub_1009704B(int a1@<ebp>);
int __thiscall SEH_1006C8E0(void *this);
// void __usercall sub_10097062(int a1@<ebp>);
// int __usercall sub_1009706D@<eax>(int a1@<ebp>);
// void __usercall sub_10097083(int a1@<ebp>);
int __thiscall SEH_10078240(void *this);
// void __usercall sub_10097098(int a1@<ebp>);
// int __usercall sub_100970A3@<eax>(int a1@<ebp>);
// void __usercall sub_100970B9(int a1@<ebp>);
int __thiscall SEH_10078C00(void *this);
// int __usercall sub_100970CE@<eax>(int a1@<ebp>);
// void __usercall sub_100970E1(int a1@<ebp>);
int __thiscall sub_100970E9(void *this);
// int __usercall sub_100970F3@<eax>(int a1@<ebp>);
// void __usercall sub_10097106(int a1@<ebp>);
int __thiscall SEH_10079940(void *this);
// void __usercall sub_10097118(int a1@<ebp>);
// void __usercall sub_10097123(int a1@<ebp>);
int __thiscall SEH_10084890(void *this);
// void __usercall sub_10097138(int a1@<ebp>);
// void __usercall sub_10097143(int a1@<ebp>);
// void __usercall sub_1009714E(int a1@<ebp>);
int __thiscall SEH_10087F90(void *this);
// void __usercall sub_10097163(int a1@<ebp>);
// void __usercall sub_1009716B(int a1@<ebp>);
int __thiscall SEH_10088740(void *this);
// void __usercall sub_1009717D(int a1@<ebp>);
// void __usercall sub_10097188(int a1@<ebp>);
int __thiscall SEH_10088920(void *this);
// void __usercall sub_1009719D(int a1@<ebp>);
// void __usercall sub_100971A8(int a1@<ebp>);
int __thiscall sub_100971B3(void *this);
// void __usercall sub_100971BD(int a1@<ebp>);
// void __usercall sub_100971C8(int a1@<ebp>);
// void __usercall sub_100971D3(int a1@<ebp>);
int __thiscall sub_100971DE(void *this);
// void __usercall sub_100971E8(int a1@<ebp>);
// void __usercall sub_100971F5(int a1@<ebp>);
// void __usercall sub_10097202(int a1@<ebp>);
// void __usercall sub_1009720F(int a1@<ebp>);
// void __usercall sub_1009721C(int a1@<ebp>);
// void __usercall sub_10097229(int a1@<ebp>);
// void __usercall sub_10097236(int a1@<ebp>);
int __thiscall SEH_100864E0(void *this);
// void __usercall sub_1009724D(int a1@<ebp>);
int __thiscall sub_1009725A(void *this);
// void __usercall sub_10097264(int a1@<ebp>);
int __thiscall SEH_10092BE0(void *this);
// void __usercall sub_10097276(int a1@<ebp>);
// void __usercall sub_10097281(int a1@<ebp>);
// void __usercall sub_1009728C(int a1@<ebp>);
int __thiscall SEH_10065420(void *this);
// void __usercall sub_100972A3(int a1@<ebp>);
// void __usercall sub_100972AE(int a1@<ebp>);
// void __usercall sub_100972B9(int a1@<ebp>);
// void __usercall sub_100972C6(int a1@<ebp>);
void sub_100972D1();
int __thiscall SEH_1006FE20(void *this);
// BOOL __usercall sub_100972E6@<eax>(int a1@<ebp>);
int __thiscall sub_100972F0(void *this);
// void __usercall sub_100972FA(int a1@<ebp>);
// void __usercall sub_10097302(int a1@<ebp>);
int __thiscall sub_1009730A(void *this);
// void __usercall sub_10097314(int a1@<ebp>);
// int __usercall sub_1009731C@<eax>(int a1@<ebp>);
int __thiscall SEH_1008AC40(void *this);
// void __usercall sub_10097339(int a1@<ebp>);
int __thiscall SEH_1008B0C0(void *this);
// int __usercall sub_1009734B@<eax>(int a1@<ebp>);
// int __usercall sub_10097361@<eax>(int a1@<ebp>);
// void __usercall sub_10097377(int a1@<ebp>);
// void __usercall sub_1009737F(int a1@<ebp>);
// void __usercall sub_10097387(int a1@<ebp>);
// void __usercall sub_1009738F(int a1@<ebp>);
int __thiscall SEH_1007A2D0(void *this);
// void __usercall sub_100973A3(int a1@<ebp>);
int __thiscall SEH_1008B1D0(void *this);
int __thiscall sub_100973BA(void *this);
// void __usercall sub_100973C4(int a1@<ebp>);
// void __usercall sub_100973CC(int a1@<ebp>);
// void __usercall sub_100973D4(int a1@<ebp>);
// void __usercall sub_100973DC(int a1@<ebp>);
int __thiscall SEH_10072420(void *this);
// void __usercall sub_100973F0(int a1@<ebp>);
// void __usercall sub_100973FB(int a1@<ebp>);
int __thiscall SEH_10036930(void *this);
// void __usercall sub_10097410(int a1@<ebp>);
// int __usercall sub_1009741B@<eax>(int a1@<ebp>);
// void __usercall sub_10097431(int a1@<ebp>);
// void __usercall sub_1009743C(int a1@<ebp>);
// void __usercall sub_10097447(int a1@<ebp>);
// void __usercall sub_10097452(int a1@<ebp>);
int __thiscall SEH_10032D20(void *this);
int __cdecl sub_10097470(int a1, int a2);
// void __usercall sub_10097490(int a1@<ebp>);
int __cdecl sub_1009749C(int a1, int a2);
// void __usercall sub_100974C0(int a1@<ebp>);
// void __usercall sub_100974CC(int a1@<ebp>);
int __cdecl sub_100974D4(int a1, int a2);
// void __usercall sub_100974F0(int a1@<ebp>);
int __cdecl sub_100974F8(int a1, int a2);
int __cdecl sub_10097520(int a1, int a2);
// void __usercall sub_10097540(int a1@<ebp>);
int __thiscall SEH_10049FB0(void *this);
// void __usercall sub_10097560(int a1@<ebp>);
int __thiscall SEH_1003F520(void *this);
// void __usercall sub_10097580(int a1@<ebp>);
int __thiscall SEH_1003F290(void *this);
// void __usercall sub_100975A0(int a1@<ebp>);
int __thiscall sub_100975AB(void *this);
// void __usercall sub_100975C0(int a1@<ebp>);
int __thiscall sub_100975CB(void *this);
// void __usercall sub_100975E0(int a1@<ebp>);
// void __usercall sub_100975EB(int a1@<ebp>);
// void __usercall sub_100975F6(int a1@<ebp>);
// void __usercall sub_10097601(int a1@<ebp>);
int __thiscall SEH_10032BC0(void *this);
// void __usercall sub_10097620(int a1@<ebp>);
// void __usercall sub_1009762A(int a1@<ebp>);
int __thiscall SEH_10032890(void *this);
// void __usercall sub_10097650(int a1@<ebp>);
int __thiscall SEH_100323F0(void *this);
// int __usercall sub_10097670@<eax>(int a1@<ebp>);
void sub_10097678();
void sub_10097683();
int __cdecl sub_1009768B(int a1, int a2);
// void __usercall sub_100976C0(int a1@<ebp>);
// void __usercall sub_100976F0(int a1@<ebp>);
int __cdecl sub_100976FC(int a1, int a2);
// void __usercall sub_10097720(int a1@<ebp>);
int __cdecl sub_1009772C(int a1, int a2);
// void __usercall sub_10097750(int a1@<ebp>);
int __cdecl sub_1009775C(int a1, int a2);
// void __usercall sub_10097780(int a1@<ebp>);
// void __usercall sub_1009778C(int a1@<ebp>);
// void __usercall sub_10097798(int a1@<ebp>);
// void __usercall sub_100977A4(int a1@<ebp>);
// void __usercall sub_100977B0(int a1@<ebp>);
int __cdecl sub_100977BC(int a1, int a2);
// void __usercall sub_100977E0(int a1@<ebp>);
int __cdecl sub_100977E8(int a1, int a2);
// void __usercall sub_10097810(int a1@<ebp>);
int __cdecl sub_10097818(int a1, int a2);
void sub_10097840();
void sub_1009784B();
void sub_10097856();
int __cdecl sub_10097861(int a1, int a2);
void sub_10097890();
void sub_1009789B();
void sub_100978A6();
// void __usercall sub_100978B1(int a1@<ebp>);
// void __usercall sub_100978C0(int a1@<ebp>);
void sub_100978CB();
void sub_100978D6();
void sub_100978E1();
// void __usercall sub_100978EC(int a1@<ebp>);
// void __usercall sub_100978FB(int a1@<ebp>);
int __cdecl sub_10097906(int a1, int a2);
// void __usercall sub_10097940(int a1@<ebp>);
int __cdecl sub_1009794C(int a1, int a2);
// void __usercall sub_10097970(int a1@<ebp>);
// void __usercall sub_1009797A(int a1@<ebp>);
// void __usercall sub_10097985(int a1@<ebp>);
int __thiscall SEH_10041700(void *this);
// void __usercall sub_100979A0(int a1@<ebp>);
// void __usercall sub_100979AA(int a1@<ebp>);
// void __usercall sub_100979B5(int a1@<ebp>);
int __thiscall SEH_10041510(void *this);
// void __usercall sub_100979D0(int a1@<ebp>);
int __thiscall SEH_10040BA0(void *this);
// void __usercall sub_100979F0(int a1@<ebp>);
// void __usercall sub_100979F8(int a1@<ebp>);
// void __usercall sub_10097A03(int a1@<ebp>);
// void __usercall sub_10097A0E(int a1@<ebp>);
// void __usercall sub_10097A19(int a1@<ebp>);
int __thiscall SEH_1003EAE0(void *this);
// void __usercall sub_10097A30(int a1@<ebp>);
int __thiscall SEH_10038CE0(void *this);
// void __usercall sub_10097A50(int a1@<ebp>);
// void __usercall sub_10097A58(int a1@<ebp>);
// void __usercall sub_10097A63(int a1@<ebp>);
// void __usercall sub_10097A6E(int a1@<ebp>);
// void __usercall sub_10097A79(int a1@<ebp>);
int __thiscall SEH_10036FD0(void *this);
// void __usercall sub_10097A90(int a1@<ebp>);
// void __usercall sub_10097A98(int a1@<ebp>);
// void __usercall sub_10097AA3(int a1@<ebp>);
// void __usercall sub_10097AAE(int a1@<ebp>);
// void __usercall sub_10097AB9(int a1@<ebp>);
int __thiscall SEH_10036E20(void *this);
// void __usercall sub_10097AD0(int a1@<ebp>);
// void __usercall sub_10097ADA(int a1@<ebp>);
// void __usercall sub_10097AE9(int a1@<ebp>);
int __thiscall SEH_10032780(void *this);
// void *__usercall sub_10097B00@<eax>(int a1@<ebp>);
int __cdecl sub_10097B0B(int a1, int a2);
// void __usercall sub_10097B30(int a1@<ebp>);
int __cdecl sub_10097B3B(int a1, int a2);
// void __usercall sub_10097B60(int a1@<ebp>);
void sub_10097B6B();
int __cdecl sub_10097B73(int a1, int a2);
void sub_10097B90();
int __thiscall SEH_10048910(void *this);
// void __usercall sub_10097BB0(int a1@<ebp>);
// void __usercall sub_10097BBB(int a1@<ebp>);
int __thiscall SEH_10047DD0(void *this);
int __thiscall SEH_1004BB90(void *this);
void sub_10097BE0();
int __thiscall SEH_10047C10(void *this);
// void __usercall sub_10097C00(int a1@<ebp>);
// void __usercall sub_10097C0B(int a1@<ebp>);
int __thiscall SEH_10046830(void *this);
// void __usercall sub_10097C20(int a1@<ebp>);
int __thiscall SEH_10043320(void *this);
// void __usercall sub_10097C40(int a1@<ebp>);
int __thiscall SEH_10042D20(void *this);
// void __usercall sub_10097C60(int a1@<ebp>);
// void __usercall sub_10097C6A(int a1@<ebp>);
// void __usercall sub_10097C75(int a1@<ebp>);
int __thiscall SEH_10041960(void *this);
// void __usercall sub_10097C90(int a1@<ebp>);
// void __usercall sub_10097C9A(int a1@<ebp>);
// void __usercall sub_10097CA5(int a1@<ebp>);
int __thiscall SEH_100417D0(void *this);
// void __usercall sub_10097CC0(int a1@<ebp>);
int __thiscall SEH_100416A0(void *this);
// void __usercall sub_10097CE0(int a1@<ebp>);
// void __usercall sub_10097CEA(int a1@<ebp>);
// void __usercall sub_10097CF5(int a1@<ebp>);
int __thiscall SEH_10041440(void *this);
void sub_10097D10();
int __thiscall sub_10097D1D(void *this);
int __thiscall SEH_1003E3D0(void *this);
void sub_10097D50();
int __thiscall SEH_10046720(void *this);
// void __usercall sub_10097D70(int a1@<ebp>);
int __thiscall SEH_100388E0(void *this);
// void __usercall sub_10097D90(int a1@<ebp>);
int __thiscall sub_10097D9D(void *this);
// void __usercall sub_10097DB5(int a1@<ebp>);
int __thiscall SEH_100343F0(void *this);
// void __usercall sub_10097DD0(int a1@<ebp>);
// void __usercall sub_10097DDD(int a1@<ebp>);
// void __usercall sub_10097DEC(int a1@<ebp>);
int __thiscall SEH_10033BD0(void *this);
// void __usercall sub_10097E10(int a1@<ebp>);
// int __usercall sub_10097E1B@<eax>(int a1@<ebp>);
// int __usercall sub_10097E33@<eax>(int a1@<ebp>);
// void __usercall sub_10097E4B(int a1@<ebp>);
// void __usercall sub_10097E59(int a1@<ebp>);
// void __usercall sub_10097E67(int a1@<ebp>);
int __cdecl sub_10097E75(int a1, int a2);
// void __usercall sub_10097E90(int a1@<ebp>);
// int __usercall sub_10097E9B@<eax>(int a1@<ebp>);
int __cdecl sub_10097EB3(int a1, int a2);
// void __usercall sub_10097ED0(int a1@<ebp>);
int __cdecl sub_10097ED8(int a1, int a2);
int __cdecl sub_10097F05(int a1, int a2);
void sub_10097F20();
void sub_10097F28();
// void __usercall sub_10097F30(int a1@<ebp>);
int __cdecl sub_10097F3D(int a1, int a2);
int __cdecl sub_10097F60(int a1, int a2);
// void __usercall sub_10097F80(int a1@<ebp>);
int __cdecl sub_10097F8B(int a1, int a2);
// void __usercall sub_10097FB0(int a1@<ebp>);
int __cdecl sub_10097FBB(int a1, int a2);
// void __usercall sub_10097FF0(int a1@<ebp>);
int __cdecl sub_10097FFC(int a1, int a2);
void sub_10098020();
int __thiscall SEH_10049CF0(void *this);
// void __usercall sub_10098040(int a1@<ebp>);
// void __usercall sub_1009804B(int a1@<ebp>);
int __thiscall SEH_10048A60(void *this);
// void __usercall sub_10098060(int a1@<ebp>);
// void __usercall sub_1009806B(int a1@<ebp>);
int __thiscall SEH_10044ED0(void *this);
// void __usercall sub_10098080(int a1@<ebp>);
// void __usercall sub_1009808B(int a1@<ebp>);
int __thiscall SEH_10043E90(void *this);
// void __usercall sub_100980A0(int a1@<ebp>);
int __thiscall SEH_100438D0(void *this);
void sub_100980C0();
int __thiscall sub_100980D0(void *this);
void sub_100980E0();
int __thiscall SEH_10041CA0(void *this);
// void __usercall sub_10098100(int a1@<ebp>);
int __thiscall SEH_1003CB20(void *this);
void sub_10098120();
int __thiscall SEH_10039DA0(void *this);
// void __usercall sub_10098140(int a1@<ebp>);
// int __usercall sub_1009814B@<eax>(int a1@<ebp>);
// int __usercall sub_10098161@<eax>(int a1@<ebp>);
int __thiscall SEH_10037E90(void *this);
// void __usercall sub_10098190(int a1@<ebp>);
// void __usercall sub_1009819D(int a1@<ebp>);
int __thiscall sub_100981AC(void *this);
// void __usercall sub_100981C0(int a1@<ebp>);
void sub_100981CB();
int __cdecl sub_100981D6(int a1, int a2);
// void __usercall sub_10098200(int a1@<ebp>);
int __cdecl sub_10098208(int a1, int a2);
// void __usercall sub_10098230(int a1@<ebp>);
void sub_1009823B();
int __cdecl sub_10098246(int a1, int a2);
// int __usercall sub_10098270@<eax>(int a1@<ebp>);
// void __usercall sub_100982A0(int a1@<ebp>);
int __cdecl sub_100982AB(int a1, int a2);
// void __usercall sub_100982D0(int a1@<ebp>);
// void __usercall sub_100982DB(int a1@<ebp>);
int __cdecl sub_100982ED(int a1, int a2);
// void __usercall sub_10098310(int a1@<ebp>);
int __cdecl sub_10098318(int a1, int a2);
void sub_10098340();
void sub_10098348();
// void __usercall sub_10098350(int a1@<ebp>);
int __cdecl sub_10098362(int a1, int a2);
int __cdecl sub_10098385(int a1, int a2);
void sub_100983A0();
int __cdecl sub_100983A8(int a1, int a2);
char sub_100983D0();
int sub_10098420();
int sub_10098430();
void __cdecl sub_10098450(); // idb
void __cdecl sub_100984A0(); // idb
// BOOL __stdcall CryptGetHashParam(HCRYPTHASH hHash, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags);
// BOOL __stdcall CryptHashData(HCRYPTHASH hHash, const BYTE *pbData, DWORD dwDataLen, DWORD dwFlags);
// BOOL __stdcall CryptReleaseContext(HCRYPTPROV hProv, DWORD dwFlags);
// BOOL __stdcall CryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash);
// BOOL __stdcall CryptAcquireContextW(HCRYPTPROV *phProv, LPCWSTR pszContainer, LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags);
// BOOL __stdcall CryptDestroyHash(HCRYPTHASH hHash);
// void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// HLOCAL __stdcall LocalAlloc(UINT uFlags, UINT uBytes);
// DWORD __stdcall GetLastError();
// void __stdcall Sleep(DWORD dwMilliseconds);
// HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// UINT __stdcall SetErrorMode(UINT uMode);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cchMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// BOOL __stdcall QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency);
// void __stdcall OutputDebugStringA(LPCSTR lpOutputString);
// void __stdcall DebugBreak();
// void __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const DWORD *lpArguments);
// void __stdcall InitializeSListHead(PSLIST_HEADER ListHead);
// PSINGLE_LIST_ENTRY __stdcall InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSINGLE_LIST_ENTRY ListEntry);
// PSINGLE_LIST_ENTRY __stdcall InterlockedPopEntrySList(PSLIST_HEADER ListHead);
// HANDLE __stdcall CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName);
// BOOL __stdcall InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
// LONG __stdcall InterlockedExchangeAdd(LPLONG Addend, LONG Value);
// LONG __stdcall InterlockedIncrement(LPLONG lpAddend);
// DWORD __stdcall GetCurrentThreadId();
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// BOOL __stdcall IsDebuggerPresent();
// LONG __stdcall InterlockedExchange(LPLONG Target, LONG Value);
// HANDLE __stdcall CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// HANDLE __stdcall CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);
// BOOL __stdcall ResetEvent(HANDLE hEvent);
// BOOL __stdcall ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// BOOL __stdcall SetEvent(HANDLE hEvent);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);
// void __cdecl std::_Xout_of_range(const char *); weak
// void __cdecl std::_Xlength_error(const char *); weak
// void __thiscall std::_Container_base0::_Orphan_all(std::_Container_base0 *__hidden this); weak
// int __cdecl beginthreadex(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void *__cdecl calloc(size_t, size_t);
// void *__cdecl expand(void *, size_t);
// size_t __cdecl msize(void *);
// int __cdecl puts(const char *);
// int sprintf_s(char *DstBuf, size_t SizeInBytes, const char *Format, ...);
// char *__cdecl strncpy(char *, const char *, size_t);
// int __cdecl stricmp(const char *, const char *);
// int __cdecl vswprintf_s(wchar_t *Dst, size_t SizeInWords, const wchar_t *Format, va_list ArgList);
// int __cdecl fgetpos(FILE *, fpos_t *);
// errno_t __cdecl wfopen_s(FILE **File, const wchar_t *Filename, const wchar_t *Mode);
// int printf(const char *, ...);
// size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
// int __cdecl fsetpos(FILE *, const fpos_t *);
// size_t __cdecl fread(void *, size_t, size_t, FILE *);
// int __cdecl fseek(FILE *, __int32, int);
// int __cdecl fclose(FILE *);
// int __cdecl vsprintf_s(char *DstBuf, size_t SizeInBytes, const char *Format, va_list ArgList);
// int __cdecl strncmp(const char *, const char *, size_t);
// void *__cdecl realloc(void *, size_t);
// int __cdecl strnicmp(const char *, const char *, size_t);
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *); weak
// void __cdecl free(void *);
// void *__cdecl memmove(void *, const void *, size_t);
// int std::exception::~exception(void); weak
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *); weak
// void *__cdecl malloc(size_t);
// void *__cdecl operator new(unsigned int); weak
// void __cdecl operator delete[](void *); weak
// void __cdecl operator delete(void *); weak
// double __cdecl ceil(double);
// int __cdecl endthreadex(_DWORD); weak
// int __cdecl fputs(const char *, FILE *);
// FILE *__cdecl _iob_func();
// void __cdecl __noreturn exit(int);
// FILE *__cdecl fopen(const char *, const char *);
// int __cdecl ferror(FILE *);
// void __cdecl __noreturn longjmp(jmp_buf, int);
// int __cdecl vsnprintf_s(char *DstBuf, size_t DstSize, size_t MaxCount, const char *Format, va_list ArgList);
// int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// int __thiscall GetProfile_alpha_slow(_DWORD); weak
// int __cdecl GetProfile_alpha_basic(_DWORD); weak
// int __thiscall GetProfile_alpha_fast(_DWORD); weak
// int __cdecl GetProfile_alpha_veryfast(_DWORD); weak
// int __thiscall GetProfile_alpha_ultrafast(_DWORD); weak
// int __cdecl CompressBlocksBC6H(_DWORD, _DWORD, _DWORD); weak
// int __thiscall GetProfile_bc6h_veryslow(_DWORD); weak
// int __cdecl GetProfile_bc6h_slow(_DWORD); weak
// int __thiscall GetProfile_bc6h_basic(_DWORD); weak
// int __thiscall GetProfile_bc6h_veryfast(_DWORD); weak
// int __cdecl CompressBlocksBC7(_DWORD, _DWORD, _DWORD); weak
// int __thiscall GetProfile_bc6h_fast(_DWORD); weak
// void __cdecl compress_image(struct Image *, _DWORD, void (__cdecl *)(struct BlockUserData_t *), struct Texture *, _DWORD, float, float); weak
// int __cdecl get_number_of_texture_formats(); weak
// void __cdecl destroy_texture(struct Texture *); weak
// void __cdecl destroy_image(struct Image *); weak
// void __cdecl copy_image_to_uncompressed_texture(struct Image *, _DWORD, struct Texture *); weak
// void __cdecl convert_image_to_8_bit_format(struct Image *, _DWORD, _DWORD); weak
// void __cdecl convert_texture_to_image(struct Texture *, struct Image *); weak
// void __cdecl set_texture_decoding_function(struct Texture *, struct Image *); weak
// struct TextureInfo *__cdecl match_texture_type(_DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

__int16 _ImageBase = 23117; // weak
__int16 word_10000002 = 144; // weak
_UNKNOWN loc_1000A800; // weak
// extern _UNKNOWN loc_10014DE0; weak
_UNKNOWN loc_100150D0; // weak
_UNKNOWN ClassDatabaseType::ClassDatabaseType; // weak
_UNKNOWN loc_100179C0; // weak
_UNKNOWN loc_100216C0; // weak
_UNKNOWN loc_1002A790; // weak
_UNKNOWN loc_10032270; // weak
_UNKNOWN loc_10032350; // weak
_UNKNOWN loc_10032CF0; // weak
_UNKNOWN loc_100330B0; // weak
_UNKNOWN loc_100368B0; // weak
_UNKNOWN loc_10036D70; // weak
_UNKNOWN loc_10036FB0; // weak
_UNKNOWN loc_1003F6E0; // weak
_UNKNOWN loc_10041B90; // weak
_UNKNOWN loc_10042C20; // weak
_UNKNOWN loc_10043220; // weak
_UNKNOWN loc_100437D0; // weak
_UNKNOWN loc_10043DC0; // weak
_UNKNOWN loc_10043E00; // weak
_UNKNOWN loc_10043E60; // weak
_UNKNOWN loc_10047BB0; // weak
_UNKNOWN loc_10091110; // weak
char aUnityweb[] = "UnityWeb"; // idb
char aUnityraw[] = "UnityRaw"; // idb
_UNKNOWN unk_100996C3; // weak
int (__stdcall *off_10099840)(char) = &sub_100042A0; // weak
char byte_10099848[] = { '\0' }; // weak
int dword_10099860[] = { 0 }; // weak
int dword_10099890[] = { 7 }; // weak
int dword_100998C0[] = { 8 }; // weak
int dword_100998F0[] = { 9 }; // weak
char aBox[4] = "box"; // idb
int off_10099948 = 268806656; // idb
float flt_1009994C[] = {  0.5 }; // weak
char byte_10099BA8[] = { '\x11' }; // weak
_BYTE byte_10099BBC[4] = { 16, 0, 0, 0 }; // idb
_UNKNOWN unk_1009AEE4; // weak
_UNKNOWN unk_1009AEE8; // weak
_UNKNOWN unk_1009AEEC; // weak
_UNKNOWN unk_1009B5F0; // weak
_UNKNOWN unk_1009B5F8; // weak
_UNKNOWN unk_1009B604; // weak
_UNKNOWN unk_1009B618; // weak
_UNKNOWN unk_1009B638; // weak
_UNKNOWN unk_1009B63C; // weak
_UNKNOWN unk_1009B640; // weak
_UNKNOWN unk_1009B649; // weak
_UNKNOWN unk_1009B697; // weak
char byte_1009C524[] = { '\x02' }; // weak
int dword_1009C528[] = { 4294967288 }; // weak
_UNKNOWN unk_1009C530; // weak
_UNKNOWN unk_1009C5A0; // weak
char byte_1009C5A8[] = { '\x03' }; // weak
_UNKNOWN unk_1009C5B0; // weak
_UNKNOWN unk_1009C5F2; // weak
_UNKNOWN unk_1009C638; // weak
int dword_1009DE08[] = { 4294967288 }; // weak
char byte_1009F8A4[] = { '\0' }; // weak
char byte_1009F8AC[] = { '\0' }; // weak
char byte_1009F8B4[] = { '\0' }; // weak
char byte_1009F8BC[] = { '\0' }; // weak
char byte_1009F8C0[] = { '\0' }; // weak
char byte_1009F8C4[] = { '\x01' }; // weak
char byte_1009F8CC[] = { '\x01' }; // weak
_UNKNOWN unk_1009FB54; // weak
_UNKNOWN unk_1009FC10; // weak
_UNKNOWN unk_100A0210; // weak
_UNKNOWN unk_100A0810; // weak
_UNKNOWN unk_100A0E10; // weak
int dword_100A1410[] = { 0 }; // weak
int dword_100A1440[] = { 7 }; // weak
int dword_100A1470[] = { 8 }; // weak
int dword_100A14A0[] = { 9 }; // weak
char byte_100A15E8[] = { '\x11' }; // weak
char byte_100A1600[] = { '\0' }; // weak
char byte_100A160C[] = { '\0' }; // weak
char aAabb[5] = "AABB"; // weak
void *off_100A1D64 = &purecall; // weak
int (*off_100A1D8C)() = &sub_100150C0; // weak
unsigned __int32 (__thiscall *off_100A1DB4)(AssetFile *__hidden this) = &AssetFile::GetFileDataIndex; // weak
unsigned __int32 (__thiscall *off_100A1DDC)(AssetFile *__hidden this) = &AssetFile::GetFileDataIndex; // weak
unsigned __int32 (__thiscall *off_100A1E04)(AssetFile *__hidden this) = &AssetFile::GetFileDataIndex; // weak
void *off_100A1FAC = &purecall; // weak
int (*off_100A1FDC)() = &sub_10014EE0; // weak
int (*off_100A200C)() = &sub_100150C0; // weak
unsigned __int32 (__thiscall *off_100A203C)(AssetFile *__hidden this) = &AssetFile::GetFileDataIndex; // weak
unsigned __int32 (__thiscall *off_100A206C)(AssetFile *__hidden this) = &AssetFile::GetFileDataIndex; // weak
unsigned __int32 (__thiscall *off_100A209C)(AssetFile *__hidden this) = &AssetFile::GetFileDataIndex; // weak
int dword_100A2308[] = { 0 }; // weak
int dword_100A4308[] = { 0 }; // weak
__int16 word_100A4408[] = { 0 }; // weak
__int16 word_100A4760[] = { 0 }; // weak
char byte_100A4B60[] = { '\x18' }; // weak
int (__stdcall *off_100A4D64)(char) = &sub_1002CFD0; // weak
int (__stdcall *off_100A4D74)(char) = &sub_1002CFD0; // weak
int (__stdcall *off_100A4D84)(char) = &sub_1002CFD0; // weak
int (__stdcall *off_100A4D94)(char) = &sub_1002CFD0; // weak
int (__stdcall *off_100A4DB0)(char) = &sub_100322F0; // weak
int (__stdcall *off_100A4DE4)(char) = &sub_10032760; // weak
int dword_100A4EB8[] = { 589824 }; // weak
float flt_100A4EC8 =  0.0; // weak
_UNKNOWN unk_100A4ECC; // weak
_UNKNOWN unk_100A4EF0; // weak
_UNKNOWN unk_100A4EFC; // weak
_UNKNOWN unk_100A4F0C; // weak
_UNKNOWN unk_100A4F14; // weak
int (__thiscall *off_100A4F34)(void *, int, int, int) = &sub_10041070; // weak
int dword_100A4F38[] = { 3 }; // weak
int dword_100A4F48[] = { 0 }; // weak
int dword_100A4F58[] = { 9 }; // weak
int (__stdcall *off_100A4FF4)(char) = &sub_100368C0; // weak
int (__stdcall *off_100A5010)(char) = &sub_10036900; // weak
_UNKNOWN unk_100A502C; // weak
int (__stdcall *off_100A5030)(char) = &sub_10036D50; // weak
int dword_100A504C[] = { 0 }; // weak
int (__stdcall *off_100A505C)(char) = &sub_10041130; // weak
int (__stdcall *off_100A5064)(char) = &sub_10041360; // weak
_UNKNOWN unk_100A5D88; // weak
_UNKNOWN unk_100A5EA0; // weak
int __security_cookie = 3141592654; // weak
int (__cdecl *off_100AD048)(_DWORD, _DWORD) = &sub_10093FF0; // weak
int (__cdecl *off_100AD04C)(_DWORD, _DWORD) = &sub_10093FC0; // weak
int dword_100AD050[] = { 1 }; // weak
_UNKNOWN unk_100AD064; // weak
_UNKNOWN unk_100AD2F0; // weak
_UNKNOWN unk_100AD2F4; // weak
int dword_100AD2F8[] = { 8 }; // weak
int dword_100AD2FC[] = { 8 }; // weak
char byte_100AD3B7 = '\x01'; // weak
int dword_100AD974 = 1; // weak
int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &sub_10092870; // weak
int (__cdecl *off_100ADB84)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &sub_1001CB90; // weak
int (__cdecl *off_100ADB88)(void *) = &sub_1001CC40; // weak
_UNKNOWN unk_100ADF64; // weak
char byte_100ADF84[] = { '\x01' }; // weak
int (__cdecl *off_100ADF8C)(_DWORD, _DWORD) = &sub_10016720; // weak
int (__cdecl *off_100ADF90)(_DWORD, _DWORD) = &sub_10006560; // weak
int (__cdecl *off_100ADF94)(int, size_t) = &sub_10016720; // weak
int (__cdecl *off_100ADF98)(_DWORD, _DWORD) = &sub_10006560; // weak
_UNKNOWN unk_100ADF9C; // weak
char byte_100AE384[] = { '\xFF' }; // weak
char byte_100AE385[] = { 'Z' }; // weak
char byte_100AE386[] = { ' ' }; // weak
char byte_100AE387[] = { '\xFF' }; // weak
int dword_100AE614[] = { 1 }; // weak
int dword_100AE618[] = { 2 }; // weak
int dword_100AE624[] = { 1 }; // weak
int dword_100AE628[] = { 2 }; // weak
_UNKNOWN unk_100AE9CC; // weak
int dword_100AE9DC; // weak
int (__stdcall *dword_100AE9E0)(_DWORD, _DWORD); // weak
int (__stdcall *dword_100AE9E4)(_DWORD, _DWORD); // weak
int dword_100AE9EC; // weak
int dword_100AE9F4; // weak
char byte_100AE9F8; // weak
char byte_100AE9F9; // weak
char byte_100AEA00[]; // weak
char byte_100AEB10[]; // weak
char byte_100AEC20[]; // weak
char byte_100AEC21[]; // weak
char byte_100AEE20[]; // weak
char byte_100AEE21[]; // weak
char byte_100AF020[]; // weak
char byte_100AF021[]; // weak
char byte_100AF220[]; // weak
char byte_100AF221[]; // weak
char byte_100AF420[]; // weak
char byte_100AF460[]; // weak
_UNKNOWN unk_100AF480; // weak
_UNKNOWN unk_100B7480; // weak
char byte_100BF488[]; // weak
int dword_100BF590[]; // weak
int dword_100BF5AC; // weak
LPCRITICAL_SECTION lpCriticalSection; // idb
double dbl_100BF5B8; // weak
LARGE_INTEGER Frequency; // idb
LARGE_INTEGER PerformanceCount; // idb
float flt_100BF794[]; // weak
_UNKNOWN unk_100C1798; // weak
int dword_100C17A0; // weak
void *dword_100C17A4; // idb
int dword_100C17A8; // weak
_UNKNOWN unk_100C17B0; // weak
int dword_100C17B4; // weak


//----- (10001000) --------------------------------------------------------
signed int __usercall sub_10001000@<eax>(int a1@<eax>)
{
  signed int result; // eax@2

  switch ( *(_DWORD *)a1 )
  {
    case 0xA:
      result = (signed int)*(float *)(a1 + 8);
      break;
    case 0xB:
      result = (signed int)*(double *)(a1 + 8);
      break;
    case 0xC:
    case 0xD:
    case 0xE:
      result = 0;
      break;
    case 2:
      result = *(_BYTE *)(a1 + 8);
      break;
    case 4:
      result = *(_WORD *)(a1 + 8);
      break;
    default:
      result = *(_DWORD *)(a1 + 8);
      break;
  }
  return result;
}

//----- (10001070) --------------------------------------------------------
int __thiscall sub_10001070(int this)
{
  int result; // eax@2

  switch ( *(_DWORD *)this )
  {
    case 0xA:
      result = (signed __int64)*(float *)(this + 8);
      break;
    case 0xB:
      result = (signed __int64)*(double *)(this + 8);
      break;
    case 0xC:
    case 0xD:
    case 0xE:
      result = 0;
      break;
    default:
      result = *(_DWORD *)(this + 8);
      break;
  }
  return result;
}

//----- (100010F0) --------------------------------------------------------
unsigned __int64 __thiscall sub_100010F0(int this)
{
  unsigned __int64 result; // rax@2

  switch ( *(_DWORD *)this )
  {
    case 0xA:
      result = (unsigned __int64)*(float *)(this + 8);
      break;
    case 0xB:
      result = (unsigned __int64)*(double *)(this + 8);
      break;
    case 0xC:
    case 0xD:
    case 0xE:
      result = 0i64;
      break;
    case 2:
      result = *(_BYTE *)(this + 8);
      break;
    case 4:
      result = *(_WORD *)(this + 8);
      break;
    case 6:
      result = *(_DWORD *)(this + 8);
      break;
    default:
      result = *(_QWORD *)(this + 8);
      break;
  }
  return result;
}

//----- (10001170) --------------------------------------------------------
void __thiscall AssetBundleAsset::FlushChanges(AssetBundleAsset *this)
{
  AssetBundleAsset *v1; // edi@1
  int v2; // eax@3
  void *v3; // ecx@4
  struct AssetTypeValueField *v4; // eax@6
  int v5; // ecx@6
  struct AssetTypeValueField *v6; // esi@7
  unsigned int v7; // ebx@12
  struct AssetTypeValueField **v8; // eax@13
  int v9; // edx@14
  int v10; // esi@14
  int v11; // eax@14
  int v12; // edi@15
  char *v13; // eax@16
  int v14; // edx@16
  int v15; // eax@16
  int v16; // ecx@16
  int v17; // edx@16
  int v18; // eax@16
  int v19; // ecx@16
  int v20; // edx@16
  int v21; // eax@17
  _DWORD *v22; // eax@21
  unsigned int *v23; // eax@23
  unsigned int v24; // ebx@26
  char *v25; // ST0C_4@28
  unsigned int v26; // eax@28
  struct AssetTypeValueField *v27; // eax@29
  int v28; // ecx@33
  int v29; // eax@37
  int v30; // edx@37
  int v31; // ecx@37
  int v32; // edx@37
  int v33; // ecx@37
  unsigned int v34; // eax@37
  struct AssetTypeValueField *v35; // eax@38
  unsigned int v36; // ecx@42
  int v37; // eax@46
  int v38; // edx@46
  int v39; // ecx@46
  int v40; // edx@46
  _DWORD *v41; // eax@47
  int v42; // ecx@47
  _DWORD *v43; // edi@48
  unsigned int v44; // eax@52
  struct AssetTypeValueField **v45; // eax@53
  int v46; // ecx@54
  int v47; // esi@54
  int v48; // eax@54
  struct AssetTypeValueField **v49; // edx@54
  int v50; // ebx@55
  int v51; // esi@55
  int v52; // ecx@56
  int v53; // ecx@56
  int v54; // ecx@56
  int v55; // ecx@56
  struct AssetTypeValueField **v56; // ecx@56
  int v57; // edx@58
  int v58; // ecx@58
  int v59; // edx@58
  int v60; // eax@58
  int v61; // edx@58
  int v62; // ecx@58
  int v63; // edx@58
  int v64; // eax@58
  int v65; // edx@58
  int v66; // ecx@58
  int v67; // edx@58
  int v68; // ecx@58
  int v69; // edx@58
  int v70; // ecx@58
  int v71; // edx@58
  int v72; // ecx@58
  struct AssetTypeValueField *v73; // eax@58
  int v74; // edx@58
  int v75; // ecx@58
  int v76; // edx@58
  int v77; // edi@59
  _DWORD *v78; // ecx@63
  unsigned int *v79; // ecx@65
  int v80; // esi@69
  void *v81; // eax@70
  unsigned int v82; // eax@72
  _DWORD *v83; // eax@73
  int v84; // ecx@77
  int v85; // eax@81
  int v86; // ecx@81
  int v87; // edx@81
  int v88; // ecx@81
  void *v89; // ST0C_4@81
  unsigned int v90; // eax@81
  void *v91; // eax@82
  unsigned int v92; // ecx@86
  int v93; // ecx@90
  int v94; // eax@94
  int v95; // edx@94
  int v96; // ecx@94
  int v97; // edx@94
  int v98; // edx@94
  unsigned int v99; // eax@94
  void *v100; // eax@95
  unsigned int v101; // ecx@99
  unsigned int v102; // ecx@103
  int v103; // eax@107
  int v104; // ecx@107
  int v105; // edx@107
  int v106; // ecx@107
  int v107; // edx@107
  unsigned int v108; // eax@107
  void *v109; // eax@108
  unsigned int v110; // ecx@112
  unsigned int v111; // ecx@116
  int v112; // ecx@120
  int v113; // eax@124
  int v114; // edx@124
  int v115; // ecx@124
  int v116; // edx@124
  void *v117; // ST0C_4@124
  unsigned int v118; // eax@124
  void *v119; // eax@125
  unsigned int v120; // ecx@129
  unsigned int v121; // ecx@133
  unsigned int v122; // ecx@137
  int v123; // eax@141
  int v124; // edx@141
  int v125; // ecx@141
  int v126; // edx@141
  AssetBundleAsset *v127; // [sp+Ch] [bp-6Ch]@1
  struct AssetTypeValueField *v128; // [sp+10h] [bp-68h]@7
  struct AssetTypeValueField *v129; // [sp+10h] [bp-68h]@55
  int v130; // [sp+14h] [bp-64h]@15
  int v131; // [sp+14h] [bp-64h]@55
  unsigned int v132; // [sp+14h] [bp-64h]@68
  struct AssetTypeValueField **v133; // [sp+18h] [bp-60h]@15
  struct AssetTypeValueField **v134; // [sp+18h] [bp-60h]@27
  struct AssetTypeValueField **v135; // [sp+18h] [bp-60h]@53
  unsigned int v136; // [sp+1Ch] [bp-5Ch]@14
  unsigned int v137; // [sp+1Ch] [bp-5Ch]@54
  struct AssetTypeValueField **v138; // [sp+20h] [bp-58h]@13
  int v139; // [sp+24h] [bp-54h]@6
  struct AssetTypeValueField **v140; // [sp+24h] [bp-54h]@54
  int v141; // [sp+28h] [bp-50h]@16
  int v142; // [sp+2Ch] [bp-4Ch]@16
  int v143; // [sp+30h] [bp-48h]@16
  int v144; // [sp+34h] [bp-44h]@16
  int v145; // [sp+38h] [bp-40h]@16
  int v146; // [sp+3Ch] [bp-3Ch]@16
  int v147; // [sp+40h] [bp-38h]@16
  int v148; // [sp+44h] [bp-34h]@16
  int v149; // [sp+48h] [bp-30h]@58
  int v150; // [sp+4Ch] [bp-2Ch]@58
  int v151; // [sp+50h] [bp-28h]@58
  int v152; // [sp+54h] [bp-24h]@58
  int v153; // [sp+58h] [bp-20h]@58
  int v154; // [sp+5Ch] [bp-1Ch]@58
  int v155; // [sp+60h] [bp-18h]@58
  int v156; // [sp+64h] [bp-14h]@58
  int v157; // [sp+68h] [bp-10h]@58
  int v158; // [sp+6Ch] [bp-Ch]@58
  int v159; // [sp+70h] [bp-8h]@58
  int v160; // [sp+74h] [bp-4h]@58

  v1 = this;
  v127 = this;
  if ( *((_BYTE *)this + 1) && *((_DWORD *)this + 1) == -1 )
  {
    v2 = *((_DWORD *)this + 2);
    if ( *(_DWORD *)v2 )
      v3 = **(void ***)(v2 + 4);
    else
      v3 = &unk_100ADF9C;
    v139 = (int)v3;
    v4 = (struct AssetTypeValueField *)AssetTypeValueField::operator[]((int)v3, "m_PreloadTable");
    v5 = *((_DWORD *)v4 + 1);
    if ( v5 == -1 )
    {
      v6 = v4;
      v128 = v4;
    }
    else
    {
      if ( v5 )
        v6 = (struct AssetTypeValueField *)**((_DWORD **)v4 + 2);
      else
        v6 = (struct AssetTypeValueField *)&unk_100ADF9C;
      v128 = v6;
    }
    v7 = *((_DWORD *)v1 + 4);
    if ( v7 <= *((_DWORD *)v6 + 1) )
    {
      v22 = (_DWORD *)*((_DWORD *)v6 + 3);
      if ( v22 )
      {
        if ( *v22 == 13 )
          v23 = v22 + 2;
        else
          v23 = 0;
        *v23 = v7;
      }
      v24 = 0;
      if ( *((_DWORD *)v1 + 4) )
      {
        v134 = 0;
        do
        {
          v25 = (char *)v134 + *((_DWORD *)v1 + 5);
          v145 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)v6 + 20) + 44) + 8);
          AssetTypeValue::Set((AssetTypeValue *)&v145, v25);
          v26 = *((_DWORD *)v6 + 1);
          if ( v26 == -1 )
          {
            v27 = v6;
          }
          else if ( v24 < v26 )
          {
            v27 = *(struct AssetTypeValueField **)(*((_DWORD *)v6 + 2) + 4 * v24);
          }
          else
          {
            v27 = (struct AssetTypeValueField *)&unk_100ADF9C;
          }
          v28 = *((_DWORD *)v27 + 1);
          if ( v28 != -1 )
          {
            if ( v28 )
              v27 = (struct AssetTypeValueField *)**((_DWORD **)v27 + 2);
            else
              v27 = (struct AssetTypeValueField *)&unk_100ADF9C;
          }
          v29 = *((_DWORD *)v27 + 3);
          v30 = v146;
          *(_DWORD *)v29 = v145;
          v31 = v147;
          *(_DWORD *)(v29 + 4) = v30;
          v32 = v148;
          *(_DWORD *)(v29 + 8) = v31;
          *(_DWORD *)(v29 + 12) = v32;
          v33 = *((_DWORD *)v1 + 5);
          v141 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)v6 + 20) + 44) + 32);
          AssetTypeValue::Set((AssetTypeValue *)&v141, (char *)v134 + v33 + 8);
          v34 = *((_DWORD *)v6 + 1);
          if ( v34 == -1 )
          {
            v35 = v6;
          }
          else if ( v24 < v34 )
          {
            v35 = *(struct AssetTypeValueField **)(*((_DWORD *)v6 + 2) + 4 * v24);
          }
          else
          {
            v35 = (struct AssetTypeValueField *)&unk_100ADF9C;
          }
          v36 = *((_DWORD *)v35 + 1);
          if ( v36 != -1 )
          {
            if ( v36 > 1 )
              v35 = *(struct AssetTypeValueField **)(*((_DWORD *)v35 + 2) + 4);
            else
              v35 = (struct AssetTypeValueField *)&unk_100ADF9C;
          }
          v37 = *((_DWORD *)v35 + 3);
          v38 = v142;
          v134 += 4;
          *(_DWORD *)v37 = v141;
          v39 = v143;
          *(_DWORD *)(v37 + 4) = v38;
          v40 = v144;
          *(_DWORD *)(v37 + 8) = v39;
          ++v24;
          *(_DWORD *)(v37 + 12) = v40;
        }
        while ( v24 < *((_DWORD *)v1 + 4) );
      }
    }
    else
    {
      v8 = (struct AssetTypeValueField **)malloc(92 * v7);
      v138 = v8;
      if ( v8 )
      {
        v9 = (int)&v8[v7];
        v10 = (int)&v8[3 * v7 + 5];
        v11 = (int)&v8[15 * v7];
        v136 = 0;
        if ( v7 )
        {
          v133 = 0;
          v12 = v11;
          v130 = v9;
          do
          {
            v138[v136] = (struct AssetTypeValueField *)(v10 - 20);
            *(_DWORD *)v130 = v10 - 4;
            *(_DWORD *)(v130 + 4) = v10 + 12;
            *(_DWORD *)(v10 - 20) = *(_DWORD *)(*(_DWORD *)v128 + 20) + 24;
            *(_DWORD *)(v10 - 12) = v130;
            *(_DWORD *)(v10 - 8) = 0;
            *(_DWORD *)(v10 - 16) = 2;
            *(_DWORD *)(v10 - 4) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v128 + 20) + 44);
            *(_DWORD *)(v10 + 8) = v12;
            *(_DWORD *)v10 = 0;
            *(_DWORD *)(v10 + 4) = 0;
            *(_DWORD *)(v10 + 12) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v128 + 20) + 44) + 24;
            *(_DWORD *)(v10 + 16) = 0;
            *(_DWORD *)(v10 + 20) = 0;
            *(_DWORD *)(v10 + 24) = v12 + 16;
            v13 = (char *)v133 + *((_DWORD *)v127 + 5);
            v141 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)v128 + 20) + 44) + 8);
            AssetTypeValue::Set((AssetTypeValue *)&v141, v13);
            v14 = v142;
            v15 = v143;
            *(_DWORD *)v12 = v141;
            v16 = v144;
            *(_DWORD *)(v12 + 4) = v14;
            *(_DWORD *)(v12 + 8) = v15;
            *(_DWORD *)(v12 + 12) = v16;
            v17 = *((_DWORD *)v127 + 5);
            v145 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)v128 + 20) + 44) + 32);
            AssetTypeValue::Set((AssetTypeValue *)&v145, (char *)v133 + v17 + 8);
            v18 = v146;
            v19 = v147;
            v130 += 8;
            *(_DWORD *)(v12 + 16) = v145;
            v20 = v148;
            *(_DWORD *)(v12 + 20) = v18;
            *(_DWORD *)(v12 + 24) = v19;
            *(_DWORD *)(v12 + 28) = v20;
            ++v136;
            v10 += 48;
            v133 += 4;
            v12 += 32;
          }
          while ( v136 < *((_DWORD *)v127 + 4) );
        }
        AssetTypeInstance::SetChildList(*((AssetTypeInstance **)v127 + 2), v128, v138, *((_DWORD *)v127 + 4), 1);
        v21 = *((_DWORD *)v128 + 3);
        if ( v21 )
        {
          if ( *(_DWORD *)v21 == 13 )
            *(_DWORD *)(v21 + 8) = *((_DWORD *)v127 + 4);
          else
            v0 = *((_DWORD *)v127 + 4);
        }
      }
    }
    v41 = AssetTypeValueField::operator[](v139, "m_Container");
    v42 = v41[1];
    if ( v42 == -1 )
    {
      v43 = v41;
    }
    else if ( v42 )
    {
      v43 = *(_DWORD **)v41[2];
    }
    else
    {
      v43 = &unk_100ADF9C;
    }
    v44 = *((_DWORD *)v127 + 6);
    if ( v44 <= *((_DWORD *)v128 + 1) )
    {
      v78 = (_DWORD *)v43[3];
      if ( v78 )
      {
        if ( *v78 == 13 )
          v79 = v78 + 2;
        else
          v79 = 0;
        *v79 = v44;
      }
      v132 = 0;
      if ( *((_DWORD *)v127 + 6) )
      {
        v80 = 0;
        do
        {
          v81 = *(void **)(v80 + *((_DWORD *)v127 + 7));
          if ( !v81 )
            v81 = &unk_100C1798;
          v157 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44) + 8);
          AssetTypeValue::Set((AssetTypeValue *)&v157, v81);
          v82 = v43[1];
          if ( v82 == -1 )
          {
            v83 = v43;
          }
          else if ( v132 < v82 )
          {
            v83 = *(_DWORD **)(v43[2] + 4 * v132);
          }
          else
          {
            v83 = &unk_100ADF9C;
          }
          v84 = v83[1];
          if ( v84 != -1 )
          {
            if ( v84 )
              v83 = *(_DWORD **)v83[2];
            else
              v83 = &unk_100ADF9C;
          }
          v85 = v83[3];
          v86 = v158;
          *(_DWORD *)v85 = v157;
          v87 = v159;
          *(_DWORD *)(v85 + 4) = v86;
          v88 = v160;
          *(_DWORD *)(v85 + 8) = v87;
          *(_DWORD *)(v85 + 12) = v88;
          v89 = (void *)(*((_DWORD *)v127 + 7) + v80 + 4);
          v153 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44) + 44) + 8);
          AssetTypeValue::Set((AssetTypeValue *)&v153, v89);
          v90 = v43[1];
          if ( v90 == -1 )
          {
            v91 = v43;
          }
          else if ( v132 < v90 )
          {
            v91 = *(void **)(v43[2] + 4 * v132);
          }
          else
          {
            v91 = &unk_100ADF9C;
          }
          v92 = *((_DWORD *)v91 + 1);
          if ( v92 != -1 )
          {
            if ( v92 > 1 )
              v91 = *(void **)(*((_DWORD *)v91 + 2) + 4);
            else
              v91 = &unk_100ADF9C;
          }
          v93 = *((_DWORD *)v91 + 1);
          if ( v93 != -1 )
          {
            if ( v93 )
              v91 = (void *)**((_DWORD **)v91 + 2);
            else
              v91 = &unk_100ADF9C;
          }
          v94 = *((_DWORD *)v91 + 3);
          v95 = v154;
          *(_DWORD *)v94 = v153;
          v96 = v155;
          *(_DWORD *)(v94 + 4) = v95;
          v97 = v156;
          *(_DWORD *)(v94 + 8) = v96;
          *(_DWORD *)(v94 + 12) = v97;
          v98 = *((_DWORD *)v127 + 7);
          v149 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44) + 44) + 32);
          AssetTypeValue::Set((AssetTypeValue *)&v149, (void *)(v98 + v80 + 8));
          v99 = v43[1];
          if ( v99 == -1 )
          {
            v100 = v43;
          }
          else if ( v132 < v99 )
          {
            v100 = *(void **)(v43[2] + 4 * v132);
          }
          else
          {
            v100 = &unk_100ADF9C;
          }
          v101 = *((_DWORD *)v100 + 1);
          if ( v101 != -1 )
          {
            if ( v101 > 1 )
              v100 = *(void **)(*((_DWORD *)v100 + 2) + 4);
            else
              v100 = &unk_100ADF9C;
          }
          v102 = *((_DWORD *)v100 + 1);
          if ( v102 != -1 )
          {
            if ( v102 > 1 )
              v100 = *(void **)(*((_DWORD *)v100 + 2) + 4);
            else
              v100 = &unk_100ADF9C;
          }
          v103 = *((_DWORD *)v100 + 3);
          v104 = v150;
          *(_DWORD *)v103 = v149;
          v105 = v151;
          *(_DWORD *)(v103 + 4) = v104;
          v106 = v152;
          *(_DWORD *)(v103 + 8) = v105;
          *(_DWORD *)(v103 + 12) = v106;
          v107 = *((_DWORD *)v127 + 7);
          v145 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44) + 44) + 68) + 8);
          AssetTypeValue::Set((AssetTypeValue *)&v145, (void *)(v107 + v80 + 16));
          v108 = v43[1];
          if ( v108 == -1 )
          {
            v109 = v43;
          }
          else if ( v132 < v108 )
          {
            v109 = *(void **)(v43[2] + 4 * v132);
          }
          else
          {
            v109 = &unk_100ADF9C;
          }
          v110 = *((_DWORD *)v109 + 1);
          if ( v110 != -1 )
          {
            if ( v110 > 1 )
              v109 = *(void **)(*((_DWORD *)v109 + 2) + 4);
            else
              v109 = &unk_100ADF9C;
          }
          v111 = *((_DWORD *)v109 + 1);
          if ( v111 != -1 )
          {
            if ( v111 > 2 )
              v109 = *(void **)(*((_DWORD *)v109 + 2) + 8);
            else
              v109 = &unk_100ADF9C;
          }
          v112 = *((_DWORD *)v109 + 1);
          if ( v112 != -1 )
          {
            if ( v112 )
              v109 = (void *)**((_DWORD **)v109 + 2);
            else
              v109 = &unk_100ADF9C;
          }
          v113 = *((_DWORD *)v109 + 3);
          v114 = v146;
          *(_DWORD *)v113 = v145;
          v115 = v147;
          *(_DWORD *)(v113 + 4) = v114;
          v116 = v148;
          *(_DWORD *)(v113 + 8) = v115;
          *(_DWORD *)(v113 + 12) = v116;
          v117 = (void *)(*((_DWORD *)v127 + 7) + v80 + 24);
          v141 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44) + 44) + 68) + 32);
          AssetTypeValue::Set((AssetTypeValue *)&v141, v117);
          v118 = v43[1];
          if ( v118 == -1 )
          {
            v119 = v43;
          }
          else if ( v132 < v118 )
          {
            v119 = *(void **)(v43[2] + 4 * v132);
          }
          else
          {
            v119 = &unk_100ADF9C;
          }
          v120 = *((_DWORD *)v119 + 1);
          if ( v120 != -1 )
          {
            if ( v120 > 1 )
              v119 = *(void **)(*((_DWORD *)v119 + 2) + 4);
            else
              v119 = &unk_100ADF9C;
          }
          v121 = *((_DWORD *)v119 + 1);
          if ( v121 != -1 )
          {
            if ( v121 > 2 )
              v119 = *(void **)(*((_DWORD *)v119 + 2) + 8);
            else
              v119 = &unk_100ADF9C;
          }
          v122 = *((_DWORD *)v119 + 1);
          if ( v122 != -1 )
          {
            if ( v122 > 1 )
              v119 = *(void **)(*((_DWORD *)v119 + 2) + 4);
            else
              v119 = &unk_100ADF9C;
          }
          v123 = *((_DWORD *)v119 + 3);
          v124 = v142;
          *(_DWORD *)v123 = v141;
          v125 = v143;
          *(_DWORD *)(v123 + 4) = v124;
          v126 = v144;
          *(_DWORD *)(v123 + 8) = v125;
          *(_DWORD *)(v123 + 12) = v126;
          v80 += 32;
          ++v132;
        }
        while ( v132 < *((_DWORD *)v127 + 6) );
      }
    }
    else
    {
      v45 = (struct AssetTypeValueField **)malloc(240 * v44 + 1);
      v135 = v45;
      if ( v45 )
      {
        v46 = *((_DWORD *)v127 + 6);
        v47 = (int)&v45[8 * v46];
        v48 = (int)&v45[40 * v46];
        v49 = &v135[60 * *((_DWORD *)v127 + 6)];
        v137 = 0;
        *(_BYTE *)v49 = 0;
        v140 = v49;
        if ( *((_DWORD *)v127 + 6) )
        {
          v129 = (struct AssetTypeValueField *)(v48 + 32);
          v131 = 0;
          v50 = (int)&v135[v46 + 3];
          v51 = v47 + 20;
          do
          {
            v135[v137] = (struct AssetTypeValueField *)(v51 - 20);
            *(_DWORD *)(v50 - 12) = v51 - 4;
            *(_DWORD *)(v50 - 8) = v51 + 12;
            *(_DWORD *)(v50 - 4) = v51 + 28;
            *(_DWORD *)v50 = v51 + 44;
            *(_DWORD *)(v50 + 4) = v51 + 60;
            *(_DWORD *)(v50 + 8) = v51 + 76;
            *(_DWORD *)(v50 + 12) = v51 + 92;
            v52 = *(_DWORD *)(*v43 + 20);
            *(_DWORD *)(v51 - 16) = 2;
            *(_DWORD *)(v51 - 20) = v52 + 24;
            *(_DWORD *)(v51 - 8) = 0;
            *(_DWORD *)(v51 - 12) = v50 - 12;
            *(_DWORD *)(v51 - 4) = *(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44);
            *(_DWORD *)v51 = 0;
            *(_DWORD *)(v51 + 4) = 0;
            *(_DWORD *)(v51 + 8) = (char *)v129 - 32;
            v53 = *(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44);
            *(_DWORD *)(v51 + 24) = 0;
            *(_DWORD *)(v51 + 16) = 3;
            *(_DWORD *)(v51 + 12) = v53 + 24;
            *(_DWORD *)(v51 + 20) = v50 - 4;
            *(_DWORD *)(v51 + 28) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44) + 44);
            *(_DWORD *)(v51 + 32) = 0;
            *(_DWORD *)(v51 + 36) = 0;
            *(_DWORD *)(v51 + 40) = (char *)v129 - 16;
            v54 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44) + 44);
            *(_DWORD *)(v51 + 56) = v129;
            *(_DWORD *)(v51 + 48) = 0;
            *(_DWORD *)(v51 + 52) = 0;
            *(_DWORD *)(v51 + 44) = v54 + 24;
            *(_DWORD *)(v51 + 60) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44) + 44) + 48;
            *(_DWORD *)(v51 + 72) = 0;
            *(_DWORD *)(v51 + 64) = 2;
            *(_DWORD *)(v51 + 68) = v50 + 8;
            *(_DWORD *)(v51 + 76) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44) + 44) + 68);
            *(_DWORD *)(v51 + 80) = 0;
            *(_DWORD *)(v51 + 84) = 0;
            *(_DWORD *)(v51 + 88) = (char *)v129 + 16;
            v55 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44) + 44) + 68) + 24;
            *(_DWORD *)(v51 + 104) = (char *)v129 + 32;
            *(_DWORD *)(v51 + 92) = v55;
            *(_DWORD *)(v51 + 96) = 0;
            *(_DWORD *)(v51 + 100) = 0;
            v56 = *(struct AssetTypeValueField ***)(v131 + *((_DWORD *)v127 + 7));
            if ( !v56 )
              v56 = v140;
            v145 = 12;
            AssetTypeValue::Set((AssetTypeValue *)&v145, v56);
            v57 = v146;
            *((_DWORD *)v129 - 8) = v145;
            v58 = v147;
            *((_DWORD *)v129 - 7) = v57;
            v59 = v148;
            *((_DWORD *)v129 - 6) = v58;
            *((_DWORD *)v129 - 5) = v59;
            v60 = *((_DWORD *)v127 + 7);
            v141 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44) + 44) + 8);
            AssetTypeValue::Set((AssetTypeValue *)&v141, (void *)(v60 + v131 + 4));
            v61 = v142;
            *((_DWORD *)v129 - 4) = v141;
            v62 = v143;
            *((_DWORD *)v129 - 3) = v61;
            v63 = v144;
            *((_DWORD *)v129 - 2) = v62;
            *((_DWORD *)v129 - 1) = v63;
            v64 = *((_DWORD *)v127 + 7);
            v149 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44) + 44) + 32);
            AssetTypeValue::Set((AssetTypeValue *)&v149, (void *)(v64 + v131 + 8));
            v65 = v150;
            *(_DWORD *)v129 = v149;
            v66 = v151;
            *((_DWORD *)v129 + 1) = v65;
            v67 = v152;
            *((_DWORD *)v129 + 2) = v66;
            *((_DWORD *)v129 + 3) = v67;
            v68 = *((_DWORD *)v127 + 7);
            v153 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44) + 44) + 68) + 8);
            AssetTypeValue::Set((AssetTypeValue *)&v153, (void *)(v68 + v131 + 16));
            v69 = v154;
            *((_DWORD *)v129 + 4) = v153;
            v70 = v155;
            *((_DWORD *)v129 + 5) = v69;
            v71 = v156;
            *((_DWORD *)v129 + 6) = v70;
            *((_DWORD *)v129 + 7) = v71;
            v72 = *((_DWORD *)v127 + 7);
            v157 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*v43 + 20) + 44) + 44) + 68) + 32);
            AssetTypeValue::Set((AssetTypeValue *)&v157, (void *)(v72 + v131 + 24));
            v73 = v129;
            v74 = v158;
            v131 += 32;
            v129 = (struct AssetTypeValueField *)((char *)v129 + 80);
            *((_DWORD *)v73 + 8) = v157;
            v75 = v159;
            *((_DWORD *)v73 + 9) = v74;
            v76 = v160;
            *((_DWORD *)v73 + 10) = v75;
            *((_DWORD *)v73 + 11) = v76;
            v50 += 28;
            v51 += 128;
            ++v137;
          }
          while ( v137 < *((_DWORD *)v127 + 6) );
        }
        AssetTypeInstance::SetChildList(
          *((AssetTypeInstance **)v127 + 2),
          (struct AssetTypeValueField *)v43,
          v135,
          *((_DWORD *)v127 + 6),
          1);
        v77 = v43[3];
        if ( v77 )
        {
          if ( *(_DWORD *)v77 == 13 )
            *(_DWORD *)(v77 + 8) = *((_DWORD *)v127 + 6);
          else
            v0 = *((_DWORD *)v127 + 6);
        }
      }
    }
  }
}

//----- (10001BF0) --------------------------------------------------------
char __thiscall AssetBundleAsset::WriteBundleFile(AssetBundleAsset *this, void *a2, int a3, int *a4)
{
  AssetBundleAsset *v4; // edi@1
  void *v6; // esi@4
  int v7; // edi@5
  AssetTypeValueField *v8; // ecx@6
  size_t v9; // eax@12
  int v10; // eax@14
  int v11; // eax@18
  size_t v12; // eax@18
  unsigned int v13; // eax@19
  bool v14; // cf@19
  int v15; // edx@20
  const char **v16; // eax@23
  const char *v17; // eax@23
  size_t v18; // eax@24
  int v19; // ecx@24
  int v20; // eax@26
  int v21; // ecx@31
  int v22; // eax@32
  size_t v23; // eax@32
  int v24; // eax@37
  size_t v25; // eax@37
  signed int v26; // eax@38
  bool v27; // sf@38
  unsigned __int8 v28; // of@38
  int v29; // eax@38
  int v30; // edx@39
  size_t v31; // eax@42
  int v32; // ecx@42
  size_t v33; // eax@44
  int v34; // ecx@44
  size_t v35; // eax@46
  int v36; // ecx@46
  int v37; // ecx@51
  int v38; // eax@54
  int v39; // edx@56
  size_t v40; // eax@58
  int v41; // ecx@58
  unsigned int v42; // edx@60
  size_t v43; // eax@62
  int v44; // ecx@62
  int v45; // [sp+Ch] [bp-14h]@25
  unsigned int v46; // [sp+Ch] [bp-14h]@29
  int v47; // [sp+Ch] [bp-14h]@32
  int v48; // [sp+Ch] [bp-14h]@37
  int v49; // [sp+Ch] [bp-14h]@38
  int v50; // [sp+Ch] [bp-14h]@43
  int v51; // [sp+Ch] [bp-14h]@45
  int v52; // [sp+Ch] [bp-14h]@47
  int v53; // [sp+Ch] [bp-14h]@59
  int v54; // [sp+Ch] [bp-14h]@63
  int v55; // [sp+10h] [bp-10h]@16
  const char **v56; // [sp+10h] [bp-10h]@23
  int v57; // [sp+10h] [bp-10h]@42
  int v58; // [sp+10h] [bp-10h]@52
  int v59; // [sp+10h] [bp-10h]@54
  int v60; // [sp+10h] [bp-10h]@61
  unsigned int v61; // [sp+14h] [bp-Ch]@14
  unsigned int v62; // [sp+14h] [bp-Ch]@15
  int v63; // [sp+14h] [bp-Ch]@22
  int v64; // [sp+14h] [bp-Ch]@41
  unsigned int v65; // [sp+18h] [bp-8h]@21
  unsigned int v66; // [sp+18h] [bp-8h]@44
  unsigned int v67; // [sp+18h] [bp-8h]@46
  unsigned int v68; // [sp+18h] [bp-8h]@48
  int v69; // [sp+1Ch] [bp-4h]@13
  int v70; // [sp+1Ch] [bp-4h]@17
  int v71; // [sp+1Ch] [bp-4h]@40
  unsigned int v72; // [sp+1Ch] [bp-4h]@60

  v4 = this;
  if ( !*((_BYTE *)this + 1) )
    return 0;
  if ( *((_DWORD *)this + 1) != -1 )
  {
    v9 = strlen(*((const char **)this + 3));
    if ( a3 < 4 )
      return 0;
    *(_DWORD *)a2 = v9;
    v69 = v9 + 4;
    if ( (signed int)(v9 + 4) > a3 )
      return 0;
    memcpy((char *)a2 + 4, *((const void **)v4 + 3), v9);
    v61 = (v69 + 3) & 0xFFFFFFFC;
    memset((char *)a2 + v69, 0, v61 - v69);
    v10 = v61 + 4;
    if ( (signed int)(v61 + 4) > a3 )
      return 0;
    *(_DWORD *)((char *)a2 + v61) = *((_DWORD *)v4 + 4);
    v62 = 0;
    if ( *((_DWORD *)v4 + 4) )
    {
      v55 = 0;
      do
      {
        v70 = v10 + 4;
        if ( v10 + 4 > a3 )
          return 0;
        *(_DWORD *)((char *)a2 + v10) = *(_DWORD *)(v55 + *((_DWORD *)v4 + 5));
        v11 = *((_DWORD *)v4 + 1) < 14;
        LOBYTE(v11) = *((_DWORD *)v4 + 1) >= 14;
        v12 = 4 * v11 + 4;
        if ( (signed int)(v12 + v70) > a3 )
          return 0;
        memcpy((char *)a2 + v70, (const void *)(*((_DWORD *)v4 + 5) + v55 + 8), v12);
        v55 += 16;
        v13 = v62 + 1;
        v62 = v13;
        v14 = v13 < *((_DWORD *)v4 + 4);
        v10 = 4 * (*((_DWORD *)v4 + 1) >= 14) + 4 + v70;
      }
      while ( v14 );
    }
    v15 = v10 + 4;
    if ( v10 + 4 > a3 )
      return 0;
    *(_DWORD *)((char *)a2 + v10) = *((_DWORD *)v4 + 6);
    v65 = 0;
    if ( *((_DWORD *)v4 + 6) )
    {
      v63 = 0;
      do
      {
        v16 = (const char **)(v63 + *((_DWORD *)v4 + 7));
        v56 = v16;
        v17 = *v16;
        if ( v17 )
        {
          v18 = strlen(v17);
          v19 = v15 + 4;
          if ( v15 + 4 > a3 )
            return 0;
          *(_DWORD *)((char *)a2 + v15) = v18;
          v45 = v18 + v19;
          if ( (signed int)(v18 + v19) > a3 )
            return 0;
          memcpy((char *)a2 + v19, *v56, v18);
          v20 = v45;
        }
        else
        {
          v20 = v15 + 4;
          if ( v15 + 4 > a3 )
            return 0;
          *(_DWORD *)((char *)a2 + v15) = 0;
        }
        v46 = (v20 + 3) & 0xFFFFFFFC;
        memset((char *)a2 + v20, 0, v46 - v20);
        if ( (signed int)(v46 + 4) > a3 )
          return 0;
        *(_DWORD *)((char *)a2 + v46) = v56[1];
        if ( (signed int)(v46 + 8) > a3 )
          return 0;
        *(_DWORD *)((char *)a2 + v46 + 4) = v56[2];
        v21 = v46 + 12;
        if ( (signed int)(v46 + 12) > a3 )
          return 0;
        *(_DWORD *)((char *)a2 + v46 + 8) = v56[4];
        v47 = v46 + 12;
        v22 = *((_DWORD *)v4 + 1) < 14;
        LOBYTE(v22) = *((_DWORD *)v4 + 1) >= 14;
        v23 = 4 * v22 + 4;
        if ( (signed int)(v23 + v21) > a3 )
          return 0;
        memcpy((char *)a2 + v21, v56 + 6, v23);
        v63 += 32;
        ++v65;
        v15 = 4 * (*((_DWORD *)v4 + 1) >= 14) + 4 + v47;
      }
      while ( v65 < *((_DWORD *)v4 + 6) );
    }
    if ( v15 + 4 > a3 )
      return 0;
    *(_DWORD *)((char *)a2 + v15) = *((_DWORD *)v4 + 9);
    if ( v15 + 8 > a3 )
      return 0;
    *(_DWORD *)((char *)a2 + v15 + 4) = *((_DWORD *)v4 + 10);
    if ( v15 + 12 > a3 )
      return 0;
    *(_DWORD *)((char *)a2 + v15 + 8) = *((_DWORD *)v4 + 12);
    v48 = v15 + 12;
    v24 = *((_DWORD *)v4 + 1) < 14;
    LOBYTE(v24) = *((_DWORD *)v4 + 1) >= 14;
    v25 = 4 * v24 + 4;
    if ( (signed int)(v25 + v15 + 12) > a3 )
      return 0;
    memcpy((char *)a2 + v48, (char *)v4 + 56, v25);
    v26 = *((_DWORD *)v4 + 1);
    v49 = 4 * (v26 >= 14) + 4 + v48;
    v28 = __OFSUB__(v26, 14);
    v27 = v26 - 14 < 0;
    v29 = v49;
    if ( v27 ^ v28 )
    {
      v30 = v49 + 4;
      if ( v49 + 4 > a3 )
        return 0;
      *(_DWORD *)((char *)a2 + v49) = *((_DWORD *)v4 + 16);
      v71 = 0;
      if ( *((_DWORD *)v4 + 16) > 0 )
      {
        v64 = 0;
        do
        {
          v57 = v64 + *((_DWORD *)v4 + 17);
          v31 = strlen(*(const char **)v57);
          v32 = v30 + 4;
          if ( v30 + 4 > a3 )
            return 0;
          *(_DWORD *)((char *)a2 + v30) = v31;
          v50 = v31 + v32;
          if ( (signed int)(v31 + v32) > a3 )
            return 0;
          memcpy((char *)a2 + v32, *(const void **)v57, v31);
          v66 = (v50 + 3) & 0xFFFFFFFC;
          memset((char *)a2 + v50, 0, v66 - v50);
          v33 = strlen(*(const char **)(v57 + 4));
          v34 = v66 + 4;
          if ( (signed int)(v66 + 4) > a3 )
            return 0;
          *(_DWORD *)((char *)a2 + v66) = v33;
          v51 = v33 + v34;
          if ( (signed int)(v33 + v34) > a3 )
            return 0;
          memcpy((char *)a2 + v34, *(const void **)(v57 + 4), v33);
          v67 = (v51 + 3) & 0xFFFFFFFC;
          memset((char *)a2 + v51, 0, v67 - v51);
          v35 = strlen(*(const char **)(v57 + 8));
          v36 = v67 + 4;
          if ( (signed int)(v67 + 4) > a3 )
            return 0;
          *(_DWORD *)((char *)a2 + v67) = v35;
          v52 = v35 + v36;
          if ( (signed int)(v35 + v36) > a3 )
            return 0;
          memcpy((char *)a2 + v36, *(const void **)(v57 + 8), v35);
          v68 = (v52 + 3) & 0xFFFFFFFC;
          memset((char *)a2 + v52, 0, v68 - v52);
          if ( (signed int)(v68 + 4) > a3 )
            return 0;
          v64 += 16;
          *(_DWORD *)((char *)a2 + v68) = *(_DWORD *)(v57 + 12);
          v30 = v68 + 4;
        }
        while ( ++v71 < *((_DWORD *)v4 + 16) );
      }
      v29 = v30 + 4;
      if ( v30 + 4 > a3 )
        return 0;
      *(_DWORD *)((char *)a2 + v30) = *((_DWORD *)v4 + 18);
      v37 = 0;
      if ( *((_DWORD *)v4 + 18) > 0 )
      {
        v58 = v30 + 8;
        while ( v58 <= a3 )
        {
          *(_DWORD *)((char *)a2 + v29) = *(_DWORD *)(*((_DWORD *)v4 + 19) + 8 * v37);
          v38 = v29 + 4;
          v59 = v58 + 4;
          if ( v59 > a3 )
            break;
          v58 = v59 + 4;
          *(_DWORD *)((char *)a2 + v38) = *(_DWORD *)(*((_DWORD *)v4 + 19) + 8 * v37++ + 4);
          v29 = v38 + 4;
          if ( v37 >= *((_DWORD *)v4 + 18) )
            goto LABEL_56;
        }
        return 0;
      }
    }
LABEL_56:
    v39 = v29 + 4;
    if ( v29 + 4 > a3 )
      return 0;
    *(_DWORD *)((char *)a2 + v29) = *((_DWORD *)v4 + 20);
    if ( *((_DWORD *)v4 + 1) < 14 )
    {
LABEL_67:
      *a4 = v39;
      return 1;
    }
    v40 = strlen(*((const char **)v4 + 21));
    v41 = v39 + 4;
    if ( v39 + 4 <= a3 )
    {
      *(_DWORD *)((char *)a2 + v39) = v40;
      v53 = v40 + v41;
      if ( (signed int)(v40 + v41) <= a3 )
      {
        memcpy((char *)a2 + v41, *((const void **)v4 + 21), v40);
        v72 = (v53 + 3) & 0xFFFFFFFC;
        memset((char *)a2 + v53, 0, v72 - v53);
        v42 = v72 + 4;
        if ( (signed int)(v72 + 4) <= a3 )
        {
          *(_DWORD *)((char *)a2 + v72) = *((_DWORD *)v4 + 22);
          v60 = 0;
          if ( *((_DWORD *)v4 + 22) > 0 )
          {
            do
            {
              v43 = strlen(*(const char **)(*((_DWORD *)v4 + 23) + 4 * v60));
              v44 = v42 + 4;
              if ( (signed int)(v42 + 4) > a3 )
                return 0;
              *(_DWORD *)((char *)a2 + v42) = v43;
              v54 = v43 + v44;
              if ( (signed int)(v43 + v44) > a3 )
                return 0;
              memcpy((char *)a2 + v44, *(const void **)(*((_DWORD *)v4 + 23) + 4 * v60), v43);
              memset((char *)a2 + v54, 0, ((v54 + 3) & 0xFFFFFFFC) - v54);
              v42 = (v54 + 3) & 0xFFFFFFFC;
            }
            while ( ++v60 < *((_DWORD *)v4 + 22) );
          }
          if ( (signed int)(v42 + 4) <= a3 )
          {
            *(_DWORD *)((char *)a2 + v42) = *((_BYTE *)v4 + 96);
            v39 = v42 + 4;
            goto LABEL_67;
          }
        }
      }
    }
    return 0;
  }
  v6 = malloc(0x10u);
  if ( !v6 )
    return 0;
  *(_DWORD *)v6 = 0;
  *((_DWORD *)v6 + 1) = a3;
  *((_DWORD *)v6 + 2) = a2;
  *((_BYTE *)v6 + 12) = 0;
  v7 = *((_DWORD *)v4 + 2);
  if ( *(_DWORD *)v7 )
    v8 = **(AssetTypeValueField ***)(v7 + 4);
  else
    v8 = (AssetTypeValueField *)&unk_100ADF9C;
  *a4 = AssetTypeValueField::Write(
          v8,
          (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32))AssetsWriterToMemory,
          (__int32)v6,
          0i64);
  if ( *((_BYTE *)v6 + 12) )
  {
    if ( *((_DWORD *)v6 + 2) )
      free(*((void **)v6 + 2));
  }
  free(v6);
  return 1;
}

//----- (100022E0) --------------------------------------------------------
unsigned int __thiscall AssetBundleAsset::GetFileSize(AssetBundleAsset *this)
{
  AssetBundleAsset *v1; // ebx@1
  unsigned int result; // eax@2
  int v3; // eax@4
  const char *v4; // eax@7
  unsigned int v5; // edx@7
  int v6; // edx@9
  int v7; // edx@11
  int v8; // ecx@12
  const char **v9; // edi@13
  unsigned int v10; // kr04_4@15
  signed int v11; // esi@18
  int v12; // eax@18
  int v13; // eax@19
  int v14; // edi@21
  int v15; // ecx@21
  int v16; // eax@22
  unsigned int v17; // kr08_4@23
  const char *v18; // edx@24
  int v19; // eax@24
  unsigned int v20; // kr0C_4@25
  const char *v21; // edx@26
  int v22; // eax@26
  unsigned int v23; // kr10_4@27
  const char *v24; // edx@32
  int v25; // eax@32
  unsigned int v26; // kr14_4@33
  int v27; // eax@34
  char **v28; // esi@35
  int v29; // ebx@35
  char *v30; // ecx@37
  char v31; // dl@38
  AssetBundleAsset *v32; // [sp+Ch] [bp-4h]@1

  v1 = this;
  v32 = this;
  if ( *((_BYTE *)this + 1) )
  {
    if ( *((_DWORD *)this + 1) == -1 )
    {
      v3 = *((_DWORD *)this + 2);
      if ( *(_DWORD *)v3 )
        result = AssetTypeValueField::GetByteSize(**(AssetTypeValueField ***)(v3 + 4), 0i64);
      else
        result = AssetTypeValueField::GetByteSize((AssetTypeValueField *)&unk_100ADF9C, 0i64);
    }
    else
    {
      v4 = (const char *)*((_DWORD *)this + 3);
      v5 = 4;
      if ( v4 )
        v5 = ((strlen(v4) + 3) & 0xFFFFFFFC) + 4;
      v6 = v5 + 4;
      if ( *((_DWORD *)this + 5) )
        v6 += *((_DWORD *)this + 4) * (4 * (*((_DWORD *)this + 1) >= 14) + 8);
      v7 = v6 + 4;
      if ( *((_DWORD *)this + 7) )
      {
        v8 = *((_DWORD *)this + 6);
        if ( v8 )
        {
          v9 = (const char **)*((_DWORD *)v1 + 7);
          do
          {
            v7 += 4;
            if ( *v9 )
            {
              v10 = strlen(*v9);
              v1 = v32;
              v7 += (v10 + 3) & 0xFFFFFFFC;
            }
            v9 += 8;
            --v8;
          }
          while ( v8 );
        }
        v7 += *((_DWORD *)v1 + 6) * (4 * (*((_DWORD *)v1 + 1) >= 14) + 16);
      }
      v11 = *((_DWORD *)v1 + 1);
      v12 = v7 + 4 * (v11 >= 14) + 8 + 8;
      if ( v11 < 14 )
      {
        v13 = v7 + 4 * (v11 >= 14) + 8 + 12;
        if ( *((_DWORD *)v1 + 17) && *((_DWORD *)v1 + 16) > 0 )
        {
          v14 = *((_DWORD *)v1 + 17);
          v15 = *((_DWORD *)v1 + 16);
          do
          {
            v16 = v13 + 4;
            if ( *(_DWORD *)v14 )
            {
              v17 = strlen(*(const char **)v14);
              v1 = v32;
              v16 += (v17 + 3) & 0xFFFFFFFC;
            }
            v18 = *(const char **)(v14 + 4);
            v19 = v16 + 4;
            if ( v18 )
            {
              v20 = strlen(v18);
              v1 = v32;
              v19 += (v20 + 3) & 0xFFFFFFFC;
            }
            v21 = *(const char **)(v14 + 8);
            v22 = v19 + 4;
            if ( v21 )
            {
              v23 = strlen(v21);
              v1 = v32;
              v22 += (v23 + 3) & 0xFFFFFFFC;
            }
            v13 = v22 + 4;
            v14 += 16;
            --v15;
          }
          while ( v15 );
        }
        v12 = v13 + 4;
        if ( *((_DWORD *)v1 + 19) )
          v12 += 8 * *((_DWORD *)v1 + 18);
      }
      result = v12 + 4;
      if ( *((_DWORD *)v1 + 1) >= 14 )
      {
        v24 = (const char *)*((_DWORD *)v1 + 21);
        v25 = result + 4;
        if ( v24 )
        {
          v26 = strlen(v24);
          v1 = v32;
          v25 += (v26 + 3) & 0xFFFFFFFC;
        }
        v27 = v25 + 4;
        if ( *((_DWORD *)v1 + 22) > 0 )
        {
          v28 = (char **)*((_DWORD *)v1 + 23);
          v29 = *((_DWORD *)v1 + 22);
          do
          {
            v27 += 4;
            if ( *v28 )
            {
              v30 = *v28;
              do
                v31 = *v30++;
              while ( v31 );
              v27 += (v30 - (*v28 + 1) + 3) & 0xFFFFFFFC;
            }
            ++v28;
            --v29;
          }
          while ( v29 );
        }
        result = v27 + 4;
      }
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10002500) --------------------------------------------------------
AssetBundleAsset *__thiscall AssetBundleAsset::AssetBundleAsset(AssetBundleAsset *this)
{
  AssetBundleAsset *result; // eax@1

  result = this;
  *(_WORD *)this = 0;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 7) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 11) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_DWORD *)this + 13) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 15) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_DWORD *)this + 17) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_DWORD *)this + 19) = 0;
  *((_DWORD *)this + 20) = 0;
  *((_DWORD *)this + 21) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 23) = 0;
  return result;
}

//----- (10002550) --------------------------------------------------------
void __thiscall AssetBundleAsset::Clear(AssetBundleAsset *this)
{
  AssetBundleAsset *v1; // esi@1
  AssetTypeInstance *v2; // edi@2
  unsigned int v3; // ebx@2
  void (__cdecl *v4)(void *); // edi@4
  int v5; // edi@10
  int v6; // edi@18
  void *v7; // edi@22
  int i; // edi@32
  int v9; // [sp+4h] [bp-4h]@17

  v1 = this;
  if ( *((_BYTE *)this + 1) )
  {
    v2 = (AssetTypeInstance *)*((_DWORD *)this + 2);
    v3 = 0;
    *((_BYTE *)this + 1) = 0;
    if ( v2 )
    {
      AssetTypeInstance::~AssetTypeInstance(v2);
      operator delete((void *)v2);
      *((_DWORD *)v1 + 2) = 0;
    }
    v4 = operator delete[];
    if ( *((_DWORD *)v1 + 3) )
    {
      operator delete[](*((void **)v1 + 3));
      *((_DWORD *)v1 + 3) = 0;
    }
    if ( *((_DWORD *)v1 + 5) )
    {
      operator delete[](*((void **)v1 + 5));
      *((_DWORD *)v1 + 5) = 0;
      *((_DWORD *)v1 + 4) = 0;
    }
    if ( *((_DWORD *)v1 + 7) )
    {
      if ( *((_DWORD *)v1 + 6) > 0u )
      {
        v5 = 0;
        do
        {
          if ( *(_DWORD *)(v5 + *((_DWORD *)v1 + 7)) )
            operator delete[](*(void **)(v5 + *((_DWORD *)v1 + 7)));
          ++v3;
          v5 += 32;
        }
        while ( v3 < *((_DWORD *)v1 + 6) );
        v4 = operator delete[];
        v3 = 0;
      }
      v4(*((void **)v1 + 7));
      *((_DWORD *)v1 + 7) = 0;
      *((_DWORD *)v1 + 6) = 0;
    }
    if ( *((_DWORD *)v1 + 17) )
    {
      v9 = 0;
      if ( *((_DWORD *)v1 + 16) > 0 )
      {
        do
        {
          v6 = *((_DWORD *)v1 + 17);
          if ( *(_DWORD *)(v6 + v3) )
            operator delete[](*(void **)(v6 + v3));
          if ( *(_DWORD *)(v6 + v3 + 4) )
            operator delete[](*(void **)(v6 + v3 + 4));
          v7 = *(void **)(v6 + v3 + 8);
          if ( v7 )
            operator delete[](v7);
          v3 += 16;
          ++v9;
        }
        while ( v9 < *((_DWORD *)v1 + 16) );
        v4 = operator delete[];
      }
      v4(*((void **)v1 + 17));
      *((_DWORD *)v1 + 17) = 0;
      *((_DWORD *)v1 + 16) = 0;
    }
    if ( *((_DWORD *)v1 + 19) )
    {
      v4(*((void **)v1 + 19));
      *((_DWORD *)v1 + 19) = 0;
      *((_DWORD *)v1 + 18) = 0;
    }
    if ( *((_DWORD *)v1 + 21) )
    {
      v4(*((void **)v1 + 21));
      *((_DWORD *)v1 + 21) = 0;
    }
    if ( *((_DWORD *)v1 + 23) )
    {
      for ( i = 0; i < *((_DWORD *)v1 + 22); ++i )
        operator delete[](*(void **)(*((_DWORD *)v1 + 23) + 4 * i));
      operator delete[](*((void **)v1 + 23));
      *((_DWORD *)v1 + 23) = 0;
      *((_DWORD *)v1 + 22) = 0;
    }
  }
}
// 10099190: using guessed type void __cdecl operator delete[](void *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (100026D0) --------------------------------------------------------
char __thiscall AssetBundleAsset::ReadBundleFile(AssetBundleAsset *this, void *a2, int a3, int *a4, struct AssetTypeTemplateField *a5, bool a6)
{
  AssetBundleAsset *v6; // ebx@1
  _DWORD *v7; // esi@1
  void *v8; // eax@2
  int v9; // edi@3
  char result; // al@4
  int v11; // eax@9
  const char *v12; // esi@11
  int v13; // eax@13
  const char *v14; // ecx@13
  _BYTE *v15; // edx@13
  char v16; // al@14
  _DWORD *v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@21
  int v20; // eax@24
  bool v21; // zf@24
  int v22; // ebx@25
  void *v23; // esi@26
  unsigned int v24; // eax@26
  _DWORD *v25; // edi@30
  _DWORD *v26; // esi@30
  int v27; // eax@30
  AssetBundleAsset *v28; // edi@32
  int v29; // ecx@39
  int v30; // ecx@43
  int v31; // eax@47
  int v32; // edx@47
  int v33; // ecx@47
  int v34; // eax@48
  _DWORD *v35; // eax@50
  int v36; // ecx@50
  int v37; // eax@55
  void *v38; // eax@58
  size_t v39; // ST14_4@58
  void *v40; // edi@60
  unsigned int v41; // eax@60
  int v42; // eax@64
  const char *v43; // esi@66
  AssetBundleAsset *v44; // ebx@68
  _BYTE *v45; // edx@68
  const char *v46; // ecx@68
  char v47; // al@69
  void *v48; // eax@72
  int v49; // esi@72
  int v50; // eax@72
  int v51; // edi@74
  int v52; // eax@81
  signed int v53; // eax@83
  void *v54; // eax@90
  int v55; // eax@90
  signed int v56; // eax@92
  void *v57; // eax@99
  int v58; // ecx@99
  unsigned __int64 v59; // rax@101
  void *v60; // eax@110
  int v61; // esi@110
  int v62; // eax@110
  signed int v63; // eax@112
  int v64; // eax@119
  signed int v65; // eax@121
  void *v66; // eax@128
  int v67; // eax@128
  signed int v68; // eax@130
  void *v69; // eax@137
  int v70; // ecx@137
  unsigned __int64 v71; // rax@139
  int v72; // eax@147
  int v73; // eax@149
  AssetBundleAsset *v74; // [sp+14h] [bp-28h]@1
  unsigned int v75; // [sp+18h] [bp-24h]@24
  int v76; // [sp+18h] [bp-24h]@59
  void *v77; // [sp+1Ch] [bp-20h]@7
  void *v78; // [sp+20h] [bp-1Ch]@21
  _DWORD *v79; // [sp+20h] [bp-1Ch]@51
  unsigned int v80; // [sp+24h] [bp-18h]@58

  v6 = this;
  v74 = this;
  AssetBundleAsset::Clear(this);
  *((_DWORD *)v6 + 1) = -1;
  v7 = malloc(0xCu);
  if ( v7 )
  {
    *v7 = 0;
    v7[1] = a3;
    v7[2] = a2;
    v8 = operator new(0x14u);
    if ( v8 )
      v9 = AssetTypeInstance::AssetTypeInstance(
             (int)v8,
             1,
             (int)&a5,
             (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32))AssetsReaderFromMemory,
             (__int32)v7,
             a6,
             0i64);
    else
      v9 = 0;
    free(v7);
    if ( *(_DWORD *)v9 )
      v77 = **(void ***)(v9 + 4);
    else
      v77 = &unk_100ADF9C;
    *((_DWORD *)v6 + 2) = v9;
    v11 = *((_DWORD *)AssetTypeValueField::operator[]((int)v77, "m_Name") + 3);
    if ( v11 )
    {
      if ( *(_DWORD *)v11 == 12 )
        v12 = *(const char **)(v11 + 8);
      else
        v12 = 0;
      v13 = unknown_libname_4(strlen(v12) + 1);
      *((_DWORD *)v6 + 3) = v13;
      v14 = v12;
      v15 = (_BYTE *)v13;
      do
      {
        v16 = *v14;
        *v15++ = *v14++;
      }
      while ( v16 );
    }
    else
    {
      *((_DWORD *)v6 + 3) = 0;
    }
    v17 = AssetTypeValueField::operator[]((int)v77, "m_PreloadTable");
    v18 = v17[1];
    if ( v18 != -1 )
    {
      if ( v18 )
        v17 = *(_DWORD **)v17[2];
      else
        v17 = &unk_100ADF9C;
    }
    v78 = v17;
    v19 = v17[1];
    if ( v19 == -1 )
      *((_DWORD *)v6 + 4) = 0;
    else
      *((_DWORD *)v6 + 4) = v19;
    v20 = unknown_libname_4(16 * *((_DWORD *)v6 + 4) | -((unsigned __int64)*((_DWORD *)v6 + 4) >> 28 != 0));
    v21 = *((_DWORD *)v6 + 4) == 0;
    *((_DWORD *)v6 + 5) = v20;
    v75 = 0;
    if ( !v21 )
    {
      v22 = 0;
      do
      {
        v23 = v78;
        v24 = *((_DWORD *)v78 + 1);
        if ( v24 != -1 )
        {
          if ( v75 < v24 )
            v23 = *(void **)(*((_DWORD *)v78 + 2) + 4 * v75);
          else
            v23 = &unk_100ADF9C;
        }
        v25 = AssetTypeValueField::operator[]((int)v23, "m_FileID");
        v26 = AssetTypeValueField::operator[]((int)v23, "m_PathID");
        v27 = v25[3];
        if ( v27 )
        {
          switch ( *(_DWORD *)v27 )
          {
            case 0xA:
              v28 = v74;
              *(_DWORD *)(v22 + *((_DWORD *)v74 + 5)) = (signed int)*(float *)(v27 + 8);
              break;
            case 0xB:
              v28 = v74;
              *(_DWORD *)(v22 + *((_DWORD *)v74 + 5)) = (signed int)*(double *)(v27 + 8);
              break;
            case 0xC:
            case 0xD:
            case 0xE:
              v28 = v74;
              *(_DWORD *)(v22 + *((_DWORD *)v74 + 5)) = 0;
              break;
            case 2:
              v28 = v74;
              *(_DWORD *)(v22 + *((_DWORD *)v74 + 5)) = *(_BYTE *)(v27 + 8);
              break;
            case 4:
              v28 = v74;
              *(_DWORD *)(v22 + *((_DWORD *)v74 + 5)) = *(_WORD *)(v27 + 8);
              break;
            default:
              v28 = v74;
              *(_DWORD *)(v22 + *((_DWORD *)v74 + 5)) = *(_DWORD *)(v27 + 8);
              break;
          }
        }
        else
        {
          *(_DWORD *)(v22 + *((_DWORD *)v74 + 5)) = 0;
          v28 = v74;
        }
        v29 = v26[3];
        if ( v29 )
        {
          switch ( *(_DWORD *)v29 )
          {
            case 0xA:
              *(_QWORD *)(v22 + *((_DWORD *)v28 + 5) + 8) = (unsigned __int64)*(float *)(v29 + 8);
              break;
            case 0xB:
              *(_QWORD *)(v22 + *((_DWORD *)v28 + 5) + 8) = (unsigned __int64)*(double *)(v29 + 8);
              break;
            case 0xC:
            case 0xD:
            case 0xE:
              v30 = *((_DWORD *)v28 + 5);
              *(_DWORD *)(v22 + v30 + 8) = 0;
              *(_DWORD *)(v22 + v30 + 12) = 0;
              break;
            case 2:
              *(_QWORD *)(v22 + *((_DWORD *)v28 + 5) + 8) = *(_BYTE *)(v29 + 8);
              break;
            case 4:
              *(_QWORD *)(v22 + *((_DWORD *)v28 + 5) + 8) = *(_WORD *)(v29 + 8);
              break;
            case 6:
              *(_QWORD *)(v22 + *((_DWORD *)v28 + 5) + 8) = *(_DWORD *)(v29 + 8);
              break;
            default:
              v31 = *(_DWORD *)(v29 + 8);
              v32 = *(_DWORD *)(v29 + 12);
              v33 = *((_DWORD *)v28 + 5);
              *(_DWORD *)(v22 + v33 + 8) = v31;
              *(_DWORD *)(v22 + v33 + 12) = v32;
              break;
          }
        }
        else
        {
          v34 = *((_DWORD *)v28 + 5);
          *(_DWORD *)(v22 + v34 + 8) = 0;
          *(_DWORD *)(v22 + v34 + 12) = 0;
        }
        v22 += 16;
        ++v75;
      }
      while ( v75 < *((_DWORD *)v28 + 4) );
    }
    v35 = AssetTypeValueField::operator[]((int)v77, "m_Container");
    v36 = v35[1];
    if ( v36 == -1 )
    {
      v79 = v35;
    }
    else if ( v36 )
    {
      v79 = *(_DWORD **)v35[2];
    }
    else
    {
      v79 = &unk_100ADF9C;
    }
    v37 = v79[1];
    if ( v37 == -1 )
      *((_DWORD *)v74 + 6) = 0;
    else
      *((_DWORD *)v74 + 6) = v37;
    v38 = (void *)unknown_libname_4(32 * *((_DWORD *)v74 + 6) | -((unsigned __int64)*((_DWORD *)v74 + 6) >> 27 != 0));
    v39 = 32 * *((_DWORD *)v74 + 6);
    *((_DWORD *)v74 + 7) = v38;
    memset(v38, 0, v39);
    v80 = 0;
    if ( *((_DWORD *)v74 + 6) )
    {
      v76 = 0;
      do
      {
        v40 = v79;
        v41 = v79[1];
        if ( v41 != -1 )
        {
          if ( v80 < v41 )
            v40 = *(void **)(v79[2] + 4 * v80);
          else
            v40 = &unk_100ADF9C;
        }
        v42 = *((_DWORD *)AssetTypeValueField::operator[]((int)v40, "first") + 3);
        if ( v42 )
        {
          if ( *(_DWORD *)v42 == 12 )
            v43 = *(const char **)(v42 + 8);
          else
            v43 = 0;
          v44 = v74;
          *(_DWORD *)(v76 + *((_DWORD *)v74 + 7)) = unknown_libname_4(strlen(v43) + 1);
          v45 = *(_BYTE **)(v76 + *((_DWORD *)v74 + 7));
          v46 = v43;
          do
          {
            v47 = *v46;
            *v45++ = *v46++;
          }
          while ( v47 );
        }
        else
        {
          v44 = v74;
          *(_DWORD *)(v76 + *((_DWORD *)v74 + 7)) = 0;
        }
        v48 = AssetTypeValueField::operator[]((int)v40, "second");
        v49 = (int)v48;
        v50 = *((_DWORD *)AssetTypeValueField::operator[]((int)v48, "preloadIndex") + 3);
        if ( v50 )
        {
          switch ( *(_DWORD *)v50 )
          {
            case 0xA:
              v51 = v76;
              *(_DWORD *)(v76 + *((_DWORD *)v44 + 7) + 4) = (signed int)*(float *)(v50 + 8);
              break;
            case 0xB:
              v51 = v76;
              *(_DWORD *)(v76 + *((_DWORD *)v44 + 7) + 4) = (signed int)*(double *)(v50 + 8);
              break;
            case 0xC:
            case 0xD:
            case 0xE:
              v51 = v76;
              *(_DWORD *)(v76 + *((_DWORD *)v44 + 7) + 4) = 0;
              break;
            case 2:
              v51 = v76;
              *(_DWORD *)(v76 + *((_DWORD *)v44 + 7) + 4) = *(_BYTE *)(v50 + 8);
              break;
            case 4:
              v51 = v76;
              *(_DWORD *)(v76 + *((_DWORD *)v44 + 7) + 4) = *(_WORD *)(v50 + 8);
              break;
            default:
              v51 = v76;
              *(_DWORD *)(v76 + *((_DWORD *)v44 + 7) + 4) = *(_DWORD *)(v50 + 8);
              break;
          }
        }
        else
        {
          v51 = v76;
        }
        v52 = *((_DWORD *)AssetTypeValueField::operator[](v49, "preloadSize") + 3);
        if ( v52 )
        {
          switch ( *(_DWORD *)v52 )
          {
            case 0xA:
              v53 = (signed int)*(float *)(v52 + 8);
              break;
            case 0xB:
              v53 = (signed int)*(double *)(v52 + 8);
              break;
            case 0xC:
            case 0xD:
            case 0xE:
              v53 = 0;
              break;
            case 2:
              v53 = *(_BYTE *)(v52 + 8);
              break;
            case 4:
              v53 = *(_WORD *)(v52 + 8);
              break;
            default:
              v53 = *(_DWORD *)(v52 + 8);
              break;
          }
          *(_DWORD *)(v51 + *((_DWORD *)v44 + 7) + 8) = v53;
        }
        v54 = AssetTypeValueField::operator[](v49, "asset");
        v55 = *((_DWORD *)AssetTypeValueField::operator[]((int)v54, "m_FileID") + 3);
        if ( v55 )
        {
          switch ( *(_DWORD *)v55 )
          {
            case 0xA:
              v56 = (signed int)*(float *)(v55 + 8);
              break;
            case 0xB:
              v56 = (signed int)*(double *)(v55 + 8);
              break;
            case 0xC:
            case 0xD:
            case 0xE:
              v56 = 0;
              break;
            case 2:
              v56 = *(_BYTE *)(v55 + 8);
              break;
            case 4:
              v56 = *(_WORD *)(v55 + 8);
              break;
            default:
              v56 = *(_DWORD *)(v55 + 8);
              break;
          }
          *(_DWORD *)(v51 + *((_DWORD *)v44 + 7) + 16) = v56;
        }
        v57 = AssetTypeValueField::operator[](v49, "asset");
        v58 = *((_DWORD *)AssetTypeValueField::operator[]((int)v57, "m_PathID") + 3);
        if ( v58 )
        {
          switch ( *(_DWORD *)v58 )
          {
            case 0xA:
              v59 = (unsigned __int64)*(float *)(v58 + 8);
              break;
            case 0xB:
              v59 = (unsigned __int64)*(double *)(v58 + 8);
              break;
            case 0xC:
            case 0xD:
            case 0xE:
              v59 = 0i64;
              break;
            case 2:
              v59 = *(_BYTE *)(v58 + 8);
              break;
            case 4:
              v59 = *(_WORD *)(v58 + 8);
              break;
            case 6:
              v59 = *(_DWORD *)(v58 + 8);
              break;
            default:
              v59 = *(_QWORD *)(v58 + 8);
              break;
          }
          *(_QWORD *)(v51 + *((_DWORD *)v44 + 7) + 24) = v59;
        }
        ++v80;
        v76 = v51 + 32;
      }
      while ( v80 < *((_DWORD *)v44 + 6) );
    }
    v60 = AssetTypeValueField::operator[]((int)v77, "m_MainAsset");
    v61 = (int)v60;
    *((_DWORD *)v74 + 8) = 0;
    v62 = *((_DWORD *)AssetTypeValueField::operator[]((int)v60, "preloadIndex") + 3);
    if ( v62 )
    {
      switch ( *(_DWORD *)v62 )
      {
        case 0xA:
          v63 = (signed int)*(float *)(v62 + 8);
          break;
        case 0xB:
          v63 = (signed int)*(double *)(v62 + 8);
          break;
        case 0xC:
        case 0xD:
        case 0xE:
          v63 = 0;
          break;
        case 2:
          v63 = *(_BYTE *)(v62 + 8);
          break;
        case 4:
          v63 = *(_WORD *)(v62 + 8);
          break;
        default:
          v63 = *(_DWORD *)(v62 + 8);
          break;
      }
      *((_DWORD *)v74 + 9) = v63;
    }
    v64 = *((_DWORD *)AssetTypeValueField::operator[](v61, "preloadSize") + 3);
    if ( v64 )
    {
      switch ( *(_DWORD *)v64 )
      {
        case 0xA:
          v65 = (signed int)*(float *)(v64 + 8);
          break;
        case 0xB:
          v65 = (signed int)*(double *)(v64 + 8);
          break;
        case 0xC:
        case 0xD:
        case 0xE:
          v65 = 0;
          break;
        case 2:
          v65 = *(_BYTE *)(v64 + 8);
          break;
        case 4:
          v65 = *(_WORD *)(v64 + 8);
          break;
        default:
          v65 = *(_DWORD *)(v64 + 8);
          break;
      }
      *((_DWORD *)v74 + 10) = v65;
    }
    v66 = AssetTypeValueField::operator[](v61, "asset");
    v67 = *((_DWORD *)AssetTypeValueField::operator[]((int)v66, "m_FileID") + 3);
    if ( v67 )
    {
      switch ( *(_DWORD *)v67 )
      {
        case 0xA:
          v68 = (signed int)*(float *)(v67 + 8);
          break;
        case 0xB:
          v68 = (signed int)*(double *)(v67 + 8);
          break;
        case 0xC:
        case 0xD:
        case 0xE:
          v68 = 0;
          break;
        case 2:
          v68 = *(_BYTE *)(v67 + 8);
          break;
        case 4:
          v68 = *(_WORD *)(v67 + 8);
          break;
        default:
          v68 = *(_DWORD *)(v67 + 8);
          break;
      }
      *((_DWORD *)v74 + 12) = v68;
    }
    v69 = AssetTypeValueField::operator[](v61, "asset");
    v70 = *((_DWORD *)AssetTypeValueField::operator[]((int)v69, "m_PathID") + 3);
    if ( v70 )
    {
      switch ( *(_DWORD *)v70 )
      {
        case 0xA:
          v71 = (unsigned __int64)*(float *)(v70 + 8);
          break;
        case 0xB:
          v71 = (unsigned __int64)*(double *)(v70 + 8);
          break;
        case 0xC:
        case 0xD:
        case 0xE:
          v71 = 0i64;
          break;
        case 2:
          v71 = *(_BYTE *)(v70 + 8);
          break;
        case 4:
          v71 = *(_WORD *)(v70 + 8);
          break;
        case 6:
          v71 = *(_DWORD *)(v70 + 8);
          break;
        default:
          v71 = *(_QWORD *)(v70 + 8);
          break;
      }
      *((_QWORD *)v74 + 7) = v71;
    }
    v72 = *((_DWORD *)AssetTypeValueField::operator[]((int)v77, "m_RuntimeCompatibility") + 3);
    if ( v72 )
    {
      switch ( *(_DWORD *)v72 )
      {
        case 0xA:
          v73 = (signed __int64)*(float *)(v72 + 8);
          break;
        case 0xB:
          v73 = (signed __int64)*(double *)(v72 + 8);
          break;
        case 0xC:
        case 0xD:
        case 0xE:
          v73 = 0;
          break;
        default:
          v73 = *(_DWORD *)(v72 + 8);
          break;
      }
      *((_DWORD *)v74 + 20) = v73;
    }
    *((_BYTE *)v74 + 1) = 1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);

//----- (10003130) --------------------------------------------------------
void __thiscall AssetBundleAsset::ReadBundleFile(AssetBundleAsset *this, void *a2, int a3, int *a4, int a5, bool a6)
{
  AssetBundleAsset *v6; // edi@1
  size_t v7; // ecx@1
  size_t v8; // ST20_4@2
  void *v9; // eax@3
  int v10; // eax@3
  int v11; // eax@5
  int v12; // ecx@7
  int v13; // ST20_4@7
  int v14; // ecx@8
  int v15; // ecx@9
  int v16; // ST40_4@9
  int v17; // ecx@10
  int v18; // ST44_4@10
  int v19; // edx@10
  int v20; // ecx@10
  int v21; // ST38_4@10
  int v22; // ST34_4@10
  unsigned int *v23; // ST30_4@12
  size_t v24; // ecx@18
  size_t v25; // ST20_4@19
  void *v26; // ST40_4@20
  int v27; // eax@20
  int v28; // ecx@20
  unsigned int *v29; // ecx@21
  unsigned int v30; // ST24_4@21
  unsigned int *v31; // ecx@23
  unsigned int v32; // ST28_4@23
  unsigned int *v33; // ecx@25
  unsigned int v34; // ST2C_4@25
  int v35; // ecx@26
  int v36; // ecx@27
  int v37; // ST40_4@27
  int v38; // ecx@28
  int v39; // ST4C_4@28
  int v40; // edx@28
  int v41; // ecx@28
  int v42; // ST48_4@28
  int v43; // ST44_4@28
  unsigned int *v44; // ST30_4@30
  bool v45; // al@32
  int v46; // ST2C_4@33
  int v47; // ST2C_4@35
  int v48; // ST2C_4@37
  int v49; // ecx@38
  int v50; // edx@40
  int v51; // ST48_4@40
  int v52; // ST44_4@40
  int v53; // edx@40
  int v54; // eax@46
  int v55; // ST2C_4@46
  size_t v56; // ecx@49
  size_t v57; // ST2C_4@50
  void *v58; // ST34_4@51
  int v59; // eax@51
  size_t v60; // ecx@51
  size_t v61; // ST28_4@52
  void *v62; // ST34_4@53
  int v63; // eax@53
  size_t v64; // ecx@53
  size_t v65; // ST24_4@54
  void *v66; // ST34_4@55
  int v67; // eax@55
  int v68; // ecx@55
  int v69; // ST20_4@56
  int v70; // eax@59
  int v71; // ST30_4@59
  int v72; // eax@60
  int v73; // eax@61
  int v74; // ecx@62
  int v75; // ST30_4@62
  int v76; // edx@64
  int v77; // ST2C_4@64
  int v78; // ecx@68
  int v79; // ST30_4@68
  size_t v80; // edx@70
  size_t v81; // ST30_4@71
  void *v82; // eax@72
  int v83; // eax@72
  int v84; // eax@73
  int v85; // ST30_4@73
  int v86; // eax@74
  bool v87; // zf@74
  bool v88; // sf@74
  size_t v89; // ecx@75
  size_t v90; // ST30_4@76
  size_t v91; // [sp+10h] [bp-38h]@1
  size_t v92; // [sp+10h] [bp-38h]@18
  size_t v93; // [sp+10h] [bp-38h]@49
  size_t v94; // [sp+10h] [bp-38h]@51
  size_t v95; // [sp+10h] [bp-38h]@53
  size_t v96; // [sp+10h] [bp-38h]@70
  size_t v97; // [sp+10h] [bp-38h]@75
  unsigned int v98; // [sp+20h] [bp-28h]@5
  int v99; // [sp+20h] [bp-28h]@74
  int v100; // [sp+24h] [bp-24h]@17
  int v101; // [sp+24h] [bp-24h]@48
  unsigned int v102; // [sp+28h] [bp-20h]@16
  int v103; // [sp+28h] [bp-20h]@55
  int i; // [sp+28h] [bp-20h]@60
  int v105; // [sp+34h] [bp-14h]@47

  v6 = this;
  AssetBundleAsset::Clear(this);
  *((_DWORD *)v6 + 1) = a5;
  *(_BYTE *)v6 = 0;
  v7 = *(_DWORD *)((char *)a2 + *a4);
  v91 = *(_DWORD *)((char *)a2 + *a4);
  *a4 += 4;
  if ( a6 )
  {
    BYTE2(v8) = BYTE1(v7);
    BYTE3(v8) = v7;
    LOBYTE(v8) = BYTE3(v91);
    BYTE1(v8) = BYTE2(v91);
    v91 = v8;
    v7 = v8;
  }
  v9 = (void *)unknown_libname_4(v7 + 1);
  *((_DWORD *)v6 + 3) = v9;
  memcpy(v9, (char *)a2 + *a4, v91);
  *a4 += v91;
  *(_BYTE *)(v91 + *((_DWORD *)v6 + 3)) = 0;
  v10 = (*a4 + 3) & 0xFFFFFFFC;
  *a4 = v10;
  *((_DWORD *)v6 + 4) = *(_DWORD *)((char *)a2 + v10);
  *a4 += 4;
  if ( a6 )
    *((_DWORD *)v6 + 4) = *((_BYTE *)v6 + 19)
                        + ((*((_DWORD *)v6 + 4) >> 8) & 0xFF00)
                        + (((*((_DWORD *)v6 + 4) & 0xFF00) + (*((_DWORD *)v6 + 4) << 16)) << 8);
  *((_DWORD *)v6 + 5) = unknown_libname_4(16 * *((_DWORD *)v6 + 4) | -((unsigned __int64)*((_DWORD *)v6 + 4) >> 28 != 0));
  v11 = 0;
  v98 = 0;
  if ( *((_DWORD *)v6 + 4) )
  {
    do
    {
      *(_DWORD *)(v11 + *((_DWORD *)v6 + 5)) = *(_DWORD *)((char *)a2 + *a4);
      *a4 += 4;
      if ( a6 )
      {
        v12 = *((_DWORD *)v6 + 5);
        BYTE2(v13) = (unsigned __int16)*(_DWORD *)(v12 + v11) >> 8;
        BYTE3(v13) = *(_DWORD *)(v12 + v11);
        BYTE1(v13) = *(_DWORD *)(v12 + v11) >> 16;
        LOBYTE(v13) = *(_DWORD *)(v12 + v11) >> 24;
        *(_DWORD *)(v12 + v11) = v13;
      }
      v14 = *((_DWORD *)v6 + 5);
      *(_DWORD *)(v11 + v14 + 8) = 0;
      *(_DWORD *)(v11 + v14 + 12) = 0;
      if ( a5 < 14 )
      {
        *(_DWORD *)(v11 + *((_DWORD *)v6 + 5) + 8) = *(_DWORD *)((char *)a2 + *a4);
        *a4 += 4;
        if ( a6 )
        {
          v23 = (unsigned int *)(v11 + *((_DWORD *)v6 + 5) + 8);
          *v23 = *(_BYTE *)(v11 + *((_DWORD *)v6 + 5) + 11)
               + ((*v23 >> 8) & 0xFF00)
               + (((*v23 & 0xFF00) + (*v23 << 16)) << 8);
        }
      }
      else
      {
        v15 = *((_DWORD *)v6 + 5);
        v16 = *a4;
        *(_DWORD *)(v11 + v15 + 8) = *(_DWORD *)((char *)a2 + *a4);
        *(_DWORD *)(v11 + v15 + 12) = *(_DWORD *)((char *)a2 + v16 + 4);
        *a4 += 8;
        if ( a6 )
        {
          v17 = *((_DWORD *)v6 + 5);
          v18 = *(_DWORD *)(v11 + v17 + 8);
          v19 = *(_DWORD *)(v11 + v17 + 12);
          v20 = v11 + v17 + 8;
          BYTE2(v21) = BYTE1(v18);
          BYTE3(v21) = v18;
          LOBYTE(v21) = BYTE3(v18);
          BYTE1(v21) = BYTE2(v18);
          BYTE2(v22) = BYTE1(v19);
          BYTE3(v22) = v19;
          BYTE1(v22) = BYTE2(v19);
          LOBYTE(v22) = BYTE3(v19);
          *(_DWORD *)v20 = v22;
          *(_DWORD *)(v20 + 4) = v21;
        }
      }
      v11 += 16;
      ++v98;
    }
    while ( v98 < *((_DWORD *)v6 + 4) );
  }
  *((_DWORD *)v6 + 6) = *(_DWORD *)((char *)a2 + *a4);
  *a4 += 4;
  if ( a6 )
    *((_DWORD *)v6 + 6) = *((_BYTE *)v6 + 27)
                        + ((*((_DWORD *)v6 + 6) >> 8) & 0xFF00)
                        + (((*((_DWORD *)v6 + 6) & 0xFF00) + (*((_DWORD *)v6 + 6) << 16)) << 8);
  *((_DWORD *)v6 + 7) = unknown_libname_4(32 * *((_DWORD *)v6 + 6) | -((unsigned __int64)*((_DWORD *)v6 + 6) >> 27 != 0));
  v102 = 0;
  if ( *((_DWORD *)v6 + 6) )
  {
    v100 = 0;
    do
    {
      v24 = *(_DWORD *)((char *)a2 + *a4);
      v92 = *(_DWORD *)((char *)a2 + *a4);
      *a4 += 4;
      if ( a6 )
      {
        BYTE2(v25) = BYTE1(v24);
        BYTE3(v25) = v24;
        LOBYTE(v25) = BYTE3(v92);
        BYTE1(v25) = BYTE2(v92);
        v92 = v25;
        v24 = v25;
      }
      v26 = (void *)unknown_libname_4(v24 + 1);
      memcpy(v26, (char *)a2 + *a4, v92);
      *a4 += v92;
      *((_BYTE *)v26 + v92) = 0;
      v27 = v100;
      *(_DWORD *)(v100 + *((_DWORD *)v6 + 7)) = v26;
      v28 = (*a4 + 3) & 0xFFFFFFFC;
      *a4 = v28;
      *(_DWORD *)(v100 + *((_DWORD *)v6 + 7) + 4) = *(_DWORD *)((char *)a2 + v28);
      *a4 += 4;
      if ( a6 )
      {
        v29 = (unsigned int *)(v100 + *((_DWORD *)v6 + 7) + 4);
        BYTE2(v30) = (unsigned __int16)*v29 >> 8;
        BYTE3(v30) = *v29;
        BYTE1(v30) = *v29 >> 16;
        LOBYTE(v30) = *v29 >> 24;
        *v29 = v30;
      }
      *(_DWORD *)(v100 + *((_DWORD *)v6 + 7) + 8) = *(_DWORD *)((char *)a2 + *a4);
      *a4 += 4;
      if ( a6 )
      {
        v31 = (unsigned int *)(v100 + *((_DWORD *)v6 + 7) + 8);
        BYTE2(v32) = (unsigned __int16)*v31 >> 8;
        BYTE3(v32) = *v31;
        BYTE1(v32) = *v31 >> 16;
        LOBYTE(v32) = *v31 >> 24;
        *v31 = v32;
      }
      *(_DWORD *)(v100 + *((_DWORD *)v6 + 7) + 16) = *(_DWORD *)((char *)a2 + *a4);
      *a4 += 4;
      if ( a6 )
      {
        v33 = (unsigned int *)(v100 + *((_DWORD *)v6 + 7) + 16);
        BYTE2(v34) = (unsigned __int16)*v33 >> 8;
        BYTE3(v34) = *v33;
        BYTE1(v34) = *v33 >> 16;
        LOBYTE(v34) = *v33 >> 24;
        *v33 = v34;
      }
      v35 = *((_DWORD *)v6 + 7);
      *(_DWORD *)(v100 + v35 + 24) = 0;
      *(_DWORD *)(v100 + v35 + 28) = 0;
      if ( a5 < 14 )
      {
        *(_DWORD *)(v100 + *((_DWORD *)v6 + 7) + 24) = *(_DWORD *)((char *)a2 + *a4);
        *a4 += 4;
        if ( a6 )
        {
          v44 = (unsigned int *)(v100 + *((_DWORD *)v6 + 7) + 24);
          *v44 = *(_BYTE *)(v27 + *((_DWORD *)v6 + 7) + 27)
               + ((*v44 >> 8) & 0xFF00)
               + (((*v44 & 0xFF00) + (*v44 << 16)) << 8);
        }
      }
      else
      {
        v36 = *((_DWORD *)v6 + 7);
        v37 = *a4;
        *(_DWORD *)(v100 + v36 + 24) = *(_DWORD *)((char *)a2 + *a4);
        *(_DWORD *)(v100 + v36 + 28) = *(_DWORD *)((char *)a2 + v37 + 4);
        *a4 += 8;
        if ( a6 )
        {
          v38 = *((_DWORD *)v6 + 7);
          v39 = *(_DWORD *)(v100 + v38 + 24);
          v40 = *(_DWORD *)(v100 + v38 + 28);
          v41 = v100 + v38 + 24;
          BYTE2(v42) = BYTE1(v39);
          BYTE3(v42) = v39;
          LOBYTE(v42) = BYTE3(v39);
          BYTE1(v42) = BYTE2(v39);
          BYTE2(v43) = BYTE1(v40);
          BYTE3(v43) = v40;
          BYTE1(v43) = BYTE2(v40);
          LOBYTE(v43) = BYTE3(v40);
          *(_DWORD *)v41 = v43;
          *(_DWORD *)(v41 + 4) = v42;
        }
      }
      ++v102;
      v100 = v27 + 32;
    }
    while ( v102 < *((_DWORD *)v6 + 6) );
  }
  *((_DWORD *)v6 + 8) = 0;
  v45 = a6;
  *((_DWORD *)v6 + 9) = *(_DWORD *)((char *)a2 + *a4);
  *a4 += 4;
  if ( a6 )
  {
    BYTE2(v46) = (unsigned __int16)*((_DWORD *)v6 + 9) >> 8;
    BYTE3(v46) = *((_DWORD *)v6 + 9);
    BYTE1(v46) = *((_DWORD *)v6 + 9) >> 16;
    LOBYTE(v46) = *((_DWORD *)v6 + 9) >> 24;
    *((_DWORD *)v6 + 9) = v46;
  }
  *((_DWORD *)v6 + 10) = *(_DWORD *)((char *)a2 + *a4);
  *a4 += 4;
  if ( a6 )
  {
    BYTE2(v47) = (unsigned __int16)*((_DWORD *)v6 + 10) >> 8;
    BYTE3(v47) = *((_DWORD *)v6 + 10);
    BYTE1(v47) = *((_DWORD *)v6 + 10) >> 16;
    LOBYTE(v47) = *((_DWORD *)v6 + 10) >> 24;
    *((_DWORD *)v6 + 10) = v47;
  }
  *((_DWORD *)v6 + 12) = *(_DWORD *)((char *)a2 + *a4);
  *a4 += 4;
  if ( a6 )
  {
    BYTE2(v48) = (unsigned __int16)*((_DWORD *)v6 + 12) >> 8;
    BYTE3(v48) = *((_DWORD *)v6 + 12);
    BYTE1(v48) = *((_DWORD *)v6 + 12) >> 16;
    LOBYTE(v48) = *((_DWORD *)v6 + 12) >> 24;
    *((_DWORD *)v6 + 12) = v48;
  }
  *((_DWORD *)v6 + 14) = 0;
  *((_DWORD *)v6 + 15) = 0;
  v49 = *a4;
  if ( a5 < 14 )
  {
    *((_DWORD *)v6 + 14) = *(_DWORD *)((char *)a2 + v49);
    *a4 += 4;
    if ( !a6 )
      goto LABEL_44;
    v53 = ((*((_DWORD *)v6 + 14) >> 8) & 0xFF00)
        + *((_BYTE *)v6 + 59)
        + (((*((_DWORD *)v6 + 14) & 0xFF00) + (*((_DWORD *)v6 + 14) << 16)) << 8);
  }
  else
  {
    *((_DWORD *)v6 + 14) = *(_DWORD *)((char *)a2 + v49);
    *((_DWORD *)v6 + 15) = *(_DWORD *)((char *)a2 + v49 + 4);
    *a4 += 8;
    if ( !a6 )
      goto LABEL_44;
    v50 = *((_DWORD *)v6 + 15);
    BYTE2(v51) = (unsigned __int16)*((_DWORD *)v6 + 14) >> 8;
    BYTE3(v51) = *((_DWORD *)v6 + 14);
    BYTE1(v51) = *((_DWORD *)v6 + 14) >> 16;
    LOBYTE(v51) = *((_DWORD *)v6 + 14) >> 24;
    BYTE3(v52) = *((_DWORD *)v6 + 15);
    LOBYTE(v52) = *((_DWORD *)v6 + 15) >> 24;
    BYTE2(v52) = BYTE1(v50);
    BYTE1(v52) = *((_DWORD *)v6 + 15) >> 16;
    v53 = v52;
    *((_DWORD *)v6 + 15) = v51;
  }
  *((_DWORD *)v6 + 14) = v53;
LABEL_44:
  if ( a5 >= 14 )
  {
    *((_DWORD *)v6 + 16) = 0;
    *((_DWORD *)v6 + 17) = 0;
    *((_DWORD *)v6 + 18) = 0;
    *((_DWORD *)v6 + 19) = 0;
  }
  else
  {
    *((_DWORD *)v6 + 16) = *(_DWORD *)((char *)a2 + *a4);
    *a4 += 4;
    if ( a6 )
    {
      v54 = *((_DWORD *)v6 + 16);
      BYTE3(v55) = *((_DWORD *)v6 + 16);
      BYTE2(v55) = BYTE1(v54);
      BYTE1(v55) = *((_DWORD *)v6 + 16) >> 16;
      LOBYTE(v55) = *((_DWORD *)v6 + 16) >> 24;
      *((_DWORD *)v6 + 16) = v55;
    }
    *((_DWORD *)v6 + 17) = unknown_libname_4(16 * *((_DWORD *)v6 + 16) | -((unsigned __int64)*((_DWORD *)v6 + 16) >> 28 != 0));
    v105 = 0;
    if ( *((_DWORD *)v6 + 16) > 0 )
    {
      v101 = 0;
      do
      {
        v56 = *(_DWORD *)((char *)a2 + *a4);
        v93 = *(_DWORD *)((char *)a2 + *a4);
        *a4 += 4;
        if ( a6 )
        {
          BYTE2(v57) = BYTE1(v56);
          BYTE3(v57) = v56;
          LOBYTE(v57) = BYTE3(v93);
          BYTE1(v57) = BYTE2(v93);
          v93 = v57;
          v56 = v57;
        }
        v58 = (void *)unknown_libname_4(v56 + 1);
        memcpy(v58, (char *)a2 + *a4, v93);
        *a4 += v93;
        *((_BYTE *)v58 + v93) = 0;
        *(_DWORD *)(v101 + *((_DWORD *)v6 + 17)) = v58;
        v59 = (*a4 + 3) & 0xFFFFFFFC;
        *a4 = v59;
        v60 = *(_DWORD *)((char *)a2 + v59);
        v94 = *(_DWORD *)((char *)a2 + v59);
        *a4 = v59 + 4;
        if ( a6 )
        {
          BYTE2(v61) = BYTE1(v60);
          BYTE3(v61) = v60;
          LOBYTE(v61) = BYTE3(v94);
          BYTE1(v61) = BYTE2(v94);
          v94 = v61;
          v60 = v61;
        }
        v62 = (void *)unknown_libname_4(v60 + 1);
        memcpy(v62, (char *)a2 + *a4, v94);
        *a4 += v94;
        *((_BYTE *)v62 + v94) = 0;
        *(_DWORD *)(v101 + *((_DWORD *)v6 + 17) + 4) = v62;
        v63 = (*a4 + 3) & 0xFFFFFFFC;
        *a4 = v63;
        v64 = *(_DWORD *)((char *)a2 + v63);
        v95 = *(_DWORD *)((char *)a2 + v63);
        *a4 = v63 + 4;
        if ( a6 )
        {
          BYTE2(v65) = BYTE1(v64);
          BYTE3(v65) = v64;
          LOBYTE(v65) = BYTE3(v95);
          BYTE1(v65) = BYTE2(v95);
          v95 = v65;
          v64 = v65;
        }
        v66 = (void *)unknown_libname_4(v64 + 1);
        memcpy(v66, (char *)a2 + *a4, v95);
        *a4 += v95;
        *((_BYTE *)v66 + v95) = 0;
        *(_DWORD *)(v101 + *((_DWORD *)v6 + 17) + 8) = v66;
        v67 = (*a4 + 3) & 0xFFFFFFFC;
        *a4 = v67;
        v68 = *(_DWORD *)((char *)a2 + v67);
        v103 = *(_DWORD *)((char *)a2 + v67);
        *a4 = v67 + 4;
        if ( a6 )
        {
          BYTE2(v69) = BYTE1(v68);
          BYTE3(v69) = v68;
          LOBYTE(v69) = BYTE3(v103);
          BYTE1(v69) = BYTE2(v103);
          v68 = v69;
        }
        *(_DWORD *)(v101 + *((_DWORD *)v6 + 17) + 12) = v68;
        ++v105;
        v101 += 16;
      }
      while ( v105 < *((_DWORD *)v6 + 16) );
    }
    *((_DWORD *)v6 + 18) = *(_DWORD *)((char *)a2 + *a4);
    *a4 += 4;
    if ( a6 )
    {
      v70 = *((_DWORD *)v6 + 18);
      BYTE3(v71) = *((_DWORD *)v6 + 18);
      *(_WORD *)((char *)&v71 + 1) = __PAIR__(BYTE1(v70), (unsigned __int8)(*((_DWORD *)v6 + 18) >> 16));
      LOBYTE(v71) = *((_DWORD *)v6 + 18) >> 24;
      *((_DWORD *)v6 + 18) = v71;
    }
    *((_DWORD *)v6 + 19) = unknown_libname_4(8 * *((_DWORD *)v6 + 18) | -((unsigned __int64)*((_DWORD *)v6 + 18) >> 29 != 0));
    v72 = 0;
    for ( i = 0; v72 < *((_DWORD *)v6 + 18); i = v72 )
    {
      v73 = 8 * v72;
      *(_DWORD *)(v73 + *((_DWORD *)v6 + 19)) = *(_DWORD *)((char *)a2 + *a4);
      *a4 += 4;
      if ( a6 )
      {
        v74 = *((_DWORD *)v6 + 19);
        BYTE2(v75) = (unsigned __int16)*(_DWORD *)(v74 + v73) >> 8;
        BYTE3(v75) = *(_DWORD *)(v74 + v73);
        BYTE1(v75) = *(_DWORD *)(v74 + v73) >> 16;
        LOBYTE(v75) = *(_DWORD *)(v74 + v73) >> 24;
        *(_DWORD *)(v74 + v73) = v75;
      }
      *(_DWORD *)(*((_DWORD *)v6 + 19) + v73 + 4) = *(_DWORD *)((char *)a2 + *a4);
      *a4 += 4;
      if ( a6 )
      {
        v76 = *((_DWORD *)v6 + 19);
        BYTE2(v77) = (unsigned __int16)*(_DWORD *)(v76 + v73 + 4) >> 8;
        BYTE3(v77) = *(_DWORD *)(v76 + v73 + 4);
        BYTE1(v77) = *(_DWORD *)(v76 + v73 + 4) >> 16;
        LOBYTE(v77) = *(_DWORD *)(v76 + v73 + 4) >> 24;
        *(_DWORD *)(v76 + v73 + 4) = v77;
      }
      v72 = i + 1;
    }
    v45 = a6;
  }
  *((_DWORD *)v6 + 20) = *(_DWORD *)((char *)a2 + *a4);
  *a4 += 4;
  if ( v45 )
  {
    v78 = *((_DWORD *)v6 + 20);
    BYTE3(v79) = *((_DWORD *)v6 + 20);
    BYTE2(v79) = BYTE1(v78);
    BYTE1(v79) = *((_DWORD *)v6 + 20) >> 16;
    LOBYTE(v79) = *((_DWORD *)v6 + 20) >> 24;
    *((_DWORD *)v6 + 20) = v79;
  }
  if ( a5 >= 14 )
  {
    v80 = *(_DWORD *)((char *)a2 + *a4);
    v96 = *(_DWORD *)((char *)a2 + *a4);
    *a4 += 4;
    if ( v45 )
    {
      BYTE2(v81) = BYTE1(v80);
      BYTE3(v81) = v80;
      LOBYTE(v81) = BYTE3(v96);
      BYTE1(v81) = BYTE2(v96);
      v80 = v81;
      v96 = v81;
    }
    v82 = (void *)unknown_libname_4(v80 + 1);
    *((_DWORD *)v6 + 21) = v82;
    memcpy(v82, (char *)a2 + *a4, v96);
    *a4 += v96;
    *(_BYTE *)(v96 + *((_DWORD *)v6 + 21)) = 0;
    v83 = (*a4 + 3) & 0xFFFFFFFC;
    *a4 = v83;
    *((_DWORD *)v6 + 22) = *(_DWORD *)((char *)a2 + v83);
    *a4 += 4;
    if ( a6 )
    {
      v84 = *((_DWORD *)v6 + 22);
      BYTE3(v85) = *((_DWORD *)v6 + 22);
      *(_WORD *)((char *)&v85 + 1) = __PAIR__(BYTE1(v84), (unsigned __int8)(*((_DWORD *)v6 + 22) >> 16));
      LOBYTE(v85) = *((_DWORD *)v6 + 22) >> 24;
      *((_DWORD *)v6 + 22) = v85;
    }
    v86 = unknown_libname_4(4 * *((_DWORD *)v6 + 22) | -((unsigned __int64)*((_DWORD *)v6 + 22) >> 30 != 0));
    v87 = *((_DWORD *)v6 + 22) == 0;
    v88 = *((_DWORD *)v6 + 22) < 0;
    *((_DWORD *)v6 + 23) = v86;
    v99 = 0;
    if ( !v88 && !v87 )
    {
      do
      {
        v89 = *(_DWORD *)((char *)a2 + *a4);
        v97 = *(_DWORD *)((char *)a2 + *a4);
        *a4 += 4;
        if ( a6 )
        {
          BYTE2(v90) = BYTE1(v89);
          BYTE3(v90) = v89;
          LOBYTE(v90) = BYTE3(v97);
          BYTE1(v90) = BYTE2(v97);
          v97 = v90;
          v89 = v90;
        }
        *(_DWORD *)(*((_DWORD *)v6 + 23) + 4 * v99) = unknown_libname_4(v89 + 1);
        memcpy(*(void **)(*((_DWORD *)v6 + 23) + 4 * v99), (char *)a2 + *a4, v97);
        *a4 += v97;
        *(_BYTE *)(v97 + *(_DWORD *)(*((_DWORD *)v6 + 23) + 4 * v99)) = 0;
        *a4 = (*a4 + 3) & 0xFFFFFFFC;
        ++v99;
      }
      while ( v99 < *((_DWORD *)v6 + 22) );
    }
    *((_BYTE *)v6 + 96) = *((_BYTE *)a2 + *a4);
    *a4 += 4;
  }
  *((_BYTE *)v6 + 1) = 1;
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);

//----- (10003C80) --------------------------------------------------------
void __thiscall ResourceManagerFile::SetModified(ResourceManagerFile *this)
{
  *(_BYTE *)this = 1;
}

//----- (10003C90) --------------------------------------------------------
bool __thiscall ClassDatabasePackage::IsValid(ClassDatabasePackage *this)
{
  return *(_BYTE *)this;
}

//----- (10003CA0) --------------------------------------------------------
void __cdecl ASSETBUNDLEASSET_DecreaseIndexRefs(struct AssetBundleAsset *a1, int a2)
{
  unsigned int v2; // edi@1
  int v3; // edx@2
  int v4; // eax@3
  int v5; // ecx@3

  v2 = 0;
  if ( *((_DWORD *)a1 + 6) )
  {
    v3 = 0;
    do
    {
      v4 = *((_DWORD *)a1 + 7);
      v5 = *(_DWORD *)(v4 + v3 + 4);
      if ( v5 > a2 )
        *(_DWORD *)(v4 + v3 + 4) = v5 - 1;
      ++v2;
      v3 += 32;
    }
    while ( v2 < *((_DWORD *)a1 + 6) );
  }
}

//----- (10003CE0) --------------------------------------------------------
void __cdecl ASSETBUNDLEASSET_IncreaseIndexRefs(struct AssetBundleAsset *a1, int a2)
{
  unsigned int v2; // edi@1
  int v3; // edx@2
  int v4; // eax@3
  int v5; // ecx@3

  v2 = 0;
  if ( *((_DWORD *)a1 + 6) )
  {
    v3 = 0;
    do
    {
      v4 = *((_DWORD *)a1 + 7);
      v5 = *(_DWORD *)(v4 + v3 + 4);
      if ( v5 >= a2 )
        *(_DWORD *)(v4 + v3 + 4) = v5 + 1;
      ++v2;
      v3 += 32;
    }
    while ( v2 < *((_DWORD *)a1 + 6) );
  }
}

//----- (10003D20) --------------------------------------------------------
void __cdecl ASSETBUNDLEASSET_Optimize(size_t a1)
{
  size_t v1; // esi@1
  unsigned int v2; // ebx@1
  unsigned int v3; // edx@3
  _DWORD *v4; // eax@4
  unsigned int v5; // ecx@5
  unsigned int v6; // edi@5
  unsigned int v7; // edi@9
  int v8; // edx@10
  int v9; // eax@11
  signed int v10; // ecx@11
  void *v11; // edi@14
  unsigned int v12; // edx@16
  signed int v13; // ecx@17
  int v14; // eax@18
  int v15; // ebx@18
  int v16; // eax@18
  int v17; // edi@18
  void *v18; // ecx@20
  unsigned int v19; // [sp+8h] [bp-10h]@1
  void *v20; // [sp+Ch] [bp-Ch]@14
  signed int v21; // [sp+10h] [bp-8h]@2
  unsigned int v22; // [sp+14h] [bp-4h]@2
  signed int v23; // [sp+20h] [bp+8h]@2

  v1 = a1;
  v2 = 0;
  v19 = 0;
  if ( *(_DWORD *)(a1 + 16) )
  {
    v22 = 1;
    v21 = 16;
    v23 = -16;
    do
    {
      v3 = 0;
      if ( *(_DWORD *)(v1 + 24) )
      {
        v4 = (_DWORD *)(*(_DWORD *)(v1 + 28) + 8);
        while ( 1 )
        {
          v5 = *(v4 - 1);
          v6 = *v4 + v5 - 1;
          if ( v5 <= v6 && v2 >= v5 && v2 <= v6 )
            break;
          ++v3;
          v4 += 8;
          if ( v3 >= *(_DWORD *)(v1 + 24) )
            goto LABEL_9;
        }
      }
      else
      {
LABEL_9:
        v7 = 0;
        if ( *(_DWORD *)(v1 + 24) )
        {
          v8 = 0;
          do
          {
            v9 = *(_DWORD *)(v1 + 28);
            v10 = *(_DWORD *)(v9 + v8 + 4);
            if ( v10 > (signed int)v2 )
              *(_DWORD *)(v9 + v8 + 4) = v10 - 1;
            ++v7;
            v8 += 32;
          }
          while ( v7 < *(_DWORD *)(v1 + 24) );
        }
        v11 = (void *)unknown_libname_4(16 * (*(_DWORD *)(v1 + 16) - 1) | -((unsigned __int64)(unsigned int)(*(_DWORD *)(v1 + 16) - 1) >> 28 != 0));
        v20 = v11;
        if ( v2 )
          memcpy(v11, *(const void **)(v1 + 20), v23);
        v12 = v22;
        if ( v22 < *(_DWORD *)(v1 + 16) )
        {
          v13 = v21;
          do
          {
            v14 = *(_DWORD *)(v1 + 20);
            v15 = *(_DWORD *)(v14 + v13);
            v16 = v13 + v14;
            v17 = (int)v11 + v13 - 16;
            *(_DWORD *)v17 = v15;
            *(_DWORD *)(v17 + 4) = *(_DWORD *)(v16 + 4);
            *(_DWORD *)(v17 + 8) = *(_DWORD *)(v16 + 8);
            *(_DWORD *)(v17 + 12) = *(_DWORD *)(v16 + 12);
            v11 = v20;
            ++v12;
            v13 += 16;
          }
          while ( v12 < *(_DWORD *)(v1 + 16) );
          v2 = v19;
        }
        v18 = *(void **)(v1 + 20);
        --*(_DWORD *)(v1 + 16);
        operator delete[](v18);
        --v22;
        v23 -= 16;
        --v2;
        v21 -= 16;
        *(_DWORD *)(v1 + 20) = v11;
      }
      ++v22;
      v23 += 16;
      v21 += 16;
      v19 = ++v2;
    }
    while ( v2 < *(_DWORD *)(v1 + 16) );
  }
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 10099190: using guessed type void __cdecl operator delete[](void *);

//----- (10003E70) --------------------------------------------------------
int __cdecl ASSETBUNDLEASSET_GetRefCount(struct AssetBundleAsset *a1, int a2)
{
  unsigned int v2; // ebx@1
  int result; // eax@1
  unsigned int v4; // esi@1
  _DWORD *v5; // ecx@2
  int v6; // edx@3
  int v7; // edi@3

  v2 = *((_DWORD *)a1 + 6);
  result = 0;
  v4 = 0;
  if ( v2 )
  {
    v5 = (_DWORD *)(*((_DWORD *)a1 + 7) + 8);
    while ( 1 )
    {
      v6 = *(v5 - 1);
      v7 = *v5 + v6 - 1;
      if ( v6 <= v7 && a2 >= v6 && a2 <= v7 )
        break;
      ++v4;
      v5 += 8;
      if ( v4 >= v2 )
        return result;
    }
    result = 1;
  }
  return result;
}

//----- (10003EC0) --------------------------------------------------------
int __thiscall AssetBundleAsset::AddContainer(AssetBundleAsset *this, struct ContainerData *a2)
{
  AssetBundleAsset *v2; // esi@1
  void *v3; // ebx@1
  struct ContainerData *v4; // edi@1
  int v5; // eax@1
  int v6; // eax@1
  int v7; // ecx@1
  void *v8; // ebx@1
  int v9; // eax@1
  void *v10; // eax@1
  int v11; // eax@1
  struct ContainerData *v13; // [sp+14h] [bp+8h]@1

  v2 = this;
  v3 = (void *)unknown_libname_4(16 * (*((_DWORD *)this + 4) + 1) | -((unsigned __int64)(unsigned int)(*((_DWORD *)this + 4) + 1) >> 28 != 0));
  memcpy(v3, *((const void **)v2 + 5), 16 * *((_DWORD *)v2 + 4));
  v4 = a2;
  *((_DWORD *)v3 + 4 * *((_DWORD *)v2 + 4)) = *((_DWORD *)a2 + 4);
  v5 = 2 * *((_DWORD *)v2 + 4);
  *((_DWORD *)v3 + 2 * v5 + 2) = *((_DWORD *)a2 + 6);
  *((_DWORD *)v3 + 2 * v5 + 3) = *((_DWORD *)a2 + 7);
  v13 = (struct ContainerData *)*((_DWORD *)v2 + 4);
  *((_DWORD *)v2 + 4) = (char *)v13 + 1;
  operator delete[](*((void **)v2 + 5));
  v6 = 32 * (*((_DWORD *)v2 + 6) + 1);
  v7 = (unsigned __int64)(unsigned int)(*((_DWORD *)v2 + 6) + 1) >> 27 != 0;
  *((_DWORD *)v2 + 5) = v3;
  v8 = (void *)unknown_libname_4(v6 | -v7);
  memcpy(v8, *((const void **)v2 + 7), 32 * *((_DWORD *)v2 + 6));
  *((_DWORD *)v8 + 8 * *((_DWORD *)v2 + 6) + 1) = v13;
  *((_DWORD *)v8 + 8 * *((_DWORD *)v2 + 6) + 2) = 1;
  *((_DWORD *)v8 + 8 * *((_DWORD *)v2 + 6)) = *(_DWORD *)v4;
  v9 = (int)v8 + 32 * *((_DWORD *)v2 + 6) + 16;
  *(_DWORD *)v9 = *((_DWORD *)v4 + 4);
  *(_DWORD *)(v9 + 4) = *((_DWORD *)v4 + 5);
  *(_DWORD *)(v9 + 8) = *((_DWORD *)v4 + 6);
  *(_DWORD *)(v9 + 12) = *((_DWORD *)v4 + 7);
  v10 = (void *)*((_DWORD *)v2 + 7);
  ++*((_DWORD *)v2 + 6);
  operator delete[](v10);
  v11 = *((_DWORD *)v2 + 4);
  *((_DWORD *)v2 + 7) = v8;
  return v11 - 1;
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 10099190: using guessed type void __cdecl operator delete[](void *);

//----- (10003FC0) --------------------------------------------------------
void __thiscall AssetBundleAsset::UpdatePreloadArray(size_t this, unsigned __int32 a2)
{
  size_t v2; // esi@1
  unsigned __int32 v3; // edi@2
  unsigned int v4; // ebx@2
  int v5; // esi@4
  int v6; // eax@4
  void *v7; // ebx@5
  int v8; // eax@5
  int v9; // ecx@5
  void *v10; // edx@5

  v2 = this;
  if ( *(_DWORD *)(this + 24) > a2 )
  {
    v3 = *(_DWORD *)(this + 28) + 32 * a2;
    v4 = *(_DWORD *)(v3 + 4);
    if ( *(_DWORD *)(this + 16) > v4 )
    {
      if ( ASSETBUNDLEASSET_GetRefCount((struct AssetBundleAsset *)this, *(_DWORD *)(v3 + 4)) == 1 )
      {
        *(_DWORD *)(*(_DWORD *)(v2 + 20) + 16 * v4) = *(_DWORD *)(v3 + 16);
        v5 = *(_DWORD *)(v2 + 20);
        v6 = 2 * *(_DWORD *)(v3 + 4);
        *(_DWORD *)(v5 + 8 * v6 + 8) = *(_DWORD *)(v3 + 24);
        *(_DWORD *)(v5 + 8 * v6 + 12) = *(_DWORD *)(v3 + 28);
      }
      else
      {
        v7 = (void *)unknown_libname_4(16 * (*(_DWORD *)(v2 + 16) + *(_DWORD *)(v3 + 8)) | -((unsigned __int64)(unsigned int)(*(_DWORD *)(v2 + 16) + *(_DWORD *)(v3 + 8)) >> 28 != 0));
        memcpy(v7, *(const void **)(v2 + 20), 16 * *(_DWORD *)(v2 + 16));
        memcpy((char *)v7 + 16 * *(_DWORD *)(v2 + 16), (char *)v7 + 16 * *(_DWORD *)(v3 + 4), 16 * *(_DWORD *)(v3 + 8));
        *((_DWORD *)v7 + 4 * *(_DWORD *)(v2 + 16)) = *(_DWORD *)(v3 + 16);
        v8 = 2 * *(_DWORD *)(v2 + 16);
        *((_DWORD *)v7 + 2 * v8 + 2) = *(_DWORD *)(v3 + 24);
        *((_DWORD *)v7 + 2 * v8 + 3) = *(_DWORD *)(v3 + 28);
        v9 = *(_DWORD *)(v3 + 8);
        *(_DWORD *)(v3 + 4) = *(_DWORD *)(v2 + 16);
        v10 = *(void **)(v2 + 20);
        *(_DWORD *)(v2 + 16) += v9;
        operator delete[](v10);
        *(_DWORD *)(v2 + 20) = v7;
        ASSETBUNDLEASSET_Optimize(v2);
      }
    }
  }
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 10099190: using guessed type void __cdecl operator delete[](void *);

//----- (100040C0) --------------------------------------------------------
void __thiscall AssetBundleAsset::RemoveContainer(AssetBundleAsset *this, unsigned __int32 a2)
{
  AssetBundleAsset *v2; // ebx@1
  unsigned __int32 v3; // eax@1
  unsigned __int32 v4; // esi@1
  void *v5; // edi@2
  unsigned int v6; // edx@4
  int v7; // eax@5
  void *v8; // edx@7
  unsigned int v9; // edi@7
  unsigned int v10; // edx@9
  _DWORD *v11; // eax@10
  unsigned int v12; // ecx@11
  unsigned int v13; // esi@11
  unsigned int v14; // esi@15
  int v15; // edx@16
  int v16; // eax@17
  signed int v17; // ecx@17
  void *v18; // esi@20
  unsigned int v19; // edx@22
  signed int v20; // ecx@23
  int v21; // eax@24
  int v22; // edi@24
  int v23; // eax@24
  int v24; // esi@24
  void *v25; // ecx@26
  unsigned int v26; // [sp+8h] [bp-10h]@7
  void *v27; // [sp+Ch] [bp-Ch]@20
  signed int v28; // [sp+10h] [bp-8h]@8
  unsigned int v29; // [sp+14h] [bp-4h]@8
  size_t v30; // [sp+20h] [bp+8h]@2
  signed int v31; // [sp+20h] [bp+8h]@8

  v2 = this;
  v3 = *((_DWORD *)this + 6);
  v4 = a2;
  if ( v3 > a2 )
  {
    v5 = (void *)unknown_libname_4(32 * (v3 - 1) | -((unsigned __int64)(v3 - 1) >> 27 != 0));
    v30 = (size_t)v5;
    if ( v4 )
      memcpy(v5, *((const void **)v2 + 7), 32 * v4);
    v6 = v4 + 1;
    if ( v4 + 1 < *((_DWORD *)v2 + 6) )
    {
      v7 = 32 * v6;
      do
      {
        qmemcpy((char *)v5 + v7 - 32, (const void *)(v7 + *((_DWORD *)v2 + 7)), 0x20u);
        v5 = (void *)v30;
        ++v6;
        v7 += 32;
      }
      while ( v6 < *((_DWORD *)v2 + 6) );
    }
    v8 = (void *)*((_DWORD *)v2 + 7);
    --*((_DWORD *)v2 + 6);
    operator delete[](v8);
    *((_DWORD *)v2 + 7) = v5;
    v9 = 0;
    v26 = 0;
    if ( *((_DWORD *)v2 + 4) )
    {
      v29 = 1;
      v28 = 16;
      v31 = -16;
      do
      {
        v10 = 0;
        if ( *((_DWORD *)v2 + 6) )
        {
          v11 = (_DWORD *)(*((_DWORD *)v2 + 7) + 8);
          while ( 1 )
          {
            v12 = *(v11 - 1);
            v13 = *v11 + v12 - 1;
            if ( v12 <= v13 && v9 >= v12 && v9 <= v13 )
              break;
            ++v10;
            v11 += 8;
            if ( v10 >= *((_DWORD *)v2 + 6) )
              goto LABEL_15;
          }
        }
        else
        {
LABEL_15:
          v14 = 0;
          if ( *((_DWORD *)v2 + 6) )
          {
            v15 = 0;
            do
            {
              v16 = *((_DWORD *)v2 + 7);
              v17 = *(_DWORD *)(v16 + v15 + 4);
              if ( v17 > (signed int)v9 )
                *(_DWORD *)(v16 + v15 + 4) = v17 - 1;
              ++v14;
              v15 += 32;
            }
            while ( v14 < *((_DWORD *)v2 + 6) );
          }
          v18 = (void *)unknown_libname_4(16 * (*((_DWORD *)v2 + 4) - 1) | -((unsigned __int64)(unsigned int)(*((_DWORD *)v2 + 4) - 1) >> 28 != 0));
          v27 = v18;
          if ( v9 )
            memcpy(v18, *((const void **)v2 + 5), v31);
          v19 = v29;
          if ( v29 < *((_DWORD *)v2 + 4) )
          {
            v20 = v28;
            do
            {
              v21 = *((_DWORD *)v2 + 5);
              v22 = *(_DWORD *)(v21 + v20);
              v23 = v20 + v21;
              v24 = (int)v18 + v20 - 16;
              *(_DWORD *)v24 = v22;
              *(_DWORD *)(v24 + 4) = *(_DWORD *)(v23 + 4);
              *(_DWORD *)(v24 + 8) = *(_DWORD *)(v23 + 8);
              *(_DWORD *)(v24 + 12) = *(_DWORD *)(v23 + 12);
              v18 = v27;
              ++v19;
              v20 += 16;
            }
            while ( v19 < *((_DWORD *)v2 + 4) );
            v9 = v26;
          }
          v25 = (void *)*((_DWORD *)v2 + 5);
          --*((_DWORD *)v2 + 4);
          operator delete[](v25);
          --v29;
          v31 -= 16;
          --v9;
          v28 -= 16;
          *((_DWORD *)v2 + 5) = v18;
        }
        ++v29;
        v31 += 16;
        v28 += 16;
        v26 = ++v9;
      }
      while ( v9 < *((_DWORD *)v2 + 4) );
    }
  }
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 10099190: using guessed type void __cdecl operator delete[](void *);

//----- (10004290) --------------------------------------------------------
int __thiscall sub_10004290(void *this)
{
  *(_DWORD *)this = &off_10099840;
  return std::exception::~exception();
}
// 10099180: using guessed type int std::exception::~exception(void);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (100042A0) --------------------------------------------------------
void *__thiscall sub_100042A0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10099840;
  std::exception::~exception();
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}
// 10099180: using guessed type int std::exception::~exception(void);
// 10099194: using guessed type void __cdecl operator delete(void *);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (100042D0) --------------------------------------------------------
int __usercall sub_100042D0@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  int v2; // ebx@1
  unsigned __int64 v3; // rax@2
  char *v4; // eax@5
  char v5; // cl@6
  char v6; // cl@8

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 80);
  if ( (char)v2 >= 0 )
  {
    v4 = (char *)(a1 + 20);
    do
      v5 = *v4++;
    while ( v5 );
    HIDWORD(v3) = &v4[-v1 - 21];
    LODWORD(v3) = v1 + 40;
    do
    {
      v6 = *(_BYTE *)v3;
      LODWORD(v3) = v3 + 1;
    }
    while ( v6 );
    LODWORD(v3) = v3 - (v1 + 41);
    if ( v2 & 0x100 )
      LODWORD(v3) = v3 + HIDWORD(v3) + 36;
    else
      v3 = (unsigned int)(v3 + HIDWORD(v3) + 26) + (unsigned __int64)strlen((const char *)v1) + 1;
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 64);
    if ( *(_QWORD *)(v1 + 64) )
      LODWORD(v3) = v3 - *(_DWORD *)(v1 + 72);
    else
      LODWORD(v3) = -1;
  }
  return v3;
}

//----- (10004360) --------------------------------------------------------
int __usercall sub_10004360@<eax>(int a1@<edi>)
{
  int result; // eax@1
  char *v2; // eax@5
  char v3; // cl@6
  int v4; // edx@7
  char *v5; // eax@7
  char v6; // cl@8
  int v7; // eax@9

  result = 0;
  if ( !strcmp((const char *)a1, "UnityArchive") )
  {
    result = *(_DWORD *)(a1 + 72);
  }
  else
  {
    if ( !strcmp((const char *)a1, "UnityFS") || !strcmp((const char *)a1, "UnityWeb") )
    {
      v2 = (char *)(a1 + 20);
      do
        v3 = *v2++;
      while ( v3 );
      v4 = (int)&v2[-a1 - 21];
      v5 = (char *)(a1 + 40);
      do
        v6 = *v5++;
      while ( v6 );
      v7 = (int)(&v5[v4 - 15] - a1);
      if ( *(_DWORD *)(a1 + 80) & 0x100 )
        result = v7 + 10;
      else
        result = v7 + strlen((const char *)a1) + 1;
    }
    if ( !(*(_BYTE *)(a1 + 80) & 0x80) )
      result += *(_DWORD *)(a1 + 72);
  }
  return result;
}

//----- (10004450) --------------------------------------------------------
char __thiscall AssetsBundleBlockAndDirectoryList06::Read(AssetsBundleBlockAndDirectoryList06 *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4, void (__cdecl *a5)(char *))
{
  unsigned __int64 (__cdecl *v5)(unsigned __int64, unsigned __int64, void *, __int32); // ebx@1
  AssetsBundleBlockAndDirectoryList06 *v6; // esi@1
  __int64 v7; // rax@1
  __int64 v8; // rax@2
  int *v9; // edi@3
  __int64 v10; // rax@3
  int v11; // edx@4
  int v12; // edi@4
  void *v13; // eax@4
  int v14; // edi@6
  __int64 v15; // rax@7
  int v16; // ecx@8
  __int64 v17; // rax@8
  unsigned int *v18; // ST30_4@9
  __int64 v19; // rax@9
  int v20; // edx@10
  __int16 v21; // ST28_2@10
  int *v22; // edi@11
  __int64 v23; // rax@11
  int v24; // ecx@12
  int v25; // edi@12
  void *v26; // eax@12
  int v27; // edi@14
  __int64 v28; // rax@15
  int v29; // eax@16
  int v30; // ecx@16
  int v31; // edx@16
  int v32; // eax@16
  int v33; // ST34_4@16
  int v34; // ST30_4@16
  __int64 v35; // rax@16
  __int64 v36; // rax@17
  __int64 v37; // rax@19
  int v38; // eax@20
  int v39; // ecx@24
  int v40; // edx@25
  int v42; // [sp+10h] [bp-58h]@18
  size_t v43; // [sp+10h] [bp-58h]@24
  int v44; // [sp+14h] [bp-54h]@5
  int v45; // [sp+14h] [bp-54h]@13
  char v46[40]; // [sp+3Ch] [bp-2Ch]@19
  unsigned __int64 v47; // [sp+70h] [bp+8h]@4
  unsigned __int64 v48; // [sp+70h] [bp+8h]@12
  unsigned __int64 v49; // [sp+70h] [bp+8h]@18

  v5 = a3;
  v6 = this;
  LODWORD(v7) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, AssetsBundleBlockAndDirectoryList06 *, __int32))a3)(
                  a2,
                  HIDWORD(a2),
                  8,
                  0,
                  this,
                  a4);
  if ( !v7 )
    goto LABEL_32;
  LODWORD(v8) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))a3)(
                  -1,
                  -1,
                  8,
                  0,
                  (char *)v6 + 8,
                  a4);
  if ( !v8 )
    goto LABEL_32;
  v9 = (int *)((char *)v6 + 16);
  LODWORD(v10) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))a3)(
                   -1,
                   -1,
                   4,
                   0,
                   (char *)v6 + 16,
                   a4);
  if ( !v10 )
    goto LABEL_32;
  v47 = a2 + 20;
  v11 = (((unsigned int)*v9 >> 8) & 0xFF00) + *((_BYTE *)v6 + 19) + (((*v9 & 0xFF00) + (*v9 << 16)) << 8);
  *v9 = v11;
  v12 = v11;
  v13 = malloc(12 * v11);
  *((_DWORD *)v6 + 5) = v13;
  if ( !v13 )
    goto LABEL_29;
  v44 = 0;
  if ( v12 )
  {
    v14 = 0;
    do
    {
      LODWORD(v15) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int, __int32))v5)(
                       -1,
                       -1,
                       4,
                       0,
                       v14 + *((_DWORD *)v6 + 5),
                       a4);
      if ( !v15 )
        goto LABEL_32;
      v16 = *((_DWORD *)v6 + 5);
      v5 = a3;
      *(_DWORD *)(v16 + v14) = *(_BYTE *)(v16 + v14 + 3)
                             + ((*(_DWORD *)(v16 + v14) >> 8) & 0xFF00)
                             + (((*(_DWORD *)(v16 + v14) & 0xFF00) + (*(_DWORD *)(v16 + v14) << 16)) << 8);
      LODWORD(v17) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int, __int32))a3)(
                       -1,
                       -1,
                       4,
                       0,
                       *((_DWORD *)v6 + 5) + v14 + 4,
                       a4);
      if ( !v17 )
        goto LABEL_32;
      v18 = (unsigned int *)(*((_DWORD *)v6 + 5) + v14 + 4);
      *v18 = *(_BYTE *)(*((_DWORD *)v6 + 5) + v14 + 7)
           + ((*v18 >> 8) & 0xFF00)
           + (((*v18 & 0xFF00) + (*v18 << 16)) << 8);
      LODWORD(v19) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int, __int32))a3)(
                       -1,
                       -1,
                       2,
                       0,
                       *((_DWORD *)v6 + 5) + v14 + 8,
                       a4);
      if ( !v19 )
        goto LABEL_32;
      v20 = *((_DWORD *)v6 + 5);
      HIBYTE(v21) = *(_WORD *)(v20 + v14 + 8);
      v47 += 10i64;
      LOBYTE(v21) = *(_WORD *)(v20 + v14 + 8) >> 8;
      *(_WORD *)(v20 + v14 + 8) = v21;
      v14 += 12;
    }
    while ( (unsigned int)++v44 < *((_DWORD *)v6 + 4) );
  }
  v22 = (int *)((char *)v6 + 24);
  LODWORD(v23) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))v5)(
                   -1,
                   -1,
                   4,
                   0,
                   (char *)v6 + 24,
                   a4);
  if ( !v23 )
    goto LABEL_32;
  v48 = v47 + 4;
  v24 = (((unsigned int)*v22 >> 8) & 0xFF00) + *((_BYTE *)v6 + 27) + (((*v22 & 0xFF00) + (*v22 << 16)) << 8);
  *v22 = v24;
  v25 = v24;
  v26 = malloc(24 * v24);
  *((_DWORD *)v6 + 7) = v26;
  if ( !v26 )
  {
LABEL_29:
    if ( a5 )
      a5("AssetsBundleBlockAndDirectoryList06 : Out of memory!");
    return 0;
  }
  v45 = 0;
  if ( !v25 )
    return 1;
  v27 = 0;
  while ( 1 )
  {
    LODWORD(v28) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int, __int32))v5)(
                     -1,
                     -1,
                     8,
                     0,
                     v27 + *((_DWORD *)v6 + 7),
                     a4);
    if ( !v28 )
      break;
    v29 = *((_DWORD *)v6 + 7);
    v30 = *(_DWORD *)(v29 + v27);
    v31 = *(_DWORD *)(v29 + v27 + 4);
    v32 = v27 + v29;
    BYTE2(v33) = BYTE1(v30);
    BYTE3(v33) = v30;
    BYTE1(v33) = BYTE2(v30);
    LOBYTE(v33) = BYTE3(v30);
    BYTE3(v34) = v31;
    LOBYTE(v34) = BYTE3(v31);
    BYTE2(v34) = BYTE1(v31);
    BYTE1(v34) = BYTE2(v31);
    *(_DWORD *)v32 = v34;
    *(_DWORD *)(v32 + 4) = v33;
    LODWORD(v35) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int, __int32))v5)(
                     -1,
                     -1,
                     8,
                     0,
                     *((_DWORD *)v6 + 7) + v27 + 8,
                     a4);
    if ( !v35 )
      break;
    sub_1000AEB0(*((_DWORD *)v6 + 7) + v27 + 8);
    LODWORD(v36) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int, _DWORD))v5)(
                     -1,
                     -1,
                     4,
                     0,
                     *((_DWORD *)v6 + 7) + v27 + 16,
                     a4);
    if ( !v36 )
      break;
    SwapEndians_((unsigned __int32 *)(*((_DWORD *)v6 + 7) + v27 + 16));
    v42 = 0;
    v49 = v48 + 20;
LABEL_19:
    LODWORD(v37) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))v5)(
                     -1,
                     -1,
                     40,
                     0,
                     v46,
                     a4);
    if ( !v37 )
      break;
    v38 = 0;
    while ( v46[v38] )
    {
      if ( ++v38 >= 40 )
      {
        v42 += 40;
        goto LABEL_19;
      }
    }
    v43 = v42 + v38 + 1;
    *(_DWORD *)(*((_DWORD *)v6 + 7) + v27 + 20) = malloc(v43);
    v39 = *(_DWORD *)(*((_DWORD *)v6 + 7) + v27 + 20);
    if ( !v39 )
      goto LABEL_29;
    if ( ((int (__cdecl *)(_DWORD, _DWORD, size_t, _DWORD, int, __int32))v5)(
           v49,
           HIDWORD(v49),
           v43,
           (unsigned __int64)(signed int)v43 >> 32,
           v39,
           a4) != v43
      || v40 != (unsigned __int64)(signed int)v43 >> 32 )
    {
      break;
    }
    v48 = (signed int)v43 + v49;
    v27 += 24;
    if ( (unsigned int)++v45 >= *((_DWORD *)v6 + 6) )
      return 1;
  }
LABEL_32:
  if ( !a5 )
    return 0;
  a5("AssetsBundleBlockAndDirectoryList06 : A file read error occured!");
  return 0;
}
// 10004450: using guessed type char var_2C[40];

//----- (100048A0) --------------------------------------------------------
void __thiscall AssetsBundleBlockAndDirectoryList06::Free(AssetsBundleBlockAndDirectoryList06 *this)
{
  AssetsBundleBlockAndDirectoryList06 *v1; // esi@1
  unsigned int v2; // ebx@4
  int v3; // edi@5

  v1 = this;
  if ( *((_DWORD *)this + 5) )
    free(*((void **)this + 5));
  if ( *((_DWORD *)v1 + 7) )
  {
    v2 = 0;
    if ( *((_DWORD *)v1 + 6) )
    {
      v3 = 0;
      do
      {
        if ( *(_DWORD *)(v3 + *((_DWORD *)v1 + 7) + 20) )
          free(*(void **)(v3 + *((_DWORD *)v1 + 7) + 20));
        ++v2;
        v3 += 24;
      }
      while ( v2 < *((_DWORD *)v1 + 6) );
    }
    free(*((void **)v1 + 7));
  }
  *(_DWORD *)v1 = 0;
  *((_DWORD *)v1 + 1) = 0;
  *((_DWORD *)v1 + 2) = 0;
  *((_DWORD *)v1 + 3) = 0;
  *((_DWORD *)v1 + 4) = 0;
  *((_DWORD *)v1 + 5) = 0;
  *((_DWORD *)v1 + 6) = 0;
  *((_DWORD *)v1 + 7) = 0;
}

//----- (10004910) --------------------------------------------------------
char __thiscall AssetsBundleBlockAndDirectoryList06::Write(AssetsBundleBlockAndDirectoryList06 *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 *a4, void (__cdecl *a5)(char *))
{
  AssetsBundleBlockAndDirectoryList06 *v5; // edi@1
  __int64 v6; // rax@1
  unsigned __int8 v7; // cf@2
  __int64 v8; // rax@2
  __int64 v9; // rax@3
  __int64 v10; // rax@6
  int v11; // edx@7
  __int64 v12; // rax@7
  int v13; // edx@8
  unsigned __int16 v14; // ST28_2@8
  __int64 v15; // rax@8
  int v16; // eax@9
  __int64 v17; // rax@10
  int v18; // edx@11
  int v19; // eax@14
  int v20; // ecx@14
  int v21; // eax@14
  __int64 v22; // rax@14
  int v23; // eax@15
  int v24; // ecx@15
  __int64 v25; // rax@15
  unsigned int v26; // eax@16
  __int64 v27; // rax@16
  unsigned int v28; // kr00_4@17
  __int64 v29; // rax@17
  int i; // [sp+10h] [bp-40h]@12
  int v32; // [sp+14h] [bp-3Ch]@3
  int v33; // [sp+18h] [bp-38h]@5
  int v34; // [sp+1Ch] [bp-34h]@15
  int v35; // [sp+24h] [bp-2Ch]@4
  int v36; // [sp+28h] [bp-28h]@8
  int v37; // [sp+2Ch] [bp-24h]@14
  int v38; // [sp+30h] [bp-20h]@14
  int v39; // [sp+34h] [bp-1Ch]@14
  int v40; // [sp+38h] [bp-18h]@15
  int v41; // [sp+3Ch] [bp-14h]@15
  int v42; // [sp+40h] [bp-10h]@14
  int v43; // [sp+44h] [bp-Ch]@14
  int v44; // [sp+4Ch] [bp-4h]@17

  v5 = this;
  LODWORD(v6) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, AssetsBundleBlockAndDirectoryList06 *, __int32))a2)(
                  *(_DWORD *)a4,
                  *((_DWORD *)a4 + 1),
                  8,
                  0,
                  this,
                  a3);
  if ( v6 )
  {
    v7 = __CFADD__(*(_DWORD *)a4, 8);
    *(_DWORD *)a4 += 8;
    *((_DWORD *)a4 + 1) += v7;
    LODWORD(v8) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))a2)(
                    -1,
                    -1,
                    8,
                    0,
                    (char *)v5 + 8,
                    a3);
    if ( v8 )
    {
      v7 = __CFADD__(*(_DWORD *)a4, 8);
      *(_DWORD *)a4 += 8;
      *((_DWORD *)a4 + 1) += v7;
      v32 = (*((_DWORD *)v5 + 4) >> 24)
          + ((*((_DWORD *)v5 + 4) >> 8) & 0xFF00)
          + (((*((_DWORD *)v5 + 4) << 16) + (*((_DWORD *)v5 + 4) & 0xFF00)) << 8);
      LODWORD(v9) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int *, __int32))a2)(
                      -1,
                      -1,
                      4,
                      0,
                      &v32,
                      a3);
      if ( v9 )
      {
        v7 = __CFADD__(*(_DWORD *)a4, 4);
        *(_DWORD *)a4 += 4;
        v35 = 0;
        *((_DWORD *)a4 + 1) += v7;
        if ( *((_DWORD *)v5 + 4) )
        {
          v33 = 0;
          while ( 1 )
          {
            v32 = (*(_DWORD *)(v33 + *((_DWORD *)v5 + 5) + 4) >> 24)
                + ((*(_DWORD *)(v33 + *((_DWORD *)v5 + 5) + 4) >> 8) & 0xFF00)
                + (((*(_DWORD *)(v33 + *((_DWORD *)v5 + 5) + 4) << 16)
                  + (*(_DWORD *)(v33 + *((_DWORD *)v5 + 5) + 4) & 0xFF00)) << 8);
            LODWORD(v10) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int *, __int32))a2)(
                             -1,
                             -1,
                             4,
                             0,
                             &v32,
                             a3);
            if ( !v10 )
              break;
            v7 = __CFADD__(*(_DWORD *)a4, 4);
            *(_DWORD *)a4 += 4;
            v11 = v33;
            *((_DWORD *)a4 + 1) += v7;
            v32 = (*(_DWORD *)(v11 + *((_DWORD *)v5 + 5)) >> 24)
                + ((*(_DWORD *)(v11 + *((_DWORD *)v5 + 5)) >> 8) & 0xFF00)
                + (((*(_DWORD *)(v11 + *((_DWORD *)v5 + 5)) & 0xFF00) + (*(_DWORD *)(v11 + *((_DWORD *)v5 + 5)) << 16)) << 8);
            LODWORD(v12) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(-1, -1, 4, 0, &v32, a3);
            if ( !v12 )
              break;
            v7 = __CFADD__(*(_DWORD *)a4, 4);
            *(_DWORD *)a4 += 4;
            v13 = v33;
            *((_DWORD *)a4 + 1) += v7;
            LOBYTE(v14) = *(_WORD *)(v13 + *((_DWORD *)v5 + 5) + 8) >> 8;
            HIBYTE(v14) = *(_WORD *)(v13 + *((_DWORD *)v5 + 5) + 8);
            v36 = v14;
            LODWORD(v15) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, _DWORD))a2)(
                             -1,
                             -1,
                             2,
                             0,
                             &v36,
                             a3);
            if ( !v15 )
              break;
            v7 = __CFADD__(*(_DWORD *)a4, 2);
            *(_DWORD *)a4 += 2;
            v16 = v35;
            *((_DWORD *)a4 + 1) += v7;
            v33 += 12;
            v35 = v16 + 1;
            if ( (unsigned int)(v16 + 1) >= *((_DWORD *)v5 + 4) )
              goto LABEL_10;
          }
        }
        else
        {
LABEL_10:
          v32 = (*((_DWORD *)v5 + 6) >> 24)
              + ((*((_DWORD *)v5 + 6) >> 8) & 0xFF00)
              + (((*((_DWORD *)v5 + 6) & 0xFF00) + (*((_DWORD *)v5 + 6) << 16)) << 8);
          LODWORD(v17) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(-1, -1, 4, 0, &v32, a3);
          if ( v17 )
          {
            v7 = __CFADD__(*(_DWORD *)a4, 4);
            *(_DWORD *)a4 += 4;
            v18 = 0;
            v35 = 0;
            *((_DWORD *)a4 + 1) += v7;
            if ( !*((_DWORD *)v5 + 6) )
              return 1;
            for ( i = 0; ; v18 = i )
            {
              v19 = *((_DWORD *)v5 + 7);
              v20 = *(_DWORD *)(v18 + v19);
              v21 = *(_DWORD *)(v18 + v19 + 4);
              v38 = v20;
              BYTE2(v37) = BYTE1(v20);
              BYTE3(v37) = v20;
              v39 = v21;
              BYTE1(v37) = BYTE2(v20);
              LOBYTE(v36) = BYTE3(v21);
              BYTE3(v36) = v21;
              LOBYTE(v37) = BYTE3(v20);
              BYTE2(v36) = BYTE1(v21);
              BYTE1(v36) = BYTE2(v21);
              v42 = v36;
              v43 = v37;
              LODWORD(v22) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int *, __int32))a2)(
                               -1,
                               -1,
                               8,
                               0,
                               &v42,
                               a3);
              if ( !v22 )
                break;
              v7 = __CFADD__(*(_DWORD *)a4, 8);
              *(_DWORD *)a4 += 8;
              *((_DWORD *)a4 + 1) += v7;
              v23 = *((_DWORD *)v5 + 7);
              v24 = *(_DWORD *)(i + v23 + 8);
              v41 = *(_DWORD *)(i + v23 + 12);
              BYTE3(v33) = v41;
              v40 = v24;
              BYTE2(v33) = BYTE1(v41);
              LOBYTE(v33) = BYTE3(v41);
              BYTE1(v34) = BYTE2(v24);
              BYTE2(v34) = BYTE1(v24);
              BYTE3(v34) = v24;
              LOBYTE(v34) = BYTE3(v24);
              BYTE1(v33) = BYTE2(v41);
              v42 = v33;
              v43 = v34;
              LODWORD(v25) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, _DWORD))a2)(
                               -1,
                               -1,
                               8,
                               0,
                               &v42,
                               a3);
              if ( !v25 )
                break;
              v7 = __CFADD__(*(_DWORD *)a4, 8);
              *(_DWORD *)a4 += 8;
              *((_DWORD *)a4 + 1) += v7;
              v26 = *(_DWORD *)(i + *((_DWORD *)v5 + 7) + 16);
              v32 = (v26 >> 24) + ((v26 >> 8) & 0xFF00) + (((v26 & 0xFF00) + (v26 << 16)) << 8);
              LODWORD(v27) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
                               -1,
                               -1,
                               4,
                               0,
                               &v32,
                               a3);
              if ( !v27 )
                break;
              v7 = __CFADD__(*(_DWORD *)a4, 4);
              *(_DWORD *)a4 += 4;
              *((_DWORD *)a4 + 1) += v7;
              v28 = strlen(*(const char **)(i + *((_DWORD *)v5 + 7) + 20));
              v7 = __CFADD__(v28 + 1, *(_DWORD *)a4);
              *(_DWORD *)a4 += v28 + 1;
              v44 = 0;
              *((_DWORD *)a4 + 1) += v7;
              LODWORD(v29) = ((int (__cdecl *)(signed int, signed int, unsigned int, int, _DWORD, __int32))a2)(
                               -1,
                               -1,
                               v28 + 1,
                               v44,
                               *(_DWORD *)(i + *((_DWORD *)v5 + 7) + 20),
                               a3);
              if ( !v29 )
                break;
              i += 24;
              if ( (unsigned int)++v35 >= *((_DWORD *)v5 + 6) )
                return 1;
            }
          }
        }
      }
    }
  }
  if ( a5 )
    a5("AssetsBundleHeader06 : A file write error occured!");
  return 0;
}
// 9: found interdependent unknown calls

//----- (10004D10) --------------------------------------------------------
bool __thiscall AssetsBundleHeader06::ReadInitial(AssetsBundleHeader06 *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, void (__cdecl *a4)(char *))
{
  unsigned int v4; // esi@1
  unsigned int v5; // edi@1
  unsigned int v6; // ebx@1
  __int64 v7; // rax@1
  char v8; // al@2
  int v9; // edx@2
  int v10; // kr00_4@2
  __int64 v11; // rax@5
  bool result; // al@8
  int v13; // esi@9
  __int64 v14; // rax@9
  char v15; // [sp+13h] [bp-5h]@1
  AssetsBundleHeader06 *v16; // [sp+14h] [bp-4h]@1

  v16 = this;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  LODWORD(v7) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a2)(0, 0, 1, 0, &v15, a3);
  if ( !v7 )
    goto LABEL_10;
  while ( 1 )
  {
    v8 = v15;
    v9 = (int)v16;
    v10 = v5 + 1;
    v6 = (__PAIR__(v6, v5++) + 1) >> 32;
    if ( v4 < 0xD )
      *((_BYTE *)v16 + v4) = v15;
    if ( !v8 )
      break;
    ++v4;
    LODWORD(v11) = ((int (__cdecl *)(int, unsigned int, signed int, _DWORD, char *, __int32))a2)(
                     v10,
                     v6,
                     1,
                     0,
                     &v15,
                     a3);
    if ( !v11 )
      goto LABEL_10;
  }
  *(_BYTE *)(v9 + 12) = 0;
  if ( !strcmp((const char *)v9, "UnityArchive") )
  {
    *(_DWORD *)(v9 + 16) = 6;
    return 1;
  }
  v13 = v9 + 16;
  LODWORD(v14) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int, __int32))a2)(
                   -1,
                   -1,
                   4,
                   0,
                   v9 + 16,
                   a3);
  if ( v14 )
  {
    *(_DWORD *)v13 = *(_BYTE *)(v13 + 3)
                   + ((*(_DWORD *)v13 >> 8) & 0xFF00)
                   + (((*(_DWORD *)v13 & 0xFF00) + (*(_DWORD *)v13 << 16)) << 8);
    result = 1;
  }
  else
  {
LABEL_10:
    if ( a4 )
      a4("AssetsBundleHeader06 : A file read error occured!");
    result = 0;
  }
  return result;
}

//----- (10004E30) --------------------------------------------------------
char __thiscall AssetsBundleHeader06::Read(AssetsBundleHeader06 *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, void (__cdecl *a4)(char *))
{
  unsigned int v4; // ebx@1
  __int64 v5; // rax@1
  char v6; // al@2
  int v7; // edx@2
  __int64 v8; // rax@5
  unsigned int v9; // ebx@9
  __int64 v10; // rax@9
  char v11; // al@10
  __int64 v12; // rax@13
  int v13; // ebx@15
  __int64 v14; // rax@15
  int v15; // ecx@16
  unsigned int v17; // ebx@20
  __int64 v18; // rax@20
  char v19; // al@21
  __int64 v20; // rax@24
  int v21; // ebx@26
  int v22; // ebx@26
  __int64 v23; // rax@26
  int v24; // ecx@27
  int v25; // eax@27
  int v26; // ebx@27
  __int64 v27; // rax@27
  int v28; // ebx@28
  __int64 v29; // rax@28
  int v30; // ebx@29
  __int64 v31; // rax@29
  char v32; // [sp+13h] [bp-15h]@1
  AssetsBundleHeader06 *v33; // [sp+14h] [bp-14h]@1
  __int64 v34; // [sp+18h] [bp-10h]@1
  int v35; // [sp+20h] [bp-8h]@27
  int v36; // [sp+24h] [bp-4h]@27

  v4 = 0;
  v33 = this;
  v34 = 0i64;
  LODWORD(v5) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a2)(0, 0, 1, 0, &v32, a3);
  if ( !v5 )
    goto LABEL_30;
  while ( 1 )
  {
    v6 = v32;
    v7 = (int)v33;
    ++v34;
    if ( v4 < 0xD )
      *((_BYTE *)v33 + v4) = v32;
    if ( !v6 )
      break;
    ++v4;
    LODWORD(v8) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a2)(
                    v34,
                    HIDWORD(v34),
                    1,
                    0,
                    &v32,
                    a3);
    if ( !v8 )
      goto LABEL_30;
  }
  *(_BYTE *)(v7 + 12) = 0;
  if ( !strcmp((const char *)v7, "UnityArchive") )
  {
    *(_DWORD *)(v7 + 16) = 6;
  }
  else
  {
    v13 = v7 + 16;
    LODWORD(v14) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int, __int32))a2)(
                     -1,
                     -1,
                     4,
                     0,
                     v7 + 16,
                     a3);
    if ( !v14 )
      goto LABEL_30;
    v15 = *(_BYTE *)(v13 + 3)
        + ((*(_DWORD *)v13 >> 8) & 0xFF00)
        + (((*(_DWORD *)v13 & 0xFF00) + (*(_DWORD *)v13 << 16)) << 8);
    *(_DWORD *)v13 = v15;
    if ( v15 != 6 )
    {
      if ( a4 )
        a4("That file version is not 6!");
      return 0;
    }
  }
  v9 = 0;
  LODWORD(v10) = ((int (__cdecl *)(signed int, signed int, _DWORD, _DWORD, _DWORD, _DWORD))a2)(-1, -1, 1, 0, &v32, a3);
  if ( !v10 )
    goto LABEL_30;
  while ( 1 )
  {
    v11 = v32;
    if ( v9 < 0x14 )
      *((_BYTE *)v33 + v9 + 20) = v32;
    if ( !v11 )
      break;
    ++v9;
    LODWORD(v12) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(-1, -1, 1, 0, &v32, a3);
    if ( !v12 )
      goto LABEL_30;
  }
  v17 = 0;
  *((_BYTE *)v33 + 39) = 0;
  LODWORD(v18) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(-1, -1, 1, 0, &v32, a3);
  if ( !v18 )
    goto LABEL_30;
  while ( 1 )
  {
    v19 = v32;
    if ( v17 < 0x14 )
      *((_BYTE *)v33 + v17 + 40) = v32;
    if ( !v19 )
      break;
    ++v17;
    LODWORD(v20) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(-1, -1, 1, 0, &v32, a3);
    if ( !v20 )
      goto LABEL_30;
  }
  v21 = (int)v33;
  *((_BYTE *)v33 + 59) = 0;
  v22 = v21 + 64;
  LODWORD(v23) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int, __int32))a2)(-1, -1, 8, 0, v22, a3);
  if ( !v23
    || (v24 = *(_DWORD *)(v22 + 4),
        v35 = *(_DWORD *)v22,
        BYTE6(v34) = BYTE1(v35),
        BYTE7(v34) = v35,
        v36 = v24,
        BYTE5(v34) = BYTE2(v35),
        BYTE3(v34) = v24,
        BYTE4(v34) = BYTE3(v35),
        BYTE1(v34) = BYTE2(v24),
        v25 = HIDWORD(v34),
        BYTE2(v34) = BYTE1(v24),
        LOBYTE(v34) = BYTE3(v24),
        *(_DWORD *)v22 = v34,
        *(_DWORD *)(v22 + 4) = v25,
        v26 = (int)v33 + 72,
        LODWORD(v27) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))a2)(
                         -1,
                         -1,
                         4,
                         0,
                         (char *)v33 + 72,
                         a3),
        !v27)
    || (*(_DWORD *)v26 = *(_BYTE *)(v26 + 3)
                       + ((*(_DWORD *)v26 >> 8) & 0xFF00)
                       + (((*(_DWORD *)v26 & 0xFF00) + (*(_DWORD *)v26 << 16)) << 8),
        v28 = (int)v33 + 76,
        LODWORD(v29) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(
                         -1,
                         -1,
                         4,
                         0,
                         (char *)v33 + 76,
                         a3),
        !v29)
    || (*(_DWORD *)v28 = *(_BYTE *)(v28 + 3)
                       + ((*(_DWORD *)v28 >> 8) & 0xFF00)
                       + (((*(_DWORD *)v28 & 0xFF00) + (*(_DWORD *)v28 << 16)) << 8),
        v30 = (int)v33 + 80,
        LODWORD(v31) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(
                         -1,
                         -1,
                         4,
                         0,
                         (char *)v33 + 80,
                         a3),
        !v31) )
  {
LABEL_30:
    if ( a4 )
    {
      a4("AssetsBundleHeader06 : A file read error occured!");
      return 0;
    }
    return 0;
  }
  *(_DWORD *)v30 = *(_BYTE *)(v30 + 3)
                 + ((*(_DWORD *)v30 >> 8) & 0xFF00)
                 + (((*(_DWORD *)v30 & 0xFF00) + (*(_DWORD *)v30 << 16)) << 8);
  return 1;
}

//----- (10005160) --------------------------------------------------------
char __thiscall AssetsBundleHeader06::Write(AssetsBundleHeader06 *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 *a4, void (__cdecl *a5)(char *))
{
  AssetsBundleHeader06 *v5; // edi@1
  unsigned int v6; // kr00_4@1
  int v7; // ecx@1
  __int64 v8; // rax@1
  unsigned __int8 v9; // cf@2
  __int64 v10; // rax@2
  char *v11; // eax@3
  char v12; // cl@4
  int v13; // eax@5
  __int64 v14; // rax@5
  char *v15; // eax@6
  char v16; // cl@7
  int v17; // eax@8
  __int64 v18; // rax@8
  __int64 v19; // rax@9
  __int64 v20; // rax@10
  __int64 v21; // rax@11
  __int64 v22; // rax@12
  __int64 v23; // rax@15
  int v25; // [sp+10h] [bp-10h]@2
  AssetsBundleHeader06 *v26; // [sp+14h] [bp-Ch]@1
  __int64 v27; // [sp+18h] [bp-8h]@9

  v5 = this;
  v6 = strlen((const char *)this);
  v7 = *(_DWORD *)a4;
  v26 = (AssetsBundleHeader06 *)(v6 + 1);
  LODWORD(v8) = ((int (__cdecl *)(int, _DWORD, unsigned int, _DWORD, AssetsBundleHeader06 *, __int32))a2)(
                  v7,
                  *((_DWORD *)a4 + 1),
                  v6 + 1,
                  0,
                  v5,
                  a3);
  if ( v8 )
  {
    v9 = __CFADD__(v26, *(_DWORD *)a4);
    *(_DWORD *)a4 += v26;
    *((_DWORD *)a4 + 1) += v9;
    v25 = (*((_DWORD *)v5 + 4) >> 24)
        + ((*((_DWORD *)v5 + 4) >> 8) & 0xFF00)
        + (((*((_DWORD *)v5 + 4) << 16) + (*((_DWORD *)v5 + 4) & 0xFF00)) << 8);
    LODWORD(v10) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int *, __int32))a2)(
                     -1,
                     -1,
                     4,
                     0,
                     &v25,
                     a3);
    if ( v10 )
    {
      v9 = __CFADD__(*(_DWORD *)a4, 4);
      *(_DWORD *)a4 += 4;
      v11 = (char *)v5 + 20;
      *((_DWORD *)a4 + 1) += v9;
      v26 = (AssetsBundleHeader06 *)((char *)v5 + 21);
      do
        v12 = *v11++;
      while ( v12 );
      v13 = v11 - (char *)v26 + 1;
      v9 = __CFADD__(v13, *(_DWORD *)a4);
      *(_DWORD *)a4 += v13;
      *((_DWORD *)a4 + 1) += v9;
      LODWORD(v14) = ((int (__cdecl *)(signed int, signed int, int, _DWORD, char *, __int32))a2)(
                       -1,
                       -1,
                       v13,
                       0,
                       (char *)v5 + 20,
                       a3);
      if ( v14 )
      {
        v15 = (char *)v5 + 40;
        v26 = (AssetsBundleHeader06 *)((char *)v5 + 41);
        do
          v16 = *v15++;
        while ( v16 );
        v17 = v15 - (char *)v26 + 1;
        v9 = __CFADD__(v17, *(_DWORD *)a4);
        *(_DWORD *)a4 += v17;
        *((_DWORD *)a4 + 1) += v9;
        LODWORD(v18) = ((int (__cdecl *)(signed int, signed int, int, _DWORD, char *, __int32))a2)(
                         -1,
                         -1,
                         v17,
                         0,
                         (char *)v5 + 40,
                         a3);
        if ( v18 )
        {
          v27 = sub_1000AF00(*((_DWORD *)v5 + 16), *((_DWORD *)v5 + 17));
          LODWORD(v19) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, __int64 *, __int32))a2)(
                           -1,
                           -1,
                           8,
                           0,
                           &v27,
                           a3);
          if ( v19 )
          {
            *a4 += 8i64;
            v25 = SwapEndians(*((_DWORD *)v5 + 18));
            LODWORD(v20) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int *, __int32))a2)(
                             -1,
                             -1,
                             4,
                             0,
                             &v25,
                             a3);
            if ( v20 )
            {
              *a4 += 4i64;
              v25 = SwapEndians(*((_DWORD *)v5 + 19));
              LODWORD(v21) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
                               -1,
                               -1,
                               4,
                               0,
                               &v25,
                               a3);
              if ( v21 )
              {
                *a4 += 4i64;
                v25 = SwapEndians(*((_DWORD *)v5 + 20));
                LODWORD(v22) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
                                 -1,
                                 -1,
                                 4,
                                 0,
                                 &v25,
                                 a3);
                if ( v22 )
                {
                  v9 = __CFADD__(*(_DWORD *)a4, 4);
                  *(_DWORD *)a4 += 4;
                  *((_DWORD *)a4 + 1) += v9;
                  if ( !strcmp((const char *)v5, "UnityWeb") || !strcmp((const char *)v5, "UnityRaw") )
                  {
                    v25 = 0;
                    LODWORD(v23) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int *, __int32))a2)(
                                     -1,
                                     -1,
                                     1,
                                     0,
                                     &v25,
                                     a3);
                    if ( !v23 )
                      goto LABEL_16;
                    ++*a4;
                  }
                  return 1;
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_16:
  if ( a5 )
    a5("AssetsBundleHeader06 : A file write error occured!");
  return 0;
}

//----- (100053F0) --------------------------------------------------------
char __thiscall AssetsBundleHeader03::Read(AssetsBundleHeader03 *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, void (__cdecl *a4)(char *))
{
  AssetsBundleHeader03 *v4; // esi@1
  __int64 v5; // rax@1
  __int64 v7; // rax@7
  int v8; // ecx@8
  __int64 v9; // rax@11
  int v10; // eax@12
  char v11; // cl@12
  __int64 v12; // rax@15
  __int64 v13; // rax@17
  int v14; // eax@18
  char v15; // cl@18
  __int64 v16; // rax@21
  __int64 v17; // rax@23
  __int64 v18; // rax@24
  __int64 v19; // rax@25
  __int64 v20; // rax@26
  void *v21; // eax@29
  __int64 v22; // rax@33
  unsigned __int32 v23; // ST18_4@34
  __int64 v24; // rax@34
  int v25; // ecx@35
  unsigned __int32 v26; // ST18_4@35
  __int64 v27; // rax@37
  __int64 v28; // rax@40
  __int64 v29; // rax@42
  char v30; // [sp+Fh] [bp-9h]@11
  int v31; // [sp+10h] [bp-8h]@11
  int v32; // [sp+14h] [bp-4h]@29

  v4 = this;
  LODWORD(v5) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, AssetsBundleHeader03 *, __int32))a2)(
                  0,
                  0,
                  9,
                  0,
                  this,
                  a3);
  if ( !v5 )
    goto LABEL_43;
  if ( strnicmp((const char *)v4, "UnityRaw", 9u) && strnicmp((const char *)v4, "UnityWeb", 9u) )
  {
    if ( a4 )
      a4("AssetsBundleHeader : Unknown file type!");
    return 0;
  }
  LODWORD(v7) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))a2)(
                  -1,
                  -1,
                  4,
                  0,
                  (char *)v4 + 16,
                  a3);
  if ( !v7 )
    goto LABEL_43;
  v8 = *((_BYTE *)v4 + 19)
     + ((*((_DWORD *)v4 + 4) >> 8) & 0xFF00)
     + (((*((_DWORD *)v4 + 4) & 0xFF00) + (*((_DWORD *)v4 + 4) << 16)) << 8);
  *((_DWORD *)v4 + 4) = v8;
  if ( v8 != 3 )
  {
    if ( a4 )
    {
      a4("AssetsBundleHeader : Either that file is invalid or it uses an unknown file version!");
      return 0;
    }
    return 0;
  }
  v31 = 0;
  LODWORD(v9) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))a2)(
                  -1,
                  -1,
                  1,
                  0,
                  &v30,
                  a3);
  if ( !v9 )
    goto LABEL_43;
  while ( 1 )
  {
    v10 = v31;
    v11 = v30;
    if ( (unsigned int)v31 < 0x14 )
      *((_BYTE *)v4 + v31 + 20) = v30;
    if ( !v11 )
      break;
    v31 = v10 + 1;
    LODWORD(v12) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))a2)(
                     -1,
                     -1,
                     1,
                     0,
                     &v30,
                     a3);
    if ( !v12 )
      goto LABEL_43;
  }
  *((_BYTE *)v4 + 39) = 0;
  v31 = 0;
  LODWORD(v13) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(-1, -1, 1, 0, &v30, a3);
  if ( !v13 )
    goto LABEL_43;
  while ( 1 )
  {
    v14 = v31;
    v15 = v30;
    if ( (unsigned int)v31 < 0x14 )
      *((_BYTE *)v4 + v31 + 40) = v30;
    if ( !v15 )
      break;
    v31 = v14 + 1;
    LODWORD(v16) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(-1, -1, 1, 0, &v30, a3);
    if ( !v16 )
      goto LABEL_43;
  }
  *((_BYTE *)v4 + 59) = 0;
  LODWORD(v17) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))a2)(
                   -1,
                   -1,
                   4,
                   0,
                   (char *)v4 + 60,
                   a3);
  if ( !v17 )
    goto LABEL_43;
  *((_DWORD *)v4 + 15) = *((_BYTE *)v4 + 63)
                       + ((*((_DWORD *)v4 + 15) >> 8) & 0xFF00)
                       + (((*((_DWORD *)v4 + 15) & 0xFF00) + (*((_DWORD *)v4 + 15) << 16)) << 8);
  LODWORD(v18) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(
                   -1,
                   -1,
                   4,
                   0,
                   (char *)v4 + 64,
                   a3);
  if ( !v18 )
    goto LABEL_43;
  *((_DWORD *)v4 + 16) = *((_BYTE *)v4 + 67)
                       + ((*((_DWORD *)v4 + 16) >> 8) & 0xFF00)
                       + (((*((_DWORD *)v4 + 16) & 0xFF00) + (*((_DWORD *)v4 + 16) << 16)) << 8);
  LODWORD(v19) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(
                   -1,
                   -1,
                   4,
                   0,
                   (char *)v4 + 68,
                   a3);
  if ( !v19 )
    goto LABEL_43;
  *((_DWORD *)v4 + 17) = *((_BYTE *)v4 + 71)
                       + ((*((_DWORD *)v4 + 17) >> 8) & 0xFF00)
                       + (((*((_DWORD *)v4 + 17) & 0xFF00) + (*((_DWORD *)v4 + 17) << 16)) << 8);
  LODWORD(v20) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(
                   -1,
                   -1,
                   4,
                   0,
                   (char *)v4 + 72,
                   a3);
  if ( !v20 )
    goto LABEL_43;
  SwapEndians_((unsigned __int32 *)v4 + 18);
  if ( *((_DWORD *)v4 + 19) )
    free(*((void **)v4 + 19));
  v32 = *((_DWORD *)v4 + 18);
  v21 = malloc(8 * v32);
  *((_DWORD *)v4 + 19) = v21;
  if ( v21 )
  {
    v31 = 0;
    if ( v32 )
    {
      do
      {
        LODWORD(v22) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int, __int32))a2)(
                         -1,
                         -1,
                         4,
                         0,
                         8 * v31 + *((_DWORD *)v4 + 19),
                         a3);
        if ( !v22 )
          goto LABEL_43;
        v23 = *(_DWORD *)(*((_DWORD *)v4 + 19) + 8 * v31);
        v32 = *((_DWORD *)v4 + 19) + 8 * v31;
        *(_DWORD *)v32 = SwapEndians(v23);
        LODWORD(v24) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, int, _DWORD))a2)(
                         -1,
                         -1,
                         4,
                         0,
                         8 * v31 + *((_DWORD *)v4 + 19) + 4,
                         a3);
        if ( !v24 )
          goto LABEL_43;
        v25 = *((_DWORD *)v4 + 19);
        v26 = *(_DWORD *)(8 * v31 + v25 + 4);
        v32 = 8 * v31 + v25 + 4;
        *(_DWORD *)v32 = SwapEndians(v26);
      }
      while ( (unsigned int)++v31 < *((_DWORD *)v4 + 18) );
    }
    if ( *((_DWORD *)v4 + 4) >= 2u )
    {
      LODWORD(v27) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(
                       -1,
                       -1,
                       4,
                       0,
                       (char *)v4 + 80,
                       a3);
      if ( !v27 )
        goto LABEL_43;
      SwapEndians_((unsigned __int32 *)v4 + 20);
    }
    if ( *((_DWORD *)v4 + 4) < 3u )
      goto LABEL_42;
    LODWORD(v28) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(
                     -1,
                     -1,
                     4,
                     0,
                     (char *)v4 + 84,
                     a3);
    if ( v28 )
    {
      *((_DWORD *)v4 + 21) = SwapEndians(*((_DWORD *)v4 + 21));
LABEL_42:
      LODWORD(v29) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, _DWORD))a2)(
                       -1,
                       -1,
                       1,
                       0,
                       (char *)v4 + 88,
                       a3);
      if ( v29 )
      {
        *((_DWORD *)v4 + 23) = 1;
        return 1;
      }
    }
LABEL_43:
    if ( !a4 )
      return 0;
    a4("AssetsBundleHeader : A file read error occured!");
    return 0;
  }
  if ( !a4 )
    return 0;
  a4("AssetsBundleHeader : Out of memory!");
  return 0;
}

//----- (10005820) --------------------------------------------------------
char __thiscall AssetsBundleHeader03::Write(AssetsBundleHeader03 *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 *a4, void (__cdecl *a5)(char *))
{
  AssetsBundleHeader03 *v5; // edi@1
  __int64 v6; // rax@1
  unsigned __int8 v7; // cf@2
  __int64 v8; // rax@2
  char *v9; // eax@3
  char v10; // cl@4
  int v11; // eax@5
  __int64 v12; // rax@5
  char *v13; // eax@6
  char v14; // dl@7
  __int64 v15; // rax@8
  __int64 v16; // rax@9
  __int64 v17; // rax@10
  __int64 v18; // rax@11
  __int64 v19; // rax@12
  __int64 v20; // rax@14
  int v21; // ecx@15
  __int64 v22; // rax@15
  int v23; // eax@16
  __int64 v24; // rax@18
  __int64 v25; // rax@21
  __int64 v26; // rax@23
  char result; // al@26
  int v28; // [sp+10h] [bp-8h]@2
  int v29; // [sp+14h] [bp-4h]@3

  v5 = this;
  LODWORD(v6) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, AssetsBundleHeader03 *, __int32))a2)(
                  *(_DWORD *)a4,
                  *((_DWORD *)a4 + 1),
                  9,
                  0,
                  this,
                  a3);
  if ( v6 )
  {
    v7 = __CFADD__(*(_DWORD *)a4, 9);
    *(_DWORD *)a4 += 9;
    *((_DWORD *)a4 + 1) += v7;
    v28 = (*((_DWORD *)v5 + 4) >> 24)
        + ((*((_DWORD *)v5 + 4) >> 8) & 0xFF00)
        + (((*((_DWORD *)v5 + 4) << 16) + (*((_DWORD *)v5 + 4) & 0xFF00)) << 8);
    LODWORD(v8) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int *, __int32))a2)(
                    -1,
                    -1,
                    4,
                    0,
                    &v28,
                    a3);
    if ( v8 )
    {
      v7 = __CFADD__(*(_DWORD *)a4, 4);
      *(_DWORD *)a4 += 4;
      v9 = (char *)v5 + 20;
      *((_DWORD *)a4 + 1) += v7;
      v29 = (int)v5 + 21;
      do
        v10 = *v9++;
      while ( v10 );
      v11 = (int)&v9[-v29 + 1];
      v7 = __CFADD__(v11, *(_DWORD *)a4);
      *(_DWORD *)a4 += v11;
      *((_DWORD *)a4 + 1) += v7;
      v29 = v11;
      LODWORD(v12) = ((int (__cdecl *)(signed int, signed int, int, _DWORD, char *, __int32))a2)(
                       -1,
                       -1,
                       v11,
                       0,
                       (char *)v5 + 20,
                       a3);
      if ( v12 )
      {
        v7 = __CFADD__(v29, *(_DWORD *)a4);
        *(_DWORD *)a4 += v29;
        *((_DWORD *)a4 + 1) += v7;
        v13 = (char *)v5 + 40;
        v29 = (int)v5 + 41;
        do
          v14 = *v13++;
        while ( v14 );
        LODWORD(v15) = ((int (__cdecl *)(signed int, signed int, char *, _DWORD, char *, __int32))a2)(
                         -1,
                         -1,
                         &v13[-v29 + 1],
                         0,
                         (char *)v5 + 40,
                         a3);
        if ( v15 )
        {
          v28 = SwapEndians(*((_DWORD *)v5 + 15));
          LODWORD(v16) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int *, __int32))a2)(
                           -1,
                           -1,
                           4,
                           0,
                           &v28,
                           a3);
          if ( v16 )
          {
            *a4 += 4i64;
            v28 = SwapEndians(*((_DWORD *)v5 + 16));
            LODWORD(v17) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(-1, -1, 4, 0, &v28, a3);
            if ( v17 )
            {
              *a4 += 4i64;
              v28 = SwapEndians(*((_DWORD *)v5 + 17));
              LODWORD(v18) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
                               -1,
                               -1,
                               4,
                               0,
                               &v28,
                               a3);
              if ( v18 )
              {
                *a4 += 4i64;
                v28 = SwapEndians(*((_DWORD *)v5 + 18));
                LODWORD(v19) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
                                 -1,
                                 -1,
                                 4,
                                 0,
                                 &v28,
                                 a3);
                if ( v19 )
                {
                  v7 = __CFADD__(*(_DWORD *)a4, 4);
                  *(_DWORD *)a4 += 4;
                  v29 = 0;
                  *((_DWORD *)a4 + 1) += v7;
                  if ( *((_DWORD *)v5 + 18) )
                  {
                    do
                    {
                      v28 = SwapEndians(*(_DWORD *)(*((_DWORD *)v5 + 19) + 8 * v29));
                      LODWORD(v20) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
                                       -1,
                                       -1,
                                       4,
                                       0,
                                       &v28,
                                       a3);
                      if ( !v20 )
                        goto LABEL_24;
                      v7 = __CFADD__(*(_DWORD *)a4, 4);
                      *(_DWORD *)a4 += 4;
                      v21 = v29;
                      *((_DWORD *)a4 + 1) += v7;
                      v28 = SwapEndians(*(_DWORD *)(*((_DWORD *)v5 + 19) + 8 * v21 + 4));
                      LODWORD(v22) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
                                       -1,
                                       -1,
                                       4,
                                       0,
                                       &v28,
                                       a3);
                      if ( !v22 )
                        goto LABEL_24;
                      v7 = __CFADD__(*(_DWORD *)a4, 4);
                      *(_DWORD *)a4 += 4;
                      v23 = v29;
                      *((_DWORD *)a4 + 1) += v7;
                      v29 = v23 + 1;
                    }
                    while ( (unsigned int)(v23 + 1) < *((_DWORD *)v5 + 18) );
                  }
                  if ( *((_DWORD *)v5 + 4) >= 2u )
                  {
                    v28 = SwapEndians(*((_DWORD *)v5 + 20));
                    LODWORD(v24) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
                                     -1,
                                     -1,
                                     4,
                                     0,
                                     &v28,
                                     a3);
                    if ( !v24 )
                      goto LABEL_24;
                    *a4 += 4i64;
                  }
                  if ( *((_DWORD *)v5 + 4) >= 3u )
                  {
                    v28 = SwapEndians(*((_DWORD *)v5 + 21));
                    LODWORD(v25) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
                                     -1,
                                     -1,
                                     4,
                                     0,
                                     &v28,
                                     a3);
                    if ( !v25 )
                      goto LABEL_24;
                    *a4 += 4i64;
                  }
                  LODWORD(v26) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))a2)(
                                   -1,
                                   -1,
                                   1,
                                   0,
                                   (char *)v5 + 88,
                                   a3);
                  if ( v26 )
                  {
                    v7 = __CFADD__((*(_DWORD *)a4)++, 1);
                    result = 1;
                    *((_DWORD *)a4 + 1) += v7;
                    return result;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_24:
  if ( a5 )
    a5("AssetsBundleHeader : A file write error occured!");
  return 0;
}

//----- (10005B10) --------------------------------------------------------
unsigned __int64 __thiscall AssetsBundleDirectoryInfo06::GetAbsolutePos(AssetsBundleDirectoryInfo06 *this, struct AssetsBundleFile *a2)
{
  return *(_QWORD *)this + (unsigned int)sub_10004360((int)a2);
}

//----- (10005B30) --------------------------------------------------------
int __thiscall AssetsBundleEntry::GetAbsolutePos(AssetsBundleEntry *this, struct AssetsBundleFile *a2)
{
  return *(_DWORD *)this + *((_DWORD *)a2 + 16);
}

//----- (10005B40) --------------------------------------------------------
char __thiscall AssetsList::Read(AssetsList *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 *a4, void (__cdecl *a5)(char *))
{
  unsigned __int64 *v5; // ebx@1
  void (__cdecl *v6)(char *); // edi@1
  AssetsList *v7; // esi@1
  unsigned __int64 v8; // ST00_8@1
  __int64 v9; // rax@1
  unsigned __int8 v10; // cf@2
  unsigned int v11; // eax@2
  __int16 v12; // dx@2
  unsigned int v13; // edi@2
  void *v14; // eax@4
  unsigned int i; // eax@5
  int v16; // edi@7
  __int64 v17; // rax@9
  int v18; // eax@10
  _DWORD *v19; // ecx@14
  int v20; // edx@15
  __int64 v21; // rax@17
  int v22; // ecx@18
  __int64 v23; // rax@18
  int v24; // ecx@19
  int v26; // [sp+Ch] [bp-4Ch]@8
  int v27; // [sp+Ch] [bp-4Ch]@14
  unsigned int v28; // [sp+24h] [bp-34h]@1
  unsigned __int64 *v29; // [sp+28h] [bp-30h]@1
  char v30[40]; // [sp+2Ch] [bp-2Ch]@9

  v5 = a4;
  v6 = a5;
  v7 = this;
  *(_DWORD *)this = *(_DWORD *)a4;
  v8 = *a4;
  v29 = a4;
  LODWORD(v9) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, unsigned int *, __int32))a2)(
                  v8,
                  HIDWORD(v8),
                  4,
                  0,
                  &v28,
                  a3);
  if ( !v9 )
  {
LABEL_24:
    if ( v6 )
      v6("AssetsList : A file read error occured!");
    return 0;
  }
  v10 = __CFADD__(*(_DWORD *)a4, 4);
  *(_DWORD *)a4 += 4;
  v11 = v28;
  v12 = v28;
  *((_DWORD *)a4 + 1) += v10;
  v13 = ((v11 >> 8) & 0xFF00) + (((v11 << 16) + (v12 & 0xFF00)) << 8) + (v11 >> 24);
  for ( *((_DWORD *)v7 + 1) = v13; v13 < *((_DWORD *)v7 + 3); ++v13 )
    free(*(void **)(*((_DWORD *)v7 + 2) + 4 * v13));
  v14 = realloc(*((void **)v7 + 2), 4 * *((_DWORD *)v7 + 1));
  *((_DWORD *)v7 + 2) = v14;
  if ( v14 )
  {
    for ( i = *((_DWORD *)v7 + 3); i < *((_DWORD *)v7 + 1); ++i )
      *(_DWORD *)(*((_DWORD *)v7 + 2) + 4 * i) = 0;
    v16 = 0;
    if ( !*((_DWORD *)v7 + 1) )
    {
LABEL_20:
      *((_DWORD *)v7 + 3) = *((_DWORD *)v7 + 1);
      return 1;
    }
    while ( 1 )
    {
      v26 = 0;
LABEL_9:
      LODWORD(v17) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))a2)(
                       -1,
                       -1,
                       40,
                       0,
                       v30,
                       a3);
      if ( !v17 )
        break;
      v18 = 0;
      while ( v30[v18] )
      {
        if ( ++v18 >= 40 )
        {
          v26 += 40;
          goto LABEL_9;
        }
      }
      v27 = v26 + v18 + 1;
      *(_DWORD *)(*((_DWORD *)v7 + 2) + 4 * v16) = realloc(*(void **)(*((_DWORD *)v7 + 2) + 4 * v16), v27 + 11);
      v19 = (_DWORD *)(*((_DWORD *)v7 + 2) + 4 * v16);
      if ( !*v19 )
        goto LABEL_21;
      if ( ((int (__cdecl *)(_DWORD, _DWORD, int, _DWORD, int, __int32))a2)(
             *(_DWORD *)v5,
             *((_DWORD *)v5 + 1),
             v27,
             (unsigned __int64)v27 >> 32,
             *v19 + 8,
             a3) != v27 )
        break;
      if ( v20 != (unsigned __int64)v27 >> 32 )
        break;
      LODWORD(v21) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, _DWORD, __int32))a2)(
                       -1,
                       -1,
                       4,
                       0,
                       *(_DWORD *)(*((_DWORD *)v7 + 2) + 4 * v16),
                       a3);
      if ( !v21 )
        break;
      v22 = *(_DWORD *)(*((_DWORD *)v7 + 2) + 4 * v16);
      *(_DWORD *)v22 = *(_BYTE *)(v22 + 3)
                     + ((*(_DWORD *)v22 >> 8) & 0xFF00)
                     + (((*(_DWORD *)v22 & 0xFF00) + (*(_DWORD *)v22 << 16)) << 8);
      LODWORD(v23) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int, __int32))a2)(
                       -1,
                       -1,
                       4,
                       0,
                       *(_DWORD *)(*((_DWORD *)v7 + 2) + 4 * v16) + 4,
                       a3);
      if ( !v23 )
        break;
      v24 = *(_DWORD *)(*((_DWORD *)v7 + 2) + 4 * v16);
      v5 = v29;
      *(_DWORD *)(v24 + 4) = *(_BYTE *)(v24 + 7)
                           + ((*(_DWORD *)(v24 + 4) >> 8) & 0xFF00)
                           + (((*(_DWORD *)(v24 + 4) & 0xFF00) + (*(_DWORD *)(v24 + 4) << 16)) << 8);
      *v5 += v27 + 8;
      if ( (unsigned int)++v16 >= *((_DWORD *)v7 + 1) )
        goto LABEL_20;
    }
    v6 = a5;
    goto LABEL_24;
  }
LABEL_21:
  if ( a5 )
  {
    a5("AssetsList : Out of memory!");
    return 0;
  }
  return 0;
}
// 10005B40: using guessed type char var_2C[40];

//----- (10005E10) --------------------------------------------------------
void __thiscall AssetsList::Free(AssetsList *this)
{
  AssetsList *v1; // esi@1
  unsigned int v2; // edi@1

  v1 = this;
  v2 = 0;
  if ( *((_DWORD *)this + 3) )
  {
    do
      free(*(void **)(*((_DWORD *)v1 + 2) + 4 * v2++));
    while ( v2 < *((_DWORD *)v1 + 3) );
  }
  if ( *((_DWORD *)v1 + 2) )
  {
    free(*((void **)v1 + 2));
    *((_DWORD *)v1 + 2) = 0;
    *((_DWORD *)v1 + 3) = 0;
  }
  else
  {
    *((_DWORD *)v1 + 2) = 0;
    *((_DWORD *)v1 + 3) = 0;
  }
}

//----- (10005E60) --------------------------------------------------------
bool __thiscall AssetsList::Write(AssetsList *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 *a4, void (__cdecl *a5)(char *))
{
  AssetsList *v5; // edi@1
  unsigned __int64 v6; // rax@1
  __int64 v7; // rax@1
  unsigned __int8 v8; // cf@2
  int v9; // ecx@5
  char *v10; // eax@3
  char v11; // bl@4
  int v12; // ebx@5
  __int64 v13; // rax@5
  int v14; // ebx@6
  __int64 v15; // rax@6
  __int64 v16; // rax@7
  int v18; // [sp+10h] [bp-8h]@1
  int v19; // [sp+14h] [bp-4h]@2

  v5 = this;
  v6 = *a4;
  v18 = (*((_DWORD *)this + 1) >> 24)
      + ((*((_DWORD *)this + 1) >> 8) & 0xFF00)
      + (((*((_DWORD *)this + 1) << 16) + (*((_DWORD *)this + 1) & 0xFF00)) << 8);
  LODWORD(v7) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, __int32))a2)(
                  v6,
                  HIDWORD(v6),
                  4,
                  0,
                  &v18,
                  a3);
  if ( v7 )
  {
    v8 = __CFADD__(*(_DWORD *)a4, 4);
    *(_DWORD *)a4 += 4;
    v19 = 0;
    *((_DWORD *)a4 + 1) += v8;
    if ( *((_DWORD *)v5 + 1) > 0u )
    {
      do
      {
        v10 = (char *)(*(_DWORD *)(*((_DWORD *)v5 + 2) + 4 * v19) + 8);
        do
          v11 = *v10++;
        while ( v11 );
        v12 = (int)&v10[-*(_DWORD *)(*((_DWORD *)v5 + 2) + 4 * v19) - 8];
        v9 = *(_DWORD *)(*((_DWORD *)v5 + 2) + 4 * v19) + 8;
        LODWORD(v13) = ((int (__cdecl *)(signed int, signed int, char *, _DWORD, int, __int32))a2)(
                         -1,
                         -1,
                         &v10[-v9],
                         0,
                         v9,
                         a3);
        if ( !v13 )
          break;
        v8 = __CFADD__(v12, *(_DWORD *)a4);
        *(_DWORD *)a4 += v12;
        v14 = v19;
        *((_DWORD *)a4 + 1) += v8;
        v18 = (**(_DWORD **)(*((_DWORD *)v5 + 2) + 4 * v14) >> 24)
            + ((**(_DWORD **)(*((_DWORD *)v5 + 2) + 4 * v14) >> 8) & 0xFF00)
            + (((**(_DWORD **)(*((_DWORD *)v5 + 2) + 4 * v14) << 16)
              + (**(_DWORD **)(*((_DWORD *)v5 + 2) + 4 * v14) & 0xFF00)) << 8);
        LODWORD(v15) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int *, __int32))a2)(
                         -1,
                         -1,
                         4,
                         0,
                         &v18,
                         a3);
        if ( !v15 )
          break;
        v18 = (*(_DWORD *)(*(_DWORD *)(*((_DWORD *)v5 + 2) + 4 * v14) + 4) >> 24)
            + ((*(_DWORD *)(*(_DWORD *)(*((_DWORD *)v5 + 2) + 4 * v14) + 4) >> 8) & 0xFF00)
            + (((*(_DWORD *)(*(_DWORD *)(*((_DWORD *)v5 + 2) + 4 * v14) + 4) << 16)
              + (*(_DWORD *)(*(_DWORD *)(*((_DWORD *)v5 + 2) + 4 * v14) + 4) & 0xFF00)) << 8);
        LODWORD(v16) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(-1, -1, 4, 0, &v18, a3);
        if ( !v16 )
          break;
        *a4 += 8i64;
        v19 = v14 + 1;
      }
      while ( (unsigned int)(v14 + 1) < *((_DWORD *)v5 + 1) );
    }
  }
  if ( a5 )
    a5("AssetsList : A file write error occured!");
  return 0;
}

//----- (10006000) --------------------------------------------------------
char __thiscall AssetsList::Write(AssetsList *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5, bool a6, unsigned __int64 *a7, unsigned __int64 *a8, void (__cdecl *a9)(char *))
{
  AssetsList *v9; // edi@1
  signed int v10; // ecx@2
  __int64 v11; // rax@4
  int v12; // esi@5
  _DWORD *v13; // edx@6
  char *v14; // eax@7
  char v15; // cl@8
  int v16; // eax@9
  bool v17; // zf@9
  int v18; // ecx@14
  char *v19; // eax@14
  char v20; // dl@15
  __int64 v21; // rax@16
  unsigned int v22; // esi@17
  __int64 v23; // rax@17
  __int64 v24; // rax@18
  char *v25; // eax@21
  int v27; // ebx@29
  int v28; // ecx@29
  unsigned int v29; // esi@29
  int v30; // eax@36
  unsigned __int8 v31; // cf@36
  int v32; // eax@39
  unsigned int v33; // [sp+10h] [bp-138h]@13
  char *v34; // [sp+10h] [bp-138h]@21
  char v35; // [sp+17h] [bp-131h]@28
  signed int v36; // [sp+18h] [bp-130h]@5
  unsigned int v37; // [sp+18h] [bp-130h]@27
  int v38; // [sp+1Ch] [bp-12Ch]@4
  unsigned int v39; // [sp+20h] [bp-128h]@6
  int v40; // [sp+24h] [bp-124h]@2
  __int64 v41; // [sp+28h] [bp-120h]@1
  unsigned __int64 (__cdecl *v42)(unsigned __int64, unsigned __int64, const void *, __int32); // [sp+34h] [bp-114h]@1
  unsigned __int64 (__cdecl *v43)(unsigned __int64, unsigned __int64, void *, __int32); // [sp+38h] [bp-110h]@1
  unsigned __int64 *v44; // [sp+3Ch] [bp-10Ch]@1
  char v45; // [sp+40h] [bp-108h]@22

  v43 = a2;
  v9 = this;
  v42 = a4;
  v44 = a7;
  LODWORD(v41) = a9;
  if ( a8 )
  {
    v10 = *(_DWORD *)a8;
    v40 = *((_DWORD *)a8 + 1);
  }
  else
  {
    v10 = -1;
    v40 = -1;
  }
  v38 = (*((_DWORD *)v9 + 1) >> 24)
      + ((*((_DWORD *)v9 + 1) >> 8) & 0xFF00)
      + (((*((_DWORD *)v9 + 1) & 0xFF00) + (*((_DWORD *)v9 + 1) << 16)) << 8);
  LODWORD(v11) = ((int (__cdecl *)(signed int, int, signed int, _DWORD, int *, __int32))a4)(v10, v40, 4, 0, &v38, a5);
  if ( v11 )
  {
    v12 = 4;
    v36 = 4;
    if ( *((_DWORD *)v9 + 1) )
    {
      v13 = (_DWORD *)*((_DWORD *)v9 + 2);
      v39 = *((_DWORD *)v9 + 1);
      do
      {
        v14 = (char *)(*v13 + 8);
        do
          v15 = *v14++;
        while ( v15 );
        v16 = (int)(&v14[v36] - *v13);
        ++v13;
        v17 = v39-- == 1;
        v36 = v16;
      }
      while ( !v17 );
      v12 = v16;
    }
    if ( a8 )
      *a8 += (unsigned int)v12;
    v33 = 0;
    if ( *((_DWORD *)v9 + 1) <= 0u )
    {
LABEL_20:
      if ( a6 )
      {
        v39 = 256;
        v25 = (char *)malloc(0x100000u);
        v34 = v25;
        if ( v25 )
        {
          v39 = 0x100000;
        }
        else
        {
          v34 = &v45;
          v25 = &v45;
        }
        v41 = (unsigned int)v36;
        v37 = 0;
        if ( *((_DWORD *)v9 + 1) > 0u )
        {
          v35 = 0;
          do
          {
            v27 = 3 - (((_BYTE)v41 - 1) & 3);
            v38 = 0;
            ((void (__cdecl *)(signed int, signed int, int, _DWORD, int *, __int32))v42)(-1, -1, v27, 0, &v38, a5);
            v28 = *(_DWORD *)(*((_DWORD *)v9 + 2) + 4 * v37);
            v29 = *(_DWORD *)(v28 + 4);
            if ( v29 > v39 )
            {
              while ( 1 )
              {
                if ( v35 )
                  v32 = -1;
                else
                  v32 = *(_DWORD *)v9 + **(_DWORD **)(*((_DWORD *)v9 + 2) + 4 * v37);
                ((void (__cdecl *)(int, _DWORD, unsigned int, _DWORD, char *, __int32))v43)(v32, 0, v39, 0, v34, a3);
                ((void (__cdecl *)(signed int, signed int, unsigned int, _DWORD, char *, __int32))v42)(
                  -1,
                  -1,
                  v39,
                  0,
                  v34,
                  a5);
                v35 = 1;
              }
            }
            if ( v29 )
            {
              ((void (__cdecl *)(int, _DWORD, unsigned int, _DWORD, char *, __int32))v43)(
                *(_DWORD *)v28 + *(_DWORD *)v9,
                0,
                v29,
                0,
                v34,
                a3);
              ((void (__cdecl *)(signed int, signed int, unsigned int, _DWORD, char *, __int32))v42)(
                -1,
                -1,
                v29,
                0,
                v34,
                a5);
            }
            v41 += (unsigned int)(v27 + *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v9 + 2) + 4 * v37++) + 4));
          }
          while ( v37 < *((_DWORD *)v9 + 1) );
          v25 = v34;
        }
        if ( v25 != &v45 )
          free(v25);
        v30 = (int)v44;
        v31 = __CFADD__((_DWORD)v41, *(_DWORD *)v44);
        *(_DWORD *)v30 += v41;
        *(_DWORD *)(v30 + 4) += HIDWORD(v41) + v31;
      }
      return 1;
    }
    while ( 1 )
    {
      v18 = *(_DWORD *)(*((_DWORD *)v9 + 2) + 4 * v33) + 8;
      v19 = (char *)(*(_DWORD *)(*((_DWORD *)v9 + 2) + 4 * v33) + 8);
      v39 = *(_DWORD *)(*((_DWORD *)v9 + 2) + 4 * v33) + 9;
      do
        v20 = *v19++;
      while ( v20 );
      LODWORD(v21) = ((int (__cdecl *)(signed int, signed int, char *, _DWORD, int, __int32))a4)(
                       -1,
                       -1,
                       &v19[-v39 + 1],
                       0,
                       v18,
                       a5);
      if ( !v21 )
        break;
      v22 = (v12 + 3) & 0xFFFFFFFC;
      v38 = (v22 >> 24) + ((v22 >> 8) & 0xFF00) + (((v22 & 0xFF00) + (v22 << 16)) << 8);
      LODWORD(v23) = ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int *, __int32))a4)(
                       -1,
                       -1,
                       4,
                       0,
                       &v38,
                       a5);
      if ( !v23 )
        break;
      v38 = (*(_DWORD *)(*(_DWORD *)(*((_DWORD *)v9 + 2) + 4 * v33) + 4) >> 24)
          + ((*(_DWORD *)(*(_DWORD *)(*((_DWORD *)v9 + 2) + 4 * v33) + 4) >> 8) & 0xFF00)
          + (((*(_DWORD *)(*(_DWORD *)(*((_DWORD *)v9 + 2) + 4 * v33) + 4) & 0xFF00)
            + (*(_DWORD *)(*(_DWORD *)(*((_DWORD *)v9 + 2) + 4 * v33) + 4) << 16)) << 8);
      LODWORD(v24) = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a4)(-1, -1, 4, 0, &v38, a5);
      if ( !v24 )
        break;
      v12 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v9 + 2) + 4 * v33++) + 4) + v22;
      if ( v33 >= *((_DWORD *)v9 + 1) )
        goto LABEL_20;
    }
  }
  if ( (_DWORD)v41 )
    ((void (__cdecl *)(const char *))v41)("AssetsList : A file write error occured!");
  return 0;
}

//----- (100063B0) --------------------------------------------------------
int __cdecl AssetsBundle_AssetsFileReader(unsigned __int64 a1, unsigned __int64 a2, void *a3, __int32 a4)
{
  int v4; // edi@1
  int v5; // ecx@1
  _DWORD *v6; // edx@2
  __int64 v7; // rax@2
  unsigned int v8; // ecx@2
  int v9; // esi@2
  int v10; // esi@4
  int v11; // eax@4
  unsigned __int8 v12; // cf@5
  unsigned int v13; // esi@5
  unsigned int v14; // edi@6
  unsigned int v15; // edx@6
  int v16; // ebx@8
  unsigned __int64 v17; // kr18_8@12
  int v18; // ST14_4@13
  int v19; // esi@13
  unsigned int v20; // ST04_4@13
  int (__cdecl *v21)(unsigned int, unsigned int, int, _DWORD, void *, int); // edx@13
  unsigned int v23; // [sp+10h] [bp-8h]@5

  v4 = *(_DWORD *)a4;
  v5 = *(_DWORD *)(*(_DWORD *)a4 + 16);
  if ( v5 == 3 )
  {
    v6 = *(_DWORD **)(a4 + 4);
    LODWORD(v7) = *v6 + *(_DWORD *)(v4 + 64);
    HIDWORD(v7) = *(_DWORD *)(HIDWORD(v7) + 4);
    v8 = 0;
    v9 = 0;
  }
  else
  {
    if ( v5 != 6 )
      return 0;
    v10 = *(_DWORD *)(a4 + 4);
    v11 = sub_10004360(v4);
    HIDWORD(v7) = *(_DWORD *)(v10 + 8);
    v8 = (*(_QWORD *)v10 + (unsigned __int64)(unsigned int)v7) >> 32;
    LODWORD(v7) = *(_DWORD *)v10 + v7;
    v9 = *(_DWORD *)(v10 + 12);
  }
  v12 = __CFADD__((_DWORD)v7, HIDWORD(v7));
  v23 = v7 + HIDWORD(v7);
  HIDWORD(v7) = HIDWORD(a1);
  v13 = v8 + v12 + v9;
  if ( (HIDWORD(a1) & (unsigned int)a1) == -1 )
  {
    v14 = *(_DWORD *)(a4 + 24);
    v15 = *(_DWORD *)(a4 + 28);
  }
  else
  {
    HIDWORD(v7) = (v7 + __PAIR__(v8, (unsigned int)a1)) >> 32;
    v14 = v7 + a1;
  }
  v16 = a2;
  if ( a2 + __PAIR__(v15, v14) <= __PAIR__(v13, v23) )
    goto LABEL_13;
  if ( v13 > v15 || v13 >= v15 && v23 > v14 )
  {
    v17 = __PAIR__(v13, v23) - __PAIR__(v15, v14);
    HIDWORD(a2) = v17 >> 32;
    v16 = v17;
LABEL_13:
    *(_DWORD *)(a4 + 24) = v16 + v14;
    v18 = *(_DWORD *)(a4 + 16);
    v19 = HIDWORD(a2) + __CFADD__(v16, v14) + v15;
    v20 = v15;
    v21 = *(int (__cdecl **)(unsigned int, unsigned int, int, _DWORD, void *, int))(a4 + 12);
    *(_DWORD *)(a4 + 28) = v19;
    return v21(v14, v20, v16, HIDWORD(a2), a3, v18);
  }
  return 0;
}

//----- (10006490) --------------------------------------------------------
AssetsBundleFile *__thiscall AssetsBundleFile::AssetsBundleFile(AssetsBundleFile *this)
{
  AssetsBundleFile *result; // eax@1

  result = this;
  *((_DWORD *)this + 19) = 0;
  *((_DWORD *)this + 24) = 0;
  *((_DWORD *)this + 25) = 0;
  return result;
}

//----- (100064B0) --------------------------------------------------------
void __thiscall AssetsBundleFile::Close(AssetsBundleFile *this)
{
  AssetsBundleFile *v1; // esi@1
  unsigned int v2; // edi@2
  unsigned int v3; // eax@4
  int v4; // ebx@7
  int v5; // eax@11
  unsigned int v6; // edi@13
  int v7; // ebx@14

  v1 = this;
  if ( *((_DWORD *)this + 4) >= 6u )
  {
    v5 = *((_DWORD *)this + 25);
    if ( v5 && *((_DWORD *)this + 24) )
    {
      v6 = 0;
      if ( v5 )
      {
        v7 = 0;
        do
        {
          AssetsBundleBlockAndDirectoryList06::Free((AssetsBundleBlockAndDirectoryList06 *)(v7 + *((_DWORD *)v1 + 24)));
          ++v6;
          v7 += 32;
        }
        while ( v6 < *((_DWORD *)v1 + 25) );
      }
      free(*((void **)v1 + 24));
    }
    *((_DWORD *)v1 + 25) = 0;
    *((_DWORD *)v1 + 24) = 0;
  }
  else
  {
    v2 = 0;
    if ( *((_DWORD *)this + 18) )
    {
      free(*((void **)this + 19));
      *((_DWORD *)v1 + 19) = 0;
    }
    v3 = *((_DWORD *)v1 + 25);
    if ( v3 && *((_DWORD *)v1 + 24) )
    {
      *((_DWORD *)v1 + 18) = 0;
      *((_DWORD *)v1 + 23) = 0;
      if ( v3 > 0 )
      {
        v4 = 0;
        do
        {
          AssetsList::Free((AssetsList *)(v4 + *((_DWORD *)v1 + 24)));
          ++v2;
          v4 += 16;
        }
        while ( v2 < *((_DWORD *)v1 + 25) );
      }
      free(*((void **)v1 + 24));
    }
    *((_DWORD *)v1 + 24) = 0;
    *((_DWORD *)v1 + 25) = 0;
  }
}

//----- (10006560) --------------------------------------------------------
void __cdecl sub_10006560(int a1, void *a2)
{
  free(a2);
}

//----- (10006580) --------------------------------------------------------
signed int __usercall sub_10006580@<eax>(int a1@<edx>, int (__cdecl *a2)(_DWORD, _DWORD, int, _DWORD, void *, int)@<ecx>, _DWORD *a3, unsigned __int64 a4, int (__cdecl *a5)(_DWORD, _DWORD, _DWORD, unsigned int, void *, int), int a6, int a7)
{
  _DWORD *v7; // ebx@1
  int v8; // edx@1
  int v9; // ecx@1
  unsigned __int64 v10; // rax@1
  signed int result; // eax@2
  __int64 v12; // rdi@4
  size_t v13; // eax@5
  unsigned int v14; // ebx@12
  int v15; // eax@14
  int v16; // edx@14
  int v17; // ebx@16
  int v18; // ebx@17
  unsigned int v19; // kr10_4@18
  unsigned __int64 v20; // rax@18
  unsigned int v21; // ecx@26
  _DWORD *v22; // eax@26
  int v23; // edx@26
  unsigned __int8 v24; // cf@26
  int (__cdecl *v25)(_DWORD, _DWORD, int, _DWORD, void *, int); // [sp+Ch] [bp-BCh]@1
  int v26; // [sp+14h] [bp-B4h]@5
  int (__cdecl *v27)(_DWORD, _DWORD, _DWORD, unsigned int, void *, int); // [sp+1Ch] [bp-ACh]@1
  unsigned int v28; // [sp+24h] [bp-A4h]@4
  int v29; // [sp+28h] [bp-A0h]@16
  _DWORD *v30; // [sp+2Ch] [bp-9Ch]@1
  int v31; // [sp+30h] [bp-98h]@16
  _DWORD *v32; // [sp+34h] [bp-94h]@1
  __int64 v33; // [sp+38h] [bp-90h]@4
  void *v34; // [sp+40h] [bp-88h]@9
  void *v35; // [sp+44h] [bp-84h]@7
  char v36; // [sp+48h] [bp-80h]@3
  int v37; // [sp+58h] [bp-70h]@3
  int v38; // [sp+5Ch] [bp-6Ch]@3
  int v39; // [sp+6Ch] [bp-5Ch]@4
  int v40; // [sp+74h] [bp-54h]@4
  int v41; // [sp+78h] [bp-50h]@4
  int v42; // [sp+90h] [bp-38h]@4
  int v43; // [sp+94h] [bp-34h]@4
  int v44; // [sp+98h] [bp-30h]@4
  int v45; // [sp+A0h] [bp-28h]@4
  char v46; // [sp+BCh] [bp-Ch]@1

  v7 = (_DWORD *)a1;
  v8 = *(_DWORD *)(a1 + 4);
  v25 = a2;
  v9 = *v7;
  v30 = a3;
  v32 = v7;
  v27 = a5;
  LODWORD(v10) = a5(v9, v8, 5, 0, &v46, a6);
  if ( v10 < 5 || (v38 = 0, v37 = 0, sub_10024810((int)&v46, (int)&v36)) )
  {
    result = 11;
  }
  else
  {
    HIDWORD(v12) = a4;
    v39 = 0;
    v42 = 0;
    v45 = 0;
    v40 = 0;
    v41 = 0;
    v43 = 1;
    v44 = 1;
    LODWORD(v12) = 5;
    v28 = 0;
    v33 = 0i64;
    if ( a4 <= 0x100000 )
    {
      v26 = HIDWORD(a4);
      v13 = a4;
    }
    else
    {
      v13 = 0x100000;
      v26 = 0;
    }
    v35 = malloc(v13);
    if ( v35 )
    {
      v34 = malloc(0x100000u);
      if ( v34 )
      {
        if ( a4 > 5 )
        {
          while ( 1 )
          {
            v14 = (__PAIR__(HIDWORD(a4), HIDWORD(v12)) - __PAIR__(v28, (unsigned int)v12)) >> 32;
            HIDWORD(v12) -= v12;
            if ( __PAIR__(v14, HIDWORD(v12)) > 0x100000 )
            {
              HIDWORD(v12) = 0x100000;
              v14 = 0;
            }
            v15 = v27(v12 + *v32, (__PAIR__(v28, (unsigned int)v12) + *(_QWORD *)v32) >> 32, HIDWORD(v12), v14, v35, a6);
            if ( v15 != HIDWORD(v12) || v16 != v14 )
            {
              sub_100246F0((int)&v36);
              free(v35);
              free(v34);
              return 6;
            }
            v29 = v15;
            HIDWORD(v12) = 0;
            v31 = 0x100000;
            v26 = 0;
            v17 = sub_100243E0((int)&v36, v34, (int)&v31, v35, (int)&v29, (int)&v26);
            if ( v17 )
              goto LABEL_22;
            v18 = v31;
            if ( !v31 )
            {
              v17 = 11;
LABEL_22:
              sub_100246F0((int)&v36);
              free(v35);
              free(v34);
              return v17;
            }
            v19 = v29 + v12;
            v28 = (__PAIR__(v28, v29) + v12) >> 32;
            LODWORD(v12) = v29 + v12;
            LODWORD(v20) = v25(v33 + *v30, (unsigned __int64)(v33 + *(_QWORD *)v30) >> 32, v31, 0, v34, a7);
            if ( v20 < (unsigned int)v18 )
            {
              sub_100246F0((int)&v36);
              free(v35);
              free(v34);
              return 7;
            }
            v33 += (unsigned int)v18;
            if ( __PAIR__(v28, v19) >= a4 )
              break;
            HIDWORD(v12) = a4;
          }
          v7 = v32;
        }
        sub_100246F0((int)&v36);
        free(v35);
        free(v34);
        v21 = v28;
        v22 = v30;
        v23 = v33;
        v24 = __CFADD__((_DWORD)v12, *v7);
        *v7 += v12;
        v7[1] += v21 + v24;
        v24 = __CFADD__(v23, *v22);
        *v22 += v23;
        v22[1] += HIDWORD(v33) + v24;
        result = 0;
      }
      else
      {
        sub_100246F0((int)&v36);
        free(v35);
        result = 2;
      }
    }
    else
    {
      sub_100246F0((int)&v36);
      result = 2;
    }
  }
  return result;
}

//----- (10006940) --------------------------------------------------------
char __cdecl sub_10006940(_DWORD *a1, _DWORD *a2, unsigned __int64 a3, int (__cdecl *a4)(_DWORD, _DWORD, int, int, _BYTE *, int), int a5, int (__cdecl *a6)(_DWORD, _DWORD, char *, _DWORD, void *, int), int a7)
{
  _DWORD *v7; // esi@1
  size_t v8; // eax@3
  _BYTE *v9; // edi@5
  char result; // al@7
  char *v11; // ebx@10
  int v12; // edi@11
  int v13; // eax@11
  int v14; // edx@13
  unsigned __int64 v15; // rax@16
  _DWORD *v16; // eax@19
  unsigned __int8 v17; // cf@19
  _DWORD *v18; // eax@19
  int v19; // [sp+Ch] [bp-28h]@13
  int v20; // [sp+18h] [bp-1Ch]@11
  __int64 v21; // [sp+1Ch] [bp-18h]@2
  unsigned __int64 v22; // [sp+24h] [bp-10h]@2
  _BYTE *v23; // [sp+2Ch] [bp-8h]@5
  void *v24; // [sp+30h] [bp-4h]@8

  v7 = calloc(1u, 0x20u);
  if ( !v7 )
    return 0;
  *v7 = 0;
  v7[1] = 0;
  v7[2] = 0;
  v7[3] = 0;
  v7[4] = 0;
  v7[5] = 0;
  v7[6] = 0;
  v7[7] = 0;
  v22 = 0i64;
  v21 = 0i64;
  if ( HIDWORD(a3) > 0 || (v8 = a3, (unsigned int)a3 > 0x100000) )
    v8 = 0x100000;
  v9 = malloc(v8);
  v23 = v9;
  if ( !v9 )
  {
    free(v7);
    return 0;
  }
  v24 = malloc(0x200000u);
  if ( v24 )
  {
    v11 = 0;
    if ( a3 <= 0 )
    {
LABEL_19:
      free(v7);
      free(v9);
      free(v24);
      v16 = a1;
      v17 = __CFADD__((_DWORD)v22, *a1);
      *v16 += v22;
      v16[1] += HIDWORD(v22) + v17;
      v18 = a2;
      v17 = __CFADD__((_DWORD)v21, *a2);
      *v18 += v21;
      v18[1] += HIDWORD(v21) + v17;
      result = 1;
    }
    else
    {
      while ( 1 )
      {
        v12 = a3 - v22;
        v13 = (a3 - v22) >> 32;
        v20 = (a3 - v22) >> 32;
        if ( a3 - v22 > 0x100000 )
        {
          v20 = 0;
          v13 = 0;
          v12 = 0x100000;
        }
        v19 = a4(v22 + *a1, (v22 + *(_QWORD *)a1) >> 32, v12, v13, v23, a5);
        if ( v19 != v12 || v14 != v20 )
        {
LABEL_20:
          free(v7);
          free(v23);
          free(v24);
          return 0;
        }
        memcpy((char *)v24 + 0x100000, v24, (size_t)v11);
        v7[3] = v11;
        v7[2] = (char *)v24 + (_DWORD)v11 + 0x100000;
        *v7 = 0;
        v7[1] = 0;
        v11 = sub_10022820(v12, v23, (int)v7, v24);
        if ( !v11 )
          break;
        v22 += (unsigned int)v19;
        LODWORD(v15) = a6(v21 + *a2, (unsigned __int64)(v21 + *(_QWORD *)a2) >> 32, v11, 0, v24, a7);
        if ( v15 < (unsigned int)v11 )
          goto LABEL_20;
        v21 += (unsigned int)v11;
        if ( v22 >= a3 )
        {
          v9 = v23;
          goto LABEL_19;
        }
      }
      free(v7);
      free(v23);
      free(v24);
      result = 0;
    }
  }
  else
  {
    free(v7);
    free(v9);
    result = 0;
  }
  return result;
}

//----- (10006B90) --------------------------------------------------------
char __thiscall AssetsBundleFile::Unpack(AssetsBundleFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5)
{
  AssetsBundleFile *v5; // edi@1
  int v6; // eax@2
  char v7; // al@3
  unsigned __int64 v8; // rax@10
  unsigned int v9; // esi@10
  size_t v10; // ST2C_4@10
  void *v11; // eax@10
  void *v12; // ebx@10
  _DWORD *v13; // esi@11
  int v14; // eax@14
  unsigned __int64 v15; // rax@15
  void (__cdecl *v16)(void *); // edi@16
  void *v17; // eax@17
  bool v18; // zf@17
  _DWORD *v19; // esi@27
  int v20; // edx@28
  int v21; // eax@28
  unsigned int v22; // eax@29
  unsigned __int64 v23; // rax@30
  int v24; // esi@30
  int v25; // esi@33
  unsigned int v26; // ebx@36
  char *v27; // eax@36
  unsigned int v28; // esi@41
  int v29; // eax@43
  int v30; // esi@43
  int v31; // eax@43
  unsigned int v32; // esi@55
  int v33; // edx@56
  unsigned __int64 (__cdecl *v34)(unsigned __int64, unsigned __int64, const void *, __int32); // esi@58
  int v35; // eax@58
  unsigned __int64 v36; // rax@61
  unsigned int v38; // edi@73
  __int64 v39; // rax@73
  void **v40; // edx@77
  void *v41; // esi@77
  __int64 v42; // rcx@79
  char *v43; // esi@79
  int v44; // eax@79
  _DWORD *v45; // eax@81
  void *v46; // esi@82
  int v47; // ecx@83
  void *v48; // ebx@85
  unsigned int v49; // edi@85
  size_t v50; // esi@88
  unsigned int *v51; // ecx@89
  unsigned int v52; // edx@89
  char *v53; // edi@93
  unsigned int v54; // ebx@93
  int *v55; // ecx@93
  void *v56; // edi@97
  int v57; // esi@97
  int v58; // eax@99
  int v59; // esi@101
  unsigned int v60; // kr00_4@101
  unsigned int v61; // ecx@101
  unsigned int v62; // edi@102
  int v63; // eax@105
  AssetsBundleFile *v64; // edx@105
  int v65; // ecx@105
  void *v66; // [sp+Ch] [bp-274h]@36
  char v67; // [sp+13h] [bp-26Dh]@3
  int i; // [sp+14h] [bp-26Ch]@33
  unsigned __int64 v69; // [sp+18h] [bp-268h]@13
  void *v70; // [sp+24h] [bp-25Ch]@36
  unsigned __int64 v71; // [sp+28h] [bp-258h]@6
  int v72; // [sp+30h] [bp-250h]@36
  unsigned __int64 (__cdecl *v73)(unsigned __int64, unsigned __int64, const void *, __int32); // [sp+34h] [bp-24Ch]@1
  int v74; // [sp+38h] [bp-248h]@27
  unsigned __int64 (__cdecl *v75)(unsigned __int64, unsigned __int64, void *, __int32); // [sp+3Ch] [bp-244h]@1
  int v76; // [sp+40h] [bp-240h]@28
  unsigned int v77; // [sp+44h] [bp-23Ch]@28
  void *v78; // [sp+48h] [bp-238h]@28
  int v79; // [sp+4Ch] [bp-234h]@28
  unsigned int v80; // [sp+50h] [bp-230h]@28
  int v81; // [sp+54h] [bp-22Ch]@28
  int v82; // [sp+58h] [bp-228h]@28
  int v83; // [sp+5Ch] [bp-224h]@28
  unsigned __int64 v84; // [sp+60h] [bp-220h]@77
  unsigned __int64 v85; // [sp+68h] [bp-218h]@84
  __int64 v86; // [sp+70h] [bp-210h]@95
  AssetsBundleFile *v87; // [sp+7Ch] [bp-204h]@1
  __int64 v88; // [sp+80h] [bp-200h]@30
  unsigned __int64 v89; // [sp+88h] [bp-1F8h]@73
  __int64 v90; // [sp+90h] [bp-1F0h]@73
  char v91; // [sp+98h] [bp-1E8h]@75
  int v92; // [sp+A8h] [bp-1D8h]@75
  int v93; // [sp+ACh] [bp-1D4h]@75
  int v94; // [sp+BCh] [bp-1C4h]@77
  int v95; // [sp+C4h] [bp-1BCh]@77
  int v96; // [sp+C8h] [bp-1B8h]@77
  int v97; // [sp+E0h] [bp-1A0h]@77
  int v98; // [sp+E4h] [bp-19Ch]@77
  int v99; // [sp+E8h] [bp-198h]@77
  int v100; // [sp+F0h] [bp-190h]@77
  int v101; // [sp+108h] [bp-178h]@107
  int v102; // [sp+10Ch] [bp-174h]@107
  char v103; // [sp+110h] [bp-170h]@107
  int v104; // [sp+144h] [bp-13Ch]@107
  int v105; // [sp+148h] [bp-138h]@107
  int v106; // [sp+158h] [bp-128h]@107
  char v107; // [sp+168h] [bp-118h]@73
  char v108; // [sp+178h] [bp-108h]@37

  v5 = this;
  v87 = this;
  v75 = a2;
  v73 = a4;
  if ( !AssetsBundleFile::Read(this, a2, a3, 0, 1) )
    return 0;
  v6 = *((_DWORD *)v5 + 4);
  if ( v6 == 6 )
  {
    v7 = *((_BYTE *)v5 + 80) & 0x3F;
    v67 = v7;
    if ( (unsigned __int8)v7 < 4u )
    {
      if ( v7 == 2 )
        v67 = 3;
      v71 = 0i64;
      if ( *((_DWORD *)v5 + 20) & 0x100 )
      {
        *(_DWORD *)v5 = *(_DWORD *)"UnityWeb";
        *((_DWORD *)v5 + 1) = *(_DWORD *)"yWeb";
        *((_BYTE *)v5 + 8) = aUnityweb[8];
      }
      AssetsBundleHeader06::Write(v5, a4, a5, &v71, 0);
      if ( *((_DWORD *)v5 + 20) & 0x100 )
      {
        *(_DWORD *)v5 = *(_DWORD *)"UnityFS";
        *((_DWORD *)v5 + 1) = *(_DWORD *)"yFS";
      }
      LODWORD(v8) = sub_100042D0((int)v5);
      v9 = *((_DWORD *)v5 + 19);
      v10 = *((_DWORD *)v5 + 19);
      v71 = v8;
      v11 = malloc(v10);
      v12 = v11;
      if ( v11 )
      {
        v13 = Create_AssetsWriterToMemory(v11, v9);
        if ( v13 )
        {
          v69 = 0i64;
          switch ( v67 )
          {
            case 0:
              v14 = *((_DWORD *)v5 + 18);
              if ( v14 == *((_DWORD *)v5 + 19) )
              {
                LODWORD(v15) = ((int (__cdecl *)(_DWORD, _DWORD, int, _DWORD, void *, __int32))v75)(
                                 v71,
                                 HIDWORD(v71),
                                 v14,
                                 0,
                                 v12,
                                 a3);
                if ( v15 >= *((_DWORD *)v5 + 19) )
                  goto LABEL_24;
              }
              goto LABEL_16;
            case 1:
              if ( sub_10006580(
                     (int)&v71,
                     (int (__cdecl *)(_DWORD, _DWORD, int, _DWORD, void *, int))AssetsWriterToMemory,
                     &v69,
                     *((_DWORD *)v5 + 18),
                     (int (__cdecl *)(_DWORD, _DWORD, _DWORD, unsigned int, void *, int))v75,
                     a3,
                     (int)v13) )
              {
                goto LABEL_16;
              }
              goto LABEL_24;
            case 2:
            case 3:
              if ( sub_10006940(
                     &v71,
                     &v69,
                     *((_DWORD *)v5 + 18),
                     (int (__cdecl *)(_DWORD, _DWORD, int, int, _BYTE *, int))v75,
                     a3,
                     (int (__cdecl *)(_DWORD, _DWORD, char *, _DWORD, void *, int))AssetsWriterToMemory,
                     (int)v13) )
              {
LABEL_24:
                if ( *((_BYTE *)v13 + 12) && v13[2] )
                  free((void *)v13[2]);
                free(v13);
                v74 = *((_DWORD *)v5 + 19);
                v19 = malloc(0xCu);
                if ( !v19 )
                  goto LABEL_12;
                v20 = v74;
                *v19 = 0;
                v19[1] = v20;
                v19[2] = v12;
                v76 = 0;
                v77 = 0;
                v78 = 0;
                v79 = 0;
                v80 = 0;
                v81 = 0;
                v82 = 0;
                v83 = 0;
                v67 = AssetsBundleBlockAndDirectoryList06::Read(
                        (AssetsBundleBlockAndDirectoryList06 *)&v76,
                        0i64,
                        (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32))AssetsReaderFromMemory,
                        (__int32)v19,
                        0);
                free(v19);
                free(v12);
                v21 = sub_10004360((int)v5);
                v18 = (*((_BYTE *)v5 + 80) & 0x80) == 0;
                v71 = (unsigned int)v21;
                if ( v18 )
                {
                  LODWORD(v23) = sub_100042D0((int)v5);
                  v69 = v23;
                  HIDWORD(v88) = HIDWORD(v23);
                  v24 = v23;
                  AssetsBundleBlockAndDirectoryList06::Write(
                    (AssetsBundleBlockAndDirectoryList06 *)&v76,
                    v73,
                    a5,
                    &v69,
                    0);
                  v22 = v69;
                  *((_DWORD *)v5 + 19) = v69 - v24;
                }
                else
                {
                  v22 = sub_10004360((int)v5);
                  v69 = v22;
                }
                if ( !v67 )
                  goto LABEL_12;
                v74 = 0;
                if ( !v80 )
                {
LABEL_54:
                  if ( *((_BYTE *)v5 + 80) & 0x80 )
                  {
                    v32 = v22;
                    HIDWORD(v88) = HIDWORD(v69);
                    AssetsBundleBlockAndDirectoryList06::Write(
                      (AssetsBundleBlockAndDirectoryList06 *)&v76,
                      v73,
                      a5,
                      &v69,
                      0);
                    v22 = v69;
                    *((_DWORD *)v5 + 19) = v69 - v32;
                  }
                  v33 = HIDWORD(v69);
                  *((_DWORD *)v5 + 20) &= 0xFFFFFFC0;
                  *((_DWORD *)v5 + 16) = v22;
                  *((_DWORD *)v5 + 18) = *((_DWORD *)v5 + 19);
                  v18 = (*((_DWORD *)v5 + 20) & 0x100) == 0;
                  *((_DWORD *)v5 + 17) = v33;
                  v69 = 0i64;
                  if ( !v18 )
                  {
                    *(_DWORD *)v5 = *(_DWORD *)"UnityWeb";
                    *((_DWORD *)v5 + 1) = *(_DWORD *)"yWeb";
                    *((_BYTE *)v5 + 8) = aUnityweb[8];
                  }
                  v34 = v73;
                  AssetsBundleHeader06::Write(v5, v73, a5, &v69, 0);
                  v35 = *((_DWORD *)v5 + 20);
                  if ( v35 & 0x100 )
                  {
                    *(_DWORD *)v5 = *(_DWORD *)"UnityFS";
                    *((_DWORD *)v5 + 1) = *(_DWORD *)"yFS";
                  }
                  if ( (char)v35 < 0 )
                  {
                    LODWORD(v36) = sub_100042D0((int)v5);
                    v69 = v36;
                  }
                  AssetsBundleBlockAndDirectoryList06::Write(
                    (AssetsBundleBlockAndDirectoryList06 *)&v76,
                    v34,
                    a5,
                    &v69,
                    0);
                  AssetsBundleBlockAndDirectoryList06::Free((AssetsBundleBlockAndDirectoryList06 *)&v76);
                  return 1;
                }
                v25 = 0;
                i = 0;
                while ( 2 )
                {
                  switch ( *(_BYTE *)(v25 + v81 + 8) & 0x3F )
                  {
                    case 0:
                      if ( *(_DWORD *)(v25 + v81 + 4) != *(_DWORD *)(v25 + v81) )
                        goto LABEL_65;
                      v26 = 0x100000;
                      v70 = 0;
                      v72 = 0x100000;
                      v27 = (char *)malloc(0x100000u);
                      v66 = v27;
                      if ( !v27 )
                      {
                        v27 = &v108;
                        v26 = 256;
                        v66 = &v108;
                        v72 = 256;
                      }
                      if ( !*(_DWORD *)(v25 + v81 + 4) )
                        goto LABEL_47;
                      while ( 1 )
                      {
                        v28 = *(_DWORD *)(v25 + v81 + 4) - (_DWORD)v70;
                        if ( v26 > v28 )
                          v26 = v28;
                        v29 = ((int (__cdecl *)(_DWORD, _DWORD, unsigned int, _DWORD, void *, __int32))v75)(
                                v71,
                                HIDWORD(v71),
                                v26,
                                0,
                                v66,
                                a3);
                        v30 = v29;
                        v31 = ((int (__cdecl *)(_DWORD, _DWORD, int, _DWORD, void *, __int32))v73)(
                                v69,
                                HIDWORD(v69),
                                v29,
                                0,
                                v66,
                                a5);
                        v71 += (unsigned int)v30;
                        v69 += (unsigned int)v31;
                        if ( v30 != v26 || v31 != v30 )
                          break;
                        v70 = (char *)v70 + v30;
                        v25 = i;
                        if ( (unsigned int)v70 >= *(_DWORD *)(i + v81 + 4) )
                        {
                          v5 = v87;
                          v27 = (char *)v66;
LABEL_47:
                          if ( v27 != &v108 )
                            free(v27);
                          goto LABEL_52;
                        }
                        v26 = v72;
                      }
                      if ( v66 != &v108 )
                        free(v66);
                      goto LABEL_65;
                    case 1:
                      if ( !sub_10006580(
                              (int)&v71,
                              (int (__cdecl *)(_DWORD, _DWORD, int, _DWORD, void *, int))v73,
                              &v69,
                              *(_DWORD *)(v25 + v81 + 4),
                              (int (__cdecl *)(_DWORD, _DWORD, _DWORD, unsigned int, void *, int))v75,
                              a3,
                              a5) )
                        goto LABEL_52;
                      goto LABEL_65;
                    case 2:
                    case 3:
                      if ( !sub_10006940(
                              &v71,
                              &v69,
                              *(_DWORD *)(v25 + v81 + 4),
                              (int (__cdecl *)(_DWORD, _DWORD, int, int, _BYTE *, int))v75,
                              a3,
                              (int (__cdecl *)(_DWORD, _DWORD, char *, _DWORD, void *, int))v73,
                              a5) )
                        goto LABEL_65;
LABEL_52:
                      *(_DWORD *)(v25 + v81 + 4) = *(_DWORD *)(v25 + v81);
                      *(_WORD *)(v25 + v81 + 8) &= 0xFFC0u;
                      v25 += 12;
                      ++v74;
                      i = v25;
                      if ( v74 < v80 )
                        continue;
                      v22 = v69;
                      goto LABEL_54;
                    default:
LABEL_65:
                      AssetsBundleBlockAndDirectoryList06::Free((AssetsBundleBlockAndDirectoryList06 *)&v76);
                      break;
                  }
                  break;
                }
              }
              else
              {
LABEL_16:
                v16 = free;
                if ( *((_BYTE *)v13 + 12) )
                {
                  v17 = (void *)v13[2];
                  v18 = v17 == 0;
LABEL_18:
                  if ( !v18 )
                    v16(v17);
                }
LABEL_20:
                v16(v13);
                v16(v12);
              }
              break;
            default:
              v16 = free;
              if ( !*((_BYTE *)v13 + 12) )
                goto LABEL_20;
              v17 = (void *)v13[2];
              v18 = v17 == 0;
              goto LABEL_18;
          }
        }
        else
        {
LABEL_12:
          free(v12);
        }
      }
    }
    return 0;
  }
  if ( v6 != 3 )
    return 0;
  if ( strcmp((const char *)v5, "UnityWeb") )
    return 0;
  if ( !*((_DWORD *)v5 + 18) )
    return 0;
  if ( **((_DWORD **)v5 + 19) < 0xDu )
    return 0;
  v70 = malloc(0x200000u);
  if ( !v70 )
    return 0;
  v89 = 0i64;
  AssetsBundleHeader03::Write(v5, v73, a5, &v89, 0);
  v38 = *((_DWORD *)v5 + 16);
  v90 = v38;
  LODWORD(v39) = ((int (__cdecl *)(unsigned int, _DWORD, signed int, _DWORD, char *, __int32))v75)(
                   v38,
                   0,
                   13,
                   0,
                   &v107,
                   a3);
  if ( !v39 )
  {
    free(v70);
    return 0;
  }
  v93 = 0;
  v92 = 0;
  if ( sub_10024810((int)&v107, (int)&v91) )
  {
    free(v70);
    return 0;
  }
  v98 = 1;
  v99 = 1;
  v40 = (void **)*((_DWORD *)v87 + 19);
  v94 = 0;
  v97 = 0;
  v100 = 0;
  v95 = 0;
  v96 = 0;
  v41 = *v40;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  LODWORD(v84) = v41;
  if ( (unsigned int)v41 > 0x100000 )
  {
    v41 = (void *)0x100000;
    LODWORD(v84) = 0x100000;
  }
  LODWORD(v42) = v38 + 13;
  HIDWORD(v42) = __CFADD__(v38, 13);
  v88 = v42;
  ((void (__cdecl *)(unsigned int, _DWORD, void *, _DWORD, void *, __int32))v75)(
    v38 + 13,
    HIDWORD(v42),
    v41,
    0,
    v70,
    a3);
  v66 = v41;
  v43 = (char *)v70 + 0x100000;
  i = 0x100000;
  v72 = 0;
  v44 = sub_100243E0((int)&v91, (char *)v70 + 0x100000, (int)&i, v70, (int)&v66, (int)&v72);
  if ( !v66 || v44 )
  {
    sub_100246F0((int)&v91);
    free(v70);
    return 0;
  }
  v45 = malloc(0xCu);
  if ( v45 )
  {
    v47 = i;
    v45[2] = v43;
    *v45 = 0;
    v45[1] = v47;
    v46 = v45;
  }
  else
  {
    v46 = 0;
  }
  v85 = 0i64;
  AssetsList::Read(
    (AssetsList *)&v76,
    (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32))AssetsReaderFromMemory,
    (__int32)v46,
    &v85,
    0);
  free(v46);
  v66 = 0;
  if ( v77 > 0 )
  {
    v48 = v78;
    v49 = 1;
    for ( i = 1; ; v49 = i )
    {
      if ( v49 < v77 )
      {
        v50 = 4 * (i - (_DWORD)v66);
        do
        {
          v51 = *(unsigned int **)v48;
          v52 = **((_DWORD **)v78 + v49);
          v74 = *((_DWORD *)v78 + v49);
          if ( v52 < *v51 )
          {
            memcpy((char *)v48 + 4, v48, v50);
            *(_DWORD *)v48 = v74;
          }
          ++v49;
          v50 += 4;
        }
        while ( v49 < v77 );
      }
      ++i;
      v48 = (char *)v48 + 4;
      v66 = (char *)v66 + 1;
      if ( (unsigned int)v66 >= v77 )
        break;
    }
  }
  v53 = (char *)v70 + 0x100000;
  v54 = 0;
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, __int32))v73)(
    v90,
    HIDWORD(v90),
    **(_DWORD **)v78,
    0,
    (char *)v70 + 0x100000,
    a5);
  sub_100246F0((int)&v91);
  v93 = 0;
  v92 = 0;
  sub_10024810((int)&v107, (int)&v91);
  v98 = 1;
  v99 = 1;
  v94 = 0;
  v97 = 0;
  v100 = 0;
  v95 = 0;
  v96 = 0;
  v55 = *(int **)v78;
  v66 = (void *)v84;
  i = *v55;
  v72 = 0;
  sub_100243E0((int)&v91, v53, (int)&i, v70, (int)&v66, (int)&v72);
  v84 = (unsigned int)v66;
  LODWORD(v85) = i;
  v66 = 0;
  if ( v77 > 0 )
  {
    i = 0;
    do
    {
      v86 = *(_DWORD *)(*((_DWORD *)v78 + (_DWORD)v66) + 4);
      LODWORD(v69) = (char *)v66 + 1;
      if ( (unsigned int)v66 + 1 < v77 )
        v86 += (unsigned int)(**((_DWORD **)v78 + (_DWORD)v66 + 1)
                            - *(_DWORD *)(*((_DWORD *)v78 + (_DWORD)v66) + 4)
                            - **((_DWORD **)v78 + (_DWORD)v66));
      do
      {
        v56 = v70;
        memset(v70, 0, 0x200000u);
        v57 = v86 + **((_DWORD **)v78 + (_DWORD)v66) - v85;
        HIDWORD(v71) = (v86 + **((_DWORD **)v78 + (_DWORD)v66) - __PAIR__(v54, (unsigned int)v85)) >> 32;
        if ( __PAIR__(HIDWORD(v71), v57) > 0x100000 )
        {
          v57 = 0x100000;
          HIDWORD(v71) = 0;
        }
        ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, void *, __int32))v75)(
          v84 + v88,
          (v84 + v88) >> 32,
          0x100000,
          0,
          v56,
          a3);
        v72 = 0x100000;
        v74 = v57;
        LODWORD(v71) = 0;
        v58 = sub_100243E0((int)&v91, (char *)v56 + 0x100000, (int)&v74, v56, (int)&v72, (int)&v71);
        if ( !v72 || v58 )
        {
          sub_100246F0((int)&v91);
          free(v56);
          return 0;
        }
        v59 = v74;
        ((void (__cdecl *)(_DWORD, _DWORD, int, _DWORD, char *, __int32))v73)(
          v90 + v85,
          (v90 + __PAIR__(v54, (unsigned int)v85)) >> 32,
          v74,
          0,
          (char *)v70 + 0x100000,
          a5);
        v60 = v84;
        LODWORD(v84) = v72 + v84;
        v61 = **((_DWORD **)v78 + (_DWORD)v66);
        v84 = __PAIR__(HIDWORD(v84), v72) + v60;
        v54 = ((unsigned int)v59 + __PAIR__(v54, (unsigned int)v85)) >> 32;
        LODWORD(v85) = v59 + v85;
      }
      while ( __PAIR__(v54, (unsigned int)v85) < v86 + (unsigned __int64)v61 );
      v62 = v77;
      if ( v77 == 1
        || !strcmp((const char *)(*((_DWORD *)v78 + (_DWORD)v66) + 8), "mainData")
        || !strncmp((const char *)(*((_DWORD *)v78 + (_DWORD)v66) + 8), "level", 5u) )
      {
        v63 = *(_DWORD *)(*((_DWORD *)v78 + (_DWORD)v66) + 4) + **((_DWORD **)v78 + (_DWORD)v66);
        v64 = v87;
        v65 = i;
        *(_DWORD *)(i + *((_DWORD *)v87 + 19) + 4) = v63;
        *(_DWORD *)(v65 + *((_DWORD *)v64 + 19)) = v63;
        i = v65 + 8;
      }
      v66 = (void *)v69;
    }
    while ( (unsigned int)v69 < v62 );
  }
  sub_100246F0((int)&v91);
  AssetsList::Free((AssetsList *)&v76);
  free(v70);
  qmemcpy(&v101, (const void *)v87, 0x60u);
  v103 = aUnityraw[8];
  v106 = v105 + v85;
  v104 = v105 + v85;
  v89 = 0i64;
  v101 = *(_DWORD *)"UnityRaw";
  v102 = *(_DWORD *)"yRaw";
  AssetsBundleHeader03::Write((AssetsBundleHeader03 *)&v101, v73, a5, &v89, 0);
  return 1;
}

//----- (10007820) --------------------------------------------------------
signed int __cdecl sub_10007820(int a1, int a2, int *a3)
{
  signed int result; // eax@2
  int v4; // eax@3

  if ( *a3 )
  {
    v4 = (*(int (__cdecl **)(signed int, signed int, int, _DWORD, int, _DWORD))(a1 + 4))(
           -1,
           -1,
           *a3,
           0,
           a2,
           *(_DWORD *)(a1 + 8));
    *a3 = v4;
    result = v4 != 0 ? 0 : 6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10007870) --------------------------------------------------------
int __cdecl sub_10007870(int a1, int a2, int a3)
{
  int result; // eax@1

  result = (*(int (__cdecl **)(signed int, signed int, int, _DWORD, int, _DWORD))(a1 + 4))(
             -1,
             -1,
             a3,
             0,
             a2,
             *(_DWORD *)(a1 + 8));
  *(_QWORD *)(a1 + 16) += (unsigned int)result;
  return result;
}

//----- (100078B0) --------------------------------------------------------
char __thiscall AssetsBundleFile::Pack(AssetsBundleFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5)
{
  AssetsBundleFile *v5; // esi@1
  bool v6; // zf@1
  unsigned int v7; // eax@4
  unsigned int v8; // edi@4
  unsigned int v9; // ecx@5
  unsigned int v10; // ebx@6
  size_t v11; // ecx@7
  int v12; // eax@9
  int v13; // eax@14
  int v14; // esi@14
  unsigned int v16; // edi@20
  void *v17; // [sp+Ch] [bp-FCh]@7
  void *v18; // [sp+Ch] [bp-FCh]@13
  unsigned __int64 v19; // [sp+10h] [bp-F8h]@9
  unsigned int v20; // [sp+18h] [bp-F0h]@5
  unsigned __int64 (__cdecl *v21)(unsigned __int64, unsigned __int64, const void *, __int32); // [sp+1Ch] [bp-ECh]@1
  AssetsBundleFile *v22; // [sp+20h] [bp-E8h]@1
  unsigned __int64 (__cdecl *v23)(unsigned __int64, unsigned __int64, void *, __int32); // [sp+24h] [bp-E4h]@1
  int v24; // [sp+28h] [bp-E0h]@22
  int v25; // [sp+2Ch] [bp-DCh]@22
  signed int (__cdecl *v26)(int, int, int *); // [sp+34h] [bp-D4h]@20
  unsigned __int64 (__cdecl *v27)(unsigned __int64, unsigned __int64, void *, __int32); // [sp+38h] [bp-D0h]@20
  __int32 v28; // [sp+3Ch] [bp-CCh]@20
  int (__cdecl *v29)(int, int, int); // [sp+40h] [bp-C8h]@20
  unsigned __int64 (__cdecl *v30)(unsigned __int64, unsigned __int64, const void *, __int32); // [sp+44h] [bp-C4h]@20
  __int32 v31; // [sp+48h] [bp-C0h]@20
  int v32; // [sp+50h] [bp-B8h]@20
  int v33; // [sp+54h] [bp-B4h]@20
  int v34; // [sp+58h] [bp-B0h]@15
  int v35; // [sp+5Ch] [bp-ACh]@15
  int v36; // [sp+60h] [bp-A8h]@15
  int v37; // [sp+64h] [bp-A4h]@15
  int v38; // [sp+68h] [bp-A0h]@15
  int v39; // [sp+6Ch] [bp-9Ch]@15
  int v40; // [sp+70h] [bp-98h]@15
  int v41; // [sp+74h] [bp-94h]@15
  int v42; // [sp+78h] [bp-90h]@15
  int v43; // [sp+7Ch] [bp-8Ch]@15
  int v44; // [sp+80h] [bp-88h]@15
  int v45; // [sp+84h] [bp-84h]@15
  int v46; // [sp+88h] [bp-80h]@15
  int v47; // [sp+8Ch] [bp-7Ch]@15
  int v48; // [sp+90h] [bp-78h]@22
  int v49; // [sp+94h] [bp-74h]@22
  char v50; // [sp+98h] [bp-70h]@22
  int v51; // [sp+CCh] [bp-3Ch]@22
  int v52; // [sp+D0h] [bp-38h]@22
  int v53; // [sp+E0h] [bp-28h]@22
  char v54; // [sp+F4h] [bp-14h]@19
  int v55; // [sp+F9h] [bp-Fh]@20
  int v56; // [sp+FDh] [bp-Bh]@20

  v5 = this;
  v6 = *((_DWORD *)this + 4) == 3;
  v22 = this;
  v23 = a2;
  v21 = a4;
  if ( !v6 || !AssetsBundleFile::Read(this, a2, a3, 0, 0) )
    return 0;
  if ( !strcmp((const char *)v5, "UnityRaw") )
  {
    v7 = *(_DWORD *)(*((_DWORD *)v5 + 24) + 4);
    v8 = 0;
    if ( v7 )
    {
      v9 = 1;
      v20 = 1;
      do
      {
        v10 = v9;
        if ( v9 < v7 )
        {
          v11 = 4 * (v9 - v8);
          v17 = (void *)v11;
          do
          {
            if ( **(_DWORD **)(*(_DWORD *)(*((_DWORD *)v5 + 24) + 8) + 4 * v10) < **(_DWORD **)(*(_DWORD *)(*((_DWORD *)v5 + 24) + 8)
                                                                                              + 4 * v8) )
            {
              v12 = *(_DWORD *)(*((_DWORD *)v5 + 24) + 8);
              LODWORD(v19) = *(_DWORD *)(v12 + 4 * v10);
              memcpy((void *)(v12 + 4 * v8 + 4), (const void *)(v12 + 4 * v8), v11);
              *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v5 + 24) + 8) + 4 * v8) = v19;
              v11 = (size_t)v17;
            }
            ++v10;
            v11 += 4;
            v17 = (void *)v11;
          }
          while ( v10 < *(_DWORD *)(*((_DWORD *)v5 + 24) + 4) );
          v9 = v20;
        }
        v7 = *(_DWORD *)(*((_DWORD *)v5 + 24) + 4);
        ++v8;
        v20 = ++v9;
      }
      while ( v8 < v7 );
    }
    v18 = malloc(0x200000u);
    if ( v18 )
    {
      v19 = 0i64;
      AssetsBundleHeader03::Write(v5, v21, a5, &v19, 0);
      v19 = *((_DWORD *)v5 + 16);
      v13 = off_100ADF94((int)&off_100ADF94, 0x45488u);
      v14 = v13;
      if ( v13 )
      {
        sub_100271A0(v13);
        v36 = -1;
        v37 = -1;
        v44 = -1;
        v43 = -1;
        v42 = -1;
        v41 = -1;
        v40 = -1;
        v39 = -1;
        v38 = -1;
        v46 = 1;
        v47 = 1;
        v34 = 5;
        v45 = 0;
        v35 = 0x10000;
        if ( sub_10024B60(&v34, v14) )
        {
          free(v18);
          return 0;
        }
        v20 = 5;
        sub_100280A0(&v20, (int)&v54, v14);
        if ( v20 == 5 )
        {
          v55 = 0;
          v56 = 0;
          v16 = v19;
          ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))v21)(
            v19,
            HIDWORD(v19),
            13,
            0,
            &v54,
            a5);
          v28 = a3;
          v32 = 0;
          v33 = 0;
          v27 = v23;
          v26 = sub_10007820;
          v29 = sub_10007870;
          v30 = v21;
          v31 = a5;
          *(_DWORD *)(v14 + 188) = &v29;
          *(_DWORD *)(v14 + 648) = &v26;
          *(_DWORD *)(v14 + 116) = 1;
          if ( !sub_10027F50(v14, &off_100ADF94, &off_100ADF94) )
            sub_10028060((_DWORD *)v14);
          v24 = v32;
          v25 = v33;
          ((void (__cdecl *)(unsigned int, _DWORD, signed int, _DWORD, int *, __int32))v21)(
            v16 + 5,
            (__PAIR__(HIDWORD(v19), v16) + 5) >> 32,
            8,
            0,
            &v24,
            a5);
          free(v18);
          qmemcpy(&v48, (const void *)v22, 0x60u);
          v49 = *(_DWORD *)"yWeb";
          v53 = v52;
          v51 = v52;
          v48 = *(_DWORD *)"UnityWeb";
          v19 = 0i64;
          v50 = aUnityweb[8];
          AssetsBundleHeader03::Write((AssetsBundleHeader03 *)&v48, v21, a5, &v19, 0);
          return 1;
        }
      }
      free(v18);
    }
    return 0;
  }
  return 1;
}
// 100ADF94: using guessed type int (__cdecl *off_100ADF94)(int, size_t);

//----- (10007C70) --------------------------------------------------------
char __thiscall AssetsBundleFile::Write(AssetsBundleFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5, struct BundleReplacer **a6, unsigned int a7, void (__cdecl *a8)(char *), struct ClassDatabaseFile *a9)
{
  unsigned int v9; // edi@1
  int v10; // eax@3
  _BYTE *v11; // esi@5
  const char *v12; // edx@7
  int v13; // ecx@8
  unsigned int v14; // eax@8
  const char **v15; // esi@9
  int v16; // edx@17
  int v17; // ebx@17
  int v18; // edi@20
  int v19; // eax@25
  int v20; // ecx@26
  int v21; // eax@32
  int v22; // ecx@33
  int v23; // ebx@36
  int v24; // esi@36
  int v25; // eax@36
  char v26; // al@36
  int v27; // esi@36
  int v28; // edx@37
  int v29; // eax@37
  int v30; // ecx@38
  const char *v31; // edi@41
  unsigned int v32; // kr00_4@43
  AssetsBundleFile *v33; // edi@47
  bool v34; // al@47
  int v35; // esi@47
  int v36; // eax@47
  int v37; // edx@47
  __int64 v38; // kr18_8@47
  void *v39; // eax@47
  _DWORD *v40; // esi@47
  unsigned int v41; // ecx@48
  const char *v42; // eax@48
  unsigned int v43; // kr04_4@49
  void *v44; // eax@49
  void *v45; // ST5C_4@49
  unsigned int v46; // edi@50
  unsigned int *v47; // esi@51
  int v48; // eax@53
  size_t v49; // ecx@54
  char v50; // al@63
  unsigned __int64 (__cdecl *v51)(unsigned __int64, unsigned __int64, void *, __int32); // ecx@63
  int v52; // edx@63
  int v53; // eax@63
  int v54; // ecx@63
  unsigned int v55; // edx@63
  int v56; // esi@65
  int v57; // eax@65
  unsigned int v58; // edi@67
  int v59; // esi@67
  unsigned int v60; // edx@68
  unsigned int v61; // ecx@68
  unsigned int v62; // ecx@69
  unsigned int v63; // eax@69
  unsigned int v64; // eax@71
  unsigned int v65; // edx@77
  unsigned int v66; // eax@77
  int v67; // eax@78
  int v68; // edx@81
  unsigned int v69; // kr08_4@81
  void *v70; // eax@81
  const void *v71; // ST5C_4@81
  int v72; // edx@82
  signed int v73; // ebx@85
  int v74; // eax@85
  unsigned int v75; // edx@89
  int *v76; // edx@90
  const char *v77; // esi@91
  int v78; // eax@91
  bool v79; // cf@92
  unsigned __int8 v80; // cl@94
  int v81; // eax@96
  unsigned int v82; // kr0C_4@106
  int v83; // esi@106
  int v84; // eax@106
  char v85; // al@106
  bool v86; // zf@108
  int v87; // edi@109
  unsigned int v88; // esi@110
  char *v89; // ebx@110
  const char *v90; // ebx@112
  unsigned int v91; // edi@114
  size_t v92; // edi@116
  int v93; // eax@116
  int v94; // ecx@116
  char *v95; // ebx@117
  unsigned int v96; // esi@120
  unsigned __int64 v97; // rax@122
  unsigned int v98; // edx@125
  unsigned int v99; // edx@126
  unsigned int v100; // ecx@126
  unsigned int v101; // ecx@127
  unsigned int v102; // eax@127
  unsigned int v103; // eax@129
  char *v104; // eax@133
  size_t v105; // ecx@134
  int v106; // eax@141
  int v107; // eax@142
  unsigned int v108; // edx@144
  unsigned int v109; // ecx@144
  unsigned int v110; // ecx@145
  unsigned int v111; // eax@145
  unsigned int v112; // eax@147
  unsigned int v113; // edx@153
  int v114; // eax@155
  unsigned int v115; // edx@160
  unsigned int v116; // edx@161
  unsigned int v117; // ecx@161
  unsigned int v118; // ecx@162
  unsigned int v119; // eax@162
  unsigned int v120; // eax@164
  int v121; // eax@169
  unsigned int v122; // edx@172
  unsigned int v123; // ecx@172
  unsigned int v124; // ecx@173
  unsigned int v125; // eax@173
  unsigned int v126; // eax@175
  int v127; // ecx@181
  int v128; // edx@181
  unsigned int v129; // ebx@184
  struct ClassDatabaseFile *v130; // edi@184
  int v131; // esi@184
  unsigned int v132; // ebx@187
  unsigned int v133; // ebx@187
  unsigned int v134; // kr28_4@187
  unsigned __int64 (__cdecl *v135)(unsigned __int64, unsigned __int64, void *, __int32); // edi@187
  int (__stdcall *v136)(unsigned int, unsigned int, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32), __int32); // eax@187
  int v137; // eax@187
  int v138; // ecx@187
  int v139; // edx@187
  int v140; // edx@189
  int v141; // eax@189
  int v142; // ecx@189
  int v143; // eax@189
  int v144; // edx@189
  int v145; // edi@189
  int v146; // eax@189
  __int64 v147; // rcx@189
  unsigned int v148; // edx@191
  char *v149; // eax@191
  int v150; // eax@197
  unsigned int v151; // ebx@197
  int v152; // edx@200
  void **v153; // esi@201
  void *v154; // ebx@205
  unsigned int v155; // esi@206
  unsigned int v156; // edi@206
  int v158; // eax@224
  unsigned int v159; // ebx@224
  int v160; // esi@225
  void *v161; // eax@230
  unsigned int v162; // edx@232
  int v163; // edi@232
  int v164; // esi@233
  unsigned int v165; // ebx@234
  int v166; // edx@238
  int v167; // eax@238
  int v168; // ecx@239
  int v169; // edx@246
  int v170; // eax@246
  int v171; // ecx@247
  int v172; // edx@251
  const char *v173; // ebx@253
  unsigned int v174; // edi@255
  int v175; // eax@255
  unsigned int v176; // esi@259
  char v177; // al@259
  int v178; // edx@259
  int v179; // eax@259
  int v180; // edi@259
  _DWORD *v181; // esi@259
  unsigned int v182; // edx@260
  const char *v183; // eax@260
  void *v184; // eax@261
  void *v185; // ST5C_4@261
  unsigned int v186; // edi@262
  char *v187; // ebx@263
  int v188; // esi@263
  unsigned int v189; // ecx@264
  int v190; // edx@265
  int v191; // eax@265
  int v192; // ecx@266
  unsigned int v193; // edx@273
  char v194; // dl@276
  int v195; // eax@276
  int v196; // edx@276
  int v197; // ecx@278
  unsigned int v198; // edx@281
  unsigned int v199; // ecx@281
  unsigned int v200; // ecx@282
  unsigned int v201; // eax@282
  unsigned int v202; // eax@284
  unsigned int v203; // ecx@290
  unsigned int v204; // edx@290
  int v205; // edi@291
  int v206; // eax@291
  char *v207; // eax@294
  int v208; // edx@294
  char v209; // cl@295
  int v210; // esi@296
  int v211; // eax@296
  unsigned int v212; // edx@296
  const void *v213; // ST5C_4@296
  _DWORD *v214; // eax@296
  unsigned int v215; // edx@296
  unsigned int v216; // ecx@299
  unsigned int v217; // ecx@300
  unsigned int v218; // esi@300
  unsigned int v219; // eax@301
  unsigned int v220; // eax@302
  unsigned int v221; // ecx@310
  signed int v222; // esi@311
  unsigned int v223; // ecx@311
  unsigned int v224; // edx@312
  unsigned int v225; // eax@313
  int v226; // edx@322
  int v227; // ebx@323
  const char *v228; // ebx@326
  int v229; // esi@327
  unsigned int v230; // edi@327
  unsigned int v231; // edi@335
  int v232; // eax@335
  int v233; // esi@335
  _DWORD *v234; // eax@335
  unsigned int v235; // ecx@336
  int v236; // esi@337
  int v237; // edx@346
  int v238; // edx@346
  unsigned int v239; // edx@348
  char *v240; // ebx@351
  int v241; // edi@352
  const char *v242; // esi@353
  unsigned int v243; // ebx@355
  int v244; // ecx@356
  unsigned int v245; // edx@357
  char *v246; // esi@358
  char *v247; // esi@360
  unsigned __int64 v248; // rax@361
  unsigned int v249; // esi@361
  unsigned int v250; // ebx@361
  unsigned int v251; // edx@365
  unsigned int v252; // esi@366
  unsigned int v253; // edi@366
  unsigned int v254; // eax@366
  int v255; // esi@366
  int v256; // edi@366
  int v257; // esi@366
  unsigned int v258; // ebx@366
  unsigned int v259; // edx@366
  int (**v260)(void); // edx@368
  unsigned int v261; // kr58_4@369
  int v262; // eax@369
  int v263; // edx@369
  _DWORD *v264; // ecx@369
  unsigned int v265; // eax@369
  int v266; // ecx@369
  int v267; // kr60_4@369
  int v268; // edi@370
  unsigned int v269; // ecx@375
  unsigned int v270; // edx@377
  void *v271; // eax@379
  int v272; // ecx@380
  int v273; // ecx@382
  int v274; // eax@382
  int v275; // edx@383
  unsigned __int64 (__cdecl *v276)(unsigned __int64, unsigned __int64, const void *, __int32); // ebx@388
  unsigned int v277; // esi@388
  unsigned int v278; // ebx@388
  char *v279; // esi@390
  unsigned int v280; // edi@390
  int v281; // ebx@391
  int v282; // ecx@393
  unsigned int v283; // edx@395
  void (__cdecl *v284)(void *); // edi@398
  size_t v285; // [sp+74h] [bp-1F4h]@51
  const char *v286; // [sp+74h] [bp-1F4h]@63
  size_t v287; // [sp+74h] [bp-1F4h]@110
  size_t v288; // [sp+74h] [bp-1F4h]@185
  size_t v289; // [sp+74h] [bp-1F4h]@324
  size_t v290; // [sp+74h] [bp-1F4h]@350
  size_t v291; // [sp+74h] [bp-1F4h]@358
  size_t v292; // [sp+74h] [bp-1F4h]@367
  void *v293; // [sp+78h] [bp-1F0h]@6
  char v294; // [sp+7Fh] [bp-1E9h]@19
  unsigned int v295; // [sp+80h] [bp-1E8h]@8
  int v296; // [sp+84h] [bp-1E4h]@19
  _BYTE *v297; // [sp+88h] [bp-1E0h]@4
  char *v298; // [sp+8Ch] [bp-1DCh]@4
  char *v299; // [sp+90h] [bp-1D8h]@4
  unsigned __int64 v300; // [sp+98h] [bp-1D0h]@5
  unsigned __int64 v301; // [sp+A0h] [bp-1C8h]@7
  unsigned int v302; // [sp+A8h] [bp-1C0h]@4
  unsigned int v303; // [sp+ACh] [bp-1BCh]@4
  unsigned int v304; // [sp+B0h] [bp-1B8h]@4
  AssetsBundleFile *v305; // [sp+B8h] [bp-1B0h]@1
  unsigned __int64 (__cdecl *v306)(unsigned __int64, unsigned __int64, void *, __int32); // [sp+BCh] [bp-1ACh]@1
  unsigned __int64 (__cdecl *v307)(unsigned __int64, unsigned __int64, const void *, __int32); // [sp+C0h] [bp-1A8h]@1
  int v308; // [sp+C4h] [bp-1A4h]@4
  int v309; // [sp+C8h] [bp-1A0h]@4
  int v310; // [sp+CCh] [bp-19Ch]@4
  struct ClassDatabaseFile *v311; // [sp+D4h] [bp-194h]@1
  unsigned __int64 v312; // [sp+D8h] [bp-190h]@47
  unsigned __int64 v313; // [sp+E0h] [bp-188h]@1
  void (__cdecl *v314)(char *); // [sp+E8h] [bp-180h]@1
  int v315; // [sp+ECh] [bp-17Ch]@189
  int v316; // [sp+F0h] [bp-178h]@366
  int v317; // [sp+F4h] [bp-174h]@366
  unsigned int v318; // [sp+F8h] [bp-170h]@67
  int v319; // [sp+FCh] [bp-16Ch]@366
  int v320; // [sp+100h] [bp-168h]@81
  int v321; // [sp+104h] [bp-164h]@81
  int v322; // [sp+108h] [bp-160h]@81
  int v323; // [sp+10Ch] [bp-15Ch]@81
  int v324; // [sp+110h] [bp-158h]@81
  void *v325; // [sp+114h] [bp-154h]@81
  int v326; // [sp+118h] [bp-150h]@184
  int v327; // [sp+11Ch] [bp-14Ch]@184
  int v328; // [sp+120h] [bp-148h]@184
  int v329; // [sp+124h] [bp-144h]@184
  int v330; // [sp+128h] [bp-140h]@184
  void *v331; // [sp+12Ch] [bp-13Ch]@184
  int v332; // [sp+130h] [bp-138h]@184
  int v333; // [sp+134h] [bp-134h]@184
  int v334; // [sp+138h] [bp-130h]@43
  int v335; // [sp+13Ch] [bp-12Ch]@43
  int v336; // [sp+140h] [bp-128h]@43
  int v337; // [sp+144h] [bp-124h]@43
  int v338; // [sp+148h] [bp-120h]@43
  void *v339; // [sp+14Ch] [bp-11Ch]@43
  int v340; // [sp+150h] [bp-118h]@83
  int v341; // [sp+154h] [bp-114h]@84
  char v342; // [sp+158h] [bp-110h]@84
  int v343; // [sp+18Ch] [bp-DCh]@388
  int v344; // [sp+190h] [bp-D8h]@200
  int v345; // [sp+194h] [bp-D4h]@200
  int v346; // [sp+198h] [bp-D0h]@184
  int v347; // [sp+19Ch] [bp-CCh]@184
  int v348; // [sp+1A0h] [bp-C8h]@83
  int v349; // [sp+1A4h] [bp-C4h]@366
  unsigned __int64 v350; // [sp+1B0h] [bp-B8h]@47
  int v351; // [sp+1B8h] [bp-B0h]@158
  int v352; // [sp+1C0h] [bp-A8h]@123
  unsigned int v353; // [sp+1C4h] [bp-A4h]@47
  int v354; // [sp+1C8h] [bp-A0h]@123
  char v355; // [sp+1D0h] [bp-98h]@28
  int v356; // [sp+264h] [bp-4h]@4

  v306 = a2;
  LODWORD(v313) = a3;
  v307 = a4;
  v9 = 0;
  v305 = this;
  v314 = a8;
  v311 = a9;
  if ( !*((_DWORD *)this + 24) || *((_DWORD *)this + 25) != 1 )
  {
    a8("ERROR : Invalid bundle file!");
    return 0;
  }
  v10 = *((_DWORD *)this + 4);
  if ( v10 == 6 )
  {
    v302 = 0;
    v303 = 0;
    v304 = 0;
    v356 = 0;
    v308 = 0;
    v309 = 0;
    v310 = 0;
    v297 = 0;
    v298 = 0;
    v299 = 0;
    LOBYTE(v356) = 2;
    sub_1000A640(a7, (int)&v302);
    if ( a7 > 0 )
    {
      v11 = (_BYTE *)(v302 + 8);
      LODWORD(v300) = v302 + 8;
      do
      {
        *((_DWORD *)v11 - 2) = a6[v9];
        v293 = (void *)(*(int (**)(void))(*(_DWORD *)a6[v9] + 8))();
        if ( v293 == (void *)-1 )
        {
          v12 = (const char *)(*(int (**)(void))(*(_DWORD *)a6[v9] + 12))();
          LODWORD(v301) = v12;
          if ( v12 )
          {
            v13 = *((_DWORD *)v305 + 24);
            v14 = 0;
            v295 = *(_DWORD *)(v13 + 24);
            if ( v295 )
            {
              v15 = (const char **)(*(_DWORD *)(v13 + 28) + 20);
              while ( strcmp(*v15, v12) )
              {
                ++v14;
                v15 += 6;
                if ( v14 >= v295 )
                  goto LABEL_15;
                v12 = (const char *)v301;
              }
              v293 = (void *)v14;
LABEL_15:
              v11 = (_BYTE *)v300;
            }
          }
        }
        *((_DWORD *)v11 - 1) = v293;
        *v11 = 0;
        ++v9;
        v11 += 12;
        LODWORD(v300) = v11;
      }
      while ( v9 < a7 );
    }
    v16 = *((_DWORD *)v305 + 24);
    v17 = v303;
    v295 = 0;
    if ( *(_DWORD *)(v16 + 24) )
    {
      LODWORD(v301) = 0;
      do
      {
        BYTE3(v296) = 1;
        v294 = 0;
        v293 = (void *)((signed int)(v17 - v302) / 12);
        if ( v293 )
        {
          v18 = v302 + 12 * ((signed int)(v17 - v302) / 12);
          LODWORD(v300) = v302 + 12 * ((signed int)(v17 - v302) / 12);
          do
          {
            if ( *(_DWORD *)(v18 - 8) == v295 )
            {
              if ( (***(int (****)(void))(v18 - 12))() == 2 )
              {
                v46 = 0;
                if ( (signed int)(v17 - v302) / 12 )
                {
                  v293 = (void *)(v17 - v302);
                  v47 = (unsigned int *)(v302 + 4);
                  LODWORD(v300) = v302 + 12;
                  v285 = v302;
                  do
                  {
                    if ( *v47 == v295 )
                    {
                      v48 = v300;
                      if ( (_DWORD)v300 != v17 )
                      {
                        v49 = v285;
                        do
                        {
                          *(_DWORD *)v49 = *(_DWORD *)v48;
                          *(_DWORD *)(v49 + 4) = *(_DWORD *)(v48 + 4);
                          *(_DWORD *)(v49 + 8) = *(_DWORD *)(v48 + 8);
                          v48 += 12;
                          v49 += 12;
                        }
                        while ( v48 != v17 );
                      }
                      v293 = (char *)v293 - 12;
                      LODWORD(v300) = v300 - 12;
                      v285 -= 12;
                      v17 -= 12;
                      --v46;
                      v47 -= 3;
                    }
                    else if ( *v47 > v295 && *v47 < 0xFFFFFFFF )
                    {
                      --*v47;
                    }
                    LODWORD(v300) = v300 + 12;
                    v285 += 12;
                    v47 += 3;
                    ++v46;
                  }
                  while ( v46 < (signed int)v293 / 12 );
                  v303 = v17;
                }
                goto LABEL_82;
              }
              if ( (***(int (****)(void))(v18 - 12))() == 1 )
              {
                if ( v294 )
                {
                  v19 = v18;
                  if ( v18 != v17 )
                  {
                    v20 = v18 - 12;
                    do
                    {
                      *(_DWORD *)v20 = *(_DWORD *)v19;
                      *(_DWORD *)(v20 + 4) = *(_DWORD *)(v19 + 4);
                      *(_DWORD *)(v20 + 8) = *(_DWORD *)(v19 + 8);
                      v19 += 12;
                      v20 += 12;
                    }
                    while ( v19 != v17 );
                  }
                  v17 -= 12;
                  v303 = v17;
                  sub_1000AF40("INFO : Ignoring double entry rename of index %ull.", v295);
                  v314(&v355);
                }
                v294 = 1;
              }
              else if ( !(***(int (****)(void))(v18 - 12))() )
              {
                if ( BYTE3(v296) )
                {
                  v23 = *(_DWORD *)(v300 - 12);
                  v24 = v301 + *(_DWORD *)(*((_DWORD *)v305 + 24) + 28);
                  v25 = sub_10004360((int)v305);
                  v26 = (*(int (__thiscall **)(int, AssetsBundleFile *, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), _DWORD, int, _DWORD, _DWORD, _DWORD, struct ClassDatabaseFile *))(*(_DWORD *)v23 + 24))(
                          v23,
                          v305,
                          v306,
                          v313,
                          *(_DWORD *)v24 + v25,
                          (*(_QWORD *)v24 + (unsigned __int64)(unsigned int)v25) >> 32,
                          *(_DWORD *)(v24 + 8),
                          *(_DWORD *)(v24 + 12),
                          v311);
                  v27 = v300;
                  if ( !v26 )
                  {
                    v28 = v303;
                    v29 = v300;
                    if ( (_DWORD)v300 != v303 )
                    {
                      v30 = v300 - 12;
                      do
                      {
                        *(_DWORD *)v30 = *(_DWORD *)v29;
                        *(_DWORD *)(v30 + 4) = *(_DWORD *)(v29 + 4);
                        *(_DWORD *)(v30 + 8) = *(_DWORD *)(v29 + 8);
                        v29 += 12;
                        v30 += 12;
                      }
                      while ( v29 != v28 );
                    }
                    v303 = v28 - 12;
                    sub_1000AF40("WARNING : Unable to prepare the entry modification for index %ull.", v295);
                    v314(&v355);
                  }
                  v31 = (const char *)(*(int (**)(void))(**(_DWORD **)(v27 - 12) + 12))();
                  if ( !v31 )
                    v31 = (const char *)&unk_100996C3;
                  v32 = strlen(v31);
                  v334 = 0;
                  v335 = 0;
                  v336 = 0;
                  v337 = 0;
                  v338 = 0;
                  v339 = 0;
                  v339 = (void *)unknown_libname_4(v32 + 1);
                  memcpy(v339, v31, v32 + 1);
                  sub_1000A750((unsigned int)&v334, (int)&v308);
                  v18 = v300;
                  v17 = v303;
                }
                else
                {
                  v21 = v18;
                  if ( v18 != v17 )
                  {
                    v22 = v18 - 12;
                    do
                    {
                      *(_DWORD *)v22 = *(_DWORD *)v21;
                      *(_DWORD *)(v22 + 4) = *(_DWORD *)(v21 + 4);
                      *(_DWORD *)(v22 + 8) = *(_DWORD *)(v21 + 8);
                      v21 += 12;
                      v22 += 12;
                    }
                    while ( v21 != v17 );
                  }
                  v17 -= 12;
                  v303 = v17;
                  sub_1000AF40("INFO : Ignoring double entry modification for index %ull.", v295);
                  v314(&v355);
                }
                BYTE3(v296) = 0;
              }
            }
            v18 -= 12;
            v293 = (char *)v293 - 1;
            LODWORD(v300) = v18;
          }
          while ( v293 );
          if ( !BYTE3(v296) )
            goto LABEL_82;
        }
        v33 = v305;
        v34 = AssetsBundleFile::IsAssetsFile(
                v305,
                v306,
                v313,
                (struct AssetsBundleDirectoryInfo06 *)(v301 + *(_DWORD *)(*((_DWORD *)v305 + 24) + 28)));
        v35 = *(_DWORD *)(*((_DWORD *)v33 + 24) + 28) + v301;
        v294 = v34;
        v36 = sub_10004360((int)v33);
        v37 = *(_DWORD *)(v35 + 12);
        v38 = *(_QWORD *)v35 + (unsigned int)v36;
        LODWORD(v350) = *(_DWORD *)(v35 + 8);
        v353 = HIDWORD(v38);
        v39 = *(void **)(v35 + 20);
        HIDWORD(v350) = v37;
        v293 = v39;
        v40 = operator new(0x38u);
        LODWORD(v312) = v40;
        if ( v40 )
        {
          v41 = v295;
          LOBYTE(v356) = 4;
          v42 = (const char *)v293;
          *v40 = &off_100A200C;
          v40[1] = v41;
          if ( v42 )
          {
            v43 = strlen(v42);
            v44 = (void *)unknown_libname_4(v43 + 1);
            v45 = v293;
            v40[2] = v44;
            memcpy(v44, v45, v43 + 1);
          }
          else
          {
            v40[2] = 0;
          }
          v50 = v294;
          v51 = v306;
          v40[3] = v40[2];
          v52 = v313;
          *((_BYTE *)v40 + 16) = v50;
          v53 = v350;
          v40[6] = v51;
          v54 = HIDWORD(v350);
          v40[7] = v52;
          v55 = v353;
          *v40 = &off_100A203C;
          v40[8] = v53;
          v40[9] = v54;
          v40[10] = v38;
          v40[11] = v55;
          v40[12] = 0x4000;
          v40[13] = 0;
          v286 = (const char *)v40;
        }
        else
        {
          v286 = 0;
        }
        LOBYTE(v356) = 2;
        v56 = v301 + *(_DWORD *)(*((_DWORD *)v305 + 24) + 28);
        v57 = sub_10004360((int)v305);
        if ( (unsigned __int8)(*(int (__thiscall **)(const char *, AssetsBundleFile *, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), _DWORD, int, _DWORD, _DWORD, _DWORD, struct ClassDatabaseFile *))(*(_DWORD *)v286 + 24))(
                                v286,
                                v305,
                                v306,
                                v313,
                                *(_DWORD *)v56 + v57,
                                (*(_QWORD *)v56 + (unsigned __int64)(unsigned int)v57) >> 32,
                                *(_DWORD *)(v56 + 8),
                                *(_DWORD *)(v56 + 12),
                                v311) )
        {
          v58 = v304;
          v59 = v302;
          LOBYTE(v318) = 1;
          if ( v17 == v304 )
          {
            v60 = (signed int)((unsigned __int64)(715827883i64 * (signed int)(v17 - v302)) >> 32) >> 1;
            v61 = v60 + (v60 >> 31);
            if ( v61 > 0x15555554 )
              goto LABEL_97;
            v62 = v61 + 1;
            v63 = (signed int)(v304 - v302) / 12;
            if ( v62 > v63 )
            {
              if ( 357913941 - (v63 >> 1) >= v63 )
                v64 = (v63 >> 1) + v63;
              else
                v64 = 0;
              if ( v64 < v62 )
                v64 = v62;
              sub_1000AA80(&v302, v64);
              v17 = v303;
              v59 = v302;
            }
          }
          if ( v17 )
          {
            v65 = v295;
            v66 = v318;
            *(_DWORD *)v17 = v286;
            *(_DWORD *)(v17 + 4) = v65;
            *(_DWORD *)(v17 + 8) = v66;
          }
          v17 += 12;
          v67 = v17 - 12;
          v303 = v17;
          if ( v59 != v17 - 12 && v67 != v17 )
            sub_1000B030(v67, v59, v17);
          v68 = *((_DWORD *)v305 + 24);
          v320 = 0;
          v321 = 0;
          v322 = 0;
          v323 = 0;
          v324 = 0;
          v325 = 0;
          v69 = strlen(*(const char **)(*(_DWORD *)(v68 + 28) + v301 + 20));
          v70 = (void *)unknown_libname_4(v69 + 1);
          v71 = *(const void **)(*(_DWORD *)(*((_DWORD *)v305 + 24) + 28) + v301 + 20);
          v325 = v70;
          memcpy(v70, v71, v69 + 1);
          sub_1000A750((unsigned int)&v320, (int)&v308);
        }
        else
        {
          sub_1000AF40("ERROR : Unable to prepare the writer for an unmodified bundle entry at index %ull.", v295);
          v314(&v355);
          (*(void (__stdcall **)(signed int))(*(_DWORD *)v286 + 4))(1);
        }
LABEL_82:
        v72 = *((_DWORD *)v305 + 24);
        LODWORD(v301) = v301 + 24;
        ++v295;
      }
      while ( v295 < *(_DWORD *)(v72 + 24) );
    }
    qmemcpy(&v340, (const void *)v305, 0x58u);
    v312 = 0i64;
    if ( v348 & 0x100 )
    {
      v340 = *(_DWORD *)"UnityWeb";
      v341 = *(_DWORD *)"yWeb";
      v342 = aUnityweb[8];
    }
    AssetsBundleHeader06::Write((AssetsBundleHeader06 *)&v340, v307, a5, &v312, 0);
    v73 = v17 - v302;
    v74 = v73 / 12;
    v295 = v73 / 12;
    if ( !(v73 / 12) )
      goto LABEL_109;
    v17 = v302;
    LODWORD(v300) = v302;
    LODWORD(v301) = v74;
    do
    {
      if ( *(_DWORD *)(v17 + 4) == -1 )
      {
        v286 = (const char *)(*(int (**)(void))(**(_DWORD **)v17 + 12))();
        if ( !v286 )
          goto LABEL_103;
        v75 = (signed int)((unsigned __int64)(715827883i64 * (v309 - v308)) >> 32) >> 2;
        v58 = v75 + (v75 >> 31);
        v293 = 0;
        if ( !(v75 + (v75 >> 31)) )
          goto LABEL_103;
        v76 = (int *)(v308 + 20);
LABEL_91:
        v77 = v286;
        v78 = *v76;
        while ( 1 )
        {
          v79 = *(_BYTE *)v78 < (const unsigned __int8)*v77;
          if ( *(_BYTE *)v78 != *v77 )
            goto LABEL_98;
          if ( *(_BYTE *)v78 )
          {
            v80 = *(_BYTE *)(v78 + 1);
            v79 = v80 < v77[1];
            if ( v80 != v77[1] )
              goto LABEL_98;
            v78 += 2;
            v77 += 2;
            if ( v80 )
              continue;
          }
          v81 = 0;
          goto LABEL_99;
        }
      }
LABEL_108:
      v17 += 12;
      v86 = (_DWORD)v301 == 1;
      LODWORD(v301) = v301 - 1;
      LODWORD(v300) = v17;
    }
    while ( !v86 );
LABEL_109:
    v87 = v303;
    LODWORD(v300) = 0;
    if ( v295 )
    {
      v88 = v302;
      v89 = (char *)(v302 + 12);
      v293 = (void *)(v302 + 12);
      v287 = v302;
      do
      {
        if ( *(_DWORD *)(v88 + 4) == -1 )
        {
          v314("WARNING : A lone replacer has nothing to replace.");
          if ( *(_BYTE *)(v88 + 8) && *(_DWORD *)v88 )
            (*(void (__stdcall **)(signed int))(**(_DWORD **)v88 + 4))(1);
          v104 = v89;
          if ( v89 != (char *)v87 )
          {
            v105 = v287;
            do
            {
              *(_DWORD *)v105 = *(_DWORD *)v104;
              *(_DWORD *)(v105 + 4) = *((_DWORD *)v104 + 1);
              *(_DWORD *)(v105 + 8) = *((_DWORD *)v104 + 2);
              v104 += 12;
              v105 += 12;
            }
            while ( v104 != (char *)v87 );
          }
          LODWORD(v300) = v300 - 1;
          v87 -= 12;
          v88 -= 12;
          v95 = v89 - 12;
          v287 -= 12;
          v303 = v87;
        }
        else
        {
          v90 = (const char *)(*(int (**)(void))(**(_DWORD **)v88 + 16))();
          if ( v90 || (v90 = (const char *)(*(int (**)(void))(**(_DWORD **)v88 + 12))()) != 0 )
          {
            v91 = strlen(v90);
            if ( *(_DWORD *)(v308 + 24 * *(_DWORD *)(v88 + 4) + 20) )
              operator delete[](*(void **)(v308 + 24 * *(_DWORD *)(v88 + 4) + 20));
            v92 = v91 + 1;
            v93 = unknown_libname_4(v92);
            v94 = v308;
            *(_DWORD *)(v308 + 24 * *(_DWORD *)(v88 + 4) + 20) = v93;
            memcpy(*(void **)(v94 + 24 * *(_DWORD *)(v88 + 4) + 20), v90, v92);
            v87 = v303;
          }
          v95 = (char *)v293;
        }
        LODWORD(v300) = v300 + 1;
        v287 += 12;
        v89 = v95 + 12;
        v88 += 12;
        v293 = v89;
      }
      while ( (unsigned int)v300 < (signed int)(v87 - v302) / 12 );
    }
    v293 = 0;
    v295 = (signed int)(v87 - v302) / 12;
    if ( v295 )
    {
      v58 = (unsigned int)v297;
      v96 = (unsigned int)v298;
      v286 = (const char *)v302;
      do
      {
        if ( !(***(int (****)(void))v286)() )
        {
          LODWORD(v97) = (*(int (**)(void))(**(_DWORD **)v286 + 20))();
          v300 = v97;
          if ( v97 >= 0xFFFFFFFF )
          {
            do
            {
              v352 = 0;
              v353 = 0;
              v354 = 0;
              if ( (unsigned int)&v352 >= v96 || v58 > (unsigned int)&v352 )
              {
                v17 = (int)v299;
                if ( (char *)v96 == v299 )
                {
                  v108 = (signed int)((unsigned __int64)(715827883i64 * (signed int)(v96 - v58)) >> 32) >> 1;
                  v109 = v108 + (v108 >> 31);
                  if ( v109 > 0x15555554 )
                    goto LABEL_97;
                  v110 = v109 + 1;
                  v111 = (signed int)&v299[-v58] / 12;
                  if ( v110 > v111 )
                  {
                    if ( 357913941 - (v111 >> 1) >= v111 )
                      v112 = (v111 >> 1) + v111;
                    else
                      v112 = 0;
                    if ( v112 < v110 )
                      v112 = v110;
                    sub_1000AA80(&v297, v112);
                    v96 = (unsigned int)v298;
                    v58 = (unsigned int)v297;
                  }
                }
                if ( !v96 )
                  goto LABEL_155;
                v113 = v353;
                v107 = v354;
                *(_DWORD *)v96 = v352;
                *(_DWORD *)(v96 + 4) = v113;
              }
              else
              {
                v98 = (signed int)((unsigned __int64)(715827883i64 * (signed int)((signed int)&v352 - v58)) >> 32) >> 1;
                v17 = v98 + (v98 >> 31);
                if ( (char *)v96 == v299 )
                {
                  v99 = (signed int)((unsigned __int64)(715827883i64 * (signed int)(v96 - v58)) >> 32) >> 1;
                  v100 = v99 + (v99 >> 31);
                  if ( v100 > 0x15555554 )
                    goto LABEL_97;
                  v101 = v100 + 1;
                  v102 = (signed int)&v299[-v58] / 12;
                  if ( v101 > v102 )
                  {
                    if ( 357913941 - (v102 >> 1) >= v102 )
                      v103 = (v102 >> 1) + v102;
                    else
                      v103 = 0;
                    if ( v103 < v101 )
                      v103 = v101;
                    sub_1000AA80(&v297, v103);
                    v96 = (unsigned int)v298;
                    v58 = (unsigned int)v297;
                  }
                }
                v106 = v58 + 12 * v17;
                if ( !v96 )
                  goto LABEL_155;
                *(_DWORD *)v96 = *(_DWORD *)v106;
                *(_DWORD *)(v96 + 4) = *(_DWORD *)(v106 + 4);
                v107 = *(_DWORD *)(v106 + 8);
              }
              *(_DWORD *)(v96 + 8) = v107;
LABEL_155:
              v96 += 12;
              v298 = (char *)v96;
              v114 = (v300 + 1) >> 32;
              LODWORD(v300) = v300 + 1;
              HIDWORD(v300) = v114 - 1;
            }
            while ( v114 != 1 || (unsigned int)v300 >= 0xFFFFFFFF );
          }
          if ( v300 )
          {
            v17 = 0;
            v350 = 0i64;
            v351 = 0;
            if ( (unsigned int)&v350 >= v96 || v58 > (unsigned int)&v350 )
            {
              if ( (char *)v96 == v299 )
              {
                v122 = (signed int)((unsigned __int64)(715827883i64 * (signed int)(v96 - v58)) >> 32) >> 1;
                v123 = v122 + (v122 >> 31);
                if ( v123 > 0x15555554 )
                {
LABEL_97:
                  std::_Xlength_error("vector<T> too long");
LABEL_98:
                  v81 = -v79 - (v79 - 1);
LABEL_99:
                  if ( v81 )
                  {
                    v76 += 6;
                    v293 = (char *)v293 + 1;
                    if ( (unsigned int)v293 < v58 )
                      goto LABEL_91;
                  }
                  else
                  {
                    *(_DWORD *)(v17 + 4) = v293;
                  }
LABEL_103:
                  if ( *(_DWORD *)(v17 + 4) == -1 && !(***(int (****)(void))v17)() )
                  {
                    if ( v286 )
                    {
                      v320 = 0;
                      v321 = 0;
                      v322 = 0;
                      v323 = 0;
                      v324 = 0;
                      v325 = 0;
                      v82 = strlen(v286);
                      v325 = (void *)unknown_libname_4(v82 + 1);
                      memcpy(v325, v286, v82 + 1);
                      *(_DWORD *)(v17 + 4) = (v309 - v308) / 24;
                      sub_1000A750((unsigned int)&v320, (int)&v308);
                      v83 = *(_DWORD *)(*((_DWORD *)v305 + 24) + 28) + 24 * *(_DWORD *)(v17 + 4);
                      v84 = sub_10004360((int)v305);
                      v85 = (*(int (__stdcall **)(AssetsBundleFile *, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), _DWORD, int, _DWORD, _DWORD, _DWORD, struct ClassDatabaseFile *))(**(_DWORD **)v17 + 24))(
                              v305,
                              v306,
                              v313,
                              *(_DWORD *)v83 + v84,
                              (*(_QWORD *)v83 + (unsigned __int64)(unsigned int)v84) >> 32,
                              *(_DWORD *)(v83 + 8),
                              *(_DWORD *)(v83 + 12),
                              v311);
                      v17 = v300;
                      if ( !v85 )
                      {
                        sub_1000AF40(
                          "WARNING : Unable to prepare the new entry writer for index %u.",
                          *(_DWORD *)(v300 + 4));
                        v314(&v355);
                      }
                    }
                  }
                  goto LABEL_108;
                }
                v124 = v123 + 1;
                v125 = (signed int)&v299[-v58] / 12;
                if ( v124 > v125 )
                {
                  if ( 357913941 - (v125 >> 1) >= v125 )
                    v126 = (v125 >> 1) + v125;
                  else
                    v126 = 0;
                  if ( v126 < v124 )
                    v126 = v124;
                  sub_1000AA80(&v297, v126);
                  v96 = (unsigned int)v298;
                  v58 = (unsigned int)v297;
                }
              }
              if ( v96 )
              {
                v127 = HIDWORD(v350);
                v128 = v351;
                *(_DWORD *)v96 = 0;
                *(_DWORD *)(v96 + 4) = v127;
                *(_DWORD *)(v96 + 8) = v128;
              }
            }
            else
            {
              v115 = (signed int)((unsigned __int64)(715827883i64 * (signed int)((signed int)&v350 - v58)) >> 32) >> 1;
              v17 = v115 + (v115 >> 31);
              if ( (char *)v96 == v299 )
              {
                v116 = (signed int)((unsigned __int64)(715827883i64 * (signed int)(v96 - v58)) >> 32) >> 1;
                v117 = v116 + (v116 >> 31);
                if ( v117 > 0x15555554 )
                  goto LABEL_97;
                v118 = v117 + 1;
                v119 = (signed int)&v299[-v58] / 12;
                if ( v118 > v119 )
                {
                  if ( 357913941 - (v119 >> 1) >= v119 )
                    v120 = (v119 >> 1) + v119;
                  else
                    v120 = 0;
                  if ( v120 < v118 )
                    v120 = v118;
                  sub_1000AA80(&v297, v120);
                  v96 = (unsigned int)v298;
                  v58 = (unsigned int)v297;
                }
              }
              v121 = v58 + 12 * v17;
              if ( v96 )
              {
                *(_DWORD *)v96 = *(_DWORD *)v121;
                *(_DWORD *)(v96 + 4) = *(_DWORD *)(v121 + 4);
                *(_DWORD *)(v96 + 8) = *(_DWORD *)(v121 + 8);
              }
            }
            v96 += 12;
            v298 = (char *)v96;
          }
        }
        v286 += 12;
        v293 = (char *)v293 + 1;
      }
      while ( (unsigned int)v293 < v295 );
    }
    v326 = 0;
    v327 = 0;
    v328 = 0;
    v329 = 0;
    v129 = v312;
    v293 = (void *)((v298 - v297) / 12);
    v330 = (v298 - v297) / 12;
    v331 = v297;
    v130 = (struct ClassDatabaseFile *)((v309 - v308) / 24);
    v350 = v312;
    v311 = (struct ClassDatabaseFile *)((v309 - v308) / 24);
    v332 = (v309 - v308) / 24;
    v333 = v308;
    AssetsBundleBlockAndDirectoryList06::Write((AssetsBundleBlockAndDirectoryList06 *)&v326, v307, a5, &v312, 0);
    v131 = v312;
    v348 &= 0xFFFFFF7F;
    v347 = v312 - v129;
    v346 = v312 - v129;
    LODWORD(v301) = 0;
    if ( v295 )
    {
      v306 = (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32))v302;
      v288 = v295;
      do
      {
        if ( !(***(int (****)(void))v306)() )
        {
          v132 = HIDWORD(v312);
          LODWORD(v300) = 0;
          v353 = 0;
          ((void (__cdecl *)(int, _DWORD, unsigned int, _DWORD, unsigned __int64 *, __int32))v307)(
            v131,
            HIDWORD(v312),
            ((v131 + 3) & 0xFFFFFFFC) - v131,
            0,
            &v300,
            a5);
          v134 = (v131 + 3) & 0xFFFFFFFC;
          v133 = (__PAIR__(v353, v134 - v131) + __PAIR__(v132, v131)) >> 32;
          v135 = v306;
          v136 = *(int (__stdcall **)(unsigned int, unsigned int, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32), __int32))(**(_DWORD **)v306 + 32);
          v313 = __PAIR__(v133, v134);
          v137 = v136(v134, v133, v307, a5);
          v138 = *(_DWORD *)v135;
          HIDWORD(v312) = v139;
          v131 = v137;
          if ( (unsigned __int8)(*(int (**)(void))(*(_DWORD *)v138 + 40))() )
            *(_DWORD *)(v308 + 24 * *((_DWORD *)v135 + 1) + 16) |= 4u;
          v140 = v308;
          v142 = 3 * *((_DWORD *)v306 + 1);
          v141 = (__PAIR__(HIDWORD(v312), v131) - v313) >> 32;
          HIDWORD(v147) = v131 - v313;
          *(_DWORD *)(v308 + 8 * v147 + 8) = v131 - v313;
          v315 = v141;
          *(_DWORD *)(v140 + 8 * v147 + 12) = v141;
          v143 = sub_10004360((int)&v340);
          v144 = (v313 - (unsigned int)v143) >> 32;
          LODWORD(v147) = v313 - v143;
          v145 = v308;
          v146 = 3 * *((_DWORD *)v306 + 1);
          *(_DWORD *)(v308 + 8 * v146) = v147;
          LODWORD(v147) = v315;
          *(_DWORD *)(v145 + 8 * v146 + 4) = v144;
          if ( (_DWORD)v147 || HIDWORD(v147) >= 0xFFFFFFFF )
          {
            v148 = v301;
            v149 = &v297[12 * v301 + 8];
            do
            {
              if ( (unsigned int)v293 <= v148 )
                break;
              *((_DWORD *)v149 - 2) = -1;
              *((_DWORD *)v149 - 1) = -1;
              *(_WORD *)v149 = 64;
              ++v148;
              v149 += 12;
              LODWORD(v147) = (__PAIR__((unsigned int)v147, HIDWORD(v147)) - 0xFFFFFFFF) >> 32;
              ++HIDWORD(v147);
            }
            while ( __PAIR__((unsigned int)v147, HIDWORD(v147)) >= 0xFFFFFFFF );
            LODWORD(v301) = v148;
          }
          else
          {
            v148 = v301;
          }
          if ( v147 && (unsigned int)v293 > v148 )
          {
            v150 = (int)&v297[12 * v148];
            v151 = (HIDWORD(v147) + 3) & 0xFFFFFFFC;
            *(_DWORD *)v150 = v151;
            *(_DWORD *)(v150 + 4) = v151;
            *(_WORD *)(v150 + 8) = 64;
            LODWORD(v301) = v148 + 1;
          }
        }
        v306 = (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32))((char *)v306 + 12);
        --v288;
      }
      while ( v288 );
      v130 = v311;
      v129 = v350;
    }
    v152 = HIDWORD(v312);
    v312 = 0i64;
    v345 = v152;
    v344 = v131;
    AssetsBundleHeader06::Write((AssetsBundleHeader06 *)&v340, v307, a5, &v312, 0);
    v331 = v297;
    v333 = v308;
    v312 = __PAIR__(HIDWORD(v350), v129);
    AssetsBundleBlockAndDirectoryList06::Write((AssetsBundleBlockAndDirectoryList06 *)&v326, v307, a5, &v312, 0);
    if ( v130 )
    {
      v153 = (void **)(v308 + 20);
      do
      {
        if ( *v153 )
          operator delete[](*v153);
        v153 += 6;
        v130 = (struct ClassDatabaseFile *)((char *)v130 - 1);
      }
      while ( v130 );
    }
    v154 = (void *)v302;
    if ( v295 )
    {
      v155 = v302;
      v156 = v295;
      do
      {
        if ( *(_BYTE *)(v155 + 8) && *(_DWORD *)v155 )
          (*(void (__stdcall **)(signed int))(**(_DWORD **)v155 + 4))(1);
        v155 += 12;
        --v156;
      }
      while ( v156 );
    }
    if ( v297 )
      operator delete(v297);
    if ( v308 )
      operator delete((void *)v308);
    if ( v154 )
      operator delete(v154);
    return 1;
  }
  if ( v10 != 3 )
    return 0;
  v297 = 0;
  v298 = 0;
  v299 = 0;
  v356 = 5;
  v302 = 0;
  v303 = 0;
  v304 = 0;
  v308 = 0;
  v309 = 0;
  v310 = 0;
  LOBYTE(v356) = 7;
  sub_1000A640(a7, (int)&v297);
  if ( a7 > 0 )
  {
    v293 = 0;
    do
    {
      *(_DWORD *)((char *)v293 + (_DWORD)v297) = a6[v9];
      LODWORD(v300) = (*(int (**)(void))(*(_DWORD *)a6[v9] + 8))();
      if ( (_DWORD)v300 == -1 )
      {
        LODWORD(v301) = (*(int (**)(void))(*(_DWORD *)a6[v9] + 12))();
        if ( (_DWORD)v301 )
        {
          v158 = *((_DWORD *)v305 + 24);
          v159 = 0;
          v295 = *(_DWORD *)(v158 + 4);
          if ( v295 )
          {
            v160 = *(_DWORD *)(v158 + 8);
            while ( strcmp((const char *)(*(_DWORD *)v160 + 8), (const char *)v301) )
            {
              ++v159;
              v160 += 4;
              if ( v159 >= v295 )
                goto LABEL_230;
            }
            LODWORD(v300) = v159;
          }
        }
      }
LABEL_230:
      v161 = v293;
      *(_DWORD *)((char *)v293 + (_DWORD)v297 + 4) = v300;
      *((_BYTE *)v161 + (_DWORD)v297 + 8) = 0;
      ++v9;
      v293 = (char *)v161 + 12;
    }
    while ( v9 < a7 );
  }
  v86 = *(_DWORD *)(*((_DWORD *)v305 + 24) + 4) == 0;
  v295 = 0;
  if ( v86 )
    goto LABEL_323;
  do
  {
    v162 = (signed int)((unsigned __int64)(715827883i64 * (v298 - v297)) >> 32) >> 1;
    v163 = v162 + (v162 >> 31);
    BYTE3(v296) = 1;
    v294 = 0;
    v286 = (const char *)(v162 + (v162 >> 31));
    if ( !(v162 + (v162 >> 31)) )
      goto LABEL_259;
    v164 = 12 * v163;
    do
    {
      v165 = v295;
      if ( *(_DWORD *)&v297[v164 - 8] != v295 )
        goto LABEL_257;
      if ( (***(int (****)(void))&v297[v164 - 12])() == 2 )
      {
        v186 = 0;
        if ( !((v298 - v297) / 12) )
          goto LABEL_322;
        v187 = v297;
        v188 = 0;
        while ( 2 )
        {
          v189 = *(_DWORD *)&v187[v188 + 4];
          if ( v189 == v295 )
          {
            v190 = (int)v298;
            v191 = (int)&v187[v188 + 12];
            if ( (char *)v191 != v298 )
            {
              v192 = (int)&v187[v188];
              do
              {
                *(_DWORD *)v192 = *(_DWORD *)v191;
                *(_DWORD *)(v192 + 4) = *(_DWORD *)(v191 + 4);
                *(_DWORD *)(v192 + 8) = *(_DWORD *)(v191 + 8);
                v191 += 12;
                v192 += 12;
              }
              while ( v191 != v190 );
            }
            v298 -= 12;
            --v186;
            v188 -= 12;
LABEL_272:
            v187 = v297;
          }
          else if ( v189 > v295 && v189 < 0xFFFFFFFF )
          {
            --*(_DWORD *)&v187[v188 + 4];
            goto LABEL_272;
          }
          v193 = (signed int)((unsigned __int64)(715827883i64 * (v298 - v187)) >> 32) >> 1;
          ++v186;
          v188 += 12;
          if ( v186 >= v193 + (v193 >> 31) )
            goto LABEL_322;
          continue;
        }
      }
      if ( (***(int (****)(void))&v297[v164 - 12])() == 1 )
      {
        if ( v294 )
        {
          v166 = (int)v298;
          v167 = (int)&v297[v164];
          if ( &v297[v164] != v298 )
          {
            v168 = v167 - 12;
            do
            {
              *(_DWORD *)v168 = *(_DWORD *)v167;
              *(_DWORD *)(v168 + 4) = *(_DWORD *)(v167 + 4);
              *(_DWORD *)(v168 + 8) = *(_DWORD *)(v167 + 8);
              v167 += 12;
              v168 += 12;
            }
            while ( v167 != v166 );
            v163 = (int)v286;
          }
          v298 -= 12;
          sub_1000AF40("INFO : Ignoring double entry rename of index %ull.", v165);
          v314(&v355);
        }
        v294 = 1;
      }
      else if ( !(***(int (****)(void))&v297[v164 - 12])() )
      {
        if ( BYTE3(v296) )
        {
          v172 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v305 + 24) + 8) + 4 * v165);
          if ( !(unsigned __int8)(*(int (__stdcall **)(AssetsBundleFile *, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), _DWORD, int, _DWORD, _DWORD, _DWORD, struct ClassDatabaseFile *))(**(_DWORD **)&v297[v164 - 12] + 24))(
                                   v305,
                                   v306,
                                   v313,
                                   *(_DWORD *)v172 + *((_DWORD *)v305 + 16),
                                   0,
                                   *(_DWORD *)(v172 + 4),
                                   0,
                                   v311) )
          {
            sub_1000A710(&v293, (int)&v297, (int)&v297[v164 - 12]);
            sub_1000AF40("WARNING : Unable to prepare the entry modification for index %ull.", v295);
            v314(&v355);
          }
          v173 = (const char *)(*(int (**)(void))(**(_DWORD **)&v297[v164 - 12] + 12))();
          if ( !v173 )
            v173 = (const char *)&unk_100996C3;
          v174 = strlen(v173);
          v175 = unknown_libname_4(v174 + 9);
          *(_DWORD *)v175 = 0;
          v293 = (void *)v175;
          *(_DWORD *)(v175 + 4) = 0;
          memcpy((void *)(v175 + 8), v173, v174 + 1);
          sub_1000A830(&v293, (int)&v302);
          v163 = (int)v286;
        }
        else
        {
          v169 = (int)v298;
          v170 = (int)&v297[v164];
          if ( &v297[v164] != v298 )
          {
            v171 = v170 - 12;
            do
            {
              *(_DWORD *)v171 = *(_DWORD *)v170;
              *(_DWORD *)(v171 + 4) = *(_DWORD *)(v170 + 4);
              *(_DWORD *)(v171 + 8) = *(_DWORD *)(v170 + 8);
              v170 += 12;
              v171 += 12;
            }
            while ( v170 != v169 );
            v163 = (int)v286;
          }
          v298 -= 12;
          sub_1000AF40("INFO : Ignoring double entry modification for index %ull.", v165);
          v314(&v355);
        }
        BYTE3(v296) = 0;
      }
LABEL_257:
      --v163;
      v164 -= 12;
      v286 = (const char *)v163;
    }
    while ( v163 );
    if ( !BYTE3(v296) )
      goto LABEL_322;
LABEL_259:
    v17 = (int)v305;
    v176 = v295;
    v177 = AssetsBundleFile::IsAssetsFile(
             v305,
             v306,
             v313,
             *(struct AssetsBundleEntry **)(*(_DWORD *)(*((_DWORD *)v305 + 24) + 8) + 4 * v295));
    v178 = *(_DWORD *)(*(_DWORD *)(v17 + 96) + 8);
    v294 = v177;
    v179 = *(_DWORD *)(v178 + 4 * v176);
    v180 = *(_DWORD *)(v17 + 64) + *(_DWORD *)v179;
    v352 = *(_DWORD *)(v179 + 4);
    v293 = (void *)(v179 + 8);
    v181 = operator new(0x38u);
    LODWORD(v300) = v181;
    if ( v181 )
    {
      v182 = v295;
      LOBYTE(v356) = 9;
      v183 = (const char *)v293;
      *v181 = &off_100A200C;
      v181[1] = v182;
      if ( v183 )
      {
        v286 = (const char *)(strlen(v183) + 1);
        v184 = (void *)unknown_libname_4(v286);
        v185 = v293;
        v181[2] = v184;
        memcpy(v184, v185, (size_t)v286);
      }
      else
      {
        v181[2] = 0;
      }
      v194 = v294;
      v181[3] = v181[2];
      v181[6] = v306;
      v195 = v352;
      *((_BYTE *)v181 + 16) = v194;
      v196 = v313;
      v181[8] = v195;
      *v181 = &off_100A203C;
      v181[7] = v196;
      v181[9] = 0;
      v181[10] = v180;
      v181[11] = 0;
      v181[12] = 0x4000;
      v181[13] = 0;
    }
    else
    {
      v181 = 0;
    }
    LOBYTE(v356) = 7;
    v197 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v17 + 96) + 8) + 4 * v295);
    if ( !(unsigned __int8)(*(int (__thiscall **)(_DWORD *, int, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), _DWORD, int, _DWORD, _DWORD, _DWORD, struct ClassDatabaseFile *))(*v181 + 24))(
                             v181,
                             v17,
                             v306,
                             v313,
                             *(_DWORD *)(v17 + 64) + *(_DWORD *)v197,
                             0,
                             *(_DWORD *)(v197 + 4),
                             0,
                             v311) )
    {
      sub_1000AF40("ERROR : Unable to prepare the writer for an unmodified bundle entry at index %ull.", v295);
      v314(&v355);
      (*(void (__thiscall **)(_DWORD *, signed int))(*v181 + 4))(v181, 1);
      goto LABEL_322;
    }
    v58 = (unsigned int)v298;
    LOBYTE(v318) = 1;
    if ( v298 == v299 )
    {
      v198 = (signed int)((unsigned __int64)(715827883i64 * (v298 - v297)) >> 32) >> 1;
      v199 = v198 + (v198 >> 31);
      if ( v199 > 0x15555554 )
        goto LABEL_97;
      v200 = v199 + 1;
      v201 = (v299 - v297) / 12;
      if ( v200 > v201 )
      {
        if ( 357913941 - (v201 >> 1) >= v201 )
          v202 = (v201 >> 1) + v201;
        else
          v202 = 0;
        if ( v202 < v200 )
          v202 = v200;
        sub_1000AA80(&v297, v202);
        v58 = (unsigned int)v298;
      }
    }
    if ( v58 )
    {
      v203 = v295;
      v204 = v318;
      *(_DWORD *)v58 = v181;
      *(_DWORD *)(v58 + 4) = v203;
      *(_DWORD *)(v58 + 8) = v204;
      v58 = (unsigned int)v298;
    }
    v205 = v58 + 12;
    v206 = v205 - 12;
    v298 = (char *)v205;
    if ( v297 != (_BYTE *)(v205 - 12) && v206 != v205 )
      sub_1000B030(v206, (int)v297, v205);
    v207 = (char *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v17 + 96) + 8) + 4 * v295) + 8);
    v208 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v17 + 96) + 8) + 4 * v295) + 9;
    do
      v209 = *v207++;
    while ( v209 );
    v210 = (int)&v207[-v208];
    v211 = unknown_libname_4(&v207[-v208 + 9]);
    v212 = v295;
    v58 = v211;
    *(_DWORD *)v211 = 0;
    *(_DWORD *)(v211 + 4) = 0;
    v213 = (const void *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v17 + 96) + 8) + 4 * v212) + 8);
    v293 = (void *)v211;
    memcpy((void *)(v211 + 8), v213, v210 + 1);
    v214 = (_DWORD *)v303;
    v215 = v302;
    if ( (unsigned int)&v293 >= v303 || v302 > (unsigned int)&v293 )
    {
      if ( v303 == v304 )
      {
        v221 = (signed int)(v303 - v302) >> 2;
        if ( v221 > 0x3FFFFFFE )
          goto LABEL_97;
        v222 = v304 - v302;
        v223 = v221 + 1;
        if ( v223 > (signed int)(v304 - v302) >> 2 )
        {
          v224 = (unsigned int)(v222 >> 2) >> 1;
          if ( 0x3FFFFFFF - v224 >= v222 >> 2 )
            v225 = v224 + (v222 >> 2);
          else
            v225 = 0;
          if ( v225 < v223 )
            v225 = v223;
          sub_10010F70((int)&v302, v225);
          v214 = (_DWORD *)v303;
        }
      }
      if ( v214 )
      {
        *v214 = v58;
LABEL_320:
        v214 = (_DWORD *)v303;
      }
    }
    else
    {
      v58 = (signed int)((signed int)&v293 - v302) >> 2;
      if ( v303 == v304 )
      {
        v216 = (signed int)(v303 - v302) >> 2;
        if ( v216 > 0x3FFFFFFE )
          goto LABEL_97;
        v217 = v216 + 1;
        v218 = (signed int)(v304 - v302) >> 2;
        if ( v217 > v218 )
        {
          v219 = (signed int)(v304 - v302) >> 2;
          if ( 0x3FFFFFFF - (v218 >> 1) >= v219 )
            v220 = (v218 >> 1) + v219;
          else
            v220 = 0;
          if ( v220 < v217 )
            v220 = v217;
          sub_10010F70((int)&v302, v220);
          v214 = (_DWORD *)v303;
          v215 = v302;
        }
      }
      if ( v214 )
      {
        *v214 = *(_DWORD *)(v215 + 4 * v58);
        goto LABEL_320;
      }
    }
    v303 = (unsigned int)(v214 + 1);
LABEL_322:
    v226 = *((_DWORD *)v305 + 24);
    ++v295;
  }
  while ( v295 < *(_DWORD *)(v226 + 4) );
LABEL_323:
  v227 = (int)v298;
  qmemcpy(&v340, (const void *)v305, 0x60u);
  LODWORD(v300) = 0;
  if ( !((v298 - v297) / 12) )
    goto LABEL_350;
  v289 = 0;
  while ( 2 )
  {
    v86 = *(_DWORD *)&v297[v289 + 4] == -1;
    LODWORD(v301) = &v297[v289];
    if ( v86 )
    {
      v228 = (const char *)(*(int (**)(void))(**(_DWORD **)&v297[v289] + 12))();
      if ( v228 )
      {
        v229 = 0;
        v230 = (signed int)(v303 - v302) >> 2;
        if ( v230 )
        {
          while ( strcmp((const char *)(*(_DWORD *)(v302 + 4 * v229) + 8), v228) )
          {
            if ( ++v229 >= v230 )
              goto LABEL_332;
          }
          *(_DWORD *)(v301 + 4) = v229;
        }
      }
LABEL_332:
      if ( *(_DWORD *)(v301 + 4) == -1 && !(***(int (****)(void))v301)() && v228 )
      {
        v231 = strlen(v228);
        v232 = unknown_libname_4(v231 + 9);
        v233 = v232;
        *(_DWORD *)v232 = 0;
        v293 = (void *)v232;
        *(_DWORD *)(v232 + 4) = 0;
        memcpy((void *)(v232 + 8), v228, v231 + 1);
        *(_DWORD *)(v301 + 4) = (signed int)(v303 - v302) >> 2;
        v234 = (_DWORD *)v303;
        if ( (unsigned int)&v293 >= v303 || (v235 = v302, v302 > (unsigned int)&v293) )
        {
          if ( v303 == v304 )
          {
            sub_1000A9D0((int)&v302);
            v234 = (_DWORD *)v303;
          }
          if ( v234 )
          {
            *v234 = v233;
LABEL_345:
            v234 = (_DWORD *)v303;
          }
        }
        else
        {
          v236 = (signed int)((signed int)&v293 - v302) >> 2;
          if ( v303 == v304 )
          {
            sub_1000A9D0((int)&v302);
            v234 = (_DWORD *)v303;
            v235 = v302;
          }
          if ( v234 )
          {
            *v234 = *(_DWORD *)(v235 + 4 * v236);
            goto LABEL_345;
          }
        }
        v237 = *((_DWORD *)v305 + 24);
        v303 = (unsigned int)(v234 + 1);
        v238 = *(_DWORD *)(*(_DWORD *)(v237 + 8) + 4 * *(_DWORD *)(v301 + 4));
        if ( !(unsigned __int8)(*(int (__stdcall **)(AssetsBundleFile *, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), _DWORD, int, _DWORD, _DWORD, _DWORD, struct ClassDatabaseFile *))(**(_DWORD **)v301 + 24))(
                                 v305,
                                 v306,
                                 v313,
                                 *(_DWORD *)v238 + *((_DWORD *)v305 + 16),
                                 0,
                                 *(_DWORD *)(v238 + 4),
                                 0,
                                 v311) )
        {
          sub_1000AF40("WARNING : Unable to prepare the new entry writer for index %u.", *(_DWORD *)(v301 + 4));
          v314(&v355);
        }
      }
    }
    v289 += 12;
    v239 = (signed int)((unsigned __int64)(715827883i64 * (v298 - v297)) >> 32) >> 1;
    LODWORD(v300) = v300 + 1;
    if ( (unsigned int)v300 < v239 + (v239 >> 31) )
      continue;
    break;
  }
  v227 = (int)v298;
LABEL_350:
  v290 = 0;
  if ( (v227 - (signed int)v297) / 12 )
  {
    v240 = 0;
    v293 = 0;
    do
    {
      v241 = (int)&v297[(_DWORD)v240];
      if ( *(_DWORD *)&v297[(_DWORD)v240 + 4] == -1 )
      {
        v314("WARNING : A lone replacer has nothing to replace.");
        v271 = v297;
        if ( v240[(_DWORD)v297 + 8] )
        {
          v272 = *(_DWORD *)&v240[(_DWORD)v297];
          if ( v272 )
          {
            (*(void (__stdcall **)(signed int))(*(_DWORD *)v272 + 4))(1);
            v271 = v297;
          }
        }
        v273 = (int)v298;
        v274 = (int)&v240[(_DWORD)v271 + 12];
        if ( (char *)v274 != v298 )
        {
          v275 = v274 - 12;
          do
          {
            *(_DWORD *)v275 = *(_DWORD *)v274;
            *(_DWORD *)(v275 + 4) = *(_DWORD *)(v274 + 4);
            *(_DWORD *)(v275 + 8) = *(_DWORD *)(v274 + 8);
            v274 += 12;
            v275 += 12;
          }
          while ( v274 != v273 );
          v273 = (int)v298;
        }
        --v290;
        v244 = v273 - 12;
        v298 = (char *)v244;
        v240 -= 12;
      }
      else
      {
        v242 = (const char *)(*(int (**)(void))(**(_DWORD **)v241 + 16))();
        if ( v242 || (v242 = (const char *)(*(int (**)(void))(**(_DWORD **)v241 + 12))()) != 0 )
        {
          operator delete(*(void **)(v302 + 4 * *(_DWORD *)(v241 + 4)));
          v243 = strlen(v242);
          LODWORD(v300) = unknown_libname_4(v243 + 9);
          memcpy((void *)(v300 + 8), v242, v243 + 1);
          v240 = (char *)v293;
          *(_DWORD *)(v302 + 4 * *(_DWORD *)(v241 + 4)) = v300;
        }
        v244 = (int)v298;
      }
      v245 = (signed int)((unsigned __int64)(715827883i64 * (v244 - (signed int)v297)) >> 32) >> 1;
      v240 += 12;
      ++v290;
      v293 = v240;
    }
    while ( v290 < v245 + (v245 >> 31) );
  }
  v350 = 0i64;
  sub_1000A890((unsigned int)&v350, (int)&v308);
  v246 = v297;
  v291 = 0;
  if ( (v298 - v297) / 12 )
  {
    v293 = 0;
    do
    {
      v247 = &v246[(_DWORD)v293];
      if ( !(***(int (****)(void))v247)() )
      {
        LODWORD(v248) = (*(int (**)(void))(**(_DWORD **)v247 + 20))();
        v249 = HIDWORD(v248);
        v250 = v248;
        if ( v248 >= 0xFFFFFFFF )
        {
          do
          {
            v350 = 0i64;
            sub_1000A890((unsigned int)&v350, (int)&v308);
            v249 = (__PAIR__(v249, v250++) - 0xFFFFFFFF) >> 32;
          }
          while ( __PAIR__(v249, v250) >= 0xFFFFFFFF );
        }
        if ( v249 | v250 )
        {
          v300 = 0i64;
          sub_1000A890((unsigned int)&v300, (int)&v308);
        }
      }
      v246 = v297;
      v293 = (char *)v293 + 12;
      v251 = (signed int)((unsigned __int64)(715827883i64 * (v298 - v297)) >> 32) >> 1;
      ++v291;
    }
    while ( v291 < v251 + (v251 >> 31) );
  }
  v347 = v308;
  v346 = (v309 - v308) >> 3;
  v301 = 0i64;
  AssetsBundleHeader03::Write((AssetsBundleHeader03 *)&v340, v307, a5, &v301, 0);
  v252 = v301;
  v253 = ((v301 + 3) & 0xFFFFFFFC) - v301;
  LODWORD(v312) = 0;
  ((void (__cdecl *)(_DWORD, _DWORD, unsigned int, _DWORD, unsigned __int64 *, __int32))v307)(
    v301,
    HIDWORD(v301),
    v253,
    0,
    &v312,
    a5);
  v254 = (v253 + __PAIR__(HIDWORD(v301), v252)) >> 32;
  v255 = v253 + v252;
  v317 = (signed int)(v303 - v302) >> 2;
  v319 = (signed int)(v303 - v302) >> 2;
  v318 = v302;
  v256 = v255;
  v301 = __PAIR__(v254, v255);
  v350 = __PAIR__(v254, v255);
  v316 = v255;
  AssetsList::Write((AssetsList *)&v316, v307, a5, &v301, 0);
  v257 = v301;
  v349 = v301 - v256;
  v344 = v256;
  *(_DWORD *)(v308 + 4) = v301 - v256;
  *(_DWORD *)v308 = v349;
  v258 = 1;
  LODWORD(v300) = 0;
  v259 = (signed int)((unsigned __int64)(715827883i64 * (v298 - v297)) >> 32) >> 1;
  if ( v259 + (v259 >> 31) )
  {
    v292 = 0;
    while ( 1 )
    {
      v260 = **(int (****)(void))&v297[v292];
      v293 = &v297[v292];
      if ( !(*v260)() )
      {
        v311 = 0;
        ((void (__cdecl *)(int, _DWORD, unsigned int, _DWORD, struct ClassDatabaseFile **, __int32))v307)(
          v257,
          HIDWORD(v301),
          ((v257 + 3) & 0xFFFFFFFC) - v257,
          0,
          &v311,
          a5);
        v261 = (v257 + 3) & 0xFFFFFFFC;
        HIDWORD(v301) = (__PAIR__(HIDWORD(v301), v261 - v257) + (unsigned int)v257) >> 32;
        v353 = HIDWORD(v301);
        v262 = (*(int (__stdcall **)(unsigned int, _DWORD, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32), __int32))(**(_DWORD **)v293 + 32))(
                 v261,
                 HIDWORD(v301),
                 v307,
                 a5);
        HIDWORD(v301) = v263;
        v264 = v293;
        v257 = v262;
        *(_DWORD *)(*(_DWORD *)(v302 + 4 * *((_DWORD *)v293 + 1)) + 4) = v262 - v261;
        **(_DWORD **)(v302 + 4 * v264[1]) = v261 - v344;
        v267 = v262 - v261;
        v265 = (__PAIR__(HIDWORD(v301), v262) - __PAIR__(v353, v261)) >> 32;
        v266 = v267;
        if ( __PAIR__(v265, v267) < 0xFFFFFFFF )
        {
LABEL_372:
          v268 = v308;
        }
        else
        {
          while ( 1 )
          {
            v268 = v308;
            if ( (v309 - v308) >> 3 <= v258 )
              break;
            *(_DWORD *)(v308 + 8 * v258 + 4) = -1;
            *(_DWORD *)(v308 + 8 * v258++) = -1;
            v265 = (__PAIR__(v265, v266++) - 0xFFFFFFFF) >> 32;
            if ( __PAIR__(v265, v266) < 0xFFFFFFFF )
              goto LABEL_372;
          }
        }
        if ( !(v265 | v266) || (v309 - v268) >> 3 <= v258 )
          goto LABEL_377;
        v269 = (v266 + 3) & 0xFFFFFFFC;
        *(_DWORD *)(v268 + 8 * v258 + 4) = v269;
        *(_DWORD *)(v308 + 8 * v258++) = v269;
      }
      v268 = v308;
LABEL_377:
      LODWORD(v300) = v300 + 1;
      v292 += 12;
      v270 = (signed int)((unsigned __int64)(715827883i64 * (v298 - v297)) >> 32) >> 1;
      if ( (unsigned int)v300 >= v270 + (v270 >> 31) )
        goto LABEL_388;
    }
  }
  v268 = v308;
LABEL_388:
  v276 = v307;
  v343 = v257;
  v348 = v257;
  v277 = 0;
  v347 = v268;
  v301 = 0i64;
  AssetsBundleHeader03::Write((AssetsBundleHeader03 *)&v340, v307, a5, &v301, 0);
  v301 = v350;
  v318 = v302;
  AssetsList::Write((AssetsList *)&v316, v276, a5, &v301, 0);
  v278 = v302;
  if ( (signed int)(v303 - v302) >> 2 )
  {
    do
    {
      operator delete[](*(void **)(v278 + 4 * v277));
      v278 = v302;
      ++v277;
    }
    while ( v277 < (signed int)(v303 - v302) >> 2 );
  }
  v279 = v297;
  v280 = 0;
  if ( (v298 - v297) / 12 )
  {
    v281 = 0;
    do
    {
      if ( v279[v281 + 8] )
      {
        v282 = *(_DWORD *)&v279[v281];
        if ( v282 )
        {
          (*(void (__stdcall **)(signed int))(*(_DWORD *)v282 + 4))(1);
          v279 = v297;
        }
      }
      v283 = (signed int)((unsigned __int64)(715827883i64 * (v298 - v279)) >> 32) >> 1;
      ++v280;
      v281 += 12;
    }
    while ( v280 < v283 + (v283 >> 31) );
    v278 = v302;
  }
  LOBYTE(v356) = 6;
  if ( v308 )
  {
    std::_Container_base0::_Orphan_all((std::_Container_base0 *)&v308);
    v284 = operator delete;
    operator delete((void *)v308);
    v279 = v297;
    v278 = v302;
  }
  else
  {
    v284 = operator delete;
  }
  v308 = 0;
  v309 = 0;
  v310 = 0;
  LOBYTE(v356) = 5;
  if ( v278 )
  {
    std::_Container_base0::_Orphan_all((std::_Container_base0 *)&v302);
    v284((void *)v302);
    v279 = v297;
  }
  v302 = 0;
  v303 = 0;
  v304 = 0;
  v356 = -1;
  if ( !v279 )
    return 1;
  std::_Container_base0::_Orphan_all((std::_Container_base0 *)&v297);
  v284(v297);
  return 1;
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 100990E8: using guessed type void __thiscall std::_Container_base0::_Orphan_all(std::_Container_base0 *__hidden this);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099190: using guessed type void __cdecl operator delete[](void *);
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100A200C: using guessed type int (*off_100A200C)();
// 100A203C: using guessed type unsigned __int32 (__thiscall *off_100A203C)(AssetFile *__hidden this);

//----- (1000A040) --------------------------------------------------------
char __thiscall AssetsBundleFile::Read(AssetsBundleFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, void (__cdecl *a4)(char *), bool a5)
{
  AssetsBundleFile *v5; // esi@1
  int v6; // eax@2
  _DWORD *v7; // eax@10
  unsigned __int64 v8; // rax@11
  unsigned int v9; // edi@16
  int v10; // ebx@17
  _DWORD *v12; // eax@27
  int v13; // ebx@30
  unsigned int v14; // edi@30
  unsigned __int64 v15; // [sp+10h] [bp-10h]@27
  unsigned __int64 v16; // [sp+18h] [bp-8h]@31

  v5 = this;
  AssetsBundleFile::Close(this);
  if ( !AssetsBundleHeader06::ReadInitial(v5, a2, a3, a4) )
    return 0;
  v6 = *((_DWORD *)v5 + 4);
  if ( v6 != 6 )
  {
    if ( v6 == 3 )
    {
      memset((void *)v5, 0, 0x60u);
      if ( AssetsBundleHeader03::Read(v5, a2, a3, a4) )
      {
        if ( !strcmp((const char *)v5, "UnityRaw") )
        {
          v15 = *((_DWORD *)v5 + 16);
          v12 = malloc(0x10u);
          *((_DWORD *)v5 + 24) = v12;
          if ( v12 )
          {
            *v12 = 0;
            v12[1] = 0;
            v12[2] = 0;
            v13 = 0;
            v12[3] = 0;
            v14 = 0;
            while ( 1 )
            {
              v16 = v15;
              if ( !AssetsList::Read((AssetsList *)(v14 + *((_DWORD *)v5 + 24)), a2, a3, &v16, a4) )
                break;
              v15 += (*(_DWORD *)(*((_DWORD *)v5 + 19) + v13 + 4) + 3) & 0xFFFFFFFC;
              v14 += 16;
              v13 += 8;
              if ( v14 >= 0x10 )
              {
                *((_DWORD *)v5 + 25) = 1;
                return 1;
              }
            }
            goto LABEL_12;
          }
LABEL_28:
          if ( a4 )
            a4("AssetsBundleFile.Read : Out of memory!");
          goto LABEL_14;
        }
LABEL_22:
        if ( !a5 )
        {
          AssetsBundleFile::Close(v5);
          return 0;
        }
        return 1;
      }
    }
    else if ( a4 )
    {
      a4("AssetsBundleFile.Read : Unknown file version!");
    }
    return 0;
  }
  memset((void *)v5, 0, 0x58u);
  if ( !AssetsBundleHeader06::Read(v5, a2, a3, a4) )
    return 0;
  if ( !strcmp((const char *)v5, "UnityArchive") )
    goto LABEL_40;
  if ( !strcmp((const char *)v5, "UnityWeb") )
  {
    *(_DWORD *)v5 = *(_DWORD *)"UnityFS";
    *((_DWORD *)v5 + 20) |= 0x100u;
    *((_DWORD *)v5 + 1) = *(_DWORD *)"yFS";
    goto LABEL_9;
  }
  if ( !strcmp((const char *)v5, "UnityRaw") )
LABEL_40:
    *((_DWORD *)v5 + 20) |= 0x40u;
LABEL_9:
  if ( *((_BYTE *)v5 + 80) & 0x3F )
    goto LABEL_22;
  *((_DWORD *)v5 + 25) = 1;
  v7 = malloc(0x20u);
  *((_DWORD *)v5 + 24) = v7;
  if ( !v7 )
    goto LABEL_28;
  *v7 = 0;
  v7[1] = 0;
  v7[2] = 0;
  v7[3] = 0;
  v7[4] = 0;
  v7[5] = 0;
  v7[6] = 0;
  v7[7] = 0;
  LODWORD(v8) = sub_100042D0((int)v5);
  if ( AssetsBundleBlockAndDirectoryList06::Read(*((AssetsBundleBlockAndDirectoryList06 **)v5 + 24), v8, a2, a3, 0) )
    return 1;
LABEL_12:
  if ( a4 )
    a4("AssetsBundleFile.Read : A file read error occured!");
LABEL_14:
  if ( *((_DWORD *)v5 + 4) == 3 )
  {
    if ( *((_DWORD *)v5 + 24) )
    {
      v9 = 0;
      if ( *((_DWORD *)v5 + 25) )
      {
        v10 = 0;
        do
        {
          AssetsList::Free((AssetsList *)(v10 + *((_DWORD *)v5 + 24)));
          ++v9;
          v10 += 16;
        }
        while ( v9 < *((_DWORD *)v5 + 25) );
      }
      free(*((void **)v5 + 24));
    }
    *((_DWORD *)v5 + 24) = 0;
  }
  *((_DWORD *)v5 + 25) = 0;
  return 0;
}

//----- (1000A360) --------------------------------------------------------
bool __thiscall AssetsBundleFile::IsAssetsFile(AssetsBundleFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, struct AssetsBundleDirectoryInfo06 *a4)
{
  int v4; // eax@1
  char v6[4]; // [sp+Ch] [bp-Ch]@1
  int v7; // [sp+10h] [bp-8h]@2

  v4 = sub_10004360((int)this);
  ((void (__cdecl *)(int, _DWORD, signed int, _DWORD, char *, __int32))a2)(
    *(_DWORD *)a4 + v4,
    (*(_QWORD *)a4 + (unsigned __int64)(unsigned int)v4) >> 32,
    8,
    0,
    v6,
    a3);
  return (*(_DWORD *)v6 != -41966060 || v7 != 1172842019) && strncmp(v6, "FSB5", 4u) && strncmp(v6, "MZ", 2u);
}

//----- (1000A410) --------------------------------------------------------
char __thiscall AssetsBundleFile::IsAssetsFile(AssetsBundleFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, struct AssetsBundleEntry *a4)
{
  unsigned int v4; // ebx@1
  unsigned int v5; // edi@1
  struct AssetsBundleEntry ***v6; // esi@2
  unsigned int v7; // edx@3
  unsigned int v8; // eax@3
  struct AssetsBundleEntry **v9; // ecx@4
  char result; // al@9
  unsigned int v11; // [sp+10h] [bp-18h]@1
  char v12[4]; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@11

  v4 = *((_DWORD *)this + 25);
  v5 = 0;
  *(_DWORD *)v12 = this;
  v11 = v4;
  if ( !v4 )
    goto LABEL_9;
  v6 = (struct AssetsBundleEntry ***)(*((_DWORD *)this + 24) + 8);
  while ( 1 )
  {
    v7 = (unsigned int)*(v6 - 1);
    v8 = 0;
    if ( v7 )
      break;
LABEL_8:
    ++v5;
    v6 += 4;
    if ( v5 >= v4 )
      goto LABEL_9;
  }
  v9 = *v6;
  while ( *v9 != a4 )
  {
    ++v8;
    ++v9;
    if ( v8 >= v7 )
    {
      v4 = v11;
      goto LABEL_8;
    }
  }
  if ( (((void (__cdecl *)(int, _DWORD, signed int, _DWORD, char *, __int32))a2)(
          *(_DWORD *)a4 + *(_DWORD *)(*(_DWORD *)v12 + 64),
          0,
          8,
          0,
          v12,
          a3),
        *(_DWORD *)v12 == -41966060)
    && v13 == 1172842019
    || !strncmp(v12, "FSB5", 4u)
    || !strncmp(v12, "MZ", 2u) )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1000A510) --------------------------------------------------------
int (__cdecl *__thiscall AssetsBundleFile::MakeAssetsFileReader(AssetsBundleFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 *a3, struct AssetsBundleDirectoryInfo06 *a4))(unsigned __int64 a1, unsigned __int64 a2, void *a3, __int32 a4)
{
  AssetsBundleFile *v4; // edi@1
  _DWORD *v5; // eax@1
  __int32 v6; // esi@1

  v4 = this;
  v5 = malloc(0x20u);
  v6 = (__int32)v5;
  v5[3] = a2;
  v5[4] = *a3;
  v5[1] = a4;
  v5[2] = 0;
  *v5 = v4;
  *((_QWORD *)v5 + 3) = *(_QWORD *)a4 + (unsigned int)sub_10004360((int)v4);
  *a3 = v6;
  return AssetsBundle_AssetsFileReader;
}

//----- (1000A570) --------------------------------------------------------
int (__cdecl *__thiscall AssetsBundleFile::MakeAssetsFileReader(AssetsBundleFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 *a3, struct AssetsBundleEntry *a4))(unsigned __int64 a1, unsigned __int64 a2, void *a3, __int32 a4)
{
  unsigned int v4; // ebx@1
  unsigned int v5; // edi@1
  struct AssetsBundleEntry ***v6; // esi@2
  unsigned int v7; // edx@3
  unsigned int v8; // eax@3
  struct AssetsBundleEntry **v9; // ecx@4
  int (__cdecl *result)(unsigned __int64, unsigned __int64, void *, __int32); // eax@9
  _DWORD *v11; // eax@10
  AssetsBundleFile *v12; // [sp+Ch] [bp-8h]@1
  unsigned int v13; // [sp+10h] [bp-4h]@1

  v4 = *((_DWORD *)this + 25);
  v5 = 0;
  v12 = this;
  v13 = v4;
  if ( v4 )
  {
    v6 = (struct AssetsBundleEntry ***)(*((_DWORD *)this + 24) + 8);
    while ( 1 )
    {
      v7 = (unsigned int)*(v6 - 1);
      v8 = 0;
      if ( v7 )
        break;
LABEL_8:
      ++v5;
      v6 += 4;
      if ( v5 >= v4 )
        goto LABEL_9;
    }
    v9 = *v6;
    while ( *v9 != a4 )
    {
      ++v8;
      ++v9;
      if ( v8 >= v7 )
      {
        v4 = v13;
        goto LABEL_8;
      }
    }
    v11 = malloc(0x20u);
    v11[3] = a2;
    v11[4] = *a3;
    v11[1] = a4;
    v11[2] = v5;
    *v11 = v12;
    v11[6] = *(_DWORD *)a4 + *((_DWORD *)v12 + 16);
    v11[7] = 0;
    *a3 = (__int32)v11;
    result = AssetsBundle_AssetsFileReader;
  }
  else
  {
LABEL_9:
    result = 0;
  }
  return result;
}

//----- (1000A610) --------------------------------------------------------
void __cdecl FreeAssetsBundle_FileReader(__int32 *a1, unsigned __int64 (__cdecl **a2)(unsigned __int64, unsigned __int64, void *, __int32))
{
  unsigned __int64 (__cdecl *v2)(unsigned __int64, unsigned __int64, void *, __int32); // ebx@1
  __int32 v3; // edi@1

  v2 = *(unsigned __int64 (__cdecl **)(unsigned __int64, unsigned __int64, void *, __int32))(*a1 + 12);
  v3 = *(_DWORD *)(*a1 + 16);
  free((void *)*a1);
  *a1 = v3;
  *a2 = v2;
}

//----- (1000A640) --------------------------------------------------------
unsigned int __usercall sub_1000A640@<eax>(unsigned int a1@<eax>, int a2@<esi>)
{
  unsigned int v2; // edi@1
  unsigned int result; // eax@1
  int v4; // edx@2

  v2 = a1;
  result = (*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) / 12;
  if ( result <= v2 )
  {
    if ( result < v2 )
    {
      sub_1000A8F0(a2, v2 - result);
      sub_1000AF80(*(_DWORD *)(a2 + 4), v2 - (*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) / 12);
      result = *(_DWORD *)(a2 + 4) + 12 * (v2 - (*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) / 12);
      *(_DWORD *)(a2 + 4) = result;
    }
  }
  else
  {
    result = 3 * v2;
    v4 = *(_DWORD *)a2 + 12 * v2;
    if ( v4 != *(_DWORD *)(a2 + 4) )
    {
      result = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a2 + 4) = v4;
    }
  }
  return result;
}

//----- (1000A710) --------------------------------------------------------
_DWORD *__userpurge sub_1000A710@<eax>(_DWORD *result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // esi@1
  int v5; // ecx@1

  v3 = a3;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = a3 + 12;
  if ( a3 + 12 != v4 )
  {
    do
    {
      *(_DWORD *)v3 = *(_DWORD *)v5;
      *(_DWORD *)(v3 + 4) = *(_DWORD *)(v5 + 4);
      *(_DWORD *)(v3 + 8) = *(_DWORD *)(v5 + 8);
      v5 += 12;
      v3 += 12;
    }
    while ( v5 != v4 );
    v3 = a3;
  }
  *(_DWORD *)(a2 + 4) -= 12;
  *result = v3;
  return result;
}

//----- (1000A750) --------------------------------------------------------
int __usercall sub_1000A750@<eax>(unsigned int a1@<eax>, int a2@<edi>)
{
  unsigned int v2; // ecx@1
  unsigned int v3; // esi@1
  unsigned int v4; // edx@3
  int v5; // esi@3
  int v6; // ecx@5
  int result; // eax@5

  v2 = *(_DWORD *)(a2 + 4);
  v3 = a1;
  if ( a1 >= v2 || *(_DWORD *)a2 > a1 )
  {
    if ( v2 == *(_DWORD *)(a2 + 8) )
      sub_1000A960(a2);
    result = *(_DWORD *)(a2 + 4);
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)v3;
      *(_DWORD *)(result + 4) = *(_DWORD *)(v3 + 4);
      *(_DWORD *)(result + 8) = *(_DWORD *)(v3 + 8);
      *(_DWORD *)(result + 12) = *(_DWORD *)(v3 + 12);
      *(_DWORD *)(result + 16) = *(_DWORD *)(v3 + 16);
      *(_DWORD *)(result + 20) = *(_DWORD *)(v3 + 20);
    }
  }
  else
  {
    v4 = (signed int)((unsigned __int64)(715827883i64 * (signed int)(a1 - *(_DWORD *)a2)) >> 32) >> 2;
    v5 = v4 + (v4 >> 31);
    if ( v2 == *(_DWORD *)(a2 + 8) )
      sub_1000A960(a2);
    v6 = *(_DWORD *)a2 + 24 * v5;
    result = *(_DWORD *)(a2 + 4);
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)v6;
      *(_DWORD *)(result + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(result + 8) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(result + 12) = *(_DWORD *)(v6 + 12);
      *(_DWORD *)(result + 16) = *(_DWORD *)(v6 + 16);
      *(_DWORD *)(result + 20) = *(_DWORD *)(v6 + 20);
      *(_DWORD *)(a2 + 4) += 24;
      return result;
    }
  }
  *(_DWORD *)(a2 + 4) += 24;
  return result;
}

//----- (1000A830) --------------------------------------------------------
_DWORD *__usercall sub_1000A830@<eax>(_DWORD *a1@<eax>, int a2@<edi>)
{
  _DWORD *v2; // esi@1
  unsigned int v3; // eax@1
  int v4; // esi@3
  _DWORD *result; // eax@5

  v2 = a1;
  v3 = *(_DWORD *)(a2 + 4);
  if ( (unsigned int)v2 >= v3 || *(_DWORD *)a2 > (unsigned int)v2 )
  {
    if ( v3 == *(_DWORD *)(a2 + 8) )
      sub_1000A9D0(a2);
    result = *(_DWORD **)(a2 + 4);
    if ( result )
      *result = *v2;
  }
  else
  {
    v4 = ((signed int)v2 - *(_DWORD *)a2) >> 2;
    if ( v3 == *(_DWORD *)(a2 + 8) )
      sub_1000A9D0(a2);
    result = *(_DWORD **)(a2 + 4);
    if ( result )
    {
      *result = *(_DWORD *)(*(_DWORD *)a2 + 4 * v4);
      *(_DWORD *)(a2 + 4) += 4;
      return result;
    }
  }
  *(_DWORD *)(a2 + 4) += 4;
  return result;
}

//----- (1000A890) --------------------------------------------------------
unsigned int __usercall sub_1000A890@<eax>(unsigned int a1@<eax>, int a2@<edi>)
{
  unsigned int v2; // esi@1
  unsigned int result; // eax@1
  int v4; // esi@3
  int v5; // ecx@5
  int v6; // eax@6

  v2 = a1;
  result = *(_DWORD *)(a2 + 4);
  if ( v2 >= result || *(_DWORD *)a2 > v2 )
  {
    if ( result == *(_DWORD *)(a2 + 8) )
      sub_1000AA30(a2);
    result = *(_DWORD *)(a2 + 4);
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)v2;
      *(_DWORD *)(result + 4) = *(_DWORD *)(v2 + 4);
    }
  }
  else
  {
    v4 = (signed int)(v2 - *(_DWORD *)a2) >> 3;
    if ( result == *(_DWORD *)(a2 + 8) )
      result = sub_1000AA30(a2);
    v5 = *(_DWORD *)(a2 + 4);
    if ( v5 )
    {
      v6 = *(_DWORD *)a2;
      *(_DWORD *)v5 = *(_DWORD *)(*(_DWORD *)a2 + 8 * v4);
      result = *(_DWORD *)(v6 + 8 * v4 + 4);
      *(_DWORD *)(v5 + 4) = result;
      *(_DWORD *)(a2 + 4) += 8;
      return result;
    }
  }
  *(_DWORD *)(a2 + 4) += 8;
  return result;
}

//----- (1000A8F0) --------------------------------------------------------
unsigned int __usercall sub_1000A8F0@<eax>(int a1@<ecx>, int a2@<ebx>)
{
  int v2; // edi@1
  unsigned int v3; // esi@1
  unsigned int v4; // esi@3
  unsigned int result; // eax@3
  unsigned int v6; // eax@5

  v2 = *(_DWORD *)a1;
  v3 = (*(_DWORD *)(a1 + 4) - *(_DWORD *)a1) / 12;
  if ( 357913941 - a2 < v3 )
    std::_Xlength_error("vector<T> too long");
  v4 = a2 + v3;
  result = (*(_DWORD *)(a1 + 8) - v2) / 12;
  if ( v4 > result )
  {
    if ( 357913941 - (result >> 1) >= result )
      v6 = (result >> 1) + result;
    else
      v6 = 0;
    if ( v6 < v4 )
      v6 = v4;
    result = sub_1000AA80((void *)a1, v6);
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);

//----- (1000A960) --------------------------------------------------------
unsigned int __thiscall sub_1000A960(int this)
{
  int v1; // edi@1
  unsigned int v2; // edx@1
  unsigned int v3; // esi@1
  unsigned int v4; // esi@3
  unsigned int result; // eax@3
  unsigned int v6; // eax@5

  v1 = *(_DWORD *)this;
  v2 = (signed int)((unsigned __int64)(715827883i64 * (*(_DWORD *)(this + 4) - *(_DWORD *)this)) >> 32) >> 2;
  v3 = v2 + (v2 >> 31);
  if ( v3 > 0xAAAAAA9 )
    std::_Xlength_error("vector<T> too long");
  v4 = v3 + 1;
  result = (*(_DWORD *)(this + 8) - v1) / 24;
  if ( v4 > result )
  {
    if ( 178956970 - (result >> 1) >= result )
      v6 = (result >> 1) + result;
    else
      v6 = 0;
    if ( v6 < v4 )
      v6 = v4;
    result = sub_1000AB70((void *)this, v6);
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);

//----- (1000A9D0) --------------------------------------------------------
unsigned int __usercall sub_1000A9D0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // edx@1
  unsigned int v3; // eax@1
  unsigned int result; // eax@3
  unsigned int v5; // ecx@3
  unsigned int v6; // ecx@5

  v1 = a1;
  v2 = *(_DWORD *)a1;
  v3 = (*(_DWORD *)(a1 + 4) - *(_DWORD *)a1) >> 2;
  if ( v3 > 0x3FFFFFFE )
    std::_Xlength_error("vector<T> too long");
  result = v3 + 1;
  v5 = (*(_DWORD *)(v1 + 8) - v2) >> 2;
  if ( result > v5 )
  {
    if ( 0x3FFFFFFF - (v5 >> 1) >= v5 )
      v6 = (v5 >> 1) + v5;
    else
      v6 = 0;
    if ( v6 < result )
      v6 = result;
    result = sub_10010F70(v1, v6);
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);

//----- (1000AA30) --------------------------------------------------------
unsigned int __thiscall sub_1000AA30(int this)
{
  int v1; // esi@1
  unsigned int v2; // eax@1
  unsigned int result; // eax@3
  unsigned int v4; // edx@3
  unsigned int v5; // edx@5

  v1 = *(_DWORD *)this;
  v2 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 3;
  if ( v2 > 0x1FFFFFFE )
    std::_Xlength_error("vector<T> too long");
  result = v2 + 1;
  v4 = (*(_DWORD *)(this + 8) - v1) >> 3;
  if ( result > v4 )
  {
    if ( 0x1FFFFFFF - (v4 >> 1) >= v4 )
      v5 = (v4 >> 1) + v4;
    else
      v5 = 0;
    if ( v5 < result )
      v5 = result;
    result = sub_1000AC60((void *)this, v5);
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);

//----- (1000AA80) --------------------------------------------------------
unsigned int __thiscall sub_1000AA80(void *this, unsigned int a2)
{
  void *v2; // esi@1
  unsigned int v3; // ecx@1
  unsigned int result; // eax@3
  char *v5; // eax@4
  int v6; // edx@4
  int v7; // ecx@4
  unsigned int v8; // edx@4
  int v9; // edi@4
  int v10; // [sp+0h] [bp-24h]@1
  char *v11; // [sp+10h] [bp-14h]@4
  int *v12; // [sp+14h] [bp-10h]@1
  int v13; // [sp+20h] [bp-4h]@4

  v12 = &v10;
  v2 = this;
  v3 = a2;
  if ( a2 > 0x15555555 )
    std::_Xlength_error("vector<T> too long");
  result = (*((_DWORD *)v2 + 2) - *(_DWORD *)v2) / 12;
  if ( result < v3 )
  {
    v5 = (char *)sub_1000AD90(v3);
    v13 = 0;
    v6 = *((_DWORD *)v2 + 1);
    v7 = *(_DWORD *)v2;
    v11 = v5;
    sub_1000AFA0((int)v5, v6, v7);
    v8 = (signed int)((unsigned __int64)(715827883i64 * (*((_DWORD *)v2 + 1) - *(_DWORD *)v2)) >> 32) >> 1;
    v9 = v8 + (v8 >> 31);
    if ( *(_DWORD *)v2 )
      operator delete(*(void **)v2);
    result = (unsigned int)v11;
    *((_DWORD *)v2 + 2) = &v11[12 * a2];
    *((_DWORD *)v2 + 1) = result + 12 * v9;
    *(_DWORD *)v2 = result;
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1000AB4F) --------------------------------------------------------
void __usercall __noreturn sub_1000AB4F(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 20));
  CxxThrowException(0, 0);
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1000AB70) --------------------------------------------------------
unsigned int __thiscall sub_1000AB70(void *this, unsigned int a2)
{
  void *v2; // esi@1
  unsigned int v3; // ecx@1
  unsigned int result; // eax@3
  char *v5; // eax@4
  int v6; // edx@4
  int v7; // ecx@4
  unsigned int v8; // edx@4
  int v9; // edi@4
  int v10; // [sp+0h] [bp-24h]@1
  char *v11; // [sp+10h] [bp-14h]@4
  int *v12; // [sp+14h] [bp-10h]@1
  int v13; // [sp+20h] [bp-4h]@4

  v12 = &v10;
  v2 = this;
  v3 = a2;
  if ( a2 > 0xAAAAAAA )
    std::_Xlength_error("vector<T> too long");
  result = (*((_DWORD *)v2 + 2) - *(_DWORD *)v2) / 24;
  if ( result < v3 )
  {
    v5 = (char *)sub_1000AD30(v3);
    v13 = 0;
    v6 = *((_DWORD *)v2 + 1);
    v7 = *(_DWORD *)v2;
    v11 = v5;
    sub_1000AFD0((int)v5, v6, v7);
    v8 = (signed int)((unsigned __int64)(715827883i64 * (*((_DWORD *)v2 + 1) - *(_DWORD *)v2)) >> 32) >> 2;
    v9 = v8 + (v8 >> 31);
    if ( *(_DWORD *)v2 )
      operator delete(*(void **)v2);
    result = (unsigned int)v11;
    *((_DWORD *)v2 + 2) = &v11[24 * a2];
    *((_DWORD *)v2 + 1) = result + 24 * v9;
    *(_DWORD *)v2 = result;
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1000AC41) --------------------------------------------------------
void __usercall __noreturn sub_1000AC41(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 20));
  CxxThrowException(0, 0);
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1000AC60) --------------------------------------------------------
unsigned int __thiscall sub_1000AC60(void *this, unsigned int a2)
{
  void *v2; // esi@1
  unsigned int v3; // ecx@1
  unsigned int result; // eax@3
  char *v5; // ebx@4
  int v6; // edx@4
  int v7; // ecx@4
  int v8; // edi@4
  int v9; // [sp+0h] [bp-24h]@1
  char *v10; // [sp+10h] [bp-14h]@4
  int *v11; // [sp+14h] [bp-10h]@1
  int v12; // [sp+20h] [bp-4h]@4

  v11 = &v9;
  v2 = this;
  v3 = a2;
  if ( a2 > 0x1FFFFFFF )
    std::_Xlength_error("vector<T> too long");
  result = (*((_DWORD *)v2 + 2) - *(_DWORD *)v2) >> 3;
  if ( result < v3 )
  {
    v5 = (char *)sub_1000AE50(v3);
    v12 = 0;
    v6 = *((_DWORD *)v2 + 1);
    v7 = *(_DWORD *)v2;
    v10 = v5;
    sub_1000B010((int)v5, v6, v7);
    v8 = (*((_DWORD *)v2 + 1) - *(_DWORD *)v2) >> 3;
    if ( *(_DWORD *)v2 )
      operator delete(*(void **)v2);
    result = (unsigned int)&v5[8 * v8];
    *((_DWORD *)v2 + 2) = &v5[8 * a2];
    *((_DWORD *)v2 + 1) = result;
    *(_DWORD *)v2 = v5;
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1000AD10) --------------------------------------------------------
void __usercall __noreturn sub_1000AD10(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 20));
  CxxThrowException(0, 0);
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1000AD30) --------------------------------------------------------
void *__fastcall sub_1000AD30(unsigned int a1)
{
  void *result; // eax@1
  int (__stdcall **v2)(char); // [sp+0h] [bp-10h]@4
  int v3; // [sp+Ch] [bp-4h]@4

  result = 0;
  if ( a1 )
  {
    if ( a1 > 0xAAAAAAA || (result = operator new(24 * a1)) == 0 )
    {
      v3 = 0;
      std::exception::exception((std::exception *)&v2, (const char *const *)&v3);
      v2 = &off_10099840;
      CxxThrowException(&v2, &unk_100A5EA0);
    }
  }
  return result;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (1000AD90) --------------------------------------------------------
void *__fastcall sub_1000AD90(unsigned int a1)
{
  void *result; // eax@1
  int (__stdcall **v2)(char); // [sp+0h] [bp-10h]@4
  int v3; // [sp+Ch] [bp-4h]@4

  result = 0;
  if ( a1 )
  {
    if ( a1 > 0x15555555 || (result = operator new(12 * a1)) == 0 )
    {
      v3 = 0;
      std::exception::exception((std::exception *)&v2, (const char *const *)&v3);
      v2 = &off_10099840;
      CxxThrowException(&v2, &unk_100A5EA0);
    }
  }
  return result;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (1000ADF0) --------------------------------------------------------
void *__fastcall sub_1000ADF0(unsigned int a1)
{
  void *result; // eax@1
  int (__stdcall **v2)(char); // [sp+0h] [bp-10h]@4
  int v3; // [sp+Ch] [bp-4h]@4

  result = 0;
  if ( a1 )
  {
    if ( a1 > 0x3FFFFFFF || (result = operator new(4 * a1)) == 0 )
    {
      v3 = 0;
      std::exception::exception((std::exception *)&v2, (const char *const *)&v3);
      v2 = &off_10099840;
      CxxThrowException(&v2, &unk_100A5EA0);
    }
  }
  return result;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (1000AE50) --------------------------------------------------------
void *__fastcall sub_1000AE50(unsigned int a1)
{
  void *result; // eax@1
  int (__stdcall **v2)(char); // [sp+0h] [bp-10h]@4
  int v3; // [sp+Ch] [bp-4h]@4

  result = 0;
  if ( a1 )
  {
    if ( a1 > 0x1FFFFFFF || (result = operator new(8 * a1)) == 0 )
    {
      v3 = 0;
      std::exception::exception((std::exception *)&v2, (const char *const *)&v3);
      v2 = &off_10099840;
      CxxThrowException(&v2, &unk_100A5EA0);
    }
  }
  return result;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (1000AEB0) --------------------------------------------------------
int __usercall sub_1000AEB0@<eax>(int result@<eax>)
{
  int v1; // ST0C_4@1
  int v2; // ST04_4@1
  int v3; // ST08_4@1

  BYTE2(v1) = (unsigned __int16)*(_DWORD *)result >> 8;
  BYTE3(v1) = *(_DWORD *)result;
  BYTE1(v1) = *(_DWORD *)result >> 16;
  v2 = *(_DWORD *)(result + 4);
  LOBYTE(v1) = *(_DWORD *)result >> 24;
  BYTE3(v3) = *(_DWORD *)(result + 4);
  LOBYTE(v3) = *(_DWORD *)(result + 4) >> 24;
  BYTE2(v3) = BYTE1(v2);
  BYTE1(v3) = *(_DWORD *)(result + 4) >> 16;
  *(_DWORD *)result = v3;
  *(_DWORD *)(result + 4) = v1;
  return result;
}

//----- (1000AF00) --------------------------------------------------------
__int64 __cdecl sub_1000AF00(int a1, int a2)
{
  __int64 v2; // ST00_8@1

  BYTE6(v2) = BYTE1(a1);
  BYTE7(v2) = a1;
  BYTE4(v2) = BYTE3(a1);
  BYTE5(v2) = BYTE2(a1);
  BYTE2(v2) = BYTE1(a2);
  BYTE3(v2) = a2;
  BYTE1(v2) = BYTE2(a2);
  LOBYTE(v2) = BYTE3(a2);
  return v2;
}

//----- (1000AF40) --------------------------------------------------------
int sub_1000AF40(char *Format, ...)
{
  char *v1; // edx@0
  va_list va; // [sp+Ch] [bp+Ch]@1

  va_start(va, Format);
  return vsprintf_s(v1, 0x80u, Format, va);
}
// 1000AF40: can not handle register arguments in vararg function, discarded them

//----- (1000AF60) --------------------------------------------------------
std::exception *__thiscall sub_1000AF60(std::exception *this, const struct std::exception *a2)
{
  std::exception *v2; // esi@1

  v2 = this;
  std::exception::exception(this, a2);
  *(_DWORD *)v2 = &off_10099840;
  return v2;
}
// 10099174: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (1000AF80) --------------------------------------------------------
int __usercall sub_1000AF80@<eax>(int result@<eax>, int a2@<edx>)
{
  for ( ; a2; --a2 )
  {
    if ( result )
    {
      *(_DWORD *)result = 0;
      *(_DWORD *)(result + 4) = 0;
      *(_DWORD *)(result + 8) = 0;
    }
    result += 12;
  }
  return result;
}

//----- (1000AFA0) --------------------------------------------------------
int __usercall sub_1000AFA0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  for ( ; a3 != a2; result += 12 )
  {
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)a3;
      *(_DWORD *)(result + 4) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(result + 8) = *(_DWORD *)(a3 + 8);
    }
    a3 += 12;
  }
  return result;
}

//----- (1000AFD0) --------------------------------------------------------
int __usercall sub_1000AFD0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  for ( ; a3 != a2; result += 24 )
  {
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)a3;
      *(_DWORD *)(result + 4) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(result + 8) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(result + 12) = *(_DWORD *)(a3 + 12);
      *(_DWORD *)(result + 16) = *(_DWORD *)(a3 + 16);
      *(_DWORD *)(result + 20) = *(_DWORD *)(a3 + 20);
    }
    a3 += 24;
  }
  return result;
}

//----- (1000B010) --------------------------------------------------------
int __usercall sub_1000B010@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  for ( ; a3 != a2; result += 8 )
  {
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)a3;
      *(_DWORD *)(result + 4) = *(_DWORD *)(a3 + 4);
    }
    a3 += 8;
  }
  return result;
}

//----- (1000B030) --------------------------------------------------------
int __usercall sub_1000B030@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int result; // eax@1
  signed int v6; // esi@1
  int v7; // edx@2
  int v8; // ecx@6
  int v9; // esi@8
  int v10; // eax@8
  int v11; // ecx@8
  int v12; // eax@10
  int v13; // edx@10
  int v14; // ST14_4@10
  int v15; // eax@10
  int v16; // [sp+18h] [bp-Ch]@6
  int v17; // [sp+20h] [bp-4h]@1

  v3 = a3;
  v4 = (a1 - a2) / 12;
  result = (a3 - a2) / 12;
  v17 = (a3 - a2) / 12;
  v6 = v4;
  if ( v4 )
  {
    do
    {
      v7 = result % v6;
      result = v6;
      v6 = v7;
    }
    while ( v7 );
    v17 = result;
  }
  if ( result < (a3 - a2) / 12 && result > 0 )
  {
    v8 = 12 * v4;
    result = a2 + 12 * result;
    v16 = result;
    while ( 1 )
    {
      v9 = result;
      v10 = v8 + result;
      v11 = a2;
      if ( v10 != v3 )
        v11 = v10;
      do
      {
        v12 = *(_DWORD *)v9;
        v13 = *(_DWORD *)(v9 + 4);
        v14 = *(_DWORD *)(v9 + 8);
        *(_DWORD *)v9 = *(_DWORD *)v11;
        *(_DWORD *)(v9 + 4) = *(_DWORD *)(v11 + 4);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(v11 + 8);
        v3 = a3;
        *(_DWORD *)v11 = v12;
        *(_DWORD *)(v11 + 4) = v13;
        *(_DWORD *)(v11 + 8) = v14;
        v15 = (a3 - v11) / 12;
        v9 = v11;
        if ( v4 >= v15 )
          v11 = a2 + 12 * (v4 - v15);
        else
          v11 += 12 * v4;
      }
      while ( v11 != v16 );
      result = v16 - 12;
      --v17;
      v16 -= 12;
      if ( v17 <= 0 )
        break;
      v8 = 12 * v4;
    }
  }
  return result;
}

//----- (1000B130) --------------------------------------------------------
char *__thiscall AssetFile::GetFileName(AssetFile *this, char *a2, unsigned int a3, int a4)
{
  AssetFile *v4; // esi@1
  signed int v5; // ecx@4
  int v6; // eax@4
  char *result; // eax@10

  v4 = this;
  if ( (unsigned int)a4 > 0x122 )
  {
LABEL_14:
    result = a2;
    if ( a3 )
      *a2 = 0;
    return result;
  }
  if ( a4 != 290 )
  {
    switch ( a4 )
    {
      case 21:
      case 27:
      case 28:
      case 43:
      case 48:
      case 49:
      case 62:
      case 72:
      case 74:
      case 83:
      case 84:
      case 89:
      case 90:
      case 91:
      case 93:
      case 109:
      case 115:
      case 117:
      case 121:
      case 128:
      case 134:
      case 142:
      case 150:
      case 152:
      case 156:
      case 158:
      case 171:
      case 184:
      case 185:
      case 186:
      case 194:
      case 200:
      case 207:
      case 213:
      case 221:
      case 226:
      case 228:
      case 237:
      case 238:
      case 240:
      case 258:
      case 271:
      case 272:
      case 273:
        goto LABEL_4;
      default:
        goto LABEL_14;
    }
    goto LABEL_14;
  }
LABEL_4:
  v5 = *(_DWORD *)this;
  v6 = 0;
  if ( *(_DWORD *)v4 > 0 )
  {
    while ( *((_BYTE *)v4 + v6 + 4) >= 32 )
    {
      if ( ++v6 >= v5 )
        goto LABEL_7;
    }
    goto LABEL_14;
  }
LABEL_7:
  if ( a3 >= v5 + 1 )
  {
    memcpy(a2, (char *)v4 + 4, v5);
    a2[*(_DWORD *)v4] = 0;
  }
  else
  {
    if ( a3 >= 4 )
    {
      memcpy(a2, (char *)v4 + 4, a3 - 4);
      *(_DWORD *)&a2[a3 - 4] = 3026478;
      return a2;
    }
    if ( a3 )
    {
      *a2 = 0;
      return a2;
    }
  }
  return a2;
}

//----- (1000B300) --------------------------------------------------------
signed int __cdecl AssetFileInfo::GetSize(unsigned __int32 a1)
{
  signed int result; // eax@3

  if ( a1 >= 0x11 )
    goto LABEL_10;
  if ( a1 >= 0x10 )
    return 23;
  if ( a1 >= 0xF )
    return 25;
  result = 24;
  if ( a1 != 14 )
LABEL_10:
    result = 20;
  return result;
}

//----- (1000B340) --------------------------------------------------------
unsigned __int64 __thiscall AssetFileInfo::Read(AssetFileInfo *this, unsigned __int32 a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a5, bool a6)
{
  unsigned __int32 v6; // ebx@1
  unsigned int v7; // edi@1
  AssetFileInfo *v8; // esi@1
  int v9; // ecx@1
  signed int v10; // eax@5
  signed int v11; // eax@12
  size_t v12; // edi@17
  int v13; // edx@19
  int v14; // ST2C_4@19
  int v15; // ST28_4@19
  int v16; // edx@19
  int v17; // edx@22
  unsigned int v18; // edx@24
  unsigned int v19; // ecx@26
  signed int v20; // edi@26
  __int16 v21; // cx@29
  __int16 v22; // ST28_2@30
  __int16 v23; // cx@33
  __int16 v24; // ST28_2@34
  unsigned __int64 result; // rax@37
  int v26; // [sp+20h] [bp-20h]@10
  int v27; // [sp+24h] [bp-1Ch]@24
  int v28; // [sp+28h] [bp-18h]@26
  unsigned __int64 v29; // [sp+4Ch] [bp+Ch]@17

  v6 = a2;
  v7 = a3;
  v8 = this;
  v9 = HIDWORD(a3);
  if ( a2 >= 0xE )
  {
    v9 = (a3 + 3) >> 32;
    HIDWORD(a3) = (a3 + 3) >> 32;
    v7 = (a3 + 3) & 0xFFFFFFFC;
  }
  if ( a2 >= 0x11 )
    goto LABEL_9;
  if ( a2 < 0x10 )
  {
    if ( a2 >= 0xF )
    {
      v10 = 25;
      goto LABEL_10;
    }
    v10 = 24;
    if ( a2 == 14 )
      goto LABEL_10;
LABEL_9:
    v10 = 20;
    goto LABEL_10;
  }
  v10 = 23;
LABEL_10:
  ((void (__cdecl *)(unsigned int, int, signed int, _DWORD, int *, __int32))a4)(v7, v9, v10, 0, &v26, a5);
  if ( a2 >= 0x11 )
    goto LABEL_42;
  if ( a2 >= 0x10 )
  {
    v11 = 23;
    goto LABEL_17;
  }
  if ( a2 >= 0xF )
  {
    v11 = 25;
    goto LABEL_17;
  }
  v11 = 24;
  if ( a2 != 14 )
LABEL_42:
    v11 = 20;
LABEL_17:
  v29 = __PAIR__(HIDWORD(a3), v11) + v7;
  *(_DWORD *)v8 = 0;
  *((_DWORD *)v8 + 1) = 0;
  v12 = a2 < 0xE ? 4 : 8;
  memcpy((void *)v8, &v26, v12);
  if ( a6 )
  {
    if ( a2 < 0xE )
    {
      v16 = *((_BYTE *)v8 + 3)
          + ((*(_DWORD *)v8 >> 8) & 0xFF00)
          + (((*(_DWORD *)v8 & 0xFF00) + (*(_DWORD *)v8 << 16)) << 8);
    }
    else
    {
      v13 = *((_DWORD *)v8 + 1);
      BYTE2(v14) = (unsigned __int16)*(_DWORD *)v8 >> 8;
      BYTE3(v14) = *(_DWORD *)v8;
      BYTE1(v14) = *(_DWORD *)v8 >> 16;
      LOBYTE(v14) = *(_DWORD *)v8 >> 24;
      BYTE3(v15) = *((_DWORD *)v8 + 1);
      LOBYTE(v15) = *((_DWORD *)v8 + 1) >> 24;
      BYTE2(v15) = BYTE1(v13);
      BYTE1(v15) = *((_DWORD *)v8 + 1) >> 16;
      v16 = v15;
      *((_DWORD *)v8 + 1) = v14;
    }
    *(_DWORD *)v8 = v16;
  }
  v17 = *(int *)((char *)&v26 + v12);
  *((_DWORD *)v8 + 2) = v17;
  if ( a6 )
    *((_DWORD *)v8 + 2) = *((_BYTE *)v8 + 11)
                        + ((*((_DWORD *)v8 + 2) >> 8) & 0xFF00)
                        + (((v17 & 0xFF00) + (v17 << 16)) << 8);
  v18 = *(int *)((char *)&v27 + v12);
  *((_DWORD *)v8 + 3) = v18;
  if ( a6 )
  {
    v6 = a2;
    *((_DWORD *)v8 + 3) = ((v18 >> 8) & 0xFF00) + *((_BYTE *)v8 + 15) + (((v18 & 0xFF00) + (v18 << 16)) << 8);
  }
  v19 = *(int *)((char *)&v28 + v12);
  v20 = a2 < 0xE ? 16 : 20;
  *((_DWORD *)v8 + 4) = v19;
  if ( a6 )
  {
    v6 = a2;
    *((_DWORD *)v8 + 4) = ((v19 >> 8) & 0xFF00) + *((_BYTE *)v8 + 19) + (((v19 & 0xFF00) + (v19 << 16)) << 8);
  }
  if ( v6 >= 0x10 )
  {
    *((_WORD *)v8 + 10) = 0;
  }
  else
  {
    v21 = *(_WORD *)((char *)&v26 + v20);
    v20 = a2 < 0xE ? 18 : 22;
    *((_WORD *)v8 + 10) = v21;
    if ( a6 )
    {
      LOBYTE(v22) = HIBYTE(v21);
      HIBYTE(v22) = v21;
      *((_WORD *)v8 + 10) = v22;
    }
  }
  if ( v6 - 11 > 5 )
  {
    *((_WORD *)v8 + 11) = -1;
    if ( v6 < 0xB )
      v20 += 2;
  }
  else
  {
    v23 = *(_WORD *)((char *)&v26 + v20);
    v20 += 2;
    *((_WORD *)v8 + 11) = v23;
    if ( a6 )
    {
      LOBYTE(v24) = HIBYTE(v23);
      HIBYTE(v24) = v23;
      *((_WORD *)v8 + 11) = v24;
    }
  }
  result = v29;
  if ( v6 - 15 > 1 )
    *((_BYTE *)v8 + 24) = 0;
  else
    *((_BYTE *)v8 + 24) = *((_BYTE *)&v26 + v20);
  return result;
}

//----- (1000B5E0) --------------------------------------------------------
signed __int64 __thiscall AssetFileInfo::Write(AssetFileInfo *this, unsigned __int32 a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5)
{
  AssetFileInfo *v5; // ebx@1
  __int64 v6; // rdi@2
  size_t v7; // edi@4
  int v8; // edx@4
  int v9; // ecx@4
  signed int v10; // eax@4
  __int16 v11; // dx@8
  unsigned int v12; // ebx@12
  int v14; // [sp+14h] [bp-24h]@2
  int v15; // [sp+18h] [bp-20h]@4
  int v16; // [sp+1Ch] [bp-1Ch]@4
  int v17; // [sp+20h] [bp-18h]@4

  v5 = this;
  if ( a2 < 0xE )
  {
    HIDWORD(v6) = HIDWORD(a3);
  }
  else
  {
    v14 = 0;
    ((void (__cdecl *)(_DWORD, _DWORD, int, int, int *, __int32))a4)(
      a3,
      HIDWORD(a3),
      3 - (((_BYTE)a3 - 1) & 3),
      -((((_BYTE)a3 - 1) & 3u) > 3),
      &v14,
      a5);
    LODWORD(v6) = (a3 + 3) >> 32;
    LODWORD(a3) = (a3 + 3) & 0xFFFFFFFC;
    HIDWORD(v6) = v6;
  }
  v7 = a2 < 0xE ? 4 : 8;
  memcpy(&v15, (const void *)v5, v7);
  v8 = *((_DWORD *)v5 + 3);
  *(int *)((char *)&v15 + v7) = *((_DWORD *)v5 + 2);
  v9 = *((_DWORD *)v5 + 4);
  *(int *)((char *)&v16 + v7) = v8;
  *(int *)((char *)&v17 + v7) = v9;
  v10 = a2 < 0xE ? 16 : 20;
  if ( a2 < 0x10 )
  {
    *(_WORD *)((char *)&v15 + v10) = *((_WORD *)v5 + 10);
    v10 = a2 < 0xE ? 18 : 22;
  }
  if ( a2 < 0x11 )
  {
    if ( a2 < 0xB )
      v11 = 0;
    else
      v11 = *((_WORD *)v5 + 11);
    *(_WORD *)((char *)&v15 + v10) = v11;
    v10 += 2;
    if ( a2 >= 0xF )
      *((_BYTE *)&v15 + v10++) = *((_BYTE *)v5 + 24);
  }
  v12 = (unsigned __int64)v10 >> 32;
  LODWORD(v6) = v10;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, unsigned int, int *, __int32))a4)(a3, HIDWORD(v6), v10, v12, &v15, a5);
  return __PAIR__(v12, (unsigned int)a3) + v6;
}

//----- (1000B700) --------------------------------------------------------
unsigned int __thiscall AssetFileList::GetSizeBytes(AssetFileList *this, unsigned __int32 a2)
{
  unsigned int result; // eax@3
  signed int v3; // eax@4
  int v4; // edx@4
  signed int v5; // edx@10

  if ( a2 - 15 > 1 )
  {
    if ( a2 >= 0x11 )
      goto LABEL_15;
    if ( a2 >= 0x10 )
      return 23 * *(_DWORD *)this;
    if ( a2 >= 0xF )
      return 25 * *(_DWORD *)this;
    v5 = 24;
    if ( a2 != 14 )
LABEL_15:
      v5 = 20;
    result = v5 * *(_DWORD *)this;
  }
  else if ( *(_DWORD *)this )
  {
    v3 = AssetFileInfo::GetSize(a2);
    result = v3 + (v4 - 1) * ((v3 + 3) & 0xFFFFFFFC);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000B780) --------------------------------------------------------
int __thiscall AssetFileList::Read(AssetFileList *this, unsigned __int32 a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a5, bool a6)
{
  unsigned __int64 v6; // rax@1
  unsigned __int32 v7; // ebx@2
  char *v8; // esi@2
  unsigned int v9; // edi@3
  signed __int64 v10; // rax@4
  signed int v11; // eax@7
  signed int v12; // eax@14
  int v13; // edi@19
  int v14; // edx@21
  int v15; // ST3C_4@21
  int v16; // ST38_4@21
  int v17; // edx@21
  unsigned int v18; // edx@24
  unsigned int v19; // edx@26
  unsigned int v20; // edx@28
  signed int v21; // eax@28
  __int16 v22; // dx@31
  __int16 v23; // ST2C_2@32
  __int16 v24; // cx@35
  __int16 v25; // ST28_2@36
  unsigned __int64 v27; // [sp+18h] [bp-50h]@19
  unsigned int v28; // [sp+1Ch] [bp-4Ch]@3
  int v29; // [sp+2Ch] [bp-3Ch]@1
  signed int v30; // [sp+3Ch] [bp-2Ch]@2
  AssetFileList *v31; // [sp+44h] [bp-24h]@1
  int v32; // [sp+48h] [bp-20h]@12
  int v33; // [sp+4Ch] [bp-1Ch]@26
  int v34; // [sp+50h] [bp-18h]@28

  HIDWORD(v6) = HIDWORD(a3);
  v31 = this;
  v29 = 0;
  if ( *(_DWORD *)this )
  {
    v7 = a2;
    v30 = a2 < 0xE ? 4 : 8;
    LODWORD(v6) = a3;
    v8 = (char *)this + 16;
    while ( 1 )
    {
      v28 = HIDWORD(v6);
      v9 = v6;
      if ( v7 >= 0xE )
      {
        v10 = v6 + 3;
        v28 = HIDWORD(v10);
        v9 = v10 & 0xFFFFFFFC;
      }
      if ( v7 >= 0x11 )
        goto LABEL_48;
      if ( v7 >= 0x10 )
      {
        v11 = 23;
        goto LABEL_12;
      }
      if ( v7 >= 0xF )
      {
        v11 = 25;
        goto LABEL_12;
      }
      v11 = 24;
      if ( v7 != 14 )
LABEL_48:
        v11 = 20;
LABEL_12:
      ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, int *, __int32))a4)(v9, v28, v11, 0, &v32, a5);
      if ( v7 >= 0x11 )
        goto LABEL_18;
      if ( v7 < 0x10 )
      {
        if ( v7 < 0xF )
        {
          v12 = 24;
          if ( v7 != 14 )
          {
LABEL_18:
            v12 = 20;
            goto LABEL_19;
          }
        }
        else
        {
          v12 = 25;
        }
      }
      else
      {
        v12 = 23;
      }
LABEL_19:
      v27 = (unsigned int)v12 + __PAIR__(v28, v9);
      v13 = (int)(v8 - 8);
      *(_DWORD *)v13 = 0;
      *(_DWORD *)(v13 + 4) = 0;
      memcpy(v8 - 8, &v32, v30);
      if ( a6 )
      {
        if ( v7 < 0xE )
        {
          v7 = a2;
          v17 = (unsigned __int8)*(v8 - 5)
              + ((*(_DWORD *)v13 >> 8) & 0xFF00)
              + (((*(_DWORD *)v13 & 0xFF00) + (*(_DWORD *)v13 << 16)) << 8);
        }
        else
        {
          v14 = *(_DWORD *)(v13 + 4);
          BYTE2(v15) = (unsigned __int16)*(_DWORD *)v13 >> 8;
          BYTE3(v15) = *(_DWORD *)v13;
          BYTE1(v15) = *(_DWORD *)v13 >> 16;
          LOBYTE(v15) = *(_DWORD *)v13 >> 24;
          BYTE3(v16) = *(_DWORD *)(v13 + 4);
          LOBYTE(v16) = *(_DWORD *)(v13 + 4) >> 24;
          BYTE2(v16) = BYTE1(v14);
          BYTE1(v16) = *(_DWORD *)(v13 + 4) >> 16;
          v17 = v16;
          *(_DWORD *)(v13 + 4) = v15;
        }
        *(_DWORD *)v13 = v17;
      }
      v18 = *(int *)((char *)&v32 + v30);
      *(_DWORD *)v8 = v18;
      if ( a6 )
        *(_DWORD *)v8 = (unsigned __int8)v8[3] + ((v18 >> 8) & 0xFF00) + (((v18 & 0xFF00) + (v18 << 16)) << 8);
      v19 = *(int *)((char *)&v33 + v30);
      *((_DWORD *)v8 + 1) = v19;
      if ( a6 )
        *((_DWORD *)v8 + 1) = (unsigned __int8)v8[7] + ((v19 >> 8) & 0xFF00) + (((v19 & 0xFF00) + (v19 << 16)) << 8);
      v20 = *(int *)((char *)&v34 + v30);
      v21 = a2 < 0xE ? 16 : 20;
      *((_DWORD *)v8 + 2) = v20;
      if ( a6 )
        *((_DWORD *)v8 + 2) = (unsigned __int8)v8[11] + ((v20 >> 8) & 0xFF00) + (((v20 & 0xFF00) + (v20 << 16)) << 8);
      if ( v7 >= 0x10 )
      {
        *((_WORD *)v8 + 6) = 0;
      }
      else
      {
        v22 = *(_WORD *)((char *)&v32 + v21);
        v21 = a2 < 0xE ? 18 : 22;
        *((_WORD *)v8 + 6) = v22;
        if ( a6 )
        {
          LOBYTE(v23) = HIBYTE(v22);
          HIBYTE(v23) = v22;
          *((_WORD *)v8 + 6) = v23;
        }
      }
      if ( v7 - 11 > 5 )
      {
        *((_WORD *)v8 + 7) = -1;
        if ( v7 < 0xB )
          v21 += 2;
      }
      else
      {
        v24 = *(_WORD *)((char *)&v32 + v21);
        v21 += 2;
        *((_WORD *)v8 + 7) = v24;
        if ( a6 )
        {
          LOBYTE(v25) = HIBYTE(v24);
          HIBYTE(v25) = v24;
          *((_WORD *)v8 + 7) = v25;
        }
      }
      if ( v7 - 15 > 1 )
        v8[16] = 0;
      else
        v8[16] = *((_BYTE *)&v32 + v21);
      v6 = v27;
      v8 += 32;
      if ( (unsigned int)++v29 >= *(_DWORD *)v31 )
        return v6;
    }
  }
  LODWORD(v6) = a3;
  return v6;
}

//----- (1000BA80) --------------------------------------------------------
int __thiscall AssetFileList::Write(AssetFileList *this, unsigned __int32 a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5)
{
  bool v5; // zf@1
  unsigned int v6; // edi@2
  unsigned int v7; // esi@2
  size_t v8; // eax@2
  char *v9; // ebx@2
  int v10; // edx@6
  int v11; // ecx@6
  signed int v12; // eax@6
  __int16 v13; // dx@10
  unsigned int v14; // edi@14
  signed int v15; // esi@14
  int v16; // kr00_4@14
  int result; // eax@15
  signed int v18; // [sp+Ch] [bp-3Ch]@2
  unsigned __int64 v19; // [sp+10h] [bp-38h]@4
  int v20; // [sp+1Ch] [bp-2Ch]@1
  int v21; // [sp+20h] [bp-28h]@5
  AssetFileList *v22; // [sp+24h] [bp-24h]@1
  int v23; // [sp+28h] [bp-20h]@6
  int v24; // [sp+2Ch] [bp-1Ch]@6
  int v25; // [sp+30h] [bp-18h]@6

  v5 = *(_DWORD *)this == 0;
  v22 = this;
  v20 = 0;
  if ( v5 )
  {
    result = a3;
  }
  else
  {
    v6 = HIDWORD(a3);
    v7 = a3;
    v8 = a2 < 0xE ? 4 : 8;
    v18 = a2 < 0xE ? 4 : 8;
    v9 = (char *)this + 20;
    while ( 1 )
    {
      v19 = __PAIR__(v6, v7);
      if ( a2 >= 0xE )
      {
        v21 = 0;
        ((void (__cdecl *)(unsigned int, unsigned int, int, int, int *, __int32))a4)(
          v7,
          v6,
          3 - (((_BYTE)v7 - 1) & 3),
          -((((_BYTE)v7 - 1) & 3u) > 3),
          &v21,
          a5);
        v8 = a2 < 0xE ? 4 : 8;
        v19 = (__PAIR__(v6, v7) + 3) & 0xFFFFFFFFFFFFFFFCui64;
      }
      memcpy(&v23, v9 - 12, v8);
      v10 = *(_DWORD *)v9;
      *(int *)((char *)&v23 + v18) = *((_DWORD *)v9 - 1);
      v11 = *((_DWORD *)v9 + 1);
      *(int *)((char *)&v24 + v18) = v10;
      *(int *)((char *)&v25 + v18) = v11;
      v12 = a2 < 0xE ? 16 : 20;
      if ( a2 < 0x10 )
      {
        *(_WORD *)((char *)&v23 + v12) = *((_WORD *)v9 + 4);
        v12 = a2 < 0xE ? 18 : 22;
      }
      if ( a2 < 0x11 )
      {
        if ( a2 < 0xB )
          v13 = 0;
        else
          v13 = *((_WORD *)v9 + 5);
        *(_WORD *)((char *)&v23 + v12) = v13;
        v12 += 2;
        if ( a2 >= 0xF )
          *((_BYTE *)&v23 + v12++) = v9[12];
      }
      v14 = (unsigned __int64)v12 >> 32;
      v15 = v12;
      ((void (__cdecl *)(_DWORD, _DWORD, signed int, unsigned int, int *, __int32))a4)(
        v19,
        HIDWORD(v19),
        v12,
        v14,
        &v23,
        a5);
      v16 = v19 + v15;
      v6 = (v19 + __PAIR__(v14, v15)) >> 32;
      v7 = v19 + v15;
      v9 += 32;
      if ( (unsigned int)++v20 >= *(_DWORD *)v22 )
        break;
      v8 = a2 < 0xE ? 4 : 8;
    }
    result = v16;
  }
  return result;
}

//----- (1000BC10) --------------------------------------------------------
int __thiscall AssetsFileHeader::Read(AssetsFileHeader *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4)
{
  AssetsFileHeader *v4; // ebx@1
  unsigned __int64 v5; // kr00_8@1
  unsigned int v6; // eax@2
  unsigned int v7; // ecx@2
  int result; // eax@3

  v4 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, AssetsFileHeader *, __int32))a3)(
    a2,
    HIDWORD(a2),
    4,
    0,
    this,
    a4);
  *(_DWORD *)v4 = *((_BYTE *)v4 + 3)
                + ((*(_DWORD *)v4 >> 8) & 0xFF00)
                + (((*(_DWORD *)v4 & 0xFF00) + (*(_DWORD *)v4 << 16)) << 8);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a3)(
    a2 + 4,
    (a2 + 4) >> 32,
    4,
    0,
    (char *)v4 + 4,
    a4);
  *((_DWORD *)v4 + 1) = *((_BYTE *)v4 + 7)
                      + ((*((_DWORD *)v4 + 1) >> 8) & 0xFF00)
                      + (((*((_DWORD *)v4 + 1) & 0xFF00) + (*((_DWORD *)v4 + 1) << 16)) << 8);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a3)(
    a2 + 8,
    (a2 + 8) >> 32,
    4,
    0,
    (char *)v4 + 8,
    a4);
  *((_DWORD *)v4 + 2) = *((_BYTE *)v4 + 11)
                      + ((*((_DWORD *)v4 + 2) >> 8) & 0xFF00)
                      + (((*((_DWORD *)v4 + 2) & 0xFF00) + (*((_DWORD *)v4 + 2) << 16)) << 8);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a3)(
    a2 + 12,
    (a2 + 12) >> 32,
    4,
    0,
    (char *)v4 + 12,
    a4);
  *((_DWORD *)v4 + 3) = *((_BYTE *)v4 + 15)
                      + ((*((_DWORD *)v4 + 3) >> 8) & 0xFF00)
                      + (((*((_DWORD *)v4 + 3) & 0xFF00) + (*((_DWORD *)v4 + 3) << 16)) << 8);
  v5 = a2 + 16;
  if ( *((_DWORD *)v4 + 2) >= 9u || (v6 = *((_DWORD *)v4 + 1), v7 = *(_DWORD *)v4, v6 <= *(_DWORD *)v4) )
  {
    ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a3)(
      v5,
      HIDWORD(v5),
      1,
      0,
      (char *)v4 + 16,
      a4);
    ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, _DWORD))a3)(
      v5 + 1,
      (v5 + 1) >> 32,
      3,
      0,
      (char *)v4 + 17,
      a4);
    result = v5 + 4;
  }
  else
  {
    *((_WORD *)v4 + 9) = 0;
    *((_BYTE *)v4 + 17) = 0;
    ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a3)(
      a2 + v6 - v7,
      (a2 + v6 - (unsigned __int64)v7) >> 32,
      1,
      0,
      (char *)v4 + 16,
      a4);
    result = v5;
  }
  return result;
}

//----- (1000BDB0) --------------------------------------------------------
unsigned __int64 __thiscall AssetsFileHeader::Write(AssetsFileHeader *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a4)
{
  AssetsFileHeader *v4; // ebx@1
  int v6; // [sp+Ch] [bp-4h]@1

  v4 = this;
  v6 = (*(_DWORD *)this >> 24)
     + ((*(_DWORD *)this >> 8) & 0xFF00)
     + (((*(_DWORD *)this << 16) + (*(_DWORD *)this & 0xFF00)) << 8);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, __int32))a3)(a2, HIDWORD(a2), 4, 0, &v6, a4);
  v6 = (*((_DWORD *)v4 + 1) >> 24)
     + ((*((_DWORD *)v4 + 1) >> 8) & 0xFF00)
     + (((*((_DWORD *)v4 + 1) << 16) + (*((_DWORD *)v4 + 1) & 0xFF00)) << 8);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, __int32))a3)(a2 + 4, (a2 + 4) >> 32, 4, 0, &v6, a4);
  v6 = (*((_DWORD *)v4 + 2) >> 24)
     + ((*((_DWORD *)v4 + 2) >> 8) & 0xFF00)
     + (((*((_DWORD *)v4 + 2) << 16) + (*((_DWORD *)v4 + 2) & 0xFF00)) << 8);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a3)(a2 + 8, (a2 + 8) >> 32, 4, 0, &v6, a4);
  v6 = (*((_DWORD *)v4 + 3) >> 24)
     + ((*((_DWORD *)v4 + 3) >> 8) & 0xFF00)
     + (((*((_DWORD *)v4 + 3) << 16) + (*((_DWORD *)v4 + 3) & 0xFF00)) << 8);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a3)(a2 + 12, (a2 + 12) >> 32, 4, 0, &v6, a4);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a3)(
    a2 + 16,
    (a2 + 16) >> 32,
    1,
    0,
    (char *)v4 + 16,
    a4);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, _DWORD))a3)(
    a2 + 17,
    (a2 + 17) >> 32,
    3,
    0,
    (char *)v4 + 17,
    a4);
  return a2 + 20;
}

//----- (1000BF10) --------------------------------------------------------
signed int AssetsFileHeader::GetSizeBytes()
{
  return 20;
}

//----- (1000BF20) --------------------------------------------------------
int __thiscall TypeField_0D::Read(TypeField_0D *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4, bool a5)
{
  TypeField_0D *v5; // ebx@1
  unsigned __int64 v6; // kr00_8@1
  __int16 v7; // ST54_2@2
  signed __int64 v8; // kr20_8@3
  signed __int64 v9; // kr28_8@5
  signed __int64 v10; // kr30_8@7
  signed __int64 v11; // kr38_8@9
  int v12; // ebx@11

  v5 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, TypeField_0D *, __int32))a3)(a2, HIDWORD(a2), 2, 0, this, a4);
  v6 = a2 + 2;
  if ( a5 )
  {
    LOBYTE(v7) = *(_WORD *)v5 >> 8;
    HIBYTE(v7) = *(_WORD *)v5;
    *(_WORD *)v5 = v7;
  }
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a3)(v6, HIDWORD(v6), 1, 0, (char *)v5 + 2, a4);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a3)(
    v6 + 1,
    (v6 + 1) >> 32,
    1,
    0,
    (char *)v5 + 3,
    a4);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, _DWORD))a3)(
    v6 + 2,
    (v6 + 2) >> 32,
    4,
    0,
    (char *)v5 + 4,
    a4);
  v8 = v6 + 6;
  if ( a5 )
    *((_DWORD *)v5 + 1) = *((_BYTE *)v5 + 7)
                        + ((*((_DWORD *)v5 + 1) >> 8) & 0xFF00)
                        + (((*((_DWORD *)v5 + 1) & 0xFF00) + (*((_DWORD *)v5 + 1) << 16)) << 8);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, _DWORD))a3)(v8, HIDWORD(v8), 4, 0, (char *)v5 + 8, a4);
  v9 = v8 + 4;
  if ( a5 )
    *((_DWORD *)v5 + 2) = *((_BYTE *)v5 + 11)
                        + ((*((_DWORD *)v5 + 2) >> 8) & 0xFF00)
                        + (((*((_DWORD *)v5 + 2) & 0xFF00) + (*((_DWORD *)v5 + 2) << 16)) << 8);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a3)(v9, HIDWORD(v9), 4, 0, (char *)v5 + 12, a4);
  v10 = v9 + 4;
  if ( a5 )
    *((_DWORD *)v5 + 3) = *((_BYTE *)v5 + 15)
                        + ((*((_DWORD *)v5 + 3) >> 8) & 0xFF00)
                        + (((*((_DWORD *)v5 + 3) & 0xFF00) + (*((_DWORD *)v5 + 3) << 16)) << 8);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a3)(v10, HIDWORD(v10), 4, 0, (char *)v5 + 16, a4);
  v11 = v10 + 4;
  if ( a5 )
    *((_DWORD *)v5 + 4) = *((_BYTE *)v5 + 19)
                        + ((*((_DWORD *)v5 + 4) >> 8) & 0xFF00)
                        + (((*((_DWORD *)v5 + 4) & 0xFF00) + (*((_DWORD *)v5 + 4) << 16)) << 8);
  v12 = (int)v5 + 20;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int, __int32))a3)(v11, HIDWORD(v11), 4, 0, v12, a4);
  if ( a5 )
    *(_DWORD *)v12 = *(_BYTE *)(v12 + 3)
                   + ((*(_DWORD *)v12 >> 8) & 0xFF00)
                   + (((*(_DWORD *)v12 & 0xFF00) + (*(_DWORD *)v12 << 16)) << 8);
  return v11 + 4;
}

//----- (1000C110) --------------------------------------------------------
unsigned __int64 __thiscall TypeField_0D::Write(TypeField_0D *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a4)
{
  TypeField_0D *v4; // ebx@1

  v4 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, TypeField_0D *, __int32))a3)(a2, HIDWORD(a2), 2, 0, this, a4);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a3)(
    a2 + 2,
    (a2 + 2) >> 32,
    1,
    0,
    (char *)v4 + 2,
    a4);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a3)(
    a2 + 3,
    (a2 + 3) >> 32,
    1,
    0,
    (char *)v4 + 3,
    a4);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, _DWORD))a3)(
    a2 + 4,
    (a2 + 4) >> 32,
    4,
    0,
    (char *)v4 + 4,
    a4);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, _DWORD))a3)(
    a2 + 8,
    (a2 + 8) >> 32,
    4,
    0,
    (char *)v4 + 8,
    a4);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a3)(
    a2 + 12,
    (a2 + 12) >> 32,
    4,
    0,
    (char *)v4 + 12,
    a4);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a3)(
    a2 + 16,
    (a2 + 16) >> 32,
    4,
    0,
    (char *)v4 + 16,
    a4);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a3)(
    a2 + 20,
    (a2 + 20) >> 32,
    4,
    0,
    (char *)v4 + 20,
    a4);
  return a2 + 24;
}

//----- (1000C1F0) --------------------------------------------------------
char *__thiscall TypeField_0D::GetTypeString(TypeField_0D *this, const char *a2, unsigned int a3)
{
  unsigned int v3; // ecx@1
  char *result; // eax@1
  unsigned int v5; // ecx@2

  v3 = *((_DWORD *)this + 1);
  result = 0;
  if ( (v3 & 0x80000000) == 0 )
  {
    if ( v3 < a3 - 1 )
      result = (char *)&a2[v3];
  }
  else
  {
    v5 = v3 & 0x7FFFFFFF;
    if ( v5 < 0x411 )
      result = &aAabb[v5];
  }
  return result;
}

//----- (1000C230) --------------------------------------------------------
char *__thiscall TypeField_0D::GetNameString(TypeField_0D *this, const char *a2, unsigned int a3)
{
  unsigned int v3; // ecx@1
  char *result; // eax@1
  unsigned int v5; // ecx@2

  v3 = *((_DWORD *)this + 2);
  result = 0;
  if ( (v3 & 0x80000000) == 0 )
  {
    if ( v3 < a3 - 1 )
      result = (char *)&a2[v3];
  }
  else
  {
    v5 = v3 & 0x7FFFFFFF;
    if ( v5 < 0x411 )
      result = &aAabb[v5];
  }
  return result;
}

//----- (1000C270) --------------------------------------------------------
int __thiscall Type_0D::Write(Type_0D *this, bool a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5, unsigned __int32 a6)
{
  Type_0D *v6; // ebx@1
  unsigned int v7; // edi@1
  unsigned int v8; // esi@1
  unsigned __int64 v9; // kr08_8@2
  unsigned int v10; // edi@7
  unsigned int v11; // edi@7
  unsigned __int64 v12; // kr20_8@7
  unsigned int v13; // edi@7
  unsigned __int64 v14; // kr28_8@7
  unsigned __int64 v15; // kr30_8@7
  unsigned __int64 v16; // kr50_8@8
  unsigned int v17; // edi@9
  unsigned int v18; // esi@9
  unsigned __int64 v19; // rax@11
  int result; // eax@12
  int v21; // [sp+Ch] [bp-Ch]@10
  unsigned int v22; // [sp+10h] [bp-8h]@9
  Type_0D *v23; // [sp+14h] [bp-4h]@9

  v6 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, Type_0D *, __int32))a4)(a3, HIDWORD(a3), 4, 0, this, a5);
  v7 = (a3 + 4) >> 32;
  v8 = a3 + 4;
  if ( a6 >= 0x10 )
  {
    ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a4)(
      v8,
      v7,
      1,
      0,
      (char *)v6 + 4,
      a5);
    v9 = __PAIR__(v7, v8) + 1;
    if ( a6 >= 0x11 )
      ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a4)(
        v9,
        HIDWORD(v9),
        2,
        0,
        (char *)v6 + 6,
        a5);
    v7 = (__PAIR__(v7, v8) + 3) >> 32;
    v8 = v9 + 2;
  }
  if ( *(_DWORD *)v6 < 0 || *(_DWORD *)v6 == 114 )
  {
    ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a4)(
      v8,
      v7,
      4,
      0,
      (char *)v6 + 8,
      a5);
    v10 = (__PAIR__(v7, v8) + 4) >> 32;
    ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a4)(
      v8 + 4,
      v10,
      4,
      0,
      (char *)v6 + 12,
      a5);
    v12 = __PAIR__(v10, v8 + 4) + 4;
    v11 = (__PAIR__(v10, v8 + 4) + 4) >> 32;
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v12, v11, 4, 0, (char *)v6 + 16, a5);
    v14 = __PAIR__(v11, (unsigned int)v12) + 4;
    v13 = (__PAIR__(v11, (unsigned int)v12) + 4) >> 32;
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v14, v13, 4, 0, (char *)v6 + 20, a5);
    v15 = __PAIR__(v13, (unsigned int)v14) + 4;
    v7 = (__PAIR__(v13, (unsigned int)v14) + 4) >> 32;
    v8 = v15;
  }
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v8, v7, 4, 0, (char *)v6 + 24, a5);
  ((void (__cdecl *)(unsigned int, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(
    v8 + 4,
    (__PAIR__(v7, v8) + 4) >> 32,
    4,
    0,
    (char *)v6 + 28,
    a5);
  ((void (__cdecl *)(unsigned int, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(
    v8 + 8,
    (__PAIR__(v7, v8) + 8) >> 32,
    4,
    0,
    (char *)v6 + 32,
    a5);
  ((void (__cdecl *)(unsigned int, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(
    v8 + 12,
    (__PAIR__(v7, v8) + 12) >> 32,
    4,
    0,
    (char *)v6 + 36,
    a5);
  v16 = __PAIR__(v7, v8) + 16;
  if ( a2 )
  {
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v16, HIDWORD(v16), 4, 0, (char *)v6 + 40, a5);
    v23 = (Type_0D *)((char *)v6 + 48);
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(
      v16 + 4,
      (v16 + 4) >> 32,
      4,
      0,
      (char *)v6 + 48,
      a5);
    v17 = (v16 + 8) >> 32;
    v18 = v16 + 8;
    v22 = 0;
    if ( *((_DWORD *)v6 + 10) )
    {
      v21 = 0;
      do
      {
        v19 = TypeField_0D::Write((TypeField_0D *)(v21 + *((_DWORD *)v6 + 11)), __PAIR__(v17, v18), a4, a5);
        v21 += 24;
        v17 = HIDWORD(v19);
        v18 = v19;
        ++v22;
      }
      while ( v22 < *((_DWORD *)v6 + 10) );
    }
    ((void (__cdecl *)(unsigned int, unsigned int, _DWORD, _DWORD, _DWORD, __int32))a4)(
      v18,
      v17,
      *(_DWORD *)v23,
      0,
      *((_DWORD *)v6 + 13),
      a5);
    result = v18 + *(_DWORD *)v23;
  }
  else
  {
    result = v16;
  }
  return result;
}

//----- (1000C460) --------------------------------------------------------
unsigned int __thiscall Type_0D::Read(Type_0D *this, bool a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a5, unsigned __int32 a6, unsigned __int32 a7, bool a8)
{
  Type_0D *v8; // ebx@1
  unsigned int v9; // edi@2
  unsigned int v10; // esi@2
  __int16 v11; // kr20_2@9
  unsigned int v12; // edi@13
  unsigned int v13; // edi@13
  unsigned __int64 v14; // kr30_8@13
  unsigned int v15; // edi@13
  unsigned __int64 v16; // kr38_8@13
  unsigned __int64 v17; // kr40_8@13
  unsigned int v18; // edi@14
  unsigned int v19; // edi@14
  unsigned __int64 v20; // kr50_8@14
  unsigned int v21; // edi@14
  unsigned __int64 v22; // kr58_8@14
  unsigned int v23; // edi@14
  unsigned int v24; // esi@14
  unsigned __int64 v25; // kr60_8@14
  unsigned __int64 v26; // kr68_8@15
  signed __int64 v27; // kr70_8@17
  size_t v28; // eax@18
  void *v29; // eax@20
  unsigned int result; // eax@21
  void *v31; // eax@22
  int v32; // ecx@23
  void *v33; // edx@23
  TypeField_0D *v34; // ecx@23
  unsigned __int64 v35; // rax@24
  char *v36; // eax@28
  void *v37; // eax@28
  unsigned int v38; // edx@31
  TypeField_0D *v39; // [sp+Ch] [bp-24Ch]@25
  size_t v40; // [sp+10h] [bp-248h]@3
  int v41; // [sp+14h] [bp-244h]@9
  unsigned int v42; // [sp+18h] [bp-240h]@3
  unsigned int v43; // [sp+1Ch] [bp-23Ch]@15
  void *v44; // [sp+20h] [bp-238h]@20
  void *v45; // [sp+24h] [bp-234h]@22
  TypeField_0D *v46; // [sp+28h] [bp-230h]@23
  unsigned int v47; // [sp+2Ch] [bp-22Ch]@20
  char v48; // [sp+30h] [bp-228h]@35

  v8 = this;
  if ( a6 < 0xD )
  {
    memset((void *)this, 0, 0x38u);
    memset(&v48, 0, 0x220u);
    result = Type_07::Read((Type_07 *)&v48, a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
    ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, Type_0D *, __int32))a4)(a3, HIDWORD(a3), 4, 0, this, a5);
    v9 = (a3 + 4) >> 32;
    v10 = a3 + 4;
    if ( a8 )
    {
      v42 = *(_DWORD *)v8;
      BYTE2(v40) = BYTE1(v42);
      BYTE3(v40) = v42;
      LOBYTE(v40) = BYTE3(v42);
      BYTE1(v40) = BYTE2(v42);
      *(_DWORD *)v8 = v40;
    }
    if ( a6 < 0x10 )
    {
      *((_BYTE *)v8 + 4) = 0;
    }
    else
    {
      ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a4)(
        v10,
        v9,
        1,
        0,
        (char *)v8 + 4,
        a5);
      v9 = (__PAIR__(v9, v10) + 1) >> 32;
      v10 = a3 + 5;
    }
    if ( a6 < 0x11 )
    {
      *((_WORD *)v8 + 3) = -1;
    }
    else
    {
      ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a4)(
        v10,
        v9,
        2,
        0,
        (char *)v8 + 6,
        a5);
      v9 = (__PAIR__(v9, v10) + 2) >> 32;
      v10 += 2;
      if ( a8 )
      {
        v11 = *((_WORD *)v8 + 3);
        LOBYTE(v41) = *((_WORD *)v8 + 3) >> 8;
        BYTE1(v41) = v11;
        *((_WORD *)v8 + 3) = v41;
      }
    }
    if ( *(_DWORD *)v8 < 0 || *(_DWORD *)v8 == 114 )
    {
      ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a4)(
        v10,
        v9,
        4,
        0,
        (char *)v8 + 8,
        a5);
      v12 = (__PAIR__(v9, v10) + 4) >> 32;
      ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a4)(
        v10 + 4,
        v12,
        4,
        0,
        (char *)v8 + 12,
        a5);
      v14 = __PAIR__(v12, v10 + 4) + 4;
      v13 = (__PAIR__(v12, v10 + 4) + 4) >> 32;
      ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v14, v13, 4, 0, (char *)v8 + 16, a5);
      v16 = __PAIR__(v13, (unsigned int)v14) + 4;
      v15 = (__PAIR__(v13, (unsigned int)v14) + 4) >> 32;
      ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v16, v15, 4, 0, (char *)v8 + 20, a5);
      v17 = __PAIR__(v15, (unsigned int)v16) + 4;
      v9 = (__PAIR__(v15, (unsigned int)v16) + 4) >> 32;
      v10 = v17;
    }
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v10, v9, 4, 0, (char *)v8 + 24, a5);
    v18 = (__PAIR__(v9, v10) + 4) >> 32;
    ((void (__cdecl *)(unsigned int, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(
      v10 + 4,
      v18,
      4,
      0,
      (char *)v8 + 28,
      a5);
    v20 = __PAIR__(v18, v10 + 4) + 4;
    v19 = (__PAIR__(v18, v10 + 4) + 4) >> 32;
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v20, v19, 4, 0, (char *)v8 + 32, a5);
    v22 = __PAIR__(v19, (unsigned int)v20) + 4;
    v21 = (__PAIR__(v19, (unsigned int)v20) + 4) >> 32;
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v22, v21, 4, 0, (char *)v8 + 36, a5);
    v25 = __PAIR__(v21, (unsigned int)v22) + 4;
    v23 = (__PAIR__(v21, (unsigned int)v22) + 4) >> 32;
    v24 = v25;
    *((_DWORD *)v8 + 10) = 0;
    *((_DWORD *)v8 + 11) = 0;
    *((_DWORD *)v8 + 12) = 0;
    *((_DWORD *)v8 + 13) = 0;
    if ( a2 )
    {
      ((void (__cdecl *)(_DWORD, unsigned int, signed int, _DWORD, unsigned int *, __int32))a4)(
        v25,
        v23,
        4,
        0,
        &v43,
        a5);
      v26 = __PAIR__(v23, (unsigned int)v25) + 4;
      if ( a8 )
        v43 = (v43 >> 24) + ((v43 >> 8) & 0xFF00) + (((v43 << 16) + (v43 & 0xFF00)) << 8);
      ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, size_t *, __int32))a4)(v26, HIDWORD(v26), 4, 0, &v40, a5);
      v27 = v26 + 4;
      if ( a8 )
      {
        v28 = (v40 >> 24) + ((v40 >> 8) & 0xFF00) + (((v40 << 16) + (v40 & 0xFF00)) << 8);
        v40 = (v40 >> 24) + ((v40 >> 8) & 0xFF00) + (((v40 << 16) + (v40 & 0xFF00)) << 8);
      }
      else
      {
        v28 = v40;
      }
      v41 = 24 * v43 + v28;
      v47 = 24 * v43;
      v29 = malloc(v41 + 1);
      v44 = v29;
      if ( !v29 )
        return v41 + v27;
      ((void (__cdecl *)(_DWORD, _DWORD, int, _DWORD, void *, __int32))a4)(v27, HIDWORD(v27), v41, 0, v29, a5);
      v24 = v41 + v27;
      v31 = malloc(0xCu);
      v45 = v31;
      if ( v31 )
      {
        v32 = v41;
        v33 = v44;
        *(_DWORD *)v31 = 0;
        *((_DWORD *)v31 + 1) = v32;
        *((_DWORD *)v31 + 2) = v33;
        v34 = (TypeField_0D *)malloc(24 * v43);
        v46 = v34;
        if ( v34 )
        {
          v35 = 0i64;
          v42 = 0;
          if ( v43 )
          {
            v39 = v34;
            do
            {
              LODWORD(v35) = TypeField_0D::Read(
                               v39,
                               v35,
                               (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32))AssetsReaderFromMemory,
                               (__int32)v45,
                               a8);
              ++v42;
              v39 = (TypeField_0D *)((char *)v39 + 24);
            }
            while ( v42 < v43 );
            v34 = v46;
          }
          v36 = (char *)v44;
          *((_DWORD *)v8 + 10) = v43;
          *((_DWORD *)v8 + 11) = v34;
          LOBYTE(v41) = v36[v41 - 1] != 0;
          v37 = malloc(v40 + ((_BYTE)v41 != 0));
          v42 = (unsigned int)v37;
          if ( v37 )
          {
            memcpy(v37, (char *)v44 + v47, v40);
            if ( (_BYTE)v41 )
              *(_BYTE *)(v42 + v40) = 0;
            v38 = v42;
            *((_DWORD *)v8 + 12) = v40;
            *((_DWORD *)v8 + 13) = v38;
          }
        }
        free(v45);
      }
      free(v44);
    }
    result = v24;
  }
  return result;
}

//----- (1000C8E0) --------------------------------------------------------
unsigned int __thiscall TypeField_07::Read(TypeField_07 *this, bool a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a5, unsigned __int32 a6, unsigned __int32 a7, bool a8)
{
  TypeField_07 *v8; // ebx@1
  TypeField_07 *v9; // eax@1
  char v10; // cl@2
  unsigned int v11; // edi@3
  unsigned int v12; // esi@3
  char *v13; // eax@3
  char v14; // dl@4
  unsigned int v15; // edi@5
  int v16; // kr08_4@5
  unsigned int v17; // edi@5
  unsigned int v18; // esi@5
  unsigned __int64 v19; // kr10_8@5
  unsigned __int64 v20; // kr28_8@11
  unsigned int v21; // edi@13
  unsigned int v22; // esi@13
  unsigned int v23; // edi@22
  TypeField_07 *v24; // eax@23
  void *v25; // eax@25
  unsigned int i; // ebx@26
  unsigned __int64 v27; // kr48_8@27
  unsigned __int64 v28; // rax@31
  unsigned int v30; // [sp+10h] [bp-238h]@29
  int v31; // [sp+14h] [bp-234h]@30
  TypeField_07 *v32; // [sp+18h] [bp-230h]@22
  char v33; // [sp+20h] [bp-228h]@27

  v8 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, TypeField_07 *, __int32))a4)(a3, HIDWORD(a3), 256, 0, this, a5);
  v9 = v8;
  *((_BYTE *)v8 + 255) = 0;
  do
  {
    v10 = *(_BYTE *)v9;
    v9 = (TypeField_07 *)((char *)v9 + 1);
  }
  while ( v10 );
  v11 = (a3 + (unsigned int)(v9 - (TypeField_07 *)((char *)v8 + 1) + 1)) >> 32;
  v12 = a3 + v9 - (TypeField_07 *)((char *)v8 + 1) + 1;
  ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a4)(
    v12,
    v11,
    256,
    0,
    (char *)v8 + 256,
    a5);
  v13 = (char *)v8 + 256;
  *((_BYTE *)v8 + 511) = 0;
  do
    v14 = *v13++;
  while ( v14 );
  v16 = v13 - ((char *)v8 + 257) + 1 + v12;
  v15 = (__PAIR__(v11, v13 - ((char *)v8 + 257) + 1) + v12) >> 32;
  ((void (__cdecl *)(int, unsigned int, signed int, _DWORD, char *, __int32))a4)(v16, v15, 4, 0, (char *)v8 + 512, a5);
  v19 = __PAIR__(v15, v16) + 4;
  v17 = (__PAIR__(v15, v16) + 4) >> 32;
  v18 = v19;
  if ( a8 )
    *((_DWORD *)v8 + 128) = *((_BYTE *)v8 + 515)
                          + ((*((_DWORD *)v8 + 128) >> 8) & 0xFF00)
                          + (((*((_DWORD *)v8 + 128) & 0xFF00) + (*((_DWORD *)v8 + 128) << 16)) << 8);
  if ( a7 == 2 )
  {
    v17 = (__PAIR__(v17, (unsigned int)v19) + 4) >> 32;
    v18 = v19 + 4;
  }
  else if ( a7 == 3 )
  {
    *((_DWORD *)v8 + 129) = -1;
    goto LABEL_11;
  }
  ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a4)(
    v18,
    v17,
    4,
    0,
    (char *)v8 + 516,
    a5);
  v17 = (__PAIR__(v17, v18) + 4) >> 32;
  v18 += 4;
  if ( a8 )
    *((_DWORD *)v8 + 129) = *((_BYTE *)v8 + 519)
                          + ((*((_DWORD *)v8 + 129) >> 8) & 0xFF00)
                          + (((*((_DWORD *)v8 + 129) & 0xFF00) + (*((_DWORD *)v8 + 129) << 16)) << 8);
LABEL_11:
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v18, v17, 4, 0, (char *)v8 + 520, a5);
  v20 = __PAIR__(v17, v18) + 4;
  if ( a8 )
    *((_DWORD *)v8 + 130) = *((_BYTE *)v8 + 523)
                          + ((*((_DWORD *)v8 + 130) >> 8) & 0xFF00)
                          + (((*((_DWORD *)v8 + 130) & 0xFF00) + (*((_DWORD *)v8 + 130) << 16)) << 8);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v20, HIDWORD(v20), 4, 0, (char *)v8 + 524, a5);
  v21 = (v20 + 4) >> 32;
  v22 = v20 + 4;
  if ( a8 )
    *((_DWORD *)v8 + 131) = *((_BYTE *)v8 + 527)
                          + ((*((_DWORD *)v8 + 131) >> 8) & 0xFF00)
                          + (((*((_DWORD *)v8 + 131) & 0xFF00) + (*((_DWORD *)v8 + 131) << 16)) << 8);
  if ( a7 == 3 )
  {
    *((_DWORD *)v8 + 132) = -1;
  }
  else
  {
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v22, v21, 4, 0, (char *)v8 + 528, a5);
    v21 = (__PAIR__(v21, v22) + 4) >> 32;
    v22 = v20 + 8;
    if ( a8 )
      *((_DWORD *)v8 + 132) = *((_BYTE *)v8 + 531)
                            + ((*((_DWORD *)v8 + 132) >> 8) & 0xFF00)
                            + (((*((_DWORD *)v8 + 132) & 0xFF00) + (*((_DWORD *)v8 + 132) << 16)) << 8);
  }
  if ( a2 )
  {
    v32 = (TypeField_07 *)((char *)v8 + 532);
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v22, v21, 4, 0, (char *)v8 + 532, a5);
    v23 = (__PAIR__(v21, v22) + 4) >> 32;
    v22 += 4;
    if ( a8 )
    {
      v24 = (TypeField_07 *)((char *)v8 + 532);
      *((_DWORD *)v8 + 133) = *((_BYTE *)v8 + 535)
                            + ((*((_DWORD *)v8 + 133) >> 8) & 0xFF00)
                            + (((*((_DWORD *)v8 + 133) & 0xFF00) + (*((_DWORD *)v8 + 133) << 16)) << 8);
    }
    else
    {
      v24 = (TypeField_07 *)((char *)v8 + 532);
    }
    v25 = malloc(540 * *(_DWORD *)v24);
    *((_DWORD *)v8 + 134) = v25;
    if ( v25 )
    {
      v30 = 0;
      if ( *(_DWORD *)v32 > 0u )
      {
        v31 = 0;
        do
        {
          v28 = TypeField_07::Read(
                  (TypeField_07 *)(v31 + *((_DWORD *)v8 + 134)),
                  a2,
                  __PAIR__(v23, v22),
                  a4,
                  a5,
                  a6,
                  a7,
                  a8);
          v31 += 540;
          v23 = HIDWORD(v28);
          v22 = v28;
          ++v30;
        }
        while ( v30 < *(_DWORD *)v32 );
      }
    }
    else
    {
      for ( i = 0; i < *(_DWORD *)v32; v22 = v27 )
      {
        memset(&v33, 0, 0x21Cu);
        ++i;
        v27 = TypeField_07::Read((TypeField_07 *)&v33, a2, __PAIR__(v23, v22), a4, a5, a6, a7, a8);
        v23 = HIDWORD(v27);
      }
      *(_DWORD *)v32 = 0;
    }
  }
  return v22;
}

//----- (1000CCE0) --------------------------------------------------------
unsigned int __thiscall TypeField_07::Write(TypeField_07 *this, bool a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5)
{
  TypeField_07 *v5; // ebx@1
  unsigned int v6; // kr04_4@1
  unsigned int v7; // edi@1
  unsigned int v8; // esi@1
  char *v9; // eax@1
  char v10; // dl@2
  char *v11; // eax@3
  char v12; // dl@4
  unsigned int v13; // edi@5
  int v14; // kr10_4@5
  unsigned int v15; // edi@5
  unsigned __int64 v16; // kr18_8@5
  unsigned int v17; // edi@5
  unsigned __int64 v18; // kr20_8@5
  unsigned int v19; // edi@5
  unsigned __int64 v20; // kr28_8@5
  unsigned int v21; // edi@5
  unsigned __int64 v22; // kr30_8@5
  unsigned int v23; // edi@5
  unsigned int v24; // esi@5
  unsigned __int64 v25; // kr38_8@5
  unsigned int v26; // edi@6
  unsigned __int64 v27; // rax@8
  unsigned int v29; // [sp+10h] [bp-4h]@6
  int v30; // [sp+24h] [bp+10h]@7

  v5 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, unsigned int, _DWORD, TypeField_07 *, __int32))a4)(
    a3,
    HIDWORD(a3),
    strlen((const char *)this) + 1,
    0,
    this,
    a5);
  v6 = strlen((const char *)v5);
  v9 = (char *)v5 + 256;
  v7 = (a3 + v6 + 1) >> 32;
  v8 = a3 + v6 + 1;
  do
    v10 = *v9++;
  while ( v10 );
  ((void (__cdecl *)(unsigned int, unsigned int, int, _DWORD, char *, __int32))a4)(
    v8,
    v7,
    v9 - ((char *)v5 + 257) + 1,
    0,
    (char *)v5 + 256,
    a5);
  v11 = (char *)v5 + 256;
  do
    v12 = *v11++;
  while ( v12 );
  v14 = v11 - ((char *)v5 + 257) + 1 + v8;
  v13 = (__PAIR__(v7, v11 - ((char *)v5 + 257) + 1) + v8) >> 32;
  ((void (__cdecl *)(int, unsigned int, signed int, _DWORD, char *, __int32))a4)(v14, v13, 4, 0, (char *)v5 + 512, a5);
  v16 = __PAIR__(v13, v14) + 4;
  v15 = (__PAIR__(v13, v14) + 4) >> 32;
  ((void (__cdecl *)(_DWORD, unsigned int, signed int, _DWORD, char *, __int32))a4)(
    v16,
    v15,
    4,
    0,
    (char *)v5 + 516,
    a5);
  v18 = __PAIR__(v15, (unsigned int)v16) + 4;
  v17 = (__PAIR__(v15, (unsigned int)v16) + 4) >> 32;
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v18, v17, 4, 0, (char *)v5 + 520, a5);
  v20 = __PAIR__(v17, (unsigned int)v18) + 4;
  v19 = (__PAIR__(v17, (unsigned int)v18) + 4) >> 32;
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v20, v19, 4, 0, (char *)v5 + 524, a5);
  v22 = __PAIR__(v19, (unsigned int)v20) + 4;
  v21 = (__PAIR__(v19, (unsigned int)v20) + 4) >> 32;
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v22, v21, 4, 0, (char *)v5 + 528, a5);
  v25 = __PAIR__(v21, (unsigned int)v22) + 4;
  v23 = (__PAIR__(v21, (unsigned int)v22) + 4) >> 32;
  v24 = v25;
  if ( a2 )
  {
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a4)(v25, v23, 4, 0, (char *)v5 + 532, a5);
    v26 = (__PAIR__(v23, (unsigned int)v25) + 4) >> 32;
    v24 = v25 + 4;
    v29 = 0;
    if ( *((_DWORD *)v5 + 133) )
    {
      v30 = 0;
      do
      {
        v27 = TypeField_07::Write((TypeField_07 *)(v30 + *((_DWORD *)v5 + 134)), a2, __PAIR__(v26, v24), a4, a5);
        v30 += 540;
        v26 = HIDWORD(v27);
        v24 = v27;
        ++v29;
      }
      while ( v29 < *((_DWORD *)v5 + 133) );
    }
  }
  return v24;
}

//----- (1000CE70) --------------------------------------------------------
unsigned int __thiscall Type_07::Write(Type_07 *this, bool a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a5)
{
  Type_07 *v5; // ebx@1

  v5 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a4)(a3, HIDWORD(a3), 4, 0, this, a5);
  return TypeField_07::Write((Type_07 *)((char *)v5 + 4), a2, a3 + 4, a4, a5);
}

//----- (1000CEC0) --------------------------------------------------------
unsigned int __thiscall Type_07::Read(Type_07 *this, bool a2, unsigned __int64 a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a5, unsigned __int32 a6, unsigned __int32 a7, bool a8)
{
  Type_07 *v8; // ebx@1
  unsigned int result; // eax@2
  int v10; // kr00_4@4
  int v11; // ST30_4@4
  char v12; // [sp+18h] [bp-38h]@2

  v8 = this;
  if ( a6 < 0xD )
  {
    ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, Type_07 *, __int32))a4)(a3, HIDWORD(a3), 4, 0, this, a5);
    if ( a8 )
    {
      v10 = *(_DWORD *)v8;
      BYTE2(v11) = BYTE1(v10);
      BYTE3(v11) = *(_DWORD *)v8;
      LOBYTE(v11) = *(_DWORD *)v8 >> 24;
      BYTE1(v11) = *(_DWORD *)v8 >> 16;
      *(_DWORD *)v8 = v11;
    }
    result = TypeField_07::Read((Type_07 *)((char *)v8 + 4), a2, a3 + 4, a4, a5, a6, a7, a8);
  }
  else
  {
    memset((void *)this, 0, 0x220u);
    memset(&v12, 0, 0x38u);
    result = Type_0D::Read((Type_0D *)&v12, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

//----- (1000CFA0) --------------------------------------------------------
unsigned int __thiscall TypeTree::Write(TypeTree *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a4, unsigned __int32 a5)
{
  TypeTree *v5; // ebx@1
  unsigned int v6; // eax@1
  unsigned int v7; // edi@1
  unsigned int v8; // esi@1
  unsigned int v9; // edi@1
  unsigned int v10; // esi@1
  unsigned __int64 v11; // kr10_8@1
  unsigned int v12; // eax@3
  unsigned int v13; // edi@3
  unsigned int v14; // esi@3
  bool v15; // ST30_1@8
  int v16; // ST34_4@8
  unsigned int v17; // edx@8
  int v18; // eax@13
  unsigned int v19; // edx@13
  int v21; // [sp+10h] [bp-10h]@7
  int v22; // [sp+10h] [bp-10h]@12
  unsigned int v23; // [sp+14h] [bp-Ch]@6
  unsigned int v24; // [sp+14h] [bp-Ch]@11

  v5 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, unsigned int, _DWORD, TypeTree *, __int32))a3)(
    a2,
    HIDWORD(a2),
    strlen((const char *)this) + 1,
    0,
    this,
    a4);
  v6 = strlen((const char *)v5);
  v7 = (a2 + v6 + 1) >> 32;
  v8 = a2 + v6 + 1;
  ((void (__cdecl *)(_DWORD, unsigned int, signed int, _DWORD, char *, __int32))a3)(
    a2 + v6 + 1,
    v7,
    4,
    0,
    (char *)v5 + 28,
    a4);
  v11 = __PAIR__(v7, v8) + 4;
  v9 = (__PAIR__(v7, v8) + 4) >> 32;
  v10 = v11;
  if ( a5 >= 0xD )
  {
    ((void (__cdecl *)(_DWORD, unsigned int, signed int, _DWORD, char *, __int32))a3)(
      v11,
      v9,
      1,
      0,
      (char *)v5 + 32,
      a4);
    v9 = (__PAIR__(v9, (unsigned int)v11) + 1) >> 32;
    v10 = v11 + 1;
  }
  ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a3)(
    v10,
    v9,
    4,
    0,
    (char *)v5 + 36,
    a4);
  v12 = *((_DWORD *)v5 + 9);
  v13 = (__PAIR__(v9, v10) + 4) >> 32;
  v14 = v10 + 4;
  if ( v12 )
  {
    if ( a5 >= 0xD )
    {
      if ( *((_DWORD *)v5 + 10) )
      {
        v24 = 0;
        if ( v12 > 0 )
        {
          v22 = 0;
          do
          {
            v18 = Type_0D::Write(
                    (Type_0D *)(v22 + *((_DWORD *)v5 + 10)),
                    *((_BYTE *)v5 + 32),
                    __PAIR__(v13, v14),
                    a3,
                    a4,
                    a5);
            v22 += 56;
            v14 = v18;
            v13 = v19;
            ++v24;
          }
          while ( v24 < *((_DWORD *)v5 + 9) );
        }
      }
    }
    else if ( *((_DWORD *)v5 + 10) )
    {
      v23 = 0;
      if ( v12 > 0 )
      {
        v21 = 0;
        do
        {
          v15 = *((_BYTE *)v5 + 32);
          v16 = v21 + *((_DWORD *)v5 + 10);
          ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, int, __int32))a3)(v14, v13, 4, 0, v16, a4);
          v21 += 544;
          v14 = TypeField_07::Write((TypeField_07 *)(v16 + 4), v15, __PAIR__(v13, v14) + 4, a3, a4);
          v13 = v17;
          ++v23;
        }
        while ( v23 < *((_DWORD *)v5 + 9) );
      }
    }
  }
  else
  {
    *((_DWORD *)v5 + 10) = 0;
  }
  if ( a5 < 0xE )
  {
    ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a3)(
      v14,
      v13,
      4,
      0,
      (char *)v5 + 44,
      a4);
    v14 += 4;
  }
  return v14;
}

//----- (1000D150) --------------------------------------------------------
int __thiscall TypeTree::Read(TypeTree *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4, unsigned __int32 a5, bool a6)
{
  TypeTree *v6; // ebx@1
  unsigned __int64 v7; // kr08_8@2
  unsigned int v8; // edi@4
  unsigned int v9; // esi@4
  int v10; // ebx@8
  unsigned int v11; // edi@8
  unsigned int v12; // esi@8
  int v13; // eax@10
  void *v14; // eax@12
  unsigned int v15; // edx@14
  unsigned int v16; // eax@18
  unsigned int v17; // edx@18
  void *v18; // eax@20
  unsigned int v19; // edx@22
  unsigned int v20; // eax@26
  unsigned int v21; // edx@26
  int result; // eax@32
  unsigned int i; // [sp+10h] [bp-270h]@13
  int v24; // [sp+10h] [bp-270h]@17
  int v25; // [sp+10h] [bp-270h]@25
  TypeTree *v26; // [sp+14h] [bp-26Ch]@1
  unsigned int v27; // [sp+18h] [bp-268h]@16
  unsigned int v28; // [sp+18h] [bp-268h]@20
  char v29; // [sp+20h] [bp-260h]@22
  char v30; // [sp+58h] [bp-228h]@14

  v6 = this;
  v26 = this;
  *((_DWORD *)this + 12) = a5;
  *((_BYTE *)this + 32) = 1;
  if ( a5 <= 6 )
  {
    *((_DWORD *)this + 7) = 0;
    if ( a5 == 6 )
    {
      *(_DWORD *)this = 1970499157;
      *((_DWORD *)this + 1) = 1919905904;
      *((_DWORD *)this + 2) = 543450484;
      *((_DWORD *)this + 3) = 724971058;
      *((_BYTE *)this + 16) = 0;
    }
    else if ( a5 == 5 )
    {
      *(_DWORD *)this = 1970499157;
      *((_DWORD *)this + 1) = 1919905904;
      *((_DWORD *)this + 2) = 543450484;
      *((_DWORD *)this + 3) = 724577842;
      *((_BYTE *)this + 16) = 0;
    }
    else
    {
      *(_DWORD *)this = 1970499157;
      *((_DWORD *)this + 1) = 1919905904;
      *((_DWORD *)this + 2) = 543450484;
      *((_DWORD *)this + 3) = 1852534357;
      *((_DWORD *)this + 4) = 7239535;
    }
    result = a2;
    *((_DWORD *)this + 9) = 0;
  }
  else
  {
    ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, TypeTree *, __int32))a3)(a2, HIDWORD(a2), 25, 0, this, a4);
    *((_BYTE *)v6 + 24) = 0;
    v7 = a2 + strlen((const char *)v6) + 1;
    if ( *(_BYTE *)v6 < 48 || *(_BYTE *)v6 > 57 )
    {
      *((_DWORD *)v6 + 9) = 0;
      result = v7;
    }
    else
    {
      ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a3)(
        v7,
        HIDWORD(v7),
        4,
        0,
        (char *)v6 + 28,
        a4);
      v8 = (v7 + 4) >> 32;
      v9 = v7 + 4;
      if ( a6 )
        *((_DWORD *)v6 + 7) = *((_BYTE *)v6 + 31)
                            + ((*((_DWORD *)v6 + 7) >> 8) & 0xFF00)
                            + (((*((_DWORD *)v6 + 7) & 0xFF00) + (*((_DWORD *)v6 + 7) << 16)) << 8);
      if ( a5 >= 0xD )
      {
        ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a3)(
          v9,
          v8,
          1,
          0,
          (char *)v6 + 32,
          a4);
        v8 = (__PAIR__(v8, v9) + 1) >> 32;
        v9 = v7 + 5;
      }
      v10 = (int)v6 + 36;
      ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, int, __int32))a3)(v9, v8, 4, 0, v10, a4);
      v11 = (__PAIR__(v8, v9) + 4) >> 32;
      v12 = v9 + 4;
      if ( a6 )
        *(_DWORD *)v10 = *(_BYTE *)(v10 + 3)
                       + ((*(_DWORD *)v10 >> 8) & 0xFF00)
                       + (((*(_DWORD *)v10 & 0xFF00) + (*(_DWORD *)v10 << 16)) << 8);
      v13 = *(_DWORD *)v10;
      if ( *(_DWORD *)v10 )
      {
        if ( a5 >= 0xD )
        {
          v18 = malloc(56 * v13);
          *((_DWORD *)v26 + 10) = v18;
          v28 = 0;
          if ( v18 )
          {
            if ( *(_DWORD *)v10 > 0u )
            {
              v25 = 0;
              do
              {
                v20 = Type_0D::Read(
                        (Type_0D *)(v25 + *((_DWORD *)v26 + 10)),
                        *((_BYTE *)v26 + 32),
                        __PAIR__(v11, v12),
                        a3,
                        a4,
                        a5,
                        *((_DWORD *)v26 + 7),
                        a6);
                v25 += 56;
                v12 = v20;
                v11 = v21;
                ++v28;
              }
              while ( v28 < *(_DWORD *)v10 );
            }
          }
          else
          {
            if ( *(_DWORD *)v10 > 0u )
            {
              do
              {
                memset(&v29, 0, 0x38u);
                v12 = Type_0D::Read(
                        (Type_0D *)&v29,
                        *((_BYTE *)v26 + 32),
                        __PAIR__(v11, v12),
                        a3,
                        a4,
                        a5,
                        *((_DWORD *)v26 + 7),
                        a6);
                v11 = v19;
                ++v28;
              }
              while ( v28 < *(_DWORD *)v10 );
            }
            *(_DWORD *)v10 = 0;
          }
        }
        else
        {
          v14 = malloc(544 * v13);
          *((_DWORD *)v26 + 10) = v14;
          if ( v14 )
          {
            v27 = 0;
            if ( *(_DWORD *)v10 > 0u )
            {
              v24 = 0;
              do
              {
                v16 = Type_07::Read(
                        (Type_07 *)(v24 + *((_DWORD *)v26 + 10)),
                        *((_BYTE *)v26 + 32),
                        __PAIR__(v11, v12),
                        a3,
                        a4,
                        a5,
                        *((_DWORD *)v26 + 7),
                        a6);
                v24 += 544;
                v12 = v16;
                v11 = v17;
                ++v27;
              }
              while ( v27 < *(_DWORD *)v10 );
            }
          }
          else
          {
            for ( i = 0; i < *(_DWORD *)v10; ++i )
            {
              memset(&v30, 0, 0x220u);
              v12 = Type_07::Read(
                      (Type_07 *)&v30,
                      *((_BYTE *)v26 + 32),
                      __PAIR__(v11, v12),
                      a3,
                      a4,
                      a5,
                      *((_DWORD *)v26 + 7),
                      a6);
              v11 = v15;
            }
            *(_DWORD *)v10 = 0;
          }
        }
      }
      else
      {
        *((_DWORD *)v26 + 10) = 0;
      }
      if ( a5 < 0xE )
      {
        ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a3)(
          v12,
          v11,
          4,
          0,
          (char *)v26 + 44,
          a4);
        v12 += 4;
        if ( a6 )
          *((_DWORD *)v26 + 11) = *((_BYTE *)v26 + 47)
                                + ((*((_DWORD *)v26 + 11) >> 8) & 0xFF00)
                                + (((*((_DWORD *)v26 + 11) & 0xFF00) + (*((_DWORD *)v26 + 11) << 16)) << 8);
      }
      result = v12;
    }
  }
  return result;
}

//----- (1000D590) --------------------------------------------------------
int __cdecl sub_1000D590(int a1)
{
  unsigned int v1; // ebx@1
  int v2; // edi@2
  int result; // eax@3

  v1 = 0;
  if ( *(_DWORD *)(a1 + 532) )
  {
    v2 = 0;
    do
    {
      result = v2 + *(_DWORD *)(a1 + 536);
      if ( *(_DWORD *)(result + 532) )
        result = sub_1000D590(v2 + *(_DWORD *)(a1 + 536));
      ++v1;
      v2 += 540;
    }
    while ( v1 < *(_DWORD *)(a1 + 532) );
  }
  if ( *(_DWORD *)(a1 + 532) )
  {
    free(*(void **)(a1 + 536));
    result = 0;
    *(_DWORD *)(a1 + 536) = 0;
    *(_DWORD *)(a1 + 532) = 0;
  }
  return result;
}

//----- (1000D610) --------------------------------------------------------
void __thiscall TypeTree::Clear(TypeTree *this)
{
  TypeTree *v1; // edi@1
  unsigned int v2; // ebx@2
  int v3; // esi@3
  int v4; // eax@4
  int v5; // eax@6
  int v6; // esi@11
  int v7; // edx@12
  bool v8; // zf@12
  int v9; // esi@12
  unsigned int v10; // ebx@13
  int v11; // edi@14
  int v12; // [sp+Ch] [bp-Ch]@11
  unsigned int v13; // [sp+10h] [bp-8h]@10
  TypeTree *v14; // [sp+14h] [bp-4h]@1

  v1 = this;
  v14 = this;
  if ( *((_DWORD *)this + 12) < 0xDu )
  {
    v13 = 0;
    if ( *((_DWORD *)this + 9) )
    {
      v6 = 0;
      v12 = 0;
      do
      {
        v7 = *((_DWORD *)v1 + 10);
        v8 = *(_DWORD *)(v6 + v7 + 536) == 0;
        v9 = v6 + v7 + 4;
        if ( !v8 )
        {
          do
          {
            v10 = 0;
            if ( *(_DWORD *)(v9 + 532) )
            {
              v11 = 0;
              do
              {
                if ( *(_DWORD *)(v11 + *(_DWORD *)(v9 + 536) + 532) )
                  sub_1000D590(v11 + *(_DWORD *)(v9 + 536));
                ++v10;
                v11 += 540;
              }
              while ( v10 < *(_DWORD *)(v9 + 532) );
              if ( *(_DWORD *)(v9 + 532) )
              {
                free(*(void **)(v9 + 536));
                *(_DWORD *)(v9 + 536) = 0;
                *(_DWORD *)(v9 + 532) = 0;
              }
              v1 = v14;
            }
          }
          while ( *(_DWORD *)(v9 + 532) );
        }
        v6 = v12 + 544;
        ++v13;
        v12 += 544;
      }
      while ( v13 < *((_DWORD *)v1 + 9) );
    }
    free(*((void **)v1 + 10));
    *((_DWORD *)v1 + 10) = 0;
    *((_DWORD *)v1 + 9) = 0;
  }
  else
  {
    v2 = 0;
    if ( *((_DWORD *)this + 9) )
    {
      v3 = 0;
      do
      {
        v4 = *((_DWORD *)v1 + 10);
        if ( *(_DWORD *)(v4 + v3 + 48) )
          free(*(void **)(v4 + v3 + 52));
        v5 = v3 + *((_DWORD *)v1 + 10);
        if ( *(_DWORD *)(v5 + 40) )
          free(*(void **)(v5 + 44));
        ++v2;
        v3 += 56;
      }
      while ( v2 < *((_DWORD *)v1 + 9) );
    }
    free(*((void **)v1 + 10));
    *((_DWORD *)v1 + 10) = 0;
    *((_DWORD *)v1 + 9) = 0;
  }
}

//----- (1000D760) --------------------------------------------------------
unsigned __int64 __thiscall AssetsFileDependency::GUID128::Read(AssetsFileDependency::GUID128 *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4)
{
  AssetsFileDependency::GUID128 *v4; // esi@1
  int v5; // ST44_4@1
  int v6; // ST40_4@1
  unsigned __int64 result; // rax@1

  v4 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, AssetsFileDependency::GUID128 *, __int32))a3)(
    a2,
    HIDWORD(a2),
    8,
    0,
    this,
    a4);
  BYTE2(v5) = (unsigned __int16)*(_DWORD *)v4 >> 8;
  BYTE3(v5) = *(_DWORD *)v4;
  BYTE1(v5) = *(_DWORD *)v4 >> 16;
  BYTE2(v6) = (unsigned __int16)*((_DWORD *)v4 + 1) >> 8;
  BYTE3(v6) = *((_DWORD *)v4 + 1);
  LOBYTE(v5) = *(_DWORD *)v4 >> 24;
  BYTE1(v6) = *((_DWORD *)v4 + 1) >> 16;
  LOBYTE(v6) = *((_DWORD *)v4 + 1) >> 24;
  *(_DWORD *)v4 = v6;
  *((_DWORD *)v4 + 1) = v5;
  v4 = (AssetsFileDependency::GUID128 *)((char *)v4 + 8);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, AssetsFileDependency::GUID128 *, __int32))a3)(
    a2 + 8,
    (a2 + 8) >> 32,
    8,
    0,
    v4,
    a4);
  BYTE2(v5) = (unsigned __int16)*(_DWORD *)v4 >> 8;
  BYTE3(v5) = *(_DWORD *)v4;
  BYTE1(v5) = *(_DWORD *)v4 >> 16;
  BYTE2(v6) = (unsigned __int16)*((_DWORD *)v4 + 1) >> 8;
  BYTE3(v6) = *((_DWORD *)v4 + 1);
  LOBYTE(v5) = *(_DWORD *)v4 >> 24;
  BYTE1(v6) = *((_DWORD *)v4 + 1) >> 16;
  LOBYTE(v6) = *((_DWORD *)v4 + 1) >> 24;
  *(_DWORD *)v4 = v6;
  result = a2 + 16;
  *((_DWORD *)v4 + 1) = v5;
  return result;
}

//----- (1000D850) --------------------------------------------------------
unsigned __int64 __thiscall AssetsFileDependency::GUID128::Write(AssetsFileDependency::GUID128 *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a4)
{
  AssetsFileDependency::GUID128 *v4; // esi@1
  int v5; // ST44_4@1
  int v6; // ST40_4@1
  int v8; // [sp+20h] [bp-8h]@1
  int v9; // [sp+24h] [bp-4h]@1

  v4 = this;
  BYTE2(v5) = (unsigned __int16)*(_DWORD *)this >> 8;
  BYTE3(v5) = *(_DWORD *)this;
  BYTE2(v6) = (unsigned __int16)*((_DWORD *)this + 1) >> 8;
  BYTE3(v6) = *((_DWORD *)this + 1);
  BYTE1(v5) = *(_DWORD *)this >> 16;
  LOBYTE(v5) = *(_DWORD *)this >> 24;
  BYTE1(v6) = *((_DWORD *)this + 1) >> 16;
  LOBYTE(v6) = *((_DWORD *)this + 1) >> 24;
  v8 = v6;
  v9 = v5;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, __int32))a3)(a2, HIDWORD(a2), 8, 0, &v8, a4);
  BYTE2(v5) = (unsigned __int16)*((_DWORD *)v4 + 2) >> 8;
  BYTE3(v5) = *((_DWORD *)v4 + 2);
  BYTE2(v6) = (unsigned __int16)*((_DWORD *)v4 + 3) >> 8;
  BYTE3(v6) = *((_DWORD *)v4 + 3);
  LOBYTE(v5) = *((_DWORD *)v4 + 2) >> 24;
  BYTE1(v5) = *((_DWORD *)v4 + 2) >> 16;
  BYTE1(v6) = *((_DWORD *)v4 + 3) >> 16;
  LOBYTE(v6) = *((_DWORD *)v4 + 3) >> 24;
  v8 = v6;
  v9 = v5;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, __int32))a3)(a2 + 8, (a2 + 8) >> 32, 8, 0, &v8, a4);
  return a2 + 16;
}

//----- (1000D950) --------------------------------------------------------
int __thiscall AssetsFileDependency::Read(AssetsFileDependency *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4, bool a5)
{
  unsigned int v5; // edi@1
  AssetsFileDependency *v6; // ebx@1
  unsigned int v7; // esi@2
  unsigned int v8; // kr00_4@3
  int v9; // kr20_4@3
  unsigned __int8 v10; // cf@4
  int v11; // esi@4
  unsigned int v12; // kr04_4@5
  unsigned __int64 v13; // ST08_8@6
  unsigned __int64 v14; // kr28_8@6
  signed __int64 v15; // kr30_8@6
  int v16; // ST28_4@7
  char *v17; // eax@8
  char v18; // cl@9
  unsigned int v19; // edi@11
  unsigned int v20; // esi@11
  unsigned int v21; // kr08_4@12
  int v22; // kr48_4@12
  int result; // eax@13
  char v24; // [sp+18h] [bp-18h]@3
  char v25; // [sp+28h] [bp-8h]@2

  v5 = HIDWORD(a2);
  v6 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, AssetsFileDependency *, __int32))a3)(
    a2,
    HIDWORD(a2),
    255,
    0,
    this,
    a4);
  *((_BYTE *)v6 + 255) = 0;
  if ( strlen((const char *)v6) == 255 )
  {
    v5 = (a2 + 255) >> 32;
    v7 = a2 + 255;
    v25 = 0;
    do
    {
      ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a3)(v7, v5, 16, 0, &v24, a4);
      v8 = strlen(&v24);
      v9 = v8 + v7;
      v5 = (v8 + __PAIR__(v5, v7)) >> 32;
      v7 += v8;
    }
    while ( v8 == 16 );
    v10 = __CFADD__(v9, 1);
    v11 = v9 + 1;
  }
  else
  {
    v12 = strlen((const char *)v6);
    v10 = __CFADD__(v12 + 1, (_DWORD)a2);
    v11 = v12 + 1 + a2;
  }
  HIDWORD(v13) = v10 + v5;
  LODWORD(v13) = v11;
  v14 = AssetsFileDependency::GUID128::Read((AssetsFileDependency *)((char *)v6 + 256), v13, a3, a4);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a3)(
    v14,
    HIDWORD(v14),
    4,
    0,
    (char *)v6 + 272,
    a4);
  v15 = v14 + 4;
  if ( a5 )
  {
    BYTE2(v16) = (unsigned __int16)*((_DWORD *)v6 + 68) >> 8;
    BYTE3(v16) = *((_DWORD *)v6 + 68);
    BYTE1(v16) = *((_DWORD *)v6 + 68) >> 16;
    LOBYTE(v16) = *((_DWORD *)v6 + 68) >> 24;
    *((_DWORD *)v6 + 68) = v16;
  }
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a3)(
    v15,
    HIDWORD(v15),
    255,
    0,
    (char *)v6 + 276,
    a4);
  *((_BYTE *)v6 + 531) = 0;
  v17 = (char *)v6 + 276;
  do
    v18 = *v17++;
  while ( v18 );
  if ( v17 - ((char *)v6 + 277) == 255 )
  {
    v19 = (v14 + 259) >> 32;
    v20 = v14 + 259;
    v25 = 0;
    do
    {
      ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a3)(v20, v19, 16, 0, &v24, a4);
      v21 = strlen(&v24);
      v22 = v21 + v20;
      v19 = (v21 + __PAIR__(v19, v20)) >> 32;
      v20 += v21;
    }
    while ( v21 == 16 );
    result = v22 + 1;
  }
  else
  {
    result = v15 + strlen((const char *)v6 + 276) + 1;
  }
  return result;
}

//----- (1000DB20) --------------------------------------------------------
signed __int64 __thiscall AssetsFileDependency::Write(AssetsFileDependency *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a4)
{
  AssetsFileDependency *v4; // esi@1
  AssetsFileDependency *v5; // eax@1
  char v6; // dl@2
  unsigned __int64 v7; // kr10_8@3
  const char *v8; // esi@3

  v4 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, unsigned int, _DWORD, AssetsFileDependency *, __int32))a3)(
    a2,
    HIDWORD(a2),
    strlen((const char *)this) + 1,
    0,
    this,
    a4);
  v5 = v4;
  do
  {
    v6 = *(_BYTE *)v5;
    v5 = (AssetsFileDependency *)((char *)v5 + 1);
  }
  while ( v6 );
  v7 = AssetsFileDependency::GUID128::Write(
         (AssetsFileDependency *)((char *)v4 + 256),
         a2 + (unsigned int)(v5 - (AssetsFileDependency *)((char *)v4 + 1) + 1),
         a3,
         a4);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a3)(
    v7,
    HIDWORD(v7),
    4,
    0,
    (char *)v4 + 272,
    a4);
  v8 = (char *)v4 + 276;
  ((void (__cdecl *)(_DWORD, _DWORD, unsigned int, _DWORD, const char *, __int32))a3)(
    v7 + 4,
    (v7 + 4) >> 32,
    strlen(v8) + 1,
    0,
    v8,
    a4);
  return v7 + 4 + strlen(v8) + 1;
}

//----- (1000DBE0) --------------------------------------------------------
unsigned int __thiscall AssetsFileDependencyList::Write(AssetsFileDependencyList *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a4, unsigned __int32 a5)
{
  AssetsFileDependencyList *v5; // esi@1
  unsigned int v6; // ebx@1
  unsigned int v7; // edi@1
  int v8; // esi@4
  char *v9; // eax@4
  char v10; // dl@5
  unsigned __int64 v11; // kr18_8@6
  const char *v12; // esi@6
  signed __int64 v13; // kr28_8@6
  int v15; // [sp+Ch] [bp-14h]@2
  int v16; // [sp+10h] [bp-10h]@1
  AssetsFileDependencyList *v17; // [sp+14h] [bp-Ch]@1

  v5 = this;
  v17 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, AssetsFileDependencyList *, __int32))a3)(
    a2,
    HIDWORD(a2),
    4,
    0,
    this,
    a4);
  v6 = (a2 + 4) >> 32;
  v7 = a2 + 4;
  v16 = 0;
  if ( *(_DWORD *)v5 )
  {
    v15 = 0;
    while ( 1 )
    {
      v8 = v15 + *((_DWORD *)v5 + 1);
      ((void (__cdecl *)(unsigned int, unsigned int, unsigned int, _DWORD, int, __int32))a3)(
        v7,
        v6,
        strlen((const char *)v8) + 1,
        0,
        v8,
        a4);
      v9 = (char *)v8;
      do
        v10 = *v9++;
      while ( v10 );
      v11 = AssetsFileDependency::GUID128::Write(
              (AssetsFileDependency::GUID128 *)(v8 + 256),
              (unsigned __int64)(&v9[__PAIR__(v6, v7)] - v8),
              a3,
              a4);
      ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int, __int32))a3)(v11, HIDWORD(v11), 4, 0, v8 + 272, a4);
      v12 = (const char *)(v8 + 276);
      ((void (__cdecl *)(_DWORD, _DWORD, unsigned int, _DWORD, const char *, __int32))a3)(
        v11 + 4,
        (v11 + 4) >> 32,
        strlen(v12) + 1,
        0,
        v12,
        a4);
      v13 = v11 + 4 + strlen(v12) + 1;
      v6 = HIDWORD(v13);
      v7 = v13;
      v15 += 536;
      if ( (unsigned int)++v16 >= *(_DWORD *)v17 )
        break;
      v5 = v17;
    }
  }
  return v7;
}

//----- (1000DD10) --------------------------------------------------------
int __thiscall AssetsFileDependencyList::Read(AssetsFileDependencyList *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4, unsigned __int32 a5, bool a6)
{
  AssetsFileDependencyList *v6; // ebx@1
  unsigned int v7; // edi@1
  int v8; // esi@1
  void *v9; // eax@4
  int v10; // eax@7
  unsigned int v11; // edx@7
  unsigned int v12; // edx@10
  unsigned int v14; // [sp+Ch] [bp-22Ch]@4
  int v15; // [sp+10h] [bp-228h]@6
  char v16; // [sp+18h] [bp-220h]@10

  v6 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, AssetsFileDependencyList *, __int32))a3)(
    a2,
    HIDWORD(a2),
    4,
    0,
    this,
    a4);
  v7 = (a2 + 4) >> 32;
  v8 = a2 + 4;
  if ( a6 )
    *(_DWORD *)v6 = *((_BYTE *)v6 + 3)
                  + ((*(_DWORD *)v6 >> 8) & 0xFF00)
                  + (((*(_DWORD *)v6 & 0xFF00) + (*(_DWORD *)v6 << 16)) << 8);
  if ( *(_DWORD *)v6 )
  {
    v9 = malloc(536 * *(_DWORD *)v6);
    *((_DWORD *)v6 + 1) = v9;
    v14 = 0;
    if ( v9 )
    {
      if ( *(_DWORD *)v6 > 0u )
      {
        v15 = 0;
        do
        {
          v10 = AssetsFileDependency::Read(
                  (AssetsFileDependency *)(v15 + *((_DWORD *)v6 + 1)),
                  __PAIR__(v7, v8),
                  a3,
                  a4,
                  a6);
          v15 += 536;
          v8 = v10;
          v7 = v11;
          ++v14;
        }
        while ( v14 < *(_DWORD *)v6 );
      }
    }
    else
    {
      if ( *(_DWORD *)v6 > 0u )
      {
        do
        {
          memset(&v16, 0, 0x218u);
          v8 = AssetsFileDependency::Read((AssetsFileDependency *)&v16, __PAIR__(v7, v8), a3, a4, a6);
          v7 = v12;
          ++v14;
        }
        while ( v14 < *(_DWORD *)v6 );
      }
      *(_DWORD *)v6 = 0;
    }
  }
  else
  {
    *((_DWORD *)v6 + 1) = 0;
  }
  return v8;
}

//----- (1000DE60) --------------------------------------------------------
unsigned int __thiscall PreloadList::Write(PreloadList *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a4, unsigned __int32 a5)
{
  PreloadList *v5; // ebx@1
  int v6; // edi@1
  unsigned int v7; // esi@1
  unsigned int v8; // edi@3
  int v9; // kr08_4@3
  unsigned __int8 v10; // cf@4
  int v12; // [sp+10h] [bp-8h]@2
  unsigned int v13; // [sp+14h] [bp-4h]@1

  v5 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, PreloadList *, __int32))a3)(a2, HIDWORD(a2), 4, 0, this, a4);
  v6 = (a2 + 4) >> 32;
  v7 = a2 + 4;
  v13 = 0;
  if ( *(_DWORD *)v5 )
  {
    v12 = 0;
    do
    {
      ((void (__cdecl *)(unsigned int, int, signed int, _DWORD, int, __int32))a3)(
        v7,
        v6,
        4,
        0,
        v12 + *((_DWORD *)v5 + 1),
        a4);
      v9 = v7 + 4;
      v8 = (__PAIR__((unsigned int)v6, v7) + 4) >> 32;
      if ( a5 < 0xE )
      {
        ((void (__cdecl *)(int, unsigned int, signed int, _DWORD, int, __int32))a3)(
          v9,
          v8,
          4,
          0,
          *((_DWORD *)v5 + 1) + v12 + 8,
          a4);
        v10 = __CFADD__(v9, 4);
        v7 += 8;
      }
      else
      {
        v8 = (__PAIR__(v8, v9) + 3) >> 32;
        ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, int, __int32))a3)(
          (v7 + 7) & 0xFFFFFFFC,
          v8,
          8,
          0,
          *((_DWORD *)v5 + 1) + v12 + 8,
          a4);
        v10 = __CFADD__((v7 + 7) & 0xFFFFFFFC, 8);
        v7 = ((v7 + 7) & 0xFFFFFFFC) + 8;
      }
      v6 = v10 + v8;
      v12 += 16;
      ++v13;
    }
    while ( v13 < *(_DWORD *)v5 );
  }
  return v7;
}

//----- (1000DF40) --------------------------------------------------------
int __thiscall PreloadList::Read(PreloadList *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4, unsigned __int32 a5, bool a6)
{
  PreloadList *v6; // ebx@1
  unsigned int v7; // edi@1
  int v8; // esi@1
  unsigned int v9; // eax@6
  int result; // eax@8
  unsigned __int64 v11; // kr08_8@13
  unsigned int v12; // edi@16
  unsigned int v13; // esi@16
  int v14; // eax@17
  int v15; // edx@17
  int v16; // ecx@17
  unsigned int v17; // eax@19
  int v18; // ecx@21
  int v19; // [sp+10h] [bp-20h]@12
  unsigned int v20; // [sp+14h] [bp-1Ch]@18
  unsigned int v21; // [sp+18h] [bp-18h]@11
  int v22; // [sp+1Ch] [bp-14h]@14
  int v23; // [sp+20h] [bp-10h]@17
  int v24; // [sp+24h] [bp-Ch]@17
  int v25; // [sp+28h] [bp-8h]@17
  int v26; // [sp+2Ch] [bp-4h]@17

  v6 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, PreloadList *, __int32))a3)(a2, HIDWORD(a2), 4, 0, this, a4);
  v7 = (a2 + 4) >> 32;
  v8 = a2 + 4;
  if ( a6 )
    *(_DWORD *)v6 = *((_BYTE *)v6 + 3)
                  + ((*(_DWORD *)v6 >> 8) & 0xFF00)
                  + (((*(_DWORD *)v6 & 0xFF00) + (*(_DWORD *)v6 << 16)) << 8);
  if ( *(_DWORD *)v6 )
    *((_DWORD *)v6 + 1) = malloc(16 * *(_DWORD *)v6);
  if ( *((_DWORD *)v6 + 1) )
  {
    v21 = 0;
    if ( *(_DWORD *)v6 > 0u )
    {
      v19 = 0;
      do
      {
        ((void (__cdecl *)(int, unsigned int, signed int, _DWORD, int, __int32))a3)(
          v8,
          v7,
          4,
          0,
          v19 + *((_DWORD *)v6 + 1),
          a4);
        v11 = __PAIR__(v7, v8) + 4;
        if ( a6 )
        {
          v22 = v19 + *((_DWORD *)v6 + 1);
          *(_DWORD *)v22 = *(_BYTE *)(v22 + 3)
                         + ((*(_DWORD *)v22 >> 8) & 0xFF00)
                         + (((*(_DWORD *)v22 & 0xFF00) + (*(_DWORD *)v22 << 16)) << 8);
        }
        if ( a5 < 0xE )
        {
          ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, unsigned int *, __int32))a3)(
            v11,
            HIDWORD(v11),
            4,
            0,
            &v20,
            a4);
          v7 = (v11 + 4) >> 32;
          v8 = v11 + 4;
          if ( a6 )
          {
            v17 = (v20 >> 24) + ((v20 >> 8) & 0xFF00) + (((v20 << 16) + (v20 & 0xFF00)) << 8);
            v20 = (v20 >> 24) + ((v20 >> 8) & 0xFF00) + (((v20 << 16) + (v20 & 0xFF00)) << 8);
          }
          else
          {
            v17 = v20;
          }
          v18 = *((_DWORD *)v6 + 1);
          *(_DWORD *)(v19 + v18 + 8) = v17;
          *(_DWORD *)(v19 + v18 + 12) = 0;
        }
        else
        {
          v12 = (__PAIR__(v7, v8) + 7) >> 32;
          v13 = (v11 + 3) & 0xFFFFFFFC;
          ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, int, __int32))a3)(
            v13,
            v12,
            8,
            0,
            v19 + *((_DWORD *)v6 + 1) + 8,
            a4);
          v7 = (__PAIR__(v12, v13) + 8) >> 32;
          v8 = v13 + 8;
          if ( a6 )
          {
            v14 = v19 + *((_DWORD *)v6 + 1) + 8;
            v15 = *(_DWORD *)(v19 + *((_DWORD *)v6 + 1) + 12);
            v25 = *(_DWORD *)v14;
            BYTE2(v24) = BYTE1(v25);
            BYTE3(v24) = v25;
            BYTE1(v24) = BYTE2(v25);
            v26 = v15;
            LOBYTE(v24) = BYTE3(v25);
            BYTE3(v23) = v15;
            LOBYTE(v23) = BYTE3(v15);
            v16 = v24;
            BYTE2(v23) = BYTE1(v15);
            BYTE1(v23) = BYTE2(v15);
            *(_DWORD *)v14 = v23;
            *(_DWORD *)(v14 + 4) = v16;
          }
        }
        v19 += 16;
        ++v21;
      }
      while ( v21 < *(_DWORD *)v6 );
    }
    result = v8;
  }
  else
  {
    v9 = *(_DWORD *)v6;
    if ( a5 < 0xE )
    {
      v8 += 8 * v9;
    }
    else if ( v9 > 0 )
    {
      *(_DWORD *)v6 = 0;
      return 12 * v9 + ((a2 + 7) & 0xFFFFFFFC);
    }
    *(_DWORD *)v6 = 0;
    result = v8;
  }
  return result;
}

//----- (1000E190) --------------------------------------------------------
int __thiscall AssetsFile::Write(AssetsFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), void *a3, unsigned __int64 a4, struct AssetsReplacer **a5, unsigned int a6, unsigned __int32 a7, struct ClassDatabaseFile *a8)
{
  unsigned int v8; // edi@1
  unsigned int v9; // esi@1
  AssetsFile *v10; // ebx@1
  _QWORD *v11; // eax@4
  int v12; // edx@6
  int v13; // ecx@6
  int v14; // eax@6
  unsigned __int64 v15; // rax@6
  int v16; // ST14_4@6
  void (__cdecl *v17)(int, _DWORD, signed int, _DWORD, unsigned int *, int); // ecx@6
  int v18; // ST00_4@6
  unsigned int v19; // ecx@8
  char *v20; // esi@9
  unsigned int v21; // edx@11
  int v22; // esi@11
  int result; // eax@14
  char *v24; // edi@20
  int v25; // esi@20
  unsigned int v26; // ebx@20
  char *v27; // esi@21
  bool v28; // ST14_1@27
  __int32 v29; // ST10_4@27
  unsigned __int64 (__cdecl *v30)(unsigned __int64, unsigned __int64, void *, __int32); // ST0C_4@27
  unsigned __int32 v31; // ST00_4@27
  unsigned __int64 v32; // rax@27
  bool v33; // cf@27
  int v34; // edx@28
  int v35; // ebx@32
  unsigned int v36; // edi@32
  int v37; // esi@33
  int v38; // eax@35
  int v39; // edx@35
  int v40; // esi@43
  void *v41; // ebx@47
  AssetFileInfo *v42; // edi@47
  unsigned int v43; // edx@49
  int v44; // esi@49
  unsigned int v45; // edx@50
  unsigned int v46; // ecx@50
  unsigned int v47; // ecx@51
  unsigned int v48; // eax@51
  unsigned int v49; // eax@53
  int *v50; // esi@58
  unsigned int v51; // edx@61
  unsigned int v52; // ecx@61
  unsigned int v53; // ecx@62
  unsigned int v54; // eax@62
  unsigned int v55; // eax@64
  unsigned int v56; // eax@76
  int (__thiscall *v57)(void *); // edx@77
  __int64 v58; // rax@79
  unsigned int v59; // edi@79
  unsigned int v60; // esi@79
  AssetFileInfo *v61; // eax@80
  int v62; // esi@85
  int v63; // edi@86
  unsigned int v64; // esi@88
  char *v65; // edi@89
  unsigned __int32 (__thiscall **v66)(AssetFile *__hidden); // esi@94
  int v67; // eax@97
  char *v68; // edx@97
  int (__thiscall *v69)(void *); // eax@99
  unsigned __int32 (__thiscall ***v70)(AssetFile *__hidden); // edx@103
  unsigned int v71; // eax@103
  unsigned int v72; // ecx@103
  bool v73; // zf@107
  int v74; // esi@108
  int v75; // eax@108
  int v76; // ecx@108
  int v77; // eax@108
  unsigned int v78; // ecx@108
  int v79; // ebx@108
  int v80; // edi@108
  int v81; // edi@109
  int v82; // eax@110
  struct ClassDatabaseFile *v83; // esi@110
  void *v84; // edx@111
  unsigned int v85; // ecx@112
  char *v86; // edi@116
  char *v87; // eax@117
  unsigned int v88; // esi@120
  unsigned int v89; // edi@121
  unsigned int v90; // edx@122
  void *v91; // ecx@123
  unsigned int v92; // eax@123
  char *v93; // esi@123
  unsigned int v94; // edi@136
  void *v95; // ecx@137
  unsigned int v96; // eax@137
  char *v97; // esi@137
  unsigned int v98; // edi@152
  void *v99; // ecx@153
  unsigned int v100; // eax@153
  char *v101; // esi@153
  unsigned int v102; // edi@168
  void *v103; // ecx@169
  unsigned int v104; // eax@169
  char *v105; // esi@169
  int v106; // edi@182
  size_t v107; // esi@182
  void *v108; // eax@182
  int v109; // edi@183
  size_t v110; // esi@186
  void *v111; // eax@186
  unsigned int v112; // esi@194
  unsigned __int32 (__thiscall ***v113)(AssetFile *__hidden); // eax@194
  unsigned int v114; // edx@196
  int v115; // esi@196
  unsigned int v116; // eax@198
  unsigned int v117; // eax@200
  int *v118; // esi@206
  int *v119; // eax@206
  signed int v120; // ecx@210
  unsigned int v121; // esi@210
  unsigned int v122; // eax@210
  unsigned int v123; // eax@212
  int v124; // ecx@221
  unsigned int v125; // edx@228
  int v126; // esi@228
  unsigned int v127; // eax@230
  unsigned int v128; // eax@232
  char *v129; // esi@237
  unsigned int v130; // eax@242
  unsigned int v131; // eax@244
  char *v132; // eax@254
  char *v133; // ebx@255
  char *v134; // edx@255
  char *v135; // esi@256
  char *v136; // edi@256
  unsigned int v137; // ebx@260
  void *v138; // esi@260
  unsigned int v139; // edx@268
  int v140; // ecx@268
  unsigned __int32 (__thiscall ***v141)(AssetFile *__hidden); // edx@269
  char *v142; // eax@269
  int v143; // edi@271
  int v144; // edi@271
  int v145; // ecx@272
  unsigned __int32 v146; // esi@274
  unsigned int v147; // eax@276
  int v148; // ebx@276
  unsigned int v149; // esi@276
  unsigned int v150; // edx@276
  unsigned int v151; // edi@276
  unsigned int v152; // edi@276
  unsigned int v153; // esi@276
  AssetFileInfo *v154; // ebx@277
  signed __int64 v155; // rax@278
  unsigned int v156; // edx@280
  unsigned __int64 v157; // rax@281
  unsigned int v158; // esi@281
  unsigned int v159; // ebx@283
  signed __int64 v160; // rax@285
  unsigned int v161; // ebx@287
  __int64 v162; // kr18_8@289
  unsigned __int64 v163; // kr20_8@289
  unsigned __int64 v164; // rax@290
  unsigned int v165; // edx@298
  unsigned int v166; // ecx@304
  unsigned int v167; // eax@304
  int v168; // esi@305
  int v169; // edi@305
  unsigned int v170; // ecx@311
  int v171; // edx@311
  int v172; // ecx@311
  unsigned int v173; // ebx@311
  unsigned __int64 v174; // kr30_8@313
  char v175; // [sp+14h] [bp-1C0h]@32
  char v176; // [sp+15h] [bp-1BFh]@110
  char v177; // [sp+16h] [bp-1BEh]@110
  char v178; // [sp+17h] [bp-1BDh]@1
  AssetsFile *v179; // [sp+18h] [bp-1BCh]@1
  int v180; // [sp+1Ch] [bp-1B8h]@108
  char *v181; // [sp+1Ch] [bp-1B8h]@288
  char *v182; // [sp+20h] [bp-1B4h]@108
  char *v183; // [sp+20h] [bp-1B4h]@269
  char *v184; // [sp+20h] [bp-1B4h]@277
  char *v185; // [sp+20h] [bp-1B4h]@288
  unsigned __int64 (__cdecl *v186)(unsigned __int64, unsigned __int64, const void *, __int32); // [sp+24h] [bp-1B0h]@1
  AssetFileInfo *v187; // [sp+28h] [bp-1ACh]@6
  char *v188; // [sp+2Ch] [bp-1A8h]@6
  char *v189; // [sp+30h] [bp-1A4h]@6
  int v190; // [sp+38h] [bp-19Ch]@8
  char *v191; // [sp+3Ch] [bp-198h]@6
  unsigned __int32 (__thiscall ***v192)(AssetFile *__hidden); // [sp+40h] [bp-194h]@6
  unsigned __int32 (__thiscall ***v193)(AssetFile *__hidden); // [sp+44h] [bp-190h]@6
  int *v194; // [sp+4Ch] [bp-188h]@79
  void *v195; // [sp+50h] [bp-184h]@108
  char *v196; // [sp+54h] [bp-180h]@79
  int v197; // [sp+58h] [bp-17Ch]@109
  unsigned __int64 v198; // [sp+5Ch] [bp-178h]@121
  unsigned __int64 v199; // [sp+64h] [bp-170h]@108
  void *v200; // [sp+6Ch] [bp-168h]@120
  void *v201; // [sp+70h] [bp-164h]@115
  void *v202; // [sp+74h] [bp-160h]@6
  int v203; // [sp+78h] [bp-15Ch]@6
  int v204; // [sp+7Ch] [bp-158h]@6
  unsigned __int64 v205; // [sp+84h] [bp-150h]@6
  unsigned int v206; // [sp+8Ch] [bp-148h]@7
  int v207; // [sp+90h] [bp-144h]@287
  unsigned int v208; // [sp+98h] [bp-13Ch]@6
  __int64 v209; // [sp+9Ch] [bp-138h]@79
  unsigned int v210; // [sp+A4h] [bp-130h]@120
  unsigned __int32 (__thiscall ***v211)(AssetFile *__hidden); // [sp+A8h] [bp-12Ch]@107
  unsigned __int64 v212; // [sp+ACh] [bp-128h]@26
  void *v213; // [sp+B8h] [bp-11Ch]@108
  unsigned int v214; // [sp+BCh] [bp-118h]@26
  int v215; // [sp+C0h] [bp-114h]@289
  unsigned int v216; // [sp+C8h] [bp-10Ch]@109
  struct ClassDatabaseFile *v217; // [sp+CCh] [bp-108h]@1
  void *v218; // [sp+D0h] [bp-104h]@77
  unsigned __int64 i; // [sp+D4h] [bp-100h]@120
  unsigned __int32 (__thiscall **v220)(AssetFile *__hidden); // [sp+DCh] [bp-F8h]@93
  unsigned __int32 v221; // [sp+E0h] [bp-F4h]@100
  int v222; // [sp+E4h] [bp-F0h]@271
  int v223; // [sp+E8h] [bp-ECh]@271
  int v224; // [sp+ECh] [bp-E8h]@271
  int v225; // [sp+F0h] [bp-E4h]@271
  int v226; // [sp+F4h] [bp-E0h]@107
  int v227; // [sp+F8h] [bp-DCh]@107
  int v228; // [sp+FCh] [bp-D8h]@107
  int v229; // [sp+100h] [bp-D4h]@107
  int v230; // [sp+104h] [bp-D0h]@99
  int v231; // [sp+108h] [bp-CCh]@99
  int v232; // [sp+10Ch] [bp-C8h]@99
  void *v233; // [sp+110h] [bp-C4h]@99
  unsigned __int64 v234; // [sp+114h] [bp-C0h]@3
  char v235; // [sp+11Ch] [bp-B8h]@6
  int v236; // [sp+140h] [bp-94h]@275
  char *v237; // [sp+144h] [bp-90h]@275
  int v238; // [sp+150h] [bp-84h]@311
  unsigned int v239; // [sp+154h] [bp-80h]@311
  int v240; // [sp+158h] [bp-7Ch]@311
  int v241; // [sp+15Ch] [bp-78h]@311
  int v242; // [sp+160h] [bp-74h]@311
  int v243; // [sp+164h] [bp-70h]@27
  int v244; // [sp+168h] [bp-6Ch]@36
  int v245; // [sp+170h] [bp-64h]@42
  unsigned int v246; // [sp+174h] [bp-60h]@28
  __int16 v247; // [sp+178h] [bp-5Ch]@30
  int v248; // [sp+184h] [bp-50h]@32
  char v249; // [sp+188h] [bp-4Ch]@27
  int v250; // [sp+18Ch] [bp-48h]@32
  int v251; // [sp+198h] [bp-3Ch]@6
  int v252; // [sp+19Ch] [bp-38h]@6
  int v253; // [sp+1A0h] [bp-34h]@6
  int v254; // [sp+1A4h] [bp-30h]@6
  int v255; // [sp+1A8h] [bp-2Ch]@6
  int v256; // [sp+1ACh] [bp-28h]@107
  int v257; // [sp+1B0h] [bp-24h]@107
  int v258; // [sp+1B4h] [bp-20h]@107
  int v259; // [sp+1B8h] [bp-1Ch]@107
  int v260; // [sp+1D0h] [bp-4h]@6
  signed __int64 v261; // [sp+1E4h] [bp+10h]@6
  unsigned __int64 v262; // [sp+1E4h] [bp+10h]@281

  v8 = HIDWORD(a4);
  v9 = a4;
  v186 = a2;
  v10 = this;
  v179 = this;
  v217 = a8;
  v178 = 1;
  if ( !a4 )
    v178 = 0;
  v234 = a4;
  if ( v178 )
  {
    v11 = malloc(0x10u);
    if ( !v11 )
      return 0;
    v11[1] = a4;
    v9 = 0;
    *(_DWORD *)v11 = a2;
    *((_DWORD *)v11 + 1) = a3;
    a3 = v11;
    v186 = (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32))AssetsWriterOffset;
    v8 = 0;
  }
  v12 = *((_DWORD *)v10 + 2);
  v13 = *((_DWORD *)v10 + 1);
  v251 = *(_DWORD *)v10;
  v14 = *((_DWORD *)v10 + 3);
  v253 = v12;
  v254 = v14;
  v252 = v13;
  v255 = *((_DWORD *)v10 + 4);
  v205 = __PAIR__(v8, v9);
  LOBYTE(v255) = 0;
  v15 = AssetsFileHeader::Write((AssetsFileHeader *)&v251, __PAIR__(v8, v9), v186, (__int32)a3);
  v16 = *((_DWORD *)v10 + 25);
  v17 = (void (__cdecl *)(int, _DWORD, signed int, _DWORD, unsigned int *, int))*((_DWORD *)v10 + 24);
  v261 = v15;
  v18 = *((_DWORD *)v10 + 22);
  v208 = 0;
  v17(v18, 0, 4, 0, &v208, v16);
  qmemcpy(&v235, (char *)v10 + 20, 0x34u);
  v191 = 0;
  v192 = 0;
  v193 = 0;
  v260 = 0;
  v187 = 0;
  v188 = 0;
  v189 = 0;
  v202 = 0;
  v203 = 0;
  v204 = 0;
  LOBYTE(v260) = 2;
  if ( *((_DWORD *)v10 + 2) >= 0xDu )
  {
    sub_10010B60((unsigned int *)&v191, *((_DWORD *)v10 + 14));
    v206 = 0;
    if ( *((_DWORD *)v10 + 14) )
    {
      v19 = (unsigned int)v192;
      v190 = 0;
      do
      {
        v20 = (char *)(v190 + *((_DWORD *)v10 + 15));
        if ( (unsigned int)v20 >= v19 || v191 > v20 )
        {
          if ( (unsigned __int32 (__thiscall ***)(AssetFile *__hidden))v19 == v193 )
          {
            sub_10010DD0((int)&v191);
            v19 = (unsigned int)v192;
          }
        }
        else
        {
          v21 = (signed int)(v20 - v191 + ((unsigned __int64)(-1840700269i64 * (v20 - v191)) >> 32)) >> 5;
          v22 = v21 + (v21 >> 31);
          if ( (unsigned __int32 (__thiscall ***)(AssetFile *__hidden))v19 == v193 )
          {
            sub_10010DD0((int)&v191);
            v19 = (unsigned int)v192;
          }
          v20 = &v191[56 * v22];
        }
        if ( v19 )
        {
          qmemcpy(v192, v20, 0x38u);
          v19 = (unsigned int)v192;
        }
        v190 += 56;
        v19 += 56;
        v192 = (unsigned __int32 (__thiscall ***)(AssetFile *__hidden))v19;
        ++v206;
      }
      while ( v206 < *((_DWORD *)v10 + 14) );
    }
  }
  sub_10010D50(a6, (int)&v202);
  v24 = (char *)v202;
  memcpy(v202, a5, 4 * a6);
  v25 = v203;
  v26 = 0;
  if ( (v203 - (signed int)v24) >> 2 )
  {
    v190 = v203 - (_DWORD)v24;
    v27 = v24 + 4;
    do
    {
      if ( !*(_DWORD *)v24 )
      {
        memmove(v24, v27, 4 * ((v203 - (signed int)v27) >> 2));
        v203 -= 4;
        v190 -= 4;
        --v26;
        v24 -= 4;
        v27 -= 4;
      }
      ++v26;
      v24 += 4;
      v27 += 4;
    }
    while ( v26 < v190 >> 2 );
    v25 = v203;
    v24 = (char *)v202;
  }
  v206 = 0;
  sub_10010C60((unsigned int *)&v187, v208);
  v212 = (unsigned int)(*((_DWORD *)v179 + 22) + 4);
  v214 = 0;
  if ( v208 > 0 )
  {
    while ( 1 )
    {
      v28 = *((_BYTE *)v179 + 16) != 0;
      v29 = *((_DWORD *)v179 + 25);
      v30 = (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32))*((_DWORD *)v179 + 24);
      v31 = *((_DWORD *)v179 + 2);
      v249 = 1;
      v32 = AssetFileInfo::Read((AssetFileInfo *)&v243, v31, v212, v30, v29, v28);
      v33 = *((_DWORD *)v179 + 2) < 0x10u;
      v212 = v32;
      if ( v33 )
      {
        v34 = v246;
      }
      else if ( v246 < ((char *)v192 - v191) / 56 )
      {
        v34 = *(_DWORD *)&v191[56 * v246];
        v247 = *(_DWORD *)&v191[56 * v246];
      }
      else
      {
        v34 = 0;
        v247 = 0;
      }
      v35 = 0;
      v36 = (v203 - (signed int)v202) >> 2;
      v248 = v34;
      v250 = 0;
      v175 = 0;
      if ( !v36 )
        goto LABEL_45;
      while ( 1 )
      {
        v37 = *((_DWORD *)v202 + v35);
        if ( (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v37 + 8))(*((_DWORD *)v202 + v35)) == a7 || a7 == -1 )
        {
          v38 = (*(int (__thiscall **)(int))(*(_DWORD *)v37 + 12))(v37);
          if ( v38 == v243 && v39 == v244 )
            break;
        }
        if ( ++v35 >= v36 )
        {
          ++v206;
          goto LABEL_47;
        }
      }
      if ( (**(int (__thiscall ***)(_DWORD))v37)(v37) == 1 )
      {
        v175 = 1;
      }
      else
      {
        if ( (**(int (__thiscall ***)(_DWORD))v37)(v37) )
          goto LABEL_45;
        v245 = (*(int (__thiscall **)(int))(*(_DWORD *)v37 + 24))(v37);
        v250 = v37;
      }
      v40 = v203;
      memmove((char *)v202 + 4 * v35, (char *)v202 + 4 * v35 + 4, 4 * ((v203 - ((signed int)v202 + 4 * v35 + 4)) >> 2));
      v203 = v40 - 4;
      if ( !v175 )
        break;
LABEL_73:
      if ( ++v214 >= v208 )
      {
        v25 = v203;
        v24 = (char *)v202;
        goto LABEL_75;
      }
    }
    if ( v250 )
      v249 = 0;
    else
LABEL_45:
      ++v206;
LABEL_47:
    v41 = v188;
    v42 = v187;
    if ( &v243 >= (int *)v188 || v187 > (AssetFileInfo *)&v243 )
    {
      if ( v188 == v189 )
      {
        v51 = (signed int)((unsigned __int64)(715827883i64 * (v188 - (char *)v187)) >> 32) >> 3;
        v52 = v51 + (v51 >> 31);
        if ( v52 > 0x5555554 )
          goto LABEL_87;
        v53 = v52 + 1;
        v54 = (v189 - (char *)v187) / 48;
        if ( v53 > v54 )
        {
          if ( 89478485 - (v54 >> 1) >= v54 )
            v55 = (v54 >> 1) + v54;
          else
            v55 = 0;
          if ( v55 < v53 )
            v55 = v53;
          sub_10010C60((unsigned int *)&v187, v55);
          v41 = v188;
        }
      }
      if ( !v41 )
        goto LABEL_72;
      v50 = &v243;
    }
    else
    {
      v43 = (signed int)((unsigned __int64)(715827883i64 * ((char *)&v243 - (char *)v187)) >> 32) >> 3;
      v44 = v43 + (v43 >> 31);
      if ( v188 == v189 )
      {
        v45 = (signed int)((unsigned __int64)(715827883i64 * (v188 - (char *)v187)) >> 32) >> 3;
        v46 = v45 + (v45 >> 31);
        if ( v46 > 0x5555554 )
          goto LABEL_87;
        v47 = v46 + 1;
        v48 = (v189 - (char *)v187) / 48;
        if ( v47 > v48 )
        {
          if ( 89478485 - (v48 >> 1) >= v48 )
            v49 = (v48 >> 1) + v48;
          else
            v49 = 0;
          if ( v49 < v47 )
            v49 = v47;
          sub_10010C60((unsigned int *)&v187, v49);
          v41 = v188;
          v42 = v187;
        }
      }
      v50 = (int *)((char *)v42 + 48 * v44);
      if ( !v41 )
        goto LABEL_72;
    }
    v41 = v188;
    qmemcpy(v188, v50, 0x30u);
LABEL_72:
    v188 = (char *)v41 + 48;
    goto LABEL_73;
  }
LABEL_75:
  v190 = 0;
  LODWORD(v212) = (v25 - (signed int)v24) >> 2;
  if ( (unsigned int)v212 > 0 )
  {
    v56 = 0;
    while ( 1 )
    {
      v41 = (void *)*((_DWORD *)v202 + v56);
      v57 = *(int (__thiscall **)(void *))(*(_DWORD *)v41 + 8);
      v218 = (void *)*((_DWORD *)v202 + v56);
      if ( v57(v218) != a7 && a7 != -1 )
        goto LABEL_258;
      LODWORD(v58) = (*(int (__thiscall **)(void *))(*(_DWORD *)v41 + 12))(v41);
      v209 = v58;
      v194 = &v243;
      v59 = 0;
      v60 = 0;
      v175 = 0;
      v196 = (char *)((v188 - (char *)v187) / 48);
      if ( v196 )
      {
        v61 = v187;
        do
        {
          if ( *(_QWORD *)v61 == v209 )
          {
            v175 = 1;
            v194 = (int *)v61;
            v59 = v60;
          }
          ++v60;
          v61 = (AssetFileInfo *)((char *)v61 + 48);
        }
        while ( v60 < (unsigned int)v196 );
      }
      if ( (**(int (__thiscall ***)(void *))v41)(v41) )
      {
        if ( (**(int (__thiscall ***)(void *))v41)(v41) == 1 && v175 )
        {
          v132 = (char *)v187 + 48 * v59 + 48;
          if ( v132 != v188 )
          {
            v133 = v188;
            v134 = (char *)v187 + 48 * v59;
            do
            {
              v135 = v132;
              v136 = v134;
              v132 += 48;
              v134 += 48;
              qmemcpy(v136, v135, 0x30u);
            }
            while ( v132 != v133 );
          }
          v188 -= 48;
        }
        goto LABEL_258;
      }
      v62 = (int)v194;
      v194[10] = (int)v41;
      *(_DWORD *)(v62 + 12) = (*(int (__thiscall **)(void *))(*(_DWORD *)v41 + 24))(v41);
      if ( *((_DWORD *)v179 + 2) < 0x10u )
      {
        *(_DWORD *)(v62 + 16) = (*(int (__thiscall **)(void *))(*(_DWORD *)v41 + 16))(v41);
        *(_DWORD *)(v62 + 32) = (*(int (__thiscall **)(void *))(*(_DWORD *)v41 + 16))(v41);
        v63 = v62;
        goto LABEL_221;
      }
      while ( 1 )
      {
        v64 = 0;
        v214 = ((char *)v192 - v191) / 56;
        if ( v214 )
        {
          v65 = v191;
          do
          {
            if ( (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v41 + 16))(v41) < 0 )
            {
              if ( *(_DWORD *)v65 == 114
                && *((_WORD *)v65 + 3) == (unsigned __int16)(*(int (__thiscall **)(void *))(*(_DWORD *)v41 + 20))(v41) )
              {
LABEL_97:
                v63 = (int)v194;
                v194[4] = v64;
                v67 = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v41 + 16))(v41);
                v68 = v191;
                *(_DWORD *)(v63 + 32) = v67;
                *(_WORD *)(v63 + 20) = *(_WORD *)&v68[56 * v64];
                goto LABEL_221;
              }
            }
            else if ( (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v41 + 16))(v41) == *(_DWORD *)v65 )
            {
              goto LABEL_97;
            }
            ++v64;
            v65 += 56;
          }
          while ( v64 < v214 );
        }
        memset(&v220, 0, 0x38u);
        if ( (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v41 + 16))(v41) < 0 )
          v66 = (unsigned __int32 (__thiscall **)(AssetFile *__hidden))114;
        else
          v66 = (unsigned __int32 (__thiscall **)(AssetFile *__hidden))(*(int (__thiscall **)(_DWORD))(*(_DWORD *)v41 + 16))(v41);
        v69 = *(int (__thiscall **)(void *))(*(_DWORD *)v41 + 16);
        v220 = v66;
        v233 = 0;
        v231 = 0;
        v232 = 0;
        v230 = 0;
        if ( v69(v41) < 0 )
          HIWORD(v221) = (*(int (__thiscall **)(void *))(*(_DWORD *)v41 + 20))(v41);
        else
          HIWORD(v221) = -1;
        LOBYTE(v221) = 0;
        if ( v217 )
        {
          v70 = (unsigned __int32 (__thiscall ***)(AssetFile *__hidden))*((_DWORD *)v217 + 9);
          v71 = (*((_DWORD *)v217 + 10) - (signed int)v70) >> 5;
          v72 = 0;
          if ( v71 )
          {
            while ( *v70 != v66 )
            {
              ++v72;
              v70 += 8;
              if ( v72 >= v71 )
                goto LABEL_194;
            }
            v211 = v70;
            ClassDatabaseType::MakeTypeHash(v70, (BYTE *)&v256, (int)v217);
            v227 = v257;
            v73 = *((_BYTE *)v179 + 52) == 0;
            v226 = v256;
            v228 = v258;
            v229 = v259;
            if ( !v73 )
            {
              v75 = 24 * (((char *)v211[5] - (char *)v211[4]) >> 5);
              v76 = 24 * (unsigned __int64)(unsigned int)(((char *)v211[5] - (char *)v211[4]) >> 5) >> 32 != 0;
              LODWORD(v199) = ((char *)v211[5] - (char *)v211[4]) >> 5;
              v74 = v199;
              v77 = unknown_libname_4(v75 | -v76);
              v78 = 0;
              v79 = 0;
              v80 = v77;
              v213 = (void *)v77;
              v195 = 0;
              v180 = 0;
              v182 = 0;
              if ( !v74 )
                goto LABEL_193;
              v81 = v77 + 3;
              v216 = 0;
              v197 = v77 + 3;
              while ( 1 )
              {
                v82 = (int)&v211[4][v216 / 4];
                v83 = v217;
                *(_WORD *)(v81 - 3) = *(_WORD *)(v82 + 24);
                *(_BYTE *)(v81 - 1) = *(_BYTE *)(v82 + 16);
                v176 = 0;
                *(_BYTE *)v81 = *(_BYTE *)(v82 + 17) != 0;
                *(_DWORD *)(v81 + 9) = *(_DWORD *)(v82 + 20);
                *(_DWORD *)(v81 + 13) = v78;
                *(_DWORD *)(v81 + 17) = *(_DWORD *)(v82 + 28);
                v177 = 0;
                if ( *(_BYTE *)(v82 + 12) )
                {
                  v85 = *(_DWORD *)(v82 + 8);
                  if ( v85 < *((_DWORD *)v83 + 7) )
                    v84 = (void *)(v85 + *((_DWORD *)v83 + 13));
                  else
                    v84 = 0;
                }
                else
                {
                  v84 = *(void **)(v82 + 8);
                }
                v73 = *(_BYTE *)(v82 + 4) == 0;
                v201 = v84;
                if ( v73 )
                {
                  v86 = *(char **)v82;
                }
                else
                {
                  v87 = *(char **)v82;
                  if ( (unsigned int)v87 < *((_DWORD *)v83 + 7) )
                    v86 = &v87[*((_DWORD *)v83 + 13)];
                  else
                    v86 = 0;
                }
                v200 = v86;
                v88 = strlen((const char *)v84);
                LODWORD(i) = v88;
                v210 = strlen(v86);
                if ( v88 < 0x411 )
                {
                  v89 = 0;
                  LODWORD(v198) = 1041 - v88;
                  if ( 1041 != v88 )
                  {
                    v90 = v88 + 1;
                    do
                    {
                      v91 = v201;
                      v92 = v90;
                      v93 = &aAabb[v89];
                      if ( v90 < 4 )
                      {
LABEL_126:
                        if ( !v92
                          || *(_BYTE *)v91 == *v93
                          && (v92 <= 1 || *((_BYTE *)v91 + 1) == v93[1] && (v92 <= 2 || *((_BYTE *)v91 + 2) == v93[2])) )
                        {
                          *(_DWORD *)(v197 + 5) = v89 | 0x80000000;
                          v176 = 1;
                          break;
                        }
                      }
                      else
                      {
                        while ( *(_DWORD *)v93 == *(_DWORD *)v91 )
                        {
                          v92 -= 4;
                          v91 = (char *)v91 + 4;
                          v93 += 4;
                          if ( v92 < 4 )
                            goto LABEL_126;
                        }
                      }
                      ++v89;
                    }
                    while ( v89 < (unsigned int)v198 );
                  }
                }
                if ( v210 < 0x411 )
                {
                  v94 = 0;
                  LODWORD(v198) = 1041 - v210;
                  if ( 1041 != v210 )
                  {
                    do
                    {
                      v95 = v200;
                      v96 = v210 + 1;
                      v97 = &aAabb[v94];
                      if ( v210 + 1 < 4 )
                      {
LABEL_140:
                        if ( !v96
                          || *(_BYTE *)v95 == *v97
                          && (v96 <= 1 || *((_BYTE *)v95 + 1) == v97[1] && (v96 <= 2 || *((_BYTE *)v95 + 2) == v97[2])) )
                        {
                          *(_DWORD *)(v197 + 1) = v94 | 0x80000000;
                          v177 = 1;
                          break;
                        }
                      }
                      else
                      {
                        while ( *(_DWORD *)v97 == *(_DWORD *)v95 )
                        {
                          v96 -= 4;
                          v95 = (char *)v95 + 4;
                          v97 += 4;
                          if ( v96 < 4 )
                            goto LABEL_140;
                        }
                      }
                      ++v94;
                    }
                    while ( v94 < (unsigned int)v198 );
                  }
                }
                if ( !v176 )
                {
                  if ( v180 )
                  {
                    if ( (unsigned int)i < v180 - 1 )
                    {
                      v98 = 0;
                      LODWORD(v198) = v180 - i - 1;
                      if ( v180 - (_DWORD)i != 1 )
                      {
                        do
                        {
                          v99 = v201;
                          v100 = i + 1;
                          v101 = (char *)v195 + v98;
                          if ( (unsigned int)(i + 1) < 4 )
                          {
LABEL_156:
                            if ( !v100
                              || *(_BYTE *)v99 == *v101
                              && (v100 <= 1
                               || *((_BYTE *)v99 + 1) == v101[1] && (v100 <= 2 || *((_BYTE *)v99 + 2) == v101[2])) )
                            {
                              *(_DWORD *)(v197 + 5) = v98;
                              v176 = 1;
                              break;
                            }
                          }
                          else
                          {
                            while ( *(_DWORD *)v101 == *(_DWORD *)v99 )
                            {
                              v100 -= 4;
                              v99 = (char *)v99 + 4;
                              v101 += 4;
                              if ( v100 < 4 )
                                goto LABEL_156;
                            }
                          }
                          ++v98;
                        }
                        while ( v98 < (unsigned int)v198 );
                      }
                    }
                  }
                }
                if ( !v177 )
                {
                  if ( v180 )
                  {
                    if ( v210 < v180 - 1 )
                    {
                      v102 = 0;
                      LODWORD(v198) = v180 - v210 - 1;
                      if ( v180 - v210 != 1 )
                      {
                        do
                        {
                          v103 = v200;
                          v104 = v210 + 1;
                          v105 = (char *)v195 + v102;
                          if ( v210 + 1 < 4 )
                          {
LABEL_172:
                            if ( !v104
                              || *(_BYTE *)v103 == *v105
                              && (v104 <= 1
                               || *((_BYTE *)v103 + 1) == v105[1] && (v104 <= 2 || *((_BYTE *)v103 + 2) == v105[2])) )
                            {
                              *(_DWORD *)(v197 + 1) = v102;
                              v177 = 1;
                              break;
                            }
                          }
                          else
                          {
                            while ( *(_DWORD *)v105 == *(_DWORD *)v103 )
                            {
                              v104 -= 4;
                              v103 = (char *)v103 + 4;
                              v105 += 4;
                              if ( v104 < 4 )
                                goto LABEL_172;
                            }
                          }
                          ++v102;
                        }
                        while ( v102 < (unsigned int)v198 );
                      }
                    }
                  }
                }
                v79 = v180;
                if ( v176 )
                {
                  v109 = v197;
                }
                else
                {
                  v106 = i;
                  v107 = i + v180 + 1;
                  v108 = realloc(v195, v107);
                  if ( !v108 )
                    goto LABEL_190;
                  v195 = v108;
                  memcpy((char *)v108 + v180, v201, v106 + 1);
                  v109 = v197;
                  *(_DWORD *)(v197 + 5) = v180;
                  v79 = v107;
                  v180 = v107;
                }
                if ( !v177 )
                {
                  v110 = v210 + v79 + 1;
                  v111 = realloc(v195, v110);
                  if ( !v111 )
                  {
LABEL_190:
                    v80 = (int)v213;
                    operator delete[](v213);
                    v74 = 0;
                    if ( v195 )
                      free(v195);
                    v79 = 0;
LABEL_193:
                    v232 = v79;
                    v41 = v218;
                    v231 = v80;
                    v230 = v74;
                    v233 = v195;
                    break;
                  }
                  v195 = v111;
                  memcpy((char *)v111 + v79, v200, v210 + 1);
                  *(_DWORD *)(v109 + 1) = v79;
                  v79 = v110;
                  v180 = v110;
                }
                v74 = v199;
                v216 += 32;
                v78 = (unsigned int)(v182 + 1);
                v81 = v109 + 24;
                v182 = (char *)v78;
                v197 = v81;
                if ( v78 >= (unsigned int)v199 )
                {
                  v80 = (int)v213;
                  goto LABEL_193;
                }
              }
            }
          }
        }
LABEL_194:
        v112 = v214;
        v63 = (int)v194;
        v194[4] = v214;
        *(_DWORD *)(v63 + 32) = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v41 + 16))(v41);
        v113 = (unsigned __int32 (__thiscall ***)(AssetFile *__hidden))v191;
        *(_WORD *)(v63 + 20) = *(_WORD *)&v191[56 * v190];
        if ( &v220 >= v192 || v113 > &v220 )
        {
          if ( v192 == v193 )
          {
            if ( v112 > 0x4924923 )
              goto LABEL_87;
            v120 = (char *)v193 - (char *)v113;
            v121 = v112 + 1;
            v122 = ((char *)v193 - (char *)v113) / 56;
            if ( v121 > v120 / 56 )
            {
              if ( 76695844 - (v122 >> 1) >= v122 )
                v123 = (v122 >> 1) + v122;
              else
                v123 = 0;
              if ( v123 < v121 )
                v123 = v121;
              sub_10010B60((unsigned int *)&v191, v123);
            }
          }
          v119 = (int *)v192;
          if ( v192 )
          {
            v118 = (int *)&v220;
LABEL_219:
            qmemcpy(v119, v118, 0x38u);
            v63 = (int)v194;
            goto LABEL_220;
          }
        }
        else
        {
          v114 = (signed int)((char *)&v220
                            - (char *)v113
                            + ((unsigned __int64)(-1840700269i64 * ((char *)&v220 - (char *)v113)) >> 32)) >> 5;
          v115 = v114 + (v114 >> 31);
          if ( v192 == v193 )
          {
            if ( v214 > 0x4924923 )
              goto LABEL_87;
            v116 = ((char *)v193 - v191) / 56;
            if ( v214 + 1 > v116 )
            {
              if ( 76695844 - (v116 >> 1) >= v116 )
                v117 = (v116 >> 1) + v116;
              else
                v117 = 0;
              if ( v117 < v214 + 1 )
                v117 = v214 + 1;
              sub_10010B60((unsigned int *)&v191, v117);
            }
            v63 = (int)v194;
          }
          v118 = (int *)&v191[56 * v115];
          v119 = (int *)v192;
          if ( v192 )
            goto LABEL_219;
        }
LABEL_220:
        v192 = (unsigned __int32 (__thiscall ***)(AssetFile *__hidden))(v119 + 14);
LABEL_221:
        v124 = HIDWORD(v209);
        *(_DWORD *)v63 = v209;
        *(_DWORD *)(v63 + 4) = v124;
        *(_BYTE *)(v63 + 36) = 0;
        *(_DWORD *)(v63 + 8) = 0;
        if ( *((_DWORD *)v179 + 2) < 0x10u )
        {
          if ( *(_DWORD *)(v63 + 16) >= 0 )
            *(_WORD *)(v63 + 20) = *(_WORD *)(v63 + 16);
          else
            *(_WORD *)(v63 + 20) = 114;
        }
        *(_WORD *)(v63 + 22) = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v41 + 20))(v41);
        *(_BYTE *)(v63 + 24) = 0;
        if ( v175 )
          goto LABEL_258;
        if ( &v243 < (int *)v188 && v187 <= (AssetFileInfo *)&v243 )
        {
          v125 = (signed int)((unsigned __int64)(715827883i64 * ((char *)&v243 - (char *)v187)) >> 32) >> 3;
          v126 = v125 + (v125 >> 31);
          if ( v188 != v189 )
            goto LABEL_237;
          if ( (unsigned int)v196 <= 0x5555554 )
          {
            v127 = (v189 - (char *)v187) / 48;
            if ( (unsigned int)(v196 + 1) > v127 )
            {
              if ( 89478485 - (v127 >> 1) >= v127 )
                v128 = (v127 >> 1) + v127;
              else
                v128 = 0;
              if ( v128 < (unsigned int)(v196 + 1) )
                v128 = (unsigned int)(v196 + 1);
              sub_10010C60((unsigned int *)&v187, v128);
            }
LABEL_237:
            v129 = (char *)v187 + 48 * v126;
            if ( v188 )
              qmemcpy(v188, v129, 0x30u);
            v188 += 48;
            goto LABEL_258;
          }
          goto LABEL_87;
        }
        if ( v188 != v189 )
          goto LABEL_249;
        if ( (unsigned int)v196 <= 0x5555554 )
          break;
LABEL_87:
        std::_Xlength_error("vector<T> too long");
      }
      v130 = (v189 - (char *)v187) / 48;
      if ( (unsigned int)(v196 + 1) > v130 )
      {
        if ( 89478485 - (v130 >> 1) >= v130 )
          v131 = (v130 >> 1) + v130;
        else
          v131 = 0;
        if ( v131 < (unsigned int)(v196 + 1) )
          v131 = (unsigned int)(v196 + 1);
        sub_10010C60((unsigned int *)&v187, v131);
      }
LABEL_249:
      if ( v188 )
        qmemcpy(v188, &v243, 0x30u);
      v188 += 48;
LABEL_258:
      v56 = v190 + 1;
      v190 = v56;
      if ( v56 >= (unsigned int)v212 )
      {
        v24 = (char *)v202;
        break;
      }
    }
  }
  v137 = *((_DWORD *)v179 + 2) < 9u ? 0x10 : 0;
  v138 = malloc(56 * v206);
  v218 = v138;
  if ( v138 )
  {
    v139 = (signed int)((unsigned __int64)(715827883i64 * (v188 - (char *)v187)) >> 32) >> 3;
    v140 = v139 + (v139 >> 31);
    v196 = (char *)(v139 + (v139 >> 31));
    if ( v139 + (v139 >> 31) )
    {
      v141 = (unsigned __int32 (__thiscall ***)(AssetFile *__hidden))v138;
      v142 = (char *)v187 + 40;
      v183 = (char *)v140;
      do
      {
        if ( !*(_DWORD *)v142 )
        {
          v143 = *((_DWORD *)v142 - 8);
          v221 = a7;
          v222 = *((_DWORD *)v142 - 10);
          v223 = *((_DWORD *)v142 - 9);
          v224 = *((_DWORD *)v142 - 2);
          LOWORD(v225) = *((_WORD *)v142 - 9);
          v144 = *((_DWORD *)v179 + 3) + v143;
          v226 = *((_DWORD *)v179 + 24);
          v227 = *((_DWORD *)v179 + 25);
          v228 = *((_DWORD *)v142 - 7);
          v229 = 0;
          v230 = v144;
          v231 = 0;
          v220 = &off_100A1DB4;
          v232 = 0x4000;
          qmemcpy(v141, &v220, 0x38u);
          *(_DWORD *)v142 = v141;
          v141 += 14;
        }
        v145 = *((_DWORD *)v142 - 7);
        *((_DWORD *)v142 - 8) = v137;
        v137 = (v145 + v137 + 7) & 0xFFFFFFF8;
        v142 += 48;
        --v183;
      }
      while ( v183 );
    }
    v33 = *((_DWORD *)v179 + 2) < 9u;
    v198 = 0i64;
    v199 = v205;
    if ( v33 )
      goto LABEL_287;
    while ( 1 )
    {
      v146 = *((_DWORD *)v179 + 2);
      if ( v146 >= 0xD )
      {
        v237 = v191;
        v236 = ((char *)v192 - v191) / 56;
      }
      v209 = v261;
      v147 = TypeTree::Write((TypeTree *)&v235, v261, v186, (__int32)a3, v146);
      v148 = (int)v196;
      v149 = v147;
      v151 = v150;
      LODWORD(v212) = v196;
      ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, unsigned __int64 *, void *))v186)(
        v147,
        v150,
        4,
        0,
        &v212,
        a3);
      v152 = (__PAIR__(v151, v149) + 4) >> 32;
      v153 = v149 + 4;
      if ( v148 )
      {
        v154 = v187;
        v184 = v196;
        do
        {
          v155 = AssetFileInfo::Write(v154, *((_DWORD *)v179 + 2), __PAIR__(v152, v153), v186, (__int32)a3);
          v154 = (AssetFileInfo *)((char *)v154 + 48);
          v73 = v184-- == (char *)1;
          v152 = HIDWORD(v155);
          v153 = v155;
        }
        while ( !v73 );
      }
      if ( *((_DWORD *)v179 + 2) >= 0xBu )
      {
        v153 = PreloadList::Write(
                 (AssetsFile *)((char *)v179 + 72),
                 __PAIR__(v152, v153),
                 v186,
                 (__int32)a3,
                 *((_DWORD *)v179 + 2));
        v152 = v156;
      }
      LODWORD(v157) = AssetsFileDependencyList::Write(
                        (AssetsFile *)((char *)v179 + 80),
                        __PAIR__(v152, v153),
                        v186,
                        (__int32)a3,
                        *((_DWORD *)v179 + 2));
      v158 = *((_DWORD *)v179 + 2);
      LODWORD(v262) = v157;
      if ( v158 >= 9 )
      {
        v159 = *((_DWORD *)v179 + 3);
        v198 = v157 - v205 - 19;
        if ( v157 >= v159 )
        {
          v160 = v157 + 15;
          LODWORD(v160) = v160 & 0xFFFFFFF0;
          v199 = v160;
        }
        else
        {
          v199 = v159;
        }
      }
      else
      {
        v198 = v157 - v209 + 1;
      }
      if ( v158 < 9 )
        break;
LABEL_287:
      v161 = HIDWORD(v199);
      v262 = v199;
      v206 = 0;
      v207 = 0;
      if ( v196 )
      {
        v181 = (char *)v187 + 40;
        v185 = v196;
        do
        {
          v162 = v199 + *((_DWORD *)v181 - 8);
          v163 = v199 + *((_DWORD *)v181 - 8) - __PAIR__(v161, (unsigned int)v262);
          v215 = HIDWORD(v163);
          if ( v163 > 8 )
          {
            v164 = v205 + 16;
            for ( i = v205 + 16; ; LODWORD(v164) = i )
            {
              if ( __PAIR__(v161, (unsigned int)v262) >= v164 )
              {
                ((void (__cdecl *)(_DWORD, unsigned int, signed int, _DWORD, unsigned int *, void *))v186)(
                  v262,
                  v161,
                  8,
                  0,
                  &v206,
                  a3);
                HIDWORD(v164) = HIDWORD(i);
              }
              v161 = (__PAIR__(v161, (unsigned int)v262) + 8) >> 32;
              LODWORD(v262) = v262 + 8;
              if ( v162 - __PAIR__(v161, (unsigned int)v262) <= 8 )
                break;
            }
          }
          if ( (v162 - __PAIR__(v161, (unsigned int)v262)) >> 32 || (_DWORD)v162 != (_DWORD)v262 )
            ((void (__cdecl *)(_DWORD, unsigned int, _DWORD, _DWORD, unsigned int *, void *))v186)(
              v262,
              v161,
              v162 - v262,
              (v162 - __PAIR__(v161, (unsigned int)v262)) >> 32,
              &v206,
              a3);
          LODWORD(v262) = (*(int (__stdcall **)(_DWORD, _DWORD, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32), void *))(**(_DWORD **)v181 + 28))(
                            v162,
                            HIDWORD(v162),
                            v186,
                            a3);
          v161 = v165;
          if ( *(v181 - 4) )
            (*(void (__stdcall **)(_DWORD))(**(_DWORD **)v181 + 4))(0);
          v181 += 48;
          --v185;
        }
        while ( v185 );
        HIDWORD(v262) = v161;
      }
      if ( *((_DWORD *)v179 + 2) >= 9u )
        break;
      ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, void *))v186)(
        v262,
        HIDWORD(v262),
        1,
        0,
        (char *)v179 + 16,
        a3);
      v261 = v262 + 1;
    }
    free(v218);
    v166 = *((_DWORD *)v179 + 14);
    v167 = ((char *)v192 - v191) / 56;
    if ( v166 < v167 )
    {
      v168 = (int)&v191[56 * v166 + 44];
      v169 = v167 - v166;
      do
      {
        if ( *(_DWORD *)(v168 + 8) )
          free(*(void **)(v168 + 8));
        if ( *(_DWORD *)v168 )
          operator delete[](*(void **)v168);
        v168 += 56;
        --v169;
      }
      while ( v169 );
    }
    v170 = *((_DWORD *)v179 + 1);
    v171 = *((_DWORD *)v179 + 2);
    v238 = *(_DWORD *)v179;
    v241 = *((_DWORD *)v179 + 3);
    v239 = v170;
    v172 = *((_DWORD *)v179 + 4);
    v173 = v205;
    v239 = v262 - v205;
    v242 = v172;
    v241 = v199 - v205;
    v240 = v171;
    v238 = v198;
    LOBYTE(v242) = 0;
    AssetsFileHeader::Write((AssetsFileHeader *)&v238, v205, v186, (__int32)a3);
    if ( v178 )
      free(a3);
    v174 = v234 + __PAIR__(HIDWORD(v205), v173) + v239;
    if ( v202 )
      operator delete(v202);
    if ( v187 )
      operator delete((void *)v187);
    if ( v191 )
      operator delete(v191);
    result = v174;
  }
  else
  {
    if ( v24 )
      operator delete(v24);
    if ( v187 )
      operator delete((void *)v187);
    if ( v191 )
      operator delete(v191);
    result = v261;
  }
  return result;
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099190: using guessed type void __cdecl operator delete[](void *);
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100A1DB4: using guessed type unsigned __int32 (__thiscall *off_100A1DB4)(AssetFile *__hidden this);

//----- (1000F850) --------------------------------------------------------
AssetsFileHeader *__thiscall AssetsFile::AssetsFile(AssetsFileHeader *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3)
{
  AssetsFileHeader *v3; // esi@1
  int v4; // eax@1
  unsigned __int32 v5; // ecx@1
  unsigned int v6; // edx@1
  unsigned int v7; // edx@5
  int v8; // edi@5
  char v9; // al@5
  unsigned int v10; // ebx@5
  int v11; // ST28_4@8
  int v12; // ecx@8
  unsigned __int32 v13; // eax@10
  unsigned int v14; // ebx@10
  unsigned int v15; // edi@10
  int v16; // kr08_4@10
  unsigned int v17; // kr00_4@13
  unsigned __int32 v18; // eax@13
  unsigned int v19; // ebx@13
  int v20; // edi@13
  int v21; // kr18_4@13
  unsigned int v22; // edx@14
  unsigned int v24; // [sp+14h] [bp-34h]@1
  int v25; // [sp+18h] [bp-30h]@7

  v3 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int32))a2)(0, 0, 0, 0, 0, a3);
  *((_DWORD *)v3 + 24) = a2;
  *((_DWORD *)v3 + 25) = a3;
  v4 = AssetsFileHeader::Read(v3, 0i64, a2, a3);
  v5 = *((_DWORD *)v3 + 2);
  v24 = v6;
  if ( !v5 || v5 > 0x40 )
    goto LABEL_21;
  if ( v5 < 9 )
  {
    v24 = 0;
    v4 = *((_DWORD *)v3 + 1) - *(_DWORD *)v3 + 1;
  }
  v8 = TypeTree::Read((AssetsFileHeader *)((char *)v3 + 20), __PAIR__(v24, v4), a2, a3, v5, *((_BYTE *)v3 + 16) != 0);
  v9 = *((_BYTE *)v3 + 20);
  v10 = v7;
  if ( v9 >= 48 && v9 <= 57 )
  {
    *((_DWORD *)v3 + 22) = v8;
    v25 = 0;
    ((void (__cdecl *)(int, unsigned int, signed int, _DWORD, int *, __int32))a2)(v8, v7, 4, 0, &v25, a3);
    if ( *((_BYTE *)v3 + 16) )
    {
      BYTE2(v11) = BYTE1(v25);
      BYTE3(v11) = v25;
      LOBYTE(v11) = BYTE3(v25);
      BYTE1(v11) = BYTE2(v25);
      v12 = v11;
      v25 = v11;
    }
    else
    {
      v12 = v25;
    }
    v13 = *((_DWORD *)v3 + 2);
    v16 = v8 + 4;
    v14 = (__PAIR__(v10, v8) + 4) >> 32;
    v15 = v8 + 4;
    *((_DWORD *)v3 + 23) = v12;
    if ( v13 >= 0xE && v12 )
    {
      v14 = (__PAIR__(v14, v16) + 3) >> 32;
      v15 = (v16 + 3) & 0xFFFFFFFC;
    }
    v17 = AssetFileList::GetSizeBytes((AssetFileList *)&v25, v13);
    v18 = *((_DWORD *)v3 + 2);
    v21 = v17 + v15;
    v19 = (__PAIR__(v14, v17) + v15) >> 32;
    v20 = v17 + v15;
    if ( v18 < 0xB )
    {
      *((_DWORD *)v3 + 18) = 0;
      *((_DWORD *)v3 + 19) = 0;
    }
    else
    {
      v20 = PreloadList::Read(
              (AssetsFileHeader *)((char *)v3 + 72),
              __PAIR__(v19, v21),
              a2,
              a3,
              v18,
              *((_BYTE *)v3 + 16) != 0);
      v19 = v22;
    }
    AssetsFileDependencyList::Read(
      (AssetsFileHeader *)((char *)v3 + 80),
      __PAIR__(v19, v20),
      a2,
      a3,
      *((_DWORD *)v3 + 2),
      *((_BYTE *)v3 + 16) != 0);
  }
  else
  {
LABEL_21:
    *((_DWORD *)v3 + 18) = 0;
    *((_DWORD *)v3 + 19) = 0;
    *((_DWORD *)v3 + 22) = 0;
    *((_DWORD *)v3 + 23) = 0;
    *((_DWORD *)v3 + 14) = 0;
    *((_DWORD *)v3 + 20) = 0;
    *((_DWORD *)v3 + 21) = 0;
  }
  return v3;
}

//----- (1000FA00) --------------------------------------------------------
void __thiscall AssetsFile::~AssetsFile(AssetsFile *this)
{
  AssetsFile *v1; // esi@1
  unsigned int v2; // eax@1
  int v3; // edi@1
  unsigned int v4; // ebx@3
  int v5; // eax@4
  int v6; // eax@6
  int v7; // ebx@11
  int v8; // edx@12
  int v9; // edi@12
  unsigned int v10; // [sp+8h] [bp-4h]@10

  v1 = this;
  v2 = *((_DWORD *)this + 14);
  v3 = 0;
  if ( v2 )
  {
    if ( *((_DWORD *)this + 2) < 0xDu )
    {
      v10 = 0;
      if ( v2 > 0 )
      {
        v7 = 0;
        do
        {
          v8 = *((_DWORD *)v1 + 15);
          v9 = v8 + v7 + 4;
          if ( *(_DWORD *)(v8 + v7 + 536) )
          {
            do
              sub_1000D590(v9);
            while ( *(_DWORD *)(v9 + 532) );
          }
          v7 += 544;
          ++v10;
        }
        while ( v10 < *((_DWORD *)v1 + 14) );
      }
      free(*((void **)v1 + 15));
    }
    else
    {
      v4 = 0;
      if ( v2 > 0 )
      {
        do
        {
          v5 = *((_DWORD *)v1 + 15);
          if ( *(_DWORD *)(v5 + v3 + 48) )
            free(*(void **)(v5 + v3 + 52));
          v6 = *((_DWORD *)v1 + 15);
          if ( *(_DWORD *)(v6 + v3 + 40) )
            free(*(void **)(v6 + v3 + 44));
          ++v4;
          v3 += 56;
        }
        while ( v4 < *((_DWORD *)v1 + 14) );
      }
      free(*((void **)v1 + 15));
    }
    *((_DWORD *)v1 + 14) = 0;
    *((_DWORD *)v1 + 15) = 0;
  }
  if ( *((_DWORD *)v1 + 18) > 0u )
  {
    free(*((void **)v1 + 19));
    *((_DWORD *)v1 + 19) = 0;
    *((_DWORD *)v1 + 18) = 0;
  }
  if ( *((_DWORD *)v1 + 20) > 0u )
  {
    free(*((void **)v1 + 21));
    *((_DWORD *)v1 + 21) = 0;
    *((_DWORD *)v1 + 20) = 0;
  }
}

//----- (1000FB00) --------------------------------------------------------
bool __thiscall AssetsFile::GetAssetFile(AssetsFile *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), struct AssetFile *a4, __int32 a5)
{
  AssetsFile *v5; // ebx@1
  unsigned int v7; // eax@3
  signed int v8; // eax@5
  bool v9; // zf@8
  __int64 v10; // rax@10
  unsigned int v11; // ecx@12
  int v12; // eax@14
  int v13; // edx@14
  int v14; // [sp+10h] [bp-28h]@1
  int v15; // [sp+14h] [bp-24h]@1
  unsigned int v16; // [sp+18h] [bp-20h]@1
  int v17; // [sp+1Ch] [bp-1Ch]@1
  int v18; // [sp+20h] [bp-18h]@1
  int v19; // [sp+24h] [bp-14h]@1
  int v20; // [sp+28h] [bp-10h]@1
  int v21; // [sp+2Ch] [bp-Ch]@1

  v5 = this;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  if ( !a3 )
    return 0;
  v7 = *((_DWORD *)this + 2);
  if ( v7 >= 0x11 )
    goto LABEL_20;
  if ( v7 >= 0x10 )
  {
    v8 = 23;
    goto LABEL_10;
  }
  if ( v7 >= 0xF )
  {
    v8 = 25;
    goto LABEL_10;
  }
  v9 = v7 == 14;
  v8 = 24;
  if ( !v9 )
LABEL_20:
    v8 = 20;
LABEL_10:
  LODWORD(v10) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, __int32))a3)(
                   a2,
                   HIDWORD(a2),
                   v8,
                   0,
                   &v14,
                   a5);
  if ( !v10 )
    return 0;
  if ( *((_BYTE *)v5 + 16) )
  {
    v11 = (v16 >> 24) + ((v16 >> 8) & 0xFF00) + (((v16 << 16) + (v16 & 0xFF00)) << 8);
    v16 = (v16 >> 24) + ((v16 >> 8) & 0xFF00) + (((v16 << 16) + (v16 & 0xFF00)) << 8);
  }
  else
  {
    v11 = v16;
  }
  v12 = ((int (__cdecl *)(unsigned int, _DWORD, int, _DWORD, struct AssetFile *, __int32))a3)(
          v11 + *((_DWORD *)v5 + 3),
          0,
          v17,
          0,
          a4,
          a5);
  return v13 || v12;
}

//----- (1000FC40) --------------------------------------------------------
unsigned __int64 __thiscall AssetsFile::GetAssetFileOffs(AssetsFile *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4)
{
  AssetsFile *v4; // esi@1
  unsigned int v6; // eax@3
  signed int v7; // eax@5
  bool v8; // zf@8
  __int64 v9; // rax@10
  unsigned int v10; // ecx@12
  int v11; // [sp+8h] [bp-28h]@1
  int v12; // [sp+Ch] [bp-24h]@1
  unsigned int v13; // [sp+10h] [bp-20h]@1
  int v14; // [sp+14h] [bp-1Ch]@1
  int v15; // [sp+18h] [bp-18h]@1
  int v16; // [sp+1Ch] [bp-14h]@1
  int v17; // [sp+20h] [bp-10h]@1
  int v18; // [sp+24h] [bp-Ch]@1

  v4 = this;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  if ( !a3 )
    return 0i64;
  v6 = *((_DWORD *)this + 2);
  if ( v6 >= 0x11 )
    goto LABEL_17;
  if ( v6 >= 0x10 )
  {
    v7 = 23;
    goto LABEL_10;
  }
  if ( v6 >= 0xF )
  {
    v7 = 25;
    goto LABEL_10;
  }
  v8 = v6 == 14;
  v7 = 24;
  if ( !v8 )
LABEL_17:
    v7 = 20;
LABEL_10:
  LODWORD(v9) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, __int32))a3)(
                  a2,
                  HIDWORD(a2),
                  v7,
                  0,
                  &v11,
                  a4);
  if ( !v9 )
    return 0i64;
  if ( *((_BYTE *)v4 + 16) )
    v10 = (v13 >> 24) + ((v13 >> 8) & 0xFF00) + (((v13 << 16) + (v13 & 0xFF00)) << 8);
  else
    v10 = v13;
  return v10 + *((_DWORD *)v4 + 3);
}

//----- (1000FD30) --------------------------------------------------------
bool __thiscall AssetsFile::GetAssetFileByIndex(AssetsFile *this, unsigned __int64 a2, struct AssetFile *a3, unsigned int *a4, unsigned __int64 (__cdecl *a5)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a6)
{
  AssetsFile *v6; // edi@1
  __int32 v8; // ebx@3
  __int64 v9; // rax@3
  unsigned int v10; // ecx@3
  signed int v11; // ecx@5
  bool v12; // zf@8
  __int64 v13; // rax@10
  unsigned int v14; // ecx@12
  unsigned int v15; // eax@12
  int v16; // eax@14
  int v17; // edx@14
  int v18; // [sp+20h] [bp-28h]@1
  int v19; // [sp+24h] [bp-24h]@1
  unsigned int v20; // [sp+28h] [bp-20h]@1
  unsigned int v21; // [sp+2Ch] [bp-1Ch]@1
  int v22; // [sp+30h] [bp-18h]@1
  int v23; // [sp+34h] [bp-14h]@1
  int v24; // [sp+38h] [bp-10h]@1
  int v25; // [sp+3Ch] [bp-Ch]@1

  v6 = this;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  if ( !a5 )
    return 0;
  v8 = a6;
  v9 = AssetsFile::GetAssetFileInfoOffs(this, a2, a5, a6);
  v10 = *((_DWORD *)v6 + 2);
  if ( v10 >= 0x11 )
    goto LABEL_20;
  if ( v10 >= 0x10 )
  {
    v11 = 23;
    goto LABEL_10;
  }
  if ( v10 >= 0xF )
  {
    v11 = 25;
    goto LABEL_10;
  }
  v12 = v10 == 14;
  v11 = 24;
  if ( !v12 )
LABEL_20:
    v11 = 20;
LABEL_10:
  LODWORD(v13) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, __int32))a5)(
                   v9,
                   HIDWORD(v9),
                   v11,
                   0,
                   &v18,
                   a6);
  if ( !v13 )
    return 0;
  if ( *((_BYTE *)v6 + 16) )
  {
    v14 = (v20 >> 24) + ((v20 >> 8) & 0xFF00) + (((v20 << 16) + (v20 & 0xFF00)) << 8);
    v8 = a6;
    v15 = (v21 >> 24) + ((v21 >> 8) & 0xFF00) + (((v21 << 16) + (v21 & 0xFF00)) << 8);
    v20 = (v20 >> 24) + ((v20 >> 8) & 0xFF00) + (((v20 << 16) + (v20 & 0xFF00)) << 8);
    v21 = (v21 >> 24) + ((v21 >> 8) & 0xFF00) + (((v21 << 16) + (v21 & 0xFF00)) << 8);
  }
  else
  {
    v15 = v21;
    v14 = v20;
  }
  *a4 = v15;
  v16 = ((int (__cdecl *)(unsigned int, _DWORD, unsigned int, _DWORD, struct AssetFile *, __int32))a5)(
          v14 + *((_DWORD *)v6 + 3),
          0,
          v15,
          0,
          a3,
          v8);
  return v17 || v16;
}

//----- (1000FEC0) --------------------------------------------------------
unsigned __int64 __thiscall AssetsFile::GetAssetFileOffsByIndex(AssetsFile *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4)
{
  AssetsFile *v4; // edi@1
  unsigned __int64 result; // rax@2
  __int64 v6; // rax@3
  unsigned int v7; // ecx@3
  signed int v8; // ecx@5
  bool v9; // zf@8
  __int64 v10; // rax@10
  unsigned int v11; // ecx@12
  int v12; // [sp+10h] [bp-28h]@1
  int v13; // [sp+14h] [bp-24h]@1
  unsigned int v14; // [sp+18h] [bp-20h]@1
  int v15; // [sp+1Ch] [bp-1Ch]@1
  int v16; // [sp+20h] [bp-18h]@1
  int v17; // [sp+24h] [bp-14h]@1
  int v18; // [sp+28h] [bp-10h]@1
  int v19; // [sp+2Ch] [bp-Ch]@1

  v4 = this;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  if ( !a3 )
    goto LABEL_2;
  v6 = AssetsFile::GetAssetFileInfoOffs(this, a2, a3, a4);
  v7 = *((_DWORD *)v4 + 2);
  if ( v7 >= 0x11 )
    goto LABEL_18;
  if ( v7 >= 0x10 )
  {
    v8 = 23;
    goto LABEL_10;
  }
  if ( v7 >= 0xF )
  {
    v8 = 25;
    goto LABEL_10;
  }
  v9 = v7 == 14;
  v8 = 24;
  if ( !v9 )
LABEL_18:
    v8 = 20;
LABEL_10:
  LODWORD(v10) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, __int32))a3)(
                   v6,
                   HIDWORD(v6),
                   v8,
                   0,
                   &v12,
                   a4);
  if ( !v10 )
  {
LABEL_2:
    LODWORD(result) = 0;
    goto LABEL_15;
  }
  if ( *((_BYTE *)v4 + 16) )
    v11 = (v14 >> 24) + ((v14 >> 8) & 0xFF00) + (((v14 << 16) + (v14 & 0xFF00)) << 8);
  else
    v11 = v14;
  LODWORD(result) = v11 + *((_DWORD *)v4 + 3);
LABEL_15:
  HIDWORD(result) = 0;
  return result;
}

//----- (1000FFB0) --------------------------------------------------------
bool __thiscall AssetsFile::GetAssetFileByName(AssetsFile *this, const char *a2, struct AssetFile *a3, unsigned int *a4, unsigned __int64 (__cdecl *a5)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a6)
{
  AssetsFile *v6; // edi@1
  __int32 v8; // ebx@3
  unsigned __int64 v9; // rax@3
  unsigned int v10; // ecx@3
  signed int v11; // ecx@5
  bool v12; // zf@8
  __int64 v13; // rax@10
  unsigned int v14; // ecx@12
  unsigned int v15; // eax@12
  int v16; // eax@14
  int v17; // edx@14
  int v18; // [sp+20h] [bp-28h]@1
  int v19; // [sp+24h] [bp-24h]@1
  unsigned int v20; // [sp+28h] [bp-20h]@1
  unsigned int v21; // [sp+2Ch] [bp-1Ch]@1
  int v22; // [sp+30h] [bp-18h]@1
  int v23; // [sp+34h] [bp-14h]@1
  int v24; // [sp+38h] [bp-10h]@1
  int v25; // [sp+3Ch] [bp-Ch]@1

  v6 = this;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  if ( !a5 )
    return 0;
  v8 = a6;
  v9 = AssetsFile::GetAssetFileInfoOffsByName(this, a2, a5, a6);
  v10 = *((_DWORD *)v6 + 2);
  if ( v10 >= 0x11 )
    goto LABEL_20;
  if ( v10 >= 0x10 )
  {
    v11 = 23;
    goto LABEL_10;
  }
  if ( v10 >= 0xF )
  {
    v11 = 25;
    goto LABEL_10;
  }
  v12 = v10 == 14;
  v11 = 24;
  if ( !v12 )
LABEL_20:
    v11 = 20;
LABEL_10:
  LODWORD(v13) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, __int32))a5)(
                   v9,
                   HIDWORD(v9),
                   v11,
                   0,
                   &v18,
                   a6);
  if ( !v13 )
    return 0;
  if ( *((_BYTE *)v6 + 16) )
  {
    v14 = (v20 >> 24) + ((v20 >> 8) & 0xFF00) + (((v20 << 16) + (v20 & 0xFF00)) << 8);
    v8 = a6;
    v15 = (v21 >> 24) + ((v21 >> 8) & 0xFF00) + (((v21 << 16) + (v21 & 0xFF00)) << 8);
    v20 = (v20 >> 24) + ((v20 >> 8) & 0xFF00) + (((v20 << 16) + (v20 & 0xFF00)) << 8);
    v21 = (v21 >> 24) + ((v21 >> 8) & 0xFF00) + (((v21 << 16) + (v21 & 0xFF00)) << 8);
  }
  else
  {
    v15 = v21;
    v14 = v20;
  }
  *a4 = v15;
  v16 = ((int (__cdecl *)(unsigned int, _DWORD, unsigned int, _DWORD, struct AssetFile *, __int32))a5)(
          v14 + *((_DWORD *)v6 + 3),
          0,
          v15,
          0,
          a3,
          v8);
  return v17 || v16;
}

//----- (10010130) --------------------------------------------------------
unsigned __int64 __thiscall AssetsFile::GetAssetFileOffsByName(AssetsFile *this, const char *a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4)
{
  AssetsFile *v4; // edi@1
  unsigned __int64 result; // rax@2
  unsigned __int64 v6; // rax@3
  unsigned int v7; // ecx@3
  signed int v8; // ecx@5
  bool v9; // zf@8
  __int64 v10; // rax@10
  unsigned int v11; // ecx@12
  int v12; // [sp+10h] [bp-28h]@1
  int v13; // [sp+14h] [bp-24h]@1
  unsigned int v14; // [sp+18h] [bp-20h]@1
  int v15; // [sp+1Ch] [bp-1Ch]@1
  int v16; // [sp+20h] [bp-18h]@1
  int v17; // [sp+24h] [bp-14h]@1
  int v18; // [sp+28h] [bp-10h]@1
  int v19; // [sp+2Ch] [bp-Ch]@1

  v4 = this;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  if ( !a3 )
    goto LABEL_2;
  v6 = AssetsFile::GetAssetFileInfoOffsByName(this, a2, a3, a4);
  v7 = *((_DWORD *)v4 + 2);
  if ( v7 >= 0x11 )
    goto LABEL_18;
  if ( v7 >= 0x10 )
  {
    v8 = 23;
    goto LABEL_10;
  }
  if ( v7 >= 0xF )
  {
    v8 = 25;
    goto LABEL_10;
  }
  v9 = v7 == 14;
  v8 = 24;
  if ( !v9 )
LABEL_18:
    v8 = 20;
LABEL_10:
  LODWORD(v10) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, __int32))a3)(
                   v6,
                   HIDWORD(v6),
                   v8,
                   0,
                   &v12,
                   a4);
  if ( !v10 )
  {
LABEL_2:
    LODWORD(result) = 0;
    goto LABEL_15;
  }
  if ( *((_BYTE *)v4 + 16) )
    v11 = (v14 >> 24) + ((v14 >> 8) & 0xFF00) + (((v14 << 16) + (v14 & 0xFF00)) << 8);
  else
    v11 = v14;
  LODWORD(result) = v11 + *((_DWORD *)v4 + 3);
LABEL_15:
  HIDWORD(result) = 0;
  return result;
}

//----- (10010220) --------------------------------------------------------
__int64 __thiscall AssetsFile::GetAssetFileInfoOffs(AssetsFile *this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4)
{
  AssetsFile *v4; // esi@1
  unsigned int v5; // edi@2
  __int64 v6; // rax@3
  unsigned __int64 v7; // kr08_8@6
  AssetFileList *v8; // eax@6
  AssetFileList *v9; // esi@6
  int v10; // eax@7
  AssetFileList *v12; // [sp+Ch] [bp-14h]@3
  AssetFileList *v13; // [sp+10h] [bp-10h]@5
  AssetsFile *v14; // [sp+14h] [bp-Ch]@1
  unsigned __int64 v15; // [sp+18h] [bp-8h]@1

  v4 = this;
  v14 = this;
  v15 = 0i64;
  if ( a3 )
  {
    v5 = *((_DWORD *)this + 22);
    if ( *((_DWORD *)this + 22) )
    {
      LODWORD(v6) = ((int (__cdecl *)(unsigned int, _DWORD, signed int, _DWORD, AssetFileList **, __int32))a3)(
                      v5,
                      0,
                      4,
                      0,
                      &v12,
                      a4);
      if ( v6 )
      {
        if ( *((_BYTE *)v4 + 16) )
        {
          BYTE2(v13) = BYTE1(v12);
          BYTE3(v13) = (_BYTE)v12;
          LOBYTE(v13) = BYTE3(v12);
          BYTE1(v13) = BYTE2(v12);
          v12 = v13;
        }
        v7 = v5 + 4i64;
        v8 = (AssetFileList *)malloc(32 * (_DWORD)v12 + 8);
        v9 = v8;
        if ( v8 )
        {
          *(_DWORD *)v8 = v12;
          AssetFileList::Read(v8, *((_DWORD *)v14 + 2), v7, a3, a4, *((_BYTE *)v14 + 16) != 0);
          v10 = 0;
          if ( *(_DWORD *)v9 )
          {
            v13 = (AssetFileList *)((char *)v9 + 8);
            while ( *(_QWORD *)v13 != a2 )
            {
              v13 = (AssetFileList *)((char *)v13 + 32);
              if ( (unsigned int)++v10 >= *(_DWORD *)v9 )
                goto LABEL_13;
            }
            v15 = v7 + (unsigned int)(32 * v10 + 8);
          }
LABEL_13:
          free((void *)v9);
        }
      }
    }
  }
  return v15;
}

//----- (10010340) --------------------------------------------------------
unsigned __int64 __thiscall AssetsFile::GetAssetFileInfoOffsByName(AssetsFile *this, const char *a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a4)
{
  AssetsFile *v4; // ebx@1
  unsigned int v5; // edi@2
  bool v6; // zf@2
  __int64 v7; // rax@3
  int v8; // ST34_4@5
  int v9; // esi@5
  int v10; // edi@7
  unsigned int v11; // et0@7
  bool v12; // cf@7
  AssetFileList *v13; // edi@9
  unsigned int *v14; // esi@11
  unsigned int v15; // edi@14
  unsigned int v17; // [sp+10h] [bp-90h]@10
  int v18; // [sp+14h] [bp-8Ch]@3
  unsigned __int64 v19; // [sp+18h] [bp-88h]@2
  AssetFileList *v20; // [sp+20h] [bp-80h]@9
  unsigned int *v21; // [sp+24h] [bp-7Ch]@11
  unsigned __int64 v22; // [sp+28h] [bp-78h]@1
  unsigned __int64 (__cdecl *v23)(unsigned __int64, unsigned __int64, void *, __int32); // [sp+30h] [bp-70h]@1
  char v24; // [sp+34h] [bp-6Ch]@20
  char v25; // [sp+68h] [bp-38h]@20

  v4 = this;
  v23 = a3;
  v22 = 0i64;
  if ( !a3 )
    return v22;
  v5 = *((_DWORD *)this + 22);
  v6 = *((_DWORD *)this + 22) == 0;
  HIDWORD(v19) = 0;
  if ( v6 )
    return v22;
  LODWORD(v7) = ((int (__cdecl *)(unsigned int, _DWORD, signed int, _DWORD, int *, __int32))a3)(v5, 0, 4, 0, &v18, a4);
  if ( !v7 )
    return v22;
  if ( *((_BYTE *)v4 + 16) )
  {
    BYTE3(v8) = v18;
    *(_WORD *)((char *)&v8 + 1) = __PAIR__(BYTE1(v18), BYTE2(v18));
    LOBYTE(v8) = BYTE3(v18);
    v9 = v8;
    v18 = v8;
  }
  else
  {
    v9 = v18;
  }
  v11 = (__PAIR__(HIDWORD(v19), v5) + 4) >> 32;
  v10 = v5 + 4;
  v12 = *((_DWORD *)v4 + 2) < 0xEu;
  v19 = __PAIR__(v11, v10);
  if ( !v12 )
    v19 = (__PAIR__(HIDWORD(v19), v10) + 3) & 0xFFFFFFFFFFFFFFFCui64;
  v13 = (AssetFileList *)malloc(32 * v9 + 8);
  v20 = v13;
  if ( !v13 )
    return v22;
  *(_DWORD *)v13 = v9;
  AssetFileList::Read(v13, *((_DWORD *)v4 + 2), v19, v23, a4, *((_BYTE *)v4 + 16) != 0);
  v17 = 0;
  if ( !*(_DWORD *)v13 )
    goto LABEL_26;
  v14 = (unsigned int *)((char *)v13 + 24);
  v21 = (unsigned int *)((char *)v13 + 24);
  while ( 1 )
  {
    if ( *((_DWORD *)v4 + 2) < 0x10u )
    {
      v15 = *v14;
      goto LABEL_17;
    }
    if ( *v14 < *((_DWORD *)v4 + 14) )
      break;
LABEL_23:
    v14 += 8;
    ++v17;
    v21 = v14;
    if ( v17 >= *(_DWORD *)v13 )
      goto LABEL_26;
  }
  v15 = *(_DWORD *)(*((_DWORD *)v4 + 15) + 56 * *v14);
  if ( !HasName(v15) )
  {
LABEL_22:
    v13 = v20;
    goto LABEL_23;
  }
LABEL_17:
  if ( v15 > 0x122 )
    goto LABEL_22;
  if ( v15 != 290 )
  {
    switch ( v15 )
    {
      case 0x15u:
      case 0x1Bu:
      case 0x1Cu:
      case 0x2Bu:
      case 0x30u:
      case 0x31u:
      case 0x3Eu:
      case 0x48u:
      case 0x4Au:
      case 0x53u:
      case 0x54u:
      case 0x59u:
      case 0x5Au:
      case 0x5Bu:
      case 0x5Du:
      case 0x6Du:
      case 0x73u:
      case 0x75u:
      case 0x79u:
      case 0x80u:
      case 0x86u:
      case 0x8Eu:
      case 0x96u:
      case 0x98u:
      case 0x9Cu:
      case 0x9Eu:
      case 0xABu:
      case 0xB8u:
      case 0xB9u:
      case 0xBAu:
      case 0xC2u:
      case 0xC8u:
      case 0xCFu:
      case 0xD5u:
      case 0xDDu:
      case 0xE2u:
      case 0xE4u:
      case 0xEDu:
      case 0xEEu:
      case 0xF0u:
      case 0x102u:
      case 0x10Fu:
      case 0x110u:
      case 0x111u:
        goto LABEL_20;
      default:
        goto LABEL_22;
    }
    goto LABEL_22;
  }
LABEL_20:
  memset(&v24, 0, 0x32u);
  ((void (__cdecl *)(unsigned int, _DWORD, signed int, _DWORD, char *, __int32))v23)(
    *((_DWORD *)v4 + 3) + *(v14 - 2),
    0,
    50,
    0,
    &v24,
    a4);
  if ( strcmp(AssetFile::GetFileName((AssetFile *)&v24, &v25, 0x32u, v15), a2) )
  {
    v14 = v21;
    goto LABEL_22;
  }
  v13 = v20;
  v22 = v19 + 32 * v17 + 8;
LABEL_26:
  free((void *)v13);
  return v22;
}

//----- (100106A0) --------------------------------------------------------
unsigned __int64 __thiscall AssetsFile::GetFileList(AssetsFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3)
{
  return *((_DWORD *)this + 22);
}

//----- (100106B0) --------------------------------------------------------
unsigned __int32 __cdecl SwapEndians(unsigned __int32 a1)
{
  return (a1 >> 24) + ((a1 >> 8) & 0xFF00) + (((a1 << 16) + (a1 & 0xFF00)) << 8);
}

//----- (100106E0) --------------------------------------------------------
void __cdecl SwapEndians_(unsigned __int32 *a1)
{
  *a1 = *((_BYTE *)a1 + 3) + ((*a1 >> 8) & 0xFF00) + (((*a1 & 0xFF00) + (*a1 << 16)) << 8);
}

//----- (10010710) --------------------------------------------------------
char __cdecl StringIsValid(char *a1, int a2)
{
  int v2; // eax@1
  char result; // al@4

  v2 = 0;
  if ( a2 <= 0 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    while ( a1[v2] >= 32 )
    {
      if ( ++v2 >= a2 )
        goto LABEL_4;
    }
    result = 0;
  }
  return result;
}

//----- (10010740) --------------------------------------------------------
char __cdecl HasName(unsigned __int32 a1)
{
  if ( a1 <= 0x122 )
  {
    if ( a1 == 290 )
      return 1;
    switch ( a1 )
    {
      case 0x15u:
      case 0x1Bu:
      case 0x1Cu:
      case 0x2Bu:
      case 0x30u:
      case 0x31u:
      case 0x3Eu:
      case 0x48u:
      case 0x4Au:
      case 0x53u:
      case 0x54u:
      case 0x59u:
      case 0x5Au:
      case 0x5Bu:
      case 0x5Du:
      case 0x6Du:
      case 0x73u:
      case 0x75u:
      case 0x79u:
      case 0x80u:
      case 0x86u:
      case 0x8Eu:
      case 0x96u:
      case 0x98u:
      case 0x9Cu:
      case 0x9Eu:
      case 0xABu:
      case 0xB8u:
      case 0xB9u:
      case 0xBAu:
      case 0xC2u:
      case 0xC8u:
      case 0xCFu:
      case 0xD5u:
      case 0xDDu:
      case 0xE2u:
      case 0xE4u:
      case 0xEDu:
      case 0xEEu:
      case 0xF0u:
      case 0x102u:
      case 0x10Fu:
      case 0x110u:
      case 0x111u:
        return 1;
      default:
        return 0;
    }
  }
  return 0;
}

//----- (10010880) --------------------------------------------------------
char __thiscall AssetsFile::VerifyAssetsFile(AssetsFile *this, void (__cdecl *a2)(char *))
{
  void (__cdecl *v2)(char *); // ebx@1
  AssetFileList *v3; // edi@1
  AssetsFile *v4; // esi@1
  unsigned int v6; // eax@5
  char v7; // cl@9
  unsigned int v8; // eax@12
  unsigned int v9; // ebx@15
  int (__cdecl *v10)(int, _DWORD, signed int, _DWORD, size_t *, int); // eax@15
  int v11; // ST14_4@15
  int v12; // ST00_4@15
  __int64 v13; // rax@15
  unsigned int v14; // ebx@19
  unsigned int v15; // edi@19
  bool v16; // cf@19
  unsigned int v17; // edi@20
  AssetFileList *v18; // eax@21
  unsigned int v19; // eax@23
  char *v20; // eax@25
  unsigned int v21; // eax@26
  __int64 v22; // rax@28
  char v23; // [sp+Fh] [bp-F1h]@16
  void (__cdecl *v24)(char *); // [sp+10h] [bp-F0h]@1
  size_t v25; // [sp+14h] [bp-ECh]@1
  size_t v26; // [sp+18h] [bp-E8h]@18
  char v27; // [sp+1Fh] [bp-E1h]@28
  unsigned int v28; // [sp+24h] [bp-DCh]@19
  char v29; // [sp+28h] [bp-D8h]@12
  char v30; // [sp+90h] [bp-70h]@31

  v2 = a2;
  v3 = 0;
  v4 = this;
  v24 = a2;
  v25 = 0;
  if ( !a2 )
  {
    v24 = (void (__cdecl *)(char *))AssetTypeValue::~AssetTypeValue;
    v2 = (void (__cdecl *)(char *))AssetTypeValue::~AssetTypeValue;
  }
  if ( !*((_DWORD *)this + 24) )
  {
    v2("ERROR : The AssetsFileReader is NULL!");
    return 0;
  }
  v6 = *((_DWORD *)this + 2);
  if ( !v6 || v6 > 0x40 )
  {
    v20 = "Invalid file format";
    goto LABEL_33;
  }
  if ( *((_BYTE *)this + 16) )
    v2("WARNING : Big endianness support is limited to reading!");
  v7 = *((_BYTE *)v4 + 20);
  if ( !v7 || v7 < 48 || v7 > 57 )
  {
    sub_10010FF0("Invalid version string at %X", 20);
    v20 = &v30;
    goto LABEL_33;
  }
  sub_10010FF0("INFO : The .assets file was built with Unity version '%s'.", (char *)v4 + 20);
  v2(&v29);
  v8 = *((_DWORD *)v4 + 2);
  if ( v8 > 0xF || v8 < 8 )
    v2("WARNING : AssetsTools (for .assets versions 8-15) wasn't tested with this .assets' version, likely parsing the file won't work properly!");
  v9 = *((_DWORD *)v4 + 22);
  v10 = (int (__cdecl *)(int, _DWORD, signed int, _DWORD, size_t *, int))*((_DWORD *)v4 + 24);
  v11 = *((_DWORD *)v4 + 25);
  v12 = *((_DWORD *)v4 + 22);
  v25 = 0;
  LODWORD(v13) = v10(v12, 0, 4, 0, &v25, v11);
  if ( v13 )
  {
    if ( *((_BYTE *)v4 + 16) )
    {
      BYTE2(v26) = BYTE1(v25);
      BYTE3(v26) = v25;
      LOBYTE(v26) = BYTE3(v25);
      BYTE1(v26) = BYTE2(v25);
      v25 = v26;
    }
    v15 = ((unsigned __int64)v9 + 4) >> 32;
    v14 = v9 + 4;
    v16 = *((_DWORD *)v4 + 2) < 0xEu;
    v28 = v15;
    if ( !v16 )
    {
      v17 = (__PAIR__(v15, v14) + 3) >> 32;
      v14 = (v14 + 3) & 0xFFFFFFFC;
      v28 = v17;
    }
    v26 = 32 * v25 + 8;
    v18 = (AssetFileList *)malloc(v26);
    v3 = v18;
    if ( !v18 )
    {
      v23 = 0;
      sub_10010FF0("ERROR : Out of Memory : Allocating %u bytes failed!", v26);
      v24(&v29);
      return v23;
    }
    *(_DWORD *)v18 = v25;
    AssetFileList::Read(
      v18,
      *((_DWORD *)v4 + 2),
      __PAIR__(v28, v14),
      *((unsigned __int64 (__cdecl **)(unsigned __int64, unsigned __int64, void *, __int32))v4 + 24),
      *((_DWORD *)v4 + 25),
      *((_BYTE *)v4 + 16) != 0);
    v19 = AssetFileList::GetSizeBytes(v3, *((_DWORD *)v4 + 2));
    sub_10010FF0("INFO : The .assets file has %u files (info list : %u bytes).", *(_DWORD *)v3, v19);
    v2 = v24;
    v24(&v29);
    if ( *(_DWORD *)v3 )
    {
      if ( *(_DWORD *)v4 < 8u )
      {
        v20 = "Invalid metadata size";
LABEL_33:
        v23 = 0;
        sub_10010FF0("ERROR : Invalid .assets file (error message : '%s')!", v20);
        v2(&v29);
LABEL_34:
        if ( v3 )
          free((void *)v3);
        return v23;
      }
      v21 = *((_DWORD *)v3 + 8 * *(_DWORD *)v3 - 3) + *((_DWORD *)v4 + 3) + *((_DWORD *)v3 + 8 * *(_DWORD *)v3 - 4) - 1;
      if ( v21 < *(_DWORD *)v4 )
      {
        v2 = v24;
        v20 = "Last asset begins before the header ends";
        goto LABEL_33;
      }
      LODWORD(v22) = (*((int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v4 + 24))(
                       v21,
                       0,
                       1,
                       0,
                       &v27,
                       *((_DWORD *)v4 + 25));
      if ( !v22 )
      {
        v2 = v24;
        v20 = "File data are cut off";
        goto LABEL_33;
      }
    }
    v24("SUCCESS : The Assets file seems to be ok!");
    v23 = 1;
    goto LABEL_34;
  }
  v23 = 0;
  sub_10010FF0("ERROR : Invalid .assets file (reading %u bytes at %X in the .assets file failed)!", 4, v9);
  v24(&v29);
  return v23;
}

//----- (10010B60) --------------------------------------------------------
unsigned int __thiscall sub_10010B60(unsigned int *this, unsigned int a2)
{
  unsigned int *v2; // esi@1
  unsigned int result; // eax@3
  char *v4; // eax@4
  const void *v5; // ebx@4
  const void *v6; // edx@4
  unsigned int v7; // edx@4
  int v8; // ebx@4
  int v9; // [sp+0h] [bp-24h]@1
  char *v10; // [sp+10h] [bp-14h]@4
  int *v11; // [sp+14h] [bp-10h]@1
  int v12; // [sp+20h] [bp-4h]@4

  v11 = &v9;
  v2 = this;
  if ( a2 > 0x4924924 )
    std::_Xlength_error("vector<T> too long");
  result = (signed int)(v2[2] - *v2) / 56;
  if ( result < a2 )
  {
    v4 = (char *)sub_10010E50(a2);
    v12 = 0;
    v5 = (const void *)v2[1];
    v6 = (const void *)*v2;
    v10 = v4;
    sub_10011010(v4, v6, v5);
    v7 = (signed int)(v2[1] - *v2 + ((unsigned __int64)(-1840700269i64 * (signed int)(v2[1] - *v2)) >> 32)) >> 5;
    v8 = v7 + (v7 >> 31);
    if ( *v2 )
      operator delete((void *)*v2);
    result = (unsigned int)v10;
    v2[2] = (unsigned int)&v10[56 * a2];
    v2[1] = result + 56 * v8;
    *v2 = result;
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10010C43) --------------------------------------------------------
void __usercall __noreturn sub_10010C43(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 20));
  CxxThrowException(0, 0);
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10010C60) --------------------------------------------------------
unsigned int __thiscall sub_10010C60(unsigned int *this, unsigned int a2)
{
  unsigned int *v2; // esi@1
  unsigned int v3; // ecx@1
  unsigned int result; // eax@3
  char *v5; // eax@4
  const void *v6; // ebx@4
  const void *v7; // edx@4
  unsigned int v8; // edx@4
  int v9; // ebx@4
  int v10; // ecx@6
  int v11; // [sp+0h] [bp-24h]@1
  char *v12; // [sp+10h] [bp-14h]@4
  int *v13; // [sp+14h] [bp-10h]@1
  int v14; // [sp+20h] [bp-4h]@4

  v13 = &v11;
  v2 = this;
  v3 = a2;
  if ( a2 > 0x5555555 )
    std::_Xlength_error("vector<T> too long");
  result = (signed int)(v2[2] - *v2) / 48;
  if ( result < v3 )
  {
    v5 = (char *)sub_10010EB0(v3);
    v14 = 0;
    v6 = (const void *)v2[1];
    v7 = (const void *)*v2;
    v12 = v5;
    sub_10011040(v5, v7, v6);
    v8 = (signed int)((unsigned __int64)(715827883i64 * (signed int)(v2[1] - *v2)) >> 32) >> 3;
    v9 = v8 + (v8 >> 31);
    if ( *v2 )
      operator delete((void *)*v2);
    result = (unsigned int)v12;
    v10 = (int)&v12[48 * v9];
    v2[2] = (unsigned int)&v12[48 * a2];
    v2[1] = v10;
    *v2 = result;
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10010D35) --------------------------------------------------------
void __usercall __noreturn sub_10010D35(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 20));
  CxxThrowException(0, 0);
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10010D50) --------------------------------------------------------
char *__usercall sub_10010D50@<eax>(unsigned int a1@<eax>, int a2@<esi>)
{
  const void *v2; // ecx@1
  unsigned int v3; // ebx@1
  char *result; // eax@1
  void *v5; // edi@2
  int v6; // eax@5

  v2 = *(const void **)(a2 + 4);
  v3 = a1;
  result = (char *)((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 2);
  if ( (unsigned int)result <= v3 )
  {
    if ( (unsigned int)result < v3 )
    {
      sub_10010F10(a2, v3 - (_DWORD)result);
      v6 = (*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 2;
      if ( v3 != v6 )
        memset(*(void **)(a2 + 4), 0, 4 * (v3 - v6));
      result = *(char **)(a2 + 4);
      *(_DWORD *)(a2 + 4) = &result[4 * (v3 - ((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 2))];
    }
  }
  else
  {
    v5 = (void *)(*(_DWORD *)a2 + 4 * v3);
    if ( v5 != v2 )
    {
      result = (char *)memmove(v5, v2, 0);
      *(_DWORD *)(a2 + 4) = v5;
    }
  }
  return result;
}

//----- (10010DD0) --------------------------------------------------------
unsigned int __thiscall sub_10010DD0(int this)
{
  unsigned int v1; // ebx@1
  unsigned int v2; // edx@1
  unsigned int v3; // esi@1
  unsigned int v4; // esi@3
  unsigned int result; // eax@3
  unsigned int v6; // eax@5

  v1 = *(_DWORD *)this;
  v2 = (signed int)(*(_DWORD *)(this + 4)
                  - *(_DWORD *)this
                  + ((unsigned __int64)(-1840700269i64 * (*(_DWORD *)(this + 4) - *(_DWORD *)this)) >> 32)) >> 5;
  v3 = v2 + (v2 >> 31);
  if ( v3 > 0x4924923 )
    std::_Xlength_error("vector<T> too long");
  v4 = v3 + 1;
  result = (signed int)(*(_DWORD *)(this + 8) - v1) / 56;
  if ( v4 > result )
  {
    if ( 76695844 - (result >> 1) >= result )
      v6 = (result >> 1) + result;
    else
      v6 = 0;
    if ( v6 < v4 )
      v6 = v4;
    result = sub_10010B60((unsigned int *)this, v6);
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);

//----- (10010E50) --------------------------------------------------------
void *__fastcall sub_10010E50(unsigned int a1)
{
  void *result; // eax@1
  int (__stdcall **v2)(char); // [sp+0h] [bp-10h]@4
  int v3; // [sp+Ch] [bp-4h]@4

  result = 0;
  if ( a1 )
  {
    if ( a1 > 0x4924924 || (result = operator new(56 * a1)) == 0 )
    {
      v3 = 0;
      std::exception::exception((std::exception *)&v2, (const char *const *)&v3);
      v2 = &off_10099840;
      CxxThrowException(&v2, &unk_100A5EA0);
    }
  }
  return result;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (10010EB0) --------------------------------------------------------
void *__fastcall sub_10010EB0(unsigned int a1)
{
  void *result; // eax@1
  int (__stdcall **v2)(char); // [sp+0h] [bp-10h]@4
  int v3; // [sp+Ch] [bp-4h]@4

  result = 0;
  if ( a1 )
  {
    if ( a1 > 0x5555555 || (result = operator new(48 * a1)) == 0 )
    {
      v3 = 0;
      std::exception::exception((std::exception *)&v2, (const char *const *)&v3);
      v2 = &off_10099840;
      CxxThrowException(&v2, &unk_100A5EA0);
    }
  }
  return result;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (10010F10) --------------------------------------------------------
unsigned int __usercall sub_10010F10@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // eax@1
  unsigned int result; // eax@3
  unsigned int v6; // ecx@3
  unsigned int v7; // ecx@5

  v2 = a1;
  v3 = *(_DWORD *)a1;
  v4 = (*(_DWORD *)(a1 + 4) - *(_DWORD *)a1) >> 2;
  if ( 0x3FFFFFFF - a2 < v4 )
    std::_Xlength_error("vector<T> too long");
  result = a2 + v4;
  v6 = (*(_DWORD *)(v2 + 8) - v3) >> 2;
  if ( result > v6 )
  {
    if ( 0x3FFFFFFF - (v6 >> 1) >= v6 )
      v7 = (v6 >> 1) + v6;
    else
      v7 = 0;
    if ( v7 < result )
      v7 = result;
    result = sub_10010F70(v2, v7);
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);

//----- (10010F70) --------------------------------------------------------
unsigned int __userpurge sub_10010F70@<eax>(int a1@<esi>, unsigned int a2)
{
  unsigned int v2; // ecx@1
  unsigned int result; // eax@3
  void *v4; // ebx@4
  int v5; // edi@4

  v2 = a2;
  if ( a2 > 0x3FFFFFFF )
    std::_Xlength_error("vector<T> too long");
  result = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1) >> 2;
  if ( result < v2 )
  {
    v4 = sub_1000ADF0(v2);
    memmove(v4, *(const void **)a1, 4 * ((*(_DWORD *)(a1 + 4) - *(_DWORD *)a1) >> 2));
    v5 = (*(_DWORD *)(a1 + 4) - *(_DWORD *)a1) >> 2;
    if ( *(_DWORD *)a1 )
      operator delete(*(void **)a1);
    result = (unsigned int)v4 + 4 * a2;
    *(_DWORD *)a1 = v4;
    *(_DWORD *)(a1 + 8) = result;
    *(_DWORD *)(a1 + 4) = (char *)v4 + 4 * v5;
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10010FF0) --------------------------------------------------------
int sub_10010FF0(char *Format, ...)
{
  char *v1; // edx@0
  va_list va; // [sp+Ch] [bp+Ch]@1

  va_start(va, Format);
  return vsprintf_s(v1, 0x64u, Format, va);
}
// 10010FF0: can not handle register arguments in vararg function, discarded them

//----- (10011010) --------------------------------------------------------
void *__usercall sub_10011010@<eax>(void *result@<eax>, const void *a2@<edx>, const void *a3@<ebx>)
{
  for ( ; a2 != a3; result = (char *)result + 56 )
  {
    if ( result )
      qmemcpy(result, a2, 0x38u);
    a2 = (char *)a2 + 56;
  }
  return result;
}

//----- (10011040) --------------------------------------------------------
void *__usercall sub_10011040@<eax>(void *result@<eax>, const void *a2@<edx>, const void *a3@<ebx>)
{
  for ( ; a2 != a3; result = (char *)result + 48 )
  {
    if ( result )
      qmemcpy(result, a2, 0x30u);
    a2 = (char *)a2 + 48;
  }
  return result;
}

//----- (10011070) --------------------------------------------------------
int __thiscall AssetsFileTable::AssetsFileTable(int this, int a2, char a3)
{
  int v3; // ebx@1
  int v4; // ST14_4@1
  unsigned int v5; // esi@1
  void (__cdecl *v6)(int, _DWORD, signed int, _DWORD, void **, int); // eax@1
  int v7; // ST00_4@1
  void *v8; // eax@1
  int v9; // esi@3
  unsigned int v10; // et0@3
  bool v11; // cf@3
  int v12; // esi@5
  void *v13; // eax@5
  void *v14; // ecx@5
  int v15; // esi@6
  unsigned __int64 v16; // rax@7
  int v17; // ecx@10
  int v18; // eax@10
  int v19; // edx@10
  int v20; // eax@15
  int v21; // eax@15
  int v22; // edi@18
  int v23; // esi@22
  _DWORD *v24; // edi@25
  signed int v25; // ecx@25
  int v26; // eax@25
  void *v28; // [sp+Ch] [bp-1Ch]@1
  void *v29; // [sp+10h] [bp-18h]@2
  int v30; // [sp+14h] [bp-14h]@1
  unsigned int v31; // [sp+18h] [bp-10h]@5
  int v32; // [sp+1Ch] [bp-Ch]@5
  unsigned __int64 v33; // [sp+20h] [bp-8h]@1

  v3 = this;
  *(_DWORD *)this = a2;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 96);
  v4 = *(_DWORD *)(a2 + 100);
  *(_DWORD *)(this + 8) = v4;
  v5 = *(_DWORD *)(a2 + 88);
  v6 = *(void (__cdecl **)(int, _DWORD, signed int, _DWORD, void **, int))(this + 4);
  v7 = *(_DWORD *)(a2 + 88);
  v30 = this;
  HIDWORD(v33) = 0;
  v6(v7, 0, 4, 0, &v28, v4);
  v8 = v28;
  if ( *(_BYTE *)(a2 + 16) )
  {
    BYTE2(v29) = BYTE1(v28);
    BYTE3(v29) = (_BYTE)v28;
    LOBYTE(v29) = BYTE3(v28);
    BYTE1(v29) = BYTE2(v28);
    v8 = v29;
    v28 = v29;
  }
  v10 = (__PAIR__(HIDWORD(v33), v5) + 4) >> 32;
  v9 = v5 + 4;
  v11 = *(_DWORD *)(a2 + 8) < 0xEu;
  v33 = __PAIR__(v10, v9);
  if ( !v11 )
    v33 = (__PAIR__(HIDWORD(v33), v9) + 3) & 0xFFFFFFFFFFFFFFFCui64;
  *(_DWORD *)(v3 + 16) = v8;
  v12 = unknown_libname_4(152 * (_DWORD)v8 | -(152 * (unsigned __int64)(unsigned int)v8 >> 32 != 0));
  v32 = v12;
  v13 = malloc(0x78u);
  v14 = v28;
  v29 = v13;
  v31 = 0;
  if ( v28 )
  {
    v15 = v12 + 16;
    while ( 1 )
    {
      v16 = AssetFileInfo::Read(
              (AssetFileInfo *)(v15 - 16),
              *(_DWORD *)(a2 + 8),
              v33,
              (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32))*(_DWORD *)(v3 + 4),
              *(_DWORD *)(v3 + 8),
              *(_BYTE *)(a2 + 16) != 0);
      v11 = *(_DWORD *)(a2 + 8) < 0x10u;
      v33 = v16;
      if ( v11 )
        break;
      if ( *(_DWORD *)v15 < *(_DWORD *)(a2 + 56) )
      {
        v17 = *(_DWORD *)(a2 + 60);
        v18 = 56 * *(_DWORD *)v15;
        v19 = *(_DWORD *)(v17 + v18);
        if ( *(_WORD *)(v17 + v18 + 6) == -1 )
        {
          v3 = v30;
          *(_WORD *)(v15 + 4) = v19;
          *(_WORD *)(v15 + 6) = -1;
LABEL_14:
          *(_DWORD *)(v15 + 16) = v19;
          goto LABEL_15;
        }
        *(_DWORD *)(v15 + 16) = -1 - *(_WORD *)(v18 + v17 + 6);
        v3 = v30;
        *(_WORD *)(v15 + 4) = v19;
        *(_WORD *)(v15 + 6) = *(_WORD *)(v18 + *(_DWORD *)(a2 + 60) + 6);
      }
      else
      {
        *(_DWORD *)(v15 + 16) = 2147483648;
        *(_DWORD *)(v15 + 4) = -1;
      }
LABEL_15:
      v20 = *(_DWORD *)(a2 + 12) + *(_DWORD *)(v15 - 8);
      *(_DWORD *)(v15 + 28) = 0;
      *(_DWORD *)(v15 + 24) = v20;
      v21 = v31;
      *(_BYTE *)(v15 + 32) = 0;
      v14 = v28;
      v15 += 152;
      v31 = v21 + 1;
      if ( v21 + 1 >= (unsigned int)v28 )
        goto LABEL_16;
    }
    v19 = *(_DWORD *)v15;
    goto LABEL_14;
  }
LABEL_16:
  if ( a3 )
  {
    v31 = 0;
    if ( v14 )
    {
      v22 = v32 + 32;
      v30 = v32 + 32;
      do
      {
        if ( *(_DWORD *)v22 <= 0x122u )
        {
          if ( *(_DWORD *)v22 != 290 )
          {
            switch ( *(_DWORD *)v22 )
            {
              case 0x15:
              case 0x1B:
              case 0x1C:
              case 0x2B:
              case 0x30:
              case 0x31:
              case 0x3E:
              case 0x48:
              case 0x4A:
              case 0x53:
              case 0x54:
              case 0x59:
              case 0x5A:
              case 0x5B:
              case 0x5D:
              case 0x6D:
              case 0x73:
              case 0x75:
              case 0x79:
              case 0x80:
              case 0x86:
              case 0x8E:
              case 0x96:
              case 0x98:
              case 0x9C:
              case 0x9E:
              case 0xAB:
              case 0xB8:
              case 0xB9:
              case 0xBA:
              case 0xC2:
              case 0xC8:
              case 0xCF:
              case 0xD5:
              case 0xDD:
              case 0xE2:
              case 0xE4:
              case 0xED:
              case 0xEE:
              case 0xF0:
              case 0x102:
              case 0x10F:
              case 0x110:
              case 0x111:
                goto LABEL_22;
              default:
                goto LABEL_32;
            }
            goto LABEL_32;
          }
LABEL_22:
          v23 = v22 + 16;
          (*(void (__cdecl **)(_DWORD, _DWORD, signed int, _DWORD, void *, _DWORD))(v3 + 4))(
            *(_DWORD *)(v22 + 8),
            *(_DWORD *)(v22 + 12),
            120,
            0,
            v29,
            *(_DWORD *)(v3 + 8));
          if ( *(_DWORD *)v22 <= 0x122u )
          {
            if ( *(_DWORD *)v22 == 290 )
            {
LABEL_25:
              v24 = v29;
              v25 = *(_DWORD *)v29;
              v26 = 0;
              if ( *(_DWORD *)v29 <= 0 )
              {
LABEL_28:
                if ( (unsigned int)(v25 + 1) <= 0x64 )
                {
                  memcpy((void *)v23, (char *)v29 + 4, *(_DWORD *)v29);
                  *(_BYTE *)(v23 + *v24) = 0;
                }
                else
                {
                  memcpy((void *)v23, (char *)v29 + 4, 0x60u);
                  *(_DWORD *)(v23 + 96) = 3026478;
                }
                goto LABEL_32;
              }
              while ( *((_BYTE *)v29 + v26 + 4) >= 32 )
              {
                if ( ++v26 >= v25 )
                  goto LABEL_28;
              }
            }
            else
            {
              switch ( *(_DWORD *)v22 )
              {
                case 0x15:
                case 0x1B:
                case 0x1C:
                case 0x2B:
                case 0x30:
                case 0x31:
                case 0x3E:
                case 0x48:
                case 0x4A:
                case 0x53:
                case 0x54:
                case 0x59:
                case 0x5A:
                case 0x5B:
                case 0x5D:
                case 0x6D:
                case 0x73:
                case 0x75:
                case 0x79:
                case 0x80:
                case 0x86:
                case 0x8E:
                case 0x96:
                case 0x98:
                case 0x9C:
                case 0x9E:
                case 0xAB:
                case 0xB8:
                case 0xB9:
                case 0xBA:
                case 0xC2:
                case 0xC8:
                case 0xCF:
                case 0xD5:
                case 0xDD:
                case 0xE2:
                case 0xE4:
                case 0xED:
                case 0xEE:
                case 0xF0:
                case 0x102:
                case 0x10F:
                case 0x110:
                case 0x111:
                  goto LABEL_25;
                default:
                  break;
              }
            }
          }
          *(_BYTE *)v23 = 0;
        }
LABEL_32:
        v22 = v30 + 152;
        ++v31;
        v30 += 152;
      }
      while ( v31 < (unsigned int)v28 );
    }
  }
  free(v29);
  *(_DWORD *)(v3 + 12) = v32;
  return v3;
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);

//----- (10011560) --------------------------------------------------------
void __thiscall AssetsFileTable::~AssetsFileTable(AssetsFileTable *this)
{
  if ( *((_DWORD *)this + 3) )
    operator delete[](*((void **)this + 3));
}
// 10099190: using guessed type void __cdecl operator delete[](void *);

//----- (10011570) --------------------------------------------------------
struct AssetFileInfoEx *__thiscall AssetsFileTable::getAssetInfo(AssetsFileTable *this, unsigned __int64 a2)
{
  unsigned int v2; // edx@1
  unsigned int v3; // eax@1
  int v4; // edi@2
  _QWORD *v5; // ecx@2
  struct AssetFileInfoEx *result; // eax@5

  v2 = *((_DWORD *)this + 4);
  v3 = 0;
  if ( v2 )
  {
    v4 = *((_DWORD *)this + 3);
    v5 = (_QWORD *)*((_DWORD *)this + 3);
    while ( *v5 != a2 )
    {
      ++v3;
      v5 += 19;
      if ( v3 >= v2 )
        goto LABEL_5;
    }
    result = (struct AssetFileInfoEx *)(v4 + 152 * v3);
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (100115C0) --------------------------------------------------------
struct AssetFileInfoEx *__thiscall AssetsFileTable::getAssetInfo(AssetsFileTable *this, const char *a2)
{
  unsigned int v2; // edi@1
  int v3; // ebx@2
  unsigned int v4; // eax@3
  unsigned int v5; // edi@4
  const char *v6; // esi@5
  char v7; // cl@6
  char v8; // dl@9
  int v10; // [sp+Ch] [bp-10h]@2
  unsigned int v11; // [sp+10h] [bp-Ch]@1
  unsigned int v12; // [sp+14h] [bp-8h]@1
  const char *v13; // [sp+18h] [bp-4h]@2

  v2 = *((_DWORD *)this + 4);
  v12 = 0;
  v11 = v2;
  if ( v2 )
  {
    v10 = *((_DWORD *)this + 3);
    v13 = (const char *)(v10 + 48);
    v3 = v10 - (_DWORD)a2 + 48;
    do
    {
      v4 = strlen(v13);
      if ( strlen(a2) == v4 )
      {
        v5 = 0;
        if ( !v4 )
          return (struct AssetFileInfoEx *)(v10 + 152 * v12);
        v6 = a2;
        while ( 1 )
        {
          v7 = v6[v3];
          if ( v7 >= 65 && v7 <= 90 )
            v7 += 32;
          v8 = *v6;
          if ( *v6 >= 65 && v8 <= 90 )
            v8 += 32;
          if ( v7 != v8 )
            break;
          ++v5;
          ++v6;
          if ( v5 >= v4 )
            return (struct AssetFileInfoEx *)(v10 + 152 * v12);
        }
        v2 = v11;
      }
      v13 += 152;
      v3 += 152;
      ++v12;
    }
    while ( v12 < v2 );
  }
  return 0;
}

//----- (10011690) --------------------------------------------------------
struct AssetFileInfoEx *__thiscall AssetsFileTable::getAssetInfo(AssetsFileTable *this, const char *a2, unsigned __int32 a3)
{
  unsigned int v3; // edi@1
  int v4; // ecx@2
  _DWORD *v5; // ebx@2
  char *v6; // ecx@4
  char v7; // dl@5
  unsigned int v8; // eax@6
  unsigned int v9; // edi@7
  const char *v10; // esi@8
  int v11; // ebx@8
  char v12; // cl@9
  char v13; // dl@12
  int v15; // [sp+Ch] [bp-14h]@2
  unsigned int v16; // [sp+10h] [bp-10h]@1
  int v17; // [sp+18h] [bp-8h]@2
  unsigned int v18; // [sp+1Ch] [bp-4h]@1

  v3 = *((_DWORD *)this + 4);
  v18 = 0;
  v16 = v3;
  if ( v3 )
  {
    v4 = *((_DWORD *)this + 3);
    v5 = (_DWORD *)(v4 + 32);
    v15 = v4;
    v17 = v4 + 32;
    do
    {
      if ( *v5 == a3 )
      {
        v6 = (char *)(v5 + 4);
        do
          v7 = *v6++;
        while ( v7 );
        v8 = v6 - ((char *)v5 + 17);
        if ( strlen(a2) == v8 )
        {
          v9 = 0;
          if ( !v8 )
            return (struct AssetFileInfoEx *)(v15 + 152 * v18);
          v10 = a2;
          v11 = (int)v5 + 16 - (_DWORD)a2;
          while ( 1 )
          {
            v12 = v10[v11];
            if ( v12 >= 65 && v12 <= 90 )
              v12 += 32;
            v13 = *v10;
            if ( *v10 >= 65 && v13 <= 90 )
              v13 += 32;
            if ( v12 != v13 )
              break;
            ++v9;
            ++v10;
            if ( v9 >= v8 )
              return (struct AssetFileInfoEx *)(v15 + 152 * v18);
          }
          v3 = v16;
          v5 = (_DWORD *)v17;
        }
      }
      v5 += 38;
      ++v18;
      v17 = (int)v5;
    }
    while ( v18 < v3 );
  }
  return 0;
}

//----- (10011770) --------------------------------------------------------
struct AssetsFile *__thiscall AssetsFileTable::getAssetsFile(AssetsFileTable *this)
{
  return *(struct AssetsFile **)this;
}

//----- (10011780) --------------------------------------------------------
unsigned __int64 (__cdecl *__thiscall AssetsFileTable::getReader(AssetsFileTable *this))(unsigned __int64, unsigned __int64, void *, __int32)
{
  return (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32))*((_DWORD *)this + 1);
}

//----- (10011790) --------------------------------------------------------
__int32 __thiscall AssetsFileTable::getReaderPar(AssetsFileTable *this)
{
  return *((_DWORD *)this + 2);
}

//----- (100117B0) --------------------------------------------------------
void *__thiscall sub_100117B0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_100A1D64;
  if ( a2 & 1 )
    operator delete(this);
  return v2;
}
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100A1D64: using guessed type void *off_100A1D64;

//----- (100117E0) --------------------------------------------------------
int __thiscall sub_100117E0(int this)
{
  return *(_DWORD *)(this + 16);
}

//----- (100117F0) --------------------------------------------------------
__int64 sub_100117F0()
{
  return 0i64;
}

//----- (10011800) --------------------------------------------------------
__int64 __stdcall sub_10011800(__int64 a1, int a2, int a3)
{
  return a1;
}

//----- (10011810) --------------------------------------------------------
__int64 __thiscall sub_10011810(char *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4)
{
  __int64 v4; // rax@1
  __int64 v5; // rdi@1
  __int64 v6; // rax@1
  __int64 v7; // rdi@1
  __int64 v8; // rax@1
  __int64 v9; // rdi@1
  __int64 v10; // rax@1
  __int64 v11; // rdi@1
  __int64 v12; // rax@1
  __int64 v13; // rdi@1
  __int64 v14; // rax@1
  char v16; // [sp+13h] [bp-Dh]@1
  char *v17; // [sp+14h] [bp-Ch]@1
  int v18; // [sp+18h] [bp-8h]@1
  int v19; // [sp+1Ch] [bp-4h]@1

  v17 = this;
  v18 = 0;
  LODWORD(v4) = a3(a2, HIDWORD(a2), 2, 0, &v18, a4);
  v5 = v4 + a2;
  v16 = 0;
  LODWORD(v6) = a3(v5, HIDWORD(v5), 1, 0, (int *)&v16, a4);
  v7 = v6 + v5;
  v19 = 0;
  LODWORD(v8) = a3(v7, HIDWORD(v7), 4, 0, &v19, a4);
  v9 = v8 + v7;
  LODWORD(v10) = a3(v9, HIDWORD(v9), 8, 0, (int *)v17 + 2, a4);
  v11 = v10 + v9;
  LODWORD(v12) = a3(v11, HIDWORD(v11), 4, 0, (int *)v17 + 4, a4);
  v13 = v12 + v11;
  LODWORD(v14) = a3(v13, HIDWORD(v13), 2, 0, (int *)v17 + 5, a4);
  return v13 + v14;
}

//----- (100118D0) --------------------------------------------------------
int __userpurge sub_100118D0@<eax>(int result@<eax>, int a2@<ecx>, int a3, int a4, int a5, __int16 a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13)
{
  *(_DWORD *)(result + 4) = a2;
  *(_DWORD *)(result + 8) = a3;
  *(_DWORD *)(result + 12) = a4;
  *(_DWORD *)(result + 16) = a5;
  *(_WORD *)(result + 20) = a6;
  *(_DWORD *)(result + 24) = a7;
  *(_DWORD *)(result + 28) = a8;
  *(_DWORD *)(result + 32) = a9;
  *(_DWORD *)(result + 36) = a10;
  *(_DWORD *)(result + 40) = a11;
  *(_DWORD *)result = &off_100A1DB4;
  *(_DWORD *)(result + 44) = a12;
  *(_DWORD *)(result + 48) = a13;
  return result;
}
// 100A1DB4: using guessed type unsigned __int32 (__thiscall *off_100A1DB4)(AssetFile *__hidden this);

//----- (10011940) --------------------------------------------------------
__int16 __thiscall sub_10011940(int this)
{
  return *(_WORD *)(this + 20);
}

//----- (10011950) --------------------------------------------------------
int __thiscall sub_10011950(int this, __int64 a2, void (__cdecl *a3)(_DWORD, _DWORD, _DWORD, _DWORD, char *, int), int a4)
{
  int v4; // ebx@1
  int result; // eax@2
  __int64 v6; // rdi@3
  int v7; // eax@7
  unsigned int v8; // ecx@7
  int v9; // esi@14
  char *v10; // [sp+Ch] [bp-124h]@3
  __int64 v11; // [sp+10h] [bp-120h]@7
  __int64 v12; // [sp+18h] [bp-118h]@7
  char v13; // [sp+28h] [bp-108h]@3

  v4 = this;
  if ( *(_QWORD *)(this + 32) )
  {
    HIDWORD(v6) = *(_DWORD *)(this + 48);
    LODWORD(v6) = 256;
    v10 = &v13;
    if ( HIDWORD(v6) > 0x100 )
    {
      v10 = (char *)malloc(HIDWORD(v6));
      if ( v10 )
        LODWORD(v6) = HIDWORD(v6);
      else
        v10 = &v13;
    }
    v7 = *(_DWORD *)(v4 + 36);
    v8 = *(_DWORD *)(v4 + 32);
    LODWORD(v12) = *(_DWORD *)(v4 + 40);
    HIDWORD(v6) = 0;
    v11 = *(_QWORD *)(v4 + 32);
    HIDWORD(v12) = *(_DWORD *)(v4 + 44);
    if ( v7 || v8 > (unsigned int)v6 )
    {
      do
      {
        do
        {
          (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))(v4 + 24))(
            v12,
            HIDWORD(v12),
            v6,
            0,
            v10,
            *(_DWORD *)(v4 + 28));
          v11 -= v6;
          v12 += v6;
          a3(a2, HIDWORD(a2), v6, 0, v10, a4);
          a2 += v6;
        }
        while ( HIDWORD(v11) > 0 );
      }
      while ( (unsigned int)v11 > (unsigned int)v6 );
      v7 = HIDWORD(v11);
      v8 = v11;
    }
    if ( v7 || v8 )
    {
      (*(void (__cdecl **)(_DWORD, _DWORD, unsigned int, int, char *, _DWORD))(v4 + 24))(
        v12,
        HIDWORD(v12),
        v8,
        v7,
        v10,
        *(_DWORD *)(v4 + 28));
      a3(a2, HIDWORD(a2), v11, HIDWORD(v11), v10, a4);
      v9 = v11 + a2;
    }
    else
    {
      v9 = a2;
    }
    if ( (unsigned int)v6 > 0x100 )
      free(v10);
    result = v9;
  }
  else
  {
    result = a2;
  }
  return result;
}

//----- (10011AE0) --------------------------------------------------------
int __thiscall sub_10011AE0(char *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4)
{
  __int64 v4; // rax@1
  __int64 v5; // rdi@1
  __int64 v6; // rax@1
  __int64 v7; // rdi@1
  __int64 v8; // rax@1
  __int64 v9; // rdi@1
  __int64 v10; // rax@1
  __int64 v11; // rdi@1
  __int64 v12; // rax@1
  __int64 v13; // rdi@1
  __int64 v14; // rax@1
  __int64 v15; // rdi@1
  __int64 v16; // rax@1
  char v18; // [sp+13h] [bp-Dh]@1
  char *v19; // [sp+14h] [bp-Ch]@1
  int v20; // [sp+18h] [bp-8h]@1
  int v21; // [sp+1Ch] [bp-4h]@1

  v19 = this;
  v20 = 2;
  LODWORD(v4) = a3(a2, HIDWORD(a2), 2, 0, &v20, a4);
  v5 = v4 + a2;
  v18 = 0;
  LODWORD(v6) = a3(v5, HIDWORD(v5), 1, 0, (int *)&v18, a4);
  v7 = v6 + v5;
  v21 = 0;
  LODWORD(v8) = a3(v7, HIDWORD(v7), 4, 0, &v21, a4);
  v9 = v8 + v7;
  LODWORD(v10) = a3(v9, HIDWORD(v9), 8, 0, (int *)v19 + 2, a4);
  v11 = v10 + v9;
  LODWORD(v12) = a3(v11, HIDWORD(v11), 4, 0, (int *)v19 + 4, a4);
  v13 = v12 + v11;
  LODWORD(v14) = a3(v13, HIDWORD(v13), 2, 0, (int *)v19 + 5, a4);
  v15 = v14 + v13;
  LODWORD(v16) = a3(v15, HIDWORD(v15), 8, 0, (int *)v19 + 8, a4);
  return (*(int (__stdcall **)(_DWORD, _DWORD, int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int))(*(_DWORD *)v19 + 28))(
           v16 + v15,
           (unsigned __int64)(v16 + v15) >> 32,
           a3,
           a4);
}

//----- (10011BD0) --------------------------------------------------------
int __userpurge sub_10011BD0@<eax>(int result@<eax>, int a2@<ecx>, int a3, int a4, int a5, __int16 a6, int a7, int a8, int a9)
{
  *(_DWORD *)(result + 4) = a2;
  *(_DWORD *)(result + 8) = a3;
  *(_DWORD *)(result + 12) = a4;
  *(_DWORD *)(result + 16) = a5;
  *(_WORD *)(result + 20) = a6;
  *(_DWORD *)(result + 24) = a7;
  *(_DWORD *)result = &off_100A1DDC;
  *(_DWORD *)(result + 28) = a8;
  *(_DWORD *)(result + 32) = a9;
  return result;
}
// 100A1DDC: using guessed type unsigned __int32 (__thiscall *off_100A1DDC)(AssetFile *__hidden this);

//----- (10011C10) --------------------------------------------------------
void *__thiscall sub_10011C10(int this, char a2)
{
  void *v2; // esi@1
  void (__cdecl *v3)(_DWORD); // eax@1

  v2 = (void *)this;
  *(_DWORD *)this = &off_100A1DDC;
  v3 = *(void (__cdecl **)(_DWORD))(this + 32);
  if ( v3 )
    v3(*(_DWORD *)(this + 24));
  *(_DWORD *)v2 = &off_100A1D64;
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100A1D64: using guessed type void *off_100A1D64;
// 100A1DDC: using guessed type unsigned __int32 (__thiscall *off_100A1DDC)(AssetFile *__hidden this);

//----- (10011C80) --------------------------------------------------------
__int64 __thiscall sub_10011C80(int this)
{
  return *(_DWORD *)(this + 28);
}

//----- (10011C90) --------------------------------------------------------
__int64 __thiscall sub_10011C90(int this, __int64 a2, void (__cdecl *a3)(_DWORD, _DWORD, int, _DWORD, _DWORD, int), int a4)
{
  int v4; // esi@1
  int v5; // eax@1
  __int64 result; // rax@2

  v4 = this;
  v5 = *(_DWORD *)(this + 28);
  if ( v5 )
  {
    a3(a2, HIDWORD(a2), v5, 0, *(_DWORD *)(this + 24), a4);
    result = a2 + *(_DWORD *)(v4 + 28);
  }
  else
  {
    result = a2;
  }
  return result;
}

//----- (10011CE0) --------------------------------------------------------
int __thiscall sub_10011CE0(char *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4)
{
  __int64 v4; // rax@1
  __int64 v5; // rdi@1
  __int64 v6; // rax@1
  __int64 v7; // rdi@1
  __int64 v8; // rax@1
  __int64 v9; // rdi@1
  __int64 v10; // rax@1
  __int64 v11; // rdi@1
  __int64 v12; // rax@1
  __int64 v13; // rdi@1
  __int64 v14; // rax@1
  __int64 v15; // rdi@1
  __int64 v16; // rax@1
  char v18; // [sp+13h] [bp-15h]@1
  char *v19; // [sp+14h] [bp-14h]@1
  int v20; // [sp+18h] [bp-10h]@1
  int v21; // [sp+1Ch] [bp-Ch]@1
  int v22; // [sp+20h] [bp-8h]@1
  int v23; // [sp+24h] [bp-4h]@1

  v19 = this;
  v20 = 2;
  LODWORD(v4) = a3(a2, HIDWORD(a2), 2, 0, &v20, a4);
  v5 = v4 + a2;
  v18 = 0;
  LODWORD(v6) = a3(v5, HIDWORD(v5), 1, 0, (int *)&v18, a4);
  v7 = v6 + v5;
  v21 = 0;
  LODWORD(v8) = a3(v7, HIDWORD(v7), 4, 0, &v21, a4);
  v9 = v8 + v7;
  LODWORD(v10) = a3(v9, HIDWORD(v9), 8, 0, (int *)v19 + 2, a4);
  v11 = v10 + v9;
  LODWORD(v12) = a3(v11, HIDWORD(v11), 4, 0, (int *)v19 + 4, a4);
  v13 = v12 + v11;
  LODWORD(v14) = a3(v13, HIDWORD(v13), 2, 0, (int *)v19 + 5, a4);
  v15 = v14 + v13;
  v22 = *((_DWORD *)v19 + 7);
  v23 = 0;
  LODWORD(v16) = a3(v15, HIDWORD(v15), 8, 0, &v22, a4);
  return (*(int (__stdcall **)(_DWORD, _DWORD, int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int))(*(_DWORD *)v19 + 28))(
           v16 + v15,
           (unsigned __int64)(v16 + v15) >> 32,
           a3,
           a4);
}

//----- (10011DE0) --------------------------------------------------------
void *__thiscall sub_10011DE0(int this, char a2)
{
  void *v2; // esi@1
  bool v3; // zf@1

  v2 = (void *)this;
  v3 = *(_BYTE *)(this + 52) == 0;
  *(_DWORD *)this = &off_100A1E04;
  if ( !v3 )
    fclose(*(FILE **)(this + 24));
  *(_DWORD *)v2 = &off_100A1D64;
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100A1D64: using guessed type void *off_100A1D64;
// 100A1E04: using guessed type unsigned __int32 (__thiscall *off_100A1E04)(AssetFile *__hidden this);

//----- (10011E20) --------------------------------------------------------
__int64 __thiscall sub_10011E20(int this)
{
  return *(_QWORD *)(this + 40);
}

//----- (10011E30) --------------------------------------------------------
int __thiscall sub_10011E30(int this, __int64 a2, void (__cdecl *a3)(_DWORD, _DWORD, size_t, unsigned int, char *, int), int a4)
{
  int v4; // edi@1
  int result; // eax@2
  size_t v6; // ebx@3
  size_t v7; // esi@3
  unsigned int v8; // ebx@7
  unsigned int v9; // kr00_4@9
  int v10; // edi@13
  char *v11; // [sp+Ch] [bp-11Ch]@3
  size_t v12; // [sp+10h] [bp-118h]@7
  int v13; // [sp+1Ch] [bp-10Ch]@1
  char v14; // [sp+20h] [bp-108h]@3

  v4 = this;
  v13 = this;
  if ( *(_QWORD *)(this + 40) )
  {
    v6 = *(_DWORD *)(this + 48);
    v7 = 256;
    v11 = &v14;
    if ( v6 > 0x100 )
    {
      v11 = (char *)malloc(v6);
      if ( v11 )
        v7 = v6;
      else
        v11 = &v14;
    }
    v8 = *(_DWORD *)(v4 + 44);
    v12 = *(_DWORD *)(v4 + 40);
    fseek(*(FILE **)(v4 + 24), *(_DWORD *)(v4 + 32), 0);
    if ( v8 || v12 > v7 )
    {
      do
      {
        do
        {
          fread(v11, v7, 1u, *(FILE **)(v13 + 24));
          v9 = v12 - v7;
          v8 = (__PAIR__(v8, v12) - v7) >> 32;
          v12 -= v7;
          a3(a2, HIDWORD(a2), v7, 0, v11, a4);
          a2 += v7;
        }
        while ( v8 > 0 );
      }
      while ( v9 > v7 );
    }
    if ( v8 || v12 > 0 )
    {
      fread(v11, v12, 1u, *(FILE **)(v13 + 24));
      a3(a2, HIDWORD(a2), v12, v8, v11, a4);
      v10 = v12 + a2;
    }
    else
    {
      v10 = a2;
    }
    if ( v7 > 0x100 )
      free(v11);
    result = v10;
  }
  else
  {
    result = a2;
  }
  return result;
}

//----- (10011FA0) --------------------------------------------------------
int __thiscall sub_10011FA0(char *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4)
{
  __int64 v4; // rax@1
  __int64 v5; // rdi@1
  __int64 v6; // rax@1
  __int64 v7; // rdi@1
  __int64 v8; // rax@1
  __int64 v9; // rdi@1
  __int64 v10; // rax@1
  __int64 v11; // rdi@1
  __int64 v12; // rax@1
  __int64 v13; // rdi@1
  __int64 v14; // rax@1
  __int64 v15; // rdi@1
  __int64 v16; // rax@1
  char v18; // [sp+13h] [bp-Dh]@1
  char *v19; // [sp+14h] [bp-Ch]@1
  int v20; // [sp+18h] [bp-8h]@1
  int v21; // [sp+1Ch] [bp-4h]@1

  v19 = this;
  v20 = 2;
  LODWORD(v4) = a3(a2, HIDWORD(a2), 2, 0, &v20, a4);
  v5 = v4 + a2;
  v18 = 0;
  LODWORD(v6) = a3(v5, HIDWORD(v5), 1, 0, (int *)&v18, a4);
  v7 = v6 + v5;
  v21 = 0;
  LODWORD(v8) = a3(v7, HIDWORD(v7), 4, 0, &v21, a4);
  v9 = v8 + v7;
  LODWORD(v10) = a3(v9, HIDWORD(v9), 8, 0, (int *)v19 + 2, a4);
  v11 = v10 + v9;
  LODWORD(v12) = a3(v11, HIDWORD(v11), 4, 0, (int *)v19 + 4, a4);
  v13 = v12 + v11;
  LODWORD(v14) = a3(v13, HIDWORD(v13), 2, 0, (int *)v19 + 5, a4);
  v15 = v14 + v13;
  LODWORD(v16) = a3(v15, HIDWORD(v15), 8, 0, (int *)v19 + 10, a4);
  return (*(int (__stdcall **)(_DWORD, _DWORD, int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int))(*(_DWORD *)v19 + 28))(
           v16 + v15,
           (unsigned __int64)(v16 + v15) >> 32,
           a3,
           a4);
}

//----- (10012090) --------------------------------------------------------
struct AssetsReplacer *__cdecl ReadAssetsReplacer(unsigned __int64 *a1, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, bool a4)
{
  unsigned __int64 *v4; // esi@1
  unsigned __int64 v5; // ST30_8@1
  int v6; // eax@1
  unsigned __int8 v7; // cf@1
  int v8; // edx@1
  unsigned __int64 v9; // ST18_8@1
  int v10; // eax@1
  int v11; // edx@1
  int v12; // edx@1
  int v13; // eax@1
  int v14; // eax@1
  int v15; // edx@1
  int v16; // eax@1
  int v17; // eax@1
  int v18; // edx@1
  int v19; // eax@1
  int v20; // edx@1
  int v21; // eax@1
  int v22; // eax@1
  int v23; // edx@1
  int v24; // eax@3
  __int64 v25; // rax@3
  char *v26; // eax@4
  int v27; // eax@5
  int v28; // edx@5
  void *v29; // eax@5
  struct AssetsReplacer *result; // eax@6
  void *v31; // eax@9
  __int16 v32; // cx@15
  int v33; // edx@15
  int v34; // esi@15
  int v35; // edi@15
  int v36; // ebx@15
  unsigned __int8 v37; // [sp+13h] [bp-2Dh]@1
  int v38; // [sp+14h] [bp-2Ch]@1
  int v39; // [sp+18h] [bp-28h]@1
  int v40; // [sp+1Ch] [bp-24h]@1
  int v41; // [sp+20h] [bp-20h]@1
  char *v42; // [sp+24h] [bp-1Ch]@4
  size_t v43; // [sp+28h] [bp-18h]@3
  int v44; // [sp+2Ch] [bp-14h]@3
  int v45; // [sp+30h] [bp-10h]@1
  int v46; // [sp+34h] [bp-Ch]@1
  int v47; // [sp+3Ch] [bp-4h]@5

  v4 = a1;
  v5 = *a1;
  v41 = 0xFFFF;
  v6 = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, __int32))a2)(v5, HIDWORD(v5), 2, 0, &v41, a3);
  v7 = __CFADD__(v6, *(_DWORD *)a1);
  *(_DWORD *)v4 += v6;
  *((_DWORD *)v4 + 1) += v8 + v7;
  v9 = *a1;
  v37 = 0;
  v10 = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, unsigned __int8 *, __int32))a2)(
          v9,
          HIDWORD(v9),
          1,
          0,
          &v37,
          a3);
  v7 = __CFADD__(v10, *(_DWORD *)a1);
  *(_DWORD *)v4 += v10;
  *((_DWORD *)v4 + 1) += v11 + v7;
  v12 = *((_DWORD *)a1 + 1);
  v40 = 0;
  v45 = 0;
  v46 = 0;
  v39 = 0;
  v38 = 0;
  v13 = ((int (__cdecl *)(int, int, signed int, _DWORD, int *, __int32))a2)(*(_DWORD *)a1, v12, 4, 0, &v40, a3);
  v7 = __CFADD__(v13, *(_DWORD *)a1);
  *(_DWORD *)v4 += v13;
  v14 = *(_DWORD *)a1;
  *((_DWORD *)v4 + 1) += v15 + v7;
  v16 = ((int (__cdecl *)(int, _DWORD, signed int, _DWORD, int *, __int32))a2)(v14, *((_DWORD *)a1 + 1), 8, 0, &v45, a3);
  v7 = __CFADD__(v16, *(_DWORD *)a1);
  *(_DWORD *)v4 += v16;
  v17 = *(_DWORD *)a1;
  *((_DWORD *)v4 + 1) += v18 + v7;
  v19 = ((int (__cdecl *)(int, _DWORD, signed int, _DWORD, int *, __int32))a2)(v17, *((_DWORD *)a1 + 1), 4, 0, &v39, a3);
  v7 = __CFADD__(v19, *(_DWORD *)a1);
  *(_DWORD *)v4 += v19;
  *((_DWORD *)v4 + 1) += v20 + v7;
  v21 = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, __int32))a2)(
          *(_DWORD *)v4,
          *((_DWORD *)v4 + 1),
          2,
          0,
          &v38,
          a3);
  v7 = __CFADD__(v21, *(_DWORD *)a1);
  *(_DWORD *)v4 += v21;
  v22 = (unsigned __int16)v41;
  *((_DWORD *)v4 + 1) += v23 + v7;
  if ( !v22 )
  {
    if ( v37 <= 0u )
    {
      result = (struct AssetsReplacer *)operator new(0x18u);
      if ( result )
      {
        v32 = v38;
        v33 = v39;
        v34 = v45;
        v35 = v46;
        v36 = v40;
        *(_DWORD *)result = &off_100A1D8C;
        *((_DWORD *)result + 1) = v36;
        *((_DWORD *)result + 2) = v34;
        *((_DWORD *)result + 3) = v35;
        *((_DWORD *)result + 4) = v33;
        *((_WORD *)result + 10) = v32;
        return result;
      }
    }
    return 0;
  }
  if ( (unsigned int)(v22 - 1) > 2 )
    return 0;
  v24 = *((_DWORD *)a1 + 1);
  v43 = 0;
  v44 = 0;
  LODWORD(v25) = ((int (__cdecl *)(_DWORD, int, signed int, _DWORD, size_t *, __int32))a2)(
                   *(_DWORD *)a1,
                   v24,
                   8,
                   0,
                   &v43,
                   a3);
  *a1 += v25;
  if ( !a4
    || (v26 = (char *)malloc(v43), (v42 = v26) == 0)
    || ((v27 = ((int (__cdecl *)(_DWORD, _DWORD, size_t, int, char *, __int32))a2)(
                 *(_DWORD *)a1,
                 *((_DWORD *)a1 + 1),
                 v43,
                 v44,
                 v26,
                 a3),
         v47 = v28,
         memset(&v42[v27], 0, v43 - v27),
         (v29 = operator new(0x28u)) == 0) ? (result = 0) : (result = (struct AssetsReplacer *)sub_10011BD0(
                                                                                                 (int)v29,
                                                                                                 v40,
                                                                                                 v45,
                                                                                                 v46,
                                                                                                 v39,
                                                                                                 v38,
                                                                                                 (int)v42,
                                                                                                 v43,
                                                                                                 (int)Free_PartialAssetsFileReader)),
        !result) )
  {
    v31 = operator new(0x38u);
    if ( v31 )
    {
      result = (struct AssetsReplacer *)sub_100118D0(
                                          (int)v31,
                                          v40,
                                          v45,
                                          v46,
                                          v39,
                                          v38,
                                          (int)a2,
                                          a3,
                                          v43,
                                          v44,
                                          *(_DWORD *)a1,
                                          *((_DWORD *)a1 + 1),
                                          0);
      v7 = __CFADD__(v43, *(_DWORD *)a1);
      *(_DWORD *)a1 += v43;
      *((_DWORD *)a1 + 1) += v44 + v7;
      return result;
    }
    result = 0;
  }
  v7 = __CFADD__(v43, *(_DWORD *)a1);
  *(_DWORD *)a1 += v43;
  *((_DWORD *)a1 + 1) += v44 + v7;
  return result;
}
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 100A1D8C: using guessed type int (*off_100A1D8C)();

//----- (100122F0) --------------------------------------------------------
struct AssetsReplacer *__cdecl MakeAssetRemover(unsigned __int32 a1, unsigned __int64 a2, int a3, unsigned __int16 a4)
{
  struct AssetsReplacer *result; // eax@1

  result = (struct AssetsReplacer *)operator new(0x18u);
  if ( result )
  {
    *((_DWORD *)result + 1) = a1;
    *((_QWORD *)result + 1) = a2;
    *(_DWORD *)result = &off_100A1D8C;
    *((_DWORD *)result + 4) = a3;
    *((_WORD *)result + 10) = a4;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 100A1D8C: using guessed type int (*off_100A1D8C)();

//----- (10012330) --------------------------------------------------------
struct AssetsReplacer *__cdecl MakeAssetModifierFromReader(unsigned __int32 a1, unsigned __int64 a2, int a3, unsigned __int16 a4, unsigned __int64 (__cdecl *a5)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a6, unsigned __int64 a7, unsigned __int64 a8, unsigned int a9)
{
  struct AssetsReplacer *result; // eax@1

  result = (struct AssetsReplacer *)operator new(0x38u);
  if ( result )
  {
    *((_DWORD *)result + 1) = a1;
    *((_QWORD *)result + 1) = a2;
    *((_DWORD *)result + 4) = a3;
    *((_WORD *)result + 10) = a4;
    *((_DWORD *)result + 6) = a5;
    *((_DWORD *)result + 7) = a6;
    *((_QWORD *)result + 4) = a7;
    *((_DWORD *)result + 10) = a8;
    *(_DWORD *)result = &off_100A1DB4;
    *((_DWORD *)result + 11) = HIDWORD(a8);
    *((_DWORD *)result + 12) = a9;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 100A1DB4: using guessed type unsigned __int32 (__thiscall *off_100A1DB4)(AssetFile *__hidden this);

//----- (100123A0) --------------------------------------------------------
struct AssetsReplacer *__cdecl MakeAssetModifierFromMemory(unsigned __int32 a1, unsigned __int64 a2, int a3, unsigned __int16 a4, void *a5, unsigned int a6, void (__cdecl *a7)(void *))
{
  struct AssetsReplacer *result; // eax@1

  result = (struct AssetsReplacer *)operator new(0x28u);
  if ( result )
  {
    *((_DWORD *)result + 1) = a1;
    *((_QWORD *)result + 1) = a2;
    *((_DWORD *)result + 4) = a3;
    *((_WORD *)result + 10) = a4;
    *((_DWORD *)result + 6) = a5;
    *(_DWORD *)result = &off_100A1DDC;
    *((_DWORD *)result + 7) = a6;
    *((_DWORD *)result + 8) = a7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 100A1DDC: using guessed type unsigned __int32 (__thiscall *off_100A1DDC)(AssetFile *__hidden this);

//----- (100123F0) --------------------------------------------------------
struct AssetsReplacer *__cdecl MakeAssetModifierFromFile(unsigned __int32 a1, unsigned __int64 a2, int a3, unsigned __int16 a4, struct _iobuf *a5, unsigned __int64 a6, unsigned __int64 a7, unsigned int a8, bool a9)
{
  struct AssetsReplacer *result; // eax@1

  result = (struct AssetsReplacer *)operator new(0x38u);
  if ( result )
  {
    *((_DWORD *)result + 1) = a1;
    *((_QWORD *)result + 1) = a2;
    *((_DWORD *)result + 4) = a3;
    *((_WORD *)result + 10) = a4;
    *((_DWORD *)result + 6) = a5;
    *((_QWORD *)result + 4) = a6;
    *((_QWORD *)result + 5) = a7;
    *(_DWORD *)result = &off_100A1E04;
    *((_DWORD *)result + 12) = a8;
    *((_BYTE *)result + 52) = a9;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 100A1E04: using guessed type unsigned __int32 (__thiscall *off_100A1E04)(AssetFile *__hidden this);

//----- (10012460) --------------------------------------------------------
unsigned __int64 __cdecl AssetsWriterToFile(fpos_t a1, size_t a2, const void *a3, FILE *a4, FILE *a5)
{
  FILE *v5; // esi@1
  unsigned __int64 result; // rax@3

  v5 = a5;
  if ( (HIDWORD(a1) & (unsigned int)a1) != -1 && fsetpos(a5, &a1) )
    result = 0i64;
  else
    result = fwrite(a4, 1u, a2, v5);
  return result;
}

//----- (100124B0) --------------------------------------------------------
unsigned __int64 __cdecl AssetsReaderFromFile(fpos_t a1, size_t a2, void *a3, FILE *a4, FILE *a5)
{
  FILE *v5; // esi@1
  unsigned __int64 result; // rax@3

  v5 = a5;
  if ( (HIDWORD(a1) & (unsigned int)a1) != -1 && fsetpos(a5, &a1) )
  {
    memset(a4, 0, a2);
    result = 0i64;
  }
  else
  {
    result = fread(a4, 1u, a2, v5);
  }
  return result;
}

//----- (10012510) --------------------------------------------------------
void __cdecl AssetsVerifyLoggerFromFile(LPCSTR lpText)
{
  MessageBoxA(0, lpText, "Test", 0);
}

//----- (10012530) --------------------------------------------------------
void __cdecl AssetsVerifyLoggerToConsole(char *a1)
{
  printf("%s\n", a1);
}

//----- (10012550) --------------------------------------------------------
int __cdecl sub_10012550(wchar_t *a1)
{
  int v1; // ecx@0
  int v2; // ebp@0
  int v3; // esi@1
  _DWORD *v4; // eax@1
  int v5; // ebx@1
  int v6; // edi@2
  char *v7; // esi@4
  char *v8; // eax@6
  __int16 v9; // cx@7
  unsigned int v10; // eax@11
  char *v11; // esi@13
  int v12; // eax@15
  unsigned int v13; // esi@15
  int v14; // edx@16
  fpos_t v16; // [sp+10h] [bp-48h]@9
  FILE *File; // [sp+18h] [bp-40h]@8
  int v18; // [sp+1Ch] [bp-3Ch]@20
  wchar_t *Filename; // [sp+24h] [bp-34h]@1
  int v20; // [sp+28h] [bp-30h]@4
  char *i; // [sp+2Ch] [bp-2Ch]@4
  int v22; // [sp+30h] [bp-28h]@4
  char v23; // [sp+34h] [bp-24h]@4
  __int16 v24; // [sp+3Ch] [bp-1Ch]@6

  Filename = a1;
  v3 = v1;
  v4 = operator new(0x18u);
  v5 = 0;
  if ( v4 )
  {
    *v4 = 0;
    v4[1] = 0;
    v4[2] = 0;
    v6 = (int)v4;
  }
  else
  {
    v6 = 0;
  }
  v7 = (char *)Filename + 2 * v3 + 12 - (_DWORD)&v23;
  v22 = v6;
  *(_DWORD *)(v6 + 16) = 0;
  *(_DWORD *)(v6 + 20) = 0;
  v20 = 0;
  for ( i = v7; ; v7 = i )
  {
    sub_10013100(L"%u", v20);
    v24 = 0;
    v8 = &v23;
    do
    {
      v9 = *(_WORD *)v8;
      *(_WORD *)&v8[(_DWORD)v7] = *(_WORD *)v8;
      v8 += 2;
    }
    while ( v9 );
    File = 0;
    wfopen_s(&File, Filename, L"rb");
    if ( !File )
      break;
    fseek(File, 0, 2);
    v16 = 0i64;
    fgetpos(File, &v16);
    fseek(File, 0, 0);
    if ( !v16 )
    {
      fclose(File);
      goto LABEL_23;
    }
    v10 = *(_DWORD *)(v6 + 4);
    if ( (unsigned int)&v16 >= v10 || *(_DWORD *)v6 > (unsigned int)&v16 )
    {
      if ( v10 == *(_DWORD *)(v6 + 8) )
        sub_10012F70(v6, 0, v2, v6);
      v12 = *(_DWORD *)(v6 + 4);
      if ( !v12 )
        goto LABEL_22;
      *(_QWORD *)v12 = v16;
      *(_DWORD *)(v12 + 8) = File;
      v14 = v18;
    }
    else
    {
      v11 = (char *)&v16 - *(_DWORD *)v6;
      if ( v10 == *(_DWORD *)(v6 + 8) )
        sub_10012F70(v6, 0, v2, v6);
      v12 = *(_DWORD *)(v6 + 4);
      v13 = *(_DWORD *)v6 + ((unsigned int)v11 & 0xFFFFFFF0);
      if ( !v12 )
        goto LABEL_22;
      *(_DWORD *)v12 = *(_DWORD *)v13;
      *(_DWORD *)(v12 + 4) = *(_DWORD *)(v13 + 4);
      *(_DWORD *)(v12 + 8) = *(_DWORD *)(v13 + 8);
      v14 = *(_DWORD *)(v13 + 12);
    }
    *(_DWORD *)(v12 + 12) = v14;
LABEL_22:
    *(_DWORD *)(v6 + 4) += 16;
LABEL_23:
    if ( (unsigned int)++v20 >= 0x2710 )
      break;
  }
  if ( (*(_DWORD *)(v6 + 4) - *(_DWORD *)v6) & 0xFFFFFFF0 )
  {
    v5 = v22;
  }
  else
  {
    if ( *(_DWORD *)v6 )
      operator delete(*(void **)v6);
    *(_DWORD *)v6 = 0;
    *(_DWORD *)(v6 + 4) = 0;
    *(_DWORD *)(v6 + 8) = 0;
    operator delete((void *)v6);
  }
  free(Filename);
  return v5;
}
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100A1E34: using guessed type wchar_t aU[3];

//----- (10012740) --------------------------------------------------------
wchar_t *__cdecl Create_AssetsReaderFromSplitFileW(const wchar_t *a1)
{
  unsigned int v1; // eax@1
  unsigned int v2; // ebx@1
  wchar_t *result; // eax@4
  wchar_t *v4; // edi@4
  const wchar_t *v5; // eax@5
  wchar_t v6; // cx@6

  v1 = wcslen(a1);
  v2 = v1;
  if ( v1 > 7 && !wcscmp(&a1[v1 - 7], L".split0") )
    v2 -= 7;
  result = (wchar_t *)malloc(2 * v2 + 22);
  v4 = result;
  if ( result )
  {
    memcpy(result, a1, 2 * v2);
    v5 = L".split0000";
    do
    {
      v6 = *v5;
      *(const wchar_t *)((char *)v5 + (char *)&v4[v2] - (char *)L".split0000") = *v5;
      ++v5;
    }
    while ( v6 );
    result = (wchar_t *)sub_10012550(v4);
  }
  return result;
}
// 100A1E44: using guessed type wchar_t a_split0[8];
// 100A1E54: using guessed type wchar_t a_split0000[11];

//----- (10012800) --------------------------------------------------------
WCHAR *__cdecl Create_AssetsReaderFromSplitFile(LPCSTR lpMultiByteStr)
{
  unsigned int v1; // kr00_4@1
  int v2; // ebx@1
  int v3; // eax@4
  int v4; // esi@4
  WCHAR *result; // eax@4
  wchar_t *v6; // edi@4
  const wchar_t *v7; // eax@5
  wchar_t v8; // cx@6

  v1 = strlen(lpMultiByteStr);
  v2 = v1 & 0x7FFFFFFF;
  if ( (signed int)(v1 & 0x7FFFFFFF) > 7 && !strcmp(&lpMultiByteStr[(v1 & 0x7FFFFFFF) - 7], ".split0") )
    v2 -= 7;
  v3 = MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStr, v2, 0, 0);
  v4 = v3;
  result = (WCHAR *)malloc(2 * v3 + 22);
  v6 = result;
  if ( result )
  {
    MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStr, v2, result, v4);
    v7 = L".split0000";
    do
    {
      v8 = *v7;
      *(const wchar_t *)((char *)v7 + (char *)&v6[v4] - (char *)L".split0000") = *v7;
      ++v7;
    }
    while ( v8 );
    result = (WCHAR *)sub_10012550(v6);
  }
  return result;
}
// 100A1E54: using guessed type wchar_t a_split0000[11];

//----- (100128D0) --------------------------------------------------------
void __cdecl Free_AssetsReaderFromSplitFile(__int32 a1)
{
  char *v1; // eax@1
  unsigned int v2; // edi@1
  int v3; // ebx@2

  v1 = *(char **)a1;
  v2 = 0;
  if ( (*(_DWORD *)(a1 + 4) - *(_DWORD *)a1) >> 4 )
  {
    v3 = 0;
    do
    {
      fclose(*(FILE **)&v1[v3 + 8]);
      v1 = *(char **)a1;
      ++v2;
      v3 += 16;
    }
    while ( v2 < (*(_DWORD *)(a1 + 4) - *(_DWORD *)a1) >> 4 );
  }
  if ( *(_DWORD *)a1 )
    operator delete(*(void **)a1);
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  operator delete((void *)a1);
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10012940) --------------------------------------------------------
unsigned int __cdecl AssetsReaderFromSplitFile(unsigned __int64 a1, size_t a2, void *a3, __int32 a4, int a5)
{
  unsigned int v5; // edx@1
  unsigned int v6; // esi@1
  _QWORD *v7; // edi@3
  unsigned int v8; // eax@3
  unsigned int v9; // ecx@3
  unsigned __int64 v10; // kr00_8@5
  unsigned int result; // eax@8
  unsigned int v12; // ebx@9
  int v13; // ecx@11
  unsigned __int64 v14; // rdi@11
  size_t v15; // eax@13
  int v16; // [sp+Ch] [bp-24h]@10
  __int64 v17; // [sp+10h] [bp-20h]@9
  unsigned int v18; // [sp+18h] [bp-18h]@7
  fpos_t v19; // [sp+28h] [bp-8h]@13

  v5 = HIDWORD(a1);
  v6 = a1;
  if ( (HIDWORD(a1) & (unsigned int)a1) == -1 )
  {
    v6 = *(_DWORD *)(a5 + 16);
    v5 = *(_DWORD *)(a5 + 20);
  }
  v7 = *(_QWORD **)a5;
  v8 = (*(_DWORD *)(a5 + 4) - *(_DWORD *)a5) >> 4;
  v9 = 0;
  if ( !v8 )
    goto LABEL_8;
  while ( __PAIR__(v5, v6) >= *v7 )
  {
    v10 = __PAIR__(v5, v6) - *v7;
    v5 = (__PAIR__(v5, v6) - *v7) >> 32;
    v6 = v10;
    ++v9;
    v7 += 2;
    if ( v9 >= v8 )
      goto LABEL_8;
  }
  v18 = v6;
  if ( v9 != -1 )
  {
    v12 = 0;
    v17 = 0i64;
    if ( __PAIR__((unsigned int)a3, a2) > 0 )
    {
      v16 = 16 * v9;
      do
      {
        v13 = v16 + *(_DWORD *)a5;
        v14 = *(_QWORD *)v13 - __PAIR__(v5, v6);
        if ( v14 > __PAIR__((unsigned int)a3, a2) - __PAIR__(HIDWORD(v17), v12) )
          v14 = __PAIR__((unsigned int)a3, a2) - __PAIR__(HIDWORD(v17), v12);
        v19 = __PAIR__(v5, v18);
        fsetpos(*(FILE **)(v13 + 8), &v19);
        v15 = fread((void *)(v17 + a4), 1u, v14, *(FILE **)(v16 + *(_DWORD *)a5 + 8));
        v12 = v15 + v17;
        v17 += v15;
        if ( v15 < v14 )
          break;
        v16 += 16;
        v6 = 0;
        v5 = 0;
        v18 = 0;
      }
      while ( __PAIR__(HIDWORD(v17), v12) < __PAIR__((unsigned int)a3, a2) );
    }
    result = v12;
  }
  else
  {
LABEL_8:
    memset((void *)a4, 0, a2);
    result = 0;
  }
  return result;
}

//----- (10012AA0) --------------------------------------------------------
void *__cdecl Create_AssetsReaderFromMemory(void *a1, size_t a2, bool a3)
{
  void *result; // eax@1
  _DWORD *v4; // esi@1
  __int32 v5; // ebx@3

  result = malloc(a3 != 0 ? a2 + 12 : 12);
  v4 = result;
  if ( result )
  {
    *(_DWORD *)result = 0;
    *((_DWORD *)result + 1) = a2;
    if ( a3 )
    {
      v5 = (__int32)result + 12;
      memcpy((char *)result + 12, a1, a2);
      v4[2] = v5;
      result = v4;
    }
    else
    {
      *((_DWORD *)result + 2) = a1;
    }
  }
  return result;
}

//----- (10012B10) --------------------------------------------------------
void __cdecl Free_AssetsReaderFromMemory(void *a1, bool a2)
{
  if ( a2 && *((void **)a1 + 2) != (char *)a1 + 12 )
    free(*((void **)a1 + 2));
  free(a1);
}

//----- (10012B40) --------------------------------------------------------
int __cdecl AssetsReaderFromMemory(unsigned __int64 a1, size_t a2, void *a3, __int32 a4, __int32 a5)
{
  unsigned int v5; // ecx@1
  unsigned int v6; // esi@1
  unsigned int v7; // eax@3
  int result; // eax@5
  int v9; // edi@6

  v5 = HIDWORD(a1);
  v6 = a1;
  if ( (HIDWORD(a1) & (unsigned int)a1) == -1 )
  {
    v6 = *(_DWORD *)a5;
    v5 = 0;
  }
  v7 = *(_DWORD *)(a5 + 4);
  if ( v5 <= 0 && v6 < v7 )
  {
    v9 = a2;
    if ( __PAIR__((unsigned int)a3, a2) + __PAIR__(v5, v6) > v7 )
    {
      memset((void *)(a4 + v7 - v6), 0, a2 + v6 - v7);
      v9 = *(_DWORD *)(a5 + 4) - v6;
    }
    memcpy((void *)a4, (const void *)(v6 + *(_DWORD *)(a5 + 8)), v9);
    *(_DWORD *)a5 = v9 + v6;
    result = v9;
  }
  else
  {
    memset((void *)a4, 0, a2);
    result = 0;
  }
  return result;
}

//----- (10012C00) --------------------------------------------------------
_DWORD *__cdecl Create_AssetsWriterToMemory(void *a1, unsigned int a2)
{
  _DWORD *result; // eax@1

  result = malloc(0x10u);
  if ( result )
  {
    *result = 0;
    result[1] = a2;
    result[2] = a1;
    *((_BYTE *)result + 12) = 0;
  }
  return result;
}

//----- (10012C30) --------------------------------------------------------
_DWORD *__cdecl Create_AssetsWriterToMemoryDynamic()
{
  _DWORD *result; // eax@1

  result = malloc(0x10u);
  if ( result )
  {
    *result = 0;
    result[1] = 0;
    result[2] = 0;
    *((_BYTE *)result + 12) = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10012C60) --------------------------------------------------------
void __cdecl Free_AssetsWriterToMemory(void *a1, bool a2)
{
  if ( a2 && *((_BYTE *)a1 + 12) && *((_DWORD *)a1 + 2) )
    free(*((void **)a1 + 2));
  free(a1);
}

//----- (10012CA0) --------------------------------------------------------
void *__cdecl Get_AssetsWriterToMemory_Buf(__int32 a1, unsigned int *a2, unsigned int *a3)
{
  if ( a2 )
    *a2 = *(_DWORD *)a1;
  if ( a3 )
    *a3 = *(_DWORD *)(a1 + 4);
  return *(void **)(a1 + 8);
}

//----- (10012CD0) --------------------------------------------------------
size_t __cdecl AssetsWriterToMemory(unsigned __int64 a1, unsigned __int64 a2, const void *a3, __int32 a4)
{
  unsigned int v4; // edi@1
  size_t v5; // ebx@5
  void *v6; // eax@5
  unsigned int v7; // edx@7
  size_t result; // eax@9
  size_t v9; // ebx@11

  v4 = a1;
  if ( (HIDWORD(a1) & (unsigned int)a1) == -1 )
  {
    v4 = *(_DWORD *)a4;
    HIDWORD(a1) = 0;
  }
  if ( *(_BYTE *)(a4 + 12) )
  {
    if ( v4 + (unsigned int)a2 >= *(_DWORD *)(a4 + 4) )
    {
      v5 = (v4 + a2 + 31) & 0xFFFFFFE0;
      v6 = realloc(*(void **)(a4 + 8), v5);
      if ( v6 )
      {
        *(_DWORD *)(a4 + 4) = v5;
        *(_DWORD *)(a4 + 8) = v6;
      }
    }
  }
  v7 = *(_DWORD *)(a4 + 4);
  if ( HIDWORD(a1) || v4 >= v7 )
  {
    result = 0;
  }
  else
  {
    if ( a2 + v4 < v7 )
      v9 = a2;
    else
      v9 = v7 - v4;
    memcpy((void *)(v4 + *(_DWORD *)(a4 + 8)), a3, v9);
    *(_DWORD *)a4 = v9 + v4;
    result = v9;
  }
  return result;
}

//----- (10012D90) --------------------------------------------------------
_DWORD *__cdecl Create_AssetsWriterOffset(unsigned __int64 (__cdecl *a1)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a2, unsigned __int64 a3)
{
  _DWORD *result; // eax@1

  result = malloc(0x10u);
  if ( result )
  {
    *result = a1;
    result[1] = a2;
    *((_QWORD *)result + 1) = a3;
  }
  return result;
}

//----- (10012DC0) --------------------------------------------------------
int __cdecl AssetsWriterOffset(unsigned __int64 a1, unsigned __int64 a2, const void *a3, __int32 a4)
{
  int v4; // edx@1
  int v5; // ecx@1

  v4 = HIDWORD(a1);
  v5 = a1;
  if ( (HIDWORD(a1) & (unsigned int)a1) != -1 )
  {
    v4 = (*(_QWORD *)(a4 + 8) + a1) >> 32;
    v5 = *(_DWORD *)(a4 + 8) + a1;
  }
  return (*(int (__cdecl **)(int, int, _DWORD, _DWORD, const void *, _DWORD))a4)(
           v5,
           v4,
           a2,
           HIDWORD(a2),
           a3,
           *(_DWORD *)(a4 + 4));
}

//----- (10012E00) --------------------------------------------------------
void __cdecl Free_AssetsWriterToMemory_DynMem(void *a1)
{
  free(a1);
}

//----- (10012E10) --------------------------------------------------------
int __cdecl PartialAssetsFileReader(unsigned __int64 a1, size_t a2, void *a3, __int32 a4, int a5)
{
  __int64 v5; // rdi@1
  unsigned __int64 v6; // kr00_8@1
  unsigned int v7; // edx@2
  unsigned int v8; // esi@2
  char *v9; // ebx@4
  unsigned __int64 v11; // kr18_8@9
  int v12; // ST14_4@11
  int v13; // edi@11
  unsigned int v14; // ST00_4@11
  int (__cdecl *v15)(unsigned int, unsigned int, size_t, char *, __int32, int); // edx@11

  HIDWORD(v5) = HIDWORD(a1);
  v6 = *(_QWORD *)a5 + *(_QWORD *)(a5 + 8);
  if ( (HIDWORD(a1) & (unsigned int)a1) == -1 )
  {
    v7 = *(_DWORD *)(a5 + 16);
    v8 = *(_DWORD *)(a5 + 20);
  }
  else
  {
    LODWORD(v5) = *(_DWORD *)a5;
    v8 = (v5 + __PAIR__(*(_DWORD *)(a5 + 4), (unsigned int)a1)) >> 32;
    v7 = *(_DWORD *)a5 + a1;
  }
  v9 = (char *)a3;
  if ( (__PAIR__((unsigned int)a3, a2) + __PAIR__(v8, v7)) >> 32 >= HIDWORD(v6) )
  {
    if ( (__PAIR__((unsigned int)a3, a2) + __PAIR__(v8, v7)) >> 32 <= HIDWORD(v6) && a2 + v7 <= (unsigned int)v6 )
    {
      v9 = (char *)a3;
    }
    else
    {
      if ( v6 <= __PAIR__(v8, v7) )
      {
        memset((void *)a4, 0, a2);
        return 0;
      }
      v11 = v6 - __PAIR__(v8, v7);
      v9 = (char *)(v11 >> 32);
      a2 = v11;
    }
  }
  *(_DWORD *)(a5 + 16) = a2 + v7;
  v12 = *(_DWORD *)(a5 + 28);
  v13 = (int)(&v9[__CFADD__(a2, v7)] + v8);
  v14 = v7;
  v15 = *(int (__cdecl **)(unsigned int, unsigned int, size_t, char *, __int32, int))(a5 + 24);
  *(_DWORD *)(a5 + 20) = v13;
  return v15(v14, v8, a2, v9, a4, v12);
}

//----- (10012ED0) --------------------------------------------------------
unsigned __int64 (__cdecl *__cdecl Create_PartialAssetsFileReader(unsigned __int64 (__cdecl *a1)(unsigned __int64, unsigned __int64, void *, __int32), __int32 *a2, unsigned __int64 a3, unsigned __int64 a4))(unsigned __int64, unsigned __int64, void *, __int32)
{
  unsigned __int64 (__cdecl *result)(unsigned __int64, unsigned __int64, void *, __int32); // eax@1

  result = (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32))malloc(0x20u);
  if ( result )
  {
    *((_DWORD *)result + 6) = a1;
    *((_DWORD *)result + 7) = *a2;
    *((_DWORD *)result + 4) = a3;
    *(_DWORD *)result = a3;
    *((_DWORD *)result + 2) = a4;
    *((_DWORD *)result + 5) = HIDWORD(a3);
    *((_DWORD *)result + 1) = HIDWORD(a3);
    *((_DWORD *)result + 3) = HIDWORD(a4);
    *a2 = (__int32)result;
    result = (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32))PartialAssetsFileReader;
  }
  return result;
}

//----- (10012F20) --------------------------------------------------------
void __cdecl Free_PartialAssetsFileReader(void *a1)
{
  if ( a1 )
    free(a1);
}

//----- (10012F40) --------------------------------------------------------
unsigned __int64 (__cdecl *__cdecl Free_PartialAssetsFileReader(__int32 *a1))(unsigned __int64, unsigned __int64, void *, __int32)
{
  __int32 v1; // eax@2
  unsigned __int64 (__cdecl *v2)(unsigned __int64, unsigned __int64, void *, __int32); // esi@3
  unsigned __int64 (__cdecl *result)(unsigned __int64, unsigned __int64, void *, __int32); // eax@3

  if ( a1 && (v1 = *a1) != 0 )
  {
    v2 = *(unsigned __int64 (__cdecl **)(unsigned __int64, unsigned __int64, void *, __int32))(v1 + 24);
    *a1 = *(_DWORD *)(v1 + 28);
    free((void *)v1);
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10012F70) --------------------------------------------------------
unsigned int __usercall sub_10012F70@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<ebp>, signed int a4@<edi>)
{
  int v4; // esi@1
  unsigned int v5; // eax@1
  unsigned int result; // eax@3
  unsigned int v7; // ecx@3
  unsigned int v8; // ecx@5
  int v9; // esi@9
  unsigned int v10; // ebx@11
  int v11; // esi@11
  char *v12; // eax@14
  int v13; // edx@14
  int v14; // ecx@14
  int v15; // edi@14
  unsigned int v16; // edi@16
  unsigned int v17; // [sp-28h] [bp-2Ch]@11
  signed int v18; // [sp-24h] [bp-28h]@11
  int v19; // [sp-20h] [bp-24h]@11
  int v20; // [sp-1Ch] [bp-20h]@11
  char *v21; // [sp-18h] [bp-1Ch]@14
  unsigned int *v22; // [sp-14h] [bp-18h]@11
  unsigned int v23; // [sp-10h] [bp-14h]@11
  int (__cdecl *v24)(int, int); // [sp-Ch] [bp-10h]@11
  signed int v25; // [sp-8h] [bp-Ch]@4
  int v26; // [sp-4h] [bp-8h]@9

  v4 = *(_DWORD *)a1;
  v5 = (*(_DWORD *)(a1 + 4) - *(_DWORD *)a1) >> 4;
  if ( v5 > 0xFFFFFFE )
    std::_Xlength_error("vector<T> too long");
  result = v5 + 1;
  v7 = (*(_DWORD *)(a1 + 8) - v4) >> 4;
  if ( result > v7 )
  {
    v25 = a4;
    if ( 0xFFFFFFF - (v7 >> 1) >= v7 )
      v8 = (v7 >> 1) + v7;
    else
      v8 = 0;
    if ( v8 < result )
      v8 = result;
    v9 = v26;
    v26 = a3;
    v25 = -1;
    v24 = sub_10096160;
    v23 = result;
    v20 = a2;
    v19 = v9;
    v18 = a4;
    v17 = (unsigned int)&v26 ^ __security_cookie;
    v22 = &v17;
    v10 = v8;
    v11 = a1;
    if ( v8 > 0xFFFFFFF )
      std::_Xlength_error("vector<T> too long");
    result = (*(_DWORD *)(v11 + 8) - *(_DWORD *)v11) >> 4;
    if ( result < v10 )
    {
      v12 = (char *)sub_100130A0(v8);
      v25 = 0;
      v13 = *(_DWORD *)(v11 + 4);
      v14 = *(_DWORD *)v11;
      v21 = v12;
      sub_10013120((int)v12, v13, v14);
      v15 = *(_DWORD *)(v11 + 4) - *(_DWORD *)v11;
      if ( *(_DWORD *)v11 )
        operator delete(*(void **)v11);
      result = (unsigned int)v21;
      v16 = (unsigned int)&v21[v15 & 0xFFFFFFF0];
      *(_DWORD *)(v11 + 8) = &v21[16 * v10];
      *(_DWORD *)(v11 + 4) = v16;
      *(_DWORD *)v11 = result;
    }
  }
  return result;
}
// 10012F70: could not find valid save-restore pair for ebx
// 10012F70: could not find valid save-restore pair for ebp
// 10012F70: could not find valid save-restore pair for edi
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1001307A) --------------------------------------------------------
void __usercall __noreturn sub_1001307A(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 20));
  CxxThrowException(0, 0);
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (100130A0) --------------------------------------------------------
void *__fastcall sub_100130A0(unsigned int a1)
{
  void *result; // eax@1
  int (__stdcall **v2)(char); // [sp+0h] [bp-10h]@4
  int v3; // [sp+Ch] [bp-4h]@4

  result = 0;
  if ( a1 )
  {
    if ( a1 > 0xFFFFFFF || (result = operator new(16 * a1)) == 0 )
    {
      v3 = 0;
      std::exception::exception((std::exception *)&v2, (const char *const *)&v3);
      v2 = &off_10099840;
      CxxThrowException(&v2, &unk_100A5EA0);
    }
  }
  return result;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (10013100) --------------------------------------------------------
int sub_10013100(wchar_t *Format, ...)
{
  wchar_t *v1; // edx@0
  va_list va; // [sp+Ch] [bp+Ch]@1

  va_start(va, Format);
  return vswprintf_s(v1, 0x10u, Format, va);
}
// 10013100: can not handle register arguments in vararg function, discarded them

//----- (10013120) --------------------------------------------------------
int __usercall sub_10013120@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  for ( ; a3 != a2; result += 16 )
  {
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)a3;
      *(_DWORD *)(result + 4) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(result + 8) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(result + 12) = *(_DWORD *)(a3 + 12);
    }
    a3 += 16;
  }
  return result;
}

//----- (10013150) --------------------------------------------------------
double __usercall sub_10013150@<st0>(int a1@<eax>)
{
  double result; // st7@2
  float v2; // ST04_4@3

  switch ( *(_DWORD *)a1 )
  {
    case 0xA:
      result = *(float *)(a1 + 8);
      break;
    case 0xB:
      v2 = *(double *)(a1 + 8);
      result = v2;
      break;
    case 0xC:
    case 0xD:
    case 0xE:
      result = 0.0;
      break;
    case 2:
      result = (double)*(_BYTE *)(a1 + 8);
      break;
    case 4:
      result = (double)*(_WORD *)(a1 + 8);
      break;
    case 6:
      result = (double)*(signed int *)(a1 + 8);
      break;
    default:
      result = (double)*(unsigned __int64 *)(a1 + 8);
      break;
  }
  return result;
}

//----- (10013210) --------------------------------------------------------
double __usercall sub_10013210@<st0>(int a1@<eax>)
{
  double result; // st7@2

  switch ( *(_DWORD *)a1 )
  {
    case 0xA:
      result = *(float *)(a1 + 8);
      break;
    case 0xB:
      result = *(double *)(a1 + 8);
      break;
    case 0xC:
    case 0xD:
    case 0xE:
      result = 0.0;
      break;
    case 2:
      result = (double)*(_BYTE *)(a1 + 8);
      break;
    case 4:
      result = (double)*(_WORD *)(a1 + 8);
      break;
    case 6:
      result = (double)*(signed int *)(a1 + 8);
      break;
    default:
      result = (double)*(unsigned __int64 *)(a1 + 8);
      break;
  }
  return result;
}

//----- (100132D0) --------------------------------------------------------
int __thiscall AssetTypeValue::AssetTypeValue(AssetTypeValue *this, int a2, void *a3)
{
  int v3; // ecx@1

  *(_DWORD *)this = a2;
  AssetTypeValue::Set(this, a3);
  return v3;
}

//----- (100132F0) --------------------------------------------------------
void __thiscall AssetTypeValue::Set(AssetTypeValue *this, void *a2)
{
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  switch ( *(_DWORD *)this )
  {
    case 1:
    case 2:
    case 3:
      *((_BYTE *)this + 8) = *(_BYTE *)a2;
      break;
    case 4:
    case 5:
      *((_WORD *)this + 4) = *(_WORD *)a2;
      break;
    case 0xA:
      *((float *)this + 2) = *(float *)a2;
      break;
    case 0xB:
      *((double *)this + 1) = *(double *)a2;
      break;
    case 0xC:
      *((_DWORD *)this + 2) = a2;
      break;
    case 6:
    case 7:
    case 0xD:
      *((_DWORD *)this + 2) = *(_DWORD *)a2;
      break;
    case 8:
    case 9:
    case 0xE:
      *((_DWORD *)this + 2) = *(_DWORD *)a2;
      *((_DWORD *)this + 3) = *((_DWORD *)a2 + 1);
      break;
    default:
      return;
  }
}

//----- (100133B0) --------------------------------------------------------
void *__thiscall AssetTypeValueField::operator[](int this, const char *a2)
{
  void *result; // eax@1
  unsigned int v3; // ebx@1
  unsigned int v4; // esi@2
  const char ****v5; // edi@3
  int v6; // [sp+4h] [bp-4h]@3

  result = (void *)this;
  v3 = *(_DWORD *)(this + 4);
  if ( v3 != -1 )
  {
    v4 = 0;
    if ( v3 )
    {
      v6 = *(_DWORD *)(this + 8);
      v5 = *(const char *****)(this + 8);
      while ( !**v5 || strcmp(***v5, a2) )
      {
        ++v4;
        ++v5;
        if ( v4 >= v3 )
          goto LABEL_7;
      }
      result = *(void **)(v6 + 4 * v4);
    }
    else
    {
LABEL_7:
      result = &unk_100ADF9C;
    }
  }
  return result;
}

//----- (10013430) --------------------------------------------------------
_DWORD *__thiscall AssetTypeValueField::operator[](int this, unsigned int a2)
{
  _DWORD *result; // eax@1
  unsigned int v3; // ecx@1

  result = (_DWORD *)this;
  v3 = *(_DWORD *)(this + 4);
  if ( v3 != -1 )
  {
    if ( a2 < v3 )
      result = *(_DWORD **)(result[2] + 4 * a2);
    else
      result = &unk_100ADF9C;
  }
  return result;
}

//----- (10013460) --------------------------------------------------------
void __thiscall AssetTypeValueField::Read(AssetTypeValueField *this, struct AssetTypeValue *a2, struct AssetTypeTemplateField *a3, unsigned __int32 a4, struct AssetTypeValueField **a5)
{
  *((_DWORD *)this + 3) = a2;
  *(_DWORD *)this = a3;
  *((_DWORD *)this + 1) = a4;
  *((_DWORD *)this + 2) = a5;
}

//----- (10013480) --------------------------------------------------------
int __thiscall AssetTypeValueField::Write(AssetTypeValueField *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 a4)
{
  __int32 v4; // ebx@1
  AssetTypeValueField *v5; // esi@1
  int v6; // edx@1
  bool v7; // zf@1
  char v8; // al@1
  int v9; // eax@2
  char v10; // al@4
  unsigned int v11; // edi@4
  unsigned int v12; // esi@4
  unsigned int v13; // edi@4
  int v14; // esi@4
  unsigned __int16 v15; // ax@5
  unsigned int v16; // edi@5
  unsigned int v17; // esi@5
  signed int v18; // eax@6
  unsigned int v19; // edi@6
  unsigned int v20; // esi@6
  unsigned int v21; // edi@8
  unsigned int v22; // esi@8
  unsigned int v23; // edi@10
  unsigned int v24; // esi@10
  int v25; // ecx@12
  int v26; // esi@16
  const char *v27; // eax@17
  unsigned int v28; // edi@19
  unsigned int v29; // esi@19
  int v30; // eax@19
  unsigned __int64 v31; // kr28_8@19
  int v32; // eax@20
  int v33; // eax@26
  unsigned int v34; // edi@28
  unsigned int v35; // esi@28
  _DWORD *v36; // eax@28
  unsigned __int64 v37; // kr38_8@28
  int v38; // eax@29
  int *v39; // eax@33
  unsigned int v40; // edi@35
  unsigned int v41; // esi@35
  unsigned __int64 v42; // kr50_8@36
  unsigned __int64 v43; // kr58_8@40
  int v44; // edx@44
  __int64 v45; // ST08_8@45
  __int64 *v47; // [sp-8h] [bp-40h]@7
  __int32 v48; // [sp-4h] [bp-3Ch]@7
  double v49; // [sp+10h] [bp-28h]@9
  unsigned __int64 v50; // [sp+18h] [bp-20h]@7
  float v51; // [sp+24h] [bp-14h]@8
  unsigned int v52; // [sp+28h] [bp-10h]@39
  AssetTypeValueField *v53; // [sp+2Ch] [bp-Ch]@1
  unsigned int v54; // [sp+30h] [bp-8h]@5
  char v55; // [sp+37h] [bp-1h]@1

  v4 = a3;
  v5 = this;
  v6 = *(_DWORD *)this;
  v7 = *(_DWORD *)(*(_DWORD *)this + 16) == 0;
  v8 = *(_BYTE *)(*(_DWORD *)this + 13);
  v53 = this;
  v55 = v8;
  if ( v7 )
  {
    v9 = *((_DWORD *)this + 3);
    if ( v9 )
    {
      switch ( *(_DWORD *)(v6 + 8) )
      {
        case 1:
        case 2:
        case 3:
          v10 = sub_10001000(v9);
          v11 = HIDWORD(a4);
          v12 = a4;
          BYTE3(a3) = v10;
          ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a2)(
            a4,
            HIDWORD(a4),
            1,
            0,
            (char *)&a3 + 3,
            v4);
          v13 = (__PAIR__(v11, v12) + 1) >> 32;
          v14 = v12 + 1;
          goto LABEL_43;
        case 4:
        case 5:
          v15 = sub_10001000(v9);
          v16 = HIDWORD(a4);
          v17 = a4;
          v54 = v15;
          ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, unsigned int *, __int32))a2)(
            a4,
            HIDWORD(a4),
            2,
            0,
            &v54,
            v4);
          v13 = (__PAIR__(v16, v17) + 2) >> 32;
          v14 = v17 + 2;
          goto LABEL_43;
        case 6:
        case 7:
          v18 = sub_10001000(v9);
          v19 = HIDWORD(a4);
          v20 = a4;
          v54 = v18;
          ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, unsigned int *, __int32))a2)(
            a4,
            HIDWORD(a4),
            4,
            0,
            &v54,
            v4);
          v13 = (__PAIR__(v19, v20) + 4) >> 32;
          v14 = v20 + 4;
          goto LABEL_43;
        case 8:
        case 9:
          v48 = a3;
          v50 = sub_100010F0(*((_DWORD *)this + 3));
          v47 = (__int64 *)&v50;
          goto LABEL_10;
        case 0xA:
          v51 = sub_10013150(v9);
          v21 = HIDWORD(a4);
          v22 = a4;
          ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, float *, __int32))a2)(a4, HIDWORD(a4), 4, 0, &v51, v4);
          v13 = (__PAIR__(v21, v22) + 4) >> 32;
          v14 = v22 + 4;
          break;
        case 0xB:
          v49 = sub_10013210(v9);
          v48 = v4;
          v47 = (__int64 *)&v49;
LABEL_10:
          v23 = HIDWORD(a4);
          v24 = a4;
          ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, __int64 *, __int32))a2)(
            a4,
            HIDWORD(a4),
            8,
            0,
            v47,
            v48);
          v13 = (__PAIR__(v23, v24) + 8) >> 32;
          v14 = v24 + 8;
          break;
        default:
          goto LABEL_42;
      }
      goto LABEL_43;
    }
  }
  if ( *(_DWORD *)(v6 + 8) != 12 || (v25 = *((_DWORD *)this + 3)) == 0 )
  {
    if ( *(_BYTE *)(v6 + 12) && (v33 = *((_DWORD *)v5 + 3)) != 0 )
    {
      if ( *(_DWORD *)v33 == 14 )
      {
        v34 = HIDWORD(a4);
        v35 = a4;
        v54 = *(_DWORD *)(v33 + 8);
        ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, unsigned int *, __int32))a2)(
          a4,
          HIDWORD(a4),
          4,
          0,
          &v54,
          a3);
        v36 = (_DWORD *)*((_DWORD *)v53 + 3);
        v37 = __PAIR__(v34, v35) + 4;
        if ( *v36 == 14 )
          v38 = (int)(v36 + 2);
        else
          v38 = 0;
        ((void (__cdecl *)(_DWORD, _DWORD, unsigned int, _DWORD, _DWORD, __int32))a2)(
          v37,
          HIDWORD(v37),
          v54,
          0,
          *(_DWORD *)(v38 + 4),
          v4);
        v13 = (v54 + v37) >> 32;
        v14 = v54 + v37;
      }
      else
      {
        if ( *(_DWORD *)v33 == 13 )
          v39 = (int *)(v33 + 8);
        else
          v39 = 0;
        v40 = HIDWORD(a4);
        v41 = a4;
        v54 = *v39;
        ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(a4, HIDWORD(a4), 4, 0, &v54, a3);
        v13 = (__PAIR__(v40, v41) + 4) >> 32;
        v14 = v41 + 4;
        HIDWORD(a4) = 0;
        if ( v54 )
        {
          do
          {
            v42 = AssetTypeValueField::Write(
                    (AssetTypeValueField *)*(_DWORD *)(*((_DWORD *)v53 + 2) + 4 * HIDWORD(a4)),
                    a2,
                    v4,
                    __PAIR__(v13, v14));
            v13 = HIDWORD(v42);
            v14 = v42;
            ++HIDWORD(a4);
          }
          while ( HIDWORD(a4) < v54 );
        }
      }
    }
    else if ( *((_DWORD *)v5 + 1) )
    {
      v13 = HIDWORD(a4);
      v14 = a4;
      v52 = 0;
      do
      {
        v43 = AssetTypeValueField::Write(
                (AssetTypeValueField *)*(_DWORD *)(*((_DWORD *)v53 + 2) + 4 * v52),
                a2,
                v4,
                __PAIR__(v13, v14));
        v13 = HIDWORD(v43);
        v14 = v43;
        ++v52;
      }
      while ( v52 < *((_DWORD *)v53 + 1) );
    }
    else
    {
LABEL_42:
      v13 = HIDWORD(a4);
      v14 = a4;
    }
LABEL_43:
    if ( !v55 )
      return v14;
    goto LABEL_44;
  }
  if ( *(_DWORD *)v25 != 12 || !*(_DWORD *)(v25 + 8) )
    AssetTypeValue::Set((AssetTypeValue *)v25, &unk_100996C3);
  v26 = *((_DWORD *)v5 + 3);
  if ( *(_DWORD *)v26 == 12 )
    v27 = *(const char **)(v26 + 8);
  else
    v27 = 0;
  v54 = strlen(v27);
  v28 = HIDWORD(a4);
  v29 = a4;
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(a4, HIDWORD(a4), 4, 0, &v54, v4);
  v30 = *((_DWORD *)v53 + 3);
  v31 = __PAIR__(v28, v29) + 4;
  if ( *(_DWORD *)v30 == 12 )
    v32 = *(_DWORD *)(v30 + 8);
  else
    v32 = 0;
  ((void (__cdecl *)(_DWORD, _DWORD, unsigned int, _DWORD, int, __int32))a2)(v31, HIDWORD(v31), v54, 0, v32, v4);
  v13 = (v54 + v31) >> 32;
  v14 = v54 + v31;
  if ( !*(_DWORD *)(*(_DWORD *)v53 + 16) || !*(_BYTE *)(*(_DWORD *)(*(_DWORD *)v53 + 20) + 13) )
    goto LABEL_43;
LABEL_44:
  v44 = ((_BYTE)v14 - 1) & 3;
  if ( 3 - v44 > 0 )
  {
    v45 = 3 - v44;
    v54 = 0;
    a4 = (signed int)v45;
    ((void (__cdecl *)(int, unsigned int, _DWORD, _DWORD, unsigned int *, __int32))a2)(
      v14,
      v13,
      v45,
      HIDWORD(v45),
      &v54,
      v4);
    v14 += a4;
  }
  return v14;
}

//----- (100137F0) --------------------------------------------------------
unsigned int __thiscall AssetTypeValueField::GetByteSize(AssetTypeValueField *this, unsigned __int64 a2)
{
  AssetTypeValueField *v2; // ebx@1
  int v3; // ecx@1
  int v4; // edx@1
  unsigned int v5; // esi@4
  int v6; // eax@9
  const char *v7; // eax@11
  unsigned int v8; // edi@18
  int v9; // ebx@19
  unsigned int v10; // ecx@22
  _DWORD *v11; // eax@23
  unsigned int *v12; // eax@24
  unsigned __int64 v13; // rax@27
  unsigned int v14; // edi@29
  unsigned __int64 v15; // kr18_8@30
  unsigned int v17; // [sp+10h] [bp-8h]@29
  char v18; // [sp+17h] [bp-1h]@1
  int v19; // [sp+24h] [bp+Ch]@22

  v2 = this;
  v3 = *(_DWORD *)this;
  v4 = *(_DWORD *)(v3 + 16);
  v18 = *(_BYTE *)(v3 + 13);
  if ( v4 || !*((_DWORD *)v2 + 3) )
  {
    if ( *(_DWORD *)(v3 + 8) == 12 && (v6 = *((_DWORD *)v2 + 3)) != 0 )
    {
      if ( *(_DWORD *)v6 == 12 )
        v7 = *(const char **)(v6 + 8);
      else
        v7 = 0;
      v5 = strlen(v7) + 4 + a2;
      if ( v4 && *(_BYTE *)(*(_DWORD *)(v3 + 20) + 13) )
        goto LABEL_34;
    }
    else if ( *(_BYTE *)(v3 + 12) && *((_DWORD *)v2 + 3) )
    {
      v8 = (a2 + 4) >> 32;
      v5 = a2 + 4;
      if ( !stricmp(*(const char **)(v3 + 4), "TypelessData") )
      {
        v9 = *((_DWORD *)v2 + 3);
        if ( *(_DWORD *)v9 == 14 )
          v5 += *(_DWORD *)(v9 + 8);
        else
          v5 += v0;
      }
      else
      {
        v10 = 0;
        v19 = 0;
        while ( 1 )
        {
          v11 = (_DWORD *)*((_DWORD *)v2 + 3);
          v12 = *v11 == 13 ? v11 + 2 : 0;
          if ( v10 >= *v12 )
            break;
          v13 = AssetTypeValueField::GetByteSize(
                  (AssetTypeValueField *)*(_DWORD *)(*((_DWORD *)v2 + 2) + 4 * v10),
                  __PAIR__(v8, v5));
          v10 = ++v19;
          v8 = HIDWORD(v13);
          v5 = v13;
        }
      }
    }
    else if ( *((_DWORD *)v2 + 1) )
    {
      v14 = HIDWORD(a2);
      v5 = a2;
      v17 = 0;
      do
      {
        v15 = AssetTypeValueField::GetByteSize(
                (AssetTypeValueField *)*(_DWORD *)(*((_DWORD *)v2 + 2) + 4 * v17),
                __PAIR__(v14, v5));
        v14 = HIDWORD(v15);
        v5 = v15;
        ++v17;
      }
      while ( v17 < *((_DWORD *)v2 + 1) );
    }
    else
    {
LABEL_32:
      v5 = a2;
    }
  }
  else
  {
    switch ( *(_DWORD *)(v3 + 8) )
    {
      case 1:
      case 2:
      case 3:
        v5 = a2 + 1;
        break;
      case 4:
      case 5:
        v5 = a2 + 2;
        break;
      case 6:
      case 7:
      case 0xA:
        v5 = a2 + 4;
        break;
      case 8:
      case 9:
      case 0xB:
        v5 = a2 + 8;
        break;
      default:
        goto LABEL_32;
    }
  }
  if ( v18 )
LABEL_34:
    v5 = (v5 + 3) & 0xFFFFFFFC;
  return v5;
}

//----- (100139B0) --------------------------------------------------------
BOOL __thiscall AssetTypeValueField::IsDummy(AssetTypeValueField *this)
{
  return *((_DWORD *)this + 1) == -1;
}

//----- (100139C0) --------------------------------------------------------
struct AssetTypeValueField *__cdecl GetDummyAssetTypeField()
{
  return (struct AssetTypeValueField *)&unk_100ADF9C;
}

//----- (100139D0) --------------------------------------------------------
signed int __cdecl GetValueTypeByTypeName(char *a1)
{
  signed int v1; // ebx@1

  v1 = 0;
  if ( !stricmp(a1, "string") )
    return 12;
  if ( !stricmp(a1, "SInt8") || !stricmp(a1, "char") )
  {
    v1 = 2;
  }
  else
  {
    if ( !stricmp(a1, "UInt8") || !stricmp(a1, "unsigned char") )
      return 3;
    if ( !stricmp(a1, "SInt16") || !stricmp(a1, "short") )
      return 4;
    if ( !stricmp(a1, "UInt16") || !stricmp(a1, "unsigned short") )
      return 5;
    if ( !stricmp(a1, "SInt32") || !stricmp(a1, "int") || !stricmp(a1, "Type*") )
      return 6;
    if ( !stricmp(a1, "UInt32") || !stricmp(a1, "unsigned int") )
      return 7;
    if ( !stricmp(a1, "SInt64") || !stricmp(a1, "long") )
      return 8;
    if ( !stricmp(a1, "UInt64") || !stricmp(a1, "unsigned long") )
      return 9;
    if ( !stricmp(a1, "float") )
      return 10;
    if ( !stricmp(a1, "double") )
      return 11;
    if ( !stricmp(a1, "bool") )
      return 1;
  }
  return v1;
}

//----- (10013BF0) --------------------------------------------------------
int __cdecl sub_10013BF0(unsigned int a1, void (__cdecl *a2)(unsigned int, unsigned int, signed int, _DWORD, unsigned int *, int), int a3, int a4, int *a5, int *a6, int *a7, int a8)
{
  unsigned int v8; // eax@1
  unsigned int v9; // ecx@1
  int v10; // ebx@1
  int v11; // edx@1
  unsigned int v12; // esi@1
  bool v13; // zf@1
  int v14; // edx@3
  int v15; // ebx@6
  unsigned int v16; // edi@6
  int v17; // eax@11
  int v18; // edi@13
  int v19; // edx@14
  __int64 v20; // kr08_8@14
  int v21; // edx@21
  unsigned int v22; // edi@28
  int v23; // ebx@29
  int v24; // eax@30
  int v25; // edx@34
  int result; // eax@34
  unsigned __int64 v27; // [sp+10h] [bp-20h]@1
  unsigned int v28; // [sp+1Ch] [bp-14h]@7
  int v29; // [sp+20h] [bp-10h]@1
  int v30; // [sp+24h] [bp-Ch]@1
  int v31; // [sp+28h] [bp-8h]@1
  int v32; // [sp+2Ch] [bp-4h]@1

  v8 = *(_DWORD *)a4;
  v9 = *(_DWORD *)(a4 + 4);
  v32 = *a5;
  v10 = *a6;
  v11 = *a7;
  v12 = a1;
  v13 = *(_BYTE *)(a1 + 12) == 0;
  v27 = __PAIR__(v9, v8);
  v31 = v10;
  v30 = v11;
  v29 = 1;
  if ( !v13 && *(_DWORD *)(a1 + 16) == 2 )
  {
    v32 += 16;
    v14 = *(_DWORD *)(*(_DWORD *)(a1 + 20) + 8);
    if ( v14 != 6 && v14 != 7 )
    {
      MessageBoxW(0, L"Invalid array value type!", L"ERROR", 0x10u);
      v9 = HIDWORD(v27);
      v8 = v27;
      goto LABEL_34;
    }
    v15 = a3;
    v16 = 0;
    a2(v8, v9, 4, 0, &a1, a3);
    v27 += 4i64;
    if ( (_BYTE)a8 )
    {
      BYTE3(v28) = a1;
      *(_WORD *)((char *)&v28 + 1) = __PAIR__(BYTE1(a1), BYTE2(a1));
      LOBYTE(v28) = BYTE3(a1);
      a1 = v28;
    }
    if ( !stricmp(*(const char **)(v12 + 4), "TypelessData") )
    {
      v30 += a1;
      v9 = (a1 + v27) >> 32;
      v8 = a1 + v27;
      goto LABEL_32;
    }
    v31 += 4 * a1;
    if ( a1 )
    {
      do
      {
        v17 = sub_10013BF0(*(_DWORD *)(v12 + 20) + 24, a2, v15, &v27, &v32, &v31, &v30, a8);
        v29 += v17;
        ++v16;
      }
      while ( v16 < a1 );
    }
    goto LABEL_31;
  }
  v18 = *(_DWORD *)(a1 + 8);
  if ( v18 != 12 )
  {
    v21 = *(_DWORD *)(a1 + 16);
    if ( !v21 )
    {
      switch ( v18 )
      {
        case 1:
        case 2:
        case 3:
          v9 = (__PAIR__(v9, v8++) + 1) >> 32;
          v32 += 16;
          break;
        case 4:
        case 5:
          v9 = (__PAIR__(v9, v8) + 2) >> 32;
          v8 += 2;
          v32 += 16;
          break;
        case 6:
        case 7:
        case 10:
          v9 = (__PAIR__(v9, v8) + 4) >> 32;
          v8 += 4;
          v32 += 16;
          break;
        case 8:
        case 9:
        case 11:
          v9 = (__PAIR__(v9, v8) + 8) >> 32;
          v8 += 8;
          goto LABEL_27;
        default:
LABEL_27:
          v32 += 16;
          break;
      }
      goto LABEL_32;
    }
    v31 = v10 + 4 * v21;
    v22 = 0;
    if ( !v21 )
    {
LABEL_32:
      if ( *(_BYTE *)(v12 + 13) )
      {
        v9 = (__PAIR__(v9, v8) + 3) >> 32;
        v8 = (v8 + 3) & 0xFFFFFFFC;
      }
      goto LABEL_34;
    }
    v23 = 0;
    do
    {
      v24 = sub_10013BF0(v23 + *(_DWORD *)(v12 + 20), a2, a3, &v27, &v32, &v31, &v30, a8);
      v29 += v24;
      ++v22;
      v23 += 24;
    }
    while ( v22 < *(_DWORD *)(v12 + 16) );
LABEL_31:
    v9 = HIDWORD(v27);
    v8 = v27;
    goto LABEL_32;
  }
  a2(v8, v9, 4, 0, &a1, a3);
  v19 = a1;
  v20 = v27 + 4;
  if ( (_BYTE)a8 )
  {
    BYTE2(v28) = BYTE1(a1);
    BYTE3(v28) = a1;
    LOBYTE(v28) = BYTE3(a1);
    BYTE1(v28) = BYTE2(a1);
    v19 = v28;
    a1 = v28;
  }
  v9 = ((unsigned __int64)(unsigned int)v19 + v20) >> 32;
  v8 = v19 + v20;
  v13 = *(_BYTE *)(v12 + 13) == 0;
  v27 = (unsigned int)v19 + v20;
  if ( !v13 || *(_DWORD *)(v12 + 16) && *(_BYTE *)(*(_DWORD *)(v12 + 20) + 13) )
  {
    v9 = (__PAIR__(v9, v8) + 3) >> 32;
    v8 = (v8 + 3) & 0xFFFFFFFC;
  }
  v32 += v19 + 17;
LABEL_34:
  *a7 = v30;
  *a6 = v31;
  *a5 = v32;
  v25 = a4;
  *(_DWORD *)a4 = v8;
  result = v29;
  *(_DWORD *)(v25 + 4) = v9;
  return result;
}

//----- (10013EA0) --------------------------------------------------------
unsigned int __cdecl sub_10013EA0(int a1, void (__cdecl *a2)(unsigned int, int, unsigned __int32, _DWORD, void *, int), int a3, __int64 a4, int a5, _DWORD *a6, _DWORD *a7, int *a8, void **a9, int a10)
{
  int v10; // ecx@1
  int v11; // ecx@3
  unsigned int v12; // esi@5
  int v13; // edi@6
  void *v14; // ST24_4@9
  _DWORD *v15; // ecx@9
  int v16; // eax@9
  int v17; // eax@9
  int v18; // eax@9
  bool v19; // zf@9
  int v20; // eax@10
  int v21; // edx@10
  int v22; // ecx@10
  int v23; // edx@10
  int v24; // ecx@10
  int v25; // edx@10
  int v26; // eax@10
  int v27; // edx@13
  int v28; // edx@16
  signed __int64 v29; // kr10_8@17
  void *v30; // ST24_4@19
  _DWORD *v31; // edx@19
  int v32; // eax@19
  int v33; // eax@19
  int v34; // ecx@19
  unsigned __int32 v35; // ecx@23
  _DWORD *v36; // ecx@39
  int v37; // eax@39
  int v38; // eax@39
  int v39; // edx@40
  int v40; // eax@40
  int v41; // edi@41
  unsigned int v42; // eax@43
  int v43; // edx@43
  unsigned __int32 v45; // [sp+Ch] [bp-48h]@10
  int v46; // [sp+10h] [bp-44h]@10
  int *v47; // [sp+14h] [bp-40h]@1
  void (__cdecl *v48)(unsigned int, int, unsigned __int32, _DWORD, void *, int); // [sp+18h] [bp-3Ch]@1
  void **v49; // [sp+1Ch] [bp-38h]@1
  int v50; // [sp+20h] [bp-34h]@9
  int v51; // [sp+24h] [bp-30h]@9
  int v52; // [sp+28h] [bp-2Ch]@9
  int v53; // [sp+2Ch] [bp-28h]@9
  int v54; // [sp+30h] [bp-24h]@1
  _DWORD *v55; // [sp+34h] [bp-20h]@1
  int v56; // [sp+38h] [bp-1Ch]@1
  unsigned __int32 v57; // [sp+3Ch] [bp-18h]@7
  unsigned __int32 v58; // [sp+40h] [bp-14h]@6
  unsigned __int32 v59; // [sp+44h] [bp-10h]@9
  void *v60; // [sp+48h] [bp-Ch]@9

  v10 = a1;
  v19 = *(_BYTE *)(a1 + 12) == 0;
  v55 = a7;
  v56 = a1;
  v48 = a2;
  v54 = a5;
  v47 = a8;
  v49 = a9;
  if ( !v19 )
  {
    if ( *(_DWORD *)(a1 + 16) != 2 )
    {
      MessageBoxW(0, L"Invalid array!", L"ERROR", 0x10u);
      return a4;
    }
    v11 = *(_DWORD *)(*(_DWORD *)(a1 + 20) + 8);
    if ( v11 != 6 && v11 != 7 )
    {
      MessageBoxW(0, L"Invalid array value type!", L"ERROR", 0x10u);
      return a4;
    }
    a2(a4, HIDWORD(a4), 4u, 0, &v58, a3);
    v13 = (unsigned __int64)(a4 + 4) >> 32;
    v12 = a4 + 4;
    if ( (_BYTE)a10 )
    {
      BYTE2(v57) = BYTE1(v58);
      BYTE3(v57) = v58;
      LOBYTE(v57) = BYTE3(v58);
      BYTE1(v57) = BYTE2(v58);
      v58 = v57;
    }
    if ( !stricmp(*(const char **)(v56 + 4), "TypelessData") )
    {
      v14 = *v49;
      v59 = v58;
      v60 = v14;
      v48(v12, v13, v58, 0, v14, a3);
      v12 += v58;
      *v49 = (char *)*v49 + v58;
      v50 = 14;
      AssetTypeValue::Set((AssetTypeValue *)&v50, &v59);
      v15 = v55;
      v16 = *v55;
      *(_DWORD *)v16 = v50;
      *(_DWORD *)(v16 + 4) = v51;
      *(_DWORD *)(v16 + 8) = v52;
      *(_DWORD *)(v16 + 12) = v53;
      v17 = v54 + 16 * *a6;
      *(_DWORD *)(v17 + 12) = *v15;
      *(_DWORD *)v17 = v56;
      *(_DWORD *)(v17 + 4) = 0;
      *(_DWORD *)(v17 + 8) = 0;
      ++*a6;
      v18 = v56;
      *v15 += 16;
      v19 = *(_BYTE *)(v18 + 13) == 0;
    }
    else
    {
      v45 = v58;
      v50 = 13;
      AssetTypeValue::Set((AssetTypeValue *)&v50, &v45);
      v20 = *v55;
      v21 = v51;
      *(_DWORD *)v20 = v50;
      v22 = v52;
      *(_DWORD *)(v20 + 4) = v21;
      v23 = v53;
      *(_DWORD *)(v20 + 8) = v22;
      *(_DWORD *)(v20 + 12) = v23;
      v24 = *v47;
      *v47 += 4 * v58;
      v25 = *v55;
      v60 = (void *)v58;
      v26 = v54 + 16 * *a6;
      v46 = v24;
      *(_DWORD *)(v26 + 12) = v25;
      *(_DWORD *)v26 = v56;
      *(_DWORD *)(v26 + 4) = v60;
      *(_DWORD *)(v26 + 8) = v24;
      *v55 += 16;
      ++*a6;
      v57 = 0;
      if ( v58 )
      {
        while ( 1 )
        {
          *(_DWORD *)(v24 + 4 * v57) = v54 + 16 * *a6;
          v12 = sub_10013EA0(*(_DWORD *)(v56 + 20) + 24, v48, a3, v12, v13, v54, a6, v55, v47, v49, a10);
          v13 = v27;
          if ( ++v57 >= v58 )
            break;
          v24 = v46;
        }
      }
      v19 = *(_BYTE *)(v56 + 13) == 0;
    }
    goto LABEL_45;
  }
  v28 = *(_DWORD *)(a1 + 8);
  if ( v28 == 12 )
  {
    a2(a4, HIDWORD(a4), 4u, 0, &v58, a3);
    v29 = a4 + 4;
    if ( (_BYTE)a10 )
    {
      BYTE3(v57) = v58;
      *(_WORD *)((char *)&v57 + 1) = __PAIR__(BYTE1(v58), BYTE2(v58));
      LOBYTE(v57) = BYTE3(v58);
      v58 = v57;
    }
    v30 = (void *)(*v55 + 16);
    v60 = v30;
    *((_BYTE *)v30 + v58) = 0;
    v48(v29, HIDWORD(v29), v58, 0, v30, a3);
    v12 = v58 + v29;
    v50 = 12;
    AssetTypeValue::Set((AssetTypeValue *)&v50, v60);
    v31 = v55;
    v32 = *v55;
    *(_DWORD *)v32 = v50;
    *(_DWORD *)(v32 + 4) = v51;
    *(_DWORD *)(v32 + 8) = v52;
    *(_DWORD *)(v32 + 12) = v53;
    v33 = v54 + 16 * *a6;
    *(_DWORD *)(v33 + 12) = *v31;
    v34 = v56;
    *(_DWORD *)v33 = v56;
    *(_DWORD *)(v33 + 4) = 0;
    *(_DWORD *)(v33 + 8) = 0;
    if ( *(_BYTE *)(v34 + 13) || *(_DWORD *)(v34 + 16) && *(_BYTE *)(*(_DWORD *)(v34 + 20) + 13) )
      v12 = (v12 + 3) & 0xFFFFFFFC;
    v35 = v58;
    ++*a6;
    *v31 += v35 + 17;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 16) )
    {
      v39 = *a8;
      *a8 += 4 * *(_DWORD *)(a1 + 16);
      v40 = a5 + 16 * *a6;
      *(_DWORD *)(v40 + 4) = *(_DWORD *)(a1 + 16);
      v12 = a4;
      *(_DWORD *)(v40 + 12) = 0;
      *(_DWORD *)v40 = a1;
      *(_DWORD *)(v40 + 8) = v39;
      ++*a6;
      v46 = v39;
      v57 = 0;
      if ( *(_DWORD *)(a1 + 16) )
      {
        v58 = 0;
        v41 = HIDWORD(a4);
        while ( 1 )
        {
          *(_DWORD *)(v39 + 4 * v57) = v54 + 16 * *a6;
          v42 = sub_10013EA0(v58 + *(_DWORD *)(v56 + 20), v48, a3, v12, v41, v54, a6, v55, v47, v49, a10);
          v10 = v56;
          v58 += 24;
          v12 = v42;
          v41 = v43;
          if ( ++v57 >= *(_DWORD *)(v56 + 16) )
            break;
          v39 = v46;
        }
      }
      v19 = *(_BYTE *)(v10 + 13) == 0;
LABEL_45:
      if ( !v19 )
        v12 = (v12 + 3) & 0xFFFFFFFC;
      return v12;
    }
    v59 = 0;
    v60 = 0;
    switch ( v28 )
    {
      case 1:
      case 2:
      case 3:
        a2(a4, HIDWORD(a4), 1u, 0, &v59, a3);
        v10 = v56;
        v12 = a4 + 1;
        break;
      case 4:
      case 5:
        a2(a4, HIDWORD(a4), 2u, 0, &v59, a3);
        if ( (_BYTE)a10 )
        {
          LOBYTE(v58) = BYTE1(v59);
          BYTE1(v58) = v59;
          LOWORD(v59) = v58;
        }
        v10 = v56;
        v12 = a4 + 2;
        break;
      case 6:
      case 7:
      case 10:
        a2(a4, HIDWORD(a4), 4u, 0, &v59, a3);
        if ( (_BYTE)a10 )
          SwapEndians_(&v59);
        v10 = v56;
        v12 = a4 + 4;
        break;
      case 8:
      case 9:
      case 11:
        a2(a4, HIDWORD(a4), 8u, 0, &v59, a3);
        if ( (_BYTE)a10 )
          sub_1000AEB0((int)&v59);
        v10 = v56;
        v12 = a4 + 8;
        break;
      default:
        v12 = a4;
        break;
    }
    if ( *(_BYTE *)(v10 + 13) )
      v12 = (v12 + 3) & 0xFFFFFFFC;
    v50 = *(_DWORD *)(v10 + 8);
    AssetTypeValue::Set((AssetTypeValue *)&v50, &v59);
    v36 = v55;
    v37 = *v55;
    *(_DWORD *)v37 = v50;
    *(_DWORD *)(v37 + 4) = v51;
    *(_DWORD *)(v37 + 8) = v52;
    *(_DWORD *)(v37 + 12) = v53;
    v38 = v54 + 16 * *a6;
    *(_DWORD *)(v38 + 12) = *v36;
    *(_DWORD *)v38 = v56;
    *(_DWORD *)(v38 + 4) = 0;
    *(_DWORD *)(v38 + 8) = 0;
    ++*a6;
    *v36 += 16;
  }
  return v12;
}

//----- (10014440) --------------------------------------------------------
AssetTypeTemplateField *__thiscall AssetTypeTemplateField::AssetTypeTemplateField(AssetTypeTemplateField *this)
{
  AssetTypeTemplateField *result; // eax@1

  result = this;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
  return result;
}

//----- (10014460) --------------------------------------------------------
void __thiscall AssetTypeTemplateField::Clear(AssetTypeTemplateField *this)
{
  AssetTypeTemplateField *v1; // esi@1
  int v2; // eax@1
  unsigned int v3; // edi@2
  int v4; // ebx@3

  v1 = this;
  v2 = *((_DWORD *)this + 4);
  if ( v2 )
  {
    v3 = 0;
    if ( v2 )
    {
      v4 = 0;
      do
      {
        AssetTypeTemplateField::Clear((AssetTypeTemplateField *)(v4 + *((_DWORD *)v1 + 5)));
        ++v3;
        v4 += 24;
      }
      while ( v3 < *((_DWORD *)v1 + 4) );
    }
    free(*((void **)v1 + 5));
    *((_DWORD *)v1 + 5) = 0;
    *((_DWORD *)v1 + 4) = 0;
  }
}

//----- (100144B0) --------------------------------------------------------
int __thiscall AssetTypeTemplateField::MakeValue(AssetTypeTemplateField *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 a4, struct AssetTypeValueField **a5, int a6)
{
  AssetTypeTemplateField *v6; // ebx@1
  int v7; // eax@1
  int v8; // edi@1
  struct AssetTypeValueField *v9; // eax@1
  struct AssetTypeValueField *v10; // esi@1
  int result; // eax@2
  int v12; // [sp+Ch] [bp-24h]@1
  int v13; // [sp+10h] [bp-20h]@1
  int v14; // [sp+14h] [bp-1Ch]@1
  int v15; // [sp+18h] [bp-18h]@1
  char *v16; // [sp+1Ch] [bp-14h]@3
  char *v17; // [sp+20h] [bp-10h]@3
  int v18; // [sp+24h] [bp-Ch]@3
  unsigned __int64 v19; // [sp+28h] [bp-8h]@1

  v19 = a4;
  v6 = this;
  v14 = 0;
  v12 = 0;
  v13 = 0;
  v7 = sub_10013BF0(
         (unsigned int)this,
         (void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, unsigned int *, int))a2,
         a3,
         (int)&v19,
         &v14,
         &v12,
         &v13,
         a6);
  v8 = v14;
  v15 = 16 * v7;
  v9 = (struct AssetTypeValueField *)malloc(v14 + v12 + v13 + 16 * v7);
  v10 = v9;
  if ( v9 )
  {
    v17 = (char *)v9 + v15;
    v16 = (char *)v9 + v15 + v8;
    v15 += (int)v9 + v12 + v8;
    v18 = 0;
    result = sub_10013EA0(
               (int)v6,
               (void (__cdecl *)(unsigned int, int, unsigned __int32, _DWORD, void *, int))a2,
               a3,
               a4,
               (int)v9,
               &v18,
               &v17,
               (int *)&v16,
               (void **)&v15,
               a6);
    *a5 = v10;
  }
  else
  {
    *a5 = 0;
    result = a4;
  }
  return result;
}

//----- (100145A0) --------------------------------------------------------
char __thiscall AssetTypeTemplateField::From0D(AssetTypeTemplateField *this, struct Type_0D *a2, unsigned __int32 a3)
{
  struct Type_0D *v3; // edi@1
  AssetTypeTemplateField *v4; // esi@1
  char result; // al@2
  unsigned __int32 v6; // ebx@3
  unsigned int v7; // eax@3
  char *v8; // ecx@3
  unsigned int v9; // eax@4
  unsigned int v10; // eax@8
  char *v11; // edx@8
  unsigned int v12; // eax@9
  char v13; // al@16
  unsigned __int32 v14; // eax@18
  int v15; // ecx@19
  unsigned __int8 v16; // cl@20
  int v17; // eax@26
  void *v18; // eax@27
  unsigned __int32 v19; // ebx@30
  int v20; // eax@31
  unsigned __int8 v21; // cl@32
  unsigned __int32 v22; // [sp+8h] [bp-Ch]@18
  unsigned __int32 v23; // [sp+8h] [bp-Ch]@31
  int v24; // [sp+Ch] [bp-8h]@31
  unsigned __int32 v25; // [sp+10h] [bp-4h]@3
  unsigned __int8 v26; // [sp+1Fh] [bp+Bh]@18
  unsigned __int32 v27; // [sp+20h] [bp+Ch]@19
  char v28; // [sp+23h] [bp+Fh]@30

  v3 = a2;
  v4 = this;
  if ( *((_DWORD *)a2 + 10) <= a3 )
  {
    result = 0;
    *(_DWORD *)this = 0;
    *((_DWORD *)this + 1) = 0;
    *((_DWORD *)this + 2) = 0;
    *((_DWORD *)this + 3) = 0;
    *((_DWORD *)this + 4) = 0;
    *((_DWORD *)this + 5) = 0;
    return result;
  }
  v6 = *((_DWORD *)a2 + 11) + 24 * a3;
  v7 = *(_DWORD *)(v6 + 4);
  v8 = 0;
  v25 = *((_DWORD *)a2 + 11) + 24 * a3;
  if ( (v7 & 0x80000000) == 0 )
  {
    if ( v7 < *((_DWORD *)a2 + 12) - 1 )
      v8 = (char *)(v7 + *((_DWORD *)a2 + 13));
  }
  else
  {
    v9 = v7 & 0x7FFFFFFF;
    if ( v9 < 0x411 )
      v8 = &aAabb[v9];
  }
  *((_DWORD *)v4 + 1) = v8;
  v10 = *(_DWORD *)(v6 + 8);
  v11 = 0;
  if ( (v10 & 0x80000000) == 0 )
  {
    v6 = v25;
    if ( v10 < *((_DWORD *)a2 + 12) - 1 )
      v11 = (char *)(v10 + *((_DWORD *)a2 + 13));
  }
  else
  {
    v12 = v10 & 0x7FFFFFFF;
    if ( v12 < 0x411 )
      v11 = &aAabb[v12];
  }
  *(_DWORD *)v4 = v11;
  if ( v8 )
    *((_DWORD *)v4 + 2) = GetValueTypeByTypeName(v8);
  else
    *((_DWORD *)v4 + 2) = 0;
  v13 = *(_BYTE *)(v6 + 3);
  *((_BYTE *)v4 + 12) = v13;
  if ( v13 )
    *((_DWORD *)v4 + 2) = 13;
  *((_BYTE *)v4 + 13) = (*(_DWORD *)(v6 + 20) >> 14) & 1;
  v14 = a3 + 1;
  *((_DWORD *)v4 + 4) = 0;
  v26 = 0;
  v22 = a3 + 1;
  if ( a3 + 1 < *((_DWORD *)v3 + 10) )
  {
    v15 = 24 * v14;
    v27 = 24 * v14;
    while ( 1 )
    {
      v16 = *(_BYTE *)(v15 + *((_DWORD *)v3 + 11) + 2);
      if ( v16 <= *(_BYTE *)(v6 + 2) )
        goto LABEL_26;
      if ( !v26 )
        break;
      if ( v16 == v26 )
        goto LABEL_24;
LABEL_25:
      ++v14;
      v15 = v27 + 24;
      v27 += 24;
      if ( v14 >= *((_DWORD *)v3 + 10) )
        goto LABEL_26;
    }
    v26 = v16;
LABEL_24:
    ++*((_DWORD *)v4 + 4);
    goto LABEL_25;
  }
LABEL_26:
  v17 = *((_DWORD *)v4 + 4);
  *((_BYTE *)v4 + 14) = v17 == 0;
  if ( v17 )
  {
    v18 = malloc(24 * v17);
    *((_DWORD *)v4 + 5) = v18;
    if ( !v18 )
    {
      *((_DWORD *)v4 + 4) = 0;
      return 0;
    }
  }
  else
  {
    *((_DWORD *)v4 + 5) = 0;
  }
  v19 = v22;
  v28 = 1;
  if ( v22 < *((_DWORD *)v3 + 10) )
  {
    v20 = 24 * v22;
    v24 = 0;
    v23 = 24 * v22;
    do
    {
      v21 = *(_BYTE *)(v20 + *((_DWORD *)v3 + 11) + 2);
      if ( v21 <= *(_BYTE *)(v25 + 2) )
        break;
      if ( v21 == v26 )
      {
        if ( !AssetTypeTemplateField::From0D((AssetTypeTemplateField *)(v24 + *((_DWORD *)v4 + 5)), v3, v19) )
          v28 = 0;
        v24 += 24;
        v20 = v23;
      }
      ++v19;
      v20 += 24;
      v23 = v20;
    }
    while ( v19 < *((_DWORD *)v3 + 10) );
  }
  return v28;
}

//----- (10014770) --------------------------------------------------------
char __thiscall AssetTypeTemplateField::FromClassDatabase(AssetTypeTemplateField *this, struct ClassDatabaseFile *a2, struct ClassDatabaseType *a3, unsigned __int32 a4)
{
  struct ClassDatabaseType *v4; // esi@1
  AssetTypeTemplateField *v5; // edi@1
  char result; // al@2
  unsigned __int32 v7; // ebx@3
  int v8; // eax@4
  unsigned int v9; // edx@5
  char *v10; // eax@9
  unsigned __int32 v11; // eax@16
  int v12; // ecx@17
  unsigned __int8 v13; // cl@18
  bool v14; // cl@26
  int v15; // ecx@28
  void *v16; // eax@29
  unsigned __int32 v17; // ebx@33
  int v18; // eax@34
  unsigned __int8 v19; // cl@35
  unsigned __int32 v20; // [sp+Ch] [bp-Ch]@3
  int v21; // [sp+10h] [bp-8h]@34
  unsigned __int32 v22; // [sp+14h] [bp-4h]@16
  int v23; // [sp+14h] [bp-4h]@34
  unsigned __int8 v24; // [sp+27h] [bp+Fh]@16
  unsigned __int32 v25; // [sp+28h] [bp+10h]@17
  char v26; // [sp+2Bh] [bp+13h]@33

  v4 = a3;
  v5 = this;
  if ( (*((_DWORD *)a3 + 5) - *((_DWORD *)a3 + 4)) >> 5 <= a4 )
  {
    result = 0;
    *(_DWORD *)this = 0;
    *((_DWORD *)this + 1) = 0;
    *((_DWORD *)this + 2) = 0;
    *((_DWORD *)this + 3) = 0;
    *((_DWORD *)this + 4) = 0;
    *((_DWORD *)this + 5) = 0;
    return result;
  }
  v7 = *((_DWORD *)a3 + 4) + 32 * a4;
  v20 = *((_DWORD *)a3 + 4) + 32 * a4;
  *((_BYTE *)this + 12) = *(_BYTE *)(v7 + 17) != 0;
  if ( *(_BYTE *)(v7 + 12) )
  {
    v9 = *(_DWORD *)(v7 + 8);
    if ( v9 < *((_DWORD *)a2 + 7) )
      v8 = v9 + *((_DWORD *)a2 + 13);
    else
      v8 = 0;
  }
  else
  {
    v8 = *(_DWORD *)(v7 + 8);
  }
  *(_DWORD *)this = v8;
  if ( *(_BYTE *)(v7 + 4) )
  {
    if ( *(_DWORD *)v7 < *((_DWORD *)a2 + 7) )
      v10 = (char *)(*(_DWORD *)v7 + *((_DWORD *)a2 + 13));
    else
      v10 = 0;
  }
  else
  {
    v10 = *(char **)v7;
  }
  *((_DWORD *)this + 1) = v10;
  if ( v10 )
    *((_DWORD *)this + 2) = GetValueTypeByTypeName(v10);
  else
    *((_DWORD *)this + 2) = 0;
  *((_BYTE *)v5 + 13) = (*(_DWORD *)(v7 + 28) >> 14) & 1;
  *((_DWORD *)v5 + 4) = 0;
  v11 = a4 + 1;
  v24 = 0;
  v22 = a4 + 1;
  if ( a4 + 1 < (*((_DWORD *)v4 + 5) - *((_DWORD *)v4 + 4)) >> 5 )
  {
    v12 = 32 * v11;
    v25 = 32 * v11;
    while ( 1 )
    {
      v13 = *(_BYTE *)(v12 + *((_DWORD *)v4 + 4) + 16);
      if ( v13 <= *(_BYTE *)(v7 + 16) )
      {
LABEL_24:
        v11 = v22;
        goto LABEL_25;
      }
      if ( !v24 )
        break;
      if ( v13 == v24 )
        goto LABEL_22;
LABEL_23:
      ++v11;
      v12 = v25 + 32;
      v25 += 32;
      if ( v11 >= (*((_DWORD *)v4 + 5) - *((_DWORD *)v4 + 4)) >> 5 )
        goto LABEL_24;
    }
    v24 = v13;
LABEL_22:
    ++*((_DWORD *)v5 + 4);
    goto LABEL_23;
  }
LABEL_25:
  if ( (*((_DWORD *)v4 + 5) - *((_DWORD *)v4 + 4)) >> 5 <= v11 )
    v14 = 1;
  else
    v14 = *((_DWORD *)v5 + 4) == 0;
  *((_BYTE *)v5 + 14) = v14;
  v15 = *((_DWORD *)v5 + 4);
  if ( v15 )
  {
    v16 = malloc(24 * v15);
    *((_DWORD *)v5 + 5) = v16;
    if ( !v16 )
    {
      *((_DWORD *)v5 + 4) = 0;
      return 0;
    }
    v11 = v22;
  }
  else
  {
    *((_DWORD *)v5 + 5) = 0;
  }
  v17 = v11;
  v26 = 1;
  if ( v11 < (*((_DWORD *)v4 + 5) - *((_DWORD *)v4 + 4)) >> 5 )
  {
    v18 = 32 * v11;
    v23 = 0;
    v21 = 32 * v17;
    do
    {
      v19 = *(_BYTE *)(v18 + *((_DWORD *)v4 + 4) + 16);
      if ( v19 <= *(_BYTE *)(v20 + 16) )
        break;
      if ( v19 == v24 )
      {
        if ( !AssetTypeTemplateField::FromClassDatabase(
                (AssetTypeTemplateField *)(v23 + *((_DWORD *)v5 + 5)),
                a2,
                v4,
                v17) )
          v26 = 0;
        v23 += 24;
        v18 = v21;
      }
      ++v17;
      v18 += 32;
      v21 = v18;
    }
    while ( v17 < (*((_DWORD *)v4 + 5) - *((_DWORD *)v4 + 4)) >> 5 );
  }
  return v26;
}

//----- (10014960) --------------------------------------------------------
char __thiscall AssetTypeTemplateField::From07(AssetTypeTemplateField *this, struct TypeField_07 *a2)
{
  struct TypeField_07 *v2; // edi@1
  AssetTypeTemplateField *v3; // esi@1
  unsigned int v4; // ebx@1
  int v5; // eax@1
  unsigned int v6; // eax@1
  void *v7; // eax@2
  int v9; // [sp+Ch] [bp-8h]@6
  int v10; // [sp+10h] [bp-4h]@6
  char v11; // [sp+1Fh] [bp+Bh]@5

  v2 = a2;
  v3 = this;
  v4 = 0;
  *((_BYTE *)this + 12) = *((_DWORD *)a2 + 130) != 0;
  *((_BYTE *)this + 13) = (*((_DWORD *)a2 + 132) >> 14) & 1;
  *(_DWORD *)this = (char *)a2 + 256;
  *((_DWORD *)this + 1) = a2;
  *((_DWORD *)this + 2) = GetValueTypeByTypeName((char *)a2);
  v5 = *((_DWORD *)a2 + 133);
  *((_DWORD *)v3 + 4) = v5;
  *((_BYTE *)v3 + 14) = v5 == 0;
  v6 = *((_DWORD *)v3 + 4);
  if ( v6 <= 0 )
  {
    *((_DWORD *)v3 + 5) = 0;
  }
  else
  {
    v7 = malloc(24 * v6);
    *((_DWORD *)v3 + 5) = v7;
    if ( !v7 )
    {
      *((_DWORD *)v3 + 4) = 0;
      return 0;
    }
  }
  v11 = 1;
  if ( *((_DWORD *)v3 + 4) )
  {
    v9 = 0;
    v10 = 0;
    do
    {
      if ( !AssetTypeTemplateField::From07(
              (AssetTypeTemplateField *)(v9 + *((_DWORD *)v3 + 5)),
              (struct TypeField_07 *)(v10 + *((_DWORD *)v2 + 134))) )
        v11 = 0;
      v10 += 540;
      v9 += 24;
      ++v4;
    }
    while ( v4 < *((_DWORD *)v3 + 4) );
  }
  return v11;
}

//----- (10014A40) --------------------------------------------------------
struct AssetTypeTemplateField *__thiscall AssetTypeTemplateField::SearchChild(AssetTypeTemplateField *this, const char *a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // esi@1
  const char **v4; // edi@2
  struct AssetTypeTemplateField *result; // eax@5
  int v6; // [sp+Ch] [bp-4h]@2

  v2 = *((_DWORD *)this + 4);
  v3 = 0;
  if ( v2 )
  {
    v6 = *((_DWORD *)this + 5);
    v4 = (const char **)*((_DWORD *)this + 5);
    while ( strcmp(*v4, a2) )
    {
      ++v3;
      v4 += 6;
      if ( v3 >= v2 )
        goto LABEL_5;
    }
    result = (struct AssetTypeTemplateField *)(v6 + 24 * v3);
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (10014AB0) --------------------------------------------------------
int __thiscall AssetTypeInstance::AssetTypeInstance(int this, int a2, int a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a5, int a6, unsigned __int64 a7)
{
  int v7; // esi@1
  int result; // eax@2
  void *v9; // eax@3
  unsigned int v10; // ebx@5
  unsigned int v11; // eax@6
  int v12; // edi@7
  int v13; // edx@7

  v7 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)this = a2;
  if ( a2 )
  {
    v9 = malloc(4 * a2);
    *(_DWORD *)(v7 + 4) = v9;
    if ( v9 )
    {
      v10 = 0;
      *(_DWORD *)(v7 + 16) = malloc(4 * a2);
      *(_DWORD *)(v7 + 12) = a2;
      *(_DWORD *)(v7 + 8) = a2;
      if ( a2 )
      {
        v11 = a7;
        do
        {
          v12 = 4 * v10;
          v11 = AssetTypeTemplateField::MakeValue(
                  *(AssetTypeTemplateField **)(4 * v10 + a3),
                  a4,
                  a5,
                  __PAIR__(HIDWORD(a7), v11),
                  (struct AssetTypeValueField **)(4 * v10 + *(_DWORD *)(v7 + 4)),
                  a6);
          HIDWORD(a7) = v13;
          ++v10;
          *(_DWORD *)(v12 + *(_DWORD *)(v7 + 16)) = *(_DWORD *)(v12 + *(_DWORD *)(v7 + 4));
        }
        while ( v10 < a2 );
      }
      result = v7;
    }
    else
    {
      *(_DWORD *)v7 = 0;
      result = v7;
    }
  }
  else
  {
    *(_DWORD *)(this + 4) = 0;
    result = this;
  }
  return result;
}

//----- (10014B70) --------------------------------------------------------
bool __thiscall AssetTypeInstance::SetChildList(AssetTypeInstance *this, struct AssetTypeValueField *a2, struct AssetTypeValueField **a3, unsigned __int32 a4, bool a5)
{
  struct AssetTypeValueField *v5; // ebx@1
  struct AssetTypeValueField **v6; // edi@1
  AssetTypeInstance *v7; // esi@1
  struct AssetTypeValueField **v8; // ecx@1
  bool result; // al@3
  struct AssetTypeValueField *v10; // edx@4
  struct AssetTypeValueField ***v11; // eax@5
  int v12; // eax@9
  unsigned int v13; // edi@10
  void *v14; // eax@10
  unsigned int v15; // ecx@12
  unsigned int v16; // eax@15
  struct AssetTypeValueField *v17; // edx@16
  int v18; // eax@20
  unsigned int v19; // edi@23
  struct AssetTypeValueField **v20; // eax@24
  unsigned int v21; // [sp+Ch] [bp-4h]@12
  struct AssetTypeValueField *v22; // [sp+18h] [bp+8h]@12

  v5 = a2;
  v6 = a3;
  v7 = this;
  v8 = (struct AssetTypeValueField **)*((_DWORD *)a2 + 2);
  if ( v8 == a3 )
  {
    if ( *((_DWORD *)a2 + 1) != a4 )
    {
      *((_DWORD *)a2 + 2) = a3;
      *((_DWORD *)a2 + 1) = a4;
      return 1;
    }
    return 1;
  }
  v10 = 0;
  if ( !*((_DWORD *)v7 + 2) )
  {
LABEL_8:
    *((_DWORD *)a2 + 2) = a3;
    *((_DWORD *)a2 + 1) = a4;
    if ( a5 )
    {
      v12 = *((_DWORD *)v7 + 2);
      if ( *((_DWORD *)v7 + 3) < (unsigned int)(v12 + 1) )
      {
        v13 = (v12 + 8) & 0xFFFFFFF8;
        v14 = realloc(*((void **)v7 + 4), 4 * v13);
        if ( !v14 )
          return 0;
        *((_DWORD *)v7 + 3) = v13;
        v6 = a3;
        *((_DWORD *)v7 + 4) = v14;
      }
      *(_DWORD *)(*((_DWORD *)v7 + 4) + 4 * (*((_DWORD *)v7 + 2))++) = v6;
    }
    return 1;
  }
  v11 = (struct AssetTypeValueField ***)*((_DWORD *)v7 + 4);
  while ( *v11 != v8 )
  {
    v10 = (struct AssetTypeValueField *)((char *)v10 + 1);
    ++v11;
    if ( (unsigned int)v10 >= *((_DWORD *)v7 + 2) )
      goto LABEL_8;
  }
  v15 = 0;
  v22 = v10;
  v21 = 0;
  if ( *((_DWORD *)v5 + 1) )
  {
    while ( 1 )
    {
      v16 = *((_DWORD *)v5 + 1);
      if ( v16 != -1 )
        v17 = (struct AssetTypeValueField *)(v15 < v16 ? *(_DWORD *)(*((_DWORD *)v5 + 2) + 4 * v15) : &unk_100ADF9C);
      else
        v17 = v5;
      v18 = 0;
      if ( a4 )
      {
        while ( v17 != v6[v18] )
        {
          if ( ++v18 >= a4 )
            goto LABEL_23;
        }
      }
      else
      {
LABEL_23:
        v19 = 0;
        if ( *((_DWORD *)v7 + 2) )
        {
          v20 = (struct AssetTypeValueField **)*((_DWORD *)v7 + 4);
          while ( *v20 != v17 )
          {
            ++v19;
            ++v20;
            if ( v19 >= *((_DWORD *)v7 + 2) )
              goto LABEL_29;
          }
          free(*(void **)(*((_DWORD *)v7 + 4) + 4 * v19));
          memcpy(
            (void *)(*((_DWORD *)v7 + 4) + 4 * v19),
            (const void *)(*((_DWORD *)v7 + 4) + 4 * v19 + 4),
            *((_DWORD *)v7 + 2) - v19 - 1);
          --*((_DWORD *)v7 + 2);
        }
LABEL_29:
        v6 = a3;
      }
      if ( ++v21 >= *((_DWORD *)v5 + 1) )
        break;
      v15 = v21;
    }
    v10 = v22;
  }
  free(*(void **)(*((_DWORD *)v7 + 4) + 4 * (_DWORD)v10));
  *((_DWORD *)v5 + 2) = v6;
  *((_DWORD *)v5 + 1) = a4;
  if ( a5 )
  {
    *(_DWORD *)(*((_DWORD *)v7 + 4) + 4 * (_DWORD)v22) = v6;
    result = 1;
  }
  else
  {
    memcpy(
      (void *)(*((_DWORD *)v7 + 4) + 4 * (_DWORD)v22),
      (const void *)(*((_DWORD *)v7 + 4) + 4 * (_DWORD)v22 + 4),
      *((_DWORD *)v7 + 2) - (_DWORD)v22 - 1);
    --*((_DWORD *)v7 + 2);
    result = 1;
  }
  return result;
}

//----- (10014D30) --------------------------------------------------------
char __thiscall AssetTypeInstance::AddTempMemory(AssetTypeInstance *this, void *a2)
{
  AssetTypeInstance *v2; // esi@1
  int v3; // eax@1
  unsigned int v4; // edi@2
  void *v5; // eax@2
  char result; // al@3

  v2 = this;
  v3 = *((_DWORD *)this + 2);
  if ( *((_DWORD *)this + 3) < (unsigned int)(v3 + 1) )
  {
    v4 = (v3 + 8) & 0xFFFFFFF8;
    v5 = realloc(*((void **)this + 4), 4 * v4);
    if ( !v5 )
      return 0;
    *((_DWORD *)v2 + 3) = v4;
    *((_DWORD *)v2 + 4) = v5;
  }
  *(_DWORD *)(*((_DWORD *)v2 + 4) + 4 * *((_DWORD *)v2 + 2)) = a2;
  result = 1;
  ++*((_DWORD *)v2 + 2);
  return result;
}

//----- (10014D90) --------------------------------------------------------
void __thiscall AssetTypeInstance::~AssetTypeInstance(AssetTypeInstance *this)
{
  AssetTypeInstance *v1; // esi@1
  unsigned int v2; // edi@2
  void *v3; // ST00_4@4

  v1 = this;
  if ( *(_DWORD *)this )
  {
    v2 = 0;
    if ( *((_DWORD *)this + 2) )
    {
      do
        free(*(void **)(*((_DWORD *)v1 + 4) + 4 * v2++));
      while ( v2 < *((_DWORD *)v1 + 2) );
    }
    free(*((void **)v1 + 4));
    v3 = (void *)*((_DWORD *)v1 + 1);
    *((_DWORD *)v1 + 2) = 0;
    *((_DWORD *)v1 + 3) = 0;
    *((_DWORD *)v1 + 4) = 0;
    free(v3);
    *((_DWORD *)v1 + 1) = 0;
    *(_DWORD *)v1 = 0;
  }
}

//----- (10014DF0) --------------------------------------------------------
void *__thiscall sub_10014DF0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_100A1FAC;
  if ( a2 & 1 )
    operator delete(this);
  return v2;
}
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100A1FAC: using guessed type void *off_100A1FAC;

//----- (10014E20) --------------------------------------------------------
int __userpurge sub_10014E20@<eax>(const char *a1@<ebx>, int a2, int a3)
{
  unsigned int v3; // kr00_4@2
  void *v4; // eax@2

  *(_DWORD *)a2 = &off_100A1FDC;
  *(_DWORD *)(a2 + 4) = a3;
  if ( a1 )
  {
    v3 = strlen(a1);
    v4 = (void *)unknown_libname_4(v3 + 1);
    *(_DWORD *)(a2 + 8) = v4;
    memcpy(v4, a1, v3 + 1);
  }
  else
  {
    *(_DWORD *)(a2 + 8) = 0;
  }
  return a2;
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 100A1FDC: using guessed type int (*off_100A1FDC)();

//----- (10014EA0) --------------------------------------------------------
void *__thiscall sub_10014EA0(int this, char a2)
{
  void *v2; // esi@1
  void *v3; // eax@1

  v2 = (void *)this;
  v3 = *(void **)(this + 8);
  *(_DWORD *)this = &off_100A1FDC;
  if ( v3 )
    operator delete[](v3);
  *(_DWORD *)v2 = &off_100A1FAC;
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}
// 10099190: using guessed type void __cdecl operator delete[](void *);
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100A1FAC: using guessed type void *off_100A1FAC;
// 100A1FDC: using guessed type int (*off_100A1FDC)();

//----- (10014EE0) --------------------------------------------------------
signed int sub_10014EE0()
{
  return 2;
}

//----- (10014EF0) --------------------------------------------------------
__int64 __thiscall sub_10014EF0(void *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4)
{
  __int64 v4; // rax@1
  __int64 v5; // kr08_8@1
  __int64 v6; // rax@1
  __int64 v7; // kr10_8@1
  __int64 v8; // rax@1
  __int64 v9; // kr18_8@1
  __int64 v10; // rax@1
  char v12; // [sp+13h] [bp-Dh]@1
  void *v13; // [sp+14h] [bp-Ch]@1
  int v14; // [sp+18h] [bp-8h]@1
  int v15; // [sp+1Ch] [bp-4h]@1

  v13 = this;
  v15 = 0;
  LODWORD(v4) = a3(a2, HIDWORD(a2), 2, 0, &v15, a4);
  v5 = v4 + a2;
  v12 = 0;
  LODWORD(v6) = a3(v5, HIDWORD(v5), 1, 0, (int *)&v12, a4);
  v7 = v6 + v5;
  v14 = (unsigned __int16)strlen(*((const char **)v13 + 2));
  LODWORD(v8) = a3(v7, HIDWORD(v7), 2, 0, &v14, a4);
  v9 = v8 + v7;
  LODWORD(v10) = a3(v9, HIDWORD(v9), (unsigned __int16)v14, 0, *((int **)v13 + 2), a4);
  return v9 + v10;
}

//----- (10014FA0) --------------------------------------------------------
char sub_10014FA0()
{
  return 0;
}

//----- (10014FB0) --------------------------------------------------------
int __fastcall sub_10014FB0(int a1, const char *a2, int a3, const char *a4, char a5)
{
  const char *v5; // ebx@1
  unsigned int v6; // kr00_4@2
  void *v7; // eax@2
  unsigned int v8; // kr04_4@5
  void *v9; // eax@5

  v5 = a2;
  *(_DWORD *)a3 = &off_100A200C;
  *(_DWORD *)(a3 + 4) = a1;
  if ( a2 )
  {
    v6 = strlen(a2);
    v7 = (void *)unknown_libname_4(v6 + 1);
    *(_DWORD *)(a3 + 8) = v7;
    memcpy(v7, v5, v6 + 1);
  }
  else
  {
    *(_DWORD *)(a3 + 8) = 0;
  }
  if ( a4 )
  {
    v8 = strlen(a4);
    v9 = (void *)unknown_libname_4(v8 + 1);
    *(_DWORD *)(a3 + 12) = v9;
    memcpy(v9, a4, v8 + 1);
    *(_BYTE *)(a3 + 16) = a5;
  }
  else
  {
    *(_DWORD *)(a3 + 12) = *(_DWORD *)(a3 + 8);
    *(_BYTE *)(a3 + 16) = a5;
  }
  return a3;
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 100A200C: using guessed type int (*off_100A200C)();

//----- (10015070) --------------------------------------------------------
int __thiscall sub_10015070(int this, char a2)
{
  int v2; // esi@1
  void *v3; // eax@1

  v2 = this;
  v3 = *(void **)(this + 12);
  *(_DWORD *)this = &off_100A200C;
  if ( v3 && v3 != *(void **)(this + 8) )
    operator delete[](v3);
  if ( *(_DWORD *)(v2 + 8) )
    operator delete[](*(void **)(v2 + 8));
  *(_DWORD *)v2 = &off_100A1FAC;
  if ( a2 & 1 )
    operator delete((void *)v2);
  return v2;
}
// 10099190: using guessed type void __cdecl operator delete[](void *);
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100A1FAC: using guessed type void *off_100A1FAC;
// 100A200C: using guessed type int (*off_100A200C)();

//----- (100150C0) --------------------------------------------------------
signed int sub_100150C0()
{
  return 1;
}

//----- (10015110) --------------------------------------------------------
int __thiscall sub_10015110(int this)
{
  return *(_DWORD *)(this + 12);
}

//----- (10015120) --------------------------------------------------------
signed __int64 sub_10015120()
{
  return -1i64;
}

//----- (10015130) --------------------------------------------------------
char __stdcall sub_10015130(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return 1;
}

//----- (10015140) --------------------------------------------------------
__int64 __thiscall sub_10015140(void *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4)
{
  __int64 v4; // rax@1
  __int64 v5; // kr10_8@1
  __int64 v6; // rax@1
  __int64 v7; // kr18_8@1
  __int64 v8; // rax@1
  __int64 v9; // kr20_8@1
  __int64 v10; // rax@1
  __int64 v11; // kr28_8@1
  __int64 v12; // rax@1
  __int64 v13; // kr30_8@1
  __int64 v14; // rax@1
  __int64 v15; // kr38_8@1
  __int64 v16; // rax@1
  char v18; // [sp+Eh] [bp-12h]@1
  bool v19; // [sp+Fh] [bp-11h]@1
  void *v20; // [sp+10h] [bp-10h]@1
  int v21; // [sp+14h] [bp-Ch]@1
  int v22; // [sp+18h] [bp-8h]@1
  int v23; // [sp+1Ch] [bp-4h]@1

  v20 = this;
  v23 = 1;
  LODWORD(v4) = a3(a2, HIDWORD(a2), 2, 0, &v23, a4);
  v5 = v4 + a2;
  v18 = 0;
  LODWORD(v6) = a3(v5, HIDWORD(v5), 1, 0, (int *)&v18, a4);
  v7 = v6 + v5;
  v21 = (unsigned __int16)strlen(*((const char **)v20 + 2));
  LODWORD(v8) = a3(v7, HIDWORD(v7), 2, 0, &v21, a4);
  v9 = v8 + v7;
  LODWORD(v10) = a3(v9, HIDWORD(v9), (unsigned __int16)v21, 0, *((int **)v20 + 2), a4);
  v11 = v10 + v9;
  v22 = (unsigned __int16)strlen(*((const char **)v20 + 3));
  LODWORD(v12) = a3(v11, HIDWORD(v11), 2, 0, &v22, a4);
  v13 = v12 + v11;
  LODWORD(v14) = a3(v13, HIDWORD(v13), (unsigned __int16)v22, 0, *((int **)v20 + 3), a4);
  v15 = v14 + v13;
  v19 = *((_BYTE *)v20 + 16) != 0;
  LODWORD(v16) = a3(v15, HIDWORD(v15), 1, 0, (int *)&v19, a4);
  return v15 + v16;
}

//----- (10015260) --------------------------------------------------------
char __thiscall sub_10015260(int this)
{
  return *(_BYTE *)(this + 16);
}

//----- (10015270) --------------------------------------------------------
int __userpurge sub_10015270@<eax>(char a1@<al>, const char *a2@<edx>, const char *a3@<ecx>, int a4@<esi>, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13)
{
  sub_10014FB0(a5, a2, a4, a3, a1);
  *(_DWORD *)(a4 + 28) = a7;
  *(_DWORD *)(a4 + 24) = a6;
  *(_DWORD *)(a4 + 40) = a10;
  *(_DWORD *)(a4 + 32) = a8;
  *(_DWORD *)(a4 + 36) = a9;
  *(_DWORD *)(a4 + 52) = a13;
  *(_DWORD *)a4 = &off_100A203C;
  *(_DWORD *)(a4 + 44) = a11;
  *(_DWORD *)(a4 + 48) = a12;
  return a4;
}
// 100A203C: using guessed type unsigned __int32 (__thiscall *off_100A203C)(AssetFile *__hidden this);

//----- (100152C0) --------------------------------------------------------
void *__thiscall sub_100152C0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_100152F0((int)this);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (100152F0) --------------------------------------------------------
void __stdcall sub_100152F0(int a1)
{
  void (__cdecl *v1)(_DWORD, _DWORD); // eax@1
  void *v2; // eax@3

  *(_DWORD *)a1 = &off_100A203C;
  v1 = *(void (__cdecl **)(_DWORD, _DWORD))(a1 + 52);
  if ( v1 )
    v1(*(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 28));
  v2 = *(void **)(a1 + 12);
  *(_DWORD *)a1 = &off_100A200C;
  if ( v2 && v2 != *(void **)(a1 + 8) )
    operator delete[](v2);
  if ( *(_DWORD *)(a1 + 8) )
    operator delete[](*(void **)(a1 + 8));
  *(_DWORD *)a1 = &off_100A1FAC;
}
// 10099190: using guessed type void __cdecl operator delete[](void *);
// 100A1FAC: using guessed type void *off_100A1FAC;
// 100A200C: using guessed type int (*off_100A200C)();
// 100A203C: using guessed type unsigned __int32 (__thiscall *off_100A203C)(AssetFile *__hidden this);

//----- (10015390) --------------------------------------------------------
__int64 __thiscall sub_10015390(int this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, _DWORD, _DWORD, char *, int), int a4)
{
  int v4; // ebx@1
  size_t v5; // esi@1
  size_t v6; // eax@4
  int v7; // ecx@4
  __int64 v8; // rax@10
  unsigned __int64 v9; // rdi@10
  __int64 v10; // rax@10
  __int64 v12; // [sp+10h] [bp-428h]@4
  char *v13; // [sp+18h] [bp-420h]@2
  signed int v14; // [sp+1Ch] [bp-41Ch]@1
  __int64 v15; // [sp+20h] [bp-418h]@1
  char v16; // [sp+30h] [bp-408h]@3

  v4 = this;
  v5 = *(_DWORD *)(this + 48);
  v15 = *(_QWORD *)(this + 40);
  v14 = v5;
  if ( !v5 || (v13 = (char *)malloc(v5)) == 0 )
  {
    v14 = 1024;
    v5 = 1024;
    v13 = &v16;
  }
  v6 = *(_DWORD *)(v4 + 32);
  v7 = *(_DWORD *)(v4 + 36);
  v12 = *(_QWORD *)(v4 + 32);
  if ( *(_QWORD *)(v4 + 32) )
  {
    while ( 1 )
    {
      if ( v7 || v6 > v5 )
        v6 = v5;
      LODWORD(v8) = (*(int (__cdecl **)(_DWORD, _DWORD, size_t, _DWORD, char *, _DWORD))(v4 + 24))(
                      v15,
                      HIDWORD(v15),
                      v6,
                      0,
                      v13,
                      *(_DWORD *)(v4 + 28));
      v9 = __PAIR__(v8, HIDWORD(v8));
      v15 += v8;
      LODWORD(v10) = a3(a2, HIDWORD(a2), v8, HIDWORD(v8), v13, a4);
      a2 += v10;
      v12 -= __PAIR__(v9, HIDWORD(v9));
      if ( !v9 || !v12 )
        break;
      v5 = v14;
      v7 = HIDWORD(v12);
      v6 = v12;
    }
  }
  if ( v13 != &v16 )
    free(v13);
  return a2;
}

//----- (100154C0) --------------------------------------------------------
int __thiscall sub_100154C0(void *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4)
{
  void *v4; // ebx@1
  __int64 v5; // rax@1
  __int64 v6; // kr18_8@1
  __int64 v7; // rax@1
  __int64 v8; // kr20_8@1
  __int64 v9; // rax@1
  __int64 v10; // kr28_8@1
  __int64 v11; // rax@1
  __int64 v12; // kr30_8@1
  __int64 v13; // rax@1
  __int64 v14; // kr38_8@1
  __int64 v15; // rax@1
  __int64 v16; // kr40_8@1
  __int64 v17; // rax@1
  __int64 v18; // kr48_8@1
  __int64 v19; // rax@1
  char v21; // [sp+12h] [bp-Eh]@1
  bool v22; // [sp+13h] [bp-Dh]@1
  int v23; // [sp+14h] [bp-Ch]@1
  int v24; // [sp+18h] [bp-8h]@1
  int v25; // [sp+1Ch] [bp-4h]@1

  v4 = this;
  v25 = 2;
  LODWORD(v5) = a3(a2, HIDWORD(a2), 2, 0, &v25, a4);
  v6 = v5 + a2;
  v21 = 0;
  LODWORD(v7) = a3(v6, HIDWORD(v6), 1, 0, (int *)&v21, a4);
  v8 = v7 + v6;
  v23 = (unsigned __int16)strlen(*((const char **)v4 + 2));
  LODWORD(v9) = a3(v8, HIDWORD(v8), 2, 0, &v23, a4);
  v10 = v9 + v8;
  LODWORD(v11) = a3(v10, HIDWORD(v10), (unsigned __int16)v23, 0, *((int **)v4 + 2), a4);
  v12 = v11 + v10;
  v24 = (unsigned __int16)strlen(*((const char **)v4 + 3));
  LODWORD(v13) = a3(v12, HIDWORD(v12), 2, 0, &v24, a4);
  v14 = v13 + v12;
  LODWORD(v15) = a3(v14, HIDWORD(v14), (unsigned __int16)v24, 0, *((int **)v4 + 3), a4);
  v16 = v15 + v14;
  v22 = *((_BYTE *)v4 + 16) != 0;
  LODWORD(v17) = a3(v16, HIDWORD(v16), 1, 0, (int *)&v22, a4);
  v18 = v17 + v16;
  LODWORD(v19) = a3(v18, HIDWORD(v18), 8, 0, (int *)v4 + 8, a4);
  return (*(int (__thiscall **)(void *, _DWORD, _DWORD, int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int))(*(_DWORD *)v4 + 32))(
           v4,
           v19 + v18,
           (unsigned __int64)(v19 + v18) >> 32,
           a3,
           a4);
}

//----- (10015600) --------------------------------------------------------
void *__thiscall sub_10015600(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_10015630((int)this);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10015630) --------------------------------------------------------
void __stdcall sub_10015630(int a1)
{
  void (__cdecl *v1)(_DWORD); // eax@2
  void *v2; // eax@4

  *(_DWORD *)a1 = &off_100A206C;
  if ( *(_DWORD *)(a1 + 24) )
  {
    v1 = *(void (__cdecl **)(_DWORD))(a1 + 32);
    if ( v1 )
    {
      v1(*(_DWORD *)(a1 + 24));
      *(_DWORD *)(a1 + 24) = 0;
      *(_DWORD *)(a1 + 32) = 0;
      *(_DWORD *)(a1 + 28) = 0;
    }
  }
  v2 = *(void **)(a1 + 12);
  *(_DWORD *)a1 = &off_100A200C;
  if ( v2 && v2 != *(void **)(a1 + 8) )
    operator delete[](v2);
  if ( *(_DWORD *)(a1 + 8) )
    operator delete[](*(void **)(a1 + 8));
  *(_DWORD *)a1 = &off_100A1FAC;
}
// 10099190: using guessed type void __cdecl operator delete[](void *);
// 100A1FAC: using guessed type void *off_100A1FAC;
// 100A200C: using guessed type int (*off_100A200C)();
// 100A206C: using guessed type unsigned __int32 (__thiscall *off_100A206C)(AssetFile *__hidden this);

//----- (100156D0) --------------------------------------------------------
__int64 __thiscall sub_100156D0(int this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, int), int a4)
{
  __int64 v4; // rax@1

  LODWORD(v4) = a3(a2, HIDWORD(a2), *(_DWORD *)(this + 28), 0, *(_DWORD *)(this + 24), a4);
  return a2 + v4;
}

//----- (10015700) --------------------------------------------------------
int __thiscall sub_10015700(void *this, __int64 a2, int (__cdecl *a3)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int a4)
{
  void *v4; // ebx@1
  __int64 v5; // rax@1
  __int64 v6; // kr18_8@1
  __int64 v7; // rax@1
  __int64 v8; // kr20_8@1
  __int64 v9; // rax@1
  __int64 v10; // kr28_8@1
  __int64 v11; // rax@1
  __int64 v12; // kr30_8@1
  __int64 v13; // rax@1
  __int64 v14; // kr38_8@1
  __int64 v15; // rax@1
  __int64 v16; // kr40_8@1
  __int64 v17; // rax@1
  __int64 v18; // kr48_8@1
  __int64 v19; // rax@1
  char v21; // [sp+12h] [bp-16h]@1
  bool v22; // [sp+13h] [bp-15h]@1
  int v23; // [sp+14h] [bp-14h]@1
  int v24; // [sp+18h] [bp-10h]@1
  int v25; // [sp+1Ch] [bp-Ch]@1
  int v26; // [sp+20h] [bp-8h]@1
  int v27; // [sp+24h] [bp-4h]@1

  v4 = this;
  v25 = 3;
  LODWORD(v5) = a3(a2, HIDWORD(a2), 2, 0, &v25, a4);
  v6 = v5 + a2;
  v21 = 0;
  LODWORD(v7) = a3(v6, HIDWORD(v6), 1, 0, (int *)&v21, a4);
  v8 = v7 + v6;
  v23 = (unsigned __int16)strlen(*((const char **)v4 + 2));
  LODWORD(v9) = a3(v8, HIDWORD(v8), 2, 0, &v23, a4);
  v10 = v9 + v8;
  LODWORD(v11) = a3(v10, HIDWORD(v10), (unsigned __int16)v23, 0, *((int **)v4 + 2), a4);
  v12 = v11 + v10;
  v24 = (unsigned __int16)strlen(*((const char **)v4 + 3));
  LODWORD(v13) = a3(v12, HIDWORD(v12), 2, 0, &v24, a4);
  v14 = v13 + v12;
  LODWORD(v15) = a3(v14, HIDWORD(v14), (unsigned __int16)v24, 0, *((int **)v4 + 3), a4);
  v16 = v15 + v14;
  v22 = *((_BYTE *)v4 + 16) != 0;
  LODWORD(v17) = a3(v16, HIDWORD(v16), 1, 0, (int *)&v22, a4);
  v18 = v17 + v16;
  v26 = *((_DWORD *)v4 + 7);
  v27 = 0;
  LODWORD(v19) = a3(v18, HIDWORD(v18), 8, 0, &v26, a4);
  return (*(int (__thiscall **)(void *, _DWORD, _DWORD, int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, int), int))(*(_DWORD *)v4 + 32))(
           v4,
           v19 + v18,
           (unsigned __int64)(v19 + v18) >> 32,
           a3,
           a4);
}

//----- (10015850) --------------------------------------------------------
void *__thiscall sub_10015850(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_10015880((int)this);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10015880) --------------------------------------------------------
void __stdcall sub_10015880(int a1)
{
  int v1; // eax@4
  void *v2; // eax@6
  void *v3; // edi@8
  void *v4; // eax@11

  *(_DWORD *)a1 = &off_100A209C;
  if ( *(_BYTE *)(a1 + 44) && *(_DWORD *)(a1 + 28) )
    operator delete[](*(void **)(a1 + 28));
  v1 = *(_DWORD *)(a1 + 24);
  if ( v1 && *(_BYTE *)(a1 + 45) )
  {
    v2 = *(void **)(v1 + 100);
    if ( v2 )
      free(v2);
    v3 = *(void **)(a1 + 24);
    if ( v3 )
    {
      AssetsFile::~AssetsFile(*(AssetsFile **)(a1 + 24));
      operator delete(v3);
    }
    *(_DWORD *)(a1 + 24) = 0;
    *(_BYTE *)(a1 + 45) = 0;
  }
  v4 = *(void **)(a1 + 12);
  *(_DWORD *)a1 = &off_100A200C;
  if ( v4 && v4 != *(void **)(a1 + 8) )
    operator delete[](v4);
  if ( *(_DWORD *)(a1 + 8) )
    operator delete[](*(void **)(a1 + 8));
  *(_DWORD *)a1 = &off_100A1FAC;
}
// 10099190: using guessed type void __cdecl operator delete[](void *);
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100A1FAC: using guessed type void *off_100A1FAC;
// 100A200C: using guessed type int (*off_100A200C)();
// 100A209C: using guessed type unsigned __int32 (__thiscall *off_100A209C)(AssetFile *__hidden this);

//----- (10015960) --------------------------------------------------------
signed __int64 __thiscall sub_10015960(int this)
{
  int v1; // ecx@1
  int v3; // eax@3
  const char *v4; // ecx@4
  const char *v5; // ebx@4
  void *v6; // ecx@8
  int v7; // edi@9
  int v8; // esi@9
  unsigned int v9; // ebx@9
  int v10; // edx@10
  unsigned int v11; // edx@14
  unsigned int v12; // eax@18
  signed int v13; // eax@20
  bool v14; // zf@23
  char v15; // [sp+17h] [bp-45h]@9
  int v16; // [sp+18h] [bp-44h]@1
  int v17; // [sp+1Ch] [bp-40h]@4
  void *v18; // [sp+1Ch] [bp-40h]@8
  int v19; // [sp+20h] [bp-3Ch]@1
  int v20; // [sp+20h] [bp-3Ch]@8
  signed __int64 v21; // [sp+24h] [bp-38h]@3
  int v22; // [sp+2Ch] [bp-30h]@9
  int v23; // [sp+30h] [bp-2Ch]@9
  char v24; // [sp+38h] [bp-24h]@7
  void *v25; // [sp+44h] [bp-18h]@8
  int v26; // [sp+48h] [bp-14h]@7
  int v27; // [sp+58h] [bp-4h]@7

  v16 = this;
  v1 = *(_DWORD *)(this + 24);
  v19 = v1;
  if ( !v1 )
    return 0i64;
  v3 = *(_DWORD *)(v1 + 80);
  v21 = 25i64;
  if ( v3 )
  {
    v4 = *(const char **)(v1 + 84);
    v5 = v4 + 276;
    v17 = v3;
    do
    {
      v21 += strlen(v5) + 1 + (unsigned __int64)(strlen(v4) + 1) + 20;
      v4 += 536;
      v5 += 536;
      --v17;
    }
    while ( v17 );
    v1 = v19;
  }
  AssetsFileTable::AssetsFileTable((int)&v24, v1, 0);
  v27 = 0;
  if ( !v26 )
    goto LABEL_28;
  v6 = v25;
  v18 = v25;
  v20 = v26;
  do
  {
    v7 = *((_DWORD *)v6 + 3);
    v22 = *(_DWORD *)v6;
    v8 = *(_DWORD *)(v16 + 36);
    v9 = 0;
    v23 = *((_DWORD *)v6 + 1);
    v15 = 0;
    if ( !v8 )
    {
LABEL_18:
      v12 = *(_DWORD *)(*(_DWORD *)(v16 + 24) + 8);
      if ( v12 < 0x11 )
      {
        if ( v12 >= 0x10 )
        {
          v13 = 23;
LABEL_25:
          v21 += __PAIR__((__PAIR__(v9, 3) + (unsigned int)v7) >> 32, (v7 + 3) & 0xFFFFFFFC) + ((v13 + 3) & 0xFFFFFFFC);
          goto LABEL_27;
        }
        if ( v12 >= 0xF )
        {
          v13 = 25;
          goto LABEL_25;
        }
        v14 = v12 == 14;
        v13 = 24;
        if ( v14 )
          goto LABEL_25;
      }
      v13 = 20;
      goto LABEL_25;
    }
    while ( 1 )
    {
      if ( v22 != (*(int (**)(void))(**(_DWORD **)(*(_DWORD *)(v16 + 28) + 4 * v8 - 4) + 12))() || v23 != v10 )
        goto LABEL_16;
      if ( v15 || (***(int (****)(void))(*(_DWORD *)(v16 + 28) + 4 * v8 - 4))() )
        break;
      v7 = (*(int (**)(void))(**(_DWORD **)(*(_DWORD *)(v16 + 28) + 4 * v8 - 4) + 24))();
      v9 = v11;
      v15 = 1;
LABEL_16:
      if ( !--v8 )
      {
        v6 = v18;
        goto LABEL_18;
      }
    }
    if ( (***(int (****)(void))(*(_DWORD *)(v16 + 28) + 4 * v8 - 4))() != 1 )
      goto LABEL_16;
    v6 = v18;
LABEL_27:
    v6 = (char *)v6 + 152;
    v14 = v20-- == 1;
    v18 = v6;
  }
  while ( !v14 );
LABEL_28:
  if ( v25 )
    operator delete[](v25);
  return v21;
}
// 10099190: using guessed type void __cdecl operator delete[](void *);

//----- (10015B80) --------------------------------------------------------
char __thiscall sub_10015B80(void *this, int a2, int a3, void *a4, int a5, int a6, int a7, int a8, int a9)
{
  void *v9; // edi@1
  char result; // al@2
  _DWORD *v11; // eax@3
  void *v12; // ebx@4
  unsigned __int64 (__cdecl *v13)(unsigned __int64, unsigned __int64, void *, __int32); // esi@4
  AssetsFileHeader *v14; // eax@6
  AssetsFileHeader *v15; // eax@7
  void *v16; // esi@12

  v9 = this;
  (*(void (**)(void))(*(_DWORD *)this + 28))();
  if ( *((_DWORD *)v9 + 6) )
  {
    result = 1;
  }
  else
  {
    v11 = malloc(0x20u);
    if ( v11 )
    {
      v11[6] = a3;
      v11[7] = a4;
      v11[4] = a5;
      v11[5] = a6;
      *v11 = a5;
      v11[1] = a6;
      v11[2] = a7;
      v11[3] = a8;
      v12 = v11;
      v13 = (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32))PartialAssetsFileReader;
    }
    else
    {
      v12 = a4;
      v13 = 0;
    }
    v14 = (AssetsFileHeader *)operator new(0x68u);
    if ( v14 )
      v15 = AssetsFile::AssetsFile(v14, v13, (__int32)v12);
    else
      v15 = 0;
    *((_DWORD *)v9 + 6) = v15;
    if ( AssetsFile::VerifyAssetsFile(v15, 0) )
    {
      result = 1;
      *((_BYTE *)v9 + 45) = 1;
      *((_DWORD *)v9 + 8) = a9;
    }
    else
    {
      if ( v12 )
        free(v12);
      v16 = (void *)*((_DWORD *)v9 + 6);
      if ( v16 )
      {
        AssetsFile::~AssetsFile(*((AssetsFile **)v9 + 6));
        operator delete(v16);
      }
      *((_DWORD *)v9 + 6) = 0;
      result = 0;
    }
  }
  return result;
}
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10015CC0) --------------------------------------------------------
void __thiscall sub_10015CC0(int this)
{
  int v1; // esi@1
  int v2; // eax@1
  void *v3; // eax@3
  void *v4; // edi@5

  v1 = this;
  v2 = *(_DWORD *)(this + 24);
  if ( v2 && *(_BYTE *)(this + 45) )
  {
    v3 = *(void **)(v2 + 100);
    if ( v3 )
      free(v3);
    v4 = *(void **)(v1 + 24);
    if ( v4 )
    {
      AssetsFile::~AssetsFile(*(AssetsFile **)(v1 + 24));
      operator delete(v4);
    }
    *(_DWORD *)(v1 + 24) = 0;
    *(_BYTE *)(v1 + 45) = 0;
  }
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10015D10) --------------------------------------------------------
int __thiscall sub_10015D10(int this, unsigned __int64 a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, const void *, __int32), void *a4)
{
  return AssetsFile::Write(
           *(AssetsFile **)(this + 24),
           a3,
           a4,
           a2,
           *(struct AssetsReplacer ***)(this + 28),
           *(_DWORD *)(this + 36),
           *(_DWORD *)(this + 40),
           *(struct ClassDatabaseFile **)(this + 32));
}

//----- (10015D50) --------------------------------------------------------
int __thiscall sub_10015D50(void *this, __int64 a2, int (__cdecl *a3)(_DWORD, unsigned int, signed int, _DWORD, int *, int), int a4)
{
  void *v4; // ebx@1
  __int64 v5; // rax@1
  unsigned int v6; // edi@1
  unsigned int v7; // esi@1
  __int64 v8; // rax@1
  unsigned int v9; // edi@1
  unsigned __int64 v10; // kr18_8@1
  __int64 v11; // rax@1
  unsigned int v12; // edi@1
  unsigned __int64 v13; // kr20_8@1
  __int64 v14; // rax@1
  unsigned int v15; // edi@1
  unsigned __int64 v16; // kr28_8@1
  __int64 v17; // rax@1
  unsigned int v18; // edi@1
  unsigned __int64 v19; // kr30_8@1
  __int64 v20; // rax@1
  unsigned int v21; // edi@1
  unsigned __int64 v22; // kr38_8@1
  __int64 v23; // rax@1
  unsigned int v24; // edi@1
  unsigned __int64 v25; // kr40_8@1
  __int64 v26; // rax@1
  int v27; // edi@1
  int v28; // esi@1
  unsigned __int64 v29; // kr48_8@1
  bool v30; // zf@1
  int v31; // edx@2
  char v33; // [sp+Eh] [bp-1Ah]@1
  char v34; // [sp+Fh] [bp-19h]@1
  unsigned int v35; // [sp+10h] [bp-18h]@1
  int v36; // [sp+14h] [bp-14h]@1
  int v37; // [sp+18h] [bp-10h]@1
  int v38; // [sp+1Ch] [bp-Ch]@1
  int v39; // [sp+20h] [bp-8h]@1
  int v40; // [sp+24h] [bp-4h]@1

  v4 = this;
  v38 = 4;
  LODWORD(v5) = a3(a2, HIDWORD(a2), 2, 0, &v38, a4);
  v6 = (unsigned __int64)(v5 + a2) >> 32;
  v7 = v5 + a2;
  v33 = 0;
  LODWORD(v8) = a3(v5 + a2, v6, 1, 0, (int *)&v33, a4);
  v10 = v8 + __PAIR__(v6, v7);
  v9 = (v8 + __PAIR__(v6, v7)) >> 32;
  v36 = (unsigned __int16)strlen(*((const char **)v4 + 2));
  LODWORD(v11) = a3(v10, v9, 2, 0, &v36, a4);
  v13 = v11 + __PAIR__(v9, (unsigned int)v10);
  v12 = (v11 + __PAIR__(v9, (unsigned int)v10)) >> 32;
  LODWORD(v14) = a3(v13, v12, (unsigned __int16)v36, 0, *((int **)v4 + 2), a4);
  v16 = v14 + __PAIR__(v12, (unsigned int)v13);
  v15 = (v14 + __PAIR__(v12, (unsigned int)v13)) >> 32;
  v37 = (unsigned __int16)strlen(*((const char **)v4 + 3));
  LODWORD(v17) = a3(v16, v15, 2, 0, &v37, a4);
  v19 = v17 + __PAIR__(v15, (unsigned int)v16);
  v18 = (v17 + __PAIR__(v15, (unsigned int)v16)) >> 32;
  LODWORD(v20) = a3(v19, v18, (unsigned __int16)v37, 0, *((int **)v4 + 3), a4);
  v22 = v20 + __PAIR__(v18, (unsigned int)v19);
  v21 = (v20 + __PAIR__(v18, (unsigned int)v19)) >> 32;
  v34 = 1;
  LODWORD(v23) = a3(v22, v21, 1, 0, (int *)&v34, a4);
  v25 = v23 + __PAIR__(v21, (unsigned int)v22);
  v24 = (v23 + __PAIR__(v21, (unsigned int)v22)) >> 32;
  v39 = *((_DWORD *)v4 + 9);
  v40 = 0;
  LODWORD(v26) = a3(v25, v24, 8, 0, &v39, a4);
  v29 = v26 + __PAIR__(v24, (unsigned int)v25);
  v27 = (v26 + __PAIR__(v24, (unsigned int)v25)) >> 32;
  v28 = v29;
  v30 = *((_DWORD *)v4 + 9) == 0;
  v35 = 0;
  if ( !v30 )
  {
    do
    {
      v28 = (*(int (__stdcall **)(int, int, int (__cdecl *)(_DWORD, unsigned int, signed int, _DWORD, int *, int), int))(**(_DWORD **)(*((_DWORD *)v4 + 7) + 4 * v35) + 32))(
              v28,
              v27,
              a3,
              a4);
      v27 = v31;
      ++v35;
    }
    while ( v35 < *((_DWORD *)v4 + 9) );
  }
  return v28;
}

//----- (10015EC0) --------------------------------------------------------
struct AssetsReplacer **__thiscall BundleEntryModifierFromAssets::GetReplacers(BundleEntryModifierFromAssets *this, unsigned int *a2)
{
  *a2 = *((_DWORD *)this + 9);
  return (struct AssetsReplacer **)*((_DWORD *)this + 7);
}

//----- (10015EE0) --------------------------------------------------------
struct AssetsFile *__thiscall BundleEntryModifierFromAssets::GetAssignedAssetsFile(BundleEntryModifierFromAssets *this)
{
  return (struct AssetsFile *)*((_DWORD *)this + 6);
}

//----- (10015EF0) --------------------------------------------------------
struct BundleReplacer *__cdecl ReadBundleReplacer(unsigned __int64 *a1, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, bool a4)
{
  unsigned __int64 v4; // ST1C_8@1
  __int64 v5; // rax@1
  unsigned __int64 v6; // ST1C_8@2
  int v7; // eax@2
  unsigned __int8 v8; // cf@2
  int v9; // edx@2
  unsigned __int64 v10; // ST04_8@2
  int v11; // eax@2
  int v12; // eax@2
  int v13; // edx@2
  void *v14; // eax@2
  int v15; // eax@3
  _BYTE *v16; // eax@3
  int v17; // edx@3
  int v18; // eax@5
  int v19; // eax@5
  int v20; // edx@5
  void *v21; // eax@5
  int v22; // eax@7
  _BYTE *v23; // eax@7
  int v24; // edx@7
  __int64 v25; // rax@8
  struct BundleReplacer *v26; // eax@11
  void *v27; // ebx@11
  struct BundleReplacer *v28; // esi@11
  struct BundleReplacer *result; // eax@15
  struct BundleReplacer *v30; // eax@17
  void *v31; // edi@17
  void *v32; // esi@17
  struct BundleReplacer *v33; // ebx@18
  int v34; // eax@25
  __int64 v35; // rax@25
  struct BundleReplacer *v36; // eax@26
  int v37; // eax@27
  int v38; // edx@27
  struct BundleReplacer *v39; // eax@27
  struct BundleReplacer *v40; // eax@28
  struct BundleReplacer *v41; // edx@28
  size_t v42; // ecx@28
  struct BundleReplacer *v43; // eax@32
  void *v44; // eax@35
  int v45; // eax@40
  int v46; // eax@40
  struct BundleReplacer *v47; // eax@40
  int v48; // edx@40
  struct AssetsReplacer *v49; // eax@41
  int v50; // ecx@41
  _DWORD *v51; // eax@42
  _DWORD *v52; // edi@42
  void *v53; // ebx@42
  void *v54; // esi@42
  struct BundleReplacer *v55; // ecx@43
  struct BundleReplacer *v56; // edx@43
  char v57; // [sp+13h] [bp-49h]@2
  void *v58; // [sp+14h] [bp-48h]@2
  void *v59; // [sp+18h] [bp-44h]@4
  int v60; // [sp+1Ch] [bp-40h]@2
  int v61; // [sp+20h] [bp-3Ch]@4
  int v62; // [sp+24h] [bp-38h]@1
  int v63; // [sp+28h] [bp-34h]@4
  struct BundleReplacer *v64; // [sp+2Ch] [bp-30h]@26
  size_t v65; // [sp+30h] [bp-2Ch]@28
  struct BundleReplacer *v66; // [sp+34h] [bp-28h]@11
  int v67; // [sp+38h] [bp-24h]@27
  size_t v68; // [sp+3Ch] [bp-20h]@25
  int v69; // [sp+40h] [bp-1Ch]@25
  struct BundleReplacer *v70; // [sp+44h] [bp-18h]@40
  int v71; // [sp+48h] [bp-14h]@40
  int v72; // [sp+58h] [bp-4h]@11

  v4 = *a1;
  v62 = 0xFFFF;
  LODWORD(v5) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, __int32))a2)(
                  v4,
                  HIDWORD(v4),
                  2,
                  0,
                  &v62,
                  a3);
  *a1 += v5;
  if ( (unsigned __int16)v62 >= 5u )
  {
LABEL_50:
    result = 0;
  }
  else
  {
    v6 = *a1;
    v57 = 0;
    v7 = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a2)(v6, HIDWORD(v6), 1, 0, &v57, a3);
    v8 = __CFADD__(v7, *(_DWORD *)a1);
    *(_DWORD *)a1 += v7;
    *((_DWORD *)a1 + 1) += v9 + v8;
    v10 = *a1;
    v60 = 0;
    v11 = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, __int32))a2)(v10, HIDWORD(v10), 2, 0, &v60, a3);
    v8 = __CFADD__(v11, *(_DWORD *)a1);
    *(_DWORD *)a1 += v11;
    v12 = (unsigned __int16)v60;
    *((_DWORD *)a1 + 1) += v13 + v8;
    v14 = malloc(v12 + 1);
    v58 = v14;
    if ( v14 )
    {
      v15 = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, void *, __int32))a2)(
              *(_DWORD *)a1,
              *((_DWORD *)a1 + 1),
              (unsigned __int16)v60,
              0,
              v14,
              a3);
      v8 = __CFADD__(v15, *(_DWORD *)a1);
      *(_DWORD *)a1 += v15;
      v16 = v58;
      *((_DWORD *)a1 + 1) += v17 + v8;
      v16[(unsigned __int16)v60] = 0;
    }
    v59 = 0;
    v61 = 0;
    LOBYTE(v63) = 0;
    if ( (_WORD)v62 )
    {
      v18 = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, int *, _DWORD))a2)(
              *(_DWORD *)a1,
              *((_DWORD *)a1 + 1),
              2,
              0,
              &v61,
              a3);
      v8 = __CFADD__(v18, *(_DWORD *)a1);
      *(_DWORD *)a1 += v18;
      v19 = (unsigned __int16)v61;
      *((_DWORD *)a1 + 1) += v20 + v8;
      v21 = malloc(v19 + 1);
      v59 = v21;
      if ( v21 )
      {
        v22 = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, void *, _DWORD))a2)(
                *(_DWORD *)a1,
                *((_DWORD *)a1 + 1),
                (unsigned __int16)v61,
                0,
                v21,
                a3);
        v8 = __CFADD__(v22, *(_DWORD *)a1);
        *(_DWORD *)a1 += v22;
        v23 = v59;
        *((_DWORD *)a1 + 1) += v24 + v8;
        v23[(unsigned __int16)v61] = 0;
      }
      else
      {
        free(v58);
      }
      LODWORD(v25) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, int *, _DWORD))a2)(
                       *(_DWORD *)a1,
                       *((_DWORD *)a1 + 1),
                       1,
                       0,
                       &v63,
                       a3);
      *a1 += v25;
    }
    switch ( (unsigned __int16)v62 )
    {
      case 0u:
        if ( v57 )
          goto LABEL_50;
        v26 = (struct BundleReplacer *)operator new(0x10u);
        v66 = v26;
        v27 = v58;
        v28 = 0;
        v72 = 0;
        if ( v26 )
          v28 = (struct BundleReplacer *)sub_10014E20((const char *)v58, (int)v26, -1);
        if ( v27 )
          free(v27);
        result = v28;
        break;
      case 1u:
        if ( v57 )
          goto LABEL_50;
        v30 = (struct BundleReplacer *)operator new(0x18u);
        v66 = v30;
        v31 = v59;
        v32 = v58;
        v72 = 1;
        if ( v30 )
          v33 = (struct BundleReplacer *)sub_10014FB0(-1, (const char *)v58, (int)v30, (const char *)v59, v63);
        else
          v33 = 0;
        if ( v32 )
          free(v32);
        if ( v31 )
          free(v31);
        result = v33;
        break;
      case 2u:
      case 3u:
        v34 = *((_DWORD *)a1 + 1);
        v68 = 0;
        v69 = 0;
        LODWORD(v35) = ((int (__cdecl *)(_DWORD, int, signed int, _DWORD, size_t *, __int32))a2)(
                         *(_DWORD *)a1,
                         v34,
                         8,
                         0,
                         &v68,
                         a3);
        *a1 += v35;
        if ( !a4
          || (v36 = (struct BundleReplacer *)malloc(v68), (v64 = v36) == 0)
          || ((v37 = ((int (__cdecl *)(_DWORD, _DWORD, size_t, int, struct BundleReplacer *, __int32))a2)(
                       *(_DWORD *)a1,
                       *((_DWORD *)a1 + 1),
                       v68,
                       v69,
                       v36,
                       a3),
               v67 = v38,
               memset((char *)v64 + v37, 0, v68 - v37),
               v39 = (struct BundleReplacer *)operator new(0x24u),
               v66 = v39,
               v72 = 2,
               !v39) ? (v40 = 0) : (v65 = v68,
                                    sub_10014FB0(-1, (const char *)v58, (int)v39, (const char *)v59, v63),
                                    v40 = v66,
                                    v41 = v64,
                                    v42 = v65,
                                    *(_DWORD *)v66 = &off_100A206C,
                                    *((_DWORD *)v40 + 6) = v41,
                                    *((_DWORD *)v40 + 7) = v42,
                                    *((_DWORD *)v40 + 8) = Free_PartialAssetsFileReader),
              v72 = -1,
              (v64 = v40) == 0) )
        {
          v66 = (struct BundleReplacer *)operator new(0x38u);
          v72 = 3;
          if ( v66 )
            v43 = (struct BundleReplacer *)sub_10015270(
                                             v63,
                                             (const char *)v58,
                                             (const char *)v59,
                                             (int)v66,
                                             -1,
                                             (int)a2,
                                             a3,
                                             v68,
                                             v69,
                                             *(_DWORD *)a1,
                                             *((_DWORD *)a1 + 1),
                                             0,
                                             0);
          else
            v43 = 0;
          v64 = v43;
        }
        v8 = __CFADD__(v68, *(_DWORD *)a1);
        *(_DWORD *)a1 += v68;
        v44 = v58;
        *((_DWORD *)a1 + 1) += v69 + v8;
        if ( v44 )
          free(v44);
        if ( v59 )
          free(v59);
        result = v64;
        break;
      case 4u:
        v45 = *((_DWORD *)a1 + 1);
        v70 = 0;
        v71 = 0;
        v46 = ((int (__cdecl *)(_DWORD, int, signed int, _DWORD, struct BundleReplacer **, __int32))a2)(
                *(_DWORD *)a1,
                v45,
                8,
                0,
                &v70,
                a3);
        v8 = __CFADD__(v46, *(_DWORD *)a1);
        *(_DWORD *)a1 += v46;
        v47 = v70;
        v64 = v70;
        *((_DWORD *)a1 + 1) += v48 + v8;
        v66 = (struct BundleReplacer *)unknown_libname_4(4 * (_DWORD)v47 | -((unsigned __int64)(unsigned int)v47 >> 30 != 0));
        v65 = 0;
        if ( v64 )
        {
          do
          {
            v49 = ReadAssetsReplacer(a1, a2, a3, 0);
            v50 = v65;
            *((_DWORD *)v66 + v65) = v49;
            v65 = v50 + 1;
          }
          while ( v50 + 1 < (unsigned int)v64 );
        }
        v51 = operator new(0x30u);
        v52 = v51;
        v65 = (size_t)v51;
        v53 = v59;
        v54 = v58;
        v72 = 4;
        if ( v51 )
        {
          sub_10014FB0(-1, (const char *)v58, (int)v51, (const char *)v59, 1);
          v55 = v66;
          v56 = v64;
          *v52 = &off_100A209C;
          v52[6] = 0;
          v52[7] = v55;
          v52[9] = v56;
          v52[10] = 0;
          *((_WORD *)v52 + 22) = 1;
          v52[8] = 0;
        }
        else
        {
          v52 = 0;
        }
        if ( v54 )
          free(v54);
        if ( v53 )
          free(v53);
        result = (struct BundleReplacer *)v52;
        break;
      default:
        goto LABEL_50;
    }
  }
  return result;
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 100A206C: using guessed type unsigned __int32 (__thiscall *off_100A206C)(AssetFile *__hidden this);
// 100A209C: using guessed type unsigned __int32 (__thiscall *off_100A209C)(AssetFile *__hidden this);

//----- (10016400) --------------------------------------------------------
struct BundleReplacer *__cdecl MakeBundleEntryRemover(const char *a1, unsigned int a2)
{
  struct BundleReplacer *v2; // edi@1
  unsigned int v3; // kr00_4@3
  void *v4; // eax@3
  struct BundleReplacer *result; // eax@3

  v2 = (struct BundleReplacer *)operator new(0x10u);
  if ( v2 )
  {
    *(_DWORD *)v2 = &off_100A1FDC;
    *((_DWORD *)v2 + 1) = a2;
    if ( a1 )
    {
      v3 = strlen(a1);
      v4 = (void *)unknown_libname_4(v3 + 1);
      *((_DWORD *)v2 + 2) = v4;
      memcpy(v4, a1, v3 + 1);
      result = v2;
    }
    else
    {
      *((_DWORD *)v2 + 2) = 0;
      result = v2;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 100A1FDC: using guessed type int (*off_100A1FDC)();

//----- (100164C0) --------------------------------------------------------
struct BundleReplacer *__cdecl MakeBundleEntryRenamer(const char *a1, const char *a2, bool a3, unsigned int a4)
{
  void *v4; // eax@1
  struct BundleReplacer *result; // eax@2

  v4 = operator new(0x18u);
  if ( v4 )
    result = (struct BundleReplacer *)sub_10014FB0(a4, a1, (int)v4, a2, a3);
  else
    result = 0;
  return result;
}
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);

//----- (10016530) --------------------------------------------------------
struct BundleReplacer *__cdecl MakeBundleEntryModifier(const char *a1, const char *a2, bool a3, unsigned __int64 (__cdecl *a4)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a5, void (__cdecl *a6)(unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32), unsigned __int64 a7, unsigned __int64 a8, unsigned int a9, unsigned int a10)
{
  void *v10; // eax@1
  int v11; // esi@1
  void *v12; // ST14_4@1
  struct BundleReplacer *result; // eax@1

  v10 = operator new(0x38u);
  v11 = (int)v10;
  v12 = v10;
  result = 0;
  if ( v12 )
  {
    sub_10014FB0(a10, a1, v11, a2, a3);
    *(_DWORD *)(v11 + 28) = a5;
    *(_DWORD *)(v11 + 24) = a4;
    *(_DWORD *)(v11 + 40) = a8;
    *(_QWORD *)(v11 + 32) = a7;
    *(_DWORD *)(v11 + 52) = a6;
    *(_DWORD *)v11 = &off_100A203C;
    *(_DWORD *)(v11 + 44) = HIDWORD(a8);
    *(_DWORD *)(v11 + 48) = a9;
    result = (struct BundleReplacer *)v11;
  }
  return result;
}
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 100A203C: using guessed type unsigned __int32 (__thiscall *off_100A203C)(AssetFile *__hidden this);

//----- (100165E0) --------------------------------------------------------
struct BundleReplacer *__cdecl MakeBundleEntryModifierFromMem(const char *a1, const char *a2, bool a3, void *a4, unsigned int a5, unsigned int a6, void (__cdecl *a7)(void *))
{
  void *v7; // eax@1
  int v8; // esi@1
  void *v9; // ST14_4@1
  struct BundleReplacer *result; // eax@1

  v7 = operator new(0x24u);
  v8 = (int)v7;
  v9 = v7;
  result = 0;
  if ( v9 )
  {
    sub_10014FB0(a6, a1, v8, a2, a3);
    *(_DWORD *)(v8 + 28) = a5;
    *(_DWORD *)v8 = &off_100A206C;
    *(_DWORD *)(v8 + 24) = a4;
    *(_DWORD *)(v8 + 32) = a7;
    result = (struct BundleReplacer *)v8;
  }
  return result;
}
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 100A206C: using guessed type unsigned __int32 (__thiscall *off_100A206C)(AssetFile *__hidden this);

//----- (10016660) --------------------------------------------------------
struct BundleReplacer *__cdecl MakeBundleEntryModifierFromAssets(const char *a1, const char *a2, struct AssetsFile *a3, struct AssetsReplacer **a4, unsigned int a5, unsigned __int32 a6, unsigned int a7)
{
  _DWORD *v7; // esi@1
  struct BundleReplacer *result; // eax@2

  v7 = operator new(0x30u);
  if ( v7 )
  {
    sub_10014FB0(a7, a1, (int)v7, a2, 1);
    v7[6] = a3;
    v7[9] = a5;
    *v7 = &off_100A209C;
    v7[7] = a4;
    v7[10] = a6;
    *((_WORD *)v7 + 22) = 0;
    v7[8] = 0;
    result = (struct BundleReplacer *)v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 100A209C: using guessed type unsigned __int32 (__thiscall *off_100A209C)(AssetFile *__hidden this);

//----- (10016700) --------------------------------------------------------
void __cdecl FreeBundleReplacer(struct BundleReplacer *a1)
{
  if ( a1 )
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)a1 + 4))(1);
}

//----- (10016720) --------------------------------------------------------
void *__cdecl sub_10016720(int a1, size_t a2)
{
  return malloc(a2);
}

//----- (10016740) --------------------------------------------------------
const char *__thiscall ClassDatabaseFileString::GetString(ClassDatabaseFileString *this, struct ClassDatabaseFile *a2)
{
  const char *result; // eax@2
  const char *v3; // ecx@3

  if ( *((_BYTE *)this + 4) )
  {
    v3 = *(const char **)this;
    if ( (unsigned int)v3 < *((_DWORD *)a2 + 7) )
      result = &v3[*((_DWORD *)a2 + 13)];
    else
      result = 0;
  }
  else
  {
    result = *(const char **)this;
  }
  return result;
}

//----- (10016770) --------------------------------------------------------
unsigned __int64 __thiscall ClassDatabaseFileString::Read(ClassDatabaseFileString *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 a4)
{
  *((_BYTE *)this + 4) = 1;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, ClassDatabaseFileString *, __int32))a2)(
    a4,
    HIDWORD(a4),
    4,
    0,
    this,
    a3);
  return a4 + 4;
}

//----- (100167B0) --------------------------------------------------------
unsigned __int64 __thiscall ClassDatabaseFileString::Write(ClassDatabaseFileString *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 a4)
{
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, ClassDatabaseFileString *, __int32))a2)(
    a4,
    HIDWORD(a4),
    4,
    0,
    this,
    a3);
  return a4 + 4;
}

//----- (100167F0) --------------------------------------------------------
AssetFile *__thiscall AssetFile::GetFileData(AssetFile *this)
{
  return this;
}

//----- (10016800) --------------------------------------------------------
ClassDatabaseTypeField *__thiscall ClassDatabaseTypeField::ClassDatabaseTypeField(ClassDatabaseTypeField *this, const struct ClassDatabaseTypeField *a2)
{
  ClassDatabaseTypeField *result; // eax@1

  result = this;
  qmemcpy((void *)this, (const void *)a2, 0x20u);
  return result;
}

//----- (10016820) --------------------------------------------------------
signed __int64 __thiscall ClassDatabaseTypeField::Read(ClassDatabaseTypeField *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 a4, int a5)
{
  ClassDatabaseTypeField *v5; // ebx@1
  unsigned int v6; // edi@1
  unsigned int v7; // esi@1
  int v9; // [sp+Ch] [bp-4h]@2

  v5 = this;
  *((_BYTE *)this + 4) = 1;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, ClassDatabaseTypeField *, __int32))a2)(
    a4,
    HIDWORD(a4),
    4,
    0,
    this,
    a3);
  *((_BYTE *)v5 + 12) = 1;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a2)(
    a4 + 4,
    (a4 + 4) >> 32,
    4,
    0,
    (char *)v5 + 8,
    a3);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a2)(
    a4 + 8,
    (a4 + 8) >> 32,
    1,
    0,
    (char *)v5 + 16,
    a3);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, _DWORD))a2)(
    a4 + 9,
    (a4 + 9) >> 32,
    1,
    0,
    (char *)v5 + 17,
    a3);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(
    a4 + 10,
    (a4 + 10) >> 32,
    4,
    0,
    (char *)v5 + 20,
    a3);
  v6 = (a4 + 14) >> 32;
  v7 = a4 + 14;
  *((_WORD *)v5 + 12) = 1;
  if ( a5 >= 1 )
  {
    if ( a5 >= 3 )
    {
      ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a2)(
        v7,
        v6,
        2,
        0,
        (char *)v5 + 24,
        a3);
      goto LABEL_6;
    }
  }
  else
  {
    ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, int *, __int32))a2)(v7, v6, 4, 0, &v9, a3);
    v6 = (__PAIR__(v6, v7) + 4) >> 32;
    v7 = a4 + 18;
    if ( v9 & 0x80000000 )
    {
      ((void (__cdecl *)(_DWORD, unsigned int, signed int, _DWORD, char *, __int32))a2)(
        a4 + 18,
        v6,
        2,
        0,
        (char *)v5 + 24,
        a3);
LABEL_6:
      v6 = (__PAIR__(v6, v7) + 2) >> 32;
      v7 += 2;
      goto LABEL_7;
    }
  }
LABEL_7:
  ((void (__cdecl *)(unsigned int, unsigned int, _DWORD, _DWORD, char *, _DWORD))a2)(v7, v6, 4, 0, (char *)v5 + 28, a3);
  return __PAIR__(v6, v7) + 4;
}

//----- (10016940) --------------------------------------------------------
signed __int64 __thiscall ClassDatabaseTypeField::Write(ClassDatabaseTypeField *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 a4, int a5)
{
  ClassDatabaseTypeField *v5; // ebx@1
  unsigned int v6; // edi@1
  unsigned int v7; // esi@1

  v5 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(a4, HIDWORD(a4), 4, 0, this, a3);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
    a4 + 4,
    (a4 + 4) >> 32,
    4,
    0,
    (char *)v5 + 8,
    a3);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
    a4 + 8,
    (a4 + 8) >> 32,
    1,
    0,
    (char *)v5 + 16,
    a3);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
    a4 + 9,
    (a4 + 9) >> 32,
    1,
    0,
    (char *)v5 + 17,
    a3);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
    a4 + 10,
    (a4 + 10) >> 32,
    4,
    0,
    (char *)v5 + 20,
    a3);
  v6 = (a4 + 14) >> 32;
  v7 = a4 + 14;
  if ( a5 >= 3 )
  {
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(v7, v6, 2, 0, (char *)v5 + 24, a3);
    v6 = (__PAIR__(v6, v7) + 2) >> 32;
    v7 = a4 + 16;
  }
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(v7, v6, 4, 0, (char *)v5 + 28, a3);
  return __PAIR__(v6, v7) + 4;
}

//----- (10016A10) --------------------------------------------------------
int __thiscall ClassDatabaseType::ClassDatabaseType(int this)
{
  int v1; // edi@1
  int v2; // esi@1
  char v4; // [sp+10h] [bp-20h]@1
  int v5; // [sp+20h] [bp-10h]@1
  int v6; // [sp+2Ch] [bp-4h]@1

  v1 = this;
  v5 = this;
  v2 = this + 16;
  *(_DWORD *)v2 = 0;
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  v6 = 0;
  *(_DWORD *)(this + 4) = -1;
  *(_DWORD *)this = -1;
  if ( (char *)(this + 16) != &v4 )
  {
    if ( *(_DWORD *)v2 )
      operator delete(*(void **)v2);
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
  }
  LOBYTE(v6) = 0;
  sub_10019C00(1u, v2);
  return v1;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10016C40) --------------------------------------------------------
void __thiscall ClassDatabaseType::~ClassDatabaseType(ClassDatabaseType *this)
{
  ClassDatabaseType *v1; // esi@1

  v1 = this;
  if ( *((_DWORD *)this + 4) )
    operator delete(*((void **)this + 4));
  *((_DWORD *)v1 + 4) = 0;
  *((_DWORD *)v1 + 5) = 0;
  *((_DWORD *)v1 + 6) = 0;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10016E20) --------------------------------------------------------
unsigned int __thiscall ClassDatabaseType::Write(ClassDatabaseType *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 a4, int a5)
{
  ClassDatabaseType *v5; // ebx@1
  unsigned int v6; // edi@1
  unsigned int v7; // esi@1
  signed __int64 v8; // rax@3
  int v10; // [sp+Ch] [bp-Ch]@2
  unsigned int v11; // [sp+10h] [bp-8h]@1
  unsigned int v12; // [sp+14h] [bp-4h]@1

  v5 = this;
  v11 = (*((_DWORD *)v5 + 5) - *((_DWORD *)v5 + 4)) >> 5;
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, ClassDatabaseType *, __int32))a2)(
    a4,
    HIDWORD(a4),
    4,
    0,
    this,
    a3);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a2)(
    a4 + 4,
    (a4 + 4) >> 32,
    4,
    0,
    (char *)v5 + 4,
    a3);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(
    a4 + 8,
    (a4 + 8) >> 32,
    4,
    0,
    (char *)v5 + 8,
    a3);
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, unsigned int *, __int32))a2)(
    a4 + 12,
    (a4 + 12) >> 32,
    4,
    0,
    &v11,
    a3);
  v6 = (a4 + 16) >> 32;
  v7 = a4 + 16;
  v12 = 0;
  if ( v11 )
  {
    v10 = 0;
    do
    {
      v8 = ClassDatabaseTypeField::Write(
             (ClassDatabaseTypeField *)(v10 + *((_DWORD *)v5 + 4)),
             a2,
             a3,
             __PAIR__(v6, v7),
             a5);
      v10 += 32;
      v6 = HIDWORD(v8);
      v7 = v8;
      ++v12;
    }
    while ( v12 < v11 );
  }
  return v7;
}

//----- (10016F00) --------------------------------------------------------
BYTE *__thiscall ClassDatabaseType::MakeTypeHash(_DWORD *this, BYTE *a2, int a3)
{
  BYTE *v3; // esi@1
  _DWORD *v4; // ebx@1
  signed int v6; // ecx@4
  int v7; // eax@6
  const BYTE *v8; // ecx@7
  const BYTE *v9; // edi@12
  unsigned int v10; // eax@13
  int v11; // eax@16
  const BYTE *v12; // eax@16
  char v13; // dl@17
  signed int v14; // ecx@18
  DWORD pdwDataLen; // [sp+Ch] [bp-28h]@20
  BYTE v16[4]; // [sp+10h] [bp-24h]@16
  BYTE v17[4]; // [sp+14h] [bp-20h]@16
  BYTE v18[4]; // [sp+18h] [bp-1Ch]@16
  BYTE pbData[4]; // [sp+1Ch] [bp-18h]@16
  const BYTE *v20; // [sp+20h] [bp-14h]@16
  unsigned int v21; // [sp+24h] [bp-10h]@4
  HCRYPTPROV phProv; // [sp+28h] [bp-Ch]@1
  int v23; // [sp+2Ch] [bp-8h]@5
  HCRYPTHASH phHash; // [sp+30h] [bp-4h]@2

  v3 = a2;
  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 3) = 0;
  v4 = this;
  if ( CryptAcquireContextW(&phProv, 0, 0, 1u, 0xF0000000) )
  {
    if ( !CryptCreateHash(phProv, 0x8002u, 0, 0, &phHash) )
    {
      CryptReleaseContext(phProv, 0);
      return a2;
    }
    v6 = v4[5] - v4[4];
    v21 = 0;
    if ( v6 >> 5 )
    {
      v23 = 0;
      do
      {
        v7 = v4[4] + v23;
        if ( *(_BYTE *)(v7 + 4) )
        {
          if ( *(_DWORD *)v7 < *(_DWORD *)(a3 + 28) )
            v8 = (const BYTE *)(*(_DWORD *)v7 + *(_DWORD *)(a3 + 52));
          else
            v8 = 0;
        }
        else
        {
          v8 = *(const BYTE **)v7;
        }
        if ( *(_BYTE *)(v7 + 12) )
        {
          v10 = *(_DWORD *)(v7 + 8);
          if ( v10 < *(_DWORD *)(a3 + 28) )
            v9 = (const BYTE *)(v10 + *(_DWORD *)(a3 + 52));
          else
            v9 = 0;
        }
        else
        {
          v9 = *(const BYTE **)(v7 + 8);
        }
        v11 = v4[4] + v23;
        *(_DWORD *)pbData = *(_DWORD *)(v11 + 20);
        *(_DWORD *)v18 = *(_BYTE *)(v11 + 17);
        *(_DWORD *)v17 = *(_WORD *)(v11 + 24);
        *(_DWORD *)v16 = *(_DWORD *)(v11 + 28) & 0x4000;
        v12 = v8;
        v20 = v8 + 1;
        do
          v13 = *v12++;
        while ( v13 );
        CryptHashData(phHash, v8, v12 - v20, 0);
        CryptHashData(phHash, v9, strlen((const char *)v9), 0);
        CryptHashData(phHash, pbData, 4u, 0);
        CryptHashData(phHash, v18, 4u, 0);
        CryptHashData(phHash, v17, 4u, 0);
        CryptHashData(phHash, v16, 4u, 0);
        v14 = v4[5] - v4[4];
        v23 += 32;
        ++v21;
      }
      while ( v21 < v14 >> 5 );
      v3 = a2;
    }
    pdwDataLen = 16;
    CryptGetHashParam(phHash, 2u, v3, &pdwDataLen, 0);
    CryptDestroyHash(phHash);
    CryptReleaseContext(phProv, 0);
  }
  return v3;
}

//----- (100170C0) --------------------------------------------------------
signed __int64 __thiscall ClassDatabaseFileHeader::Read(ClassDatabaseFileHeader *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 a4)
{
  __int64 v4; // rax@1
  ClassDatabaseFileHeader *v5; // eax@3
  unsigned int v6; // edi@3
  unsigned int v7; // esi@3
  unsigned int v8; // edi@4
  unsigned int v9; // edi@4
  unsigned __int64 v10; // kr18_8@4
  unsigned __int64 v11; // kr20_8@4
  ClassDatabaseFileHeader *v12; // ecx@7
  unsigned int v13; // edi@7
  int v14; // esi@7
  unsigned __int64 v15; // kr28_8@7
  int v16; // eax@8
  unsigned __int64 v17; // kr38_8@9
  unsigned int v18; // edx@9
  void *v19; // eax@10
  int v20; // eax@11
  int v21; // eax@12
  size_t v22; // ecx@12
  unsigned int v23; // edi@12
  unsigned __int64 v24; // kr50_8@12
  unsigned int v25; // ecx@12
  bool v26; // cf@12
  signed __int64 result; // rax@15
  unsigned __int8 v28; // [sp+13h] [bp-15h]@7
  ClassDatabaseFileHeader *v29; // [sp+14h] [bp-14h]@1
  size_t v30; // [sp+18h] [bp-10h]@8
  unsigned int v31; // [sp+1Ch] [bp-Ch]@8
  unsigned __int64 v32; // [sp+20h] [bp-8h]@8

  v29 = this;
  LODWORD(v4) = ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, ClassDatabaseFileHeader *, __int32))a2)(
                  a4,
                  HIDWORD(a4),
                  4,
                  0,
                  this,
                  a3);
  if ( v4 && *(_DWORD *)v29 == 1650748515 )
  {
    ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, __int32))a2)(
      a4 + 4,
      (a4 + 4) >> 32,
      1,
      0,
      (char *)v29 + 4,
      a3);
    v5 = v29;
    v6 = (a4 + 5) >> 32;
    v7 = a4 + 5;
    if ( *((_BYTE *)v29 + 4) < 2u )
    {
      *((_BYTE *)v29 + 5) = 0;
      *((_DWORD *)v5 + 3) = 0;
      *((_DWORD *)v5 + 2) = 0;
    }
    else
    {
      ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, char *, __int32))a2)(
        v7,
        v6,
        1,
        0,
        (char *)v29 + 5,
        a3);
      v8 = (__PAIR__(v6, v7) + 1) >> 32;
      ((void (__cdecl *)(_DWORD, unsigned int, signed int, _DWORD, char *, __int32))a2)(
        a4 + 6,
        v8,
        4,
        0,
        (char *)v29 + 8,
        a3);
      v10 = __PAIR__(v8, (signed int)a4 + 6) + 4;
      v9 = (__PAIR__(v8, (signed int)a4 + 6) + 4) >> 32;
      ((void (__cdecl *)(_DWORD, unsigned int, signed int, _DWORD, char *, __int32))a2)(
        v10,
        v9,
        4,
        0,
        (char *)v29 + 12,
        a3);
      v5 = v29;
      v11 = __PAIR__(v9, (unsigned int)v10) + 4;
      v6 = (__PAIR__(v9, (unsigned int)v10) + 4) >> 32;
      v7 = v11;
    }
    if ( *((_BYTE *)v5 + 4) )
    {
      ((void (__cdecl *)(unsigned int, _DWORD, signed int, _DWORD, char *, _DWORD))a2)(
        v7,
        v6,
        1,
        0,
        (char *)v5 + 16,
        a3);
      v16 = *((_BYTE *)v29 + 16);
      v13 = (__PAIR__(v6, v7) + 1) >> 32;
      v14 = v7 + 1;
      v32 = __PAIR__(v13, v14);
      v30 = 4 * v16;
      v31 = 0;
      if ( v16 )
      {
        do
        {
          ((void (__cdecl *)(int, unsigned int, signed int, _DWORD, unsigned __int8 *, __int32))a2)(
            v14,
            v13,
            1,
            0,
            &v28,
            a3);
          v17 = v28 + 1i64 + __PAIR__(v13, v14);
          v13 = v17 >> 32;
          v14 = v17;
          v30 += v28 + 1;
          v18 = *((_BYTE *)v29 + 16);
          ++v31;
        }
        while ( v31 < v18 );
      }
      v19 = malloc(v30);
      v12 = v29;
      *((_DWORD *)v29 + 5) = v19;
      if ( v19 )
      {
        v20 = *((_BYTE *)v12 + 16);
        v13 = HIDWORD(v32);
        v14 = v32;
        v30 = 4 * v20;
        v31 = 0;
        if ( v20 )
        {
          do
          {
            v21 = *((_DWORD *)v12 + 5);
            v22 = v21 + v30;
            *(_DWORD *)(v21 + 4 * v31) = v21 + v30;
            LODWORD(v32) = v22;
            ((void (__cdecl *)(int, unsigned int, signed int, _DWORD, unsigned __int8 *, __int32))a2)(
              v14,
              v13,
              1,
              0,
              &v28,
              a3);
            v23 = (__PAIR__(v13, v14) + 1) >> 32;
            ((void (__cdecl *)(int, unsigned int, _DWORD, _DWORD, _DWORD, __int32))a2)(v14 + 1, v23, v28, 0, v32, a3);
            *(_BYTE *)(v28 + (_DWORD)v32) = 0;
            v24 = v28 + __PAIR__(v23, v14 + 1);
            v13 = v24 >> 32;
            v14 = v24;
            v25 = *((_BYTE *)v29 + 16);
            v30 += v28 + 1;
            v26 = v31 + 1 < v25;
            v12 = v29;
            ++v31;
          }
          while ( v26 );
        }
      }
      else
      {
        *((_BYTE *)v12 + 16) = 0;
      }
    }
    else
    {
      ((void (__cdecl *)(unsigned int, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(v7, v6, 1, 0, &v28, a3);
      v12 = v29;
      v15 = v28 + 1i64 + __PAIR__(v6, v7);
      v13 = v15 >> 32;
      v14 = v15;
    }
    ((void (__cdecl *)(int, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(v14, v13, 4, 0, (char *)v12 + 24, a3);
    ((void (__cdecl *)(int, _DWORD, signed int, _DWORD, char *, __int32))a2)(
      v14 + 4,
      (__PAIR__(v13, v14) + 4) >> 32,
      4,
      0,
      (char *)v29 + 28,
      a3);
    result = __PAIR__(v13, v14) + 8;
  }
  else
  {
    result = 0i64;
  }
  return result;
}

//----- (10017350) --------------------------------------------------------
signed __int64 __thiscall ClassDatabaseFileHeader::Write(ClassDatabaseFileHeader *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 a4)
{
  unsigned int v4; // edi@1
  unsigned int v5; // esi@1
  unsigned int v6; // edi@2
  unsigned int v7; // edi@2
  unsigned __int64 v8; // kr18_8@2
  unsigned __int64 v9; // kr20_8@2
  unsigned int v10; // edi@3
  int v11; // esi@3
  bool v12; // zf@3
  unsigned int v13; // edi@4
  unsigned __int64 v14; // kr38_8@4
  unsigned int v15; // edx@4
  unsigned __int8 v17; // [sp+Fh] [bp-9h]@4
  ClassDatabaseFileHeader *v18; // [sp+10h] [bp-8h]@1
  unsigned int v19; // [sp+14h] [bp-4h]@3

  v18 = this;
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(a4, HIDWORD(a4), 4, 0, "cldb", a3);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
    a4 + 4,
    (a4 + 4) >> 32,
    1,
    0,
    (char *)v18 + 4,
    a3);
  v4 = (a4 + 5) >> 32;
  v5 = a4 + 5;
  if ( *((_BYTE *)v18 + 4) >= 2u )
  {
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(v5, v4, 1, 0, (char *)v18 + 5, a3);
    v6 = (__PAIR__(v4, v5) + 1) >> 32;
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(a4 + 6, v6, 4, 0, (char *)v18 + 8, a3);
    v8 = __PAIR__(v6, (signed int)a4 + 6) + 4;
    v7 = (__PAIR__(v6, (signed int)a4 + 6) + 4) >> 32;
    ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(v8, v7, 4, 0, (char *)v18 + 12, a3);
    v9 = __PAIR__(v7, (unsigned int)v8) + 4;
    v4 = (__PAIR__(v7, (unsigned int)v8) + 4) >> 32;
    v5 = v9;
  }
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(v5, v4, 1, 0, (char *)v18 + 16, a3);
  v10 = (__PAIR__(v4, v5) + 1) >> 32;
  v11 = v5 + 1;
  v12 = *((_BYTE *)v18 + 16) == 0;
  v19 = 0;
  if ( !v12 )
  {
    do
    {
      v17 = strlen(*(const char **)(*((_DWORD *)v18 + 5) + 4 * v19));
      ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(v11, v10, 1, 0, &v17, a3);
      v13 = (__PAIR__(v10, v11) + 1) >> 32;
      ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
        v11 + 1,
        v13,
        v17,
        0,
        *(_DWORD *)(*((_DWORD *)v18 + 5) + 4 * v19),
        a3);
      v14 = v17 + __PAIR__(v13, v11 + 1);
      v10 = v14 >> 32;
      v11 = v14;
      v15 = *((_BYTE *)v18 + 16);
      ++v19;
    }
    while ( v19 < v15 );
  }
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(v11, v10, 4, 0, (char *)v18 + 24, a3);
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a2)(
    v11 + 4,
    (__PAIR__(v10, v11) + 4) >> 32,
    4,
    0,
    (char *)v18 + 28,
    a3);
  return __PAIR__(v10, v11) + 8;
}

//----- (100174D0) --------------------------------------------------------
int __thiscall ClassDatabaseFile::Read(ClassDatabaseFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), void *a3, unsigned __int64 a4)
{
  ClassDatabaseFile *v4; // ebx@1
  int v5; // esi@1
  signed __int64 v6; // rax@1
  int v7; // edi@1
  unsigned __int8 v8; // al@2
  _BYTE *v9; // eax@4
  int v10; // eax@5
  int v11; // edx@5
  size_t v12; // eax@9
  void *v13; // eax@9
  char v14; // cl@11
  char *v15; // eax@12
  unsigned int v16; // edx@15
  _DWORD *v17; // eax@20
  unsigned int v18; // edi@26
  int v19; // ebx@26
  unsigned int v20; // eax@27
  int v21; // edx@28
  int v22; // ecx@29
  char *v23; // esi@29
  unsigned int v24; // eax@30
  unsigned int v25; // eax@31
  unsigned int v26; // ecx@31
  unsigned int v27; // ecx@33
  int v28; // ecx@38
  unsigned int v29; // esi@38
  int v30; // ecx@41
  unsigned int v31; // eax@42
  unsigned int v32; // eax@43
  unsigned int v33; // ecx@43
  unsigned int v34; // ecx@45
  int v35; // ecx@50
  void *v36; // eax@56
  int v37; // esi@61
  int v38; // edx@61
  void *v40; // [sp+20h] [bp-64h]@1
  ClassDatabaseFile *v41; // [sp+24h] [bp-60h]@1
  _BYTE *v42; // [sp+28h] [bp-5Ch]@4
  int v43; // [sp+2Ch] [bp-58h]@5
  char *v44; // [sp+30h] [bp-54h]@11
  unsigned int v45; // [sp+34h] [bp-50h]@15
  int v46; // [sp+38h] [bp-4Ch]@5
  unsigned int v47; // [sp+40h] [bp-44h]@26
  int v48; // [sp+44h] [bp-40h]@9
  int v49; // [sp+48h] [bp-3Ch]@5
  int v50; // [sp+4Ch] [bp-38h]@2
  int v51; // [sp+50h] [bp-34h]@2
  int v52; // [sp+54h] [bp-30h]@27
  int v53; // [sp+58h] [bp-2Ch]@27
  void *v54; // [sp+64h] [bp-20h]@27
  int v55; // [sp+68h] [bp-1Ch]@27
  int v56; // [sp+6Ch] [bp-18h]@27
  int v57; // [sp+80h] [bp-4h]@27
  unsigned __int64 v58; // [sp+94h] [bp+10h]@2

  v4 = this;
  v41 = this;
  *(_WORD *)this = 0;
  v40 = 0;
  v6 = ClassDatabaseFileHeader::Read((ClassDatabaseFile *)((char *)this + 4), a2, (__int32)a3, a4);
  v5 = v6;
  LODWORD(v6) = a4;
  v7 = HIDWORD(v6);
  if ( __PAIR__(HIDWORD(v6), v5) == a4 )
    return v6;
  LOBYTE(v6) = *((_BYTE *)v4 + 9);
  v58 = __PAIR__(HIDWORD(v6), v5);
  v50 = v5;
  v51 = HIDWORD(v6);
  if ( (_BYTE)v6 && v8 < 3u )
  {
    v9 = malloc(*((_DWORD *)v4 + 3));
    v42 = v9;
    if ( !v9 )
    {
LABEL_8:
      LODWORD(v6) = v5;
      return v6;
    }
    v43 = *((_DWORD *)v4 + 3);
    v49 = 0;
    v10 = ((int (__cdecl *)(int, int, int, _DWORD, _BYTE *, void *))a2)(v5, v7, v43, 0, v9, a3);
    v46 = v11;
    if ( v10 != v43 || v46 != v49 )
    {
      free(v42);
      goto LABEL_8;
    }
    v50 = v5 + v43;
    v12 = *((_DWORD *)v4 + 4) + 1;
    v51 = v7 + __CFADD__(v5, v43) + v49;
    v48 = v12;
    v13 = malloc(v12);
    v40 = v13;
    if ( !v13 )
    {
      free(v42);
      LODWORD(v6) = v5;
      return v6;
    }
    v14 = *((_BYTE *)v4 + 9);
    v44 = 0;
    if ( v14 == 1 )
    {
      v15 = sub_100225A0(v48, v42, v13, v43);
    }
    else
    {
      if ( v14 != 2 )
        goto LABEL_18;
      if ( (unsigned int)v43 <= 5 )
        goto LABEL_18;
      v16 = *((_DWORD *)v4 + 4);
      v48 = v43 - 5;
      v45 = v16;
      v4 = v41;
      if ( sub_100248F0(&v43, v42 + 5, (int *)&v45, (int)v13, (unsigned int *)&v48, (int)v42) )
        goto LABEL_18;
      v15 = (char *)v45;
    }
    v44 = v15;
LABEL_18:
    free(v42);
    v45 = *((_DWORD *)v4 + 4);
    if ( v44 != (char *)v45 )
    {
      free(v40);
      LODWORD(v6) = v5;
      return v6;
    }
    v17 = malloc(0xCu);
    if ( v17 )
    {
      v17[1] = v45;
      *v17 = 0;
      v17[2] = v40;
      a3 = v17;
    }
    else
    {
      a3 = 0;
    }
    a2 = (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32))AssetsReaderFromMemory;
    if ( !a3 )
    {
      free(v40);
      LODWORD(v6) = v5;
      return v6;
    }
    v58 = 0i64;
  }
  ((void (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, unsigned int *, void *))a2)(v58, HIDWORD(v58), 4, 0, &v47, a3);
  v18 = (v58 + 4) >> 32;
  LODWORD(v58) = v58 + 4;
  v19 = (int)v4 + 36;
  sub_10019D80((void *)v19, v47);
  v45 = 0;
  if ( v47 )
  {
    do
    {
      v57 = 0;
      v53 = -1;
      v52 = -1;
      v54 = 0;
      v55 = 0;
      v56 = 0;
      LOBYTE(v57) = 0;
      sub_10019C00(1u, (int)&v54);
      v57 = 2;
      v58 = ClassDatabaseType::Read(
              (ClassDatabaseType *)&v52,
              a2,
              (__int32)a3,
              __PAIR__(v18, (unsigned int)v58),
              *((_BYTE *)v41 + 8));
      v20 = *(_DWORD *)(v19 + 4);
      if ( (unsigned int)&v52 >= v20 || (v21 = *(_DWORD *)v19, *(_DWORD *)v19 > (unsigned int)&v52) )
      {
        v30 = *(_DWORD *)(v19 + 8);
        if ( v20 == v30 )
        {
          v31 = (signed int)(v20 - *(_DWORD *)v19) >> 5;
          if ( v31 > 0x7FFFFFE )
          {
LABEL_60:
            std::_Xlength_error("vector<T> too long");
            goto LABEL_61;
          }
          v32 = v31 + 1;
          v33 = (v30 - *(_DWORD *)v19) >> 5;
          if ( v32 > v33 )
          {
            if ( 0x7FFFFFF - (v33 >> 1) >= v33 )
              v34 = (v33 >> 1) + v33;
            else
              v34 = 0;
            if ( v34 < v32 )
              v34 = v32;
            sub_10019D80((void *)v19, v34);
          }
        }
        v35 = *(_DWORD *)(v19 + 4);
        LOBYTE(v57) = 4;
        if ( v35 )
          ((void (__stdcall *)(int *))ClassDatabaseType::ClassDatabaseType)(&v52);
        *(_DWORD *)(v19 + 4) += 32;
      }
      else
      {
        v22 = *(_DWORD *)(v19 + 8);
        v23 = (char *)&v52 - v21;
        if ( v20 == v22 )
        {
          v24 = (signed int)(v20 - v21) >> 5;
          if ( v24 > 0x7FFFFFE )
            goto LABEL_60;
          v25 = v24 + 1;
          v26 = (v22 - v21) >> 5;
          if ( v25 > v26 )
          {
            if ( 0x7FFFFFF - (v26 >> 1) >= v26 )
              v27 = (v26 >> 1) + v26;
            else
              v27 = 0;
            if ( v27 < v25 )
              v27 = v25;
            sub_10019D80((void *)v19, v27);
          }
        }
        v28 = *(_DWORD *)(v19 + 4);
        v29 = *(_DWORD *)v19 + ((unsigned int)v23 & 0xFFFFFFE0);
        LOBYTE(v57) = 3;
        if ( v28 )
          ((void (__stdcall *)(unsigned int))ClassDatabaseType::ClassDatabaseType)(v29);
        *(_DWORD *)(v19 + 4) += 32;
      }
      v57 = -1;
      if ( v54 )
        operator delete(v54);
      v18 = HIDWORD(v58);
      v54 = 0;
      v55 = 0;
      v56 = 0;
      ++v45;
    }
    while ( v45 < v47 );
  }
  v19 = (int)v41;
  v36 = malloc(*((_DWORD *)v41 + 7) + 1);
  *((_DWORD *)v41 + 13) = v36;
  if ( !v36 )
  {
    if ( v40 )
    {
      free(a3);
      free(v40);
    }
LABEL_59:
    LODWORD(v6) = v58;
    return v6;
  }
LABEL_61:
  v37 = *(_DWORD *)(v19 + 28);
  if ( ((int (__cdecl *)(_DWORD, _DWORD, int, _DWORD, void *, void *))a2)(*((_DWORD *)v41 + 8), 0, v37, 0, v36, a3) != v37
    || v38 )
  {
    if ( v40 )
    {
      free(a3);
      free(v40);
      LODWORD(v6) = v58;
      return v6;
    }
    goto LABEL_59;
  }
  *(_BYTE *)(v37 + *((_DWORD *)v41 + 13)) = 0;
  if ( v40 )
  {
    free(a3);
    free(v40);
    LODWORD(v6) = v50;
  }
  else
  {
    LODWORD(v6) = v58;
  }
  *(_BYTE *)v41 = 1;
  return v6;
}
// 10016C70: using guessed type unsigned __int64 __thiscall ClassDatabaseType::Read(ClassDatabaseType *__hidden this, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32), __int32, unsigned __int64, _DWORD);
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10017990) --------------------------------------------------------
bool __thiscall ClassDatabaseFile::Read(ClassDatabaseFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), void *a3)
{
  ClassDatabaseFile *v3; // esi@1

  v3 = this;
  ClassDatabaseFile::Read(this, a2, a3, 0i64);
  return *(_BYTE *)v3;
}

//----- (100179D0) --------------------------------------------------------
char __stdcall sub_100179D0(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // edi@1
  void *v4; // eax@1
  char *v5; // ebx@1
  unsigned int v6; // esi@2
  _DWORD *v7; // ecx@3
  const char *v8; // eax@4
  unsigned int v9; // eax@5
  char *v10; // edx@9
  unsigned int v11; // eax@11
  int v12; // ebx@11
  unsigned int v13; // ecx@13
  int v14; // esi@14
  int v15; // eax@16
  unsigned int v16; // ecx@16
  int v17; // edx@16
  int v18; // esi@31
  unsigned int v19; // ebx@31
  char result; // al@37
  unsigned int v21; // [sp+8h] [bp-Ch]@11
  char *v22; // [sp+Ch] [bp-8h]@1
  unsigned int v23; // [sp+10h] [bp-4h]@8
  char *v24; // [sp+20h] [bp+Ch]@9

  v3 = a3;
  v4 = malloc(12 * a3);
  v5 = (char *)v4;
  v22 = (char *)v4;
  if ( v4 )
  {
    v6 = 0;
    if ( a3 )
    {
      v7 = (char *)v4 + 8;
      do
      {
        v8 = *(const char **)(a2 + 4 * v6);
        *(v7 - 1) = v8;
        if ( v8 )
        {
          v9 = strlen(v8);
          v5 = v22;
        }
        else
        {
          v9 = 0;
        }
        *(v7 - 2) = v9;
        *v7 = 0;
        ++v6;
        v7 += 3;
      }
      while ( v6 < a3 );
    }
    v23 = 0;
    if ( a3 )
    {
      v10 = v5;
      v24 = v5;
      do
      {
        if ( *((_DWORD *)v10 + 1) )
        {
          v11 = 0;
          v21 = 0;
          v12 = (int)(v5 + 4);
          do
          {
            if ( v11 != v23 )
            {
              v13 = *(_DWORD *)(v12 - 4);
              if ( v13 <= *(_DWORD *)v10 )
              {
                v14 = *(_DWORD *)v12;
                if ( *(_DWORD *)v12 )
                {
                  if ( !*(_DWORD *)(v12 + 4) )
                  {
                    v15 = *((_DWORD *)v10 + 1) + *(_DWORD *)v10 - v13;
                    v16 = v13 + 1;
                    v17 = v15;
                    if ( v16 < 4 )
                    {
LABEL_19:
                      if ( !v16
                        || *(_BYTE *)v17 == *(_BYTE *)v14
                        && (v16 <= 1
                         || *(_BYTE *)(v17 + 1) == *(_BYTE *)(v14 + 1)
                         && (v16 <= 2 || *(_BYTE *)(v17 + 2) == *(_BYTE *)(v14 + 2))) )
                      {
                        *(_DWORD *)v12 = v15;
                        *(_DWORD *)(v12 + 4) = v24;
                      }
                    }
                    else
                    {
                      while ( *(_DWORD *)v14 == *(_DWORD *)v17 )
                      {
                        v16 -= 4;
                        v17 += 4;
                        v14 += 4;
                        if ( v16 < 4 )
                          goto LABEL_19;
                      }
                    }
                    v10 = v24;
                    v3 = a3;
                  }
                }
              }
            }
            v11 = v21 + 1;
            v12 += 12;
            v21 = v11;
          }
          while ( v11 < v3 );
          v5 = v22;
        }
        v10 += 12;
        ++v23;
        v24 = v10;
      }
      while ( v23 < v3 );
      if ( v3 )
      {
        v18 = (int)(v5 + 4);
        v19 = v3;
        do
        {
          if ( *(_DWORD *)v18 )
          {
            if ( !*(_DWORD *)(v18 + 4) )
              sub_10017B50(a1, *(char **)v18, 0);
          }
          v18 += 12;
          --v19;
        }
        while ( v19 );
        v5 = v22;
      }
    }
    free(v5);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10017B50) --------------------------------------------------------
int __userpurge sub_10017B50@<eax>(int a1@<edi>, char *a2, char a3)
{
  char *v3; // ebx@1
  signed int v5; // ecx@3
  unsigned int v6; // eax@3
  unsigned int v7; // ecx@4
  int v8; // eax@9
  int v9; // esi@9
  int v10; // ebx@10
  int v11; // eax@14
  unsigned int v12; // eax@15
  void *v13; // eax@15
  int v14; // esi@24
  int v15; // eax@25
  int v16; // esi@25
  char *v17; // eax@27
  char v18; // cl@30
  int v19; // [sp+8h] [bp-10h]@3
  int v20; // [sp+8h] [bp-10h]@14
  int v21; // [sp+Ch] [bp-Ch]@3
  unsigned int v22; // [sp+10h] [bp-8h]@3
  int v23; // [sp+14h] [bp-4h]@3
  int v24; // [sp+14h] [bp-4h]@8
  char *v25; // [sp+20h] [bp+8h]@27

  v3 = a2;
  if ( !a2 )
    return 0;
  v19 = 0;
  v21 = 0;
  v5 = strlen(a2);
  v6 = 0;
  v22 = v5;
  v23 = 0;
  if ( v5 >= 2 )
  {
    v7 = v5 - 1;
    do
    {
      LOWORD(v19) = a2[v6] + (_WORD)v19;
      LOWORD(v21) = a2[v6 + 1] + (_WORD)v21;
      v6 += 2;
    }
    while ( v6 < v7 );
  }
  if ( v6 < v22 )
    v23 = (unsigned __int16)a2[v6];
  v24 = v19 + v21 + v23;
  if ( a3 )
  {
    v8 = *(_DWORD *)(a1 + 12);
    v9 = 0;
    if ( v8 )
    {
      v10 = v8 + 8 * (unsigned __int16)v24;
      if ( *(_DWORD *)(v8 + 8 * (unsigned __int16)v24) > 0u )
      {
        while ( strncmp((const char *)(*(_DWORD *)a1 + *(_DWORD *)(*(_DWORD *)(v10 + 4) + 4 * v9)), a2, v22 + 1) )
        {
          if ( (unsigned int)++v9 >= *(_DWORD *)v10 )
            goto LABEL_13;
        }
        return *(_DWORD *)(*(_DWORD *)(v10 + 4) + 4 * v9);
      }
LABEL_13:
      v3 = a2;
    }
    else if ( *(_DWORD *)(a1 + 8) > 0u )
    {
      while ( strncmp((const char *)(v9 + *(_DWORD *)a1), a2, v22 + 1) )
      {
        if ( (unsigned int)++v9 >= *(_DWORD *)(a1 + 8) )
          goto LABEL_14;
      }
      return v9;
    }
  }
LABEL_14:
  v11 = *(_DWORD *)(a1 + 8);
  v20 = *(_DWORD *)(a1 + 8);
  if ( v11 + v22 + 1 > *(_DWORD *)(a1 + 4) )
  {
    v12 = (v11 + v22 + 16) & 0xFFFFFFF0;
    *(_DWORD *)(a1 + 4) = v12;
    v13 = realloc(*(void **)a1, v12);
    if ( !v13 )
      return -1;
    *(_DWORD *)a1 = v13;
  }
  v14 = *(_DWORD *)(a1 + 12);
  if ( v14 )
  {
    v15 = *(_DWORD *)(v14 + 8 * (unsigned __int16)v24);
    v16 = v14 + 8 * (unsigned __int16)v24;
    if ( v15 )
    {
      if ( ((_BYTE)v15 + 1) & 3 )
        goto LABEL_37;
    }
    v17 = (char *)realloc(*(void **)(v16 + 4), 4 * ((v15 + 5) & 0xFFFFFFFC));
    v25 = v17;
    if ( v17 )
    {
      v18 = 1;
    }
    else
    {
      if ( *(_DWORD *)(v16 + 4) )
      {
        free(*(void **)(v16 + 4));
        v17 = v25;
      }
      *(_DWORD *)v16 = 0;
      v18 = 0;
    }
    *(_DWORD *)(v16 + 4) = v17;
    if ( v18 )
LABEL_37:
      *(_DWORD *)(*(_DWORD *)(v16 + 4) + 4 * (*(_DWORD *)v16)++) = *(_DWORD *)(a1 + 8);
  }
  strncpy((char *)(v20 + *(_DWORD *)a1), v3, v22 + 1);
  *(_DWORD *)(a1 + 8) += v22 + 1;
  return v20;
}

//----- (10017D20) --------------------------------------------------------
__int64 __thiscall ClassDatabaseFile::Write(ClassDatabaseFile *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 a4, int a5, unsigned __int32 a6, bool a7)
{
  ClassDatabaseFile *v7; // ebx@1
  unsigned int v8; // esi@1
  unsigned int v9; // ecx@3
  int v10; // eax@4
  unsigned int v11; // edx@4
  signed int v12; // edi@5
  _DWORD *v13; // edi@6
  unsigned int v14; // edx@7
  int v15; // eax@10
  int *v16; // eax@14
  int v17; // eax@15
  int v18; // ecx@17
  unsigned int v19; // esi@18
  bool v20; // zf@21
  int v21; // ecx@22
  char v22; // ST37_1@29
  int v23; // esi@34
  char *v24; // eax@35
  unsigned int v25; // ecx@36
  int v26; // esi@41
  char *v27; // eax@42
  unsigned int v28; // ecx@43
  int v29; // eax@46
  char *v30; // eax@47
  int v31; // eax@51
  int v32; // ecx@51
  int v33; // ecx@56
  void *v34; // eax@56
  signed int v35; // edi@60
  unsigned int v36; // edi@60
  int v37; // esi@61
  unsigned int v38; // edx@62
  unsigned int v39; // eax@62
  _WORD *v40; // ecx@63
  unsigned int v41; // edi@69
  unsigned int v42; // esi@69
  signed __int64 v43; // kr00_8@69
  _DWORD *v44; // eax@70
  unsigned int v45; // edi@72
  int v46; // esi@72
  unsigned int v47; // eax@74
  unsigned int v48; // edx@74
  int v49; // eax@76
  unsigned __int64 v50; // kr10_8@78
  int v51; // ecx@79
  _BYTE *v52; // edx@83
  void *v53; // eax@83
  unsigned int v54; // ecx@83
  unsigned int v55; // esi@86
  unsigned __int64 (__cdecl *v56)(unsigned __int64, unsigned __int64, const void *, __int32); // eax@90
  int v57; // eax@94
  int v58; // esi@94
  signed int v59; // ebx@95
  ClassDatabaseFile *v60; // edx@100
  void (__cdecl *v61)(void *); // edi@106
  unsigned __int64 (__cdecl *v62)(unsigned __int64, unsigned __int64, const void *, __int32); // esi@108
  int v63; // ST0C_4@109
  __int64 v64; // ST00_8@109
  int *v66; // [sp+Ch] [bp-8Ch]@8
  void *v67; // [sp+Ch] [bp-8Ch]@33
  void *v68; // [sp+Ch] [bp-8Ch]@69
  char *v69; // [sp+10h] [bp-88h]@8
  bool v70; // [sp+10h] [bp-88h]@33
  void *v71; // [sp+10h] [bp-88h]@73
  void *v72; // [sp+10h] [bp-88h]@83
  unsigned __int64 (__cdecl *v73)(unsigned __int64, unsigned __int64, const void *, __int32); // [sp+14h] [bp-84h]@40
  unsigned __int64 (__cdecl *v74)(unsigned __int64, unsigned __int64, const void *, __int32); // [sp+14h] [bp-84h]@69
  unsigned __int64 (__cdecl *v75)(unsigned __int64, unsigned __int64, const void *, __int32); // [sp+14h] [bp-84h]@90
  int v76; // [sp+18h] [bp-80h]@15
  unsigned int v77; // [sp+18h] [bp-80h]@39
  signed int v78; // [sp+18h] [bp-80h]@83
  unsigned int v79; // [sp+20h] [bp-78h]@32
  int v80; // [sp+24h] [bp-74h]@79
  unsigned int v81; // [sp+28h] [bp-70h]@1
  char *v82; // [sp+2Ch] [bp-6Ch]@34
  __int64 v83; // [sp+30h] [bp-68h]@69
  ClassDatabaseFile *v84; // [sp+3Ch] [bp-5Ch]@1
  int v85; // [sp+40h] [bp-58h]@2
  int v86; // [sp+44h] [bp-54h]@2
  int v87; // [sp+48h] [bp-50h]@2
  void *v88; // [sp+4Ch] [bp-4Ch]@2
  ClassDatabaseFileHeader *v89; // [sp+54h] [bp-44h]@69
  unsigned __int64 v90; // [sp+58h] [bp-40h]@58
  int v91; // [sp+60h] [bp-38h]@94
  int v92; // [sp+64h] [bp-34h]@94
  int v93; // [sp+68h] [bp-30h]@94
  int v94; // [sp+6Ch] [bp-2Ch]@94
  int v95; // [sp+70h] [bp-28h]@94
  int v96; // [sp+74h] [bp-24h]@94
  int v97; // [sp+78h] [bp-20h]@94
  int v98; // [sp+7Ch] [bp-1Ch]@94
  int v99; // [sp+80h] [bp-18h]@94
  int v100; // [sp+84h] [bp-14h]@94
  int v101; // [sp+88h] [bp-10h]@94
  int v102; // [sp+8Ch] [bp-Ch]@94
  int v103; // [sp+90h] [bp-8h]@94
  int v104; // [sp+94h] [bp-4h]@94

  v7 = this;
  v8 = (*((_DWORD *)this + 10) - *((_DWORD *)this + 9)) >> 5;
  v84 = this;
  v81 = v8;
  if ( a7 )
  {
    v85 = 0;
    v86 = 0;
    v87 = 0;
    v88 = 0;
    if ( a5 == 2 )
    {
      v9 = v8;
      if ( v8 > 0 )
      {
        v10 = *((_DWORD *)v7 + 9) + 16;
        v11 = v8;
        do
        {
          v12 = *(_DWORD *)(v10 + 4) - *(_DWORD *)v10;
          v10 += 32;
          --v11;
          v9 += 2 * (v12 >> 5);
        }
        while ( v11 );
      }
      v13 = malloc(4 * v9);
      if ( !v13 )
        goto LABEL_124;
      v14 = 0;
      if ( v8 )
      {
        v66 = (int *)(*((_DWORD *)v7 + 9) + 8);
        v69 = (char *)v8;
        do
        {
          if ( *((_BYTE *)v66 + 4) )
          {
            if ( (unsigned int)*v66 < *((_DWORD *)v7 + 7) )
              v15 = *v66 + *((_DWORD *)v7 + 13);
            else
              v15 = 0;
          }
          else
          {
            v15 = *v66;
          }
          v13[v14] = v15;
          v16 = v66;
          ++v14;
          if ( (v66[3] - v66[2]) >> 5 )
          {
            v17 = v66[2];
            v76 = (v66[3] - v66[2]) >> 5;
            do
            {
              if ( *(_BYTE *)(v17 + 12) )
              {
                v19 = *(_DWORD *)(v17 + 8);
                if ( v19 < *((_DWORD *)v7 + 7) )
                  v18 = v19 + *((_DWORD *)v7 + 13);
                else
                  v18 = 0;
              }
              else
              {
                v18 = *(_DWORD *)(v17 + 8);
              }
              v20 = *(_BYTE *)(v17 + 4) == 0;
              v13[v14] = v18;
              if ( v20 )
              {
                v21 = *(_DWORD *)v17;
              }
              else if ( *(_DWORD *)v17 < *((_DWORD *)v7 + 7) )
              {
                v21 = *(_DWORD *)v17 + *((_DWORD *)v7 + 13);
              }
              else
              {
                v21 = 0;
              }
              v13[v14 + 1] = v21;
              v14 += 2;
              v17 += 32;
              --v76;
            }
            while ( v76 );
            v16 = v66;
          }
          v20 = v69-- == (char *)1;
          v66 = v16 + 8;
        }
        while ( !v20 );
      }
      v22 = sub_100179D0((int)&v85, (int)v13, v14);
      free(v13);
      if ( !v22 )
LABEL_124:
        MessageBoxW(0, L"Out of memory while optimizing the string table!", L"ERROR", 0);
      v8 = v81;
    }
    v79 = 0;
    if ( v8 > 0 )
    {
      v67 = 0;
      v70 = a5 != 0;
      do
      {
        v23 = (int)v67 + *((_DWORD *)v7 + 9);
        v20 = *(_BYTE *)(v23 + 12) == 0;
        v82 = (char *)v67 + *((_DWORD *)v7 + 9);
        if ( v20 )
        {
          v24 = *(char **)(v23 + 8);
        }
        else
        {
          v25 = *(_DWORD *)(v23 + 8);
          if ( v25 < *((_DWORD *)v7 + 7) )
            v24 = (char *)(v25 + *((_DWORD *)v7 + 13));
          else
            v24 = 0;
        }
        *(_DWORD *)(v23 + 8) = sub_10017B50((int)&v85, v24, v70);
        *(_BYTE *)(v23 + 12) = 1;
        v77 = 0;
        if ( (*(_DWORD *)(v23 + 20) - *(_DWORD *)(v23 + 16)) >> 5 )
        {
          v73 = 0;
          do
          {
            v26 = (int)v73 + *((_DWORD *)v82 + 4);
            if ( *(_BYTE *)(v26 + 12) )
            {
              v28 = *(_DWORD *)(v26 + 8);
              if ( v28 < *((_DWORD *)v7 + 7) )
                v27 = (char *)(v28 + *((_DWORD *)v7 + 13));
              else
                v27 = 0;
            }
            else
            {
              v27 = *(char **)(v26 + 8);
            }
            v29 = sub_10017B50((int)&v85, v27, v70);
            v20 = *(_BYTE *)(v26 + 4) == 0;
            *(_DWORD *)(v26 + 8) = v29;
            *(_BYTE *)(v26 + 12) = 1;
            if ( v20 )
            {
              v30 = *(char **)v26;
            }
            else if ( *(_DWORD *)v26 < *((_DWORD *)v7 + 7) )
            {
              v30 = (char *)(*(_DWORD *)v26 + *((_DWORD *)v7 + 13));
            }
            else
            {
              v30 = 0;
            }
            v31 = sub_10017B50((int)&v85, v30, v70);
            v32 = (int)v82;
            v73 = (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32))((char *)v73 + 32);
            *(_DWORD *)v26 = v31;
            *(_BYTE *)(v26 + 4) = 1;
            ++v77;
          }
          while ( v77 < (*(_DWORD *)(v32 + 20) - *(_DWORD *)(v32 + 16)) >> 5 );
        }
        v67 = (char *)v67 + 32;
        ++v79;
      }
      while ( v79 < v81 );
    }
    if ( !*((_BYTE *)v7 + 1) && *((_DWORD *)v7 + 13) )
      free(*((void **)v7 + 13));
    v33 = v87;
    *((_DWORD *)v7 + 13) = v85;
    v34 = v88;
    *((_DWORD *)v7 + 7) = v33;
    *((_BYTE *)v7 + 1) = 0;
    if ( v34 )
      free(v34);
  }
  v90 = a4;
  if ( a6 > 2 )
    a6 = 0;
  v35 = *((_DWORD *)v7 + 10) - *((_DWORD *)v7 + 9);
  v79 = 0;
  v36 = v35 >> 5;
  if ( v36 )
  {
    v37 = *((_DWORD *)v7 + 9) + 16;
    while ( 1 )
    {
      v38 = 0;
      v39 = (*(_DWORD *)(v37 + 4) - *(_DWORD *)v37) >> 5;
      if ( v39 )
        break;
LABEL_66:
      v37 += 32;
      if ( ++v79 >= v36 )
        goto LABEL_67;
    }
    v40 = (_WORD *)(*(_DWORD *)v37 + 24);
    while ( *v40 == 1 )
    {
      ++v38;
      v40 += 16;
      if ( v38 >= v39 )
        goto LABEL_66;
    }
    *((_BYTE *)v7 + 8) = 3;
  }
  else
  {
LABEL_67:
    *((_BYTE *)v7 + 8) = (a6 != 0) + 1;
  }
  *((_BYTE *)v7 + 9) = a6;
  v89 = (ClassDatabaseFile *)((char *)v7 + 4);
  v43 = ClassDatabaseFileHeader::Write((ClassDatabaseFile *)((char *)v7 + 4), a2, a3, a4);
  v41 = HIDWORD(v43);
  v42 = v43;
  v83 = v43;
  v68 = (void *)a3;
  v74 = a2;
  if ( a6 )
  {
    v44 = malloc(0x10u);
    if ( v44 )
    {
      v42 = 0;
      *v44 = 0;
      v44[1] = 0;
      v44[2] = 0;
      *((_BYTE *)v44 + 12) = 1;
      v68 = v44;
      v74 = (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32))AssetsWriterToMemory;
      v41 = 0;
    }
    else
    {
      *((_BYTE *)v7 + 9) = 0;
      a6 = 0;
    }
  }
  ((void (__cdecl *)(unsigned int, unsigned int, signed int, _DWORD, unsigned int *, void *))v74)(
    v42,
    v41,
    4,
    0,
    &v81,
    v68);
  v45 = (__PAIR__(v41, v42) + 4) >> 32;
  v46 = v42 + 4;
  v79 = 0;
  if ( v81 )
  {
    v71 = 0;
    do
    {
      v47 = ClassDatabaseType::Write(
              (ClassDatabaseType *)((char *)v71 + *((_DWORD *)v7 + 9)),
              v74,
              (__int32)v68,
              __PAIR__(v45, v46),
              *((_BYTE *)v7 + 8));
      v71 = (char *)v71 + 32;
      v46 = v47;
      v45 = v48;
      ++v79;
    }
    while ( v79 < v81 );
  }
  *((_DWORD *)v7 + 8) = v46;
  if ( a7 )
  {
    v49 = *((_DWORD *)v7 + 7);
    if ( v49 )
      *(_BYTE *)(*((_DWORD *)v7 + 13) + v49 - 1) = 0;
  }
  ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, void *))v74)(
    *((_DWORD *)v7 + 8),
    0,
    *((_DWORD *)v7 + 7),
    0,
    *((_DWORD *)v7 + 13),
    v68);
  v50 = *((_DWORD *)v7 + 7) + __PAIR__(v45, v46);
  if ( a6 )
  {
    v51 = 0;
    v80 = 0;
  }
  else
  {
    v80 = HIDWORD(v83);
    v51 = v83;
  }
  *((_DWORD *)v7 + 4) = v50 - v51;
  if ( !a6 )
  {
    *((_DWORD *)v7 + 3) = v50 - v51;
LABEL_121:
    ClassDatabaseFileHeader::Write(v89, a2, a3, v90);
    return v83 + *((_DWORD *)v7 + 3);
  }
  v52 = v68;
  v53 = (void *)*((_DWORD *)v68 + 2);
  v54 = *(_DWORD *)v68;
  v78 = *(_DWORD *)v68;
  v72 = v53;
  if ( v53 )
  {
    v86 = 0;
    if ( v54 == v50 )
    {
      if ( a6 == 2 )
      {
        v55 = v54 / 3 + v54 + 133;
      }
      else if ( (unsigned int)v50 <= 0x7E000000 )
      {
        v55 = (signed int)v50 / 255 + v50 + 16;
      }
      else
      {
        v55 = 0;
      }
      v56 = (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32))malloc(v55);
      v75 = v56;
      if ( !v56 )
        goto LABEL_109;
      if ( a6 == 1 )
      {
        *((_DWORD *)v7 + 3) = sub_10022560(v55, (int)v56, (int)v72, v78);
        goto LABEL_103;
      }
      if ( a6 == 2 )
      {
        v82 = (char *)(v55 - 5);
        v79 = 5;
        v102 = 0;
        v93 = -1;
        v94 = -1;
        v101 = -1;
        v100 = -1;
        v98 = -1;
        v103 = 0;
        v91 = -1;
        v92 = 0;
        v95 = -1;
        v96 = -1;
        v97 = -1;
        v99 = -1;
        v104 = -1;
        v57 = off_100ADF8C(&off_100ADF8C, 283784);
        v58 = v57;
        if ( v57 )
        {
          sub_100271A0(v57);
          v59 = sub_10024B60(&v91, v58);
          if ( !v59 )
          {
            v59 = sub_100280A0(&v79, (int)v75, v58);
            if ( !v59 )
              v59 = sub_10028140(v78, (int)v72, (int *)&v82, v58, (int)v75 + 5);
          }
          sub_100272A0(v58);
          off_100ADF90(&off_100ADF8C, v58);
          if ( v79 == 5 && !v59 )
          {
            v60 = v84;
            *((_DWORD *)v84 + 3) = v82 + 5;
            v7 = v60;
            goto LABEL_103;
          }
          v7 = v84;
        }
      }
      *((_DWORD *)v7 + 3) = 0;
LABEL_103:
      if ( *((_DWORD *)v7 + 3) )
      {
        if ( *((_BYTE *)v68 + 12) && *((_DWORD *)v68 + 2) )
        {
          v61 = free;
          free(*((void **)v68 + 2));
        }
        else
        {
          v61 = free;
        }
        v61(v68);
        v62 = v75;
        ((void (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, const void *, __int32), __int32))a2)(
          v83,
          HIDWORD(v83),
          *((_DWORD *)v7 + 3),
          0,
          v75,
          a3);
LABEL_113:
        if ( v62 )
          v61(v62);
        goto LABEL_121;
      }
LABEL_109:
      v63 = v86;
      v64 = v83;
      *((_BYTE *)v7 + 9) = 0;
      ((void (__cdecl *)(_DWORD, _DWORD, signed int, int, void *, __int32))a2)(v64, HIDWORD(v64), v78, v63, v72, a3);
      if ( *((_BYTE *)v68 + 12) && *((_DWORD *)v68 + 2) )
        free(*((void **)v68 + 2));
      v61 = free;
      free(v68);
      v62 = v75;
      goto LABEL_113;
    }
    v52 = v68;
  }
  if ( v52[12] && v53 )
    free(v53);
  free(v68);
  return 0i64;
}
// 100ADF8C: using guessed type int (__cdecl *off_100ADF8C)(_DWORD, _DWORD);
// 100ADF90: using guessed type int (__cdecl *off_100ADF90)(_DWORD, _DWORD);

//----- (100184A0) --------------------------------------------------------
char __thiscall ClassDatabaseFile::InsertFrom(ClassDatabaseFile *this, struct ClassDatabaseFile *a2, struct ClassDatabaseType *a3)
{
  ClassDatabaseFile *v3; // edi@1
  char result; // al@2
  int v5; // eax@3
  int v6; // ecx@3
  signed int v7; // eax@3
  int v8; // edi@3
  unsigned int v9; // ebx@3
  char *v10; // eax@4
  unsigned int v11; // ecx@5
  _DWORD *v12; // edi@8
  int v13; // ebx@8
  int v14; // eax@9
  int v15; // esi@11
  bool v16; // zf@11
  char **v17; // eax@11
  char *v18; // eax@12
  char *v19; // eax@17
  unsigned int v20; // ecx@18
  int v21; // edx@21
  int v22; // edx@22
  int i; // [sp+10h] [bp-34h]@9
  int v24; // [sp+14h] [bp-30h]@8
  int v25; // [sp+18h] [bp-2Ch]@8
  int v26; // [sp+1Ch] [bp-28h]@16
  ClassDatabaseFile *v27; // [sp+20h] [bp-24h]@1
  int v28; // [sp+24h] [bp-20h]@3
  int v29; // [sp+28h] [bp-1Ch]@3
  int v30; // [sp+2Ch] [bp-18h]@3
  void *v31; // [sp+30h] [bp-14h]@3
  int v32; // [sp+40h] [bp-4h]@3

  v3 = this;
  v27 = this;
  if ( *((_BYTE *)this + 1) )
  {
    result = 0;
  }
  else
  {
    v5 = *((_DWORD *)this + 7);
    v6 = *((_DWORD *)this + 13);
    v29 = v5;
    v30 = v5;
    v28 = v6;
    v31 = 0;
    v32 = 0;
    v7 = *((_DWORD *)v3 + 10) - *((_DWORD *)v3 + 9);
    v8 = (int)v3 + 36;
    sub_10019E60((v7 >> 5) + 1, v8);
    v9 = ((*(_DWORD *)(v8 + 4) - *(_DWORD *)v8) & 0xFFFFFFE0) + *(_DWORD *)v8 - 32;
    *(_DWORD *)(v9 + 4) = *((_DWORD *)a3 + 1);
    *(_DWORD *)v9 = *(_DWORD *)a3;
    if ( *((_BYTE *)a3 + 12) )
    {
      v11 = *((_DWORD *)a3 + 2);
      if ( v11 < *((_DWORD *)a2 + 7) )
        v10 = (char *)(v11 + *((_DWORD *)a2 + 13));
      else
        v10 = 0;
    }
    else
    {
      v10 = (char *)*((_DWORD *)a3 + 2);
    }
    *(_DWORD *)(v9 + 8) = sub_10017B50((int)&v28, v10, 1);
    *(_BYTE *)(v9 + 12) = 1;
    v12 = (_DWORD *)(v9 + 16);
    v25 = v9 + 16;
    sub_10019CD0((*((_DWORD *)a3 + 5) - *((_DWORD *)a3 + 4)) >> 5, v9 + 16);
    v13 = *((_DWORD *)a3 + 4);
    v24 = 0;
    if ( (*((_DWORD *)a3 + 5) - v13) >> 5 )
    {
      v14 = 0;
      for ( i = 0; ; v14 = i )
      {
        v15 = v14 + *v12;
        v16 = *(_BYTE *)(v14 + v13 + 12) == 0;
        v17 = (char **)(v14 + v13 + 8);
        if ( v16 )
          v18 = *v17;
        else
          v18 = (unsigned int)*v17 < *((_DWORD *)a2 + 7) ? &(*v17)[*((_DWORD *)a2 + 13)] : 0;
        v26 = sub_10017B50((int)&v28, v18, 1);
        if ( *(_BYTE *)(i + v13 + 4) )
        {
          v20 = *(_DWORD *)(i + v13);
          v19 = (char *)(v20 < *((_DWORD *)a2 + 7) ? v20 + *((_DWORD *)a2 + 13) : 0);
        }
        else
        {
          v19 = *(char **)(i + v13);
        }
        *(_DWORD *)v15 = sub_10017B50((int)&v28, v19, 1);
        *(_DWORD *)(v15 + 8) = v26;
        *(_BYTE *)(v15 + 4) = 1;
        *(_BYTE *)(v15 + 12) = 1;
        *(_BYTE *)(v15 + 16) = *(_BYTE *)(i + v13 + 16);
        *(_BYTE *)(v15 + 17) = *(_BYTE *)(i + v13 + 17);
        *(_DWORD *)(v15 + 20) = *(_DWORD *)(i + v13 + 20);
        *(_WORD *)(v15 + 24) = *(_WORD *)(i + v13 + 24);
        v21 = *(_DWORD *)(i + v13 + 28);
        i += 32;
        *(_DWORD *)(v15 + 28) = v21;
        v13 = *((_DWORD *)a3 + 4);
        if ( ++v24 >= (unsigned int)((*((_DWORD *)a3 + 5) - v13) >> 5) )
          break;
        v12 = (_DWORD *)v25;
      }
    }
    v22 = v30;
    *((_DWORD *)v27 + 13) = v28;
    *((_DWORD *)v27 + 7) = v22;
    if ( v31 )
      free(v31);
    result = 1;
  }
  return result;
}

//----- (100186B0) --------------------------------------------------------
ClassDatabaseFile *__thiscall ClassDatabaseFile::ClassDatabaseFile(ClassDatabaseFile *this)
{
  ClassDatabaseFile *result; // eax@1

  result = this;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 11) = 0;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 7) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 13) = 0;
  *(_WORD *)this = 0;
  return result;
}

//----- (10018980) --------------------------------------------------------
void __thiscall ClassDatabaseFile::Clear(ClassDatabaseFile *this)
{
  ClassDatabaseFile *v1; // esi@1
  int v2; // eax@6
  _DWORD *v3; // ecx@6
  _DWORD *v4; // edi@7

  v1 = this;
  if ( *((_DWORD *)this + 6) )
  {
    free(*((void **)this + 6));
    *((_DWORD *)v1 + 6) = 0;
    *((_BYTE *)v1 + 20) = 0;
  }
  if ( !*((_BYTE *)v1 + 1) && *((_DWORD *)v1 + 13) )
  {
    free(*((void **)v1 + 13));
    *((_DWORD *)v1 + 13) = 0;
    *((_DWORD *)v1 + 7) = 0;
  }
  v2 = *((_DWORD *)v1 + 10);
  v3 = (_DWORD *)*((_DWORD *)v1 + 9);
  if ( v3 != (_DWORD *)v2 )
  {
    v4 = sub_1001A1E0(v2, v3, v2);
    sub_1001A230((int)v4, *((_DWORD *)v1 + 10));
    *((_DWORD *)v1 + 10) = v4;
  }
}

//----- (100189F0) --------------------------------------------------------
void __thiscall ClassDatabaseFile::~ClassDatabaseFile(ClassDatabaseFile *this)
{
  ClassDatabaseFile *v1; // esi@1
  int v2; // eax@1

  v1 = this;
  ClassDatabaseFile::Clear(this);
  v2 = *((_DWORD *)v1 + 9);
  if ( v2 )
  {
    sub_1001A230(v2, *((_DWORD *)v1 + 10));
    operator delete(*((void **)v1 + 9));
  }
  *((_DWORD *)v1 + 9) = 0;
  *((_DWORD *)v1 + 10) = 0;
  *((_DWORD *)v1 + 11) = 0;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10018A60) --------------------------------------------------------
unsigned __int64 __thiscall ClassDatabasePackageHeader::Read(ClassDatabasePackageHeader *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3, unsigned __int64 a4)
{
  ClassDatabasePackageHeader *v4; // edi@1
  int v5; // edx@1
  int v6; // edx@4
  int v7; // edx@6
  int v8; // edx@9
  int v9; // edx@11
  int v10; // edx@13
  int v11; // edx@15
  int v12; // ecx@17
  int v13; // eax@17
  int v14; // edi@17
  int v15; // edx@20
  int v16; // edx@22
  int v17; // edx@24
  unsigned int *v19; // [sp+Ch] [bp-24h]@15
  int v20; // [sp+10h] [bp-20h]@19
  char v21; // [sp+14h] [bp-1Ch]@20
  char v22; // [sp+18h] [bp-18h]@22
  char v23; // [sp+1Ch] [bp-14h]@24
  char v24; // [sp+2Bh] [bp-5h]@26
  unsigned __int64 v25; // [sp+40h] [bp+10h]@17

  v4 = this;
  if ( ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, ClassDatabasePackageHeader *, __int32))a2)(
         a4,
         HIDWORD(a4),
         4,
         0,
         this,
         a3) == 4
    && !v5
    && *(_DWORD *)v4 == 1263553603
    && ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, _DWORD))a2)(-1, -1, 1, 0, (char *)v4 + 4, a3) == 1
    && !v6
    && ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, _DWORD))a2)(-1, -1, 1, 0, (char *)v4 + 5, a3) == 1
    && !v7
    && *((_BYTE *)v4 + 4) <= 0u
    && ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(-1, -1, 4, 0, (char *)v4 + 8, a3) == 4
    && !v8
    && ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(-1, -1, 4, 0, (char *)v4 + 12, a3) == 4
    && !v9
    && ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(-1, -1, 4, 0, (char *)v4 + 16, a3) == 4
    && !v10 )
  {
    v19 = (unsigned int *)((char *)v4 + 20);
    if ( ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(-1, -1, 4, 0, (char *)v4 + 20, a3) == 4
      && !v11 )
    {
      v12 = *((_DWORD *)v4 + 7);
      v13 = *((_DWORD *)v4 + 6);
      v25 = a4 + 22;
      v14 = (int)v4 + 24;
      if ( v13 != v12 )
        *(_DWORD *)(v14 + 4) = sub_1001A0B0(v13, v12, v12);
      sub_1000AB70((void *)v14, *v19);
      v20 = 0;
      if ( !*v19 )
        return v25;
      while ( ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))a2)(-1, -1, 4, 0, &v21, a3) == 4
           && !v15
           && ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))a2)(-1, -1, 4, 0, &v22, a3) == 4
           && !v16
           && ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))a2)(
                -1,
                -1,
                15,
                0,
                &v23,
                a3) == 15
           && !v17 )
      {
        v24 = 0;
        v25 += 23i64;
        sub_1000A750((unsigned int)&v21, v14);
        if ( ++v20 >= *v19 )
          return v25;
      }
    }
  }
  return 0i64;
}

//----- (10018C70) --------------------------------------------------------
unsigned __int64 __thiscall ClassDatabasePackageHeader::Write(ClassDatabasePackageHeader *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 a4)
{
  ClassDatabasePackageHeader *v4; // esi@1
  int v5; // edx@1
  int v7; // edx@4
  int v8; // edx@6
  int v9; // edx@9
  int v10; // edx@11
  int v11; // edx@13
  int v12; // edx@15
  int v13; // esi@20
  int v14; // edx@20
  int v15; // edx@22
  int v16; // edx@24
  int v17; // [sp+Ch] [bp-Ch]@18
  int v18; // [sp+10h] [bp-8h]@17
  ClassDatabasePackageHeader *v19; // [sp+14h] [bp-4h]@1
  unsigned __int64 v20; // [sp+28h] [bp+10h]@17

  v4 = this;
  v19 = this;
  if ( ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, const char *, __int32))a2)(
         a4,
         HIDWORD(a4),
         4,
         0,
         "CLPK",
         a3) != 4
    || v5
    || ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))a2)(
         -1,
         -1,
         1,
         0,
         (char *)v4 + 4,
         a3) != 1
    || v7
    || ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, char *, __int32))a2)(
         -1,
         -1,
         1,
         0,
         (char *)v4 + 5,
         a3) != 1
    || v8
    || *((_BYTE *)v4 + 4) > 0u
    || ((int (__cdecl *)(_DWORD, _DWORD, signed int, _DWORD, char *, _DWORD))a2)(-1, -1, 4, 0, (char *)v4 + 8, a3) != 4
    || v9
    || ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(-1, -1, 4, 0, (char *)v4 + 12, a3) != 4
    || v10
    || ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(-1, -1, 4, 0, (char *)v4 + 16, a3) != 4
    || v11
    || ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, char *, _DWORD))a2)(-1, -1, 4, 0, (char *)v4 + 20, a3) != 4
    || v12 )
  {
    return 0i64;
  }
  v18 = 0;
  v20 = a4 + 22;
  if ( *((_DWORD *)v4 + 5) > 0u )
  {
    v17 = 0;
    while ( 1 )
    {
      v13 = v17 + *((_DWORD *)v4 + 6);
      if ( ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int, __int32))a2)(-1, -1, 4, 0, v13, a3) != 4
        || v14
        || ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, int, _DWORD))a2)(-1, -1, 4, 0, v13 + 4, a3) != 4
        || v15
        || ((int (__cdecl *)(signed int, signed int, signed int, _DWORD, int, __int32))a2)(-1, -1, 15, 0, v13 + 8, a3) != 15
        || v16 )
      {
        break;
      }
      v20 += 23i64;
      v17 += 24;
      if ( (unsigned int)++v18 >= *((_DWORD *)v19 + 5) )
        return v20;
      v4 = v19;
    }
    return 0i64;
  }
  return v20;
}

//----- (10018E20) --------------------------------------------------------
void __thiscall ClassDatabasePackage::Clear(ClassDatabasePackage *this)
{
  ClassDatabasePackage *v1; // edi@1
  unsigned int v2; // ecx@2
  int v3; // eax@3
  bool v4; // zf@3
  int *v5; // eax@3
  int v6; // esi@4
  int v7; // eax@5
  unsigned int i; // [sp+14h] [bp-10h]@2

  v1 = this;
  if ( *((_DWORD *)this + 11) )
  {
    v2 = 0;
    for ( i = 0; v2 < *((_DWORD *)v1 + 6); i = v2 )
    {
      v3 = *((_DWORD *)v1 + 11);
      v4 = *(_DWORD *)(v3 + 4 * v2) == 0;
      v5 = (int *)(v3 + 4 * v2);
      if ( !v4 )
      {
        v6 = *v5;
        if ( *v5 )
        {
          ClassDatabaseFile::Clear((ClassDatabaseFile *)v6);
          v7 = *(_DWORD *)(v6 + 36);
          if ( v7 )
          {
            sub_1001A230(v7, *(_DWORD *)(v6 + 40));
            operator delete(*(void **)(v6 + 36));
          }
          *(_DWORD *)(v6 + 36) = 0;
          *(_DWORD *)(v6 + 40) = 0;
          *(_DWORD *)(v6 + 44) = 0;
          operator delete((void *)v6);
          v2 = i;
        }
      }
      ++v2;
    }
    operator delete[](*((void **)v1 + 11));
    *((_DWORD *)v1 + 11) = 0;
  }
  if ( *((_DWORD *)v1 + 12) )
  {
    free(*((void **)v1 + 12));
    *((_DWORD *)v1 + 12) = 0;
  }
}
// 10099190: using guessed type void __cdecl operator delete[](void *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10018F00) --------------------------------------------------------
ClassDatabaseFile *__stdcall sub_10018F00(ClassDatabaseFile *a1)
{
  int v1; // eax@1

  ClassDatabaseFile::Clear(a1);
  v1 = *((_DWORD *)a1 + 9);
  if ( v1 )
  {
    sub_1001A230(v1, *((_DWORD *)a1 + 10));
    operator delete(*((void **)a1 + 9));
  }
  *((_DWORD *)a1 + 9) = 0;
  *((_DWORD *)a1 + 10) = 0;
  *((_DWORD *)a1 + 11) = 0;
  operator delete((void *)a1);
  return a1;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10018F80) --------------------------------------------------------
char __thiscall ClassDatabasePackage::Read(ClassDatabasePackage *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3)
{
  ClassDatabasePackage *v3; // esi@1
  void *v5; // eax@3
  size_t v6; // ST14_4@3
  _DWORD *v7; // eax@5
  int v8; // eax@8
  int v9; // edi@8
  _DWORD *v10; // eax@8
  unsigned __int64 (__cdecl *v11)(unsigned __int64, unsigned __int64, void *, __int32); // ecx@9
  int v12; // edi@12
  _BYTE *v13; // ebx@12
  int v14; // ecx@13
  int v15; // edi@16
  void *v16; // eax@16
  int v17; // edi@20
  unsigned int v18; // ebx@21
  int v19; // edx@21
  char v20; // al@23
  char *v21; // eax@25
  int v22; // eax@28
  unsigned int v23; // eax@32
  int v24; // edx@33
  void *v25; // [sp+Ch] [bp-14h]@8
  int v26; // [sp+10h] [bp-10h]@3
  char *v27; // [sp+14h] [bp-Ch]@4
  int v28; // [sp+18h] [bp-8h]@8

  v3 = this;
  ClassDatabasePackage::Clear(this);
  *(_BYTE *)v3 = 0;
  if ( !ClassDatabasePackageHeader::Read((ClassDatabasePackage *)((char *)v3 + 4), a2, a3, 0i64) )
    goto LABEL_2;
  v5 = (void *)unknown_libname_4(4 * *((_DWORD *)v3 + 6) | -((unsigned __int64)*((_DWORD *)v3 + 6) >> 30 != 0));
  v6 = 4 * *((_DWORD *)v3 + 6);
  *((_DWORD *)v3 + 11) = v5;
  memset(v5, 0, v6);
  v26 = 0;
  if ( *((_DWORD *)v3 + 6) > 0u )
  {
    v27 = 0;
    do
    {
      v7 = operator new(0x38u);
      if ( v7 )
      {
        v7[9] = 0;
        v7[10] = 0;
        v7[11] = 0;
        v7[1] = 0;
        v7[2] = 0;
        v7[3] = 0;
        v7[4] = 0;
        v7[5] = 0;
        v7[6] = 0;
        v7[7] = 0;
        v7[8] = 0;
        v7[13] = 0;
        *(_WORD *)v7 = 0;
      }
      else
      {
        v7 = 0;
      }
      *(_DWORD *)(*((_DWORD *)v3 + 11) + 4 * v26) = v7;
      v8 = *((_DWORD *)v3 + 7);
      v9 = *(_DWORD *)&v27[v8];
      v25 = (void *)a3;
      v28 = *(_DWORD *)&v27[v8 + 4];
      v10 = malloc(0x20u);
      if ( v10 )
      {
        v10[6] = a2;
        v10[2] = v28;
        v10[3] = 0;
        v10[7] = a3;
        v10[4] = v9;
        v10[5] = 0;
        *v10 = v9;
        v10[1] = 0;
        v25 = v10;
        v11 = (unsigned __int64 (__cdecl *)(unsigned __int64, unsigned __int64, void *, __int32))PartialAssetsFileReader;
      }
      else
      {
        v10 = v25;
        v11 = 0;
      }
      if ( !v10 )
        goto LABEL_2;
      v12 = v26;
      v13 = *(_BYTE **)(*((_DWORD *)v3 + 11) + 4 * v26);
      ClassDatabaseFile::Read(*(ClassDatabaseFile **)(*((_DWORD *)v3 + 11) + 4 * v26), v11, v10, 0i64);
      if ( !*v13 )
        goto LABEL_2;
      v14 = *(_DWORD *)(*((_DWORD *)v3 + 11) + 4 * v26);
      if ( *(_DWORD *)(v14 + 52) )
      {
        free(*(void **)(v14 + 52));
        *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v3 + 11) + 4 * v26) + 52) = 0;
      }
      free(v25);
      v27 += 24;
      v26 = v12 + 1;
    }
    while ( (unsigned int)(v12 + 1) < *((_DWORD *)v3 + 6) );
  }
  v15 = *((_DWORD *)v3 + 4);
  v16 = malloc(*((_DWORD *)v3 + 4));
  *((_DWORD *)v3 + 12) = v16;
  if ( !v16 )
    goto LABEL_2;
  if ( *((_BYTE *)v3 + 9) )
    v16 = malloc(*((_DWORD *)v3 + 5));
  else
    *((_DWORD *)v3 + 5) = v15;
  v17 = (int)v16;
  if ( !v16 )
    goto LABEL_2;
  v18 = *((_DWORD *)v3 + 5);
  if ( ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, void *, __int32))a2)(
         *((_DWORD *)v3 + 3),
         0,
         *((_DWORD *)v3 + 5),
         0,
         v16,
         a3) != v18
    || v19 )
  {
    goto LABEL_2;
  }
  v20 = *((_BYTE *)v3 + 9);
  if ( v20 )
  {
    v27 = 0;
    if ( v20 == 1 )
    {
      v21 = sub_100225A0(*((_DWORD *)v3 + 4), (_BYTE *)v17, *((void **)v3 + 12), v18);
    }
    else
    {
      if ( v20 != 2
        || v18 <= 5
        || (v22 = *((_DWORD *)v3 + 12),
            v26 = *((_DWORD *)v3 + 4),
            v25 = (void *)(v18 - 5),
            sub_100248F0(&v28, (void *)(v17 + 5), &v26, v22, (unsigned int *)&v25, v17)) )
      {
LABEL_31:
        free((void *)v17);
        if ( v27 == *((char **)v3 + 4) )
          goto LABEL_32;
LABEL_2:
        ClassDatabasePackage::Clear(v3);
        return 0;
      }
      v21 = (char *)v26;
    }
    v27 = v21;
    goto LABEL_31;
  }
LABEL_32:
  v23 = 0;
  if ( *((_DWORD *)v3 + 6) )
  {
    do
    {
      *(_BYTE *)(*(_DWORD *)(*((_DWORD *)v3 + 11) + 4 * v23) + 1) = 1;
      *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v3 + 11) + 4 * v23) + 52) = *((_DWORD *)v3 + 12);
      v24 = *(_DWORD *)(*((_DWORD *)v3 + 11) + 4 * v23++);
      *(_DWORD *)(v24 + 28) = *((_DWORD *)v3 + 4);
    }
    while ( v23 < *((_DWORD *)v3 + 6) );
  }
  *(_BYTE *)v3 = 1;
  return 1;
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);

//----- (10019240) --------------------------------------------------------
int __thiscall ClassDatabasePackage::Write(ClassDatabasePackage *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a3, unsigned __int64 a4, int a5, unsigned __int32 a6)
{
  int v6; // edi@1
  char v7; // al@2
  unsigned int v8; // ebx@5
  int v9; // edx@6
  int v10; // esi@7
  unsigned int v11; // edx@7
  int v12; // eax@8
  unsigned int v13; // ecx@8
  int v14; // eax@8
  int v15; // esi@9
  _DWORD *v16; // esi@11
  unsigned int v17; // edx@12
  int v18; // edi@14
  int v19; // ecx@14
  int v20; // ebx@15
  int v21; // eax@17
  signed int v22; // ecx@21
  signed int v23; // ecx@21
  int v24; // eax@22
  int v25; // ecx@24
  unsigned int v26; // esi@25
  bool v27; // zf@28
  int v28; // ecx@29
  char v29; // bl@36
  int v30; // eax@40
  signed int v31; // ecx@40
  int v32; // eax@42
  int v33; // esi@42
  char *v34; // eax@43
  unsigned int v35; // ecx@44
  signed int v36; // eax@47
  int v37; // ebx@48
  int v38; // eax@49
  int v39; // ecx@49
  _DWORD *v40; // ST34_4@54
  char *v41; // eax@50
  unsigned int v42; // ecx@51
  int v43; // eax@54
  char **v44; // ecx@54
  int v45; // eax@54
  char *v46; // eax@55
  char *v47; // ecx@56
  int v48; // eax@59
  unsigned int v49; // ecx@59
  int v50; // eax@60
  unsigned int v51; // edx@60
  unsigned int v52; // ebx@62
  int v53; // eax@64
  unsigned __int64 v54; // rax@64
  signed int v55; // edi@64
  int v56; // eax@66
  int v57; // edx@67
  unsigned int v58; // ebx@70
  int v59; // edx@70
  int v60; // esi@72
  void *v61; // eax@76
  int v62; // eax@80
  int v63; // esi@80
  signed int v64; // ebx@81
  __int32 v65; // esi@92
  unsigned __int64 (__cdecl *v66)(unsigned __int64, unsigned __int64, const void *, __int32); // ebx@94
  unsigned int v67; // ST0C_4@96
  int v68; // esi@97
  int v70; // [sp-14h] [bp-A0h]@92
  unsigned int v71; // [sp-10h] [bp-9Ch]@92
  int v72; // [sp-8h] [bp-94h]@92
  __int32 v73; // [sp-4h] [bp-90h]@92
  ClassDatabasePackage *v74; // [sp+10h] [bp-7Ch]@1
  ClassDatabasePackageHeader *v75; // [sp+14h] [bp-78h]@15
  ClassDatabasePackageHeader *v76; // [sp+14h] [bp-78h]@39
  ClassDatabasePackageHeader *v77; // [sp+14h] [bp-78h]@64
  char *v78; // [sp+18h] [bp-74h]@13
  _DWORD *v79; // [sp+18h] [bp-74h]@54
  void *v80; // [sp+18h] [bp-74h]@76
  signed int v81; // [sp+1Ch] [bp-70h]@22
  bool v82; // [sp+1Ch] [bp-70h]@41
  int v83; // [sp+1Ch] [bp-70h]@71
  _DWORD *v84; // [sp+20h] [bp-6Ch]@11
  int v85; // [sp+20h] [bp-6Ch]@41
  int v86; // [sp+20h] [bp-6Ch]@65
  int v87; // [sp+20h] [bp-6Ch]@70
  unsigned int v88; // [sp+24h] [bp-68h]@6
  unsigned int v89; // [sp+28h] [bp-64h]@6
  unsigned __int64 v90; // [sp+2Ch] [bp-60h]@64
  int v91; // [sp+34h] [bp-58h]@4
  int v92; // [sp+38h] [bp-54h]@4
  int v93; // [sp+3Ch] [bp-50h]@4
  void *v94; // [sp+40h] [bp-4Ch]@4
  int v95; // [sp+44h] [bp-48h]@80
  int v96; // [sp+48h] [bp-44h]@80
  int v97; // [sp+4Ch] [bp-40h]@80
  int v98; // [sp+50h] [bp-3Ch]@80
  int v99; // [sp+54h] [bp-38h]@80
  int v100; // [sp+58h] [bp-34h]@80
  int v101; // [sp+5Ch] [bp-30h]@80
  int v102; // [sp+60h] [bp-2Ch]@80
  int v103; // [sp+64h] [bp-28h]@80
  int v104; // [sp+68h] [bp-24h]@80
  int v105; // [sp+6Ch] [bp-20h]@80
  int v106; // [sp+70h] [bp-1Ch]@80
  int v107; // [sp+74h] [bp-18h]@80
  int v108; // [sp+78h] [bp-14h]@80
  int v109; // [sp+88h] [bp-4h]@4
  __int64 v110; // [sp+9Ch] [bp+10h]@64

  v74 = this;
  v6 = 0;
  if ( a6 <= 2 )
    v7 = a6;
  else
    v7 = 0;
  *((_BYTE *)this + 9) = v7;
  v91 = 0;
  v92 = 0;
  v93 = 0;
  v94 = 0;
  v109 = 0;
  if ( a5 == 2 )
  {
    v8 = 0;
    if ( *((_DWORD *)this + 6) > 0u )
    {
      v9 = *((_DWORD *)this + 6);
      v89 = *((_DWORD *)this + 11);
      v88 = v9;
      do
      {
        v10 = *(_DWORD *)(v89 + 4 * v8);
        v11 = 0;
        if ( (*(_DWORD *)(v10 + 40) - *(_DWORD *)(v10 + 36)) >> 5 )
        {
          v12 = *(_DWORD *)(*((_DWORD *)v74 + 11) + 4 * v8);
          v13 = (*(_DWORD *)(v12 + 40) - *(_DWORD *)(v12 + 36)) >> 5;
          v14 = *(_DWORD *)(v10 + 36) + 16;
          do
          {
            ++v11;
            v15 = (*(_DWORD *)(v14 + 4) - *(_DWORD *)v14) >> 5;
            v14 += 32;
            v6 += 2 * v15 + 1;
          }
          while ( v11 < v13 );
        }
        ++v8;
      }
      while ( v8 < v88 );
    }
    v16 = malloc(4 * v6);
    v84 = v16;
    if ( !v16 )
      goto LABEL_102;
    v17 = 0;
    if ( *((_DWORD *)v74 + 6) )
    {
      v78 = (char *)*((_DWORD *)v74 + 11);
      v88 = *((_DWORD *)v74 + 6);
      do
      {
        v18 = *(_DWORD *)v78;
        v19 = *(_DWORD *)(*(_DWORD *)v78 + 36);
        if ( (*(_DWORD *)(*(_DWORD *)v78 + 40) - v19) >> 5 )
        {
          v20 = v19 + 8;
          v75 = (ClassDatabasePackageHeader *)((*(_DWORD *)(*(_DWORD *)v78 + 40) - v19) >> 5);
          do
          {
            if ( *(_BYTE *)(v20 + 4) )
            {
              if ( *(_DWORD *)v20 < *(_DWORD *)(v18 + 28) )
                v21 = *(_DWORD *)v20 + *(_DWORD *)(v18 + 52);
              else
                v21 = 0;
            }
            else
            {
              v21 = *(_DWORD *)v20;
            }
            v22 = *(_DWORD *)(v20 + 12) - *(_DWORD *)(v20 + 8);
            v16[v17] = v21;
            v23 = v22 >> 5;
            ++v17;
            if ( v23 )
            {
              v24 = *(_DWORD *)(v20 + 8);
              v81 = v23;
              do
              {
                if ( *(_BYTE *)(v24 + 12) )
                {
                  v26 = *(_DWORD *)(v24 + 8);
                  if ( v26 < *(_DWORD *)(v18 + 28) )
                    v25 = v26 + *(_DWORD *)(v18 + 52);
                  else
                    v25 = 0;
                }
                else
                {
                  v25 = *(_DWORD *)(v24 + 8);
                }
                v27 = *(_BYTE *)(v24 + 4) == 0;
                v84[v17] = v25;
                if ( v27 )
                {
                  v28 = *(_DWORD *)v24;
                }
                else if ( *(_DWORD *)v24 < *(_DWORD *)(v18 + 28) )
                {
                  v28 = *(_DWORD *)v24 + *(_DWORD *)(v18 + 52);
                }
                else
                {
                  v28 = 0;
                }
                v16 = v84;
                v84[v17 + 1] = v28;
                v17 += 2;
                v24 += 32;
                --v81;
              }
              while ( v81 );
            }
            v20 += 32;
            v75 = (ClassDatabasePackageHeader *)((char *)v75 - 1);
          }
          while ( v75 );
        }
        v78 += 4;
        --v88;
      }
      while ( v88 );
    }
    v29 = sub_100179D0((int)&v91, (int)v16, v17);
    free(v16);
    if ( !v29 )
LABEL_102:
      MessageBoxW(0, L"Out of memory while optimizing the string table!", L"ERROR", 0);
    this = v74;
  }
  v76 = 0;
  if ( *((_DWORD *)this + 6) > 0u )
  {
    do
    {
      v30 = *(_DWORD *)(*((_DWORD *)v74 + 11) + 4 * (_DWORD)v76);
      v31 = *(_DWORD *)(v30 + 40) - *(_DWORD *)(v30 + 36);
      v89 = 0;
      if ( v31 >> 5 )
      {
        v85 = 0;
        v82 = a5 != 0;
        do
        {
          v32 = *(_DWORD *)(*((_DWORD *)v74 + 11) + 4 * (_DWORD)v76);
          v33 = v85 + *(_DWORD *)(v32 + 36);
          if ( *(_BYTE *)(v33 + 12) )
          {
            v35 = *(_DWORD *)(v33 + 8);
            if ( v35 < *(_DWORD *)(v32 + 28) )
              v34 = (char *)(v35 + *(_DWORD *)(v32 + 52));
            else
              v34 = 0;
          }
          else
          {
            v34 = *(char **)(v33 + 8);
          }
          *(_DWORD *)(v33 + 8) = sub_10017B50((int)&v91, v34, v82);
          *(_BYTE *)(v33 + 12) = 1;
          v36 = *(_DWORD *)(v33 + 20) - *(_DWORD *)(v33 + 16);
          v88 = 0;
          if ( v36 >> 5 )
          {
            v37 = 0;
            do
            {
              v38 = *(_DWORD *)(*((_DWORD *)v74 + 11) + 4 * (_DWORD)v76);
              v39 = v37 + *(_DWORD *)(v33 + 16);
              if ( *(_BYTE *)(v39 + 12) )
              {
                v42 = *(_DWORD *)(v39 + 8);
                if ( v42 < *(_DWORD *)(v38 + 28) )
                  v41 = (char *)(v42 + *(_DWORD *)(v38 + 52));
                else
                  v41 = 0;
              }
              else
              {
                v41 = *(char **)(v39 + 8);
              }
              v40 = (_DWORD *)(v37 + *(_DWORD *)(v33 + 16));
              v40[2] = sub_10017B50((int)&v91, v41, v82);
              *(_BYTE *)(v37 + *(_DWORD *)(v33 + 16) + 12) = 1;
              v43 = *(_DWORD *)(v33 + 16);
              v27 = *(_BYTE *)(v37 + v43 + 4) == 0;
              v44 = (char **)(v37 + v43);
              v45 = *(_DWORD *)(*((_DWORD *)v74 + 11) + 4 * (_DWORD)v76);
              v79 = v44;
              if ( v27 )
              {
                v46 = *v44;
              }
              else
              {
                v47 = *v44;
                if ( *v79 < *(_DWORD *)(v45 + 28) )
                  v46 = &v47[*(_DWORD *)(v45 + 52)];
                else
                  v46 = 0;
              }
              *v79 = sub_10017B50((int)&v91, v46, v82);
              v48 = v88;
              *(_BYTE *)(v37 + *(_DWORD *)(v33 + 16) + 4) = 1;
              v49 = (*(_DWORD *)(v33 + 20) - *(_DWORD *)(v33 + 16)) >> 5;
              v37 += 32;
              v88 = v48 + 1;
            }
            while ( v48 + 1 < v49 );
          }
          v50 = *(_DWORD *)(*((_DWORD *)v74 + 11) + 4 * (_DWORD)v76);
          v85 += 32;
          v51 = (*(_DWORD *)(v50 + 40) - *(_DWORD *)(v50 + 36)) >> 5;
          ++v89;
        }
        while ( v89 < v51 );
      }
      v76 = (ClassDatabasePackageHeader *)((char *)v76 + 1);
    }
    while ( (unsigned int)v76 < *((_DWORD *)v74 + 6) );
  }
  v52 = 0;
  if ( *((_DWORD *)v74 + 12) )
  {
    free(*((void **)v74 + 12));
    *((_DWORD *)v74 + 12) = 0;
  }
  v53 = v93;
  *((_DWORD *)v74 + 12) = v91;
  *((_DWORD *)v74 + 4) = v53;
  v90 = a4;
  v77 = (ClassDatabasePackage *)((char *)v74 + 4);
  v54 = ClassDatabasePackageHeader::Write((ClassDatabasePackage *)((char *)v74 + 4), a2, a3, a4);
  v55 = v54;
  v110 = v54;
  if ( *((_DWORD *)v74 + 6) > 0u )
  {
    v86 = 0;
    do
    {
      v56 = *(_DWORD *)(*((_DWORD *)v74 + 11) + 4 * v52);
      if ( !*(_BYTE *)(v56 + 1) )
      {
        *(_BYTE *)(v56 + 1) = 1;
        v57 = *((_DWORD *)v74 + 11);
        if ( *(_DWORD *)(*(_DWORD *)(v57 + 4 * v52) + 52) )
          free(*(void **)(*(_DWORD *)(v57 + 4 * v52) + 52));
      }
      *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v74 + 11) + 4 * v52) + 52) = *((_DWORD *)v74 + 12);
      *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v74 + 11) + 4 * v52) + 28) = 0;
      *(_DWORD *)(v86 + *((_DWORD *)v74 + 7)) = v55;
      v110 = ClassDatabaseFile::Write(
               (ClassDatabaseFile *)*(_DWORD *)(*((_DWORD *)v74 + 11) + 4 * v52),
               a2,
               a3,
               __PAIR__(HIDWORD(v110), v55),
               0,
               a6,
               0);
      v55 = v110;
      ++v52;
      *(_DWORD *)(*((_DWORD *)v74 + 7) + v86 + 4) = v110 - *(_DWORD *)(*((_DWORD *)v74 + 7) + v86);
      *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v74 + 11) + 4 * v52 - 4) + 28) = *((_DWORD *)v74 + 4);
      v86 += 24;
    }
    while ( v52 < *((_DWORD *)v74 + 6) );
  }
  v58 = *((_DWORD *)v74 + 4);
  v59 = *((_DWORD *)v74 + 12);
  *(_DWORD *)v77 = 1263553603;
  *((_DWORD *)v74 + 3) = v55;
  *((_BYTE *)v74 + 8) = 0;
  v87 = v58;
  *((_DWORD *)v74 + 5) = v58;
  if ( !a6 )
  {
    v65 = a3;
    v67 = v58;
    v66 = a2;
    ((void (__cdecl *)(signed int, _DWORD, unsigned int, _DWORD, int, __int32))a2)(v55, HIDWORD(v110), v67, 0, v59, a3);
    goto LABEL_97;
  }
  v83 = v59;
  if ( a6 == 2 )
  {
    v60 = v58 / 3 + v58 + 133;
  }
  else if ( (unsigned int)v55 <= 0x7E000000 )
  {
    v60 = v55 / 255 + v55 + 16;
  }
  else
  {
    v60 = 0;
  }
  v61 = malloc(v60);
  v80 = v61;
  if ( !v61 )
    goto LABEL_93;
  if ( a6 == 1 )
  {
    *((_DWORD *)v74 + 5) = sub_10022560(v60, (int)v61, v83, v58);
    goto LABEL_91;
  }
  if ( a6 == 2 )
  {
    v88 = v60 - 5;
    v89 = 5;
    v106 = 0;
    v97 = -1;
    v98 = -1;
    v105 = -1;
    v104 = -1;
    v102 = -1;
    v107 = 0;
    v95 = -1;
    v96 = 0;
    v99 = -1;
    v100 = -1;
    v101 = -1;
    v103 = -1;
    v108 = -1;
    v62 = off_100ADF8C(&off_100ADF8C, 283784);
    v63 = v62;
    if ( v62 )
    {
      sub_100271A0(v62);
      v64 = sub_10024B60(&v95, v63);
      if ( !v64 )
      {
        v64 = sub_100280A0(&v89, (int)v80, v63);
        if ( !v64 )
          v64 = sub_10028140(v87, v83, (int *)&v88, v63, (int)v80 + 5);
        v55 = v110;
      }
      sub_100272A0(v63);
      off_100ADF90(&off_100ADF8C, v63);
      if ( v89 == 5 && !v64 )
      {
        v58 = v87;
        *((_DWORD *)v74 + 5) = v88 + 5;
        goto LABEL_91;
      }
      v58 = v87;
    }
    *((_DWORD *)v74 + 5) = 0;
  }
  else
  {
    *((_DWORD *)v74 + 5) = 0;
  }
LABEL_91:
  if ( *((_DWORD *)v74 + 5) )
  {
    v65 = a3;
    v73 = a3;
    v72 = (int)v80;
    v71 = *((_DWORD *)v74 + 5);
    v70 = HIDWORD(v110);
    goto LABEL_94;
  }
LABEL_93:
  v65 = a3;
  v73 = a3;
  v72 = v83;
  *((_DWORD *)v74 + 5) = *((_DWORD *)v74 + 4);
  *((_BYTE *)v74 + 9) = 0;
  v71 = v58;
  v70 = HIDWORD(v110);
LABEL_94:
  v66 = a2;
  ((void (__cdecl *)(signed int, int, unsigned int, _DWORD, int, __int32))a2)(v55, v70, v71, 0, v72, v73);
  if ( v80 )
    free(v80);
LABEL_97:
  ClassDatabasePackageHeader::Write(v77, v66, v65, v90);
  v68 = v55 + *((_DWORD *)v74 + 5);
  if ( v94 )
    free(v94);
  return v68;
}
// 100ADF8C: using guessed type int (__cdecl *off_100ADF8C)(_DWORD, _DWORD);
// 100ADF90: using guessed type int (__cdecl *off_100ADF90)(_DWORD, _DWORD);

//----- (10019970) --------------------------------------------------------
char __thiscall ClassDatabasePackage::RemoveFile(ClassDatabasePackage *this, unsigned __int32 a2)
{
  unsigned __int32 v2; // ebx@1
  ClassDatabasePackage *v3; // esi@1
  char result; // al@2
  void *v5; // eax@4
  int v6; // edi@4
  const void *v7; // ST10_4@4
  int v8; // edx@4
  unsigned __int32 v9; // ebx@4
  ClassDatabaseFile *v10; // edi@4

  v2 = a2;
  v3 = this;
  if ( a2 < *((_DWORD *)this + 6) && *((_DWORD *)this + 11) )
  {
    sub_10019EF0(&a2, (int)this + 28, *((_DWORD *)this + 7) + 24 * a2);
    v5 = (void *)unknown_libname_4(4 * (*((_DWORD *)v3 + 6) - 1) | -((unsigned __int64)(unsigned int)(*((_DWORD *)v3 + 6) - 1) >> 30 != 0));
    v6 = 4 * v2;
    v7 = (const void *)*((_DWORD *)v3 + 11);
    a2 = (unsigned __int32)v5;
    memcpy(v5, v7, 4 * v2);
    v8 = *((_DWORD *)v3 + 6) - v2;
    v9 = a2;
    memcpy((void *)(v6 + a2), (const void *)(v6 + *((_DWORD *)v3 + 11) + 4), 4 * v8 - 4);
    v10 = *(ClassDatabaseFile **)(v6 + *((_DWORD *)v3 + 11));
    if ( v10 )
      sub_10018F00(v10);
    operator delete[](*((void **)v3 + 11));
    --*((_DWORD *)v3 + 6);
    *((_DWORD *)v3 + 11) = v9;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 10099190: using guessed type void __cdecl operator delete[](void *);

//----- (10019A30) --------------------------------------------------------
char __thiscall ClassDatabasePackage::ImportFile(ClassDatabasePackage *this, unsigned __int64 (__cdecl *a2)(unsigned __int64, unsigned __int64, void *, __int32), __int32 a3)
{
  ClassDatabasePackage *v3; // esi@1
  void *v4; // edi@1
  ClassDatabaseFile *v5; // eax@1
  ClassDatabaseFile *v6; // ebx@2
  char result; // al@5
  int v8; // [sp+14h] [bp-1Ch]@6
  int v9; // [sp+18h] [bp-18h]@6
  int v10; // [sp+1Ch] [bp-14h]@6
  int v11; // [sp+20h] [bp-10h]@6
  int v12; // [sp+24h] [bp-Ch]@6
  int v13; // [sp+28h] [bp-8h]@6

  v3 = this;
  v4 = (void *)unknown_libname_4(4 * (*((_DWORD *)this + 6) + 1) | -((unsigned __int64)(unsigned int)(*((_DWORD *)this + 6) + 1) >> 30 != 0));
  memcpy(v4, *((const void **)v3 + 11), 4 * *((_DWORD *)v3 + 6));
  v5 = (ClassDatabaseFile *)operator new(0x38u);
  if ( v5 )
  {
    *((_DWORD *)v5 + 9) = 0;
    *((_DWORD *)v5 + 10) = 0;
    *((_DWORD *)v5 + 11) = 0;
    *((_DWORD *)v5 + 1) = 0;
    *((_DWORD *)v5 + 2) = 0;
    *((_DWORD *)v5 + 3) = 0;
    *((_DWORD *)v5 + 4) = 0;
    *((_DWORD *)v5 + 5) = 0;
    *((_DWORD *)v5 + 6) = 0;
    *((_DWORD *)v5 + 7) = 0;
    *((_DWORD *)v5 + 8) = 0;
    *((_DWORD *)v5 + 13) = 0;
    *(_WORD *)v5 = 0;
    v6 = v5;
  }
  else
  {
    v6 = 0;
  }
  ClassDatabaseFile::Read(v6, a2, (void *)a3, 0i64);
  if ( *(_BYTE *)v6 )
  {
    *((_DWORD *)v4 + *((_DWORD *)v3 + 6)) = v6;
    operator delete[](*((void **)v3 + 11));
    *((_DWORD *)v3 + 11) = v4;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    sub_1000A750((unsigned int)&v8, (int)v3 + 28);
    ++*((_DWORD *)v3 + 6);
    result = 1;
  }
  else
  {
    sub_10018F00(v6);
    operator delete[](v4);
    result = 0;
  }
  return result;
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099190: using guessed type void __cdecl operator delete[](void *);

//----- (10019B50) --------------------------------------------------------
void *__thiscall ClassDatabasePackage::ClassDatabasePackage(void *this)
{
  void *v1; // esi@1

  v1 = this;
  *((_DWORD *)this + 7) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 9) = 0;
  memset(this, 0, 0x34u);
  return v1;
}

//----- (10019BA0) --------------------------------------------------------
void __thiscall ClassDatabasePackage::~ClassDatabasePackage(ClassDatabasePackage *this)
{
  ClassDatabasePackage *v1; // esi@1

  v1 = this;
  ClassDatabasePackage::Clear(this);
  if ( *((_DWORD *)v1 + 7) )
    operator delete(*((void **)v1 + 7));
  *((_DWORD *)v1 + 7) = 0;
  *((_DWORD *)v1 + 8) = 0;
  *((_DWORD *)v1 + 9) = 0;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10019C00) --------------------------------------------------------
unsigned int __fastcall sub_10019C00(unsigned int a1, int a2)
{
  unsigned int v2; // edi@1
  int v3; // esi@1
  unsigned int result; // eax@3
  char *v5; // eax@4
  const void *v6; // ebx@4
  const void *v7; // edx@4
  int v8; // ebx@4
  unsigned int v9; // ebx@6
  int v10; // [sp+0h] [bp-24h]@1
  char *v11; // [sp+10h] [bp-14h]@4
  int *v12; // [sp+14h] [bp-10h]@1
  int v13; // [sp+20h] [bp-4h]@4

  v12 = &v10;
  v2 = a1;
  v3 = a2;
  if ( a1 > 0x7FFFFFF )
    std::_Xlength_error("vector<T> too long");
  result = (*(_DWORD *)(v3 + 8) - *(_DWORD *)v3) >> 5;
  if ( result < v2 )
  {
    v5 = (char *)sub_10019FF0(a1);
    v13 = 0;
    v6 = *(const void **)(v3 + 4);
    v7 = *(const void **)v3;
    v11 = v5;
    sub_1001A4A0(v5, v7, v6);
    v8 = *(_DWORD *)(v3 + 4) - *(_DWORD *)v3;
    if ( *(_DWORD *)v3 )
      operator delete(*(void **)v3);
    result = (unsigned int)v11;
    v9 = (unsigned int)&v11[v8 & 0xFFFFFFE0];
    *(_DWORD *)(v3 + 8) = &v11[32 * v2];
    *(_DWORD *)(v3 + 4) = v9;
    *(_DWORD *)v3 = result;
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10019CAA) --------------------------------------------------------
void __usercall __noreturn sub_10019CAA(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 20));
  CxxThrowException(0, 0);
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10019CD0) --------------------------------------------------------
_DWORD *__usercall sub_10019CD0@<eax>(unsigned int a1@<eax>, int a2@<edi>)
{
  unsigned int v2; // esi@1
  _DWORD *result; // eax@1
  int v4; // [sp+4h] [bp-4h]@2

  v2 = a1;
  result = (_DWORD *)((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 5);
  if ( (unsigned int)result <= v2 )
  {
    if ( (unsigned int)result < v2 )
    {
      sub_10019F90(v2 - (_DWORD)result, a2);
      sub_1001A0F0(v2 - ((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 5), *(char **)(a2 + 4));
      result = *(_DWORD **)(a2 + 4);
      *(_DWORD *)(a2 + 4) = &result[8 * (v2 - ((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 5))];
    }
  }
  else
  {
    result = sub_10019F40(a2, &v4, (void *)(*(_DWORD *)a2 + 32 * v2), *(const void **)(a2 + 4));
  }
  return result;
}

//----- (10019D40) --------------------------------------------------------
void __usercall sub_10019D40(int a1@<esi>)
{
  if ( *(_DWORD *)a1 )
  {
    sub_1001A230(*(_DWORD *)a1, *(_DWORD *)(a1 + 4));
    operator delete(*(void **)a1);
  }
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10019D80) --------------------------------------------------------
unsigned int __thiscall sub_10019D80(void *this, unsigned int a2)
{
  void *v2; // esi@1
  unsigned int v3; // ebx@1
  unsigned int result; // eax@3
  char *v5; // eax@4
  int v6; // ecx@4
  int v7; // ST00_4@4
  int v8; // edi@4
  unsigned int v9; // edi@6
  int v10; // [sp+0h] [bp-24h]@1
  char *v11; // [sp+10h] [bp-14h]@4
  int *v12; // [sp+14h] [bp-10h]@1
  int v13; // [sp+20h] [bp-4h]@4

  v12 = &v10;
  v2 = this;
  v3 = a2;
  if ( a2 > 0x7FFFFFF )
    std::_Xlength_error("vector<T> too long");
  result = (*((_DWORD *)v2 + 2) - *(_DWORD *)v2) >> 5;
  if ( result < a2 )
  {
    v5 = (char *)sub_10019FF0(a2);
    v13 = 0;
    v6 = *(_DWORD *)v2;
    v7 = *((_DWORD *)v2 + 1);
    v11 = v5;
    sub_1001A3C0(v7, (int)v5);
    v8 = *((_DWORD *)v2 + 1) - *(_DWORD *)v2;
    if ( *(_DWORD *)v2 )
    {
      sub_1001A230(*(_DWORD *)v2, *((_DWORD *)v2 + 1));
      operator delete(*(void **)v2);
      v3 = a2;
    }
    result = (unsigned int)v11;
    v9 = (unsigned int)&v11[v8 & 0xFFFFFFE0];
    *((_DWORD *)v2 + 2) = &v11[32 * v3];
    *((_DWORD *)v2 + 1) = v9;
    *(_DWORD *)v2 = result;
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10019E46) --------------------------------------------------------
void __usercall __noreturn sub_10019E46(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 20));
  CxxThrowException(0, 0);
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10019E60) --------------------------------------------------------
int __usercall sub_10019E60@<eax>(unsigned int a1@<eax>, int a2@<edi>)
{
  unsigned int v2; // esi@1
  int result; // eax@1
  unsigned int v4; // ecx@1
  _DWORD *v5; // ecx@2
  _DWORD *v6; // esi@3
  int v7; // edx@5

  v2 = a1;
  result = *(_DWORD *)(a2 + 4);
  v4 = (*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 5;
  if ( v4 <= v2 )
  {
    if ( v4 < v2 )
    {
      sub_1001A050(a2, v2 - v4);
      v7 = *(_DWORD *)(a2 + 4) - *(_DWORD *)a2;
      sub_1001A120(*(_DWORD *)(a2 + 4));
      result = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a2 + 4) = result + 32 * (v2 - ((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 5));
    }
  }
  else
  {
    v5 = (_DWORD *)(*(_DWORD *)a2 + 32 * v2);
    if ( v5 != (_DWORD *)result )
    {
      v6 = sub_1001A1E0(result, v5, result);
      result = sub_1001A230((int)v6, *(_DWORD *)(a2 + 4));
      *(_DWORD *)(a2 + 4) = v6;
    }
  }
  return result;
}

//----- (10019EF0) --------------------------------------------------------
_DWORD *__userpurge sub_10019EF0@<eax>(_DWORD *result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // esi@1
  int v5; // ecx@1

  v3 = a3;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = a3 + 24;
  if ( a3 + 24 != v4 )
  {
    do
    {
      *(_DWORD *)v3 = *(_DWORD *)v5;
      *(_DWORD *)(v3 + 4) = *(_DWORD *)(v5 + 4);
      *(_DWORD *)(v3 + 8) = *(_DWORD *)(v5 + 8);
      *(_DWORD *)(v3 + 12) = *(_DWORD *)(v5 + 12);
      *(_DWORD *)(v3 + 16) = *(_DWORD *)(v5 + 16);
      *(_DWORD *)(v3 + 20) = *(_DWORD *)(v5 + 20);
      v5 += 24;
      v3 += 24;
    }
    while ( v5 != v4 );
    v3 = a3;
  }
  *(_DWORD *)(a2 + 4) -= 24;
  *result = v3;
  return result;
}

//----- (10019F40) --------------------------------------------------------
_DWORD *__stdcall sub_10019F40(int a1, _DWORD *a2, void *a3, const void *a4)
{
  const void *v4; // edx@1
  void *v5; // ebx@1
  void *v6; // ecx@1
  const void *v7; // eax@2
  const void *v8; // esi@3
  void *v9; // edi@3
  _DWORD *result; // eax@6

  v4 = a4;
  v5 = a3;
  v6 = a3;
  if ( a3 != a4 )
  {
    v7 = *(const void **)(a1 + 4);
    if ( a4 != v7 )
    {
      do
      {
        v8 = v4;
        v9 = v5;
        v4 = (char *)v4 + 32;
        v5 = (char *)v5 + 32;
        qmemcpy(v9, v8, 0x20u);
      }
      while ( v4 != v7 );
      v6 = a3;
    }
    *(_DWORD *)(a1 + 4) = v5;
  }
  result = a2;
  *a2 = v6;
  return result;
}

//----- (10019F90) --------------------------------------------------------
unsigned int __fastcall sub_10019F90(int a1, int a2)
{
  int v2; // esi@1
  unsigned int v3; // eax@1
  unsigned int result; // eax@3
  unsigned int v5; // ecx@3
  unsigned int v6; // ecx@5

  v2 = *(_DWORD *)a2;
  v3 = (*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 5;
  if ( 0x7FFFFFF - a1 < v3 )
    std::_Xlength_error("vector<T> too long");
  result = a1 + v3;
  v5 = (*(_DWORD *)(a2 + 8) - v2) >> 5;
  if ( result > v5 )
  {
    if ( 0x7FFFFFF - (v5 >> 1) >= v5 )
      v6 = (v5 >> 1) + v5;
    else
      v6 = 0;
    if ( v6 < result )
      v6 = result;
    result = sub_10019C00(v6, a2);
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);

//----- (10019FF0) --------------------------------------------------------
void *__fastcall sub_10019FF0(unsigned int a1)
{
  void *result; // eax@1
  int (__stdcall **v2)(char); // [sp+0h] [bp-10h]@4
  int v3; // [sp+Ch] [bp-4h]@4

  result = 0;
  if ( a1 )
  {
    if ( a1 > 0x7FFFFFF || (result = operator new(32 * a1)) == 0 )
    {
      v3 = 0;
      std::exception::exception((std::exception *)&v2, (const char *const *)&v3);
      v2 = &off_10099840;
      CxxThrowException(&v2, &unk_100A5EA0);
    }
  }
  return result;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (1001A050) --------------------------------------------------------
unsigned int __fastcall sub_1001A050(int a1, int a2)
{
  int v2; // esi@1
  unsigned int v3; // eax@1
  unsigned int result; // eax@3
  unsigned int v5; // edx@3
  unsigned int v6; // edx@5

  v2 = *(_DWORD *)a1;
  v3 = (*(_DWORD *)(a1 + 4) - *(_DWORD *)a1) >> 5;
  if ( 0x7FFFFFF - a2 < v3 )
    std::_Xlength_error("vector<T> too long");
  result = a2 + v3;
  v5 = (*(_DWORD *)(a1 + 8) - v2) >> 5;
  if ( result > v5 )
  {
    if ( 0x7FFFFFF - (v5 >> 1) >= v5 )
      v6 = (v5 >> 1) + v5;
    else
      v6 = 0;
    if ( v6 < result )
      v6 = result;
    result = sub_10019D80((void *)a1, v6);
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);

//----- (1001A0B0) --------------------------------------------------------
int __usercall sub_1001A0B0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  for ( ; a3 != a2; result += 24 )
  {
    *(_DWORD *)result = *(_DWORD *)a3;
    *(_DWORD *)(result + 4) = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(result + 8) = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(result + 12) = *(_DWORD *)(a3 + 12);
    *(_DWORD *)(result + 16) = *(_DWORD *)(a3 + 16);
    *(_DWORD *)(result + 20) = *(_DWORD *)(a3 + 20);
    a3 += 24;
  }
  return result;
}

//----- (1001A0F0) --------------------------------------------------------
int __usercall sub_1001A0F0@<eax>(int result@<eax>, char *a2@<edx>)
{
  char v2; // [sp+8h] [bp-24h]@3

  for ( ; result; --result )
  {
    if ( a2 )
      qmemcpy(a2, &v2, 0x20u);
    a2 += 32;
  }
  return result;
}

//----- (1001A120) --------------------------------------------------------
void __cdecl sub_1001A120(int a1)
{
  unsigned int v1; // ecx@0
  unsigned int v2; // edi@1
  int v3; // esi@1
  int v4; // [sp+0h] [bp-58h]@1
  int v5; // [sp+24h] [bp-34h]@3
  int v6; // [sp+28h] [bp-30h]@3
  void *v7; // [sp+34h] [bp-24h]@3
  int v8; // [sp+38h] [bp-20h]@3
  int v9; // [sp+3Ch] [bp-1Ch]@3
  int v10; // [sp+44h] [bp-14h]@1
  int *v11; // [sp+48h] [bp-10h]@1
  int v12; // [sp+54h] [bp-4h]@1

  v11 = &v4;
  v2 = v1;
  v3 = a1;
  v10 = a1;
  v12 = 0;
  while ( v2 > 0 )
  {
    v6 = -1;
    v5 = -1;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    LOBYTE(v12) = 1;
    sub_10019C00(1u, (int)&v7);
    LOBYTE(v12) = 4;
    if ( v3 )
      ((void (__thiscall *)(int, int *))ClassDatabaseType::ClassDatabaseType)(v3, &v5);
    LOBYTE(v12) = 0;
    if ( v7 )
      operator delete(v7);
    --v2;
    v3 += 32;
  }
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1001A1E0) --------------------------------------------------------
_DWORD *__usercall sub_1001A1E0@<eax>(int a1@<eax>, _DWORD *a2@<ecx>, int a3)
{
  _DWORD *v3; // ebx@1
  int v4; // edi@2
  int v5; // esi@2

  v3 = a2;
  if ( a1 != a3 )
  {
    v4 = (int)(a2 + 2);
    v5 = a1 + 8;
    do
    {
      *v3 = *(_DWORD *)(v5 - 8);
      *(_DWORD *)(v4 - 4) = *(_DWORD *)(v5 - 4);
      *(_DWORD *)v4 = *(_DWORD *)v5;
      *(_DWORD *)(v4 + 4) = *(_DWORD *)(v5 + 4);
      sub_1001A270(v4 + 8, v5 + 8);
      v5 += 32;
      v3 += 8;
      v4 += 32;
    }
    while ( v5 - 8 != a3 );
  }
  return v3;
}

//----- (1001A230) --------------------------------------------------------
int __usercall sub_1001A230@<eax>(int result@<eax>, int a2@<ebx>)
{
  int v2; // esi@2

  if ( result != a2 )
  {
    v2 = result + 16;
    do
    {
      if ( *(_DWORD *)v2 )
        operator delete(*(void **)v2);
      *(_DWORD *)v2 = 0;
      *(_DWORD *)(v2 + 4) = 0;
      *(_DWORD *)(v2 + 8) = 0;
      v2 += 32;
      result = v2 - 16;
    }
    while ( v2 - 16 != a2 );
  }
  return result;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1001A270) --------------------------------------------------------
int __stdcall sub_1001A270(int a1, int a2)
{
  int v2; // esi@1
  int v3; // edi@1
  const void *v4; // edx@2
  unsigned int v5; // ebx@2
  void *v6; // ebx@3
  void *v12; // eax@8
  unsigned int v13; // ecx@8
  void *v14; // ebx@9
  const void *v15; // eax@9
  const void *v16; // esi@10
  void *v17; // edi@10
  void *v18; // eax@14
  const void *v19; // edx@14
  const void *v21; // [sp+10h] [bp+8h]@14

  v2 = a2;
  v3 = a1;
  if ( a1 == a2 )
    return v3;
  v4 = *(const void **)(a2 + 4);
  v5 = ((signed int)v4 - *(_DWORD *)a2) >> 5;
  if ( !v5 )
  {
    v6 = *(void **)a1;
    if ( *(_DWORD *)a1 != *(_DWORD *)(a1 + 4) )
    {
      *(_DWORD *)(v3 + 4) = v6;
      return v3;
    }
    return v3;
  }
  v12 = *(void **)a1;
  v13 = (*(_DWORD *)(a1 + 4) - *(_DWORD *)a1) >> 5;
  if ( v5 > v13 )
  {
    if ( v5 > (*(_DWORD *)(a1 + 8) - (signed int)v12) >> 5 )
    {
      if ( v12 )
        operator delete(*(void **)a1);
      if ( !sub_1001A380((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 5, a1) )
        return v3;
      v18 = *(void **)a1;
      v19 = *(const void **)a2;
    }
    else
    {
      v21 = (const void *)(*(_DWORD *)a2 + 32 * v13);
      sub_1001A480(v12, *(const void **)a2, v21);
      v18 = *(void **)(v3 + 4);
      v19 = v21;
    }
    *(_DWORD *)(v3 + 4) = sub_1001A4A0(v18, v19, *(const void **)(a2 + 4));
    return v3;
  }
  v14 = *(void **)a1;
  v15 = *(const void **)a2;
  if ( *(const void **)a2 != v4 )
  {
    do
    {
      v16 = v15;
      v17 = v14;
      v15 = (char *)v15 + 32;
      v14 = (char *)v14 + 32;
      qmemcpy(v17, v16, 0x20u);
    }
    while ( v15 != v4 );
    v2 = a2;
    v3 = a1;
  }
  *(_DWORD *)(v3 + 4) = *(_DWORD *)v3 + ((*(_DWORD *)(v2 + 4) - *(_DWORD *)v2) & 0xFFFFFFE0);
  return v3;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1001A380) --------------------------------------------------------
char __usercall sub_1001A380@<al>(unsigned int a1@<eax>, int a2@<edi>)
{
  unsigned int v2; // esi@1
  char result; // al@2
  char *v4; // eax@5

  v2 = a1;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  if ( a1 )
  {
    if ( a1 > 0x7FFFFFF )
      std::_Xlength_error("vector<T> too long");
    v4 = (char *)sub_10019FF0(v2);
    *(_DWORD *)a2 = v4;
    *(_DWORD *)(a2 + 4) = v4;
    *(_DWORD *)(a2 + 8) = &v4[32 * v2];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);

//----- (1001A3C0) --------------------------------------------------------
int __cdecl sub_1001A3C0(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // esi@1
  int v4; // edi@1
  int v6; // [sp+0h] [bp-24h]@1
  int v7; // [sp+10h] [bp-14h]@1
  int *v8; // [sp+14h] [bp-10h]@1
  int v9; // [sp+20h] [bp-4h]@1

  v8 = &v6;
  v3 = a2;
  v4 = v2;
  v7 = a2;
  v9 = 0;
  while ( v4 != a1 )
  {
    LOBYTE(v9) = 1;
    if ( v3 )
      ((void (__thiscall *)(int, int))ClassDatabaseType::ClassDatabaseType)(v3, v4);
    v3 += 32;
    LOBYTE(v9) = 0;
    v4 += 32;
  }
  return v3;
}

//----- (1001A450) --------------------------------------------------------
void __usercall sub_1001A450(int a1@<esi>)
{
  if ( *(_DWORD *)(a1 + 16) )
    operator delete(*(void **)(a1 + 16));
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1001A480) --------------------------------------------------------
void *__usercall sub_1001A480@<eax>(void *result@<eax>, const void *a2@<edx>, const void *a3@<ebx>)
{
  const void *v3; // esi@2
  void *v4; // edi@2

  while ( a2 != a3 )
  {
    v3 = a2;
    v4 = result;
    a2 = (char *)a2 + 32;
    result = (char *)result + 32;
    qmemcpy(v4, v3, 0x20u);
  }
  return result;
}

//----- (1001A4A0) --------------------------------------------------------
void *__usercall sub_1001A4A0@<eax>(void *result@<eax>, const void *a2@<edx>, const void *a3@<ebx>)
{
  for ( ; a2 != a3; result = (char *)result + 32 )
  {
    if ( result )
      qmemcpy(result, a2, 0x20u);
    a2 = (char *)a2 + 32;
  }
  return result;
}

//----- (1001A4D0) --------------------------------------------------------
unsigned __int32 __cdecl TestTexToolWrap()
{
  HMODULE v0; // eax@1
  HMODULE v1; // edi@1
  int (*v2)(void); // eax@2
  FARPROC v3; // esi@6
  HMODULE v4; // ebx@10
  UINT uMode; // [sp+Ch] [bp-4h]@3

  v0 = LoadLibraryW(L"kernel32.dll");
  v1 = v0;
  if ( v0 && (v2 = (int (*)(void))GetProcAddress(v0, "GetErrorMode")) != 0 )
    uMode = v2();
  else
    uMode = 0;
  if ( v1 )
  {
    v3 = GetProcAddress(v1, "SetThreadErrorMode");
    if ( v3 )
    {
      ((void (__stdcall *)(signed int, UINT *))v3)(32771, &uMode);
      goto LABEL_10;
    }
  }
  else
  {
    v3 = 0;
  }
  SetErrorMode(0x8003u);
LABEL_10:
  v4 = LoadLibraryW(L"TexToolWrap.dll");
  GetLastError();
  if ( v3 )
    ((void (__stdcall *)(UINT, _DWORD))v3)(uMode, 0);
  else
    SetErrorMode(uMode);
  FreeLibrary(v1);
  if ( !v4 )
    MessageBoxW(
      0,
      L"Unable to load the PVR tex lib, texture formats for mobile Unity builds aren't supported without it.\n"
       "This may be fixed by installing the Visual C++ 2013 redistributable.",
      L"Warning",
      0);
  return 0;
}

//----- (1001A590) --------------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  if ( !fdwReason )
    Sleep(0);
  return 1;
}

//----- (1001A5B0) --------------------------------------------------------
char __thiscall ResourceManagerFile::Write(ResourceManagerFile *this, void *a2, int a3, int *a4)
{
  ResourceManagerFile *v4; // ebx@1
  int v6; // esi@3
  char *v7; // edi@5
  const char **v8; // edx@7
  size_t v9; // eax@8
  int v10; // ecx@8
  int v11; // esi@9
  int v12; // eax@10
  unsigned int v13; // esi@13
  int v14; // esi@14
  int v15; // eax@14
  size_t v16; // eax@14
  int v17; // esi@17
  int v18; // eax@19
  int v19; // esi@20
  int v20; // ecx@20
  size_t v21; // ecx@20
  int v22; // esi@21
  _DWORD *v23; // ecx@22
  int v24; // edx@22
  int v25; // esi@26
  int v26; // eax@26
  size_t v27; // eax@26
  int v28; // [sp+4h] [bp-Ch]@17
  int v29; // [sp+8h] [bp-8h]@7
  int v30; // [sp+8h] [bp-8h]@22
  int v31; // [sp+Ch] [bp-4h]@5
  int v32; // [sp+Ch] [bp-4h]@18
  void *v33; // [sp+18h] [bp+8h]@6
  _DWORD *v34; // [sp+18h] [bp+8h]@19

  v4 = this;
  if ( !*((_BYTE *)this + 1) )
    return 0;
  v6 = 4;
  if ( a3 < 4 )
    return 0;
  v7 = (char *)a2;
  *(_DWORD *)a2 = *((_DWORD *)this + 2);
  v31 = 0;
  if ( *((_DWORD *)this + 2) > 0 )
  {
    v33 = 0;
    do
    {
      v8 = (const char **)((char *)v33 + *((_DWORD *)v4 + 3));
      v29 = (int)v33 + *((_DWORD *)v4 + 3);
      if ( *v8 )
      {
        v9 = strlen(*v8);
        v10 = v6 + 4;
        if ( v6 + 4 > a3 )
          return 0;
        *(_DWORD *)&v7[v6] = v9;
        v11 = v9 + v10;
        if ( (signed int)(v9 + v10) > a3 )
          return 0;
        memcpy(&v7[v10], *v8, v9);
        v12 = v11;
      }
      else
      {
        v12 = v6 + 4;
        if ( v6 + 4 > a3 )
          return 0;
        *(_DWORD *)&v7[v6] = 0;
      }
      v13 = (v12 + 3) & 0xFFFFFFFC;
      memset(&v7[v12], 0, v13 - v12);
      if ( (signed int)(v13 + 4) > a3 )
        return 0;
      *(_DWORD *)&v7[v13] = *(_DWORD *)(v29 + 8);
      v14 = v13 + 4;
      v15 = *((_DWORD *)v4 + 1) < 14;
      LOBYTE(v15) = *((_DWORD *)v4 + 1) >= 14;
      v16 = 4 * v15 + 4;
      if ( (signed int)(v16 + v14) > a3 )
        return 0;
      memcpy(&v7[v14], (const void *)(v29 + 16), v16);
      v33 = (char *)v33 + 24;
      ++v31;
      v6 = 4 * (*((_DWORD *)v4 + 1) >= 14) + 4 + v14;
    }
    while ( v31 < *((_DWORD *)v4 + 2) );
  }
  if ( v6 + 4 <= a3 )
  {
    *(_DWORD *)&v7[v6] = *((_DWORD *)v4 + 4);
    v17 = v6 + 4;
    v28 = 0;
    if ( *((_DWORD *)v4 + 4) <= 0 )
    {
LABEL_29:
      *a4 = v17;
      return 1;
    }
    v32 = 0;
    while ( 1 )
    {
      v18 = v32 + *((_DWORD *)v4 + 5);
      v34 = (_DWORD *)(v32 + *((_DWORD *)v4 + 5));
      if ( v17 + 4 > a3 )
        break;
      *(_DWORD *)&v7[v17] = *(_DWORD *)v18;
      v19 = v17 + 4;
      v20 = *((_DWORD *)v4 + 1) < 14;
      LOBYTE(v20) = *((_DWORD *)v4 + 1) >= 14;
      v21 = 4 * v20 + 4;
      if ( (signed int)(v21 + v19) > a3 )
        break;
      memcpy(&v7[v19], (const void *)(v18 + 8), v21);
      v22 = 4 * (*((_DWORD *)v4 + 1) >= 14) + 4 + v19;
      if ( v22 + 4 > a3 )
        break;
      v23 = v34;
      v24 = v34[4];
      *(_DWORD *)&v7[v22] = v24;
      v17 = v22 + 4;
      v30 = 0;
      if ( v24 > 0 )
      {
        while ( v17 + 4 <= a3 )
        {
          *(_DWORD *)&v7[v17] = *v23;
          v25 = v17 + 4;
          v26 = *((_DWORD *)v4 + 1) < 14;
          LOBYTE(v26) = *((_DWORD *)v4 + 1) >= 14;
          v27 = 4 * v26 + 4;
          if ( (signed int)(v27 + v25) > a3 )
            break;
          memcpy(&v7[v25], v23 + 2, v27);
          ++v30;
          v17 = 4 * (*((_DWORD *)v4 + 1) >= 14) + 4 + v25;
          if ( v30 >= v34[4] )
            goto LABEL_28;
          v23 = v34;
        }
        return 0;
      }
LABEL_28:
      v32 += 24;
      if ( ++v28 >= *((_DWORD *)v4 + 4) )
        goto LABEL_29;
    }
  }
  return 0;
}

//----- (1001A810) --------------------------------------------------------
int __thiscall ResourceManagerFile::GetFileSize(ResourceManagerFile *this)
{
  int result; // eax@2
  signed int v2; // esi@3
  const char **v3; // ebx@5
  signed int v4; // edx@10
  int v5; // eax@10
  int v6; // esi@10
  int v7; // esi@11
  _DWORD *v8; // eax@11
  unsigned int v9; // edx@11
  int v10; // edx@14
  int v11; // [sp+0h] [bp-10h]@10
  int v12; // [sp+4h] [bp-Ch]@11
  int v13; // [sp+8h] [bp-8h]@5
  int v14; // [sp+8h] [bp-8h]@10
  int v15; // [sp+Ch] [bp-4h]@10

  if ( *((_BYTE *)this + 1) )
  {
    v2 = 4;
    if ( *((_DWORD *)this + 3) )
    {
      if ( *((_DWORD *)this + 2) > 0 )
      {
        v3 = (const char **)*((_DWORD *)this + 3);
        v13 = *((_DWORD *)this + 2);
        do
        {
          if ( *v3 )
            v2 += (strlen(*v3) + 3) & 0xFFFFFFFC;
          v3 += 6;
          --v13;
        }
        while ( v13 );
      }
      v2 += *((_DWORD *)this + 2) * (4 * (*((_DWORD *)this + 1) >= 14) + 12);
    }
    v4 = *((_DWORD *)this + 4);
    v5 = 0;
    v6 = v2 + 4;
    v14 = 0;
    v15 = 0;
    v11 = v6;
    if ( v4 >= 2 )
    {
      LOBYTE(v5) = *((_DWORD *)this + 1) >= 14;
      v7 = 4 * v5 + 8;
      v8 = (_DWORD *)(*((_DWORD *)this + 5) + 40);
      v9 = ((unsigned int)(v4 - 2) >> 1) + 1;
      v12 = 2 * v9;
      do
      {
        v14 += v7 * *(v8 - 6);
        v15 += v7 * *v8;
        v8 += 12;
        --v9;
      }
      while ( v9 );
      v5 = v12;
      v6 = v11;
    }
    v10 = *((_DWORD *)this + 4);
    if ( v5 < v10 )
      v6 += *(_DWORD *)(*((_DWORD *)this + 5) + 24 * v5 + 16) * (4 * (*((_DWORD *)this + 1) >= 14) + 8);
    result = v6 + v14 + v15 + v10 * (4 * (*((_DWORD *)this + 1) >= 14) + 12);
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1001A930) --------------------------------------------------------
int __thiscall ResourceManagerFile::ResourceManagerFile(int this)
{
  int result; // eax@1

  result = this;
  *(_WORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  return result;
}

//----- (1001A950) --------------------------------------------------------
void __thiscall ResourceManagerFile::Clear(ResourceManagerFile *this)
{
  ResourceManagerFile *v1; // esi@1
  bool v2; // zf@1
  int v3; // ebx@2
  int v4; // edi@3
  int v5; // ebx@9
  int v6; // edi@10
  int v7; // edx@11

  v1 = this;
  v2 = *((_DWORD *)this + 3) == 0;
  *((_BYTE *)this + 1) = 0;
  if ( !v2 )
  {
    v3 = 0;
    if ( *((_DWORD *)this + 2) > 0 )
    {
      v4 = 0;
      do
      {
        if ( *(_DWORD *)(v4 + *((_DWORD *)v1 + 3)) )
          operator delete[](*(void **)(v4 + *((_DWORD *)v1 + 3)));
        ++v3;
        v4 += 24;
      }
      while ( v3 < *((_DWORD *)v1 + 2) );
    }
    operator delete[](*((void **)v1 + 3));
    *((_DWORD *)v1 + 3) = 0;
    *((_DWORD *)v1 + 2) = 0;
  }
  if ( *((_DWORD *)v1 + 5) )
  {
    v5 = 0;
    if ( *((_DWORD *)v1 + 4) > 0 )
    {
      v6 = 0;
      do
      {
        v7 = *((_DWORD *)v1 + 5);
        if ( *(_DWORD *)(v7 + v6 + 20) )
          operator delete[](*(void **)(v7 + v6 + 20));
        ++v5;
        v6 += 24;
      }
      while ( v5 < *((_DWORD *)v1 + 4) );
    }
    operator delete[](*((void **)v1 + 5));
    *((_DWORD *)v1 + 5) = 0;
    *((_DWORD *)v1 + 4) = 0;
  }
}
// 10099190: using guessed type void __cdecl operator delete[](void *);

//----- (1001AA00) --------------------------------------------------------
void __thiscall ResourceManagerFile::Read(ResourceManagerFile *this, void *a2, int a3, int *a4, int a5, bool a6)
{
  ResourceManagerFile *v6; // edi@1
  char *v7; // ebx@1
  int v8; // eax@5
  int v9; // ST1C_4@5
  int v10; // eax@6
  ResourceManagerFile *v11; // ecx@7
  int v12; // edi@10
  int v13; // ecx@11
  size_t v14; // ebx@12
  size_t v15; // ST1C_4@15
  int v16; // eax@20
  unsigned int *v17; // eax@24
  unsigned int v18; // kr04_4@24
  unsigned int v19; // ST20_4@24
  int v20; // eax@25
  int v21; // edx@26
  int v22; // edx@27
  int v23; // eax@28
  int v24; // eax@30
  int v25; // edx@30
  int v26; // ebx@30
  int v27; // eax@30
  int v28; // ST38_4@30
  int v29; // ST34_4@30
  unsigned int *v30; // ST40_4@35
  int v31; // edx@40
  int v32; // eax@41
  int v33; // eax@46
  int v34; // ST20_4@46
  int v35; // eax@47
  int v36; // edi@50
  bool v37; // dl@53
  int v38; // kr0C_4@54
  int v39; // ST20_4@54
  int v40; // eax@55
  int v41; // ecx@60
  int v42; // ST48_4@60
  int v43; // ST44_4@60
  int v44; // ecx@60
  int v45; // kr12_4@71
  int v46; // ST1C_4@71
  int v47; // eax@72
  int v48; // eax@75
  void *v49; // ST24_4@79
  int v50; // ecx@80
  int v51; // edx@85
  int v52; // ST50_4@85
  int v53; // ST4C_4@85
  int v54; // edx@85
  int v55; // ecx@95
  int v56; // eax@96
  ResourceManagerFile *v57; // [sp+Ch] [bp-4Ch]@1
  void *v58; // [sp+18h] [bp-40h]@16
  int v59; // [sp+1Ch] [bp-3Ch]@9
  int v60; // [sp+1Ch] [bp-3Ch]@74
  int v61; // [sp+20h] [bp-38h]@49
  int v62; // [sp+24h] [bp-34h]@48
  int v63; // [sp+34h] [bp-24h]@73

  v6 = this;
  v57 = this;
  ResourceManagerFile::Clear(this);
  v7 = (char *)a2;
  *((_DWORD *)v6 + 1) = a5;
  *(_BYTE *)v6 = 0;
  if ( *a4 + 4 <= a3 )
  {
    *((_DWORD *)v6 + 2) = *(_DWORD *)((char *)a2 + *a4);
    *a4 += 4;
  }
  else
  {
    *((_DWORD *)v6 + 2) = 0;
  }
  if ( a6 )
  {
    v8 = *((_DWORD *)v6 + 2);
    BYTE3(v9) = *((_DWORD *)v6 + 2);
    *(_WORD *)((char *)&v9 + 1) = __PAIR__(BYTE1(v8), (unsigned __int8)(*((_DWORD *)v6 + 2) >> 16));
    LOBYTE(v9) = *((_DWORD *)v6 + 2) >> 24;
    *((_DWORD *)v6 + 2) = v9;
  }
  v10 = unknown_libname_4(24 * *((_DWORD *)v6 + 2) | -(24 * (unsigned __int64)*((_DWORD *)v6 + 2) >> 32 != 0));
  *((_DWORD *)v6 + 3) = v10;
  if ( !v10 )
  {
    v11 = v6;
    goto LABEL_8;
  }
  v59 = 0;
  if ( *((_DWORD *)v6 + 2) <= 0 )
    goto LABEL_38;
  v12 = 0;
  while ( 1 )
  {
    v13 = *a4 + 4;
    if ( v13 <= a3 )
    {
      v14 = *(_DWORD *)((char *)a2 + *a4);
      *a4 = v13;
    }
    else
    {
      v14 = 0;
    }
    if ( a6 )
    {
      BYTE2(v15) = BYTE1(v14);
      BYTE3(v15) = v14;
      LOBYTE(v15) = BYTE3(v14);
      BYTE1(v15) = BYTE2(v14);
      v14 = v15;
    }
    v58 = (void *)unknown_libname_4(v14 + 1);
    if ( !v58 )
      break;
    if ( (signed int)(*a4 + v14) <= a3 )
    {
      memcpy(v58, (char *)a2 + *a4, v14);
      *a4 += v14;
    }
    else
    {
      memset(v58, 0, v14);
    }
    *((_BYTE *)v58 + v14) = 0;
    *(_DWORD *)(v12 + *((_DWORD *)v57 + 3)) = v58;
    v16 = (*a4 + 3) & 0xFFFFFFFC;
    *a4 = v16;
    if ( v16 + 4 <= a3 )
    {
      *(_DWORD *)(*((_DWORD *)v57 + 3) + v12 + 8) = *(_DWORD *)((char *)a2 + v16);
      *a4 += 4;
    }
    else
    {
      *(_DWORD *)(*((_DWORD *)v57 + 3) + v12 + 8) = 0;
    }
    if ( a6 )
    {
      v17 = (unsigned int *)(*((_DWORD *)v57 + 3) + v12 + 8);
      v18 = *v17;
      BYTE2(v19) = BYTE1(v18);
      BYTE3(v19) = *v17;
      LOBYTE(v19) = *v17 >> 24;
      BYTE1(v19) = *v17 >> 16;
      *v17 = v19;
    }
    v20 = *((_DWORD *)v57 + 3);
    *(_DWORD *)(v20 + v12 + 16) = 0;
    *(_DWORD *)(v20 + v12 + 20) = 0;
    if ( a5 < 14 )
    {
      if ( *a4 + 4 <= a3 )
      {
        *(_DWORD *)(*((_DWORD *)v57 + 3) + v12 + 16) = *(_DWORD *)((char *)a2 + *a4);
        *a4 += 4;
      }
      else
      {
        *(_DWORD *)(*((_DWORD *)v57 + 3) + v12 + 16) = 0;
      }
      if ( a6 )
      {
        v30 = (unsigned int *)(*((_DWORD *)v57 + 3) + v12 + 16);
        *v30 = *(_BYTE *)(*((_DWORD *)v57 + 3) + v12 + 19)
             + ((*v30 >> 8) & 0xFF00)
             + (((*v30 & 0xFF00) + (*v30 << 16)) << 8);
      }
    }
    else
    {
      v21 = *a4;
      if ( *a4 + 8 <= a3 )
      {
        v23 = *((_DWORD *)v57 + 3);
        *(_DWORD *)(v23 + v12 + 16) = *(_DWORD *)((char *)a2 + v21);
        *(_DWORD *)(v23 + v12 + 20) = *(_DWORD *)((char *)a2 + v21 + 4);
        *a4 += 8;
      }
      else
      {
        v22 = *((_DWORD *)v57 + 3) + v12 + 16;
        *(_DWORD *)v22 = 0;
        *(_DWORD *)(v22 + 4) = 0;
      }
      if ( a6 )
      {
        v24 = *((_DWORD *)v57 + 3);
        v25 = *(_DWORD *)(v24 + v12 + 16);
        v26 = *(_DWORD *)(v24 + v12 + 20);
        v27 = v24 + v12 + 16;
        BYTE2(v28) = BYTE1(v25);
        BYTE3(v28) = v25;
        BYTE1(v28) = BYTE2(v25);
        LOBYTE(v28) = BYTE3(v25);
        BYTE1(v29) = BYTE2(v26);
        LOBYTE(v29) = BYTE3(v26);
        BYTE2(v29) = BYTE1(v26);
        BYTE3(v29) = v26;
        *(_DWORD *)v27 = v29;
        *(_DWORD *)(v27 + 4) = v28;
      }
    }
    v12 += 24;
    if ( ++v59 >= *((_DWORD *)v57 + 2) )
    {
      v7 = (char *)a2;
      v6 = v57;
LABEL_38:
      if ( *a4 + 4 <= a3 )
      {
        *((_DWORD *)v6 + 4) = *(_DWORD *)&v7[*a4];
        *a4 += 4;
      }
      else
      {
        *((_DWORD *)v6 + 4) = 0;
      }
      if ( a6 )
      {
        v33 = *((_DWORD *)v6 + 4);
        BYTE3(v34) = *((_DWORD *)v6 + 4);
        *(_WORD *)((char *)&v34 + 1) = __PAIR__(BYTE1(v33), (unsigned __int8)(*((_DWORD *)v6 + 4) >> 16));
        LOBYTE(v34) = *((_DWORD *)v6 + 4) >> 24;
        *((_DWORD *)v6 + 4) = v34;
      }
      v35 = unknown_libname_4(24 * *((_DWORD *)v6 + 4) | -(24 * (unsigned __int64)*((_DWORD *)v6 + 4) >> 32 != 0));
      v11 = v57;
      *((_DWORD *)v57 + 5) = v35;
      if ( v35 )
      {
        v62 = 0;
        if ( *((_DWORD *)v57 + 4) <= 0 )
        {
LABEL_94:
          *((_BYTE *)v11 + 1) = 1;
          return;
        }
        v61 = 0;
        while ( 2 )
        {
          v36 = v61 + *((_DWORD *)v57 + 5);
          if ( *a4 + 4 <= a3 )
          {
            *(_DWORD *)v36 = *(_DWORD *)&v7[*a4];
            *a4 += 4;
          }
          else
          {
            *(_DWORD *)v36 = 0;
          }
          v37 = a6;
          if ( a6 )
          {
            v38 = *(_DWORD *)v36;
            BYTE2(v39) = BYTE1(v38);
            BYTE3(v39) = *(_DWORD *)v36;
            LOBYTE(v39) = *(_DWORD *)v36 >> 24;
            BYTE1(v39) = *(_DWORD *)v36 >> 16;
            *(_DWORD *)v36 = v39;
          }
          *(_DWORD *)(v36 + 8) = 0;
          *(_DWORD *)(v36 + 12) = 0;
          v40 = *a4;
          if ( a5 < 14 )
          {
            if ( v40 + 4 <= a3 )
            {
              *(_DWORD *)(v36 + 8) = *(_DWORD *)&v7[v40];
              *a4 += 4;
            }
            else
            {
              *(_DWORD *)(v36 + 8) = 0;
            }
            if ( a6 )
            {
              v37 = a6;
              v44 = ((*(_DWORD *)(v36 + 8) >> 8) & 0xFF00)
                  + *(_BYTE *)(v36 + 11)
                  + (((*(_DWORD *)(v36 + 8) & 0xFF00) + (*(_DWORD *)(v36 + 8) << 16)) << 8);
LABEL_66:
              *(_DWORD *)(v36 + 8) = v44;
            }
          }
          else
          {
            if ( v40 + 8 <= a3 )
            {
              *(_DWORD *)(v36 + 8) = *(_DWORD *)&v7[v40];
              *(_DWORD *)(v36 + 12) = *(_DWORD *)&v7[v40 + 4];
              *a4 += 8;
            }
            else
            {
              *(_DWORD *)(v36 + 8) = 0;
              *(_DWORD *)(v36 + 12) = 0;
            }
            if ( a6 )
            {
              v41 = *(_DWORD *)(v36 + 12);
              BYTE2(v42) = (unsigned __int16)*(_DWORD *)(v36 + 8) >> 8;
              BYTE3(v42) = *(_DWORD *)(v36 + 8);
              BYTE1(v42) = *(_DWORD *)(v36 + 8) >> 16;
              LOBYTE(v42) = *(_DWORD *)(v36 + 8) >> 24;
              BYTE3(v43) = *(_DWORD *)(v36 + 12);
              LOBYTE(v43) = *(_DWORD *)(v36 + 12) >> 24;
              BYTE2(v43) = BYTE1(v41);
              BYTE1(v43) = *(_DWORD *)(v36 + 12) >> 16;
              v44 = v43;
              *(_DWORD *)(v36 + 12) = v42;
              goto LABEL_66;
            }
          }
          if ( *a4 + 4 <= a3 )
          {
            *(_DWORD *)(v36 + 16) = *(_DWORD *)&v7[*a4];
            *a4 += 4;
          }
          else
          {
            *(_DWORD *)(v36 + 16) = 0;
          }
          if ( v37 )
          {
            v45 = *(_DWORD *)(v36 + 16);
            BYTE2(v46) = BYTE1(v45);
            BYTE3(v46) = *(_DWORD *)(v36 + 16);
            LOBYTE(v46) = *(_DWORD *)(v36 + 16) >> 24;
            BYTE1(v46) = *(_DWORD *)(v36 + 16) >> 16;
            *(_DWORD *)(v36 + 16) = v46;
          }
          v47 = unknown_libname_4(16 * *(_DWORD *)(v36 + 16) | -((unsigned __int64)*(_DWORD *)(v36 + 16) >> 28 != 0));
          *(_DWORD *)(v36 + 20) = v47;
          if ( !v47 )
          {
            v55 = v62;
            if ( v62 < *((_DWORD *)v57 + 4) )
            {
              v56 = 24 * v62;
              do
              {
                *(_DWORD *)(v56 + *((_DWORD *)v57 + 5) + 20) = 0;
                ++v55;
                v56 += 24;
              }
              while ( v55 < *((_DWORD *)v57 + 4) );
            }
            ResourceManagerFile::Clear(v57);
            return;
          }
          v63 = 0;
          if ( *(_DWORD *)(v36 + 16) <= 0 )
          {
LABEL_93:
            v11 = v57;
            v61 += 24;
            if ( ++v62 >= *((_DWORD *)v57 + 4) )
              goto LABEL_94;
            continue;
          }
          break;
        }
        v60 = 0;
        while ( 2 )
        {
          v48 = v60 + *(_DWORD *)(v36 + 20);
          if ( *a4 + 4 <= a3 )
          {
            *(_DWORD *)v48 = *(_DWORD *)&v7[*a4];
            *a4 += 4;
          }
          else
          {
            *(_DWORD *)v48 = 0;
          }
          if ( a6 )
          {
            BYTE2(v49) = (unsigned __int16)*(_DWORD *)v48 >> 8;
            BYTE3(v49) = *(_DWORD *)v48;
            BYTE1(v49) = *(_DWORD *)v48 >> 16;
            LOBYTE(v49) = *(_DWORD *)v48 >> 24;
            *(_DWORD *)v48 = v49;
          }
          *(_DWORD *)(v48 + 8) = 0;
          *(_DWORD *)(v48 + 12) = 0;
          v50 = *a4;
          if ( a5 < 14 )
          {
            if ( v50 + 4 <= a3 )
            {
              *(_DWORD *)(v48 + 8) = *(_DWORD *)&v7[v50];
              *a4 += 4;
            }
            else
            {
              *(_DWORD *)(v48 + 8) = 0;
            }
            if ( a6 )
            {
              v7 = (char *)a2;
              v54 = ((*(_DWORD *)(v48 + 8) >> 8) & 0xFF00)
                  + *(_BYTE *)(v48 + 11)
                  + (((*(_DWORD *)(v48 + 8) & 0xFF00) + (*(_DWORD *)(v48 + 8) << 16)) << 8);
LABEL_91:
              *(_DWORD *)(v48 + 8) = v54;
            }
          }
          else
          {
            if ( v50 + 8 <= a3 )
            {
              *(_DWORD *)(v48 + 8) = *(_DWORD *)&v7[v50];
              *(_DWORD *)(v48 + 12) = *(_DWORD *)&v7[v50 + 4];
              *a4 += 8;
            }
            else
            {
              *(_DWORD *)(v48 + 8) = 0;
              *(_DWORD *)(v48 + 12) = 0;
            }
            if ( a6 )
            {
              v51 = *(_DWORD *)(v48 + 12);
              BYTE2(v52) = (unsigned __int16)*(_DWORD *)(v48 + 8) >> 8;
              BYTE3(v52) = *(_DWORD *)(v48 + 8);
              BYTE1(v52) = *(_DWORD *)(v48 + 8) >> 16;
              LOBYTE(v52) = *(_DWORD *)(v48 + 8) >> 24;
              BYTE3(v53) = *(_DWORD *)(v48 + 12);
              LOBYTE(v53) = *(_DWORD *)(v48 + 12) >> 24;
              BYTE2(v53) = BYTE1(v51);
              BYTE1(v53) = *(_DWORD *)(v48 + 12) >> 16;
              v54 = v53;
              *(_DWORD *)(v48 + 12) = v52;
              goto LABEL_91;
            }
          }
          v60 += 16;
          if ( ++v63 >= *(_DWORD *)(v36 + 16) )
            goto LABEL_93;
          continue;
        }
      }
LABEL_8:
      ResourceManagerFile::Clear(v11);
      return;
    }
  }
  v31 = v59;
  if ( v59 < *((_DWORD *)v57 + 2) )
  {
    v32 = 24 * v59;
    do
    {
      *(_DWORD *)(v32 + *((_DWORD *)v57 + 3)) = 0;
      ++v31;
      v32 += 24;
    }
    while ( v31 < *((_DWORD *)v57 + 2) );
  }
  ResourceManagerFile::Clear(v57);
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);

//----- (1001B0D0) --------------------------------------------------------
int __thiscall ResourceManagerFile::AddContainer(ResourceManagerFile *this, struct ResourceManager_ContainerData *a2)
{
  ResourceManagerFile *v2; // esi@1
  void *v3; // edi@1
  int v4; // ecx@1
  void *v5; // ecx@1
  int v6; // eax@1

  v2 = this;
  v3 = (void *)unknown_libname_4(24 * (*((_DWORD *)this + 2) + 1) | -(24
                                                                    * (unsigned __int64)(unsigned int)(*((_DWORD *)this + 2) + 1) >> 32 != 0));
  memcpy(v3, *((const void **)v2 + 3), 24 * *((_DWORD *)v2 + 2));
  *((_DWORD *)v3 + 6 * *((_DWORD *)v2 + 2)) = *(_DWORD *)a2;
  v4 = (int)v3 + 24 * *((_DWORD *)v2 + 2) + 8;
  *(_DWORD *)v4 = *((_DWORD *)a2 + 2);
  *(_DWORD *)(v4 + 4) = *((_DWORD *)a2 + 3);
  *(_DWORD *)(v4 + 8) = *((_DWORD *)a2 + 4);
  *(_DWORD *)(v4 + 12) = *((_DWORD *)a2 + 5);
  v5 = (void *)*((_DWORD *)v2 + 3);
  ++*((_DWORD *)v2 + 2);
  operator delete[](v5);
  v6 = *((_DWORD *)v2 + 2);
  *((_DWORD *)v2 + 3) = v3;
  return v6 - 1;
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 10099190: using guessed type void __cdecl operator delete[](void *);

//----- (1001B160) --------------------------------------------------------
void __thiscall ResourceManagerFile::RemoveContainer(ResourceManagerFile *this, int a2)
{
  int v2; // ebx@1
  ResourceManagerFile *v3; // esi@1
  int v4; // eax@1
  void *v5; // edi@3
  int v6; // edx@5
  int v7; // ecx@6
  int v8; // eax@7
  int v9; // ebx@7
  int v10; // eax@7
  int v11; // edi@7
  void *v12; // ecx@8
  int v13; // [sp+10h] [bp+8h]@3

  v2 = a2;
  v3 = this;
  v4 = *((_DWORD *)this + 2);
  if ( v4 > a2 && a2 >= 0 )
  {
    v5 = (void *)unknown_libname_4(24 * (v4 - 1) | -(24 * (unsigned __int64)(unsigned int)(v4 - 1) >> 32 != 0));
    v13 = (int)v5;
    if ( v2 > 0 )
      memcpy(v5, *((const void **)v3 + 3), 24 * v2);
    v6 = v2 + 1;
    if ( v2 + 1 < *((_DWORD *)v3 + 2) )
    {
      v7 = 24 * v6;
      do
      {
        v8 = *((_DWORD *)v3 + 3);
        v9 = *(_DWORD *)(v8 + v7);
        v10 = v7 + v8;
        *(_DWORD *)((char *)v5 + v7 - 24) = v9;
        v11 = (int)v5 + v7 - 24;
        *(_DWORD *)(v11 + 4) = *(_DWORD *)(v10 + 4);
        *(_DWORD *)(v11 + 8) = *(_DWORD *)(v10 + 8);
        *(_DWORD *)(v11 + 12) = *(_DWORD *)(v10 + 12);
        *(_DWORD *)(v11 + 16) = *(_DWORD *)(v10 + 16);
        *(_DWORD *)(v11 + 20) = *(_DWORD *)(v10 + 20);
        v5 = (void *)v13;
        ++v6;
        v7 += 24;
      }
      while ( v6 < *((_DWORD *)v3 + 2) );
    }
    v12 = (void *)*((_DWORD *)v3 + 3);
    --*((_DWORD *)v3 + 2);
    operator delete[](v12);
    *((_DWORD *)v3 + 3) = v5;
  }
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 10099190: using guessed type void __cdecl operator delete[](void *);

//----- (1001B230) --------------------------------------------------------
double __usercall sub_1001B230@<st0>(_WORD *a1@<eax>)
{
  return COERCE_FLOAT(dword_100A4308[(unsigned int)*a1 >> 10] + dword_100A2308[(*a1 & 0x3FF)
                                                                             + (unsigned __int16)word_100A4408[(unsigned int)*a1 >> 10]]);
}
// 100A2308: using guessed type int dword_100A2308[];
// 100A4308: using guessed type int dword_100A4308[];
// 100A4408: using guessed type __int16 word_100A4408[];

//----- (1001B270) --------------------------------------------------------
__int16 __stdcall sub_1001B270(int a1, float a2)
{
  char v2; // cl@1
  __int16 v3; // si@1
  __int16 result; // ax@1

  v2 = byte_100A4B60[LODWORD(a2) >> 23];
  v3 = word_100A4760[LODWORD(a2) >> 23] + ((LODWORD(a2) & 0x7FFFFFu) >> v2);
  result = v3
         + (((v3 & 0x7C00) != 31744) & (((unsigned __int8)(LODWORD(a2) >> 23) == 102) | (unsigned __int16)((LODWORD(a2) & 0x7FFFFFu) >> (v2 - 1))));
  *(_WORD *)a1 = result;
  return result;
}
// 100A4760: using guessed type __int16 word_100A4760[];

//----- (1001B2D0) --------------------------------------------------------
char __cdecl ReadTextureFile(struct TextureFile *a1, struct AssetTypeValueField *a2)
{
  _DWORD *v2; // eax@1
  _DWORD *v3; // edi@1
  _DWORD *v4; // eax@1
  _DWORD *v5; // ebx@1
  void *v6; // eax@1
  void *v7; // eax@1
  void *v8; // eax@1
  void *v9; // eax@1
  void *v10; // eax@1
  void *v11; // eax@1
  void *v12; // eax@1
  signed int v13; // eax@1
  bool v14; // al@5
  int v15; // eax@8
  signed int v16; // eax@9
  struct TextureFile *v17; // esi@9
  signed int v18; // eax@10
  signed int v19; // eax@12
  signed int v20; // eax@13
  signed int v21; // eax@14
  int v22; // eax@16
  char v23; // al@17
  int v24; // eax@20
  int v25; // eax@21
  int v26; // ecx@23
  int v27; // eax@23
  int v28; // edx@23
  int v29; // eax@23
  int v30; // ecx@23
  int v31; // eax@23
  int v32; // edx@23
  int v33; // eax@23
  char v34; // al@24
  char v35; // al@27
  int v36; // eax@28
  int v37; // eax@31
  signed int v38; // eax@32
  int v39; // edx@38
  int v40; // eax@38
  signed int v41; // eax@39
  int v42; // edx@45
  int v43; // eax@45
  signed int v44; // eax@46
  int v45; // edx@52
  int v46; // eax@52
  signed int v47; // eax@53
  int v48; // edx@59
  int v49; // eax@59
  signed int v50; // eax@60
  int v51; // edx@66
  int v52; // eax@66
  signed int v53; // eax@67
  int v54; // eax@74
  _DWORD *v55; // ecx@82
  _DWORD *v56; // eax@82
  _DWORD *v57; // eax@83
  _DWORD *v58; // eax@85
  int v59; // eax@86
  size_t v60; // ST08_4@88
  void *v61; // ST00_4@88
  int v62; // eax@89
  void *v63; // edx@89
  int v64; // eax@89
  char result; // al@90
  void *v66; // [sp+Ch] [bp-54h]@1
  void *v67; // [sp+10h] [bp-50h]@1
  _DWORD *v68; // [sp+14h] [bp-4Ch]@1
  _DWORD *v69; // [sp+18h] [bp-48h]@1
  void *v70; // [sp+1Ch] [bp-44h]@1
  void *v71; // [sp+20h] [bp-40h]@1
  void *v72; // [sp+24h] [bp-3Ch]@1
  void *v73; // [sp+28h] [bp-38h]@1
  void *v74; // [sp+2Ch] [bp-34h]@1
  _DWORD *v75; // [sp+30h] [bp-30h]@1
  void *v76; // [sp+34h] [bp-2Ch]@1
  void *v77; // [sp+38h] [bp-28h]@1
  void *v78; // [sp+3Ch] [bp-24h]@1
  void *v79; // [sp+40h] [bp-20h]@1
  _DWORD *v80; // [sp+44h] [bp-1Ch]@1
  void *v81; // [sp+48h] [bp-18h]@1
  _DWORD *v82; // [sp+4Ch] [bp-14h]@1
  _DWORD *v83; // [sp+50h] [bp-10h]@1
  void *v84; // [sp+54h] [bp-Ch]@1
  _DWORD *v85; // [sp+58h] [bp-8h]@1
  _DWORD *v86; // [sp+5Ch] [bp-4h]@1

  v2 = AssetTypeValueField::operator[]((int)a2, "m_MipCount");
  v3 = v2;
  v66 = v2;
  v4 = AssetTypeValueField::operator[]((int)a2, "m_MipMap");
  v5 = v4;
  v67 = v4;
  v68 = AssetTypeValueField::operator[]((int)a2, "m_ReadAllowed");
  v69 = AssetTypeValueField::operator[]((int)a2, "m_Name");
  v70 = AssetTypeValueField::operator[]((int)a2, "m_Width");
  v71 = AssetTypeValueField::operator[]((int)a2, "m_Height");
  v72 = AssetTypeValueField::operator[]((int)a2, "m_CompleteImageSize");
  v73 = AssetTypeValueField::operator[]((int)a2, "m_TextureFormat");
  v74 = AssetTypeValueField::operator[]((int)a2, "m_IsReadable");
  v75 = AssetTypeValueField::operator[]((int)a2, "m_ImageCount");
  v76 = AssetTypeValueField::operator[]((int)a2, "m_TextureDimension");
  v6 = AssetTypeValueField::operator[]((int)a2, "m_TextureSettings");
  v77 = AssetTypeValueField::operator[]((int)v6, "m_FilterMode");
  v7 = AssetTypeValueField::operator[]((int)a2, "m_TextureSettings");
  v78 = AssetTypeValueField::operator[]((int)v7, "m_Aniso");
  v8 = AssetTypeValueField::operator[]((int)a2, "m_TextureSettings");
  v79 = AssetTypeValueField::operator[]((int)v8, "m_MipBias");
  v9 = AssetTypeValueField::operator[]((int)a2, "m_TextureSettings");
  v80 = AssetTypeValueField::operator[]((int)v9, "m_WrapMode");
  v81 = AssetTypeValueField::operator[]((int)a2, "m_LightmapFormat");
  v82 = AssetTypeValueField::operator[]((int)a2, "m_ColorSpace");
  v83 = AssetTypeValueField::operator[]((int)a2, "image data");
  v10 = AssetTypeValueField::operator[]((int)a2, "m_StreamData");
  v84 = AssetTypeValueField::operator[]((int)v10, "offset");
  v11 = AssetTypeValueField::operator[]((int)a2, "m_StreamData");
  v85 = AssetTypeValueField::operator[]((int)v11, "size");
  v12 = AssetTypeValueField::operator[]((int)a2, "m_StreamData");
  v86 = AssetTypeValueField::operator[]((int)v12, "path");
  v13 = 3;
  do
  {
    if ( *((_DWORD *)*(&v66 + v13) + 1) == -1 && v13 != 16 )
      return 0;
    ++v13;
  }
  while ( v13 < 18 );
  v14 = v85[1] == -1;
  if ( (*((_DWORD *)v84 + 1) == -1) != v14 || v14 != (v86[1] == -1) )
    return 0;
  if ( v3[1] != -1 )
  {
    v15 = v3[3];
    switch ( *(_DWORD *)v15 )
    {
      case 0xA:
        v16 = (signed int)*(float *)(v15 + 8);
        v17 = a1;
        *((_DWORD *)a1 + 5) = v16;
        *((_BYTE *)a1 + 24) = v16 > 1;
        break;
      case 0xB:
        v18 = (signed int)*(double *)(v15 + 8);
        v17 = a1;
        *((_DWORD *)a1 + 5) = v18;
        *((_BYTE *)a1 + 24) = v18 > 1;
        break;
      case 0xC:
      case 0xD:
      case 0xE:
        v17 = a1;
        *((_DWORD *)a1 + 5) = 0;
        *((_BYTE *)a1 + 24) = 0;
        break;
      case 2:
        v19 = *(_BYTE *)(v15 + 8);
        v17 = a1;
        *((_DWORD *)a1 + 5) = v19;
        *((_BYTE *)a1 + 24) = v19 > 1;
        break;
      case 4:
        v20 = *(_WORD *)(v15 + 8);
        v17 = a1;
        *((_DWORD *)a1 + 5) = v20;
        *((_BYTE *)a1 + 24) = v20 > 1;
        break;
      default:
        v21 = *(_DWORD *)(v15 + 8);
        v17 = a1;
        *((_DWORD *)a1 + 5) = v21;
        *((_BYTE *)a1 + 24) = v21 > 1;
        break;
    }
    goto LABEL_20;
  }
  if ( v5[1] == -1 )
    return 0;
  v17 = a1;
  *((_DWORD *)a1 + 5) = -1;
  v22 = v5[3];
  if ( (unsigned int)(*(_DWORD *)v22 - 10) > 4 )
    v23 = *(_BYTE *)(v22 + 8);
  else
    v23 = 0;
  *((_BYTE *)a1 + 24) = v23;
LABEL_20:
  v24 = v69[3];
  if ( *(_DWORD *)v24 == 12 )
    v25 = *(_DWORD *)(v24 + 8);
  else
    v25 = 0;
  v26 = (int)v70;
  *(_DWORD *)v17 = v25;
  v27 = sub_10001070(*(_DWORD *)(v26 + 12));
  v28 = (int)v71;
  *((_DWORD *)v17 + 1) = v27;
  *((_DWORD *)v17 + 2) = sub_10001070(*(_DWORD *)(v28 + 12));
  v29 = sub_10001070(*((_DWORD *)v72 + 3));
  v30 = (int)v73;
  *((_DWORD *)v17 + 3) = v29;
  v31 = sub_10001070(*(_DWORD *)(v30 + 12));
  v32 = (int)v74;
  *((_DWORD *)v17 + 4) = v31;
  v33 = *(_DWORD *)(v32 + 12);
  if ( (unsigned int)(*(_DWORD *)v33 - 10) > 4 )
    v34 = *(_BYTE *)(v33 + 8);
  else
    v34 = 0;
  *((_BYTE *)v17 + 25) = v34;
  if ( v68[1] == -1 )
  {
    v35 = 1;
  }
  else
  {
    v36 = v68[3];
    if ( (unsigned int)(*(_DWORD *)v36 - 10) > 4 )
      v35 = *(_BYTE *)(v36 + 8);
    else
      v35 = 0;
  }
  *((_BYTE *)v17 + 26) = v35;
  v37 = v75[3];
  switch ( *(_DWORD *)v37 )
  {
    case 0xA:
      v38 = (signed int)*(float *)(v37 + 8);
      break;
    case 0xB:
      v38 = (signed int)*(double *)(v37 + 8);
      break;
    case 0xC:
    case 0xD:
    case 0xE:
      v38 = 0;
      break;
    case 2:
      v38 = *(_BYTE *)(v37 + 8);
      break;
    case 4:
      v38 = *(_WORD *)(v37 + 8);
      break;
    default:
      v38 = *(_DWORD *)(v37 + 8);
      break;
  }
  v39 = (int)v76;
  *((_DWORD *)v17 + 7) = v38;
  v40 = *(_DWORD *)(v39 + 12);
  switch ( *(_DWORD *)v40 )
  {
    case 0xA:
      v41 = (signed int)*(float *)(v40 + 8);
      break;
    case 0xB:
      v41 = (signed int)*(double *)(v40 + 8);
      break;
    case 0xC:
    case 0xD:
    case 0xE:
      v41 = 0;
      break;
    case 2:
      v41 = *(_BYTE *)(v40 + 8);
      break;
    case 4:
      v41 = *(_WORD *)(v40 + 8);
      break;
    default:
      v41 = *(_DWORD *)(v40 + 8);
      break;
  }
  v42 = (int)v77;
  *((_DWORD *)v17 + 8) = v41;
  v43 = *(_DWORD *)(v42 + 12);
  switch ( *(_DWORD *)v43 )
  {
    case 0xA:
      v44 = (signed int)*(float *)(v43 + 8);
      break;
    case 0xB:
      v44 = (signed int)*(double *)(v43 + 8);
      break;
    case 0xC:
    case 0xD:
    case 0xE:
      v44 = 0;
      break;
    case 2:
      v44 = *(_BYTE *)(v43 + 8);
      break;
    case 4:
      v44 = *(_WORD *)(v43 + 8);
      break;
    default:
      v44 = *(_DWORD *)(v43 + 8);
      break;
  }
  v45 = (int)v78;
  *((_DWORD *)v17 + 9) = v44;
  v46 = *(_DWORD *)(v45 + 12);
  switch ( *(_DWORD *)v46 )
  {
    case 0xA:
      v47 = (signed int)*(float *)(v46 + 8);
      break;
    case 0xB:
      v47 = (signed int)*(double *)(v46 + 8);
      break;
    case 0xC:
    case 0xD:
    case 0xE:
      v47 = 0;
      break;
    case 2:
      v47 = *(_BYTE *)(v46 + 8);
      break;
    case 4:
      v47 = *(_WORD *)(v46 + 8);
      break;
    default:
      v47 = *(_DWORD *)(v46 + 8);
      break;
  }
  v48 = (int)v79;
  *((_DWORD *)v17 + 10) = v47;
  *((float *)v17 + 11) = sub_10013150(*(_DWORD *)(v48 + 12));
  v49 = v80[3];
  switch ( *(_DWORD *)v49 )
  {
    case 0xA:
      v50 = (signed int)*(float *)(v49 + 8);
      break;
    case 0xB:
      v50 = (signed int)*(double *)(v49 + 8);
      break;
    case 0xC:
    case 0xD:
    case 0xE:
      v50 = 0;
      break;
    case 2:
      v50 = *(_BYTE *)(v49 + 8);
      break;
    case 4:
      v50 = *(_WORD *)(v49 + 8);
      break;
    default:
      v50 = *(_DWORD *)(v49 + 8);
      break;
  }
  v51 = (int)v81;
  *((_DWORD *)v17 + 12) = v50;
  v52 = *(_DWORD *)(v51 + 12);
  switch ( *(_DWORD *)v52 )
  {
    case 0xA:
      v53 = (signed int)*(float *)(v52 + 8);
      break;
    case 0xB:
      v53 = (signed int)*(double *)(v52 + 8);
      break;
    case 0xC:
    case 0xD:
    case 0xE:
      v53 = 0;
      break;
    case 2:
      v53 = *(_BYTE *)(v52 + 8);
      break;
    case 4:
      v53 = *(_WORD *)(v52 + 8);
      break;
    default:
      v53 = *(_DWORD *)(v52 + 8);
      break;
  }
  *((_DWORD *)v17 + 13) = v53;
  if ( v82[1] == -1 )
  {
    *((_DWORD *)v17 + 14) = 0;
  }
  else
  {
    v54 = v82[3];
    switch ( *(_DWORD *)v54 )
    {
      case 0xA:
        *((_DWORD *)v17 + 14) = (signed int)*(float *)(v54 + 8);
        break;
      case 0xB:
        *((_DWORD *)v17 + 14) = (signed int)*(double *)(v54 + 8);
        break;
      case 0xC:
      case 0xD:
      case 0xE:
        *((_DWORD *)v17 + 14) = 0;
        break;
      case 2:
        *((_DWORD *)v17 + 14) = *(_BYTE *)(v54 + 8);
        break;
      case 4:
        *((_DWORD *)v17 + 14) = *(_WORD *)(v54 + 8);
        break;
      default:
        *((_DWORD *)v17 + 14) = *(_DWORD *)(v54 + 8);
        break;
    }
  }
  v55 = v83;
  v56 = (_DWORD *)v83[3];
  if ( *v56 == 14 )
    v57 = v56 + 2;
  else
    v57 = 0;
  *((_DWORD *)v17 + 15) = *v57;
  v58 = (_DWORD *)v55[3];
  if ( *v58 == 14 )
    v59 = (int)(v58 + 2);
  else
    v59 = 0;
  v60 = *((_DWORD *)v17 + 15);
  v61 = *(void **)(v59 + 4);
  *((_DWORD *)v17 + 16) = v61;
  memcpy(v61, v61, v60);
  if ( *((_DWORD *)v84 + 1) == -1 )
  {
    *((_DWORD *)v17 + 18) = 0;
    *((_DWORD *)v17 + 17) = 0;
    *((_DWORD *)v17 + 19) = 0;
    result = 1;
  }
  else
  {
    v62 = sub_10001070(*((_DWORD *)v84 + 3));
    v63 = v85;
    *((_DWORD *)v17 + 17) = v62;
    *((_DWORD *)v17 + 18) = sub_10001070(*((_DWORD *)v63 + 3));
    v64 = v86[3];
    if ( *(_DWORD *)v64 == 12 )
    {
      *((_DWORD *)v17 + 19) = *(_DWORD *)(v64 + 8);
      result = 1;
    }
    else
    {
      result = 1;
      *((_DWORD *)v17 + 19) = 0;
    }
  }
  return result;
}

//----- (1001BA40) --------------------------------------------------------
int __cdecl WriteTextureFile(struct TextureFile *a1, struct AssetTypeTemplateField *a2, unsigned __int64 (__cdecl *a3)(unsigned __int64, unsigned __int64, const void *, __int32), __int32 a4)
{
  int v4; // edi@1
  struct AssetTypeTemplateField *v5; // esi@1
  AssetTypeValue *v6; // ecx@2
  void *v7; // ST0C_4@3
  int v8; // ecx@3
  struct AssetTypeTemplateField *v9; // esi@6
  AssetTypeValue *v10; // ecx@7
  int v11; // ecx@8
  int v12; // eax@10
  struct AssetTypeTemplateField *v13; // esi@11
  AssetTypeValue *v14; // eax@12
  int v15; // ecx@13
  int v16; // eax@15
  struct AssetTypeTemplateField *v17; // esi@16
  AssetTypeValue *v18; // ecx@17
  int v19; // ecx@18
  int v20; // eax@20
  struct AssetTypeTemplateField *v21; // esi@21
  AssetTypeValue *v22; // eax@22
  int v23; // ecx@23
  int v24; // eax@25
  struct AssetTypeTemplateField *v25; // esi@26
  AssetTypeValue *v26; // ecx@27
  int v27; // ecx@28
  AssetTypeValue *v28; // eax@30
  int v29; // eax@33
  struct AssetTypeTemplateField *v30; // esi@34
  AssetTypeValue *v31; // ecx@35
  int v32; // ecx@36
  int v33; // eax@38
  struct AssetTypeTemplateField *v34; // esi@39
  AssetTypeValue *v35; // eax@40
  int v36; // ecx@41
  int v37; // eax@43
  struct AssetTypeTemplateField *v38; // esi@44
  AssetTypeValue *v39; // ecx@45
  int v40; // ecx@46
  int v41; // eax@48
  struct AssetTypeTemplateField *v42; // esi@49
  AssetTypeValue *v43; // eax@50
  int v44; // ecx@51
  int v45; // eax@53
  AssetTypeTemplateField *v46; // eax@54
  struct AssetTypeTemplateField *v47; // esi@55
  AssetTypeValue *v48; // ecx@56
  int v49; // ecx@57
  int v50; // eax@59
  struct AssetTypeTemplateField *v51; // esi@60
  AssetTypeValue *v52; // eax@61
  int v53; // ecx@62
  int v54; // eax@64
  struct AssetTypeTemplateField *v55; // esi@65
  AssetTypeValue *v56; // ecx@66
  int v57; // ecx@67
  int v58; // eax@69
  struct AssetTypeTemplateField *v59; // esi@70
  AssetTypeValue *v60; // eax@71
  int v61; // ecx@72
  int v62; // eax@74
  struct AssetTypeTemplateField *v63; // esi@75
  AssetTypeValue *v64; // ecx@76
  int v65; // ecx@77
  int v66; // eax@79
  struct AssetTypeTemplateField *v67; // esi@80
  AssetTypeValue *v68; // eax@81
  int v69; // ecx@82
  int v70; // eax@84
  struct AssetTypeTemplateField *v71; // esi@85
  int v72; // edx@86
  AssetTypeValue *v73; // ecx@86
  int v74; // ecx@87
  int v75; // eax@89
  AssetTypeTemplateField *v76; // eax@90
  struct AssetTypeTemplateField *v77; // esi@91
  AssetTypeValue *v78; // eax@92
  int v79; // ecx@93
  int v80; // eax@95
  struct AssetTypeTemplateField *v81; // esi@96
  AssetTypeValue *v82; // ecx@97
  int v83; // ecx@98
  int v84; // eax@100
  struct AssetTypeTemplateField *v85; // esi@101
  AssetTypeValue *v86; // eax@103
  int v87; // ecx@104
  AssetTypeValue *v88; // ecx@105
  void *v89; // ST0C_4@106
  int v90; // eax@108
  int v91; // esi@109
  signed int v92; // eax@109
  int v93; // edi@122
  int v94; // edx@122
  signed int v95; // esi@123
  int v96; // eax@124
  void *v97; // eax@125
  char v99; // [sp+Fh] [bp-69h]@90
  AssetTypeTemplateField *v100; // [sp+10h] [bp-68h]@55
  int v101; // [sp+14h] [bp-64h]@86
  int *v102; // [sp+18h] [bp-60h]@122
  int v103; // [sp+1Ch] [bp-5Ch]@122
  void *v104; // [sp+24h] [bp-54h]@1
  int v105; // [sp+28h] [bp-50h]@1
  char *v106; // [sp+2Ch] [bp-4Ch]@10
  char *v107; // [sp+30h] [bp-48h]@15
  char *v108; // [sp+34h] [bp-44h]@20
  char *v109; // [sp+38h] [bp-40h]@25
  char *v110; // [sp+3Ch] [bp-3Ch]@33
  char *v111; // [sp+40h] [bp-38h]@38
  char *v112; // [sp+44h] [bp-34h]@43
  char *v113; // [sp+48h] [bp-30h]@48
  char *v114; // [sp+4Ch] [bp-2Ch]@53
  char *v115; // [sp+50h] [bp-28h]@59
  char *v116; // [sp+54h] [bp-24h]@64
  char *v117; // [sp+58h] [bp-20h]@69
  char *v118; // [sp+5Ch] [bp-1Ch]@74
  char *v119; // [sp+60h] [bp-18h]@79
  char *v120; // [sp+64h] [bp-14h]@84
  char *v121; // [sp+68h] [bp-10h]@89
  char *v122; // [sp+6Ch] [bp-Ch]@95
  char *v123; // [sp+70h] [bp-8h]@100
  char *v124; // [sp+74h] [bp-4h]@108

  v4 = unknown_libname_4(320);
  v104 = (void *)v4;
  memset(&v105, 0, 0x50u);
  v5 = AssetTypeTemplateField::SearchChild(a2, "m_Name");
  if ( v5 )
  {
    v6 = (AssetTypeValue *)operator new(0x10u);
    if ( v6 )
    {
      v7 = *(void **)a1;
      *(_DWORD *)v6 = 12;
      AssetTypeValue::Set(v6, v7);
    }
    else
    {
      v8 = 0;
    }
    *(_DWORD *)(v4 + 12) = v8;
    *(_DWORD *)v4 = v5;
    *(_DWORD *)(v4 + 4) = 0;
    *(_DWORD *)(v4 + 8) = 0;
    v105 = v4;
  }
  v9 = AssetTypeTemplateField::SearchChild(a2, "m_Width");
  if ( v9 )
  {
    v10 = (AssetTypeValue *)operator new(0x10u);
    if ( v10 )
    {
      *(_DWORD *)v10 = 6;
      AssetTypeValue::Set(v10, (char *)a1 + 4);
    }
    else
    {
      v11 = 0;
    }
    v12 = v4 + 16;
    *(_DWORD *)(v12 + 12) = v11;
    *(_DWORD *)v12 = v9;
    *(_DWORD *)(v12 + 4) = 0;
    *(_DWORD *)(v12 + 8) = 0;
    v106 = (char *)(v4 + 16);
  }
  v13 = AssetTypeTemplateField::SearchChild(a2, "m_Height");
  if ( v13 )
  {
    v14 = (AssetTypeValue *)operator new(0x10u);
    if ( v14 )
    {
      *(_DWORD *)v14 = 6;
      AssetTypeValue::Set(v14, (char *)a1 + 8);
    }
    else
    {
      v15 = 0;
    }
    v16 = v4 + 32;
    *(_DWORD *)(v16 + 12) = v15;
    *(_DWORD *)v16 = v13;
    *(_DWORD *)(v16 + 4) = 0;
    *(_DWORD *)(v16 + 8) = 0;
    v107 = (char *)(v4 + 32);
  }
  v17 = AssetTypeTemplateField::SearchChild(a2, "m_CompleteImageSize");
  if ( v17 )
  {
    v18 = (AssetTypeValue *)operator new(0x10u);
    if ( v18 )
    {
      *(_DWORD *)v18 = 6;
      AssetTypeValue::Set(v18, (char *)a1 + 12);
    }
    else
    {
      v19 = 0;
    }
    v20 = v4 + 48;
    *(_DWORD *)(v20 + 12) = v19;
    *(_DWORD *)v20 = v17;
    *(_DWORD *)(v20 + 4) = 0;
    *(_DWORD *)(v20 + 8) = 0;
    v108 = (char *)(v4 + 48);
  }
  v21 = AssetTypeTemplateField::SearchChild(a2, "m_TextureFormat");
  if ( v21 )
  {
    v22 = (AssetTypeValue *)operator new(0x10u);
    if ( v22 )
    {
      *(_DWORD *)v22 = 6;
      AssetTypeValue::Set(v22, (char *)a1 + 16);
    }
    else
    {
      v23 = 0;
    }
    v24 = v4 + 64;
    *(_DWORD *)(v24 + 12) = v23;
    *(_DWORD *)v24 = v21;
    *(_DWORD *)(v24 + 4) = 0;
    *(_DWORD *)(v24 + 8) = 0;
    v109 = (char *)(v4 + 64);
  }
  v25 = AssetTypeTemplateField::SearchChild(a2, "m_MipCount");
  if ( !v25 )
  {
    v25 = AssetTypeTemplateField::SearchChild(a2, "m_MipMap");
    if ( !v25 )
      goto LABEL_34;
    v28 = (AssetTypeValue *)operator new(0x10u);
    if ( v28 )
    {
      *(_DWORD *)v28 = 1;
      AssetTypeValue::Set(v28, (char *)a1 + 20);
      goto LABEL_33;
    }
LABEL_32:
    v27 = 0;
    goto LABEL_33;
  }
  v26 = (AssetTypeValue *)operator new(0x10u);
  if ( !v26 )
    goto LABEL_32;
  *(_DWORD *)v26 = 6;
  AssetTypeValue::Set(v26, (char *)a1 + 20);
LABEL_33:
  v29 = v4 + 80;
  *(_DWORD *)(v29 + 12) = v27;
  *(_DWORD *)v29 = v25;
  *(_DWORD *)(v29 + 4) = 0;
  *(_DWORD *)(v29 + 8) = 0;
  v110 = (char *)(v4 + 80);
LABEL_34:
  v30 = AssetTypeTemplateField::SearchChild(a2, "m_IsReadable");
  if ( v30 )
  {
    v31 = (AssetTypeValue *)operator new(0x10u);
    if ( v31 )
    {
      *(_DWORD *)v31 = 1;
      AssetTypeValue::Set(v31, (char *)a1 + 25);
    }
    else
    {
      v32 = 0;
    }
    v33 = v4 + 96;
    *(_DWORD *)(v33 + 12) = v32;
    *(_DWORD *)v33 = v30;
    *(_DWORD *)(v33 + 4) = 0;
    *(_DWORD *)(v33 + 8) = 0;
    v111 = (char *)(v4 + 96);
  }
  v34 = AssetTypeTemplateField::SearchChild(a2, "m_ReadAllowed");
  if ( v34 )
  {
    v35 = (AssetTypeValue *)operator new(0x10u);
    if ( v35 )
    {
      *(_DWORD *)v35 = 1;
      AssetTypeValue::Set(v35, (char *)a1 + 26);
    }
    else
    {
      v36 = 0;
    }
    v37 = v4 + 112;
    *(_DWORD *)(v37 + 12) = v36;
    *(_DWORD *)v37 = v34;
    *(_DWORD *)(v37 + 4) = 0;
    *(_DWORD *)(v37 + 8) = 0;
    v112 = (char *)(v4 + 112);
  }
  v38 = AssetTypeTemplateField::SearchChild(a2, "m_ImageCount");
  if ( v38 )
  {
    v39 = (AssetTypeValue *)operator new(0x10u);
    if ( v39 )
    {
      *(_DWORD *)v39 = 6;
      AssetTypeValue::Set(v39, (char *)a1 + 28);
    }
    else
    {
      v40 = 0;
    }
    v41 = v4 + 128;
    *(_DWORD *)(v41 + 12) = v40;
    *(_DWORD *)v41 = v38;
    *(_DWORD *)(v41 + 4) = 0;
    *(_DWORD *)(v41 + 8) = 0;
    v113 = (char *)(v4 + 128);
  }
  v42 = AssetTypeTemplateField::SearchChild(a2, "m_TextureDimension");
  if ( v42 )
  {
    v43 = (AssetTypeValue *)operator new(0x10u);
    if ( v43 )
    {
      *(_DWORD *)v43 = 6;
      AssetTypeValue::Set(v43, (char *)a1 + 32);
    }
    else
    {
      v44 = 0;
    }
    v45 = v4 + 144;
    *(_DWORD *)(v45 + 12) = v44;
    *(_DWORD *)v45 = v42;
    *(_DWORD *)(v45 + 4) = 0;
    *(_DWORD *)(v45 + 8) = 0;
    v114 = (char *)(v4 + 144);
  }
  v46 = AssetTypeTemplateField::SearchChild(a2, "m_TextureSettings");
  if ( v46 )
  {
    v100 = v46;
    v47 = AssetTypeTemplateField::SearchChild(v46, "m_FilterMode");
    if ( v47 )
    {
      v48 = (AssetTypeValue *)operator new(0x10u);
      if ( v48 )
      {
        *(_DWORD *)v48 = 6;
        AssetTypeValue::Set(v48, (char *)a1 + 36);
      }
      else
      {
        v49 = 0;
      }
      v50 = v4 + 160;
      *(_DWORD *)(v50 + 12) = v49;
      *(_DWORD *)v50 = v47;
      *(_DWORD *)(v50 + 4) = 0;
      *(_DWORD *)(v50 + 8) = 0;
      v115 = (char *)(v4 + 160);
    }
    v51 = AssetTypeTemplateField::SearchChild(v100, "m_Aniso");
    if ( v51 )
    {
      v52 = (AssetTypeValue *)operator new(0x10u);
      if ( v52 )
      {
        *(_DWORD *)v52 = 6;
        AssetTypeValue::Set(v52, (char *)a1 + 40);
      }
      else
      {
        v53 = 0;
      }
      v54 = v4 + 176;
      *(_DWORD *)(v54 + 12) = v53;
      *(_DWORD *)v54 = v51;
      *(_DWORD *)(v54 + 4) = 0;
      *(_DWORD *)(v54 + 8) = 0;
      v116 = (char *)(v4 + 176);
    }
    v55 = AssetTypeTemplateField::SearchChild(v100, "m_MipBias");
    if ( v55 )
    {
      v56 = (AssetTypeValue *)operator new(0x10u);
      if ( v56 )
      {
        *(_DWORD *)v56 = 10;
        AssetTypeValue::Set(v56, (char *)a1 + 44);
      }
      else
      {
        v57 = 0;
      }
      v58 = v4 + 192;
      *(_DWORD *)(v58 + 12) = v57;
      *(_DWORD *)v58 = v55;
      *(_DWORD *)(v58 + 4) = 0;
      *(_DWORD *)(v58 + 8) = 0;
      v117 = (char *)(v4 + 192);
    }
    v59 = AssetTypeTemplateField::SearchChild(v100, "m_WrapMode");
    if ( v59 )
    {
      v60 = (AssetTypeValue *)operator new(0x10u);
      if ( v60 )
      {
        *(_DWORD *)v60 = 6;
        AssetTypeValue::Set(v60, (char *)a1 + 48);
      }
      else
      {
        v61 = 0;
      }
      v62 = v4 + 208;
      *(_DWORD *)(v62 + 12) = v61;
      *(_DWORD *)v62 = v59;
      *(_DWORD *)(v62 + 4) = 0;
      *(_DWORD *)(v62 + 8) = 0;
      v118 = (char *)(v4 + 208);
    }
  }
  v63 = AssetTypeTemplateField::SearchChild(a2, "m_LightmapFormat");
  if ( v63 )
  {
    v64 = (AssetTypeValue *)operator new(0x10u);
    if ( v64 )
    {
      *(_DWORD *)v64 = 6;
      AssetTypeValue::Set(v64, (char *)a1 + 52);
    }
    else
    {
      v65 = 0;
    }
    v66 = v4 + 224;
    *(_DWORD *)(v66 + 12) = v65;
    *(_DWORD *)v66 = v63;
    *(_DWORD *)(v66 + 4) = 0;
    *(_DWORD *)(v66 + 8) = 0;
    v119 = (char *)(v4 + 224);
  }
  v67 = AssetTypeTemplateField::SearchChild(a2, "m_ColorSpace");
  if ( v67 )
  {
    v68 = (AssetTypeValue *)operator new(0x10u);
    if ( v68 )
    {
      *(_DWORD *)v68 = 6;
      AssetTypeValue::Set(v68, (char *)a1 + 56);
    }
    else
    {
      v69 = 0;
    }
    v70 = v4 + 240;
    *(_DWORD *)(v70 + 12) = v69;
    *(_DWORD *)v70 = v67;
    *(_DWORD *)(v70 + 4) = 0;
    *(_DWORD *)(v70 + 8) = 0;
    v120 = (char *)(v4 + 240);
  }
  v71 = AssetTypeTemplateField::SearchChild(a2, "image data");
  if ( v71 )
  {
    v72 = *((_DWORD *)a1 + 16);
    v100 = (AssetTypeTemplateField *)*((_DWORD *)a1 + 15);
    v101 = v72;
    v73 = (AssetTypeValue *)operator new(0x10u);
    if ( v73 )
    {
      *(_DWORD *)v73 = 14;
      AssetTypeValue::Set(v73, &v100);
    }
    else
    {
      v74 = 0;
    }
    v75 = v4 + 256;
    *(_DWORD *)(v75 + 12) = v74;
    *(_DWORD *)v75 = v71;
    *(_DWORD *)(v75 + 4) = 0;
    *(_DWORD *)(v75 + 8) = 0;
    v121 = (char *)(v4 + 256);
  }
  v99 = 0;
  v76 = AssetTypeTemplateField::SearchChild(a2, "m_StreamData");
  if ( v76 )
  {
    v99 = 1;
    v100 = v76;
    v77 = AssetTypeTemplateField::SearchChild(v76, "offset");
    if ( v77 )
    {
      v78 = (AssetTypeValue *)operator new(0x10u);
      if ( v78 )
      {
        *(_DWORD *)v78 = 7;
        AssetTypeValue::Set(v78, (char *)a1 + 68);
      }
      else
      {
        v79 = 0;
      }
      v80 = v4 + 272;
      *(_DWORD *)(v80 + 12) = v79;
      *(_DWORD *)v80 = v77;
      *(_DWORD *)(v80 + 4) = 0;
      *(_DWORD *)(v80 + 8) = 0;
      v122 = (char *)(v4 + 272);
    }
    v81 = AssetTypeTemplateField::SearchChild(v100, "size");
    if ( v81 )
    {
      v82 = (AssetTypeValue *)operator new(0x10u);
      if ( v82 )
      {
        *(_DWORD *)v82 = 7;
        AssetTypeValue::Set(v82, (char *)a1 + 72);
      }
      else
      {
        v83 = 0;
      }
      v84 = v4 + 288;
      *(_DWORD *)(v84 + 12) = v83;
      *(_DWORD *)v84 = v81;
      *(_DWORD *)(v84 + 4) = 0;
      *(_DWORD *)(v84 + 8) = 0;
      v123 = (char *)(v4 + 288);
    }
    v85 = AssetTypeTemplateField::SearchChild(v100, "path");
    if ( v85 )
    {
      if ( *((_DWORD *)a1 + 19) )
      {
        v88 = (AssetTypeValue *)operator new(0x10u);
        if ( v88 )
        {
          v89 = (void *)*((_DWORD *)a1 + 19);
          *(_DWORD *)v88 = 12;
          AssetTypeValue::Set(v88, v89);
          goto LABEL_108;
        }
      }
      else
      {
        v86 = (AssetTypeValue *)operator new(0x10u);
        if ( v86 )
        {
          *(_DWORD *)v86 = 12;
          AssetTypeValue::Set(v86, &unk_100996C3);
LABEL_108:
          v90 = v4 + 304;
          *(_DWORD *)(v90 + 8) = 0;
          *(_DWORD *)(v90 + 4) = 0;
          *(_DWORD *)v90 = v85;
          *(_DWORD *)(v90 + 12) = v87;
          v124 = (char *)(v4 + 304);
          goto LABEL_109;
        }
      }
      v87 = 0;
      goto LABEL_108;
    }
  }
LABEL_109:
  v91 = 0;
  v92 = v99 != 0 ? 20 : 17;
  if ( v92 <= 0 )
  {
LABEL_115:
    if ( !v99 && !v120 )
    {
      v120 = v121;
      v121 = 0;
      v92 = 16;
    }
    if ( !v112 )
    {
      if ( (unsigned int)v92 > 8 )
        qmemcpy(&v112, &v113, 4 * (v92 - 8));
      *(&v105 + --v92) = 0;
    }
    v100 = a2;
    v101 = v92;
    v103 = 0;
    v102 = &v105;
    v93 = AssetTypeValueField::Write((AssetTypeValueField *)&v100, a3, a4, 0i64);
    v101 = v94;
  }
  else
  {
    while ( *(&v105 + v91) || !v99 && v91 == 15 || v91 == 7 )
    {
      if ( ++v91 >= v92 )
        goto LABEL_115;
    }
    v93 = 0;
    v101 = 0;
  }
  v95 = 0;
  do
  {
    v96 = *(&v105 + v95);
    if ( v96 )
    {
      v97 = *(void **)(v96 + 12);
      if ( v97 )
        operator delete(v97);
    }
    ++v95;
  }
  while ( v95 < 20 );
  operator delete[](v104);
  return v93;
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099190: using guessed type void __cdecl operator delete[](void *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1001C240) --------------------------------------------------------
char __cdecl WriteTextureFile(struct TextureFile *a1, struct AssetTypeValueField *a2)
{
  void *v2; // eax@1
  void *v3; // edi@1
  void *v4; // eax@1
  void *v5; // ebx@1
  void *v6; // eax@1
  void *v7; // eax@1
  void *v8; // eax@1
  void *v9; // eax@1
  void *v10; // eax@1
  void *v11; // eax@1
  void *v12; // eax@1
  _DWORD *v13; // eax@1
  _DWORD *v14; // esi@1
  signed int v15; // eax@1
  bool v16; // al@5
  struct TextureFile *v17; // esi@8
  int v18; // ecx@15
  void *v20; // [sp+Ch] [bp-5Ch]@1
  void *v21; // [sp+10h] [bp-58h]@1
  void *v22; // [sp+14h] [bp-54h]@1
  void *v23; // [sp+18h] [bp-50h]@1
  void *v24; // [sp+1Ch] [bp-4Ch]@1
  void *v25; // [sp+20h] [bp-48h]@1
  void *v26; // [sp+24h] [bp-44h]@1
  void *v27; // [sp+28h] [bp-40h]@1
  void *v28; // [sp+2Ch] [bp-3Ch]@1
  void *v29; // [sp+30h] [bp-38h]@1
  void *v30; // [sp+34h] [bp-34h]@1
  void *v31; // [sp+38h] [bp-30h]@1
  void *v32; // [sp+3Ch] [bp-2Ch]@1
  void *v33; // [sp+40h] [bp-28h]@1
  void *v34; // [sp+44h] [bp-24h]@1
  void *v35; // [sp+48h] [bp-20h]@1
  void *v36; // [sp+4Ch] [bp-1Ch]@1
  void *v37; // [sp+50h] [bp-18h]@1
  void *v38; // [sp+54h] [bp-14h]@1
  void *v39; // [sp+58h] [bp-10h]@1
  void *v40; // [sp+5Ch] [bp-Ch]@1
  int v41; // [sp+60h] [bp-8h]@15
  int v42; // [sp+64h] [bp-4h]@15

  v20 = AssetTypeValueField::operator[]((int)a2, "m_MipCount");
  v21 = AssetTypeValueField::operator[]((int)a2, "m_MipMap");
  v2 = AssetTypeValueField::operator[]((int)a2, "m_ReadAllowed");
  v3 = v2;
  v22 = v2;
  v4 = AssetTypeValueField::operator[]((int)a2, "m_Name");
  v5 = v4;
  v23 = v4;
  v24 = AssetTypeValueField::operator[]((int)a2, "m_Width");
  v25 = AssetTypeValueField::operator[]((int)a2, "m_Height");
  v26 = AssetTypeValueField::operator[]((int)a2, "m_CompleteImageSize");
  v27 = AssetTypeValueField::operator[]((int)a2, "m_TextureFormat");
  v28 = AssetTypeValueField::operator[]((int)a2, "m_IsReadable");
  v29 = AssetTypeValueField::operator[]((int)a2, "m_ImageCount");
  v30 = AssetTypeValueField::operator[]((int)a2, "m_TextureDimension");
  v6 = AssetTypeValueField::operator[]((int)a2, "m_TextureSettings");
  v31 = AssetTypeValueField::operator[]((int)v6, "m_FilterMode");
  v7 = AssetTypeValueField::operator[]((int)a2, "m_TextureSettings");
  v32 = AssetTypeValueField::operator[]((int)v7, "m_Aniso");
  v8 = AssetTypeValueField::operator[]((int)a2, "m_TextureSettings");
  v33 = AssetTypeValueField::operator[]((int)v8, "m_MipBias");
  v9 = AssetTypeValueField::operator[]((int)a2, "m_TextureSettings");
  v34 = AssetTypeValueField::operator[]((int)v9, "m_WrapMode");
  v35 = AssetTypeValueField::operator[]((int)a2, "m_LightmapFormat");
  v36 = AssetTypeValueField::operator[]((int)a2, "m_ColorSpace");
  v37 = AssetTypeValueField::operator[]((int)a2, "image data");
  v10 = AssetTypeValueField::operator[]((int)a2, "m_StreamData");
  v38 = AssetTypeValueField::operator[]((int)v10, "offset");
  v11 = AssetTypeValueField::operator[]((int)a2, "m_StreamData");
  v39 = AssetTypeValueField::operator[]((int)v11, "size");
  v12 = AssetTypeValueField::operator[]((int)a2, "m_StreamData");
  v13 = AssetTypeValueField::operator[]((int)v12, "path");
  v14 = v13;
  v40 = v13;
  v15 = 3;
  do
  {
    if ( *((_DWORD *)*(&v20 + v15) + 1) == -1 && v15 != 16 )
      return 0;
    ++v15;
  }
  while ( v15 < 18 );
  v16 = *((_DWORD *)v39 + 1) == -1;
  if ( (*((_DWORD *)v38 + 1) == -1) != v16 || v16 != (v14[1] == -1) )
    return 0;
  if ( *((_DWORD *)v20 + 1) == -1 )
  {
    if ( *((_DWORD *)v21 + 1) != -1 )
    {
      v17 = a1;
      AssetTypeValue::Set(*((AssetTypeValue **)v21 + 3), (char *)a1 + 24);
      goto LABEL_11;
    }
    return 0;
  }
  v17 = a1;
  AssetTypeValue::Set(*((AssetTypeValue **)v20 + 3), (char *)a1 + 20);
LABEL_11:
  AssetTypeValue::Set(*((AssetTypeValue **)v5 + 3), *(void **)v17);
  AssetTypeValue::Set(*((AssetTypeValue **)v24 + 3), (char *)v17 + 4);
  AssetTypeValue::Set(*((AssetTypeValue **)v25 + 3), (char *)v17 + 8);
  AssetTypeValue::Set(*((AssetTypeValue **)v26 + 3), (char *)v17 + 12);
  AssetTypeValue::Set(*((AssetTypeValue **)v27 + 3), (char *)v17 + 16);
  AssetTypeValue::Set(*((AssetTypeValue **)v28 + 3), (char *)v17 + 25);
  if ( *((_DWORD *)v3 + 1) != -1 )
    AssetTypeValue::Set(*((AssetTypeValue **)v3 + 3), (char *)v17 + 26);
  AssetTypeValue::Set(*((AssetTypeValue **)v29 + 3), (char *)v17 + 28);
  AssetTypeValue::Set(*((AssetTypeValue **)v30 + 3), (char *)v17 + 32);
  AssetTypeValue::Set(*((AssetTypeValue **)v31 + 3), (char *)v17 + 36);
  AssetTypeValue::Set(*((AssetTypeValue **)v32 + 3), (char *)v17 + 40);
  AssetTypeValue::Set(*((AssetTypeValue **)v33 + 3), (char *)v17 + 44);
  AssetTypeValue::Set(*((AssetTypeValue **)v34 + 3), (char *)v17 + 48);
  AssetTypeValue::Set(*((AssetTypeValue **)v35 + 3), (char *)v17 + 52);
  if ( *((_DWORD *)v36 + 1) != -1 )
    AssetTypeValue::Set(*((AssetTypeValue **)v36 + 3), (char *)v17 + 56);
  v18 = *((_DWORD *)v17 + 16);
  v41 = *((_DWORD *)v17 + 15);
  v42 = v18;
  AssetTypeValue::Set(*((AssetTypeValue **)v37 + 3), &v41);
  if ( *((_DWORD *)v38 + 1) != -1 )
  {
    AssetTypeValue::Set(*((AssetTypeValue **)v38 + 3), (char *)v17 + 68);
    AssetTypeValue::Set(*((AssetTypeValue **)v39 + 3), (char *)v17 + 72);
    AssetTypeValue::Set(*((AssetTypeValue **)v40 + 3), *((void **)v17 + 19));
  }
  return 1;
}

//----- (1001C5A0) --------------------------------------------------------
int __fastcall sub_1001C5A0(int a1, int a2)
{
  int result; // eax@1

  *(_DWORD *)(a2 + 8) = 1;
  *(_DWORD *)(a2 + 20) = 1;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  result = 0;
  *(_DWORD *)a2 = 484;
  *(_DWORD *)(a2 + 28) = 11;
  memset((void *)(a2 + 32), 0, 0x180u);
  *(float *)(a2 + 416) = 0.0;
  *(float *)(a2 + 440) = 2.0;
  *(float *)(a2 + 444) = 2.0;
  *(_DWORD *)(a2 + 432) = 0;
  *(_DWORD *)(a2 + 448) = 0;
  *(_DWORD *)(a2 + 452) = 0;
  *(_DWORD *)(a2 + 456) = 0;
  *(_DWORD *)(a2 + 460) = 0;
  *(_DWORD *)(a2 + 464) = 0;
  *(_DWORD *)(a2 + 468) = 0;
  *(_DWORD *)(a2 + 472) = 0;
  *(_DWORD *)(a2 + 476) = 0;
  *(_DWORD *)(a2 + 480) = 0;
  *(_DWORD *)(a2 + 420) = 255;
  *(_DWORD *)(a2 + 424) = 128;
  *(_DWORD *)(a2 + 428) = 4;
  *(_DWORD *)(a2 + 436) = 3;
  return result;
}

//----- (1001C660) --------------------------------------------------------
char __userpurge sub_1001C660@<al>(unsigned int a1@<eax>, int a2, unsigned int a3, unsigned int a4)
{
  char result; // al@2
  unsigned int v5; // edi@3
  unsigned int v6; // eax@6
  unsigned int v7; // ebx@7
  int v8; // eax@7

  if ( *(_DWORD *)(a2 + 8) < a1 )
  {
    v5 = a1;
    if ( (_BYTE)a3 && (!a1 || (a1 - 1) & a1) )
    {
      v6 = ((((a1 - 1) >> 16) | (a1 - 1)) >> 8) | ((a1 - 1) >> 16) | (a1 - 1);
      v5 = ((((v6 >> 4) | v6) >> 2) | (v6 >> 4) | v6 | (((((v6 >> 4) | v6) >> 2) | (v6 >> 4) | v6) >> 1)) + 1;
    }
    v7 = a4 * v5;
    v8 = sub_1001CD90(a4 * v5, (int *)&a3, *(void **)a2);
    if ( v8 )
    {
      *(_DWORD *)a2 = v8;
      if ( a3 <= v7 )
      {
        *(_DWORD *)(a2 + 8) = v5;
        result = 1;
      }
      else
      {
        *(_DWORD *)(a2 + 8) = a3 / a4;
        result = 1;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1001C700) --------------------------------------------------------
char __userpurge sub_1001C700@<al>(int a1@<ecx>, int a2@<esi>, unsigned int a3, unsigned int a4)
{
  int v4; // ebx@1
  unsigned int v5; // eax@3
  int v6; // edx@7
  unsigned int v7; // ecx@7
  _DWORD *v8; // ebx@7
  unsigned int v9; // eax@7
  int v10; // edi@8
  int v11; // edi@14
  unsigned int v12; // edx@19
  unsigned int v13; // ecx@19
  int v14; // eax@22
  signed int v15; // ebx@24
  int v16; // eax@26
  unsigned int v17; // eax@29
  int v18; // ecx@30
  int v19; // edx@31
  unsigned int v20; // edi@33
  signed int v21; // ebx@36
  int v22; // eax@37
  int v23; // eax@41
  unsigned int i; // ebx@45
  unsigned int v25; // eax@47
  char v26; // cl@47
  signed int v27; // edi@47
  int v28; // ecx@47
  int v29; // edx@53
  int v30; // eax@53
  unsigned int v31; // ecx@59
  int v32; // eax@59
  int v33; // eax@61
  unsigned int v34; // eax@62
  int v35; // eax@67
  int v36; // edx@72
  int v38; // [sp+8h] [bp-E4h]@1
  char v39; // [sp+8h] [bp-E4h]@47
  int v40; // [sp+Ch] [bp-E0h]@7
  signed int v41; // [sp+Ch] [bp-E0h]@47
  unsigned int v42; // [sp+10h] [bp-DCh]@7
  unsigned int v43; // [sp+14h] [bp-D8h]@7
  int v44; // [sp+14h] [bp-D8h]@51
  char v45; // [sp+18h] [bp-D4h]@7
  unsigned int v46; // [sp+18h] [bp-D4h]@48
  int v47; // [sp+1Ch] [bp-D0h]@7
  signed int v48; // [sp+1Ch] [bp-D0h]@36
  unsigned int v49; // [sp+1Ch] [bp-D0h]@50
  int v50[16]; // [sp+20h] [bp-CCh]@14
  int v51; // [sp+60h] [bp-8Ch]@14
  int v52; // [sp+64h] [bp-88h]@60
  int v53; // [sp+68h] [bp-84h]@60
  int v54; // [sp+6Ch] [bp-80h]@60
  int v55[13]; // [sp+70h] [bp-7Ch]@60
  int v56[17]; // [sp+A4h] [bp-48h]@3

  v4 = a1;
  v38 = a1;
  if ( !a3 || a4 > 0xB )
    return 0;
  *(_DWORD *)a2 = a3;
  memset(v56, 0, 0x44u);
  v5 = 0;
  if ( a3 )
  {
    do
    {
      if ( *(_BYTE *)(v4 + v5) )
        ++v56[*(_BYTE *)(v4 + v5)];
      ++v5;
    }
    while ( v5 < a3 );
  }
  v6 = 0;
  v7 = 0;
  v8 = (_DWORD *)(a2 + 28);
  v40 = 0;
  v42 = 0;
  v43 = -1;
  v9 = 1;
  v45 = 15;
  v47 = a2 + 28;
  do
  {
    v10 = v56[v9];
    if ( v10 )
    {
      if ( v43 >= v9 )
        v43 = v9;
      if ( v42 <= v9 )
        v42 = v9;
      *(&v51 + v9) = v6;
      v50[v9] = v40;
      v8 = (_DWORD *)v47;
      *(_DWORD *)v47 = (((1 << v45) - 1) | ((v10 + v6 - 1) << (16 - v9))) + 1;
      v11 = v56[v9];
      *(_DWORD *)(v47 + 68) = v40;
      v6 += v11;
      v7 = v11 + v40;
      v40 += v11;
    }
    else
    {
      *v8 = 0;
    }
    --v45;
    ++v9;
    ++v8;
    v6 *= 2;
    v47 = (int)v8;
  }
  while ( v9 <= 0x10 );
  *(_DWORD *)(a2 + 4) = v7;
  if ( v7 > *(_DWORD *)(a2 + 172) )
  {
    *(_DWORD *)(a2 + 172) = v7;
    if ( !v7 || (v7 - 1) & v7 )
    {
      v12 = ((((v7 - 1) | ((v7 - 1) >> 16)) >> 8) | (v7 - 1) | ((v7 - 1) >> 16)) >> 4;
      v13 = (((v12 | (((v7 - 1) | ((v7 - 1) >> 16)) >> 8) | (v7 - 1) | ((v7 - 1) >> 16)) >> 2) | v12 | (((v7 - 1) | ((v7 - 1) >> 16)) >> 8) | (v7 - 1) | ((v7 - 1) >> 16) | ((((v12 | (((v7 - 1) | ((v7 - 1) >> 16)) >> 8) | (v7 - 1) | ((v7 - 1) >> 16)) >> 2) | v12 | (((v7 - 1) | ((v7 - 1) >> 16)) >> 8) | (v7 - 1) | ((v7 - 1) >> 16)) >> 1))
          + 1;
      if ( a3 < v13 )
        v13 = a3;
      *(_DWORD *)(a2 + 172) = v13;
    }
    v14 = *(_DWORD *)(a2 + 176);
    if ( v14 )
      sub_1001CE80((void *)(v14 - 8));
    v15 = *(_DWORD *)(a2 + 172);
    if ( !v15 )
      v15 = 1;
    v16 = sub_1001CCB0(0, 2 * v15 + 8);
    if ( v16 )
    {
      v16 += 8;
      *(_DWORD *)(v16 - 4) = v15;
      *(_DWORD *)(v16 - 8) = ~v15;
    }
    *(_DWORD *)(a2 + 176) = v16;
    if ( !v16 )
      return 0;
  }
  *(_BYTE *)(a2 + 24) = v43;
  v17 = 0;
  *(_BYTE *)(a2 + 25) = v42;
  if ( a3 )
  {
    do
    {
      v18 = *(_BYTE *)(v38 + v17);
      if ( *(_BYTE *)(v38 + v17) )
      {
        v19 = v50[v18];
        v50[v18] = v19 + 1;
        *(_WORD *)(*(_DWORD *)(a2 + 176) + 2 * v19) = v17;
      }
      ++v17;
    }
    while ( v17 < a3 );
  }
  v20 = a4;
  if ( a4 <= *(_BYTE *)(a2 + 24) )
  {
    a4 = 0;
    v20 = 0;
  }
  *(_DWORD *)(a2 + 8) = v20;
  if ( !v20 )
    goto LABEL_59;
  v21 = 1 << v20;
  v48 = 1 << v20;
  if ( (unsigned int)(1 << v20) > *(_DWORD *)(a2 + 164) )
  {
    v22 = *(_DWORD *)(a2 + 168);
    *(_DWORD *)(a2 + 164) = v21;
    if ( v22 )
      sub_1001CE80((void *)(v22 - 8));
    if ( !v48 )
      v21 = 1;
    v23 = sub_1001CCB0(0, 4 * v21 + 8);
    if ( v23 )
    {
      v23 += 8;
      *(_DWORD *)(v23 - 4) = v21;
      *(_DWORD *)(v23 - 8) = ~v21;
    }
    *(_DWORD *)(a2 + 168) = v23;
    if ( v23 )
    {
      v20 = a4;
      v21 = v48;
      goto LABEL_45;
    }
    return 0;
  }
LABEL_45:
  memset(*(void **)(a2 + 168), 255, 4 * v21);
  for ( i = 1; i <= v20; ++i )
  {
    if ( v56[i] )
    {
      v25 = *(&v51 + i);
      v26 = v20 - i;
      v27 = 1 << (v20 - i);
      v39 = v26;
      v28 = *(_DWORD *)(a2 + 4 * i + 24);
      v41 = v27;
      if ( v28 )
        v46 = (unsigned int)(v28 - 1) >> (16 - i);
      else
        v46 = -1;
      v49 = *(&v51 + i);
      if ( v25 <= v46 )
      {
        v44 = 2 * *(_DWORD *)(a2 + 4 * i + 92);
        do
        {
          if ( v27 )
          {
            v29 = *(_WORD *)(*(_DWORD *)(a2 + 176) + v44) | (i << 16);
            v30 = 4 * (v25 << v39);
            do
            {
              *(_DWORD *)(*(_DWORD *)(a2 + 168) + v30) = v29;
              v30 += 4;
              --v27;
            }
            while ( v27 );
            v25 = v49;
            v27 = v41;
          }
          v44 += 2;
          v49 = ++v25;
        }
        while ( v25 <= v46 );
      }
      v20 = a4;
    }
  }
LABEL_59:
  v31 = 0;
  v32 = a2 + 100;
  do
  {
    *(_DWORD *)(v32 - 4) -= *(&v52 + v31);
    *(_DWORD *)v32 -= *(&v53 + v31);
    *(_DWORD *)(v32 + 4) -= *(&v54 + v31);
    *(_DWORD *)(v32 + 8) -= v55[v31];
    v31 += 4;
    v32 += 16;
  }
  while ( v31 < 0x10 );
  v33 = *(_BYTE *)(a2 + 24);
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v33;
  if ( v20 )
  {
    v34 = v20;
    if ( v20 >= 1 )
    {
      while ( !v56[v34] )
      {
        if ( --v34 < 1 )
          goto LABEL_72;
      }
      *(_DWORD *)(a2 + 16) = *(_DWORD *)(a2 + 4 * v34 + 24);
      if ( v34 >= 1 )
      {
        v35 = v20 + 1;
        *(_DWORD *)(a2 + 20) = v20 + 1;
        if ( v20 + 1 <= v42 )
        {
          while ( !v56[v35] )
          {
            if ( ++v35 > v42 )
              goto LABEL_72;
          }
          *(_DWORD *)(a2 + 20) = v35;
        }
      }
    }
  }
LABEL_72:
  v36 = 32 - *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 92) = -1;
  *(_DWORD *)(a2 + 160) = 0xFFFFF;
  *(_DWORD *)(a2 + 12) = v36;
  return 1;
}
// 1001C700: using guessed type int var_48[17];
// 1001C700: using guessed type int var_CC[16];
// 1001C700: using guessed type int var_7C[13];

//----- (1001CB90) --------------------------------------------------------
void *__cdecl sub_1001CB90(void *a1, size_t a2, int a3, char a4)
{
  void *v4; // edi@1
  void *result; // eax@2
  void *v6; // esi@2
  void *v7; // esi@9

  v4 = a1;
  if ( a1 )
  {
    if ( a2 )
    {
      v7 = expand(a1, a2);
      if ( v7 || a4 && (v7 = realloc(a1, a2)) != 0 )
        v4 = v7;
      if ( a3 )
        *(_DWORD *)a3 = msize(v4);
      result = v7;
    }
    else
    {
      free(a1);
      result = 0;
      if ( a3 )
        *(_DWORD *)a3 = 0;
    }
  }
  else
  {
    result = malloc(a2);
    v6 = result;
    if ( a3 )
    {
      if ( result )
      {
        *(_DWORD *)a3 = msize(result);
        result = v6;
      }
      else
      {
        *(_DWORD *)a3 = 0;
        result = 0;
      }
    }
  }
  return result;
}

//----- (1001CC40) --------------------------------------------------------
size_t __cdecl sub_1001CC40(void *a1)
{
  size_t result; // eax@2

  if ( a1 )
    result = msize(a1);
  else
    result = 0;
  return result;
}

//----- (1001CC60) --------------------------------------------------------
int (*sub_1001CC60())()
{
  int (*result)(); // eax@1

  result = sub_10092BC0;
  if ( sub_10092BC0 && sub_10092B90 )
  {
    off_100ADB84 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))sub_10092BC0;
    off_100ADB88 = (int (__cdecl *)(void *))sub_10092B90;
    dword_100AE9EC = 0;
  }
  else
  {
    off_100ADB84 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))sub_1001CB90;
    off_100ADB88 = (int (__cdecl *)(void *))sub_1001CC40;
    dword_100AE9EC = 0;
  }
  return result;
}
// 10092B90: using guessed type int sub_10092B90();
// 10092BC0: using guessed type int sub_10092BC0();
// 100ADB84: using guessed type int (__cdecl *off_100ADB84)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100ADB88: using guessed type int (__cdecl *off_100ADB88)(void *);
// 100AE9EC: using guessed type int dword_100AE9EC;

//----- (1001CCB0) --------------------------------------------------------
int __usercall sub_1001CCB0@<eax>(int *a1@<edi>, int a2)
{
  unsigned int v2; // esi@1
  int result; // eax@3
  unsigned int v4; // ecx@3
  int v5; // [sp+4h] [bp-208h]@3
  char DstBuf; // [sp+8h] [bp-204h]@7

  v2 = (a2 + 3) & 0xFFFFFFFC;
  if ( v2 )
  {
    if ( v2 > 0x7FFF0000 )
    {
      sprintf_s(
        &DstBuf,
        0x200u,
        "%s(%u): Assertion failure: \"%s\"\n",
        "J:\\Programme\\SDKs\\crunch-104\\inc\\crn_decomp.h",
        2502,
        "crnd_malloc: size too big");
      puts(&DstBuf);
      goto LABEL_8;
    }
  }
  else
  {
    v2 = 4;
  }
  v5 = v2;
  result = off_100ADB84(0, v2, &v5, 1, dword_100AE9EC);
  v4 = v5;
  if ( a1 )
    *a1 = v5;
  if ( !result || v4 < v2 )
  {
    sprintf_s(
      &DstBuf,
      0x200u,
      "%s(%u): Assertion failure: \"%s\"\n",
      "J:\\Programme\\SDKs\\crunch-104\\inc\\crn_decomp.h",
      2502,
      "crnd_malloc: out of memory");
    puts(&DstBuf);
LABEL_8:
    result = 0;
  }
  return result;
}
// 100ADB84: using guessed type int (__cdecl *off_100ADB84)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9EC: using guessed type int dword_100AE9EC;

//----- (1001CD90) --------------------------------------------------------
int __usercall sub_1001CD90@<eax>(size_t a1@<ecx>, int *a2@<esi>, void *a3)
{
  int result; // eax@2
  int v4; // [sp+0h] [bp-208h]@5
  char DstBuf; // [sp+4h] [bp-204h]@2

  if ( (unsigned __int8)a3 & 7 )
  {
    sprintf_s(
      &DstBuf,
      0x200u,
      "%s(%u): Assertion failure: \"%s\"\n",
      "J:\\Programme\\SDKs\\crunch-104\\inc\\crn_decomp.h",
      2502,
      "crnd_realloc: bad ptr");
    puts(&DstBuf);
    result = 0;
  }
  else if ( a1 <= 0x7FFF0000 )
  {
    v4 = a1;
    result = off_100ADB84(a3, a1, &v4, 1, dword_100AE9EC);
    if ( a2 )
      *a2 = v4;
  }
  else
  {
    sprintf_s(
      &DstBuf,
      0x200u,
      "%s(%u): Assertion failure: \"%s\"\n",
      "J:\\Programme\\SDKs\\crunch-104\\inc\\crn_decomp.h",
      2502,
      "crnd_malloc: size too big");
    puts(&DstBuf);
    result = 0;
  }
  return result;
}
// 100ADB84: using guessed type int (__cdecl *off_100ADB84)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9EC: using guessed type int dword_100AE9EC;

//----- (1001CE80) --------------------------------------------------------
void *__cdecl sub_1001CE80(void *a1)
{
  void *result; // eax@1
  char DstBuf; // [sp+0h] [bp-204h]@3

  result = a1;
  if ( a1 )
  {
    if ( (unsigned __int8)a1 & 7 )
    {
      sprintf_s(
        &DstBuf,
        0x200u,
        "%s(%u): Assertion failure: \"%s\"\n",
        "J:\\Programme\\SDKs\\crunch-104\\inc\\crn_decomp.h",
        2502,
        "crnd_free: bad ptr");
      result = (void *)puts(&DstBuf);
    }
    else
    {
      result = (void *)off_100ADB84(a1, 0, 0, 1, dword_100AE9EC);
    }
  }
  return result;
}
// 100ADB84: using guessed type int (__cdecl *off_100ADB84)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9EC: using guessed type int dword_100AE9EC;

//----- (1001CF10) --------------------------------------------------------
signed int __usercall sub_1001CF10@<eax>(int a1@<eax>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
    case 9:
    case 10:
      result = 8;
      break;
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      result = 16;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (1001CF60) --------------------------------------------------------
int __usercall sub_1001CF60@<eax>(int result@<eax>, unsigned int a2@<edx>)
{
  if ( a2 >= 0x4A )
  {
    if ( (*(_BYTE *)(result + 1) | (*(_BYTE *)result << 8)) != 18552
      || (*(_BYTE *)(result + 3) | ((unsigned int)*(_BYTE *)(result + 2) << 8)) < 0x4A
      || a2 < (*(_BYTE *)(result + 9) | ((*(_BYTE *)(result + 8) | (((*(_BYTE *)(result + 6) << 8) | (unsigned int)*(_BYTE *)(result + 7)) << 8)) << 8)) )
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001CFC0) --------------------------------------------------------
char __usercall sub_1001CFC0@<al>(unsigned int a1@<edx>, int a2@<edi>, int a3)
{
  char result; // al@5
  int v4; // eax@6
  int v5; // esi@6
  int v6; // eax@8
  bool v7; // zf@9
  signed int v8; // eax@9

  if ( a3 && a1 >= 0x4A && a2 && *(_DWORD *)a2 == 36 )
  {
    v4 = sub_1001CF60(a3, a1);
    v5 = v4;
    if ( v4 )
    {
      *(_DWORD *)(a2 + 4) = *(_BYTE *)(v4 + 13) | (*(_BYTE *)(v4 + 12) << 8);
      *(_DWORD *)(a2 + 8) = *(_BYTE *)(v4 + 15) | (*(_BYTE *)(v4 + 14) << 8);
      *(_DWORD *)(a2 + 12) = *(_BYTE *)(v4 + 16);
      *(_DWORD *)(a2 + 16) = *(_BYTE *)(v4 + 17);
      *(_DWORD *)(a2 + 32) = *(_BYTE *)(v4 + 18);
      v6 = *(_BYTE *)(v4 + 18);
      if ( !*(_BYTE *)(v5 + 18) || (v7 = v6 == 9, v8 = 16, v7) )
        v8 = 8;
      *(_DWORD *)(a2 + 20) = v8;
      *(_DWORD *)(a2 + 24) = sub_100216A0(v5 + 25);
      *(_DWORD *)(a2 + 28) = sub_100216A0(v5 + 29);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001D0B0) --------------------------------------------------------
void __thiscall sub_1001D0B0(void *this)
{
  void *v1; // esi@1
  int v2; // edi@1
  int v3; // eax@2
  int v4; // eax@4

  v1 = this;
  v2 = *((_DWORD *)this + 5);
  if ( v2 )
  {
    v3 = *(_DWORD *)(v2 + 168);
    if ( v3 )
      sub_1001CE80((void *)(v3 - 8));
    v4 = *(_DWORD *)(v2 + 176);
    if ( v4 )
      sub_1001CE80((void *)(v4 - 8));
    sub_1001CE80((void *)v2);
  }
  if ( *((_DWORD *)v1 + 1) )
  {
    sub_1001CE80(*((void **)v1 + 1));
    *((_DWORD *)v1 + 1) = 0;
    *((_DWORD *)v1 + 2) = 0;
    *((_DWORD *)v1 + 3) = 0;
  }
  *((_BYTE *)v1 + 16) = 0;
}

//----- (1001D160) --------------------------------------------------------
void *__usercall sub_1001D160@<eax>(int a1@<esi>)
{
  void *result; // eax@1
  int v2; // edi@3
  int v3; // eax@4
  int v4; // eax@6

  *(_DWORD *)a1 = 0;
  result = *(void **)(a1 + 4);
  if ( result )
  {
    result = sub_1001CE80(*(void **)(a1 + 4));
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 12) = 0;
  }
  *(_BYTE *)(a1 + 16) = 0;
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 )
  {
    v3 = *(_DWORD *)(v2 + 168);
    if ( v3 )
      sub_1001CE80((void *)(v3 - 8));
    v4 = *(_DWORD *)(v2 + 176);
    if ( v4 )
      sub_1001CE80((void *)(v4 - 8));
    result = sub_1001CE80((void *)v2);
    *(_DWORD *)(a1 + 20) = 0;
  }
  return result;
}

//----- (1001D1D0) --------------------------------------------------------
char __usercall sub_1001D1D0@<al>(int a1@<ebx>)
{
  int v1; // eax@2
  unsigned int v2; // edx@6
  unsigned int v3; // eax@6
  int v4; // ecx@7
  unsigned int v5; // eax@7
  int v6; // eax@9

  *(_DWORD *)a1 = *(_DWORD *)(a1 + 8);
  if ( !*(_DWORD *)(a1 + 20) )
  {
    v1 = sub_1001CCB0(0, 180);
    if ( v1 )
    {
      *(_DWORD *)(v1 + 164) = 0;
      *(_DWORD *)(v1 + 168) = 0;
      *(_DWORD *)(v1 + 172) = 0;
      *(_DWORD *)(v1 + 176) = 0;
    }
    else
    {
      v1 = 0;
    }
    *(_DWORD *)(a1 + 20) = v1;
  }
  v2 = *(_DWORD *)a1;
  v3 = 0;
  if ( *(_DWORD *)a1 > 0x10u )
  {
    v4 = 0;
    v5 = *(_DWORD *)a1;
    if ( v2 > 1 )
    {
      do
      {
        v5 >>= 1;
        ++v4;
      }
      while ( v5 > 1 );
    }
    v6 = v4;
    if ( v4 != 32 && v2 > 1 << v4 )
      v6 = v4 + 1;
    v3 = v6 + 1;
    if ( v3 >= 0xB )
      LOBYTE(v3) = 11;
    v3 = (unsigned __int8)v3;
  }
  return sub_1001C700(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 20), v2, v3);
}

//----- (1001D260) --------------------------------------------------------
char __stdcall sub_1001D260(int a1, int a2)
{
  unsigned int v2; // ecx@1
  unsigned int v3; // eax@1
  int v4; // ebx@5
  int v5; // esi@5
  int v6; // edx@5
  int v7; // ecx@5
  unsigned int v8; // ecx@5
  int v9; // esi@5
  int v10; // edx@6
  int v12; // ecx@10
  unsigned int v13; // ebx@10
  int v14; // ecx@11
  unsigned int v15; // esi@14
  char v16; // al@15
  int v17; // edx@15
  unsigned int i; // ecx@16
  unsigned int v19; // ebx@17
  int v20; // esi@17
  unsigned int v21; // edi@18
  unsigned int v22; // eax@18
  int v23; // edx@18
  int v24; // ecx@18
  unsigned int v25; // eax@21
  unsigned int v26; // eax@24
  unsigned int v27; // ecx@28
  char v28; // al@31
  char v29; // bl@36
  int v30; // [sp+14h] [bp-2Ch]@11
  int v31; // [sp+18h] [bp-28h]@11
  int v32; // [sp+1Ch] [bp-24h]@11
  int v33; // [sp+20h] [bp-20h]@11
  char v34; // [sp+24h] [bp-1Ch]@11
  int v35; // [sp+28h] [bp-18h]@11
  _DWORD *v36; // [sp+2Ch] [bp-14h]@9
  int v37; // [sp+30h] [bp-10h]@5
  int v38; // [sp+3Ch] [bp-4h]@11

  v2 = 0x2000;
  v3 = 0;
  do
  {
    ++v3;
    v2 >>= 1;
  }
  while ( v2 );
  if ( !v3
    || (v3 <= 0x10 ? (v37 = sub_1001D4B0(0, a1, v3), v9 = v37, v4 = v10) : (v4 = a1,
                                                                            v5 = sub_1001D4B0(0, a1, v3 - 16),
                                                                            v9 = sub_1001D4B0(v7, v6, 16) | (v5 << 16),
                                                                            v37 = v9),
        !v9) )
  {
    sub_1001D160(a2);
    return 1;
  }
  v36 = (_DWORD *)(a2 + 4);
  if ( !sub_100216E0(v8, a2 + 4, v9) )
    return 0;
  memset(*(void **)(a2 + 4), 0, v9);
  v13 = sub_1001D4B0(v12, v4, 5);
  if ( v13 - 1 > 0x14 )
    return 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v38 = 0;
  if ( !sub_100216E0(v13 - 1, (int)&v31, 0x15u) )
    goto LABEL_12;
  v15 = 0;
  if ( v13 )
  {
    do
    {
      v16 = sub_1001D4B0(v14, a1, 3);
      v17 = (unsigned __int8)byte_100A15E8[v15];
      v14 = v31;
      ++v15;
      *(_BYTE *)(v17 + v31) = v16;
    }
    while ( v15 < v13 );
  }
  if ( !sub_1001D1D0((int)&v30) )
    goto LABEL_12;
  v19 = v37;
  v20 = 0;
  if ( v37 )
  {
    do
    {
      v21 = v19 - v20;
      v22 = sub_1001D510(i, a1, (int)&v30);
      if ( v22 > 0x10 )
      {
        if ( v22 == 17 )
        {
          v25 = sub_1001D4B0(v24, v23, 3) + 3;
          if ( v25 > v21 )
            goto LABEL_12;
          v20 += v25;
        }
        else if ( v22 == 18 )
        {
          v26 = sub_1001D4B0(v24, v23, 7) + 11;
          if ( v26 > v21 )
            goto LABEL_12;
          v20 += v26;
        }
        else
        {
          if ( v22 == 19 )
          {
            v27 = sub_1001D4B0(v24, v23, 2) + 3;
          }
          else
          {
            if ( v22 != 20 )
              goto LABEL_12;
            v27 = sub_1001D4B0(v24, v23, 6) + 7;
          }
          if ( !v20 )
            goto LABEL_12;
          if ( v27 > v21 )
            goto LABEL_12;
          v28 = *(_BYTE *)(*v36 + v20 - 1);
          if ( !*(_BYTE *)(*v36 + v20 - 1) )
            goto LABEL_12;
          for ( i = v20 + v27; v20 < i; ++v20 )
            *(_BYTE *)(v20 + *v36) = v28;
        }
      }
      else
      {
        i = (unsigned int)v36;
        *(_BYTE *)(v20++ + *v36) = v22;
      }
    }
    while ( v20 < v19 );
  }
  if ( v20 != v19 )
  {
LABEL_12:
    v38 = -1;
    sub_1001D0B0(&v30);
    return 0;
  }
  v29 = sub_1001D1D0(a2);
  v38 = -1;
  sub_1001D0B0(&v30);
  return v29;
}

//----- (1001D4B0) --------------------------------------------------------
int __fastcall sub_1001D4B0(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // edi@1
  _BYTE *v5; // edi@2
  int v6; // ebx@2
  int v7; // eax@3
  int result; // eax@7
  int v9; // esi@7

  v3 = *(_DWORD *)(a2 + 20);
  v4 = a3;
  if ( v3 < a3 )
  {
    v5 = *(_BYTE **)(a2 + 4);
    v6 = *(_DWORD *)(a2 + 16);
    do
    {
      v7 = 0;
      if ( v5 != *(_BYTE **)(a2 + 8) )
      {
        v7 = *v5++;
        *(_DWORD *)(a2 + 4) = v5;
      }
      v3 += 8;
      *(_DWORD *)(a2 + 20) = v3;
      v6 |= v7 << (32 - v3);
      *(_DWORD *)(a2 + 16) = v6;
    }
    while ( v3 < a3 );
    v4 = a3;
  }
  result = *(_DWORD *)(a2 + 16) >> (32 - v4);
  v9 = *(_DWORD *)(a2 + 16) << v4;
  *(_DWORD *)(a2 + 20) -= v4;
  *(_DWORD *)(a2 + 16) = v9;
  return result;
}

//----- (1001D510) --------------------------------------------------------
int __fastcall sub_1001D510(int a1, int a2, int a3)
{
  int v3; // ebx@1
  signed int v4; // esi@1
  _BYTE *v5; // ecx@2
  unsigned int v6; // edi@3
  int v7; // eax@3
  int v8; // edi@5
  int v9; // esi@5
  int v10; // eax@5
  unsigned int v11; // edi@12
  unsigned int v12; // eax@12
  int result; // eax@13
  int v14; // ecx@13
  int v15; // esi@14
  unsigned int *i; // ecx@14
  unsigned int v17; // eax@16

  v3 = *(_DWORD *)(a3 + 20);
  v4 = *(_DWORD *)(a2 + 20);
  if ( v4 < 24 )
  {
    v5 = *(_BYTE **)(a2 + 4);
    if ( v4 >= 16 )
    {
      if ( (unsigned int)v5 >= *(_DWORD *)(a2 + 8) )
      {
        v10 = 0;
      }
      else
      {
        v10 = *v5;
        *(_DWORD *)(a2 + 4) = v5 + 1;
      }
      v9 = v4 + 8;
    }
    else
    {
      v6 = *(_DWORD *)(a2 + 8);
      v7 = 0;
      if ( (unsigned int)v5 >= v6 || (v7 = *v5, ++v5, (unsigned int)v5 >= v6) )
      {
        v9 = v4 + 16;
        *(_DWORD *)(a2 + 4) = v5;
        v10 = v7 << 8;
      }
      else
      {
        v8 = *v5;
        v9 = v4 + 16;
        *(_DWORD *)(a2 + 4) = v5 + 1;
        v10 = v8 | (v7 << 8);
      }
    }
    *(_DWORD *)(a2 + 20) = v9;
    *(_DWORD *)(a2 + 16) |= v10 << (32 - v9);
  }
  v11 = *(_DWORD *)(a2 + 16);
  v12 = (*(_DWORD *)(a2 + 16) >> 16) + 1;
  if ( v12 > *(_DWORD *)(v3 + 16) )
  {
    v15 = *(_DWORD *)(v3 + 20);
    for ( i = (unsigned int *)(v3 + 4 * v15 + 24); v12 > *i; ++v15 )
      ++i;
    v17 = *(_DWORD *)(v3 + 4 * v15 + 92) + (v11 >> (32 - v15));
    if ( v17 < *(_DWORD *)a3 )
    {
      result = *(_WORD *)(*(_DWORD *)(v3 + 176) + 2 * v17);
      *(_DWORD *)(a2 + 20) -= v15;
      *(_DWORD *)(a2 + 16) = v11 << v15;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = (unsigned __int16)*(_DWORD *)(*(_DWORD *)(v3 + 168) + 4 * (v11 >> (32 - *(_BYTE *)(v3 + 8))));
    v14 = *(_DWORD *)(*(_DWORD *)(v3 + 168) + 4 * (v11 >> (32 - *(_BYTE *)(v3 + 8)))) >> 16;
    *(_DWORD *)(a2 + 20) -= v14;
    *(_DWORD *)(a2 + 16) = v11 << v14;
  }
  return result;
}

//----- (1001D620) --------------------------------------------------------
int __stdcall sub_1001D620(int a1)
{
  *(_DWORD *)a1 = 519686845;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 92) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 116) = 0;
  *(_DWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(_BYTE *)(a1 + 132) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  `eh vector constructor iterator'((void *)(a1 + 140), 0x18u, 2, (int)sub_1001D090, sub_1001D0B0);
  `eh vector constructor iterator'((void *)(a1 + 188), 0x18u, 2, (int)sub_1001D090, sub_1001D0B0);
  *(_DWORD *)(a1 + 236) = 0;
  *(_DWORD *)(a1 + 240) = 0;
  *(_DWORD *)(a1 + 244) = 0;
  *(_BYTE *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 252) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 260) = 0;
  *(_BYTE *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 268) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 276) = 0;
  *(_BYTE *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 284) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 292) = 0;
  *(_BYTE *)(a1 + 296) = 0;
  return a1;
}
// 1001D090: using guessed type int sub_1001D090();

//----- (1001D740) --------------------------------------------------------
void __stdcall sub_1001D740(int a1)
{
  *(_DWORD *)a1 = 0;
  if ( *(_DWORD *)(a1 + 284) )
  {
    sub_1001CE80(*(void **)(a1 + 284));
    *(_DWORD *)(a1 + 284) = 0;
    *(_DWORD *)(a1 + 288) = 0;
    *(_DWORD *)(a1 + 292) = 0;
  }
  *(_BYTE *)(a1 + 296) = 0;
  if ( *(_DWORD *)(a1 + 268) )
  {
    sub_1001CE80(*(void **)(a1 + 268));
    *(_DWORD *)(a1 + 268) = 0;
    *(_DWORD *)(a1 + 272) = 0;
    *(_DWORD *)(a1 + 276) = 0;
  }
  *(_BYTE *)(a1 + 280) = 0;
  if ( *(_DWORD *)(a1 + 252) )
  {
    sub_1001CE80(*(void **)(a1 + 252));
    *(_DWORD *)(a1 + 252) = 0;
    *(_DWORD *)(a1 + 256) = 0;
    *(_DWORD *)(a1 + 260) = 0;
  }
  *(_BYTE *)(a1 + 264) = 0;
  if ( *(_DWORD *)(a1 + 236) )
  {
    sub_1001CE80(*(void **)(a1 + 236));
    *(_DWORD *)(a1 + 236) = 0;
    *(_DWORD *)(a1 + 240) = 0;
    *(_DWORD *)(a1 + 244) = 0;
  }
  *(_BYTE *)(a1 + 248) = 0;
  `eh vector destructor iterator'((void *)(a1 + 188), 0x18u, 2, sub_1001D0B0);
  `eh vector destructor iterator'((void *)(a1 + 140), 0x18u, 2, sub_1001D0B0);
  sub_1001D0B0((void *)(a1 + 116));
}

//----- (1001D880) --------------------------------------------------------
bool __usercall sub_1001D880@<al>(unsigned int a1@<eax>, unsigned int a2@<edx>, int a3@<edi>)
{
  unsigned int v3; // esi@1
  int v4; // eax@2
  bool result; // al@5

  v3 = a1;
  if ( a3 )
    v4 = sub_1001CF60(a3, a2);
  else
    v4 = 0;
  *(_DWORD *)(v3 + 88) = v4;
  if ( v4 && (*(_DWORD *)(v3 + 4) = a3, *(_DWORD *)(v3 + 8) = a2, sub_1001DAC0(v3)) )
    result = sub_1001DBC0(v3) != 0;
  else
    result = 0;
  return result;
}

//----- (1001D8C0) --------------------------------------------------------
bool __userpurge sub_1001D8C0@<al>(int a1@<eax>, int a2, unsigned int a3, unsigned int a4)
{
  int v4; // edi@1
  int v5; // ecx@1
  int v6; // eax@1
  int v7; // edx@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 88);
  v6 = *(_BYTE *)(v5 + 73) | ((*(_BYTE *)(v5 + 72) | (((*(_BYTE *)(v5 + 70) << 8) | *(_BYTE *)(v5 + 71)) << 8)) << 8);
  v7 = *(_DWORD *)(v4 + 8);
  if ( *(_BYTE *)(v5 + 16) > 1u )
    v7 = *(_BYTE *)(v5 + 77) | ((*(_BYTE *)(v5 + 76) | ((*(_BYTE *)(v5 + 75) | (*(_BYTE *)(v5 + 74) << 8)) << 8)) << 8);
  return sub_1001D940(v4, v6 + *(_DWORD *)(v4 + 4), v7 - v6, a2, a3, a4);
}

//----- (1001D940) --------------------------------------------------------
bool __userpurge sub_1001D940@<al>(int a1@<edi>, int a2, int a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // ecx@1
  unsigned int v7; // ebx@1
  unsigned int v8; // eax@1
  unsigned int v9; // edx@3
  unsigned int v10; // eax@5
  unsigned int v11; // esi@5
  bool v12; // zf@6
  signed int v13; // ecx@6
  unsigned int v14; // ecx@8
  signed int v15; // edx@13
  bool result; // al@15
  unsigned int v17; // [sp+1Ch] [bp+14h]@13

  v6 = *(_DWORD *)(a1 + 88);
  v7 = a6;
  v8 = *(_BYTE *)(v6 + 13) | (*(_BYTE *)(v6 + 12) << 8);
  if ( v8 <= 1 )
    v8 = 1;
  v9 = *(_BYTE *)(v6 + 15) | (*(_BYTE *)(v6 + 14) << 8);
  if ( v9 <= 1 )
    v9 = 1;
  v10 = (v8 + 3) >> 2;
  v11 = (v9 + 3) >> 2;
  if ( !*(_BYTE *)(v6 + 18) || (v12 = *(_BYTE *)(v6 + 18) == 9, v13 = 16, v12) )
    v13 = 8;
  v14 = v10 * v13;
  if ( a6 )
  {
    if ( a6 < v14 || a6 & 3 )
      return 0;
  }
  else
  {
    v7 = v14;
    a6 = v14;
  }
  if ( a5 < v7 * v11 )
    return 0;
  v17 = (v11 + 1) >> 1;
  v15 = (v10 + 1) >> 1;
  if ( !a3 )
    return 0;
  *(_DWORD *)(a1 + 92) = a2;
  *(_DWORD *)(a1 + 96) = a2;
  *(_DWORD *)(a1 + 100) = a3 + a2;
  *(_DWORD *)(a1 + 104) = a3;
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  switch ( *(_BYTE *)(*(_DWORD *)(a1 + 88) + 18) )
  {
    case 0:
      result = sub_1001E6B0(a6, v15, a1, a4, v10, v11, v17) != 0;
      break;
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      result = sub_1001EA50(a6, v15, a1, a4, v10, v11, v17) != 0;
      break;
    case 9:
      result = sub_1001F160(a4, a6, a1, v10, v11, (v10 + 1) >> 1, v17) != 0;
      break;
    case 7:
    case 8:
      result = sub_1001EDD0(a6, v15, a1, a4, v10, v11, v17) != 0;
      break;
    default:
      return 0;
  }
  return result;
}

//----- (1001DAC0) --------------------------------------------------------
bool __usercall sub_1001DAC0@<al>(int a1@<eax>)
{
  int v1; // edi@1
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // edx@1
  int *v5; // esi@1
  int v6; // eax@3
  bool result; // al@11

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 88);
  v3 = *(_BYTE *)(v2 + 66) | (*(_BYTE *)(v2 + 65) << 8);
  v4 = (*(_BYTE *)(v2 + 69) | ((*(_BYTE *)(v2 + 68) | (*(_BYTE *)(v2 + 67) << 8)) << 8)) + *(_DWORD *)(a1 + 4);
  v5 = (int *)(a1 + 92);
  result = v3
        && (*(_DWORD *)(a1 + 108) = 0,
            *(_DWORD *)(a1 + 112) = 0,
            *v5 = v4,
            *(_DWORD *)(a1 + 96) = v4,
            *(_DWORD *)(a1 + 104) = v3,
            *(_DWORD *)(a1 + 100) = v3 + v4,
            sub_1001D260(a1 + 92, a1 + 116))
        && ((v6 = *(_DWORD *)(v1 + 88), *(_BYTE *)(v6 + 40) | (*(_BYTE *)(v6 + 39) << 8))
         || *(_BYTE *)(v6 + 56) | (*(_BYTE *)(v6 + 55) << 8))
        && (!(*(_BYTE *)(v6 + 40) | (*(_BYTE *)(v6 + 39) << 8))
         || sub_1001D260(v1 + 92, v1 + 140) && sub_1001D260(v1 + 92, v1 + 188))
        && (!(*(_BYTE *)(*(_DWORD *)(v1 + 88) + 56) | (*(_BYTE *)(*(_DWORD *)(v1 + 88) + 55) << 8))
         || sub_1001D260(v1 + 92, v1 + 164) && sub_1001D260((int)v5, v1 + 212));
  return result;
}

//----- (1001DBC0) --------------------------------------------------------
bool __usercall sub_1001DBC0@<al>(unsigned int a1@<esi>)
{
  return (!(*(_BYTE *)(*(_DWORD *)(a1 + 88) + 40) | (*(_BYTE *)(*(_DWORD *)(a1 + 88) + 39) << 8))
       || sub_1001DC30(a1) && sub_1001DE30(a1))
      && (!(*(_BYTE *)(*(_DWORD *)(a1 + 88) + 56) | (*(_BYTE *)(*(_DWORD *)(a1 + 88) + 55) << 8))
       || sub_1001E190(a1) && sub_1001E2F0(a1));
}

//----- (1001DC30) --------------------------------------------------------
char __thiscall sub_1001DC30(unsigned int this)
{
  unsigned int v1; // ebx@1
  int v2; // ecx@2
  int v3; // eax@2
  unsigned int v4; // esi@2
  int v5; // ecx@2
  int v6; // ebx@2
  char *v7; // edi@3
  int v8; // ecx@6
  int *v9; // edx@6
  int v10; // esi@6
  int v11; // edi@6
  int v12; // edx@8
  int v13; // ecx@8
  char v14; // al@8
  int v15; // ecx@8
  char v16; // al@8
  int v17; // ecx@8
  char v18; // al@8
  int v19; // ecx@8
  char v20; // al@8
  int v21; // eax@8
  int v22; // edx@8
  int v23; // eax@8
  bool v24; // zf@8
  char result; // al@9
  char v26; // [sp+10h] [bp-58h]@3
  char v27; // [sp+28h] [bp-40h]@8
  char *v28; // [sp+40h] [bp-28h]@1
  char *v29; // [sp+44h] [bp-24h]@1
  int *v30; // [sp+48h] [bp-20h]@6
  int v31; // [sp+4Ch] [bp-1Ch]@6
  int v32; // [sp+50h] [bp-18h]@6
  int v33; // [sp+54h] [bp-14h]@6
  int v34; // [sp+58h] [bp-10h]@6
  int v35; // [sp+64h] [bp-4h]@3

  v1 = this;
  v28 = (char *)(*(_BYTE *)(*(_DWORD *)(this + 88) + 40) | (*(_BYTE *)(*(_DWORD *)(this + 88) + 39) << 8));
  v29 = (char *)(this + 236);
  if ( sub_10021740(this, this + 236, (unsigned int)v28)
    && (v2 = *(_DWORD *)(v1 + 88),
        v3 = *(_BYTE *)(v2 + 38) | ((*(_BYTE *)(v2 + 37) | (*(_BYTE *)(v2 + 36) << 8)) << 8),
        v4 = 0,
        v5 = (*(_BYTE *)(v2 + 35) | (((*(_BYTE *)(v2 + 33) << 8) | *(_BYTE *)(v2 + 34)) << 8)) + *(_DWORD *)(v1 + 4),
        v6 = v1 + 92,
        v3) )
  {
    *(_DWORD *)v6 = v5;
    *(_DWORD *)(v6 + 4) = v5;
    *(_DWORD *)(v6 + 12) = v3;
    *(_DWORD *)(v6 + 8) = v3 + v5;
    *(_DWORD *)(v6 + 16) = 0;
    *(_DWORD *)(v6 + 20) = 0;
    `eh vector constructor iterator'(&v26, 0x18u, 2, (int)sub_1001D090, sub_1001D0B0);
    v35 = 0;
    v7 = &v26;
    do
    {
      if ( !sub_1001D260(v6, (int)v7) )
      {
        v35 = -1;
        `eh vector destructor iterator'(&v26, 0x18u, 2, sub_1001D0B0);
        goto LABEL_11;
      }
      ++v4;
      v7 += 24;
    }
    while ( v4 < 2 );
    v8 = (int)v29;
    v9 = *(int **)v29;
    LOBYTE(v10) = 0;
    LOBYTE(v11) = 0;
    v32 = 0;
    v34 = 0;
    v33 = 0;
    v31 = 0;
    v30 = v9;
    if ( v28 )
    {
      v29 = v28;
      do
      {
        v11 = ((unsigned __int8)sub_1001D510(v8, v6, (int)&v26) + (_BYTE)v11) & 0x1F;
        v10 = ((unsigned __int8)sub_1001D510((int)&v27, v12, (int)&v27) + (_BYTE)v10) & 0x3F;
        v14 = sub_1001D510(v13, v6, (int)&v26);
        v32 = ((_BYTE)v32 + v14) & 0x1F;
        v16 = sub_1001D510(v15, v6, (int)&v26);
        v34 = ((_BYTE)v34 + v16) & 0x1F;
        v18 = sub_1001D510(v17, v6, (int)&v27);
        v33 = ((_BYTE)v33 + v18) & 0x3F;
        v20 = sub_1001D510(v19, v6, (int)&v26);
        v21 = ((_BYTE)v31 + v20) & 0x1F;
        v22 = v32 | 32 * (v10 | ((v11 | 32 * (v21 | 32 * (v33 | (v34 << 6)))) << 6));
        v31 = v21;
        v23 = (int)v30;
        *v30 = v22;
        v24 = v29-- == (char *)1;
        v30 = (int *)(v23 + 4);
      }
      while ( !v24 );
    }
    v35 = -1;
    `eh vector destructor iterator'(&v26, 0x18u, 2, sub_1001D0B0);
    result = 1;
  }
  else
  {
LABEL_11:
    result = 0;
  }
  return result;
}
// 1001D090: using guessed type int sub_1001D090();

//----- (1001DE30) --------------------------------------------------------
char __thiscall sub_1001DE30(int this)
{
  int v1; // edi@1
  int v2; // eax@1
  unsigned int v3; // esi@1
  int v4; // ecx@1
  int v5; // eax@1
  int *v6; // ebx@1
  signed int v8; // eax@5
  int v9; // edx@5
  unsigned int v10; // ecx@5
  unsigned int v11; // eax@9
  int v12; // edi@9
  int *v13; // edi@16
  unsigned int v14; // esi@18
  int v15; // eax@19
  int v16; // edx@19
  int v17; // eax@19
  _DWORD *v18; // esi@22
  int v19; // eax@22
  int v20; // eax@24
  int v21; // [sp+14h] [bp-1FCh]@2
  void *v22; // [sp+18h] [bp-1F8h]@2
  int v23; // [sp+1Ch] [bp-1F4h]@2
  int v24; // [sp+20h] [bp-1F0h]@2
  char v25; // [sp+24h] [bp-1ECh]@2
  void *v26; // [sp+28h] [bp-1E8h]@2
  unsigned int v27; // [sp+2Ch] [bp-1E4h]@12
  int v28[50]; // [sp+30h] [bp-1E0h]@6
  int v29[50]; // [sp+F8h] [bp-118h]@6
  int v30; // [sp+1C0h] [bp-50h]@9
  int v31; // [sp+1C4h] [bp-4Ch]@19
  int v32; // [sp+1C8h] [bp-48h]@20
  int v33; // [sp+1CCh] [bp-44h]@20
  int v34; // [sp+1D0h] [bp-40h]@20
  int v35; // [sp+1D4h] [bp-3Ch]@20
  int v36; // [sp+1D8h] [bp-38h]@20
  int v37; // [sp+1DCh] [bp-34h]@20
  int v38; // [sp+1E0h] [bp-30h]@20
  int v39; // [sp+1E4h] [bp-2Ch]@20
  int v40; // [sp+1E8h] [bp-28h]@20
  int v41; // [sp+1ECh] [bp-24h]@20
  int v42; // [sp+1F0h] [bp-20h]@20
  int v43; // [sp+1F4h] [bp-1Ch]@20
  int v44; // [sp+1F8h] [bp-18h]@20
  int v45; // [sp+1FCh] [bp-14h]@20
  int v46; // [sp+20Ch] [bp-4h]@2

  v1 = this;
  v2 = *(_DWORD *)(this + 88);
  v3 = *(_BYTE *)(v2 + 48) | (*(_BYTE *)(v2 + 47) << 8);
  v4 = *(_BYTE *)(v2 + 46) | ((*(_BYTE *)(v2 + 45) | (*(_BYTE *)(v2 + 44) << 8)) << 8);
  v5 = (*(_BYTE *)(v2 + 43) | (((*(_BYTE *)(v2 + 41) << 8) | *(_BYTE *)(v2 + 42)) << 8)) + *(_DWORD *)(v1 + 4);
  v6 = (int *)(v1 + 92);
  if ( !v4 )
    return 0;
  *v6 = v5;
  *(_DWORD *)(v1 + 96) = v5;
  *(_DWORD *)(v1 + 104) = v4;
  *(_DWORD *)(v1 + 100) = v4 + v5;
  *(_DWORD *)(v1 + 108) = 0;
  *(_DWORD *)(v1 + 112) = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v46 = 0;
  if ( !sub_1001D260(v1 + 92, (int)&v21) )
  {
LABEL_3:
    v46 = -1;
    sub_1001D0B0(&v21);
    return 0;
  }
  v8 = -3;
  v9 = -3;
  v10 = 0;
  do
  {
    v28[v10] = v8++;
    v29[v10] = v9;
    if ( v8 > 3 )
    {
      v8 = -3;
      ++v9;
    }
    ++v10;
  }
  while ( v10 < 49 );
  memset(&v30, 0, 0x40u);
  v11 = *(_DWORD *)(v1 + 256);
  v12 = v1 + 252;
  if ( v3 != v11 )
  {
    if ( v3 >= v11 )
    {
      if ( v3 > *(_DWORD *)(v12 + 8) )
      {
        LOBYTE(v27) = v3 == v11 + 1;
        if ( !sub_1001C660(v3, v12, v27, 4u) )
        {
          *(_BYTE *)(v12 + 12) = 1;
          goto LABEL_3;
        }
      }
      memset((void *)(*(_DWORD *)v12 + 4 * *(_DWORD *)(v12 + 4)), 0, 4 * (v3 - *(_DWORD *)(v12 + 4)));
    }
    *(_DWORD *)(v12 + 4) = v3;
  }
  v13 = *(int **)v12;
  if ( v3 )
  {
    v27 = v3;
    do
    {
      v14 = 0;
      do
      {
        v15 = sub_1001D510((int)&v21, (int)v6, (int)&v21);
        v16 = (*(&v30 + 2 * v14) + v28[v15]) & 3;
        v17 = (*(&v31 + 2 * v14) + v29[v15]) & 3;
        *(&v30 + 2 * v14) = v16;
        *(&v31 + 2 * v14++) = v17;
      }
      while ( v14 < 8 );
      *v13 = (unsigned __int8)byte_100A1600[v30] | 4
                                                 * ((unsigned __int8)byte_100A1600[v31] | 4
                                                                                        * ((unsigned __int8)byte_100A1600[v32] | 4 * ((unsigned __int8)byte_100A1600[v33] | 4 * ((unsigned __int8)byte_100A1600[v34] | 4 * ((unsigned __int8)byte_100A1600[v35] | 4 * ((unsigned __int8)byte_100A1600[v36] | 4 * ((unsigned __int8)byte_100A1600[v37] | 4 * ((unsigned __int8)byte_100A1600[v38] | 4 * ((unsigned __int8)byte_100A1600[v39] | 4 * ((unsigned __int8)byte_100A1600[v40] | 4 * ((unsigned __int8)byte_100A1600[v41] | 4 * ((unsigned __int8)byte_100A1600[v42] | 4 * ((unsigned __int8)byte_100A1600[v43] | 4 * ((unsigned __int8)byte_100A1600[v44] | 4 * (unsigned __int8)byte_100A1600[v45]))))))))))))));
      ++v13;
      --v27;
    }
    while ( v27 );
  }
  v46 = 1;
  if ( v26 )
  {
    v18 = v26;
    v19 = *((_DWORD *)v26 + 42);
    if ( v19 )
      sub_1001CE80((void *)(v19 - 8));
    v20 = v18[44];
    if ( v20 )
      sub_1001CE80((void *)(v20 - 8));
    sub_1001CE80(v18);
  }
  v46 = -1;
  if ( v22 )
    sub_1001CE80(v22);
  return 1;
}
// 1001DE30: using guessed type int var_1E0[50];
// 1001DE30: using guessed type int var_118[50];

//----- (1001E190) --------------------------------------------------------
char __thiscall sub_1001E190(int this)
{
  int v1; // edi@1
  int v2; // eax@1
  int v3; // esi@1
  int v4; // ecx@1
  int v5; // eax@1
  int *v6; // ebx@1
  unsigned int v7; // ecx@2
  int v9; // edi@5
  int v10; // ecx@5
  _WORD *v11; // edx@6
  unsigned __int8 v12; // si@6
  int v13; // edx@7
  int v14; // eax@7
  bool v15; // zf@7
  int v16; // [sp+10h] [bp-30h]@2
  int v17; // [sp+14h] [bp-2Ch]@2
  int v18; // [sp+18h] [bp-28h]@2
  int v19; // [sp+1Ch] [bp-24h]@2
  char v20; // [sp+20h] [bp-20h]@2
  int v21; // [sp+24h] [bp-1Ch]@2
  int v22; // [sp+28h] [bp-18h]@7
  int v23; // [sp+2Ch] [bp-14h]@1
  _WORD *v24; // [sp+30h] [bp-10h]@6
  int v25; // [sp+3Ch] [bp-4h]@2

  v1 = this;
  v2 = *(_DWORD *)(this + 88);
  v3 = *(_BYTE *)(v2 + 56) | (*(_BYTE *)(v2 + 55) << 8);
  v4 = *(_BYTE *)(v2 + 54) | ((*(_BYTE *)(v2 + 53) | (*(_BYTE *)(v2 + 52) << 8)) << 8);
  v5 = (*(_BYTE *)(v2 + 51) | (((*(_BYTE *)(v2 + 49) << 8) | *(_BYTE *)(v2 + 50)) << 8)) + *(_DWORD *)(v1 + 4);
  v23 = v3;
  v6 = (int *)(v1 + 92);
  if ( !v4 )
    return 0;
  *v6 = v5;
  *(_DWORD *)(v1 + 96) = v5;
  *(_DWORD *)(v1 + 104) = v4;
  *(_DWORD *)(v1 + 100) = v4 + v5;
  *(_DWORD *)(v1 + 108) = 0;
  *(_DWORD *)(v1 + 112) = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v25 = 0;
  if ( !sub_1001D260(v1 + 92, (int)&v16) || (v9 = v1 + 268, !sub_100217A0(v7, v9, v3)) )
  {
    v25 = -1;
    sub_1001D0B0(&v16);
    return 0;
  }
  v11 = *(_WORD **)v9;
  LOBYTE(v9) = 0;
  v12 = 0;
  v24 = v11;
  if ( v23 )
  {
    do
    {
      v22 = sub_1001D510(v10, (int)v6, (int)&v16);
      v12 += sub_1001D510((int)&v16, v13, (int)&v16);
      v14 = (int)v24;
      v9 = (unsigned __int8)(v22 + v9);
      v10 = v9 | (v12 << 8);
      *v24 = v10;
      v15 = v23-- == 1;
      v24 = (_WORD *)(v14 + 2);
    }
    while ( !v15 );
  }
  v25 = -1;
  sub_1001D0B0(&v16);
  return 1;
}

//----- (1001E2F0) --------------------------------------------------------
char __thiscall sub_1001E2F0(int this)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // ebx@1
  int v4; // ecx@1
  int v5; // eax@1
  signed int v7; // eax@5
  int v8; // edx@5
  unsigned int v9; // ecx@5
  unsigned int v10; // eax@9
  int v11; // esi@9
  unsigned int v12; // edi@9
  int i; // edi@16
  unsigned int v14; // esi@17
  int v15; // eax@18
  int v16; // edx@18
  int v17; // eax@18
  unsigned __int8 v18; // al@19
  __int16 v19; // dx@19
  unsigned __int8 v20; // cl@19
  _DWORD *v21; // esi@21
  int v22; // eax@21
  int v23; // eax@23
  int v24; // [sp+10h] [bp-780h]@1
  unsigned int v25; // [sp+14h] [bp-77Ch]@0
  int v26; // [sp+18h] [bp-778h]@2
  void *v27; // [sp+1Ch] [bp-774h]@2
  int v28; // [sp+20h] [bp-770h]@2
  int v29; // [sp+24h] [bp-76Ch]@2
  char v30; // [sp+28h] [bp-768h]@2
  void *v31; // [sp+2Ch] [bp-764h]@2
  int v32[226]; // [sp+30h] [bp-760h]@6
  int v33[226]; // [sp+3B8h] [bp-3D8h]@6
  int v34; // [sp+740h] [bp-50h]@9
  int v35; // [sp+744h] [bp-4Ch]@18
  int v36; // [sp+748h] [bp-48h]@19
  int v37; // [sp+74Ch] [bp-44h]@19
  int v38; // [sp+750h] [bp-40h]@19
  int v39; // [sp+754h] [bp-3Ch]@19
  int v40; // [sp+758h] [bp-38h]@19
  int v41; // [sp+75Ch] [bp-34h]@19
  int v42; // [sp+760h] [bp-30h]@19
  int v43; // [sp+764h] [bp-2Ch]@19
  int v44; // [sp+768h] [bp-28h]@19
  int v45; // [sp+76Ch] [bp-24h]@19
  int v46; // [sp+770h] [bp-20h]@19
  int v47; // [sp+774h] [bp-1Ch]@19
  int v48; // [sp+778h] [bp-18h]@19
  int v49; // [sp+77Ch] [bp-14h]@19
  int v50; // [sp+78Ch] [bp-4h]@2

  v1 = this;
  v2 = *(_DWORD *)(this + 88);
  v3 = *(_BYTE *)(v2 + 64) | (*(_BYTE *)(v2 + 63) << 8);
  v4 = *(_BYTE *)(v2 + 62) | ((*(_BYTE *)(v2 + 61) | (*(_BYTE *)(v2 + 60) << 8)) << 8);
  v5 = (*(_BYTE *)(v2 + 59) | (((*(_BYTE *)(v2 + 57) << 8) | *(_BYTE *)(v2 + 58)) << 8)) + *(_DWORD *)(v1 + 4);
  v24 = v1 + 92;
  if ( !v4 )
    return 0;
  *(_DWORD *)(v1 + 92) = v5;
  *(_DWORD *)(v1 + 96) = v5;
  *(_DWORD *)(v1 + 104) = v4;
  *(_DWORD *)(v1 + 100) = v4 + v5;
  *(_DWORD *)(v1 + 108) = 0;
  *(_DWORD *)(v1 + 112) = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v50 = 0;
  if ( !sub_1001D260(v1 + 92, (int)&v26) )
  {
LABEL_3:
    v50 = -1;
    sub_1001D0B0(&v26);
    return 0;
  }
  v7 = -7;
  v8 = -7;
  v9 = 0;
  do
  {
    v32[v9] = v7++;
    v33[v9] = v8;
    if ( v7 > 7 )
    {
      v7 = -7;
      ++v8;
    }
    ++v9;
  }
  while ( v9 < 225 );
  memset(&v34, 0, 0x40u);
  v10 = *(_DWORD *)(v1 + 288);
  v11 = v1 + 284;
  v12 = 3 * v3;
  if ( 3 * v3 != v10 )
  {
    if ( 3 * v3 >= v10 )
    {
      if ( v12 > *(_DWORD *)(v11 + 8) )
      {
        LOBYTE(v25) = v12 == v10 + 1;
        if ( !sub_1001C660(3 * v3, v11, v25, 2u) )
        {
          *(_BYTE *)(v11 + 12) = 1;
          goto LABEL_3;
        }
      }
      memset((void *)(*(_DWORD *)v11 + 2 * *(_DWORD *)(v11 + 4)), 0, 2 * (v12 - *(_DWORD *)(v11 + 4)));
    }
    *(_DWORD *)(v11 + 4) = v12;
  }
  for ( i = *(_DWORD *)v11; v3; --v3 )
  {
    v14 = 0;
    do
    {
      v15 = sub_1001D510((int)&v26, v24, (int)&v26);
      v16 = (*(&v34 + 2 * v14) + v32[v15]) & 7;
      v17 = (*(&v35 + 2 * v14) + v33[v15]) & 7;
      *(&v34 + 2 * v14) = v16;
      *(&v35 + 2 * v14++) = v17;
    }
    while ( v14 < 8 );
    v18 = byte_100A160C[v39];
    v19 = (unsigned __int8)byte_100A160C[v43];
    *(_WORD *)i = (unsigned __int8)byte_100A160C[v34] | (unsigned __int16)(8
                                                                         * ((unsigned __int8)byte_100A160C[v35] | (unsigned __int16)(8 * ((unsigned __int8)byte_100A160C[v36] | (unsigned __int16)(8 * ((unsigned __int8)byte_100A160C[v37] | (unsigned __int16)(8 * (8 * (unsigned __int8)byte_100A160C[v39] | (unsigned __int8)byte_100A160C[v38]))))))));
    v20 = byte_100A160C[v44];
    *(_WORD *)(i + 2) = (v18 >> 1) | 4
                                   * ((unsigned __int8)byte_100A160C[v40] | (unsigned __int16)(8
                                                                                             * ((unsigned __int8)byte_100A160C[v41] | (unsigned __int16)(8 * ((unsigned __int8)byte_100A160C[v42] | (unsigned __int16)(8 * (8 * (unsigned __int8)byte_100A160C[v44] | v19)))))));
    *(_WORD *)(i + 4) = (v20 >> 2) | 2
                                   * ((unsigned __int8)byte_100A160C[v45] | (unsigned __int16)(8
                                                                                             * ((unsigned __int8)byte_100A160C[v46] | (unsigned __int16)(8 * ((unsigned __int8)byte_100A160C[v47] | (unsigned __int16)(8 * ((unsigned __int8)byte_100A160C[v48] | (unsigned __int16)(8 * (unsigned __int8)byte_100A160C[v49]))))))));
    i += 6;
  }
  v50 = 1;
  if ( v31 )
  {
    v21 = v31;
    v22 = *((_DWORD *)v31 + 42);
    if ( v22 )
      sub_1001CE80((void *)(v22 - 8));
    v23 = v21[44];
    if ( v23 )
      sub_1001CE80((void *)(v23 - 8));
    sub_1001CE80(v21);
  }
  v50 = -1;
  if ( v27 )
    sub_1001CE80(v27);
  return 1;
}
// 1001E2F0: using guessed type int var_760[226];
// 1001E2F0: using guessed type int var_3D8[226];

//----- (1001E6B0) --------------------------------------------------------
char __fastcall sub_1001E6B0(unsigned int a1, signed int a2, int a3, int a4, char a5, char a6, unsigned int a7)
{
  int v7; // edi@1
  unsigned int v8; // ebx@1
  int v9; // esi@1
  unsigned int v10; // eax@1
  int v11; // ecx@2
  unsigned int v12; // edx@2
  int v13; // eax@3
  int v14; // ebx@3
  int v15; // eax@11
  int v16; // ecx@11
  int v17; // ecx@12
  int v18; // ST4C_4@12
  signed int v19; // ecx@12
  int v20; // eax@12
  int v21; // edx@12
  char *v22; // eax@14
  int v23; // eax@19
  int v24; // edi@19
  int v25; // ecx@19
  int v26; // edx@19
  int v27; // eax@19
  int v28; // esi@19
  int v29; // ecx@19
  int v30; // edx@19
  int v31; // eax@19
  int v32; // edi@19
  int v33; // edx@19
  int v34; // eax@19
  unsigned int v35; // edi@21
  int v36; // esi@22
  int v38; // [sp+Ch] [bp-70h]@1
  unsigned int v39; // [sp+14h] [bp-68h]@1
  unsigned int v40; // [sp+1Ch] [bp-60h]@1
  signed int v41; // [sp+20h] [bp-5Ch]@3
  unsigned int v42; // [sp+24h] [bp-58h]@1
  signed int v43; // [sp+28h] [bp-54h]@3
  int v44; // [sp+2Ch] [bp-50h]@2
  int v45; // [sp+30h] [bp-4Ch]@1
  signed int v46; // [sp+34h] [bp-48h]@1
  unsigned int v47; // [sp+38h] [bp-44h]@2
  signed int v48; // [sp+3Ch] [bp-40h]@3
  int v49; // [sp+40h] [bp-3Ch]@8
  unsigned int v50; // [sp+44h] [bp-38h]@1
  int v51; // [sp+48h] [bp-34h]@1
  int v52; // [sp+4Ch] [bp-30h]@1
  unsigned int v53; // [sp+50h] [bp-2Ch]@11
  int v54; // [sp+50h] [bp-2Ch]@20
  int v55; // [sp+54h] [bp-28h]@11
  unsigned int v56; // [sp+54h] [bp-28h]@20
  unsigned int v57; // [sp+58h] [bp-24h]@11
  char *v58; // [sp+58h] [bp-24h]@20
  char *v59; // [sp+5Ch] [bp-20h]@14
  int v60; // [sp+5Ch] [bp-20h]@21
  char v61; // [sp+66h] [bp-16h]@6
  char v62; // [sp+67h] [bp-15h]@15
  int v63[4]; // [sp+68h] [bp-14h]@12

  v7 = a3;
  v38 = *(_DWORD *)(a3 + 240);
  v8 = *(_BYTE *)(*(_DWORD *)(a3 + 88) + 17);
  v9 = 0;
  v46 = a2;
  v45 = a1 >> 2;
  v10 = 0;
  v40 = a1;
  v50 = 1;
  v52 = *(_DWORD *)(a3 + 256);
  v51 = 0;
  v39 = *(_BYTE *)(*(_DWORD *)(a3 + 88) + 17);
  v42 = 0;
  if ( *(_BYTE *)(*(_DWORD *)(a3 + 88) + 17) )
  {
    do
    {
      v11 = *(_DWORD *)(a4 + 4 * v10);
      LOBYTE(v12) = 0;
      v44 = *(_DWORD *)(a4 + 4 * v10);
      v47 = 0;
      if ( a7 )
      {
        do
        {
          v13 = 0;
          v48 = v46;
          v41 = 1;
          v43 = 16;
          v14 = v11;
          if ( v12 & 1 )
          {
            v13 = v46 - 1;
            v48 = -1;
            v41 = -1;
            v43 = -16;
            v14 = v11 + 16 * v46 - 16;
          }
          if ( v47 != a7 - 1 || (v61 = 1, !(a6 & 1)) )
            v61 = 0;
          v49 = v13;
          if ( v13 != v48 )
          {
            do
            {
              if ( v50 == 1 )
                v50 = sub_1001D510(v11, v7 + 92, v7 + 116) | 0x200;
              v15 = v50 & 7;
              v50 >>= 3;
              v16 = (unsigned __int8)byte_100ADF84[v15];
              v55 = v15;
              v53 = (unsigned __int8)byte_100ADF84[v15];
              v57 = 0;
              if ( byte_100ADF84[v15] )
              {
                do
                {
                  v17 = sub_1001D510(v16, v7 + 92, v7 + 140) + v51;
                  v18 = v17;
                  v19 = v17 - v38;
                  v20 = v18 & (v19 >> 31);
                  v21 = v19 & ~(v19 >> 31);
                  v16 = *(_DWORD *)(v7 + 236);
                  v51 = v21 | v20;
                  v63[v57++] = *(_DWORD *)(v16 + 4 * (v21 | v20));
                }
                while ( v57 < v53 );
                v15 = v55;
              }
              v22 = (char *)&unk_100ADF64 + 4 * v15;
              v59 = v22;
              if ( !(a5 & 1) || (v16 = v46 - 1, v62 = 1, v49 != v46 - 1) )
                v62 = 0;
              if ( v61 || v62 )
              {
                v56 = 0;
                v58 = v22;
                v54 = v14;
                do
                {
                  v11 = v54;
                  v60 = v54;
                  v35 = 0;
                  do
                  {
                    v36 = sub_1001D510(v11, a3 + 92, a3 + 188) + v9;
                    v11 = v36 - v52;
                    v9 = (v36 - v52) & ~((v36 - v52) >> 31) | ((v36 - v52) >> 31) & v36;
                    if ( (!v35 || !v62) && (!v56 || !v61) )
                    {
                      *(_DWORD *)v60 = v63[(unsigned __int8)v58[v35]];
                      v11 = *(_DWORD *)(*(_DWORD *)(a3 + 252) + 4 * v9);
                      *(_DWORD *)(v60 + 4) = v11;
                    }
                    v60 += 8;
                    ++v35;
                  }
                  while ( v35 < 2 );
                  v54 += v40;
                  v58 += 2;
                  ++v56;
                }
                while ( v56 < 2 );
              }
              else
              {
                *(_DWORD *)v14 = v63[(unsigned __int8)*v22];
                v23 = sub_1001D510(v16, v7 + 92, v7 + 188);
                v24 = (v23 + v9) & ((v23 + v9 - v52) >> 31) | (v23 + v9 - v52) & ~((v23 + v9 - v52) >> 31);
                *(_DWORD *)(v14 + 4) = *(_DWORD *)(*(_DWORD *)(a3 + 252) + 4 * v24);
                v25 = v63[(unsigned __int8)v59[1]];
                *(_DWORD *)(v14 + 8) = v25;
                v27 = sub_1001D510(v25, v26, a3 + 188);
                v28 = (v27 + v24) & ((v27 + v24 - v52) >> 31) | (v27 + v24 - v52) & ~((v27 + v24 - v52) >> 31);
                *(_DWORD *)(v14 + 12) = *(_DWORD *)(*(_DWORD *)(a3 + 252) + 4 * v28);
                v29 = v63[(unsigned __int8)v59[2]];
                *(_DWORD *)(v14 + 4 * v45) = v29;
                v31 = sub_1001D510(v29, v30, a3 + 188);
                v32 = (v31 + v28) & ((v31 + v28 - v52) >> 31) | (v31 + v28 - v52) & ~((v31 + v28 - v52) >> 31);
                *(_DWORD *)(v14 + 4 * v45 + 4) = *(_DWORD *)(*(_DWORD *)(a3 + 252) + 4 * v32);
                *(_DWORD *)(v14 + 4 * v45 + 8) = v63[(unsigned __int8)v59[3]];
                v34 = sub_1001D510(v45, v33, a3 + 188);
                v9 = (v34 + v32) & ((v34 + v32 - v52) >> 31) | (v34 + v32 - v52) & ~((v34 + v32 - v52) >> 31);
                v11 = *(_DWORD *)(a3 + 252);
                *(_DWORD *)(v14 + 4 * v45 + 12) = *(_DWORD *)(v11 + 4 * v9);
              }
              v14 += v43;
              v7 = a3;
              v49 += v41;
            }
            while ( v49 != v48 );
            v11 = v44;
          }
          v12 = v47 + 1;
          v11 += 2 * v40;
          v44 = v11;
          v47 = v12;
        }
        while ( v12 < a7 );
        v10 = v42;
        v8 = v39;
      }
      v42 = ++v10;
    }
    while ( v10 < v8 );
  }
  return 1;
}
// 1001E6B0: using guessed type int var_14[4];

//----- (1001EA50) --------------------------------------------------------
char __fastcall sub_1001EA50(int a1, signed int a2, int a3, int a4, char a5, char a6, unsigned int a7)
{
  int v7; // ebx@1
  int v8; // eax@1
  int v9; // ecx@1
  unsigned int v10; // edx@1
  int v11; // esi@1
  unsigned int v12; // eax@1
  int v13; // edi@1
  unsigned int v14; // ecx@2
  int v15; // eax@3
  int v16; // eax@11
  int v17; // ecx@15
  int v18; // ST58_4@15
  signed int v19; // ecx@15
  int v20; // eax@15
  int v21; // edx@15
  int v22; // ecx@18
  int v23; // ST64_4@18
  signed int v24; // ecx@18
  int v25; // eax@18
  int v26; // edx@18
  int v27; // ebx@19
  int v28; // esi@21
  int v29; // ecx@21
  int v30; // edi@21
  int v31; // eax@21
  int v32; // ecx@25
  int v33; // eax@25
  int v35; // [sp+Ch] [bp-8Ch]@1
  char *v36; // [sp+10h] [bp-88h]@11
  int v37; // [sp+18h] [bp-80h]@1
  unsigned int v38; // [sp+1Ch] [bp-7Ch]@1
  int v39; // [sp+20h] [bp-78h]@1
  int v40; // [sp+24h] [bp-74h]@1
  int v41; // [sp+2Ch] [bp-6Ch]@1
  unsigned int v42; // [sp+30h] [bp-68h]@1
  signed int v43; // [sp+34h] [bp-64h]@3
  signed int v44; // [sp+38h] [bp-60h]@3
  signed int v45; // [sp+3Ch] [bp-5Ch]@3
  int v46; // [sp+40h] [bp-58h]@2
  int v47; // [sp+44h] [bp-54h]@8
  signed int v48; // [sp+48h] [bp-50h]@1
  unsigned int v49; // [sp+4Ch] [bp-4Ch]@19
  unsigned int v50; // [sp+50h] [bp-48h]@2
  int v51; // [sp+54h] [bp-44h]@1
  unsigned int v52; // [sp+58h] [bp-40h]@1
  int v53; // [sp+5Ch] [bp-3Ch]@3
  int v54; // [sp+60h] [bp-38h]@1
  unsigned int v55; // [sp+64h] [bp-34h]@11
  int v56; // [sp+64h] [bp-34h]@20
  unsigned int v57; // [sp+6Ch] [bp-2Ch]@14
  unsigned int v58; // [sp+6Ch] [bp-2Ch]@17
  char *v59; // [sp+6Ch] [bp-2Ch]@19
  char v60; // [sp+72h] [bp-26h]@12
  char v61; // [sp+73h] [bp-25h]@6
  int v62[4]; // [sp+74h] [bp-24h]@15
  int v63[4]; // [sp+84h] [bp-14h]@18

  v7 = a3;
  v48 = a2;
  v41 = a1;
  v39 = *(_DWORD *)(a3 + 240);
  v8 = *(_DWORD *)(a3 + 88);
  v35 = *(_DWORD *)(a3 + 272);
  v40 = *(_DWORD *)(a3 + 256);
  v9 = (*(_BYTE *)(v8 + 63) << 8) | *(_BYTE *)(v8 + 64);
  v10 = *(_BYTE *)(v8 + 17);
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v52 = 1;
  v37 = v9;
  v54 = 0;
  v51 = 0;
  v38 = v10;
  v42 = 0;
  if ( v10 )
  {
    do
    {
      v46 = *(_DWORD *)(a4 + 4 * v12);
      v14 = 0;
      v50 = 0;
      if ( a7 )
      {
        do
        {
          v45 = v48;
          v15 = 0;
          v44 = 1;
          v43 = 32;
          v53 = v46;
          if ( v14 & 1 )
          {
            v15 = v48 - 1;
            v53 = 32 * v48 + v46 - 32;
            v14 = v50;
            v45 = -1;
            v44 = -1;
            v43 = -32;
          }
          if ( v14 != a7 - 1 || (v61 = 1, !(a6 & 1)) )
            v61 = 0;
          v47 = v15;
          if ( v15 != v45 )
          {
            do
            {
              if ( v52 == 1 )
                v52 = sub_1001D510(v14, v7 + 92, v7 + 116) | 0x200;
              v16 = v52 & 7;
              v52 >>= 3;
              v14 = (unsigned __int8)byte_100ADF84[v16];
              v55 = (unsigned __int8)byte_100ADF84[v16];
              v36 = (char *)&unk_100ADF64 + 4 * v16;
              if ( !(a5 & 1) || (v60 = 1, v47 != v48 - 1) )
                v60 = 0;
              v57 = 0;
              if ( byte_100ADF84[v16] )
              {
                do
                {
                  v17 = sub_1001D510(v14, v7 + 92, v7 + 164) + v51;
                  v18 = v17;
                  v19 = v17 - v35;
                  v20 = v18 & (v19 >> 31);
                  v21 = v19 & ~(v19 >> 31);
                  v14 = *(_DWORD *)(v7 + 268);
                  v51 = v21 | v20;
                  v62[v57++] = *(_WORD *)(v14 + 2 * (v21 | v20));
                }
                while ( v57 < v55 );
                v14 = v55;
              }
              v58 = 0;
              if ( v14 )
              {
                do
                {
                  v22 = sub_1001D510(v14, v7 + 92, v7 + 140) + v54;
                  v23 = v22;
                  v24 = v22 - v39;
                  v25 = v23 & (v24 >> 31);
                  v26 = v24 & ~(v24 >> 31);
                  v14 = *(_DWORD *)(v7 + 236);
                  v54 = v26 | v25;
                  v63[v58++] = *(_DWORD *)(v14 + 4 * (v26 | v25));
                }
                while ( v58 < v55 );
              }
              v27 = v53;
              v49 = 0;
              v59 = v36;
              do
              {
                v56 = 0;
                do
                {
                  v28 = sub_1001D510(v14, a3 + 92, a3 + 212) + v11;
                  v29 = v28 - v37;
                  v11 = (v28 - v37) & ~((v28 - v37) >> 31) | ((v28 - v37) >> 31) & v28;
                  v30 = sub_1001D510(v29, a3 + 92, a3 + 188) + v13;
                  v14 = v30 - v40;
                  v31 = v56;
                  v13 = (v30 - v40) & ~((v30 - v40) >> 31) | ((v30 - v40) >> 31) & v30;
                  if ( (!v56 || !v60) && (!v49 || !v61) )
                  {
                    v32 = (unsigned __int8)v59[v56];
                    v33 = *(_DWORD *)(a3 + 284) + 6 * v11;
                    *(_DWORD *)v27 = v62[v32] | (*(_WORD *)v33 << 16);
                    *(_DWORD *)(v27 + 4) = *(_WORD *)(v33 + 2) | (*(_WORD *)(v33 + 4) << 16);
                    *(_DWORD *)(v27 + 8) = v63[v32];
                    v14 = *(_DWORD *)(*(_DWORD *)(a3 + 252) + 4 * v13);
                    *(_DWORD *)(v27 + 12) = v14;
                    v31 = v56;
                  }
                  v27 += 16;
                  v56 = v31 + 1;
                }
                while ( (unsigned int)(v31 + 1) < 2 );
                v59 += 2;
                v27 += v41 - 32;
                ++v49;
              }
              while ( v49 < 2 );
              v53 += v43;
              v7 = a3;
              v47 += v44;
            }
            while ( v47 != v45 );
            v14 = v50;
          }
          v46 += 2 * v41;
          v50 = ++v14;
        }
        while ( v14 < a7 );
        v12 = v42;
        v10 = v38;
      }
      v42 = ++v12;
    }
    while ( v12 < v10 );
  }
  return 1;
}
// 1001EA50: using guessed type int var_24[4];
// 1001EA50: using guessed type int var_14[4];

//----- (1001EDD0) --------------------------------------------------------
char __fastcall sub_1001EDD0(int a1, signed int a2, int a3, int a4, char a5, char a6, unsigned int a7)
{
  int v7; // ebx@1
  int v8; // eax@1
  int v9; // ecx@1
  unsigned int v10; // edx@1
  int v11; // esi@1
  unsigned int v12; // eax@1
  int v13; // edi@1
  unsigned int v14; // ecx@2
  int v15; // eax@3
  int v16; // eax@11
  int v17; // ecx@15
  int v18; // ST54_4@15
  signed int v19; // ecx@15
  int v20; // eax@15
  int v21; // edx@15
  int v22; // ecx@18
  int v23; // ST60_4@18
  signed int v24; // ecx@18
  int v25; // eax@18
  int v26; // edx@18
  int v27; // ebx@19
  int v28; // esi@21
  int v29; // ecx@21
  int v30; // edi@21
  int v31; // eax@21
  int v32; // ecx@25
  int v33; // eax@25
  int v34; // ST1C_4@25
  int v35; // ecx@25
  unsigned int v37; // [sp+10h] [bp-84h]@1
  signed int v38; // [sp+1Ch] [bp-78h]@3
  signed int v39; // [sp+20h] [bp-74h]@3
  unsigned int v40; // [sp+24h] [bp-70h]@1
  int v41; // [sp+28h] [bp-6Ch]@1
  int v42; // [sp+2Ch] [bp-68h]@1
  int v43; // [sp+30h] [bp-64h]@1
  signed int v44; // [sp+34h] [bp-60h]@1
  int v45; // [sp+38h] [bp-5Ch]@8
  char *v46; // [sp+3Ch] [bp-58h]@11
  unsigned int v47; // [sp+40h] [bp-54h]@19
  signed int v48; // [sp+44h] [bp-50h]@3
  unsigned int v49; // [sp+48h] [bp-4Ch]@2
  int v50; // [sp+4Ch] [bp-48h]@2
  int v51; // [sp+50h] [bp-44h]@1
  unsigned int v52; // [sp+54h] [bp-40h]@1
  int v53; // [sp+58h] [bp-3Ch]@3
  int v54; // [sp+5Ch] [bp-38h]@1
  unsigned int v55; // [sp+64h] [bp-30h]@11
  int v56; // [sp+64h] [bp-30h]@20
  unsigned int v57; // [sp+68h] [bp-2Ch]@14
  unsigned int v58; // [sp+68h] [bp-2Ch]@17
  char *v59; // [sp+68h] [bp-2Ch]@19
  char v60; // [sp+6Eh] [bp-26h]@12
  char v61; // [sp+6Fh] [bp-25h]@6
  int v62[4]; // [sp+70h] [bp-24h]@15
  int v63[4]; // [sp+80h] [bp-14h]@18

  v7 = a3;
  v41 = *(_DWORD *)(a3 + 272);
  v8 = *(_DWORD *)(a3 + 88);
  v43 = a1;
  v44 = a2;
  v9 = *(_BYTE *)(v8 + 64) | (*(_BYTE *)(v8 + 63) << 8);
  v10 = *(_BYTE *)(v8 + 17);
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v52 = 1;
  v42 = v9;
  v51 = 0;
  v54 = 0;
  v37 = v10;
  v40 = 0;
  if ( v10 )
  {
    do
    {
      v50 = *(_DWORD *)(a4 + 4 * v12);
      v14 = 0;
      v49 = 0;
      if ( a7 )
      {
        do
        {
          v48 = v44;
          v15 = 0;
          v39 = 1;
          v38 = 32;
          v53 = v50;
          if ( v14 & 1 )
          {
            v15 = v44 - 1;
            v53 = 32 * v44 + v50 - 32;
            v14 = v49;
            v48 = -1;
            v39 = -1;
            v38 = -32;
          }
          if ( v14 != a7 - 1 || (v61 = 1, !(a6 & 1)) )
            v61 = 0;
          v45 = v15;
          if ( v15 != v48 )
          {
            do
            {
              if ( v52 == 1 )
                v52 = sub_1001D510(v14, v7 + 92, v7 + 116) | 0x200;
              v16 = v52 & 7;
              v52 >>= 3;
              v14 = (unsigned __int8)byte_100ADF84[v16];
              v55 = (unsigned __int8)byte_100ADF84[v16];
              v46 = (char *)&unk_100ADF64 + 4 * v16;
              if ( !(a5 & 1) || (v60 = 1, v45 != v44 - 1) )
                v60 = 0;
              v57 = 0;
              if ( byte_100ADF84[v16] )
              {
                do
                {
                  v17 = sub_1001D510(v14, v7 + 92, v7 + 164) + v51;
                  v18 = v17;
                  v19 = v17 - v41;
                  v20 = v18 & (v19 >> 31);
                  v21 = v19 & ~(v19 >> 31);
                  v14 = *(_DWORD *)(v7 + 268);
                  v51 = v21 | v20;
                  v62[v57++] = *(_WORD *)(v14 + 2 * (v21 | v20));
                }
                while ( v57 < v55 );
                v14 = v55;
              }
              v58 = 0;
              if ( v14 )
              {
                do
                {
                  v22 = sub_1001D510(v14, v7 + 92, v7 + 164) + v54;
                  v23 = v22;
                  v24 = v22 - v41;
                  v25 = v23 & (v24 >> 31);
                  v26 = v24 & ~(v24 >> 31);
                  v14 = *(_DWORD *)(v7 + 268);
                  v54 = v26 | v25;
                  v63[v58++] = *(_WORD *)(v14 + 2 * (v26 | v25));
                }
                while ( v58 < v55 );
              }
              v27 = v53;
              v47 = 0;
              v59 = v46;
              do
              {
                v56 = 0;
                do
                {
                  v28 = sub_1001D510(v14, a3 + 92, a3 + 212) + v11;
                  v29 = v28 - v42;
                  v11 = (v28 - v42) & ~((v28 - v42) >> 31) | ((v28 - v42) >> 31) & v28;
                  v30 = sub_1001D510(v29, a3 + 92, a3 + 212) + v13;
                  v14 = v30 - v42;
                  v31 = v56;
                  v13 = (v30 - v42) & ~((v30 - v42) >> 31) | ((v30 - v42) >> 31) & v30;
                  if ( (!v56 || !v60) && (!v47 || !v61) )
                  {
                    v32 = *(_DWORD *)(a3 + 284);
                    v33 = v32 + 6 * v11;
                    v34 = v32 + 6 * v13;
                    v35 = (unsigned __int8)v59[v56];
                    *(_DWORD *)v27 = v62[v35] | (*(_WORD *)v33 << 16);
                    *(_DWORD *)(v27 + 4) = *(_WORD *)(v33 + 2) | (*(_WORD *)(v33 + 4) << 16);
                    *(_DWORD *)(v27 + 8) = v63[v35] | (*(_WORD *)v34 << 16);
                    v14 = *(_WORD *)(v34 + 2) | (*(_WORD *)(v34 + 4) << 16);
                    *(_DWORD *)(v27 + 12) = v14;
                    v31 = v56;
                  }
                  v27 += 16;
                  v56 = v31 + 1;
                }
                while ( (unsigned int)(v31 + 1) < 2 );
                v59 += 2;
                v27 += v43 - 32;
                ++v47;
              }
              while ( v47 < 2 );
              v53 += v38;
              v7 = a3;
              v45 += v39;
            }
            while ( v45 != v48 );
            v14 = v49;
          }
          v50 += 2 * v43;
          v49 = ++v14;
        }
        while ( v14 < a7 );
        v12 = v40;
        v10 = v37;
      }
      v40 = ++v12;
    }
    while ( v12 < v10 );
  }
  return 1;
}
// 1001EDD0: using guessed type int var_24[4];
// 1001EDD0: using guessed type int var_14[4];

//----- (1001F160) --------------------------------------------------------
char __fastcall sub_1001F160(int a1, int a2, int a3, char a4, char a5, signed int a6, unsigned int a7)
{
  int v7; // eax@1
  int v8; // ecx@1
  unsigned int v9; // edx@1
  signed int v10; // edi@1
  int v11; // ebx@1
  unsigned int v12; // eax@1
  int v13; // esi@1
  unsigned int v14; // ecx@2
  int v15; // eax@3
  int v16; // edx@4
  int v17; // eax@11
  int v18; // ecx@11
  unsigned int v19; // edi@14
  int v20; // ecx@15
  int v21; // eax@17
  int v22; // ecx@18
  int v23; // ebx@18
  unsigned int v24; // edi@19
  int v25; // esi@20
  int v26; // eax@24
  int v28; // [sp+Ch] [bp-6Ch]@1
  char *v29; // [sp+10h] [bp-68h]@11
  unsigned int v30; // [sp+14h] [bp-64h]@1
  int v31; // [sp+18h] [bp-60h]@1
  int v32; // [sp+1Ch] [bp-5Ch]@1
  int v33; // [sp+24h] [bp-54h]@1
  signed int v34; // [sp+28h] [bp-50h]@3
  signed int v35; // [sp+2Ch] [bp-4Ch]@3
  unsigned int v36; // [sp+30h] [bp-48h]@2
  unsigned int v37; // [sp+34h] [bp-44h]@1
  signed int v38; // [sp+38h] [bp-40h]@3
  int v39; // [sp+3Ch] [bp-3Ch]@8
  unsigned int v40; // [sp+40h] [bp-38h]@18
  int v41; // [sp+48h] [bp-30h]@2
  int v42; // [sp+4Ch] [bp-2Ch]@1
  int v43; // [sp+50h] [bp-28h]@3
  unsigned int v44; // [sp+54h] [bp-24h]@1
  unsigned int v45; // [sp+58h] [bp-20h]@11
  char *v46; // [sp+58h] [bp-20h]@18
  int v47; // [sp+60h] [bp-18h]@17
  char v48; // [sp+62h] [bp-16h]@12
  char v49; // [sp+63h] [bp-15h]@6
  int v50[4]; // [sp+64h] [bp-14h]@24

  v28 = a1;
  v7 = *(_DWORD *)(a3 + 88);
  v33 = a2;
  v31 = *(_DWORD *)(a3 + 272);
  v8 = (*(_BYTE *)(v7 + 63) << 8) | *(_BYTE *)(v7 + 64);
  v9 = *(_BYTE *)(v7 + 17);
  v10 = a6;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v44 = 1;
  v32 = v8;
  v42 = 0;
  v30 = v9;
  v37 = 0;
  if ( v9 )
  {
    do
    {
      v41 = *(_DWORD *)(v28 + 4 * v12);
      v14 = 0;
      v36 = 0;
      if ( a7 )
      {
        do
        {
          v15 = 0;
          v38 = v10;
          v34 = 1;
          v35 = 16;
          v43 = v41;
          if ( v14 & 1 )
          {
            v15 = v10 - 1;
            v16 = v41 + 16 * v10 - 16;
            v10 = a6;
            v38 = -1;
            v34 = -1;
            v35 = -16;
            v43 = v16;
          }
          if ( v14 != a7 - 1 || (v49 = 1, !(a5 & 1)) )
            v49 = 0;
          v39 = v15;
          if ( v15 != v38 )
          {
            do
            {
              if ( v44 == 1 )
                v44 = sub_1001D510(a3 + 116, a3 + 92, a3 + 116) | 0x200;
              v17 = v44 & 7;
              v44 >>= 3;
              v18 = (unsigned __int8)byte_100ADF84[v17];
              v45 = (unsigned __int8)byte_100ADF84[v17];
              v29 = (char *)&unk_100ADF64 + 4 * v17;
              if ( !(a4 & 1) || (v48 = 1, v39 != v10 - 1) )
                v48 = 0;
              v19 = 0;
              if ( v18 )
              {
                v20 = a3;
                while ( 1 )
                {
                  v21 = sub_1001D510(v20, v20 + 92, v20 + 164);
                  ++v19;
                  v20 = a3;
                  v42 = (v21 + v11 - v31) & ~((v21 + v11 - v31) >> 31) | (v21 + v11) & ((v21 + v11 - v31) >> 31);
                  *(&v47 + v19) = *(_WORD *)(*(_DWORD *)(a3 + 268) + 2 * v42);
                  if ( v19 >= v45 )
                    break;
                  v11 = (v21 + v11 - v31) & ~((v21 + v11 - v31) >> 31) | (v21 + v11) & ((v21 + v11 - v31) >> 31);
                }
              }
              v22 = (int)v29;
              v23 = v43;
              v40 = 0;
              v46 = v29;
              do
              {
                v24 = 0;
                do
                {
                  v25 = sub_1001D510(v22, a3 + 92, a3 + 212) + v13;
                  v22 = v25 - v32;
                  v13 = (v25 - v32) & ~((v25 - v32) >> 31) | ((v25 - v32) >> 31) & v25;
                  if ( (!v24 || !v48) && (!v40 || !v49) )
                  {
                    v26 = *(_DWORD *)(a3 + 284) + 6 * v13;
                    v22 = v50[(unsigned __int8)v46[v24]] | (*(_WORD *)v26 << 16);
                    *(_DWORD *)v23 = v22;
                    *(_DWORD *)(v23 + 4) = *(_WORD *)(v26 + 2) | (*(_WORD *)(v26 + 4) << 16);
                  }
                  ++v24;
                  v23 += 8;
                }
                while ( v24 < 2 );
                v46 += 2;
                v23 += v33 - 16;
                ++v40;
              }
              while ( v40 < 2 );
              v43 += v35;
              v11 = v42;
              v10 = a6;
              v39 += v34;
            }
            while ( v39 != v38 );
            v14 = v36;
          }
          v41 += 2 * v33;
          v36 = ++v14;
        }
        while ( v14 < a7 );
        v12 = v37;
        v9 = v30;
      }
      v37 = ++v12;
    }
    while ( v12 < v9 );
  }
  return 1;
}
// 1001F160: using guessed type int var_14[4];

//----- (1001F400) --------------------------------------------------------
void *__usercall sub_1001F400@<eax>(int a1@<ebx>, unsigned int a2)
{
  int v2; // eax@3
  int v3; // eax@4
  void *v4; // esi@4

  if ( !a1 )
    return 0;
  if ( a2 < 0x3E )
    return 0;
  v2 = sub_1001CCB0(0, 300);
  if ( !v2 )
    return 0;
  v3 = sub_1001D620(v2);
  v4 = (void *)v3;
  if ( !v3 )
    return 0;
  if ( !sub_1001D880(v3, a2, a1) )
  {
    sub_1001D740((int)v4);
    sub_1001CE80(v4);
    return 0;
  }
  return v4;
}

//----- (1001F4A0) --------------------------------------------------------
bool __usercall sub_1001F4A0@<al>(_DWORD *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, unsigned int a4@<esi>)
{
  bool result; // al@5

  if ( a1 && a3 && a2 >= 8 && *a1 == 519686845 )
    result = sub_1001D8C0((int)a1, a3, a2, a4);
  else
    result = 0;
  return result;
}

//----- (1001F4D0) --------------------------------------------------------
char __usercall sub_1001F4D0@<al>(void *a1@<edx>, int a2@<esi>)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edi@2
  int v4; // ecx@3
  int v5; // edi@16
  char v6; // cl@17
  unsigned __int8 v7; // cl@17
  char v8; // cl@17
  _BYTE *v9; // edi@21
  char v10; // cl@22
  unsigned __int8 v11; // cl@22
  char v12; // cl@22
  int v13; // edi@26
  char v14; // cl@27
  unsigned int v15; // edx@27
  char v16; // al@27
  int v17; // edx@31
  unsigned int v18; // ebx@35
  int v19; // edi@36
  double v20; // st7@37
  unsigned int v21; // ebx@40
  int v22; // edi@41
  double v23; // st7@42
  char *v24; // edi@46
  int v25; // ebx@47
  float v26; // ST18_4@47
  double v27; // st7@47
  int v28; // edi@51
  int v29; // ebx@52
  float v30; // ST1C_4@52
  float v31; // ST20_4@52
  float v32; // ST14_4@52
  unsigned int v33; // edi@55
  int v34; // ecx@56
  double v35; // st6@57
  unsigned int v36; // edi@60
  int v37; // ecx@61
  int v38; // eax@62
  double v39; // st6@62
  float *v40; // eax@62
  float v41; // ST18_4@62
  double v42; // st6@62
  unsigned int v43; // ebx@65
  int v44; // edi@66
  int v45; // ecx@66
  int v46; // eax@67
  float v47; // ST18_4@67
  float v48; // ST1C_4@67
  float v49; // ST20_4@67
  int v51; // [sp+14h] [bp-Ch]@46
  unsigned int v52; // [sp+18h] [bp-8h]@45
  unsigned int v53; // [sp+18h] [bp-8h]@50
  unsigned int v54; // [sp+1Ch] [bp-4h]@25

  v2 = *(_DWORD *)(a2 + 16);
  switch ( v2 )
  {
    case 3u:
      v2 = *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4);
      v3 = 0;
      if ( v2 )
      {
        v2 = (unsigned int)a1 + 2;
        v4 = 0;
        do
        {
          *(_BYTE *)(v2 - 2) = *(_BYTE *)(v4 + *(_DWORD *)(a2 + 64));
          *(_BYTE *)(v2 - 1) = *(_BYTE *)(v4 + *(_DWORD *)(a2 + 64) + 1);
          *(_BYTE *)v2 = *(_BYTE *)(v4 + *(_DWORD *)(a2 + 64) + 2);
          *(_BYTE *)(v2 + 1) = -1;
          ++v3;
          v4 += 3;
          v2 += 4;
        }
        while ( v3 < *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) );
      }
      break;
    case 4u:
      LOBYTE(v2) = (unsigned int)memcpy(a1, *(const void **)(a2 + 64), 4 * *(_DWORD *)(a2 + 4) * *(_DWORD *)(a2 + 8));
      break;
    case 0x25u:
    case 0xEu:
      v2 = 0;
      if ( *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) )
      {
        do
        {
          *((_BYTE *)a1 + 4 * v2) = *(_BYTE *)(*(_DWORD *)(a2 + 64) + 4 * v2 + 2);
          *((_BYTE *)a1 + 4 * v2 + 1) = *(_BYTE *)(*(_DWORD *)(a2 + 64) + 4 * v2 + 1);
          *((_BYTE *)a1 + 4 * v2 + 2) = *(_BYTE *)(*(_DWORD *)(a2 + 64) + 4 * v2);
          *((_BYTE *)a1 + 4 * v2 + 3) = *(_BYTE *)(*(_DWORD *)(a2 + 64) + 4 * v2 + 3);
          ++v2;
        }
        while ( v2 < *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) );
      }
      break;
    case 5u:
      v2 = 0;
      if ( *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) )
      {
        do
        {
          *((_BYTE *)a1 + 4 * v2) = *(_BYTE *)(*(_DWORD *)(a2 + 64) + 4 * v2 + 1);
          *((_BYTE *)a1 + 4 * v2 + 1) = *(_BYTE *)(*(_DWORD *)(a2 + 64) + 4 * v2 + 2);
          *((_BYTE *)a1 + 4 * v2 + 2) = *(_BYTE *)(*(_DWORD *)(a2 + 64) + 4 * v2 + 3);
          *((_BYTE *)a1 + 4 * v2 + 3) = *(_BYTE *)(*(_DWORD *)(a2 + 64) + 4 * v2);
          ++v2;
        }
        while ( v2 < *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) );
      }
      break;
    case 2u:
      v2 = 0;
      if ( *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) )
      {
        v5 = (int)a1 + 2;
        do
        {
          *(_BYTE *)(v5 - 1) = (*(_BYTE *)(*(_DWORD *)(a2 + 64) + 2 * v2) >> 4) | *(_BYTE *)(*(_DWORD *)(a2 + 64)
                                                                                           + 2 * v2) & 0xF0;
          v6 = *(_BYTE *)(*(_DWORD *)(a2 + 64) + 2 * v2);
          *(_BYTE *)v5 = 16 * v6 | v6 & 0xF;
          v7 = *(_BYTE *)(*(_DWORD *)(a2 + 64) + 2 * v2 + 1);
          *(_BYTE *)(v5 + 1) = (v7 >> 4) | v7 & 0xF0;
          v8 = *(_BYTE *)(*(_DWORD *)(a2 + 64) + 2 * v2 + 1);
          *(_BYTE *)(v5 - 2) = 16 * v8 | v8 & 0xF;
          ++v2;
          v5 += 4;
        }
        while ( v2 < *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) );
      }
      break;
    case 0xDu:
      v2 = 0;
      if ( *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) )
      {
        v9 = (char *)a1 + 3;
        do
        {
          *(v9 - 1) = (*(_BYTE *)(*(_DWORD *)(a2 + 64) + 2 * v2) >> 4) | *(_BYTE *)(*(_DWORD *)(a2 + 64) + 2 * v2) & 0xF0;
          v10 = *(_BYTE *)(*(_DWORD *)(a2 + 64) + 2 * v2);
          *v9 = 16 * v10 | v10 & 0xF;
          v11 = *(_BYTE *)(*(_DWORD *)(a2 + 64) + 2 * v2 + 1);
          *(v9 - 3) = (v11 >> 4) | v11 & 0xF0;
          v12 = *(_BYTE *)(*(_DWORD *)(a2 + 64) + 2 * v2 + 1);
          *(v9 - 2) = 16 * v12 | v12 & 0xF;
          ++v2;
          v9 += 4;
        }
        while ( v2 < *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) );
      }
      break;
    case 7u:
      v2 = *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4);
      v54 = 0;
      if ( v2 )
      {
        v13 = (int)a1 + 2;
        do
        {
          v14 = ((unsigned int)*(_WORD *)(*(_DWORD *)(a2 + 64) + 2 * v54) >> 11) & 0x1F;
          v15 = (unsigned int)*(_WORD *)(*(_DWORD *)(a2 + 64) + 2 * v54) >> 5;
          v16 = *(_WORD *)(*(_DWORD *)(a2 + 64) + 2 * v54) & 0x1F;
          *(_BYTE *)(v13 - 2) = 8 * v14 | v14 & 7;
          *(_BYTE *)(v13 - 1) = 4 * (v15 & 0x3F) | v15 & 3;
          *(_BYTE *)v13 = 8 * v16 | v16 & 7;
          *(_BYTE *)(v13 + 1) = -1;
          v2 = v54 + 1;
          v13 += 4;
          v54 = v2;
        }
        while ( v2 < *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) );
      }
      break;
    case 1u:
      v2 = 0;
      if ( *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) )
      {
        v17 = (int)a1 + 2;
        do
        {
          *(_BYTE *)(v17 - 2) = -1;
          *(_BYTE *)(v17 - 1) = -1;
          *(_BYTE *)v17 = -1;
          *(_BYTE *)(v17 + 1) = *(_BYTE *)(v2++ + *(_DWORD *)(a2 + 64));
          v17 += 4;
        }
        while ( v2 < *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) );
      }
      break;
    case 9u:
      v2 = *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4);
      v18 = 0;
      if ( v2 )
      {
        v19 = (int)a1 + 2;
        do
        {
          v20 = sub_1001B230((_WORD *)(*(_DWORD *)(a2 + 64) + 2 * v18));
          *(_WORD *)(v19 - 1) = 0;
          *(_BYTE *)(v19 + 1) = -1;
          ++v18;
          v19 += 4;
          *(_BYTE *)(v19 - 6) = (signed int)(v20 * 256.0);
          v2 = *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4);
        }
        while ( v18 < v2 );
      }
      break;
    case 0xFu:
      v21 = 0;
      if ( *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) )
      {
        v22 = (int)a1 + 2;
        do
        {
          v23 = sub_1001B230((_WORD *)(*(_DWORD *)(a2 + 64) + 2 * v21));
          *(_WORD *)(v22 - 1) = 0;
          *(_BYTE *)(v22 + 1) = -1;
          ++v21;
          v22 += 4;
          LOBYTE(v2) = (signed int)(v23 * 256.0);
          *(_BYTE *)(v22 - 6) = v2;
        }
        while ( v21 < *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) );
      }
      break;
    case 0x10u:
      v2 = *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4);
      v52 = 0;
      if ( v2 )
      {
        v24 = (char *)a1 + 2;
        v51 = -2 - (_DWORD)a1;
        do
        {
          v25 = (int)(&v24[v51] + *(_DWORD *)(a2 + 64));
          v26 = sub_1001B230((_WORD *)(v25 + 2));
          v27 = sub_1001B230((_WORD *)v25);
          *(_WORD *)v24 = -256;
          v24 += 4;
          *(v24 - 6) = (signed int)(v27 * 256.0);
          LOBYTE(v2) = ++v52;
          *(v24 - 5) = (signed int)(256.0 * v26);
        }
        while ( v52 < *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) );
      }
      break;
    case 0x11u:
      v2 = *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4);
      v53 = 0;
      if ( v2 )
      {
        v28 = (int)a1 + 2;
        do
        {
          v29 = *(_DWORD *)(a2 + 64) + 8 * v53;
          v30 = sub_1001B230((_WORD *)(v29 + 2));
          v31 = sub_1001B230((_WORD *)(v29 + 4));
          v32 = sub_1001B230((_WORD *)(v29 + 6));
          v28 += 4;
          *(_BYTE *)(v28 - 6) = (signed int)(sub_1001B230((_WORD *)v29) * 256.0);
          *(_BYTE *)(v28 - 5) = (signed int)(v30 * 256.0);
          *(_BYTE *)(v28 - 4) = (signed int)(v31 * 256.0);
          *(_BYTE *)(v28 - 3) = (signed int)(256.0 * v32);
          v2 = v53 + 1;
          v53 = v2;
        }
        while ( v2 < *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) );
      }
      break;
    case 0x12u:
      v2 = *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4);
      v33 = 0;
      if ( v2 )
      {
        v34 = (int)a1 + 2;
        do
        {
          v35 = *(float *)(v34 + -2 - (_DWORD)a1 + *(_DWORD *)(a2 + 64)) * 256.0;
          *(_WORD *)(v34 - 1) = 0;
          *(_BYTE *)(v34 + 1) = -1;
          ++v33;
          v34 += 4;
          *(_BYTE *)(v34 - 6) = (signed int)v35;
          v2 = *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4);
        }
        while ( v33 < v2 );
      }
      break;
    case 0x13u:
      v36 = 0;
      if ( *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) )
      {
        v37 = (int)a1 + 2;
        do
        {
          v38 = *(_DWORD *)(a2 + 64);
          v39 = *(float *)(v38 + 8 * v36 + 4);
          v40 = (float *)(v38 + 8 * v36);
          v41 = v39;
          ++v36;
          v37 += 4;
          v42 = *v40 * 256.0;
          *(_BYTE *)(v37 - 4) = 0;
          *(_BYTE *)(v37 - 3) = -1;
          *(_BYTE *)(v37 - 6) = (signed int)v42;
          *(_BYTE *)(v37 - 5) = (signed int)(v41 * 256.0);
          v2 = *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4);
        }
        while ( v36 < v2 );
      }
      break;
    case 0x14u:
      v43 = 0;
      if ( *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4) )
      {
        v44 = 0;
        v45 = (int)a1 + 2;
        do
        {
          v46 = v44 + *(_DWORD *)(a2 + 64);
          v47 = *(float *)(v46 + 4);
          ++v43;
          v44 += 16;
          v48 = *(float *)(v46 + 8);
          v45 += 4;
          v49 = *(float *)(v46 + 12);
          *(_BYTE *)(v45 - 6) = (signed int)(*(float *)v46 * 256.0);
          *(_BYTE *)(v45 - 5) = (signed int)(v47 * 256.0);
          *(_BYTE *)(v45 - 4) = (signed int)(v48 * 256.0);
          *(_BYTE *)(v45 - 3) = (signed int)(v49 * 256.0);
          v2 = *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4);
        }
        while ( v43 < v2 );
      }
      break;
  }
  return v2;
}

//----- (1001FC80) --------------------------------------------------------
bool __cdecl sub_1001FC80(int a1, void *a2)
{
  int v2; // esi@1
  int v3; // edi@1
  void *v4; // ebx@2
  unsigned int v5; // edx@6
  int v6; // edi@7
  unsigned int v7; // edi@8
  _DWORD *v8; // ebx@10
  signed int v9; // eax@10
  bool result; // al@12
  int v11; // ecx@18
  int v12; // eax@24
  HMODULE v13; // eax@29
  HMODULE v14; // ebx@29
  FARPROC v15; // eax@30
  int v16; // edi@30
  void *v17; // [sp+Ch] [bp-74h]@18
  int v18; // [sp+10h] [bp-70h]@18
  int v19; // [sp+14h] [bp-6Ch]@18
  unsigned int v20; // [sp+18h] [bp-68h]@18
  unsigned int v21; // [sp+1Ch] [bp-64h]@18
  int v22; // [sp+20h] [bp-60h]@19
  int v23; // [sp+24h] [bp-5Ch]@23
  int v24; // [sp+28h] [bp-58h]@23
  int v25; // [sp+2Ch] [bp-54h]@23
  struct TextureInfo *v26; // [sp+44h] [bp-3Ch]@23
  int v27; // [sp+48h] [bp-38h]@18
  int v28; // [sp+50h] [bp-30h]@6
  int v29; // [sp+54h] [bp-2Ch]@7
  int v30; // [sp+58h] [bp-28h]@7
  int v31; // [sp+70h] [bp-10h]@10
  int v32; // [sp+74h] [bp-Ch]@7
  int v33; // [sp+78h] [bp-8h]@3
  void *v34; // [sp+7Ch] [bp-4h]@7

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 16);
  switch ( v3 )
  {
    case 10:
    case 12:
    case 28:
    case 29:
      v4 = *(void **)(a1 + 64);
      *(_DWORD *)(a1 + 20) = 1;
      if ( (v3 == 10 || (v33 = 4, v3 == 28)) && (v33 = 1, v3 == 28) || v3 == 29 )
      {
        v5 = *(_DWORD *)(a1 + 60);
        v28 = 36;
        if ( !sub_1001CFC0(v5, (int)&v28, (int)v4) )
          goto LABEL_12;
        v6 = v29;
        v32 = GetCompressedTextureDataSize(v29, v30, 2 * (*(_DWORD *)(a1 + 16) != 28) + 10);
        v34 = malloc(v32);
        if ( !v34 )
          goto LABEL_12;
        v7 = (unsigned int)(v6 + 3) >> 2;
        if ( !v7 )
          v7 = 1;
        v8 = sub_1001F400(*(_DWORD *)(a1 + 64), *(_DWORD *)(a1 + 60));
        v9 = sub_1001CF10(v31);
        if ( !sub_1001F4A0(v8, v32, (int)&v34, v7 * v9) )
        {
          free(v34);
          goto LABEL_12;
        }
        v4 = v34;
        v2 = a1;
      }
      if ( !v4 )
        goto LABEL_12;
      sub_1002A950(*(_DWORD *)(v2 + 4), (int)a2, *(_DWORD *)(v2 + 8), (int)v4, v33);
      if ( v4 != *(void **)(v2 + 64) )
        free(v4);
      return 1;
    default:
      goto LABEL_12;
    case 24:
    case 25:
    case 26:
    case 27:
      memset(&v27, 0, 0x2Cu);
      memset(&v17, 0, 0x3Cu);
      v11 = *(_DWORD *)(a1 + 8);
      v17 = *(void **)(a1 + 64);
      v18 = *(_DWORD *)(a1 + 4);
      v20 = (v18 + 3) & 0xFFFFFFFC;
      v21 = (v18 + 3) & 0xFFFFFFFC;
      v19 = v11;
      switch ( v3 )
      {
        case 26:
          v22 = 1;
          break;
        case 27:
          v22 = 65;
          break;
        case 24:
          v22 = 17477;
          break;
        case 25:
          v22 = 100;
          break;
        default:
          break;
      }
      v26 = match_texture_type(v22);
      v23 = *((_DWORD *)v26 + 7);
      v24 = *((_DWORD *)v26 + 5);
      v25 = *((_DWORD *)v26 + 6);
      set_texture_decoding_function((struct Texture *)&v17, 0);
      convert_texture_to_image((struct Texture *)&v17, (struct Image *)&v27);
      if ( !v27 )
        goto LABEL_12;
      memset(&v17, 0, 0x3Cu);
      v12 = *(_DWORD *)(a1 + 16);
      if ( v12 == 26 || v12 == 27 )
      {
        convert_image_to_8_bit_format((struct Image *)&v27, 4, 0);
        if ( !v27 )
          goto LABEL_12;
      }
      copy_image_to_uncompressed_texture((struct Image *)&v27, 8225, (struct Texture *)&v17);
      destroy_image((struct Image *)&v27);
      if ( !v17 )
        goto LABEL_12;
      memcpy(a2, v17, 4 * *(_DWORD *)(a1 + 4) * *(_DWORD *)(a1 + 8));
      destroy_texture((struct Texture *)&v17);
      result = 1;
      break;
    case 21:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
      v13 = LoadLibraryW(L"TexToolWrap.dll");
      v14 = v13;
      if ( v13 )
      {
        v15 = GetProcAddress(v13, "Decompress");
        v16 = 0;
        if ( v15 )
          v16 = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, void *, int))v15)(
                  *(_DWORD *)(a1 + 16),
                  *(_DWORD *)(a1 + 8),
                  *(_DWORD *)(a1 + 4),
                  *(_DWORD *)(a1 + 20),
                  *(_DWORD *)(a1 + 64),
                  *(_DWORD *)(a1 + 60),
                  a2,
                  4 * *(_DWORD *)(a1 + 8) * *(_DWORD *)(a1 + 4));
        FreeLibrary(v14);
        result = v16 == 4 * *(_DWORD *)(a1 + 4) * *(_DWORD *)(a1 + 8);
      }
      else
      {
LABEL_12:
        result = 0;
      }
      break;
  }
  return result;
}
// 100AE67C: using guessed type void __cdecl destroy_texture(struct Texture *);
// 100AE680: using guessed type void __cdecl destroy_image(struct Image *);
// 100AE684: using guessed type void __cdecl copy_image_to_uncompressed_texture(struct Image *, _DWORD, struct Texture *);
// 100AE688: using guessed type void __cdecl convert_image_to_8_bit_format(struct Image *, _DWORD, _DWORD);
// 100AE68C: using guessed type void __cdecl convert_texture_to_image(struct Texture *, struct Image *);
// 100AE690: using guessed type void __cdecl set_texture_decoding_function(struct Texture *, struct Image *);
// 100AE694: using guessed type struct TextureInfo *__cdecl match_texture_type(_DWORD);

//----- (1001FFC0) --------------------------------------------------------
int __cdecl GetCompressedTextureDataSizeCrunch(struct TextureFile *a1)
{
  unsigned int v1; // edx@1
  int v2; // ST00_4@1
  int result; // eax@3
  int v4; // [sp+4h] [bp-24h]@1
  int v5; // [sp+8h] [bp-20h]@3
  int v6; // [sp+Ch] [bp-1Ch]@3
  int v7; // [sp+24h] [bp-4h]@2

  v1 = *((_DWORD *)a1 + 15);
  v2 = *((_DWORD *)a1 + 16);
  v4 = 36;
  if ( sub_1001CFC0(v1, (int)&v4, v2) )
  {
    switch ( v7 )
    {
      case 0:
      case 9:
      case 10:
        result = 4 * v5 * v6;
        break;
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
        result = 8 * v5 * v6;
        break;
      default:
        result = 0;
        break;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10020050) --------------------------------------------------------
int __cdecl GetCompressedTextureDataSize(int a1, int a2, int a3)
{
  int result; // eax@2
  HMODULE v4; // eax@4
  HMODULE v5; // edi@4
  FARPROC v6; // eax@5
  int v7; // esi@5

  switch ( a3 )
  {
    case 10:
    case 26:
      result = sub_1002A7A0(a1, a2);
      break;
    case 12:
    case 24:
    case 25:
    case 27:
      result = sub_1002A7A0(a1, a2);
      break;
    case 21:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
      v4 = LoadLibraryW(L"TexToolWrap.dll");
      v5 = v4;
      if ( !v4 )
        goto LABEL_8;
      v6 = GetProcAddress(v4, "GetMaxCompressedSize");
      v7 = 0;
      if ( v6 )
        v7 = ((int (__cdecl *)(int, int, int))v6)(a1, a2, a3);
      FreeLibrary(v5);
      result = v7;
      break;
    default:
LABEL_8:
      result = 0;
      break;
  }
  return result;
}

//----- (10020130) --------------------------------------------------------
DWORD __stdcall StartAddress(LPVOID lpThreadParameter)
{
  (*((void (__cdecl **)(_DWORD, _DWORD, _DWORD))lpThreadParameter + 6))(
    lpThreadParameter,
    *((_DWORD *)lpThreadParameter + 4),
    *((_DWORD *)lpThreadParameter + 5));
  return 0;
}

//----- (10020150) --------------------------------------------------------
void __usercall sub_10020150(int a1@<eax>, int a2, int a3, int a4)
{
  int v4; // ebx@1
  unsigned int v5; // edi@2
  unsigned int v6; // eax@4
  int v7; // esi@6
  char *v8; // eax@6
  int v9; // edi@6
  int v10; // ecx@7
  int v11; // esi@7
  bool v12; // zf@9
  int v13; // ecx@11
  HANDLE *v14; // esi@13
  DWORD v15; // edi@13
  struct _SYSTEM_INFO SystemInfo; // [sp+4h] [bp-38h]@2
  int v17; // [sp+28h] [bp-14h]@7
  char *v18; // [sp+2Ch] [bp-10h]@6
  DWORD v19; // [sp+30h] [bp-Ch]@7
  unsigned int v20; // [sp+34h] [bp-8h]@6
  DWORD v21; // [sp+38h] [bp-4h]@2

  v4 = a1;
  if ( *(_DWORD *)(a1 + 8) > 0 )
  {
    GetSystemInfo(&SystemInfo);
    v5 = SystemInfo.dwNumberOfProcessors;
    v21 = SystemInfo.dwNumberOfProcessors;
    if ( !SystemInfo.dwNumberOfProcessors )
    {
      v21 = 1;
      v5 = 1;
    }
    v6 = *(_DWORD *)(v4 + 8) >> 2;
    if ( v5 > v6 )
    {
      v21 = *(_DWORD *)(v4 + 8) >> 2;
      v5 = v6;
    }
    v7 = v6 / v5;
    v20 = v6 % v5;
    v8 = (char *)unknown_libname_4(32 * v5 | -((unsigned __int64)v5 >> 27 != 0));
    v9 = 0;
    v18 = v8;
    if ( v21 )
    {
      v10 = 4 * v7;
      v17 = 4 * v7;
      v11 = (int)(v8 + 12);
      v19 = v21;
      while ( 1 )
      {
        v12 = v20 == 0;
        *(_DWORD *)(v11 - 12) = *(_DWORD *)v4 + v9 * *(_DWORD *)(v4 + 12);
        *(_DWORD *)(v11 - 8) = *(_DWORD *)(v4 + 4);
        *(_DWORD *)v11 = *(_DWORD *)(v4 + 12);
        *(_DWORD *)(v11 - 4) = v10;
        if ( !v12 )
        {
          --v20;
          *(_DWORD *)(v11 - 4) = v10 + 4;
        }
        v13 = a2 + v9 * *(_DWORD *)(v4 + 4);
        v9 += *(_DWORD *)(v11 - 4);
        *(_DWORD *)(v11 + 4) = v13;
        *(_DWORD *)(v11 + 8) = a3;
        *(_DWORD *)(v11 + 12) = a4;
        *(_DWORD *)(v11 + 16) = CreateThread(0, 0, StartAddress, (LPVOID)(v11 - 12), 0, 0);
        v11 += 32;
        if ( !--v19 )
          break;
        v10 = v17;
      }
      v8 = v18;
      if ( v21 )
      {
        v14 = (HANDLE *)(v18 + 28);
        v15 = v21;
        do
        {
          WaitForSingleObject(*v14, 0xFFFFFFFF);
          CloseHandle(*v14);
          v14 += 8;
          --v15;
        }
        while ( v15 );
        v8 = v18;
      }
    }
    operator delete[](v8);
  }
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 10099190: using guessed type void __cdecl operator delete[](void *);

//----- (10020290) --------------------------------------------------------
void __usercall sub_10020290(int a1@<edx>, int a2, void *a3, int *a4, int a5)
{
  int v5; // esi@1
  int v6; // ecx@5
  HMODULE v7; // eax@10
  HMODULE v8; // esi@10
  int v9; // eax@13
  void *v10; // edx@13
  void *v11; // ST18_4@13
  unsigned int v12; // ecx@24
  int v13; // eax@24
  bool v14; // zf@24
  unsigned int v15; // esi@26
  int v16; // edi@27
  int v17; // esi@28
  __int16 v18; // ax@28
  int v19; // edx@28
  __int16 v20; // ax@28
  int v21; // ecx@28
  unsigned int v22; // ecx@29
  unsigned int v23; // esi@29
  int v24; // edx@30
  int v25; // eax@30
  int v26; // esi@30
  int v27; // ecx@31
  __int16 v28; // di@31
  int v29; // ecx@31
  unsigned int v30; // ecx@34
  void *v31; // eax@34
  int v32; // esi@34
  char *v33; // edi@35
  int v34; // eax@45
  int *v35; // ecx@45
  char *v36; // ST20_4@45
  int v37; // eax@55
  int v38; // ecx@55
  unsigned int v39; // esi@55
  unsigned int v40; // edx@55
  void *v41; // edi@55
  int v42; // edx@58
  unsigned int v43; // eax@59
  unsigned int v44; // eax@62
  int v45; // eax@71
  int *v46; // ecx@71
  HMODULE v47; // eax@73
  HMODULE v48; // esi@73
  FARPROC v49; // eax@74
  int v50; // eax@75
  HMODULE v51; // ST20_4@75
  int v52; // eax@77
  int v53; // edx@77
  void *v54; // ebx@77
  HMODULE v55; // ST20_4@78
  void *v56; // ST18_4@78
  void *v57; // [sp+14h] [bp-2BCh]@5
  int v58; // [sp+18h] [bp-2B8h]@5
  int v59; // [sp+1Ch] [bp-2B4h]@5
  unsigned int v60; // [sp+20h] [bp-2B0h]@5
  unsigned int v61; // [sp+24h] [bp-2ACh]@5
  int v62; // [sp+28h] [bp-2A8h]@5
  int v63; // [sp+2Ch] [bp-2A4h]@5
  int v64; // [sp+30h] [bp-2A0h]@5
  int v65; // [sp+34h] [bp-29Ch]@5
  int v66; // [sp+38h] [bp-298h]@5
  int v67; // [sp+3Ch] [bp-294h]@5
  char *v68; // [sp+40h] [bp-290h]@38
  unsigned int v69; // [sp+44h] [bp-28Ch]@38
  void *v70; // [sp+48h] [bp-288h]@38
  unsigned int v71; // [sp+4Ch] [bp-284h]@38
  unsigned int v72; // [sp+50h] [bp-280h]@26
  unsigned int v73; // [sp+54h] [bp-27Ch]@24
  int v74; // [sp+58h] [bp-278h]@25
  unsigned int v75; // [sp+5Ch] [bp-274h]@24
  int *v76; // [sp+60h] [bp-270h]@1
  void *v77; // [sp+64h] [bp-26Ch]@1
  void *v78; // [sp+68h] [bp-268h]@1
  void *v79; // [sp+6Ch] [bp-264h]@24
  char *v80; // [sp+70h] [bp-260h]@25
  char *v81; // [sp+74h] [bp-25Ch]@6
  HMODULE hLibModule; // [sp+78h] [bp-258h]@28
  char v83; // [sp+7Fh] [bp-251h]@17
  char v84; // [sp+80h] [bp-250h]@77
  int v85; // [sp+84h] [bp-24Ch]@77
  int v86; // [sp+8Ch] [bp-244h]@77
  int v87; // [sp+90h] [bp-240h]@77
  int v88; // [sp+98h] [bp-238h]@77
  void *v89; // [sp+A0h] [bp-230h]@77
  int v90; // [sp+224h] [bp-ACh]@77
  int v91; // [sp+250h] [bp-80h]@77
  signed int (*v92)(); // [sp+25Ch] [bp-74h]@77
  int v93; // [sp+268h] [bp-68h]@77
  int v94; // [sp+26Ch] [bp-64h]@77
  int v95; // [sp+270h] [bp-60h]@77
  int v96; // [sp+274h] [bp-5Ch]@77
  float v97; // [sp+278h] [bp-58h]@50
  void *v98; // [sp+27Ch] [bp-54h]@12
  int v99; // [sp+280h] [bp-50h]@77
  int v100; // [sp+284h] [bp-4Ch]@77
  int v101; // [sp+288h] [bp-48h]@77
  int v102; // [sp+28Ch] [bp-44h]@77
  int v103; // [sp+290h] [bp-40h]@77
  float v104; // [sp+294h] [bp-3Ch]@77
  float v105; // [sp+298h] [bp-38h]@77
  int v106; // [sp+29Ch] [bp-34h]@77
  int v107; // [sp+2A0h] [bp-30h]@77
  int v108; // [sp+2A4h] [bp-2Ch]@77
  int v109; // [sp+2A8h] [bp-28h]@77
  int v110; // [sp+2ACh] [bp-24h]@77
  int v111; // [sp+2B0h] [bp-20h]@77
  int v112; // [sp+2B4h] [bp-1Ch]@77
  void *v113; // [sp+2BCh] [bp-14h]@39
  unsigned int v114; // [sp+2C0h] [bp-10h]@55
  int v115; // [sp+2C4h] [bp-Ch]@55
  int v116; // [sp+2C8h] [bp-8h]@55

  v5 = *(_DWORD *)(a2 + 16);
  v77 = a3;
  v78 = (void *)a1;
  v76 = a4;
  if ( v5 == 28 || v5 == 29 )
  {
    sub_1001C5A0(a5, (int)&v84);
    v52 = *(_DWORD *)(a2 + 8);
    v97 = 2.2;
    v53 = *(_DWORD *)(a2 + 4);
    *(float *)&v98 = 0.89999998;
    v87 = v52;
    v104 = 1.0;
    v105 = 1.0;
    v86 = v53;
    v89 = v78;
    v85 = 0;
    v101 = 0;
    v102 = 0;
    v103 = 0;
    v106 = 0;
    v107 = 0;
    v108 = 0;
    v109 = 0;
    v110 = 0;
    v111 = 0;
    v112 = 0;
    v96 = 0;
    v91 = 1;
    v100 = 1;
    v88 = v5 != 28 ? 2 : 0;
    v90 = 255;
    v92 = sub_100150C0;
    v93 = 80;
    v95 = 4;
    v99 = 16;
    v94 = 3;
    v54 = sub_10092BE0((float *)&v79, &v80, (int)&v84, (int)&v93, &hLibModule);
    if ( v54 )
    {
      v55 = hLibModule;
      v56 = v77;
      *a4 = (int)hLibModule;
      a4[1] = 0;
      memcpy(v56, v54, (size_t)v55);
      if ( (unsigned __int8)v54 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v54, 0, 0, 1, dword_100AE9F4);
    }
    else
    {
      *a4 = 0;
      a4[1] = 0;
    }
  }
  else
  {
    switch ( v5 )
    {
      case 10:
      case 12:
        sub_1002A820((int)v77, (int)v78, *(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8), v5 != 10 ? 4 : 1);
        *a4 = GetCompressedTextureDataSize(*(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 16));
        a4[1] = 0;
        break;
      case 26:
      case 27:
        memset(&v57, 0, 0x2Cu);
        v6 = *(_DWORD *)(a2 + 8);
        v58 = *(_DWORD *)(a2 + 4);
        v60 = (v58 + 3) & 0xFFFFFFFC;
        v61 = (v58 + 3) & 0xFFFFFFFC;
        v62 = 8;
        v64 = 8;
        v57 = v78;
        v59 = v6;
        v63 = 4;
        v65 = 0;
        v66 = 0;
        v67 = 0;
        switch ( v5 )
        {
          case 26:
            v81 = (char *)1;
            break;
          case 27:
            v81 = (char *)65;
            break;
          case 24:
            v81 = (char *)17477;
            break;
          case 25:
            v81 = (char *)100;
            break;
          default:
            break;
        }
        get_number_of_texture_formats();
        v7 = LoadLibraryW(L"texgenpack.dll");
        v8 = v7;
        if ( v7 )
          *(_DWORD *)GetProcAddress(v7, "option_compression_level") = a5;
        memset(&v98, 0, 0x3Cu);
        compress_image(
          (struct Image *)&v57,
          v81,
          (void (__cdecl *)(struct BlockUserData_t *))AssetTypeValue::~AssetTypeValue,
          (struct Texture *)&v98,
          0,
          0.0,
          0.0);
        if ( *(float *)&v98 == 0.0 )
        {
          *a4 = 0;
          a4[1] = 0;
        }
        else
        {
          v9 = GetCompressedTextureDataSize(*(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 16));
          v10 = v98;
          *a4 = v9;
          v11 = v77;
          a4[1] = 0;
          memcpy(v11, v10, v9);
          destroy_texture((struct Texture *)&v98);
        }
        if ( v8 )
          FreeLibrary(v8);
        break;
      case 24:
        v83 = 0;
        switch ( a5 )
        {
          case 5:
            v83 = 1;
            goto LABEL_19;
          case 0:
LABEL_19:
            GetProfile_bc6h_veryfast(a5);
            goto LABEL_24;
          case 6:
            v83 = 1;
            goto LABEL_21;
          case 1:
LABEL_21:
            GetProfile_bc6h_fast(a5);
            goto LABEL_24;
          case 7:
            v83 = 1;
            goto LABEL_23;
          default:
LABEL_23:
            GetProfile_bc6h_basic(a5);
            goto LABEL_24;
          case 8:
            v83 = 1;
            goto LABEL_41;
          case 3:
LABEL_41:
            GetProfile_bc6h_slow(&v113);
            goto LABEL_24;
          case 9:
            v83 = 1;
            break;
          case 4:
            break;
        }
        GetProfile_bc6h_veryslow(a5);
LABEL_24:
        v12 = (*(_DWORD *)(a2 + 4) + 3) & 0xFFFFFFFC;
        v79 = (void *)((*(_DWORD *)(a2 + 8) + 3) & 0xFFFFFFFC);
        v75 = v12;
        v13 = unknown_libname_4(8 * v12 * (_DWORD)v79 | -((unsigned __int64)(4 * v12 * (unsigned int)v79) >> 31 != 0));
        v14 = *(_DWORD *)(a2 + 8) == 0;
        v81 = (char *)v13;
        v73 = 0;
        if ( !v14 )
        {
          v74 = 0;
          v80 = (char *)(v13 + 4);
          do
          {
            v15 = *(_DWORD *)(a2 + 4);
            v72 = 0;
            if ( v15 )
            {
              v16 = (int)v80;
              do
              {
                v17 = 4 * (v72 + v73 * v15);
                *(float *)&hLibModule = (double)*((_BYTE *)v78 + v17) / 255.0;
                *(_WORD *)(v16 - 4) = sub_10021800(*(float *)&hLibModule);
                *(float *)&hLibModule = (double)*((_BYTE *)v78 + v17 + 1) / 255.0;
                v18 = sub_10021800(*(float *)&hLibModule);
                v19 = (int)v78;
                *(_WORD *)(v16 - 2) = v18;
                *(float *)&hLibModule = (double)*(_BYTE *)(v19 + v17 + 2) / 255.0;
                v20 = sub_10021800(*(float *)&hLibModule);
                v21 = (int)v78;
                *(_WORD *)v16 = v20;
                *(float *)&hLibModule = (double)*(_BYTE *)(v21 + v17 + 3) / 255.0;
                *(_WORD *)(v16 + 2) = sub_10021800(*(float *)&hLibModule);
                v15 = *(_DWORD *)(a2 + 4);
                v16 += 8;
                ++v72;
              }
              while ( v72 < v15 );
            }
            v22 = *(_DWORD *)(a2 + 4);
            v23 = v75;
            if ( v22 < v75 )
            {
              v24 = (int)v81;
              v25 = (int)&v81[8 * (v22 + v74) + 4];
              v26 = v75 - v22;
              do
              {
                v27 = v74 + *(_DWORD *)(a2 + 4);
                v28 = *(_WORD *)(v24 + 8 * v27 - 8);
                v29 = 4 * v27 - 4;
                *(_WORD *)(v25 - 4) = v28;
                *(_WORD *)(v25 - 2) = *(_WORD *)(v24 + 2 * v29 + 2);
                *(_WORD *)v25 = *(_WORD *)(v24 + 2 * v29 + 4);
                *(_WORD *)(v25 + 2) = *(_WORD *)(v24 + 2 * v29 + 6);
                v25 += 8;
                --v26;
              }
              while ( v26 );
              v23 = v75;
            }
            v74 += v23;
            v80 += 8 * v23;
            ++v73;
          }
          while ( v73 < *(_DWORD *)(a2 + 8) );
        }
        v30 = *(_DWORD *)(a2 + 8);
        v31 = v79;
        v32 = v75;
        if ( v30 < (unsigned int)v79 )
        {
          v33 = &v81[8 * v75 * v30];
          v80 = (char *)v79 - v30;
          do
          {
            memcpy(v33, &v81[8 * v75 * (*(_DWORD *)(a2 + 8) - 1)], 8 * v75);
            v33 += 8 * v75;
            --v80;
          }
          while ( v80 );
          v31 = v79;
        }
        v68 = v81;
        v69 = v75;
        v70 = v31;
        v71 = 8 * v75;
        if ( v83 )
          sub_10020150((int)&v68, (int)v77, (int)&v113, (int)CompressBlocksBC6H);
        else
          CompressBlocksBC6H(&v68, v77, &v113);
        v34 = GetCompressedTextureDataSize(v32, (int)v79, *(_DWORD *)(a2 + 16));
        v35 = v76;
        v36 = v81;
        *v76 = v34;
        v35[1] = 0;
        operator delete[](v36);
        break;
      case 25:
        v83 = 0;
        switch ( a5 )
        {
          case 5:
            v83 = 1;
            goto LABEL_48;
          case 0:
LABEL_48:
            GetProfile_alpha_ultrafast(a5);
            goto LABEL_55;
          case 6:
            v83 = 1;
            goto LABEL_50;
          case 1:
LABEL_50:
            GetProfile_alpha_veryfast(&v97);
            goto LABEL_55;
          case 7:
            v83 = 1;
            goto LABEL_52;
          case 2:
LABEL_52:
            GetProfile_alpha_fast(a5);
            goto LABEL_55;
          case 8:
            v83 = 1;
            goto LABEL_54;
          default:
LABEL_54:
            GetProfile_alpha_basic(&v97);
            goto LABEL_55;
          case 9:
            v83 = 1;
            break;
          case 4:
            break;
        }
        GetProfile_alpha_slow(a5);
LABEL_55:
        v37 = *(_DWORD *)(a2 + 4);
        v38 = *(_DWORD *)(a2 + 8);
        v113 = v78;
        v116 = 4 * v37;
        v39 = (v37 + 3) & 0xFFFFFFFC;
        v40 = (v38 + 3) & 0xFFFFFFFC;
        v41 = 0;
        v114 = v37;
        v115 = v38;
        v81 = (char *)((v38 + 3) & 0xFFFFFFFC);
        if ( v37 != v39 || v38 != v40 )
        {
          v41 = (void *)unknown_libname_4(4 * v39 * v40);
          v79 = v41;
          if ( *(_DWORD *)(a2 + 4) != v39 )
          {
            v42 = 0;
            v80 = 0;
            if ( *(_DWORD *)(a2 + 8) )
            {
              do
              {
                v43 = *(_DWORD *)(a2 + 4);
                hLibModule = *((HMODULE *)v41 + v43 + v42 - 1);
                if ( v43 < v39 )
                {
                  memset32((char *)v79 + 4 * (v42 + v43), (int)hLibModule, v39 - v43);
                  v41 = v79;
                }
                v42 += v39;
                ++v80;
              }
              while ( (unsigned int)v80 < *(_DWORD *)(a2 + 8) );
            }
          }
          v44 = *(_DWORD *)(a2 + 8);
          if ( v44 < (unsigned int)v81 )
          {
            v79 = (char *)v41 + 4 * v39 * v44;
            v80 = &v81[-v44];
            do
            {
              memcpy(v79, (char *)v41 + 4 * v39 * (*(_DWORD *)(a2 + 8) - 1), 4 * v39);
              v79 = (char *)v79 + 4 * v39;
              --v80;
            }
            while ( v80 );
          }
          v113 = v41;
          v114 = v39;
          v115 = (int)v81;
          v116 = 4 * v39;
        }
        if ( v83 )
          sub_10020150((int)&v113, (int)v77, (int)&v97, (int)CompressBlocksBC7);
        else
          CompressBlocksBC7(&v113, v77, &v97);
        v45 = GetCompressedTextureDataSize(v39, (int)v81, *(_DWORD *)(a2 + 16));
        v46 = v76;
        *v76 = v45;
        v46[1] = 0;
        if ( v41 )
          operator delete[](v41);
        break;
      case 21:
      case 30:
      case 31:
      case 32:
      case 33:
      case 34:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 54:
      case 55:
      case 56:
      case 57:
      case 58:
      case 59:
      case 60:
      case 61:
        v47 = LoadLibraryW(L"TexToolWrap.dll");
        v48 = v47;
        hLibModule = v47;
        if ( v47 )
        {
          v49 = GetProcAddress(v47, "Compress");
          if ( v49 )
          {
            v50 = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, void *, int, void *, int, int))v49)(
                    *(_DWORD *)(a2 + 16),
                    *(_DWORD *)(a2 + 8),
                    *(_DWORD *)(a2 + 4),
                    *(_DWORD *)(a2 + 20),
                    v78,
                    4 * *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4),
                    v77,
                    *a4,
                    a5);
            v51 = hLibModule;
            *a4 = v50;
            a4[1] = 0;
            FreeLibrary(v51);
          }
          else
          {
            *a4 = 0;
            a4[1] = 0;
            FreeLibrary(v48);
          }
        }
        break;
      default:
        return;
    }
  }
}
// 1004F7B8: using guessed type int __cdecl unknown_libname_4(_DWORD);
// 10099190: using guessed type void __cdecl operator delete[](void *);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE640: using guessed type int __thiscall GetProfile_alpha_slow(_DWORD);
// 100AE644: using guessed type int __cdecl GetProfile_alpha_basic(_DWORD);
// 100AE648: using guessed type int __thiscall GetProfile_alpha_fast(_DWORD);
// 100AE64C: using guessed type int __cdecl GetProfile_alpha_veryfast(_DWORD);
// 100AE650: using guessed type int __thiscall GetProfile_alpha_ultrafast(_DWORD);
// 100AE654: using guessed type int __cdecl CompressBlocksBC6H(_DWORD, _DWORD, _DWORD);
// 100AE658: using guessed type int __thiscall GetProfile_bc6h_veryslow(_DWORD);
// 100AE65C: using guessed type int __cdecl GetProfile_bc6h_slow(_DWORD);
// 100AE660: using guessed type int __thiscall GetProfile_bc6h_basic(_DWORD);
// 100AE664: using guessed type int __thiscall GetProfile_bc6h_veryfast(_DWORD);
// 100AE668: using guessed type int __cdecl CompressBlocksBC7(_DWORD, _DWORD, _DWORD);
// 100AE66C: using guessed type int __thiscall GetProfile_bc6h_fast(_DWORD);
// 100AE674: using guessed type void __cdecl compress_image(struct Image *, _DWORD, void (__cdecl *)(struct BlockUserData_t *), struct Texture *, _DWORD, float, float);
// 100AE678: using guessed type int __cdecl get_number_of_texture_formats();
// 100AE67C: using guessed type void __cdecl destroy_texture(struct Texture *);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10020D50) --------------------------------------------------------
bool __cdecl MakeTextureData(struct TextureFile *a1, void *a2, bool a3, int a4)
{
  int v4; // esi@1
  unsigned int v5; // edx@2
  unsigned int v6; // edi@2
  int v7; // ecx@3
  unsigned int v8; // eax@4
  bool result; // al@5
  unsigned int v10; // edx@6
  unsigned int v11; // edi@6
  int v12; // ecx@7
  int v13; // eax@8
  unsigned int v14; // edx@11
  unsigned int v15; // edi@11
  _BYTE *v16; // ecx@12
  unsigned int v17; // eax@13
  unsigned int v18; // ecx@15
  unsigned int v19; // edi@15
  int v20; // eax@16
  unsigned int v21; // ecx@18
  unsigned int v22; // edi@18
  unsigned int v23; // eax@19
  unsigned int v24; // edx@21
  unsigned int v25; // ecx@21
  unsigned int v26; // ecx@24
  unsigned int v27; // eax@24
  char *v28; // edi@25
  unsigned int v29; // ebx@28
  unsigned int v30; // edi@28
  int v31; // ebx@31
  char *v32; // edi@32
  int v33; // ebx@35
  int v34; // edi@36
  char *v35; // esi@36
  int v36; // ebx@39
  char *v37; // edx@39
  unsigned int v38; // edi@39
  char *v39; // ecx@40
  unsigned int v40; // edx@40
  int v41; // eax@40
  int v42; // edi@41
  int v43; // eax@44
  int v44; // ebx@44
  unsigned int v45; // ebx@47
  _BYTE *v46; // eax@47
  unsigned int v47; // edx@47
  char *v48; // eax@48
  unsigned int v49; // edi@48
  int v50; // ecx@48
  int v51; // ebx@54
  float v52; // edx@54
  char *v53; // eax@55
  unsigned int v54; // edx@55
  int v55; // ecx@55
  int v56; // ecx@59
  char *v57; // eax@59
  int v58; // ebx@59
  int v59; // eax@62
  int v60; // [sp+14h] [bp-10h]@29
  float v61; // [sp+18h] [bp-Ch]@29
  unsigned int v62; // [sp+1Ch] [bp-8h]@40
  int v63; // [sp+20h] [bp-4h]@62

  v4 = *((_DWORD *)a1 + 16);
  switch ( *((_DWORD *)a1 + 4) )
  {
    case 5:
      v5 = *((_DWORD *)a1 + 1) * *((_DWORD *)a1 + 2);
      v6 = 0;
      if ( !v5 )
        goto LABEL_46;
      v7 = v4 + 2;
      do
      {
        v8 = *((_DWORD *)a2 + v6);
        *(_BYTE *)(v7 - 2) = *((_DWORD *)a2 + v6) >> 24;
        *(_BYTE *)(v7 - 1) = v8;
        *(_BYTE *)v7 = BYTE1(v8);
        *(_BYTE *)(v7 + 1) = v8 >> 16;
        ++v6;
        v7 += 4;
      }
      while ( v6 < v5 );
      return 1;
    case 0xE:
    case 0x25:
      v10 = *((_DWORD *)a1 + 1) * *((_DWORD *)a1 + 2);
      v11 = 0;
      if ( !v10 )
        goto LABEL_46;
      v12 = v4 + 2;
      do
      {
        v13 = *((_DWORD *)a2 + v11);
        *(_BYTE *)(v12 - 2) = *((_DWORD *)a2 + v11) >> 16;
        *(_BYTE *)v12 = v13;
        *(_BYTE *)(v12 - 1) = BYTE1(v13);
        *(_BYTE *)(v12 + 1) = BYTE3(v13);
        ++v11;
        v12 += 4;
      }
      while ( v11 < v10 );
      return 1;
    case 4:
      memcpy((void *)v4, a2, 4 * *((_DWORD *)a1 + 1) * *((_DWORD *)a1 + 2));
      return 1;
    case 3:
      v14 = *((_DWORD *)a1 + 1) * *((_DWORD *)a1 + 2);
      v15 = 0;
      if ( !v14 )
        goto LABEL_46;
      v16 = (_BYTE *)(v4 + 2);
      do
      {
        v17 = *((_DWORD *)a2 + v15);
        *(v16 - 2) = v17;
        *(v16 - 1) = BYTE1(v17);
        *v16 = v17 >> 16;
        ++v15;
        v16 += 3;
      }
      while ( v15 < v14 );
      return 1;
    case 2:
      v18 = *((_DWORD *)a1 + 1) * *((_DWORD *)a1 + 2);
      v19 = 0;
      if ( !v18 )
        goto LABEL_46;
      do
      {
        v20 = *((_DWORD *)a2 + v19);
        *(_BYTE *)(v4 + 2 * v19) = ((unsigned __int8)(*((_DWORD *)a2 + v19) >> 16) >> 4) | (*((_WORD *)a2 + 2 * v19) >> 8) & 0xF0;
        *(_BYTE *)(v4 + 2 * v19++ + 1) = ((unsigned __int8)v20 >> 4) | BYTE3(v20) & 0xF0;
      }
      while ( v19 < v18 );
      return 1;
    case 0xD:
      v21 = *((_DWORD *)a1 + 1) * *((_DWORD *)a1 + 2);
      v22 = 0;
      if ( !v21 )
        goto LABEL_46;
      do
      {
        v23 = *((_DWORD *)a2 + v22);
        *(_BYTE *)(v4 + 2 * v22 + 1) = *((_DWORD *)a2 + v22) & 0xF0 | ((unsigned __int8)(*((_WORD *)a2 + 2 * v22) >> 8) >> 4);
        *(_BYTE *)(v4 + 2 * v22++) = (BYTE3(v23) >> 4) | (v23 >> 16) & 0xF0;
      }
      while ( v22 < v21 );
      return 1;
    case 7:
      v24 = *((_DWORD *)a1 + 1) * *((_DWORD *)a1 + 2);
      v25 = 0;
      if ( !v24 )
        goto LABEL_46;
      do
      {
        *(_WORD *)(v4 + 2 * v25) = ((unsigned __int8)(*((_DWORD *)a2 + v25) >> 16) >> 3) | 32
                                                                                         * (((unsigned __int8)*((_DWORD *)a2 + v25) >> 3 << 6) | ((unsigned __int8)(*((_WORD *)a2 + 2 * v25) >> 8) >> 2));
        ++v25;
      }
      while ( v25 < v24 );
      return 1;
    case 1:
      v26 = *((_DWORD *)a1 + 1) * *((_DWORD *)a1 + 2);
      v27 = 0;
      if ( !v26 )
        goto LABEL_46;
      v28 = (char *)a2 + 3;
      do
      {
        *(_BYTE *)(v27++ + v4) = *v28;
        v28 += 4;
      }
      while ( v27 < v26 );
      return 1;
    case 9:
    case 0xF:
      v29 = *((_DWORD *)a1 + 1) * *((_DWORD *)a1 + 2);
      v30 = 0;
      if ( !v29 )
        goto LABEL_46;
      do
      {
        LODWORD(v61) = *((_BYTE *)a2 + 4 * v30);
        v61 = (double)SLODWORD(v61) * 0.00390625;
        sub_1001B270((int)&v60, v61);
        *(_WORD *)(v4 + 2 * v30++) = v60;
      }
      while ( v30 < v29 );
      return 1;
    case 0x10:
      v31 = *((_DWORD *)a1 + 1) * *((_DWORD *)a1 + 2);
      if ( !v31 )
        goto LABEL_46;
      v32 = (char *)a2 - v4;
      do
      {
        LODWORD(v61) = (unsigned __int8)v32[v4];
        v61 = (double)SLODWORD(v61) * 0.00390625;
        sub_1001B270((int)&v60, v61);
        *(_WORD *)v4 = v60;
        LODWORD(v61) = (unsigned __int8)v32[v4 + 1];
        v61 = (double)SLODWORD(v61) * 0.00390625;
        sub_1001B270((int)&v60, v61);
        *(_WORD *)(v4 + 2) = v60;
        v4 += 4;
        --v31;
      }
      while ( v31 );
      return 1;
    case 0x11:
      v33 = *((_DWORD *)a1 + 1) * *((_DWORD *)a1 + 2);
      if ( !v33 )
        goto LABEL_46;
      v34 = v4 + 4;
      v35 = (char *)a2 + 2;
      do
      {
        LODWORD(v61) = (unsigned __int8)*(v35 - 2);
        v61 = (double)SLODWORD(v61) * 0.00390625;
        sub_1001B270((int)&v60, v61);
        *(_WORD *)(v34 - 4) = v60;
        LODWORD(v61) = (unsigned __int8)*(v35 - 1);
        v61 = (double)SLODWORD(v61) * 0.00390625;
        sub_1001B270((int)&v60, v61);
        *(_WORD *)(v34 - 2) = v60;
        LODWORD(v61) = (unsigned __int8)*v35;
        v61 = (double)SLODWORD(v61) * 0.00390625;
        sub_1001B270((int)&v60, v61);
        *(_WORD *)v34 = v60;
        LODWORD(v61) = (unsigned __int8)v35[1];
        v61 = (double)SLODWORD(v61) * 0.00390625;
        sub_1001B270((int)&v60, v61);
        *(_WORD *)(v34 + 2) = v60;
        v35 += 4;
        v34 += 8;
        --v33;
      }
      while ( v33 );
      return 1;
    case 0x12:
      v36 = *((_DWORD *)a1 + 1) * *((_DWORD *)a1 + 2);
      v37 = (char *)a2;
      v38 = 0;
      if ( v36 >= 4 )
      {
        v39 = (char *)a2 + 12;
        v60 = (int)a2 - v4;
        v40 = ((unsigned int)(v36 - 4) >> 2) + 1;
        v41 = v4 + 4;
        v62 = 4 * v40;
        do
        {
          LODWORD(v61) = (unsigned __int8)*(v39 - 12);
          v42 = v60;
          v41 += 16;
          v39 += 16;
          --v40;
          *(float *)(v41 - 20) = (double)SLODWORD(v61) * 0.00390625;
          LODWORD(v61) = *(_BYTE *)(v42 + v41 - 16);
          *(float *)(v41 - 16) = (double)SLODWORD(v61) * 0.00390625;
          LODWORD(v61) = (unsigned __int8)*(v39 - 20);
          *(float *)(v41 - 12) = (double)SLODWORD(v61) * 0.00390625;
          LODWORD(v61) = (unsigned __int8)*(v39 - 16);
          *(float *)(v41 - 8) = (double)SLODWORD(v61) * 0.00390625;
        }
        while ( v40 );
        v38 = v62;
        v37 = (char *)a2;
      }
      if ( v38 < v36 )
      {
        v43 = v4 + 4 * v38;
        v44 = v36 - v38;
        do
        {
          v62 = (unsigned __int8)*(&v37[v43] - v4);
          v43 += 4;
          --v44;
          *(float *)(v43 - 4) = (double)(signed int)v62 * 0.00390625;
        }
        while ( v44 );
      }
      goto LABEL_46;
    case 0x13:
      v45 = *((_DWORD *)a1 + 1) * *((_DWORD *)a1 + 2);
      v46 = a2;
      v47 = 0;
      v61 = *(float *)&v45;
      if ( (signed int)v45 >= 4 )
      {
        v48 = (char *)a2 + 4;
        v49 = ((v45 - 4) >> 2) + 1;
        v50 = v4 + 8;
        v47 = 4 * v49;
        do
        {
          v62 = (unsigned __int8)*(v48 - 4);
          v48 += 16;
          v50 += 32;
          --v49;
          *(float *)(v50 - 40) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v48 - 19);
          *(float *)(v50 - 36) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v48 - 16);
          *(float *)(v50 - 32) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v48 - 15);
          *(float *)(v50 - 28) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v48 - 12);
          *(float *)(v50 - 24) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v48 - 11);
          *(float *)(v50 - 20) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v48 - 8);
          *(float *)(v50 - 16) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v48 - 7);
          *(float *)(v50 - 12) = (double)(signed int)v62 * 0.00390625;
        }
        while ( v49 );
        *(float *)&v45 = v61;
        v46 = a2;
      }
      if ( v47 >= v45 )
        goto LABEL_46;
      do
      {
        v62 = v46[4 * v47++];
        *(float *)(v4 + 8 * v47 - 8) = (double)(signed int)v62 * 0.00390625;
        v62 = v46[4 * v47 - 3];
        *(float *)(v4 + 8 * v47 - 4) = (double)(signed int)v62 * 0.00390625;
      }
      while ( v47 < v45 );
      return 1;
    case 0x14:
      v51 = *((_DWORD *)a1 + 1) * *((_DWORD *)a1 + 2);
      v52 = 0.0;
      if ( v51 >= 4 )
      {
        v53 = (char *)a2 + 2;
        v54 = ((unsigned int)(v51 - 4) >> 2) + 1;
        v55 = v4 + 8;
        LODWORD(v61) = 4 * v54;
        do
        {
          v62 = (unsigned __int8)*(v53 - 2);
          v53 += 16;
          *(float *)(v55 - 8) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v53 - 17);
          *(float *)(v55 - 4) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v53 - 16);
          *(float *)v55 = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v53 - 15);
          *(float *)(v55 + 4) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v53 - 14);
          *(float *)(v55 + 8) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v53 - 13);
          *(float *)(v55 + 12) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v53 - 12);
          *(float *)(v55 + 16) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v53 - 11);
          *(float *)(v55 + 20) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v53 - 10);
          *(float *)(v55 + 24) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v53 - 9);
          *(float *)(v55 + 28) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v53 - 8);
          *(float *)(v55 + 32) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v53 - 7);
          *(float *)(v55 + 36) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v53 - 6);
          *(float *)(v55 + 40) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v53 - 5);
          *(float *)(v55 + 44) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v53 - 4);
          *(float *)(v55 + 48) = (double)(signed int)v62 * 0.00390625;
          v62 = (unsigned __int8)*(v53 - 3);
          *(float *)(v55 + 52) = (double)(signed int)v62 * 0.00390625;
          v55 += 64;
          --v54;
        }
        while ( v54 );
        v52 = v61;
      }
      if ( LODWORD(v52) >= v51 )
        goto LABEL_46;
      v56 = v4 + 16 * LODWORD(v52) + 8;
      v57 = (char *)a2 + 4 * LODWORD(v52) + 2;
      v58 = v51 - LODWORD(v52);
      do
      {
        v62 = (unsigned __int8)*(v57 - 2);
        v57 += 4;
        v56 += 16;
        --v58;
        *(float *)(v56 - 24) = (double)(signed int)v62 * 0.00390625;
        v62 = (unsigned __int8)*(v57 - 5);
        *(float *)(v56 - 20) = (double)(signed int)v62 * 0.00390625;
        v62 = (unsigned __int8)*(v57 - 4);
        *(float *)(v56 - 16) = (double)(signed int)v62 * 0.00390625;
        v62 = (unsigned __int8)*(v57 - 3);
        *(float *)(v56 - 12) = (double)(signed int)v62 * 0.00390625;
      }
      while ( v58 );
      result = 1;
      break;
    case 0xA:
    case 0xC:
    case 0x15:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x29:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x2F:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3B:
    case 0x3C:
    case 0x3D:
      v62 = *((_DWORD *)a1 + 15);
      v63 = 0;
      sub_10020290((int)a2, (int)a1, (void *)v4, (int *)&v62, a4);
      v59 = v62;
      *((_DWORD *)a1 + 3) = v62;
      *((_DWORD *)a1 + 15) = v59;
      if ( v63 | v59 || !(*((_DWORD *)a1 + 1) * *((_DWORD *)a1 + 2)) )
      {
LABEL_46:
        result = 1;
      }
      else
      {
        printf("Failed converting texture format RGBA32 to %i!", *((_DWORD *)a1 + 4));
        result = 0;
      }
      break;
    default:
      printf("Unsupported texture format %i!", *((_DWORD *)a1 + 4));
      result = 0;
      break;
  }
  return result;
}

//----- (100215E0) --------------------------------------------------------
char __cdecl GetTextureData(struct TextureFile *a1, void *a2)
{
  char result; // al@3

  switch ( *((_DWORD *)a1 + 4) )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 9:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x25:
      sub_1001F4D0(a2, (int)a1);
      goto LABEL_3;
    case 0xA:
    case 0xC:
    case 0x15:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x29:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x2F:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3B:
    case 0x3C:
    case 0x3D:
      if ( sub_1001FC80((int)a1, a2) )
      {
LABEL_3:
        result = 1;
      }
      else
      {
        printf("Failed decompressing from texture format %i!", *((_DWORD *)a1 + 4));
        result = 0;
      }
      break;
    default:
      printf("Unsupported texture format %i!", *((_DWORD *)a1 + 4));
      result = 0;
      break;
  }
  return result;
}

//----- (100216A0) --------------------------------------------------------
int __thiscall sub_100216A0(int this)
{
  return *(_BYTE *)(this + 3) | ((*(_BYTE *)(this + 2) | ((*(_BYTE *)(this + 1) | (*(_BYTE *)this << 8)) << 8)) << 8);
}

//----- (100216E0) --------------------------------------------------------
char __usercall sub_100216E0@<al>(unsigned int a1@<ecx>, int a2@<edi>, unsigned int a3@<esi>)
{
  unsigned int v3; // eax@1
  char result; // al@4
  unsigned int v5; // [sp+0h] [bp-4h]@1

  v5 = a1;
  v3 = *(_DWORD *)(a2 + 4);
  if ( a3 != v3 )
  {
    if ( a3 >= v3 )
    {
      if ( a3 > *(_DWORD *)(a2 + 8) )
      {
        LOBYTE(v5) = a3 == v3 + 1;
        result = sub_1001C660(a3, a2, v5, 1u);
        if ( !result )
        {
          *(_BYTE *)(a2 + 12) = 1;
          return result;
        }
      }
      memset((void *)(*(_DWORD *)(a2 + 4) + *(_DWORD *)a2), 0, a3 - *(_DWORD *)(a2 + 4));
    }
    *(_DWORD *)(a2 + 4) = a3;
  }
  return 1;
}

//----- (10021740) --------------------------------------------------------
char __usercall sub_10021740@<al>(unsigned int a1@<ecx>, int a2@<edi>, unsigned int a3@<esi>)
{
  unsigned int v3; // eax@1
  char result; // al@4
  unsigned int v5; // [sp+0h] [bp-4h]@1

  v5 = a1;
  v3 = *(_DWORD *)(a2 + 4);
  if ( a3 != v3 )
  {
    if ( a3 >= v3 )
    {
      if ( a3 > *(_DWORD *)(a2 + 8) )
      {
        LOBYTE(v5) = a3 == v3 + 1;
        result = sub_1001C660(a3, a2, v5, 4u);
        if ( !result )
        {
          *(_BYTE *)(a2 + 12) = 1;
          return result;
        }
      }
      memset((void *)(*(_DWORD *)a2 + 4 * *(_DWORD *)(a2 + 4)), 0, 4 * (a3 - *(_DWORD *)(a2 + 4)));
    }
    *(_DWORD *)(a2 + 4) = a3;
  }
  return 1;
}

//----- (100217A0) --------------------------------------------------------
char __usercall sub_100217A0@<al>(unsigned int a1@<ecx>, int a2@<edi>, unsigned int a3@<esi>)
{
  unsigned int v3; // eax@1
  char result; // al@4
  unsigned int v5; // [sp+0h] [bp-4h]@1

  v5 = a1;
  v3 = *(_DWORD *)(a2 + 4);
  if ( a3 != v3 )
  {
    if ( a3 >= v3 )
    {
      if ( a3 > *(_DWORD *)(a2 + 8) )
      {
        LOBYTE(v5) = a3 == v3 + 1;
        result = sub_1001C660(a3, a2, v5, 2u);
        if ( !result )
        {
          *(_BYTE *)(a2 + 12) = 1;
          return result;
        }
      }
      memset((void *)(*(_DWORD *)a2 + 2 * *(_DWORD *)(a2 + 4)), 0, 2 * (a3 - *(_DWORD *)(a2 + 4)));
    }
    *(_DWORD *)(a2 + 4) = a3;
  }
  return 1;
}

//----- (10021800) --------------------------------------------------------
__int16 __cdecl sub_10021800(float a1)
{
  char v1; // cl@1
  __int16 v2; // si@1

  v1 = byte_100A4B60[LODWORD(a1) >> 23];
  v2 = word_100A4760[LODWORD(a1) >> 23] + ((LODWORD(a1) & 0x7FFFFFu) >> v1);
  return v2
       + (((v2 & 0x7C00) != 31744) & (((unsigned __int8)(LODWORD(a1) >> 23) == 102) | (unsigned __int16)((LODWORD(a1) & 0x7FFFFFu) >> (v1 - 1))));
}
// 100A4760: using guessed type __int16 word_100A4760[];

//----- (10021860) --------------------------------------------------------
int __usercall sub_10021860@<eax>(unsigned int a1@<eax>, _WORD *a2@<edx>, _WORD *a3@<ecx>, unsigned int a4@<edi>)
{
  char *v4; // ebx@1
  int result; // eax@10

  v4 = (char *)a3;
  if ( (unsigned int)a3 >= a4 - 3 )
  {
LABEL_4:
    if ( (unsigned int)a3 < a4 - 1 && *a2 == *a3 )
    {
      ++a3;
      ++a2;
    }
    if ( (unsigned int)a3 < a4 && *(_BYTE *)a2 == *(_BYTE *)a3 )
      a3 = (_WORD *)((char *)a3 + 1);
    result = (char *)a3 - v4;
  }
  else
  {
    while ( *(_DWORD *)a2 == *(_DWORD *)a3 )
    {
      a3 += 2;
      a2 += 2;
      if ( (unsigned int)a3 >= a4 - 3 )
        goto LABEL_4;
    }
    _BitScanForward(&a1, *(_DWORD *)a2 ^ *(_DWORD *)a3);
    result = (int)a3 + (a1 >> 3) - (_DWORD)v4;
  }
  return result;
}

//----- (100218C0) --------------------------------------------------------
char *__usercall sub_100218C0@<eax>(char *result@<eax>, int a2@<edx>, int a3@<edi>, int a4@<esi>)
{
  unsigned int v4; // ecx@1
  unsigned int v5; // ecx@2
  int v6; // edx@5

  v4 = -1640531535 * *(_DWORD *)result;
  if ( a2 == 2 )
    v5 = v4 >> 19;
  else
    v5 = v4 >> 20;
  if ( !a2 )
    goto LABEL_9;
  v6 = a2 - 1;
  if ( !v6 )
  {
    result -= a3;
LABEL_9:
    *(_DWORD *)(a4 + 4 * v5) = result;
    return result;
  }
  if ( v6 == 1 )
  {
    result -= a3;
    *(_WORD *)(a4 + 2 * v5) = (_WORD)result;
  }
  return result;
}

//----- (100218F0) --------------------------------------------------------
char *__usercall sub_100218F0@<eax>(signed int a1@<eax>, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebx@1
  _BYTE *v6; // esi@1
  signed int v7; // edi@1
  int v8; // ecx@2
  unsigned int v9; // edx@3
  char *result; // eax@7
  signed int v11; // edi@10
  unsigned int v12; // ecx@10
  char *v13; // eax@10
  unsigned int v14; // edx@10
  int v15; // ecx@13
  _DWORD *v16; // edi@13
  int v17; // eax@18
  _BYTE *v18; // edx@18
  _BYTE *v19; // esi@18
  unsigned int v20; // ecx@19
  unsigned int v21; // ST20_4@20
  unsigned int v22; // eax@23
  int v23; // ecx@23
  _BYTE *v24; // edx@25
  _WORD *v25; // esi@25
  _WORD *v26; // eax@26
  unsigned int v27; // ecx@26
  _WORD *v28; // edi@26
  unsigned int v29; // ecx@36
  unsigned int v30; // ecx@38
  unsigned int v31; // edx@39
  unsigned int v32; // eax@47
  size_t v33; // ebx@50
  unsigned int v34; // ecx@51
  unsigned int v35; // edi@52
  void *v36; // esi@56
  int v37; // ebx@57
  unsigned int v38; // edi@60
  signed int v39; // ecx@61
  unsigned int v40; // ebx@61
  char *v41; // edx@61
  unsigned int i; // eax@61
  int v43; // ecx@64
  _DWORD *v44; // ebx@64
  int v45; // eax@70
  _BYTE *v46; // ecx@70
  _BYTE *v47; // esi@70
  unsigned int v48; // edx@71
  unsigned int v49; // ST20_4@72
  unsigned int v50; // eax@75
  int v51; // ecx@75
  unsigned int v52; // ecx@77
  _WORD *v53; // esi@77
  _WORD *v54; // eax@78
  _WORD *v55; // ebx@78
  unsigned int v56; // ebx@87
  unsigned int v57; // ebx@89
  unsigned int v58; // edx@90
  size_t v59; // ebx@102
  unsigned int v60; // ecx@103
  unsigned int v61; // edi@104
  void *v62; // esi@108
  unsigned int v63; // ebx@112
  signed int v64; // edx@113
  unsigned int v65; // ecx@113
  char *v66; // eax@113
  signed int v67; // edi@113
  unsigned int v68; // edx@115
  int v69; // edi@115
  int v70; // ecx@116
  _DWORD *v71; // edi@116
  unsigned int v72; // ecx@121
  _BYTE *v73; // esi@121
  unsigned int v74; // edx@123
  unsigned int v75; // ST18_4@124
  unsigned int v76; // ecx@127
  int v77; // eax@127
  _WORD *v78; // esi@129
  _WORD *v79; // eax@130
  unsigned int v80; // ecx@130
  _WORD *v81; // edi@130
  unsigned int v82; // ecx@139
  unsigned int v83; // ecx@142
  unsigned int v84; // edx@143
  unsigned int v85; // eax@151
  unsigned int v86; // edi@156
  size_t v87; // ebx@156
  unsigned int v88; // ecx@158
  unsigned int v89; // edi@159
  void *v90; // esi@164
  _BYTE *v91; // ebx@165
  unsigned int v92; // esi@167
  signed int v93; // edx@168
  unsigned int v94; // edi@168
  char *v95; // ecx@168
  unsigned int v96; // eax@168
  int v97; // edx@171
  unsigned int v98; // edi@171
  unsigned int v99; // ecx@177
  _BYTE *v100; // ebx@177
  unsigned int v101; // eax@179
  unsigned int v102; // ecx@183
  int v103; // eax@183
  _WORD *v104; // ebx@185
  unsigned int v105; // ecx@186
  unsigned int v106; // ecx@188
  unsigned int v107; // edx@189
  unsigned int v108; // ecx@199
  unsigned int v109; // esi@202
  char v110; // al@202
  void *v111; // ebx@207
  unsigned int v112; // [sp+Ch] [bp-1Ch]@116
  signed int v113; // [sp+Ch] [bp-1Ch]@170
  int v114; // [sp+10h] [bp-18h]@115
  size_t v115; // [sp+14h] [bp-14h]@110
  size_t v116; // [sp+14h] [bp-14h]@165
  int v117; // [sp+14h] [bp-14h]@199
  signed int v118; // [sp+18h] [bp-10h]@12
  int v119; // [sp+18h] [bp-10h]@19
  int v120; // [sp+18h] [bp-10h]@26
  int v121; // [sp+18h] [bp-10h]@71
  int v122; // [sp+18h] [bp-10h]@78
  int v123; // [sp+18h] [bp-10h]@123
  int v124; // [sp+18h] [bp-10h]@130
  int v125; // [sp+18h] [bp-10h]@165
  _BYTE *v126; // [sp+1Ch] [bp-Ch]@18
  unsigned int v127; // [sp+1Ch] [bp-Ch]@64
  _BYTE *v128; // [sp+1Ch] [bp-Ch]@70
  _BYTE *v129; // [sp+1Ch] [bp-Ch]@121
  unsigned int v130; // [sp+1Ch] [bp-Ch]@171
  _BYTE *v131; // [sp+1Ch] [bp-Ch]@177
  _BYTE *v132; // [sp+20h] [bp-8h]@5
  _BYTE *v133; // [sp+20h] [bp-8h]@110
  _BYTE *v134; // [sp+20h] [bp-8h]@165
  unsigned int v135; // [sp+24h] [bp-4h]@13
  int v136; // [sp+24h] [bp-4h]@110
  unsigned int v137; // [sp+24h] [bp-4h]@179
  int v138; // [sp+3Ch] [bp+14h]@6
  int v139; // [sp+3Ch] [bp+14h]@51
  int v140; // [sp+3Ch] [bp+14h]@57
  int v141; // [sp+3Ch] [bp+14h]@103
  int v142; // [sp+3Ch] [bp+14h]@158
  unsigned int v143; // [sp+3Ch] [bp+14h]@201

  v5 = a3;
  v6 = (_BYTE *)a4;
  v7 = a1;
  memset(a2, 0, 0x4020u);
  if ( (unsigned int)v7 <= 0x7E000000 )
  {
    v9 = (signed int)(v7 + ((unsigned __int64)(-2139062143i64 * v7) >> 32)) >> 7;
    v8 = v9 + (v9 >> 31) + v7 + 16;
  }
  else
  {
    v8 = 0;
  }
  if ( a5 < v8 )
  {
    if ( v7 >= 65547 )
    {
      v91 = (_BYTE *)a4;
      v134 = (_BYTE *)a3;
      v125 = v7 + a3;
      v116 = a4 + a5;
      if ( (unsigned int)v7 <= 0x7E000000 )
      {
        if ( v7 >= 13 )
        {
          sub_100218C0((char *)a3, 0, a3, (int)a2);
          v92 = a3;
LABEL_168:
          v93 = 1;
          v94 = (unsigned int)(-1640531535 * *(_DWORD *)(v92 + 1)) >> 20;
          v95 = (char *)(v92 + 1);
          v96 = 64;
          while ( 1 )
          {
            v92 = (unsigned int)v95;
            v95 += v93;
            v113 = v96 >> 6;
            if ( (unsigned int)v95 > v125 - 12 )
              break;
            v97 = 4 * v94;
            v98 = *((_DWORD *)a2 + v94);
            v130 = (unsigned int)(-1640531535 * *(_DWORD *)v95) >> 20;
            *(_DWORD *)((char *)a2 + v97) = v92;
            if ( v98 + 0xFFFF >= v92 && *(_DWORD *)v98 == *(_DWORD *)v92 )
            {
              for ( ; v92 > (unsigned int)v134; --v98 )
              {
                if ( v98 <= a3 )
                  break;
                if ( *(_BYTE *)(v92 - 1) != *(_BYTE *)(v98 - 1) )
                  break;
                --v92;
              }
              v99 = v92 - (_DWORD)v134;
              v131 = v91;
              v100 = v91 + 1;
              if ( (unsigned int)(&v100[(v92 - (unsigned int)v134) / 0xFF + 8] + v92 - (_DWORD)v134) <= v116 )
              {
                if ( v99 < 0xF )
                {
                  *v131 = 16 * v99;
                }
                else
                {
                  LOBYTE(v101) = v99 - 15;
                  v137 = v99 - 15;
                  *v131 = -16;
                  if ( (signed int)(v99 - 15) >= 255 )
                  {
                    memset(v100, 255, v137 / 0xFF);
                    v99 = v92 - (_DWORD)v134;
                    v100 += v137 / 0xFF;
                    v101 = v137 % 0xFF;
                  }
                  *v100++ = v101;
                }
                v102 = (unsigned int)&v100[v99];
                v103 = v134 - v100;
                do
                {
                  *(_DWORD *)v100 = *(_DWORD *)&v100[v103];
                  *((_DWORD *)v100 + 1) = *(_DWORD *)&v100[v103 + 4];
                  v100 += 8;
                }
                while ( (unsigned int)v100 < v102 );
                v104 = (_WORD *)v102;
                while ( 1 )
                {
                  *v104 = v92 - v98;
                  v91 = v104 + 1;
                  v105 = sub_10021860(v92 - v98, (_WORD *)(v98 + 4), (_WORD *)(v92 + 4), v125 - 5);
                  v92 += v105 + 4;
                  if ( (unsigned int)&v91[(v105 >> 8) + 6] > v116 )
                    break;
                  if ( v105 < 0xF )
                  {
                    *v131 += v105;
                  }
                  else
                  {
                    *v131 += 15;
                    v106 = v105 - 15;
                    if ( v106 >= 0x1FE )
                    {
                      v107 = v106 / 0x1FE;
                      do
                      {
                        *(_WORD *)v91 = -1;
                        v91 += 2;
                        v106 -= 510;
                        --v107;
                      }
                      while ( v107 );
                    }
                    if ( v106 >= 0xFF )
                    {
                      LOBYTE(v106) = v106 + 1;
                      *v91++ = -1;
                    }
                    *v91++ = v106;
                  }
                  v134 = (_BYTE *)v92;
                  if ( v92 > v125 - 12 )
                    goto LABEL_199;
                  *((_DWORD *)a2 + ((unsigned int)(-1640531535 * *(_DWORD *)(v92 - 2)) >> 20)) = v92 - 2;
                  v98 = *((_DWORD *)a2 + ((unsigned int)(-1640531535 * *(_DWORD *)v92) >> 20));
                  *((_DWORD *)a2 + ((unsigned int)(-1640531535 * *(_DWORD *)v92) >> 20)) = v92;
                  if ( v98 + 0xFFFF < v92 || *(_DWORD *)v98 != *(_DWORD *)v92 )
                    goto LABEL_168;
                  v131 = v91;
                  v104 = v91 + 1;
                  *v131 = 0;
                }
              }
              return 0;
            }
            ++v96;
            v93 = v113;
            v94 = v130;
          }
        }
LABEL_199:
        v108 = v125 - (_DWORD)v134;
        v117 = v125 - (_DWORD)v134;
        if ( (unsigned int)(&v91[(v125 - (signed int)v134 + 240) / 0xFFu - a4 + 1] + v125 - (_DWORD)v134) <= a5 )
        {
          if ( v108 < 0xF )
          {
            *v91 = 16 * v108;
          }
          else
          {
            *v91++ = -16;
            v143 = v108 - 15;
            if ( v108 - 15 < 0xFF )
            {
              *v91 = v143;
            }
            else
            {
              v109 = v143 / 0xFF;
              memset(v91, 255, v143 / 0xFF);
              v110 = v143;
              v91 += v143 / 0xFF;
              do
              {
                ++v110;
                --v109;
              }
              while ( v109 );
              *v91 = v110;
            }
          }
          v111 = v91 + 1;
          memcpy(v111, v134, v117);
          return (char *)v111 + v117 - a4;
        }
      }
    }
    else
    {
      v133 = (_BYTE *)a3;
      v136 = v7 + a3;
      v115 = a4 + a5;
      if ( (unsigned int)v7 <= 0x7E000000 )
      {
        if ( v7 < 13 )
        {
          v69 = v7 + a3;
        }
        else
        {
          v63 = a3;
          *((_WORD *)a2 + ((unsigned int)(-1640531535 * *(_DWORD *)a3) >> 19)) = 0;
LABEL_113:
          v64 = 1;
          v65 = (unsigned int)(-1640531535 * *(_DWORD *)(v63 + 1)) >> 19;
          v66 = (char *)(v63 + 1);
          v67 = 64;
          while ( 1 )
          {
            v63 = (unsigned int)v66;
            v66 += v64;
            v68 = v67;
            v114 = v67 + 1;
            v69 = v136;
            if ( (unsigned int)v66 > v136 - 12 )
              break;
            v70 = 2 * v65;
            v112 = (unsigned int)(-1640531535 * *(_DWORD *)v66) >> 19;
            v71 = (_DWORD *)(a3 + *(_WORD *)((char *)a2 + v70));
            *(_WORD *)((char *)a2 + v70) = v63 - a3;
            if ( *v71 == *(_DWORD *)v63 )
            {
              for ( ; v63 > (unsigned int)v133; v71 = (_DWORD *)((char *)v71 - 1) )
              {
                if ( (unsigned int)v71 <= a3 )
                  break;
                if ( *(_BYTE *)(v63 - 1) != *((_BYTE *)v71 - 1) )
                  break;
                --v63;
              }
              v72 = v63 - (_DWORD)v133;
              v129 = v6;
              v73 = v6 + 1;
              if ( (unsigned int)(&v73[(v63 - (unsigned int)v133) / 0xFF + 8] + v63 - (_DWORD)v133) <= v115 )
              {
                if ( v72 < 0xF )
                {
                  *v129 = 16 * v72;
                }
                else
                {
                  v74 = v72 - 15;
                  v123 = v72 - 15;
                  *v129 = -16;
                  if ( (signed int)(v72 - 15) >= 255 )
                  {
                    v75 = v74 / 0xFF;
                    memset(v73, 255, v74 / 0xFF);
                    v72 = v63 - (_DWORD)v133;
                    v73 += v75;
                    v74 = -255 * v75 + v123;
                  }
                  *v73++ = v74;
                }
                v76 = (unsigned int)&v73[v72];
                v77 = v133 - v73;
                do
                {
                  *(_DWORD *)v73 = *(_DWORD *)&v73[v77];
                  *((_DWORD *)v73 + 1) = *(_DWORD *)&v73[v77 + 4];
                  v73 += 8;
                }
                while ( (unsigned int)v73 < v76 );
                v78 = (_WORD *)v76;
                while ( 1 )
                {
                  *v78 = v63 - (_WORD)v71;
                  v79 = (_WORD *)(v63 + 4);
                  v80 = v136 - 8;
                  v6 = v78 + 1;
                  v81 = v71 + 1;
                  v124 = v63 + 4;
                  if ( v63 + 4 >= v136 - 8 )
                  {
LABEL_133:
                    if ( (unsigned int)v79 < v136 - 6 && *v81 == *v79 )
                    {
                      ++v79;
                      ++v81;
                    }
                    if ( (unsigned int)v79 < v136 - 5 && *(_BYTE *)v81 == *(_BYTE *)v79 )
                      v79 = (_WORD *)((char *)v79 + 1);
                    v82 = (unsigned int)v79 - v124;
                  }
                  else
                  {
                    while ( *(_DWORD *)v79 == *(_DWORD *)v81 )
                    {
                      v79 += 2;
                      v81 += 2;
                      if ( (unsigned int)v79 >= v80 )
                        goto LABEL_133;
                    }
                    _BitScanForward(&v80, *(_DWORD *)v79 ^ *(_DWORD *)v81);
                    v82 = (unsigned int)v79 + (v80 >> 3) - v124;
                  }
                  v63 += v82 + 4;
                  if ( (unsigned int)&v6[(v82 >> 8) + 6] > v115 )
                    break;
                  if ( v82 < 0xF )
                  {
                    *v129 += v82;
                  }
                  else
                  {
                    *v129 += 15;
                    v83 = v82 - 15;
                    if ( v83 >= 0x1FE )
                    {
                      v84 = v83 / 0x1FE;
                      do
                      {
                        *(_WORD *)v6 = -1;
                        v6 += 2;
                        v83 -= 510;
                        --v84;
                      }
                      while ( v84 );
                    }
                    if ( v83 >= 0xFF )
                    {
                      LOBYTE(v83) = v83 + 1;
                      *v6++ = -1;
                    }
                    *v6++ = v83;
                  }
                  v133 = (_BYTE *)v63;
                  if ( v63 > v136 - 12 )
                  {
                    v69 = v136;
                    goto LABEL_156;
                  }
                  *((_WORD *)a2 + ((unsigned int)(-1640531535 * *(_DWORD *)(v63 - 2)) >> 19)) = v63 - 2 - a3;
                  v85 = (unsigned int)(-1640531535 * *(_DWORD *)v63) >> 19;
                  v71 = (_DWORD *)(a3 + *((_WORD *)a2 + v85));
                  *((_WORD *)a2 + v85) = v63 - a3;
                  if ( (unsigned int)v71 + 0xFFFF < v63 || *v71 != *(_DWORD *)v63 )
                    goto LABEL_113;
                  v129 = v6;
                  v78 = v6 + 1;
                  *v129 = 0;
                }
              }
              return 0;
            }
            v67 = v114;
            v64 = v68 >> 6;
            v65 = v112;
          }
        }
LABEL_156:
        v86 = v69 - (_DWORD)v133;
        v87 = v86;
        if ( (unsigned int)(&v6[(v86 + 240) / 0xFF - a4 + 1] + v86) <= a5 )
        {
          if ( v86 < 0xF )
          {
            *v6 = 16 * v86;
          }
          else
          {
            v88 = v86 - 15;
            *v6++ = -16;
            v142 = v86 - 15;
            if ( v86 - 15 >= 0xFF )
            {
              v89 = v88 / 0xFF;
              memset(v6, 255, v88 / 0xFF);
              v6 += v89;
              do
              {
                v142 -= 255;
                --v89;
              }
              while ( v89 );
              LOBYTE(v88) = v142;
            }
            *v6 = v88;
          }
          v90 = v6 + 1;
          memcpy(v90, v133, v87);
          return (char *)v90 + v87 - a4;
        }
      }
    }
    return 0;
  }
  v132 = (_BYTE *)a3;
  if ( v7 < 65547 )
  {
    v138 = a3 + v7;
    if ( (unsigned int)v7 <= 0x7E000000 )
    {
      if ( v7 >= 13 )
      {
        *((_WORD *)a2 + ((unsigned int)(-1640531535 * *(_DWORD *)a3) >> 19)) = 0;
LABEL_10:
        v11 = 1;
        v12 = (unsigned int)(-1640531535 * *(_DWORD *)(v5 + 1)) >> 19;
        v13 = (char *)(v5 + 1);
        v14 = 64;
        while ( 1 )
        {
          v5 = (unsigned int)v13;
          v13 += v11;
          v118 = v14 >> 6;
          if ( (unsigned int)v13 > v138 - 12 )
            break;
          v15 = 2 * v12;
          v135 = (unsigned int)(-1640531535 * *(_DWORD *)v13) >> 19;
          v16 = (_DWORD *)(a3 + *(_WORD *)((char *)a2 + v15));
          *(_WORD *)((char *)a2 + v15) = v5 - a3;
          if ( *v16 == *(_DWORD *)v5 )
          {
            for ( ; v5 > (unsigned int)v132; v16 = (_DWORD *)((char *)v16 - 1) )
            {
              if ( (unsigned int)v16 <= a3 )
                break;
              if ( *(_BYTE *)(v5 - 1) != *((_BYTE *)v16 - 1) )
                break;
              --v5;
            }
            v17 = v5 - (_DWORD)v132;
            v18 = v6;
            v19 = v6 + 1;
            v126 = v18;
            if ( v5 - (unsigned int)v132 < 0xF )
            {
              *v18 = 16 * v17;
            }
            else
            {
              v20 = v17 - 15;
              v119 = v17 - 15;
              *v18 = -16;
              if ( v17 - 15 >= 255 )
              {
                v21 = v20 / 0xFF;
                memset(v19, 255, v20 / 0xFF);
                v19 += v21;
                v20 = -255 * v21 + v119;
                v17 = v5 - (_DWORD)v132;
              }
              *v19++ = v20;
            }
            v22 = (unsigned int)&v19[v17];
            v23 = v132 - v19;
            do
            {
              *(_DWORD *)v19 = *(_DWORD *)&v19[v23];
              *((_DWORD *)v19 + 1) = *(_DWORD *)&v19[v23 + 4];
              v19 += 8;
            }
            while ( (unsigned int)v19 < v22 );
            v24 = v126;
            v25 = (_WORD *)v22;
            while ( 1 )
            {
              *v25 = v5 - (_WORD)v16;
              v26 = (_WORD *)(v5 + 4);
              v27 = v138 - 8;
              v6 = v25 + 1;
              v28 = v16 + 1;
              v120 = v5 + 4;
              if ( v5 + 4 >= v138 - 8 )
              {
LABEL_30:
                if ( (unsigned int)v26 < v138 - 6 && *v28 == *v26 )
                {
                  ++v26;
                  ++v28;
                }
                if ( (unsigned int)v26 < v138 - 5 && *(_BYTE *)v28 == *(_BYTE *)v26 )
                  v26 = (_WORD *)((char *)v26 + 1);
                v29 = (unsigned int)v26 - v120;
              }
              else
              {
                while ( *(_DWORD *)v28 == *(_DWORD *)v26 )
                {
                  v26 += 2;
                  v28 += 2;
                  if ( (unsigned int)v26 >= v27 )
                  {
                    v24 = v126;
                    goto LABEL_30;
                  }
                }
                _BitScanForward(&v27, *(_DWORD *)v28 ^ *(_DWORD *)v26);
                v24 = v126;
                v29 = (unsigned int)v26 + (v27 >> 3) - v120;
              }
              v5 += v29 + 4;
              if ( v29 < 0xF )
              {
                *v24 += v29;
              }
              else
              {
                *v24 += 15;
                v30 = v29 - 15;
                if ( v30 >= 0x1FE )
                {
                  v31 = v30 / 0x1FE;
                  do
                  {
                    *(_WORD *)v6 = -1;
                    v6 += 2;
                    v30 -= 510;
                    --v31;
                  }
                  while ( v31 );
                }
                if ( v30 >= 0xFF )
                {
                  LOBYTE(v30) = v30 + 1;
                  *v6++ = -1;
                }
                *v6++ = v30;
              }
              v132 = (_BYTE *)v5;
              if ( v5 > v138 - 12 )
                goto LABEL_50;
              *((_WORD *)a2 + ((unsigned int)(-1640531535 * *(_DWORD *)(v5 - 2)) >> 19)) = v5 - 2 - a3;
              v32 = (unsigned int)(-1640531535 * *(_DWORD *)v5) >> 19;
              v16 = (_DWORD *)(a3 + *((_WORD *)a2 + v32));
              *((_WORD *)a2 + v32) = v5 - a3;
              if ( (unsigned int)v16 + 0xFFFF < v5 || *v16 != *(_DWORD *)v5 )
                goto LABEL_10;
              v24 = v6;
              v126 = v6;
              v25 = v6 + 1;
              *v24 = 0;
            }
          }
          ++v14;
          v11 = v118;
          v12 = v135;
        }
      }
LABEL_50:
      v33 = v138 - (_DWORD)v132;
      if ( (unsigned int)(v138 - (_DWORD)v132) < 0xF )
      {
        LOBYTE(v34) = 16 * v33;
      }
      else
      {
        v34 = v33 - 15;
        *v6++ = -16;
        v139 = v33 - 15;
        if ( v33 - 15 >= 0xFF )
        {
          v35 = v34 / 0xFF;
          memset(v6, 255, v34 / 0xFF);
          v6 += v35;
          do
          {
            v139 -= 255;
            --v35;
          }
          while ( v35 );
          LOBYTE(v34) = v139;
        }
      }
      *v6 = v34;
      v36 = v6 + 1;
      memcpy(v36, v132, v33);
      result = (char *)v36 + v33 - a4;
    }
    else
    {
      result = 0;
    }
    return result;
  }
  v37 = v7 + a3;
  v140 = v7 + a3;
  if ( (unsigned int)v7 > 0x7E000000 )
    return 0;
  if ( v7 >= 13 )
  {
    v38 = a3;
    *((_DWORD *)a2 + ((unsigned int)(-1640531535 * *(_DWORD *)a3) >> 20)) = a3;
LABEL_61:
    v39 = 1;
    v40 = (unsigned int)(-1640531535 * *(_DWORD *)(v38 + 1)) >> 20;
    v41 = (char *)(v38 + 1);
    for ( i = 64; ; ++i )
    {
      v38 = (unsigned int)v41;
      v41 += v39;
      if ( (unsigned int)v41 > v140 - 12 )
        break;
      v43 = 4 * v40;
      v44 = (_DWORD *)*((_DWORD *)a2 + v40);
      v127 = (unsigned int)(-1640531535 * *(_DWORD *)v41) >> 20;
      *(_DWORD *)((char *)a2 + v43) = v38;
      if ( (unsigned int)v44 + 0xFFFF >= v38 && *v44 == *(_DWORD *)v38 )
      {
        for ( ; v38 > (unsigned int)v132; v44 = (_DWORD *)((char *)v44 - 1) )
        {
          if ( (unsigned int)v44 <= a3 )
            break;
          if ( *(_BYTE *)(v38 - 1) != *((_BYTE *)v44 - 1) )
            break;
          --v38;
        }
        v45 = v38 - (_DWORD)v132;
        v46 = v6;
        v47 = v6 + 1;
        v128 = v46;
        if ( v38 - (unsigned int)v132 < 0xF )
        {
          *v46 = 16 * v45;
        }
        else
        {
          v48 = v45 - 15;
          v121 = v45 - 15;
          *v46 = -16;
          if ( v45 - 15 >= 255 )
          {
            v49 = v48 / 0xFF;
            memset(v47, 255, v48 / 0xFF);
            v47 += v49;
            v48 = -255 * v49 + v121;
            v45 = v38 - (_DWORD)v132;
          }
          *v47++ = v48;
        }
        v50 = (unsigned int)&v47[v45];
        v51 = v132 - v47;
        do
        {
          *(_DWORD *)v47 = *(_DWORD *)&v47[v51];
          *((_DWORD *)v47 + 1) = *(_DWORD *)&v47[v51 + 4];
          v47 += 8;
        }
        while ( (unsigned int)v47 < v50 );
        v52 = v140 - 8;
        v53 = (_WORD *)v50;
        while ( 1 )
        {
          *v53 = v38 - (_WORD)v44;
          v54 = (_WORD *)(v38 + 4);
          v6 = v53 + 1;
          v55 = v44 + 1;
          v122 = v38 + 4;
          if ( v38 + 4 >= v52 )
          {
LABEL_81:
            if ( (unsigned int)v54 < v140 - 6 && *v55 == *v54 )
            {
              ++v54;
              ++v55;
            }
            if ( (unsigned int)v54 < v140 - 5 && *(_BYTE *)v55 == *(_BYTE *)v54 )
              v54 = (_WORD *)((char *)v54 + 1);
            v56 = (unsigned int)v54 - v122;
          }
          else
          {
            while ( *(_DWORD *)v54 == *(_DWORD *)v55 )
            {
              v54 += 2;
              v55 += 2;
              if ( (unsigned int)v54 >= v52 )
                goto LABEL_81;
            }
            _BitScanForward(&v52, *(_DWORD *)v54 ^ *(_DWORD *)v55);
            v56 = (unsigned int)v54 + (v52 >> 3) - v122;
          }
          v38 += v56 + 4;
          if ( v56 < 0xF )
          {
            *v128 += v56;
          }
          else
          {
            *v128 += 15;
            v57 = v56 - 15;
            if ( v57 >= 0x1FE )
            {
              v58 = v57 / 0x1FE;
              do
              {
                *(_WORD *)v6 = -1;
                v6 += 2;
                v57 -= 510;
                --v58;
              }
              while ( v58 );
            }
            if ( v57 >= 0xFF )
            {
              LOBYTE(v57) = v57 + 1;
              *v6++ = -1;
            }
            *v6++ = v57;
          }
          v132 = (_BYTE *)v38;
          if ( v38 > v140 - 12 )
            goto LABEL_101;
          *((_DWORD *)a2 + ((unsigned int)(-1640531535 * *(_DWORD *)(v38 - 2)) >> 20)) = v38 - 2;
          v44 = (_DWORD *)*((_DWORD *)a2 + ((unsigned int)(-1640531535 * *(_DWORD *)v38) >> 20));
          *((_DWORD *)a2 + ((unsigned int)(-1640531535 * *(_DWORD *)v38) >> 20)) = v38;
          if ( (unsigned int)v44 + 0xFFFF < v38 || *v44 != *(_DWORD *)v38 )
            goto LABEL_61;
          v52 = v140 - 8;
          v128 = v6;
          v53 = v6 + 1;
          *v128 = 0;
        }
      }
      v39 = i >> 6;
      v40 = v127;
    }
LABEL_101:
    v37 = v140;
  }
  v59 = v37 - (_DWORD)v132;
  if ( v59 < 0xF )
  {
    LOBYTE(v60) = 16 * v59;
  }
  else
  {
    v60 = v59 - 15;
    *v6++ = -16;
    v141 = v59 - 15;
    if ( v59 - 15 >= 0xFF )
    {
      v61 = v60 / 0xFF;
      memset(v6, 255, v60 / 0xFF);
      v6 += v61;
      do
      {
        v141 -= 255;
        --v61;
      }
      while ( v61 );
      LOBYTE(v60) = v141;
    }
  }
  *v6 = v60;
  v62 = v6 + 1;
  memcpy(v62, v132, v59);
  return (char *)v62 + v59 - a4;
}

//----- (10022560) --------------------------------------------------------
char *__usercall sub_10022560@<eax>(int a1@<edx>, int a2@<ecx>, int a3, signed int a4)
{
  char v5; // [sp+0h] [bp-4028h]@1

  return sub_100218F0(a4, &v5, a3, a2, a1);
}

//----- (100225A0) --------------------------------------------------------
char *__usercall sub_100225A0@<eax>(int a1@<edx>, _BYTE *a2@<ecx>, void *a3, int a4)
{
  char *v4; // ebx@1
  char *result; // eax@1
  _BYTE *v6; // esi@1
  unsigned int v7; // edi@5
  int v8; // eax@6
  unsigned int v9; // ecx@10
  _WORD *v10; // edx@11
  char *v11; // eax@12
  int v12; // esi@12
  unsigned int v13; // eax@14
  int v14; // edi@15
  int v15; // edx@17
  int v16; // edi@19
  int v17; // ST1C_4@20
  char v18; // dl@20
  char *v19; // eax@20
  char *v20; // ecx@20
  char *v21; // eax@20
  int v22; // eax@25
  int v23; // eax@31
  char v24; // [sp+10h] [bp-54h]@5
  _BYTE *v25; // [sp+14h] [bp-50h]@1
  int v26; // [sp+18h] [bp-4Ch]@1
  char *v27; // [sp+1Ch] [bp-48h]@1
  int v28; // [sp+20h] [bp-44h]@1
  int v29; // [sp+24h] [bp-40h]@1
  int v30; // [sp+28h] [bp-3Ch]@1
  int v31; // [sp+2Ch] [bp-38h]@1
  int v32; // [sp+30h] [bp-34h]@1
  int v33; // [sp+34h] [bp-30h]@1
  int v34; // [sp+38h] [bp-2Ch]@1
  int v35; // [sp+3Ch] [bp-28h]@1
  int v36; // [sp+40h] [bp-24h]@1
  int v37; // [sp+44h] [bp-20h]@1
  int v38; // [sp+48h] [bp-1Ch]@1
  int v39; // [sp+4Ch] [bp-18h]@1
  int v40; // [sp+50h] [bp-14h]@1
  int v41; // [sp+54h] [bp-10h]@1
  int v42; // [sp+58h] [bp-Ch]@1
  int v43; // [sp+5Ch] [bp-8h]@1

  v4 = (char *)a3;
  v26 = (int)&a2[a4];
  v27 = (char *)a3 + a1;
  v36 = 4;
  v40 = 4;
  v41 = 4;
  v42 = 4;
  v43 = 4;
  result = 0;
  v25 = a2;
  v6 = a2;
  v37 = 1;
  v38 = 2;
  v39 = 1;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = -1;
  v32 = 0;
  v33 = 1;
  v34 = 2;
  v35 = 3;
  if ( a1 )
  {
    while ( 1 )
    {
      v24 = *v6;
      v7 = (unsigned int)*v6++ >> 4;
      if ( v7 == 15 )
      {
        do
        {
          v8 = *v6++;
          v7 += v8;
        }
        while ( (unsigned int)v6 < v26 - 15 && v8 == 255 );
        if ( &v4[v7] < v4 || &v6[v7] < v6 )
          return (char *)(a2 - v6 - 1);
      }
      v9 = (unsigned int)&v4[v7];
      if ( &v4[v7] > v27 - 12 || (v10 = &v6[v7], (unsigned int)&v6[v7] > v26 - 8) )
      {
        if ( &v6[v7] == (_BYTE *)v26 && v9 <= (unsigned int)v27 )
        {
          memcpy(v4, v6, v7);
          return &v4[v7 - (_DWORD)a3];
        }
        goto LABEL_37;
      }
      v11 = v4;
      v12 = v6 - v4;
      do
      {
        *(_DWORD *)v11 = *(_DWORD *)&v11[v12];
        *((_DWORD *)v11 + 1) = *(_DWORD *)&v11[v12 + 4];
        v11 += 8;
      }
      while ( (unsigned int)v11 < v9 );
      v13 = v9 - *v10;
      v6 = v10 + 1;
      if ( v13 < (unsigned int)a3 )
        goto LABEL_37;
      v14 = v24 & 0xF;
      if ( v14 == 15 )
      {
        while ( (unsigned int)v6 <= v26 - 5 )
        {
          v15 = *v6++;
          v14 += v15;
          if ( v15 != 255 )
          {
            if ( v9 + v14 < v9 )
              break;
            goto LABEL_19;
          }
        }
LABEL_37:
        a2 = v25;
        return (char *)(a2 - v6 - 1);
      }
LABEL_19:
      v4 = (char *)(v9 + v14 + 4);
      v16 = v9 - v13;
      if ( (signed int)(v9 - v13) >= 8 )
      {
        *(_DWORD *)v9 = *(_DWORD *)v13;
        *(_DWORD *)(v9 + 4) = *(_DWORD *)(v13 + 4);
        v20 = (char *)(v9 + 8);
        v21 = (char *)(v13 + 8);
      }
      else
      {
        v17 = *(&v28 + v16);
        *(_BYTE *)v9 = *(_BYTE *)v13;
        *(_BYTE *)(v9 + 1) = *(_BYTE *)(v13 + 1);
        *(_BYTE *)(v9 + 2) = *(_BYTE *)(v13 + 2);
        v18 = *(_BYTE *)(v13 + 3);
        v19 = (char *)(*(&v36 + v16) + v13);
        *(_BYTE *)(v9 + 3) = v18;
        *(_DWORD *)(v9 + 4) = *(_DWORD *)v19;
        v20 = (char *)(v9 + 8);
        v21 = &v19[-v17];
      }
      if ( v4 <= v27 - 12 )
        break;
      if ( v4 > v27 - 5 )
        goto LABEL_37;
      if ( v20 < v27 - 8 )
      {
        v22 = v21 - v20;
        do
        {
          *(_DWORD *)v20 = *(_DWORD *)&v20[v22];
          *((_DWORD *)v20 + 1) = *(_DWORD *)&v20[v22 + 4];
          v20 += 8;
        }
        while ( v20 < v27 - 8 );
        v21 = &v27[v22 - 8];
        v20 = v27 - 8;
      }
      if ( v20 >= v4 )
      {
LABEL_33:
        a2 = v25;
      }
      else
      {
        do
          *v20++ = *v21++;
        while ( v20 < v4 );
        a2 = v25;
      }
    }
    v23 = v21 - v20;
    do
    {
      *(_DWORD *)v20 = *(_DWORD *)&v20[v23];
      *((_DWORD *)v20 + 1) = *(_DWORD *)&v20[v23 + 4];
      v20 += 8;
    }
    while ( v20 < v4 );
    goto LABEL_33;
  }
  if ( a4 != 1 || *a2 )
    result = (char *)-1;
  return result;
}

//----- (10022820) --------------------------------------------------------
char *__usercall sub_10022820@<eax>(int a1@<edx>, _BYTE *a2@<ecx>, int a3, void *a4)
{
  char *v4; // esi@1
  char *v5; // edi@1
  int v6; // ebx@1
  int v7; // edi@2
  unsigned int v8; // edx@2
  unsigned int v9; // edi@4
  _BYTE *v10; // ecx@4
  size_t v11; // edi@4
  int v12; // eax@5
  char *v13; // eax@9
  char *v14; // ebx@9
  _WORD *v15; // edx@10
  int v16; // ecx@11
  int v17; // esi@13
  _BYTE *v18; // edx@13
  unsigned int v19; // eax@13
  char *v20; // ecx@13
  int v21; // edi@15
  int v22; // esi@17
  size_t v23; // edi@19
  size_t v24; // edi@23
  unsigned int v25; // ecx@24
  int v26; // eax@25
  int v27; // esi@29
  unsigned int v28; // ebx@29
  char v29; // dl@30
  char *v30; // eax@30
  char *v31; // ecx@30
  char *v32; // eax@30
  int v33; // eax@35
  int v34; // eax@41
  char *result; // eax@47
  int v36; // ecx@50
  unsigned int v37; // edx@51
  int v38; // edi@51
  char *v39; // eax@51
  unsigned int v40; // edi@53
  char *v41; // eax@53
  size_t v42; // edi@53
  int v43; // ecx@54
  char *v44; // ecx@58
  char *v45; // ebx@58
  char *v46; // ecx@59
  int v47; // eax@60
  char *v48; // esi@62
  unsigned int v49; // eax@62
  char *v50; // ecx@62
  int v51; // edi@64
  int v52; // edx@66
  char *v53; // edi@68
  size_t v54; // edi@72
  unsigned int v55; // ecx@73
  char *v56; // eax@74
  int v57; // esi@78
  unsigned int v58; // ebx@78
  char v59; // dl@79
  char *v60; // eax@79
  char *v61; // ecx@79
  char *v62; // eax@79
  int v63; // eax@84
  int v64; // eax@90
  _BYTE *v65; // [sp+10h] [bp-6Ch]@1
  unsigned int v66; // [sp+14h] [bp-68h]@2
  char *v67; // [sp+14h] [bp-68h]@51
  int v68; // [sp+18h] [bp-64h]@51
  char *v69; // [sp+1Ch] [bp-60h]@2
  int v70; // [sp+20h] [bp-5Ch]@2
  char v71; // [sp+20h] [bp-5Ch]@53
  size_t v72; // [sp+24h] [bp-58h]@2
  char *v73; // [sp+24h] [bp-58h]@70
  int v74; // [sp+28h] [bp-54h]@2
  int v75; // [sp+28h] [bp-54h]@51
  char v76; // [sp+2Ch] [bp-50h]@4
  int v77; // [sp+2Ch] [bp-50h]@21
  size_t v78; // [sp+2Ch] [bp-50h]@51
  void *v79; // [sp+34h] [bp-48h]@4
  char *v80; // [sp+34h] [bp-48h]@53
  int v81; // [sp+38h] [bp-44h]@2
  int v82; // [sp+3Ch] [bp-40h]@2
  int v83; // [sp+40h] [bp-3Ch]@2
  int v84; // [sp+44h] [bp-38h]@2
  int v85; // [sp+48h] [bp-34h]@2
  int v86; // [sp+4Ch] [bp-30h]@2
  int v87; // [sp+50h] [bp-2Ch]@2
  int v88; // [sp+54h] [bp-28h]@2
  int v89; // [sp+58h] [bp-24h]@2
  int v90; // [sp+5Ch] [bp-20h]@2
  int v91; // [sp+60h] [bp-1Ch]@2
  int v92; // [sp+64h] [bp-18h]@2
  int v93; // [sp+68h] [bp-14h]@2
  int v94; // [sp+6Ch] [bp-10h]@2
  int v95; // [sp+70h] [bp-Ch]@2
  int v96; // [sp+74h] [bp-8h]@2

  v4 = (char *)a4;
  v5 = *(char **)(a3 + 8);
  v6 = a1;
  v65 = a2;
  if ( v5 != a4 )
  {
    v37 = *(_DWORD *)(a3 + 12);
    v38 = (int)&v5[-v37];
    *(_DWORD *)a3 = v38;
    *(_DWORD *)(a3 + 4) = v37;
    v39 = a2;
    v75 = (int)&a2[v6];
    v67 = (char *)a4 - v37;
    v81 = 4;
    v85 = 4;
    v86 = 4;
    v87 = 4;
    v88 = 4;
    v89 = 0;
    v90 = 0;
    v91 = 0;
    v93 = 0;
    v78 = v37 + v38;
    v82 = 1;
    v83 = 2;
    v84 = 1;
    v92 = -1;
    v94 = 1;
    v95 = 2;
    v96 = 3;
    v68 = v37 < 0x10000;
    while ( 1 )
    {
      v40 = (unsigned __int8)*v39;
      v71 = *v39;
      v41 = v39 + 1;
      v42 = v40 >> 4;
      v80 = v41;
      if ( v42 == 15 )
      {
        do
        {
          v43 = (unsigned __int8)*v41++;
          v42 += v43;
        }
        while ( (unsigned int)v41 < v75 - 15 && v43 == 255 );
        v80 = v41;
        if ( &v4[v42] < v4 || &v41[v42] < v41 )
          goto LABEL_97;
      }
      v44 = (char *)a4 + 0x100000;
      v45 = &v4[v42];
      if ( &v4[v42] > (char *)a4 + 1048564 )
        goto LABEL_94;
      v46 = &v80[v42];
      if ( (unsigned int)&v80[v42] > v75 - 8 )
      {
        v44 = (char *)a4 + 0x100000;
LABEL_94:
        if ( &v80[v42] != (char *)v75 || v45 > v44 )
        {
LABEL_97:
          result = (char *)(v65 - v80 - 1);
        }
        else
        {
          memcpy(v4, v80, v42);
          result = &v4[v42 - (_DWORD)a4];
        }
        if ( (signed int)result > 0 )
        {
          *(_DWORD *)(a3 + 12) = result;
          *(_DWORD *)(a3 + 8) = (char *)a4 + (_DWORD)result;
        }
        return result;
      }
      v47 = v80 - v4;
      do
      {
        *(_DWORD *)v4 = *(_DWORD *)&v4[v47];
        *((_DWORD *)v4 + 1) = *(_DWORD *)&v4[v47 + 4];
        v4 += 8;
      }
      while ( v4 < v45 );
      v48 = v46 + 2;
      v49 = (unsigned int)&v45[-*(_WORD *)v46];
      v50 = v45;
      v80 = v48;
      if ( v68 && v49 < (unsigned int)v67 )
        goto LABEL_97;
      v51 = v71 & 0xF;
      if ( v51 == 15 )
      {
        do
        {
          if ( (unsigned int)v48 > v75 - 5 )
            goto LABEL_97;
          v52 = (unsigned __int8)*v48++;
          v51 += v52;
          v80 = v48;
        }
        while ( v52 == 255 );
        if ( &v45[v51] < v45 )
          goto LABEL_97;
      }
      v53 = (char *)(v51 + 4);
      if ( v49 >= (unsigned int)a4 )
      {
        v57 = (int)&v45[-v49];
        v58 = (unsigned int)&v45[(_DWORD)v53];
        if ( (signed int)&v50[-v49] >= 8 )
        {
          *(_DWORD *)v50 = *(_DWORD *)v49;
          *((_DWORD *)v50 + 1) = *(_DWORD *)(v49 + 4);
          v61 = v50 + 8;
          v62 = (char *)(v49 + 8);
        }
        else
        {
          *v50 = *(_BYTE *)v49;
          v50[1] = *(_BYTE *)(v49 + 1);
          v50[2] = *(_BYTE *)(v49 + 2);
          v59 = *(_BYTE *)(v49 + 3);
          v60 = (char *)(*(&v81 + v57) + v49);
          v50[3] = v59;
          *((_DWORD *)v50 + 1) = *(_DWORD *)v60;
          v61 = v50 + 8;
          v62 = &v60[-*(&v89 + v57)];
        }
        if ( v58 <= (unsigned int)a4 + 1048564 )
        {
          v64 = v62 - v61;
          do
          {
            *(_DWORD *)v61 = *(_DWORD *)&v61[v64];
            *((_DWORD *)v61 + 1) = *(_DWORD *)&v61[v64 + 4];
            v61 += 8;
          }
          while ( (unsigned int)v61 < v58 );
LABEL_92:
          v4 = (char *)v58;
          goto LABEL_52;
        }
        if ( v58 > (unsigned int)a4 + 1048571 )
          goto LABEL_97;
        if ( v61 < (char *)a4 + 1048568 )
        {
          v63 = v62 - v61;
          do
          {
            *(_DWORD *)v61 = *(_DWORD *)&v61[v63];
            *((_DWORD *)v61 + 1) = *(_DWORD *)&v61[v63 + 4];
            v61 += 8;
          }
          while ( v61 < (char *)a4 + 1048568 );
          v62 = (char *)a4 + v63 + 1048568;
          v61 = (char *)a4 + 1048568;
        }
        if ( (unsigned int)v61 >= v58 )
          goto LABEL_92;
        do
          *v61++ = *v62++;
        while ( (unsigned int)v61 < v58 );
        v4 = (char *)v58;
      }
      else
      {
        v4 = &v53[(_DWORD)v45];
        if ( &v53[(signed int)v45] > (char *)a4 + 1048571 )
          goto LABEL_97;
        v73 = (char *)a4 - v49;
        if ( v53 > (char *)a4 - v49 )
        {
          memcpy(v45, (const void *)(v78 - (_DWORD)v73), (size_t)v73);
          v54 = v53 - v73;
          v4 = &v73[(_DWORD)v45];
          if ( (char *)v54 <= &v73[(signed int)v45] - (char *)a4 )
          {
            memcpy(v4, a4, v54);
            v4 += v54;
          }
          else
          {
            v55 = (unsigned int)&v4[v54];
            if ( v4 < &v4[v54] )
            {
              v56 = (char *)((_BYTE *)a4 - v4);
              do
              {
                *v4 = v4[(_DWORD)v56];
                ++v4;
              }
              while ( (unsigned int)v4 < v55 );
            }
          }
        }
        else
        {
          memmove(v45, (const void *)(v78 + v49 - (_DWORD)a4), (size_t)v53);
        }
      }
LABEL_52:
      v39 = v80;
    }
  }
  v7 = (int)&v5[-*(_DWORD *)(a3 + 12)];
  v8 = *(_DWORD *)(a3 + 4);
  v72 = v8 + *(_DWORD *)a3;
  v89 = 4;
  v93 = 4;
  v94 = 4;
  v95 = 4;
  v96 = 4;
  v69 = (char *)v7;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v85 = 0;
  v74 = (int)&a2[v6];
  v66 = v7 - v8;
  v90 = 1;
  v91 = 2;
  v92 = 1;
  v84 = -1;
  v86 = 1;
  v87 = 2;
  v88 = 3;
  v70 = v8 < 0x10000;
  while ( 1 )
  {
    v9 = *a2;
    v76 = *a2;
    v10 = a2 + 1;
    v11 = v9 >> 4;
    v79 = v10;
    if ( v11 == 15 )
    {
      do
      {
        v12 = *v10++;
        v11 += v12;
      }
      while ( (unsigned int)v10 < v74 - 15 && v12 == 255 );
      v79 = v10;
      if ( &v4[v11] < v4 || &v10[v11] < v10 )
        break;
    }
    v13 = (char *)a4 + 0x100000;
    v14 = &v4[v11];
    if ( &v4[v11] > (char *)a4 + 1048564 )
      goto LABEL_45;
    v15 = &v10[v11];
    if ( (unsigned int)&v10[v11] > v74 - 8 )
    {
      v13 = (char *)a4 + 0x100000;
LABEL_45:
      if ( &v10[v11] == (_BYTE *)v74 && v14 <= v13 )
      {
        memcpy(v4, v79, v11);
        result = &v4[v11 - (_DWORD)a4];
        goto LABEL_49;
      }
      break;
    }
    v16 = v10 - v4;
    do
    {
      *(_DWORD *)v4 = *(_DWORD *)&v4[v16];
      *((_DWORD *)v4 + 1) = *(_DWORD *)&v4[v16 + 4];
      v4 += 8;
    }
    while ( v4 < v14 );
    v17 = *v15;
    v18 = v15 + 1;
    v19 = (unsigned int)&v14[-v17];
    v20 = v14;
    v79 = v18;
    if ( v70 && v19 < v66 )
      break;
    v21 = v76 & 0xF;
    if ( v21 == 15 )
    {
      while ( (unsigned int)v18 <= v74 - 5 )
      {
        v22 = *v18++;
        v21 += v22;
        v79 = v18;
        if ( v22 != 255 )
        {
          if ( &v14[v21] < v14 )
            goto LABEL_48;
          goto LABEL_19;
        }
      }
      break;
    }
LABEL_19:
    v23 = v21 + 4;
    if ( v19 >= (unsigned int)v69 )
    {
      v27 = (int)&v14[-v19];
      v28 = (unsigned int)&v14[v23];
      if ( (signed int)&v20[-v19] >= 8 )
      {
        *(_DWORD *)v20 = *(_DWORD *)v19;
        *((_DWORD *)v20 + 1) = *(_DWORD *)(v19 + 4);
        v31 = v20 + 8;
        v32 = (char *)(v19 + 8);
      }
      else
      {
        *v20 = *(_BYTE *)v19;
        v20[1] = *(_BYTE *)(v19 + 1);
        v20[2] = *(_BYTE *)(v19 + 2);
        v29 = *(_BYTE *)(v19 + 3);
        v30 = (char *)(*(&v89 + v27) + v19);
        v20[3] = v29;
        *((_DWORD *)v20 + 1) = *(_DWORD *)v30;
        v31 = v20 + 8;
        v32 = &v30[-*(&v81 + v27)];
      }
      if ( v28 <= (unsigned int)a4 + 1048564 )
      {
        v34 = v32 - v31;
        do
        {
          *(_DWORD *)v31 = *(_DWORD *)&v31[v34];
          *((_DWORD *)v31 + 1) = *(_DWORD *)&v31[v34 + 4];
          v31 += 8;
        }
        while ( (unsigned int)v31 < v28 );
LABEL_43:
        v4 = (char *)v28;
        goto LABEL_3;
      }
      if ( v28 > (unsigned int)a4 + 1048571 )
        break;
      if ( v31 < (char *)a4 + 1048568 )
      {
        v33 = v32 - v31;
        do
        {
          *(_DWORD *)v31 = *(_DWORD *)&v31[v33];
          *((_DWORD *)v31 + 1) = *(_DWORD *)&v31[v33 + 4];
          v31 += 8;
        }
        while ( v31 < (char *)a4 + 1048568 );
        v32 = (char *)a4 + v33 + 1048568;
        v31 = (char *)a4 + 1048568;
      }
      if ( (unsigned int)v31 >= v28 )
        goto LABEL_43;
      do
        *v31++ = *v32++;
      while ( (unsigned int)v31 < v28 );
      v4 = (char *)v28;
    }
    else
    {
      v4 = &v14[v23];
      if ( &v14[v23] > (char *)a4 + 1048571 )
        break;
      v77 = (int)&v69[-v19];
      if ( v23 > (unsigned int)&v69[-v19] )
      {
        memcpy(v14, (const void *)(v72 - v77), v77);
        v24 = v23 - v77;
        v4 = &v14[v77];
        if ( v24 <= &v14[v77] - v69 )
        {
          memcpy(v4, v69, v24);
          v4 += v24;
        }
        else
        {
          v25 = (unsigned int)&v4[v24];
          if ( v4 < &v4[v24] )
          {
            v26 = v69 - v4;
            do
            {
              *v4 = v4[v26];
              ++v4;
            }
            while ( (unsigned int)v4 < v25 );
          }
        }
      }
      else
      {
        memmove(v14, (const void *)(v72 + v19 - (_DWORD)v69), v23);
      }
    }
LABEL_3:
    a2 = v79;
  }
LABEL_48:
  result = (char *)(v65 - (_BYTE *)v79 - 1);
LABEL_49:
  if ( (signed int)result > 0 )
  {
    v36 = a3;
    *(_DWORD *)(v36 + 12) += result;
    *(_DWORD *)(v36 + 8) += result;
  }
  return result;
}

//----- (10022E70) --------------------------------------------------------
signed int __stdcall sub_10022E70(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // edi@1
  unsigned int v4; // ebx@1
  unsigned int v5; // esi@1
  int v6; // edx@1
  unsigned int v7; // eax@1
  int v8; // ecx@2
  unsigned int v9; // edx@4
  int v10; // edx@5
  unsigned int v11; // ecx@7
  signed int v12; // ecx@11
  unsigned int v13; // ecx@13
  int v14; // edi@14
  unsigned int v15; // ebx@16
  int v16; // edi@21
  int v17; // edi@23
  int v18; // edx@23
  int v19; // edi@23
  unsigned int v20; // ebx@25
  unsigned int v21; // eax@30
  int v22; // edx@30
  unsigned int v23; // edi@32
  unsigned int v24; // eax@33
  unsigned int v25; // ebx@33
  int v26; // ecx@33
  unsigned int v27; // eax@34
  int v28; // edx@36
  unsigned int v29; // edi@38
  unsigned int v30; // eax@39
  int v31; // edx@39
  unsigned int v32; // edi@41
  unsigned int v33; // edi@42
  unsigned int v34; // eax@44
  int v35; // edx@44
  unsigned int v36; // edi@46
  __int16 v37; // di@47
  unsigned int v38; // edx@47
  unsigned int v39; // eax@48
  int v40; // edx@48
  unsigned int v41; // edi@50
  __int16 v42; // di@51
  int v43; // edx@56
  unsigned int v44; // edi@58
  int v45; // edi@59
  unsigned int v46; // eax@60
  int v47; // edx@60
  unsigned int v48; // edi@62
  unsigned int v49; // edx@65
  unsigned int v50; // ecx@66
  unsigned int v51; // edi@68
  unsigned int v52; // edx@72
  signed int v53; // ecx@73
  int v54; // ecx@75
  int v55; // edx@75
  unsigned int v56; // edi@77
  unsigned int v57; // eax@78
  signed int v58; // edx@78
  int v59; // ebx@80
  unsigned int v60; // edx@80
  unsigned int v61; // edi@82
  unsigned int v62; // eax@83
  int v63; // ebx@85
  int v64; // edx@85
  unsigned int v65; // edi@87
  unsigned int v66; // eax@88
  int v67; // ebx@90
  int v68; // edx@90
  unsigned int v69; // edi@92
  unsigned int v70; // eax@93
  int v71; // ebx@95
  int v72; // edx@95
  unsigned int v73; // edi@97
  unsigned int v74; // eax@98
  int v75; // ebx@100
  int v76; // edx@100
  unsigned int v77; // edi@102
  unsigned int v78; // ebx@105
  unsigned int v79; // edx@106
  int v80; // edi@106
  int v81; // ecx@106
  int v82; // ebx@106
  int v83; // ecx@107
  unsigned int v84; // edx@108
  unsigned int v85; // ecx@110
  int v86; // ecx@115
  unsigned int v87; // esi@118
  int v88; // edx@119
  unsigned int v89; // edi@121
  unsigned int v90; // eax@122
  signed int v91; // edx@122
  unsigned int v92; // edx@124
  unsigned int v93; // edi@126
  unsigned int v94; // eax@127
  __int16 v95; // di@127
  int v96; // edx@127
  unsigned int v97; // edx@129
  unsigned int v98; // edi@131
  unsigned int v99; // eax@132
  __int16 v100; // di@132
  int v101; // edx@132
  unsigned int v102; // edx@134
  unsigned int v103; // edi@136
  unsigned int v104; // edx@140
  bool v105; // cf@141
  unsigned int v106; // edx@145
  int v107; // ecx@148
  _BYTE *v108; // edx@149
  int v110; // edx@161
  int v111; // [sp+Ch] [bp-50h]@1
  int v112; // [sp+10h] [bp-4Ch]@23
  int v113; // [sp+10h] [bp-4Ch]@149
  int v114; // [sp+14h] [bp-48h]@1
  unsigned __int16 *v115; // [sp+18h] [bp-44h]@23
  int v116; // [sp+18h] [bp-44h]@106
  int v117; // [sp+1Ch] [bp-40h]@1
  unsigned int v118; // [sp+20h] [bp-3Ch]@1
  unsigned int v119; // [sp+24h] [bp-38h]@1
  signed int v120; // [sp+24h] [bp-38h]@107
  int v121; // [sp+28h] [bp-34h]@1
  unsigned int v122; // [sp+2Ch] [bp-30h]@1
  unsigned int v123; // [sp+30h] [bp-2Ch]@1
  int v124; // [sp+34h] [bp-28h]@1
  int v125; // [sp+34h] [bp-28h]@65
  unsigned int v126; // [sp+34h] [bp-28h]@72
  unsigned int v127; // [sp+38h] [bp-24h]@1
  int v128; // [sp+3Ch] [bp-20h]@1
  int v129; // [sp+40h] [bp-1Ch]@2
  signed int v130; // [sp+40h] [bp-1Ch]@21
  unsigned int v131; // [sp+40h] [bp-1Ch]@59
  int v132; // [sp+40h] [bp-1Ch]@124
  int v133; // [sp+40h] [bp-1Ch]@129
  int v134; // [sp+40h] [bp-1Ch]@134
  unsigned int v135; // [sp+44h] [bp-18h]@1
  unsigned int v136; // [sp+48h] [bp-14h]@1
  unsigned int v137; // [sp+4Ch] [bp-10h]@1
  unsigned int v138; // [sp+50h] [bp-Ch]@1
  unsigned int v139; // [sp+50h] [bp-Ch]@146
  unsigned __int16 *v140; // [sp+54h] [bp-8h]@2
  int v141; // [sp+54h] [bp-8h]@5
  unsigned __int16 *v142; // [sp+54h] [bp-8h]@39
  signed int v143; // [sp+54h] [bp-8h]@59
  int v144; // [sp+54h] [bp-8h]@107
  _BYTE *v145; // [sp+58h] [bp-4h]@1

  v3 = a1;
  v128 = *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 52);
  v135 = *(_DWORD *)(a1 + 56);
  v5 = *(_DWORD *)(a1 + 32);
  v122 = *(_DWORD *)(a1 + 64);
  v119 = *(_DWORD *)(a1 + 68);
  v123 = *(_DWORD *)(a1 + 60);
  v6 = (1 << *(_DWORD *)(a1 + 8)) - 1;
  v121 = *(_DWORD *)(a1 + 20);
  v114 = (1 << *(_DWORD *)(a1 + 4)) - 1;
  v117 = *(_DWORD *)a1;
  v127 = *(_DWORD *)(a1 + 40);
  v137 = *(_DWORD *)(a1 + 44);
  v138 = *(_DWORD *)(a1 + 36);
  v145 = *(_BYTE **)(a1 + 24);
  v7 = *(_DWORD *)(a1 + 28);
  v136 = *(_DWORD *)(a1 + 52);
  v111 = (1 << *(_DWORD *)(a1 + 8)) - 1;
  v118 = *(_DWORD *)(a1 + 48);
  v124 = 0;
  while ( 1 )
  {
    v129 = v6 & v137;
    v140 = (unsigned __int16 *)(v128 + 2 * ((v6 & v137) + 16 * v4));
    v8 = *v140;
    if ( v7 < 0x1000000 )
    {
      v7 <<= 8;
      v5 = *v145++ | (v5 << 8);
    }
    v9 = v8 * (v7 >> 11);
    if ( v5 < v9 )
    {
      v7 = v8 * (v7 >> 11);
      *v140 = v8 + ((unsigned int)(2048 - v8) >> 5);
      v10 = v128 + 3692;
      v141 = v128 + 3692;
      if ( v118 || v137 )
      {
        v11 = v138;
        if ( !v138 )
          v11 = v127;
        v10 = 1536 * (((v114 & v137) << v117) + ((unsigned int)*(_BYTE *)(v11 + v121 - 1) >> (8 - v117))) + v141;
        v4 = v136;
        v141 += 1536 * (((v114 & v137) << v117) + ((unsigned int)*(_BYTE *)(v11 + v121 - 1) >> (8 - v117)));
      }
      if ( v4 >= 7 )
      {
        v130 = 256;
        v16 = *(_BYTE *)(*(_DWORD *)(v3 + 20) + (v138 < v135 ? v127 : 0) - v135 + v138);
        v136 = v4 - (v4 < 0xA ? 3 : 6);
        v13 = 1;
        while ( 1 )
        {
          v17 = 2 * v16;
          v18 = v17 & v130;
          v112 = v17;
          v115 = (unsigned __int16 *)(v141 + 2 * (v13 + (v17 & v130) + v130));
          v19 = *v115;
          if ( v7 < 0x1000000 )
          {
            v7 <<= 8;
            v5 = *v145++ | (v5 << 8);
          }
          v20 = v19 * (v7 >> 11);
          if ( v5 >= v20 )
          {
            v7 -= v20;
            v5 -= v20;
            *v115 -= *v115 >> 5;
            v13 = 2 * v13 + 1;
          }
          else
          {
            v7 = v19 * (v7 >> 11);
            *v115 = v19 + ((unsigned int)(2048 - v19) >> 5);
            v13 *= 2;
            v18 = ~v18;
          }
          v130 &= v18;
          if ( v13 >= 0x100 )
            break;
          v16 = v112;
        }
      }
      else
      {
        v12 = v4;
        if ( v4 >= 4 )
          v12 = 3;
        v136 = v4 - v12;
        v13 = 1;
        do
        {
          v14 = *(_WORD *)(v10 + 2 * v13);
          if ( v7 < 0x1000000 )
          {
            v7 <<= 8;
            v5 = *v145++ | (v5 << 8);
          }
          v15 = v14 * (v7 >> 11);
          if ( v5 >= v15 )
          {
            v7 -= v15;
            v5 -= v15;
            *(_WORD *)(v10 + 2 * v13) -= *(_WORD *)(v10 + 2 * v13) >> 5;
            v13 = 2 * v13 + 1;
          }
          else
          {
            v7 = v14 * (v7 >> 11);
            *(_WORD *)(v10 + 2 * v13) = v14 + ((unsigned int)(2048 - v14) >> 5);
            v13 *= 2;
          }
        }
        while ( v13 < 0x100 );
      }
      *(_BYTE *)(v138 + v121) = v13;
      ++v137;
      ++v138;
      goto LABEL_156;
    }
    v21 = v7 - v9;
    v5 -= v9;
    *v140 -= *v140 >> 5;
    v22 = *(_WORD *)(v128 + 2 * v4 + 384);
    if ( v21 < 0x1000000 )
    {
      v21 <<= 8;
      v5 = *v145++ | (v5 << 8);
    }
    v23 = v22 * (v21 >> 11);
    if ( v5 >= v23 )
    {
      v27 = v21 - v23;
      v5 -= v23;
      *(_WORD *)(v128 + 2 * v4 + 384) -= *(_WORD *)(v128 + 2 * v4 + 384) >> 5;
      if ( !v118 && !v137 )
        return 1;
      v28 = *(_WORD *)(v128 + 2 * v4 + 408);
      if ( v27 < 0x1000000 )
      {
        v27 <<= 8;
        v5 = *v145++ | (v5 << 8);
      }
      v29 = v28 * (v27 >> 11);
      if ( v5 >= v29 )
      {
        v34 = v27 - v29;
        v5 -= v29;
        *(_WORD *)(v128 + 2 * v4 + 408) -= *(_WORD *)(v128 + 2 * v4 + 408) >> 5;
        v35 = *(_WORD *)(v128 + 2 * v4 + 432);
        if ( v34 < 0x1000000 )
        {
          v34 <<= 8;
          v5 = *v145++ | (v5 << 8);
        }
        v36 = v35 * (v34 >> 11);
        if ( v5 >= v36 )
        {
          v39 = v34 - v36;
          v5 -= v36;
          *(_WORD *)(v128 + 2 * v4 + 432) -= *(_WORD *)(v128 + 2 * v4 + 432) >> 5;
          v40 = *(_WORD *)(v128 + 2 * v4 + 456);
          if ( v39 < 0x1000000 )
          {
            v39 <<= 8;
            v5 = *v145++ | (v5 << 8);
          }
          v41 = v40 * (v39 >> 11);
          if ( v5 >= v41 )
          {
            v24 = v39 - v41;
            v5 -= v41;
            *(_WORD *)(v128 + 2 * v4 + 456) -= *(_WORD *)(v128 + 2 * v4 + 456) >> 5;
            v38 = v119;
            v119 = v122;
          }
          else
          {
            v24 = v40 * (v39 >> 11);
            v42 = v40 + ((unsigned int)(2048 - v40) >> 5);
            v38 = v122;
            *(_WORD *)(v128 + 2 * v4 + 456) = v42;
          }
          v122 = v123;
        }
        else
        {
          v24 = v35 * (v34 >> 11);
          v37 = v35 + ((unsigned int)(2048 - v35) >> 5);
          v38 = v123;
          *(_WORD *)(v128 + 2 * v4 + 432) = v37;
        }
        v123 = v135;
        v135 = v38;
      }
      else
      {
        v30 = v28 * (v27 >> 11);
        *(_WORD *)(v128 + 2 * v4 + 408) = v28 + ((unsigned int)(2048 - v28) >> 5);
        v142 = (unsigned __int16 *)(v128 + 2 * (v129 + 16 * (v4 + 15)));
        v31 = *v142;
        if ( v30 < 0x1000000 )
        {
          v30 <<= 8;
          v5 = *v145++ | (v5 << 8);
        }
        v32 = v31 * (v30 >> 11);
        if ( v5 < v32 )
        {
          *v142 = v31 + ((unsigned int)(2048 - v31) >> 5);
          v7 = v31 * (v30 >> 11);
          ++v137;
          *(_BYTE *)(v138 + v121) = *(_BYTE *)(v138 + (v138 < v135 ? v127 : 0) - v135 + v121);
          v33 = v138 + 1;
          v136 = v4 < 7 ? 9 : 11;
LABEL_155:
          v138 = v33;
          goto LABEL_156;
        }
        v24 = v30 - v32;
        v5 -= v32;
        *v142 -= *v142 >> 5;
      }
      v25 = v4 < 7 ? 8 : 11;
      v26 = v128 + 2664;
    }
    else
    {
      v24 = v22 * (v21 >> 11);
      *(_WORD *)(v128 + 2 * v4 + 384) = v22 + ((unsigned int)(2048 - v22) >> 5);
      v25 = v4 + 12;
      v26 = v128 + 1636;
    }
    v43 = *(_WORD *)v26;
    v136 = v25;
    if ( v24 < 0x1000000 )
    {
      v24 <<= 8;
      v5 = *v145++ | (v5 << 8);
    }
    v44 = v43 * (v24 >> 11);
    if ( v5 >= v44 )
    {
      v46 = v24 - v44;
      v5 -= v44;
      *(_WORD *)v26 -= *(_WORD *)v26 >> 5;
      v47 = *(_WORD *)(v26 + 2);
      if ( v46 < 0x1000000 )
      {
        v46 <<= 8;
        v5 = *v145++ | (v5 << 8);
      }
      v48 = v47 * (v46 >> 11);
      if ( v5 >= v48 )
      {
        v7 = v46 - v48;
        v5 -= v48;
        *(_WORD *)(v26 + 2) -= *(_WORD *)(v26 + 2) >> 5;
        v45 = v26 + 516;
        v143 = 16;
        v131 = 256;
      }
      else
      {
        v7 = v47 * (v46 >> 11);
        *(_WORD *)(v26 + 2) = v47 + ((unsigned int)(2048 - v47) >> 5);
        v45 = v26 + 16 * v129 + 260;
        v143 = 8;
        v131 = 8;
      }
    }
    else
    {
      v7 = v43 * (v24 >> 11);
      *(_WORD *)v26 = v43 + ((unsigned int)(2048 - v43) >> 5);
      v45 = v26 + 16 * v129 + 4;
      v143 = 0;
      v131 = 8;
    }
    v125 = v45;
    v49 = 1;
    do
    {
      v50 = *(_WORD *)(v45 + 2 * v49);
      if ( v7 < 0x1000000 )
      {
        v7 <<= 8;
        v5 = *v145++ | (v5 << 8);
      }
      v51 = v50 * (v7 >> 11);
      if ( v5 >= v51 )
      {
        v7 -= v51;
        v5 -= v51;
        v45 = v125;
        *(_WORD *)(v125 + 2 * v49) = v50 - (v50 >> 5);
        v49 = 2 * v49 + 1;
      }
      else
      {
        v7 = v50 * (v7 >> 11);
        v45 = v125;
        *(_WORD *)(v125 + 2 * v49) = v50 + ((2048 - v50) >> 5);
        v49 *= 2;
      }
    }
    while ( v49 < v131 );
    v52 = v143 - v131 + v49;
    v126 = v52;
    if ( v25 >= 0xC )
      break;
LABEL_145:
    v33 = v138;
    v106 = v52 + 2;
    if ( a2 == v138 )
      return 1;
    v139 = a2 - v138;
    if ( v139 >= v106 )
      v139 = v106;
    v137 += v139;
    v107 = v33 + (v33 < v135 ? v127 : 0) - v135;
    v124 = v106 - v139;
    if ( v107 + v139 > v127 )
    {
      do
      {
        *(_BYTE *)(v33++ + v121) = *(_BYTE *)(v107++ + v121);
        if ( v107 == v127 )
          v107 = 0;
        --v139;
      }
      while ( v139 );
      goto LABEL_155;
    }
    v108 = (_BYTE *)(v33 + v121);
    v113 = v33 + v121 + v139;
    v138 = v139 + v33;
    do
    {
      *v108 = v108[(v33 < v135 ? v127 : 0) - v135];
      ++v108;
    }
    while ( v108 != (_BYTE *)v113 );
LABEL_156:
    if ( v138 >= a2 || (unsigned int)v145 >= a3 )
      goto LABEL_161;
    v6 = v111;
    v4 = v136;
    v3 = a1;
  }
  v53 = v52;
  if ( v52 >= 4 )
    v53 = 3;
  v54 = (v53 << 7) + v128 + 864;
  v55 = *(_WORD *)(v54 + 2);
  if ( v7 < 0x1000000 )
  {
    v7 <<= 8;
    v5 = *v145++ | (v5 << 8);
  }
  v56 = v55 * (v7 >> 11);
  if ( v5 >= v56 )
  {
    v57 = v7 - v56;
    v5 -= v56;
    *(_WORD *)(v54 + 2) -= *(_WORD *)(v54 + 2) >> 5;
    v58 = 3;
  }
  else
  {
    v57 = v55 * (v7 >> 11);
    *(_WORD *)(v54 + 2) = v55 + ((unsigned int)(2048 - v55) >> 5);
    v58 = 2;
  }
  v59 = 2 * v58;
  v60 = *(_WORD *)(2 * v58 + v54);
  if ( v57 < 0x1000000 )
  {
    v57 <<= 8;
    v5 = *v145++ | (v5 << 8);
  }
  v61 = v60 * (v57 >> 11);
  if ( v5 >= v61 )
  {
    v62 = v57 - v61;
    v5 -= v61;
    *(_WORD *)(v59++ + v54) = v60 - (v60 >> 5);
  }
  else
  {
    v62 = v60 * (v57 >> 11);
    *(_WORD *)(v59 + v54) = v60 + ((2048 - v60) >> 5);
  }
  v63 = 2 * v59;
  v64 = *(_WORD *)(v63 + v54);
  if ( v62 < 0x1000000 )
  {
    v62 <<= 8;
    v5 = *v145++ | (v5 << 8);
  }
  v65 = v64 * (v62 >> 11);
  if ( v5 >= v65 )
  {
    v66 = v62 - v65;
    v5 -= v65;
    *(_WORD *)(v63 + v54) -= *(_WORD *)(v63 + v54) >> 5;
    ++v63;
  }
  else
  {
    v66 = v64 * (v62 >> 11);
    *(_WORD *)(v63 + v54) = v64 + ((unsigned int)(2048 - v64) >> 5);
  }
  v67 = 2 * v63;
  v68 = *(_WORD *)(v67 + v54);
  if ( v66 < 0x1000000 )
  {
    v66 <<= 8;
    v5 = *v145++ | (v5 << 8);
  }
  v69 = v68 * (v66 >> 11);
  if ( v5 >= v69 )
  {
    v70 = v66 - v69;
    v5 -= v69;
    *(_WORD *)(v67 + v54) -= *(_WORD *)(v67 + v54) >> 5;
    ++v67;
  }
  else
  {
    v70 = v68 * (v66 >> 11);
    *(_WORD *)(v67 + v54) = v68 + ((unsigned int)(2048 - v68) >> 5);
  }
  v71 = 2 * v67;
  v72 = *(_WORD *)(v71 + v54);
  if ( v70 < 0x1000000 )
  {
    v70 <<= 8;
    v5 = *v145++ | (v5 << 8);
  }
  v73 = v72 * (v70 >> 11);
  if ( v5 >= v73 )
  {
    v74 = v70 - v73;
    v5 -= v73;
    *(_WORD *)(v71 + v54) -= *(_WORD *)(v71 + v54) >> 5;
    ++v71;
  }
  else
  {
    v74 = v72 * (v70 >> 11);
    *(_WORD *)(v71 + v54) = v72 + ((unsigned int)(2048 - v72) >> 5);
  }
  v75 = 2 * v71;
  v76 = *(_WORD *)(v75 + v54);
  if ( v74 < 0x1000000 )
  {
    v74 <<= 8;
    v5 = *v145++ | (v5 << 8);
  }
  v77 = v76 * (v74 >> 11);
  if ( v5 >= v77 )
  {
    v7 = v74 - v77;
    v5 -= v77;
    *(_WORD *)(v75 + v54) -= *(_WORD *)(v75 + v54) >> 5;
    ++v75;
  }
  else
  {
    v7 = v76 * (v74 >> 11);
    *(_WORD *)(v75 + v54) = v76 + ((unsigned int)(2048 - v76) >> 5);
  }
  v78 = v75 - 64;
  if ( v78 < 4 )
  {
LABEL_140:
    v104 = v123;
    v119 = v122;
    v123 = v135;
    v122 = v104;
    v135 = v78 + 1;
    if ( v118 )
      v105 = v78 < v118;
    else
      v105 = v78 < v137;
    if ( !v105 )
      return 1;
    v52 = v126;
    v136 = v136 < 0x13 ? 7 : 10;
    goto LABEL_145;
  }
  v79 = v78;
  v80 = 1;
  v81 = (v78 >> 1) - 1;
  v82 = v78 & 1 | 2;
  v116 = v81;
  if ( v79 < 0xE )
  {
    v78 = v82 << v81;
    v120 = 1;
    v83 = v128 + 2 * (v78 - v79) + 1374;
    v144 = v128 + 2 * (v78 - v79) + 1374;
    do
    {
      v84 = *(_WORD *)(v83 + 2 * v80);
      if ( v7 < 0x1000000 )
      {
        v7 <<= 8;
        v5 = *v145++ | (v5 << 8);
      }
      v85 = v84 * (v7 >> 11);
      if ( v5 >= v85 )
      {
        v7 -= v85;
        v5 -= v85;
        v83 = v144;
        v78 |= v120;
        *(_WORD *)(v144 + 2 * v80) = v84 - (v84 >> 5);
        v80 = 2 * v80 + 1;
      }
      else
      {
        v7 = v84 * (v7 >> 11);
        v83 = v144;
        *(_WORD *)(v144 + 2 * v80) = v84 + ((2048 - v84) >> 5);
        v80 *= 2;
      }
      v120 *= 2;
      --v116;
    }
    while ( v116 );
    goto LABEL_140;
  }
  v86 = v81 - 4;
  do
  {
    if ( v7 < 0x1000000 )
    {
      v7 <<= 8;
      v5 = *v145++ | (v5 << 8);
    }
    v7 >>= 1;
    v87 = v5 - v7;
    v82 = 2 * v82 - (v87 >> 31) + 1;
    v5 = (v7 & -(v87 >> 31)) + v87;
    --v86;
  }
  while ( v86 );
  v88 = *(_WORD *)(v128 + 1606);
  v78 = 16 * v82;
  if ( v7 < 0x1000000 )
  {
    v7 <<= 8;
    v5 = *v145++ | (v5 << 8);
  }
  v89 = v88 * (v7 >> 11);
  if ( v5 >= v89 )
  {
    v90 = v7 - v89;
    v5 -= v89;
    *(_WORD *)(v128 + 1606) -= *(_WORD *)(v128 + 1606) >> 5;
    v91 = 3;
    v78 |= 1u;
  }
  else
  {
    v90 = v88 * (v7 >> 11);
    *(_WORD *)(v128 + 1606) = v88 + ((unsigned int)(2048 - v88) >> 5);
    v91 = 2;
  }
  v132 = 2 * v91;
  v92 = *(_WORD *)(2 * v91 + v128 + 1604);
  if ( v90 < 0x1000000 )
  {
    v90 <<= 8;
    v5 = *v145++ | (v5 << 8);
  }
  v93 = v92 * (v90 >> 11);
  if ( v5 >= v93 )
  {
    v94 = v90 - v93;
    v5 -= v93;
    *(_WORD *)(v132 + v128 + 1604) = v92 - (v92 >> 5);
    v96 = v132 + 1;
    v78 |= 2u;
  }
  else
  {
    v94 = v92 * (v90 >> 11);
    v95 = v92 + ((2048 - v92) >> 5);
    v96 = v132;
    *(_WORD *)(v132 + v128 + 1604) = v95;
  }
  v133 = 2 * v96;
  v97 = *(_WORD *)(2 * v96 + v128 + 1604);
  if ( v94 < 0x1000000 )
  {
    v94 <<= 8;
    v5 = *v145++ | (v5 << 8);
  }
  v98 = v97 * (v94 >> 11);
  if ( v5 >= v98 )
  {
    v99 = v94 - v98;
    v5 -= v98;
    *(_WORD *)(v133 + v128 + 1604) = v97 - (v97 >> 5);
    v101 = v133 + 1;
    v78 |= 4u;
  }
  else
  {
    v99 = v97 * (v94 >> 11);
    v100 = v97 + ((2048 - v97) >> 5);
    v101 = v133;
    *(_WORD *)(v133 + v128 + 1604) = v100;
  }
  v134 = v101;
  v102 = *(_WORD *)(v128 + 2 * v101 + 1604);
  if ( v99 < 0x1000000 )
  {
    v99 <<= 8;
    v5 = *v145++ | (v5 << 8);
  }
  v103 = v102 * (v99 >> 11);
  if ( v5 >= v103 )
  {
    v7 = v99 - v103;
    v5 -= v103;
    *(_WORD *)(v128 + 2 * v134 + 1604) = v102 - (v102 >> 5);
    v78 |= 8u;
  }
  else
  {
    v7 = v102 * (v99 >> 11);
    *(_WORD *)(v128 + 2 * v134 + 1604) = v102 + ((2048 - v102) >> 5);
  }
  if ( v78 != -1 )
    goto LABEL_140;
  v124 = v126 + 274;
  v136 -= 12;
LABEL_161:
  v110 = (int)v145;
  if ( v7 < 0x1000000 )
  {
    v7 <<= 8;
    v5 = *v145 | (v5 << 8);
    v110 = (int)(v145 + 1);
  }
  *(_DWORD *)(a1 + 28) = v7;
  *(_DWORD *)(a1 + 24) = v110;
  *(_DWORD *)(a1 + 36) = v138;
  *(_DWORD *)(a1 + 72) = v124;
  *(_DWORD *)(a1 + 56) = v135;
  *(_DWORD *)(a1 + 44) = v137;
  *(_DWORD *)(a1 + 64) = v122;
  *(_DWORD *)(a1 + 32) = v5;
  *(_DWORD *)(a1 + 60) = v123;
  *(_DWORD *)(a1 + 52) = v136;
  *(_DWORD *)(a1 + 68) = v119;
  return 0;
}

//----- (10023A60) --------------------------------------------------------
void __userpurge sub_10023A60(int a1@<esi>, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@3
  unsigned int v4; // ecx@3
  int v5; // edi@3
  int v6; // [sp+4h] [bp-8h]@3
  unsigned int v7; // [sp+8h] [bp-4h]@3

  v2 = *(_DWORD *)(a1 + 72);
  if ( v2 && v2 < 0x112 )
  {
    v3 = *(_DWORD *)(a1 + 36);
    v7 = *(_DWORD *)(a1 + 56);
    v6 = *(_DWORD *)(a1 + 40);
    v4 = *(_DWORD *)(a1 + 72);
    v5 = *(_DWORD *)(a1 + 20);
    if ( a2 - v3 < v2 )
      v4 = a2 - v3;
    if ( !*(_DWORD *)(a1 + 48) && *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 44) <= v4 )
      *(_DWORD *)(a1 + 48) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 44) += v4;
    for ( *(_DWORD *)(a1 + 72) = v2 - v4; v4; --v4 )
    {
      *(_BYTE *)(v3 + v5) = *(_BYTE *)(v3 + (v3 < v7 ? v6 : 0) - v7 + v5);
      ++v3;
    }
    *(_DWORD *)(a1 + 36) = v3;
  }
}

//----- (10023AE0) --------------------------------------------------------
signed int __userpurge sub_10023AE0@<eax>(int a1@<eax>, unsigned int a2@<edi>, unsigned int a3)
{
  int v3; // esi@1
  unsigned int v4; // edx@2
  int v5; // ecx@3
  unsigned int v6; // eax@3
  signed int result; // eax@5
  unsigned int v8; // eax@6

  v3 = a1;
  while ( 1 )
  {
    v4 = a2;
    if ( !*(_DWORD *)(v3 + 48) )
    {
      v5 = *(_DWORD *)(v3 + 36);
      v6 = *(_DWORD *)(v3 + 12) - *(_DWORD *)(v3 + 44);
      if ( a2 - v5 > v6 )
        v4 = v5 + v6;
    }
    result = sub_10022E70(v3, v4, a3);
    if ( result )
      break;
    v8 = *(_DWORD *)(v3 + 12);
    if ( *(_DWORD *)(v3 + 44) >= v8 )
      *(_DWORD *)(v3 + 48) = v8;
    sub_10023A60(v3, a2);
    if ( *(_DWORD *)(v3 + 36) >= a2 || *(_DWORD *)(v3 + 24) >= a3 || *(_DWORD *)(v3 + 72) >= 0x112u )
    {
      if ( *(_DWORD *)(v3 + 72) > 0x112u )
        *(_DWORD *)(v3 + 72) = 274;
      return 0;
    }
  }
  return result;
}

//----- (10023B50) --------------------------------------------------------
signed int __usercall sub_10023B50@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3)
{
  int v3; // edi@1
  unsigned int v4; // edx@1
  unsigned int v5; // esi@1
  int v6; // ebx@1
  unsigned int v7; // eax@4
  unsigned int v8; // edx@5
  int v9; // ecx@7
  unsigned int v10; // ecx@11
  int v11; // edi@12
  unsigned int v12; // eax@15
  signed int result; // eax@19
  unsigned int v14; // ecx@20
  unsigned int v15; // ebx@20
  int v16; // eax@21
  int v17; // ecx@23
  unsigned int v18; // edi@23
  int v19; // ecx@24
  int v20; // eax@24
  unsigned int v21; // ecx@27
  unsigned int v22; // edx@32
  unsigned int v23; // esi@32
  int v24; // ecx@32
  unsigned int v25; // eax@35
  unsigned int v26; // edx@36
  _BYTE *v27; // eax@36
  int v28; // edi@36
  unsigned int v29; // edx@37
  int v30; // edi@40
  unsigned int v31; // ecx@40
  unsigned int v32; // edx@41
  unsigned int v33; // ecx@44
  unsigned int v34; // edx@48
  int v35; // edi@48
  unsigned int v36; // ecx@51
  int v37; // edi@53
  int v38; // eax@63
  unsigned int v39; // ecx@63
  int v40; // ebx@64
  unsigned int v41; // edx@65
  unsigned int v42; // ecx@68
  unsigned int v43; // edi@71
  int v44; // eax@75
  unsigned int v45; // ecx@75
  unsigned int v46; // edi@79
  int v47; // ebx@82
  _BYTE *v48; // eax@82
  unsigned int v49; // edi@82
  unsigned int v50; // ecx@86
  unsigned int v51; // edi@90
  int v52; // ebx@91
  int v53; // ebx@93
  int v54; // eax@99
  int v55; // ecx@100
  unsigned int v56; // edi@103
  int v57; // [sp+Ch] [bp-18h]@24
  signed int v58; // [sp+Ch] [bp-18h]@36
  signed int v59; // [sp+10h] [bp-14h]@64
  int v60; // [sp+10h] [bp-14h]@91
  int v61; // [sp+14h] [bp-10h]@1
  int v62; // [sp+14h] [bp-10h]@24
  unsigned int v63; // [sp+14h] [bp-10h]@64
  int v64; // [sp+14h] [bp-10h]@83
  int v65; // [sp+18h] [bp-Ch]@1
  int v66; // [sp+18h] [bp-Ch]@5
  unsigned int v67; // [sp+18h] [bp-Ch]@36
  int v68; // [sp+18h] [bp-Ch]@92
  int v69; // [sp+1Ch] [bp-8h]@1
  signed int v70; // [sp+1Ch] [bp-8h]@23
  unsigned int v71; // [sp+20h] [bp-4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 28);
  v5 = *(_DWORD *)(a2 + 32);
  v71 = (unsigned int)&a3[a1];
  v65 = *(_DWORD *)(a2 + 52);
  v69 = *(_DWORD *)(a2 + 16);
  v6 = *(_DWORD *)(v3 + 44) & ((1 << *(_DWORD *)(v3 + 8)) - 1);
  v61 = *(_WORD *)(v69 + 2 * (v6 + 16 * v65));
  if ( v4 < 0x1000000 )
  {
    if ( (unsigned int)a3 >= v71 )
      return 0;
    v4 <<= 8;
    v5 = *a3++ | (v5 << 8);
  }
  v7 = v61 * (v4 >> 11);
  if ( v5 < v7 )
  {
    v8 = v61 * (v4 >> 11);
    v66 = v69 + 3692;
    if ( *(_DWORD *)(a2 + 48) || *(_DWORD *)(a2 + 44) )
    {
      v9 = *(_DWORD *)(a2 + 36);
      if ( !v9 )
        v9 = *(_DWORD *)(v3 + 40);
      v66 += 1536
           * (((*(_DWORD *)(v3 + 44) & ((1 << *(_DWORD *)(v3 + 4)) - 1)) << *(_DWORD *)v3)
            + ((unsigned int)*(_BYTE *)(*(_DWORD *)(v3 + 20) + v9 - 1) >> (8 - *(_DWORD *)v3)));
    }
    if ( *(_DWORD *)(v3 + 52) >= 7u )
    {
      v14 = *(_DWORD *)(v3 + 36);
      v15 = *(_DWORD *)(v3 + 56);
      if ( v14 >= v15 )
        v16 = 0;
      else
        v16 = *(_DWORD *)(v3 + 40);
      v17 = *(_BYTE *)(v14 + *(_DWORD *)(v3 + 20) - v15 + v16);
      v70 = 256;
      v18 = 1;
      while ( 1 )
      {
        v19 = 2 * v17;
        v20 = v19 & v70;
        v57 = v19;
        v62 = *(_WORD *)(v66 + 2 * (v70 + (v19 & v70) + v18));
        if ( v8 < 0x1000000 )
        {
          if ( (unsigned int)a3 >= v71 )
            return 0;
          v8 <<= 8;
          v5 = *a3++ | (v5 << 8);
        }
        v21 = v62 * (v8 >> 11);
        if ( v5 >= v21 )
        {
          v8 -= v21;
          v5 -= v21;
          v18 = 2 * v18 + 1;
        }
        else
        {
          v8 = v62 * (v8 >> 11);
          v18 *= 2;
          v20 = ~v20;
        }
        v70 &= v20;
        if ( v18 >= 0x100 )
          break;
        v17 = v57;
      }
    }
    else
    {
      v10 = 1;
      do
      {
        v11 = *(_WORD *)(v66 + 2 * v10);
        if ( v8 < 0x1000000 )
        {
          if ( (unsigned int)a3 >= v71 )
            return 0;
          v8 <<= 8;
          v5 = *a3++ | (v5 << 8);
        }
        v12 = v11 * (v8 >> 11);
        if ( v5 >= v12 )
        {
          v8 -= v12;
          v5 -= v12;
          v10 = 2 * v10 + 1;
        }
        else
        {
          v8 = v11 * (v8 >> 11);
          v10 *= 2;
        }
      }
      while ( v10 < 0x100 );
    }
    result = 1;
    goto LABEL_108;
  }
  v22 = v4 - v7;
  v23 = v5 - v7;
  v24 = *(_WORD *)(v69 + 2 * v65 + 384);
  if ( v22 < 0x1000000 )
  {
    if ( (unsigned int)a3 >= v71 )
      return 0;
    v22 <<= 8;
    v23 = *a3++ | (v23 << 8);
  }
  v25 = v24 * (v22 >> 11);
  if ( v23 < v25 )
  {
    v26 = v24 * (v22 >> 11);
    v27 = a3;
    v67 = 0;
    v28 = v69 + 1636;
    v58 = 2;
    goto LABEL_60;
  }
  v29 = v22 - v25;
  v23 -= v25;
  v27 = a3;
  v58 = 3;
  if ( v29 < 0x1000000 )
  {
    if ( (unsigned int)a3 >= v71 )
      return 0;
    v29 <<= 8;
    v23 = *a3 | (v23 << 8);
    v27 = a3++ + 1;
  }
  v30 = *(_WORD *)(v69 + 2 * v65 + 408);
  v31 = v30 * (v29 >> 11);
  if ( v23 < v31 )
  {
    v27 = a3;
    v32 = v30 * (v29 >> 11);
    if ( v31 < 0x1000000 )
    {
      if ( (unsigned int)a3 >= v71 )
        return 0;
      v32 = v31 << 8;
      v23 = *a3 | (v23 << 8);
      v27 = a3++ + 1;
    }
    v33 = *(_WORD *)(v69 + 2 * (v6 + 16 * (v65 + 15))) * (v32 >> 11);
    if ( v23 < v33 )
    {
      if ( v33 >= 0x1000000 || (unsigned int)v27 < v71 )
        return 3;
      return 0;
    }
    goto LABEL_58;
  }
  v34 = v29 - v31;
  v23 -= v31;
  v35 = *(_WORD *)(v69 + 2 * v65 + 432);
  if ( v34 < 0x1000000 )
  {
    if ( (unsigned int)v27 >= v71 )
      return 0;
    v34 <<= 8;
    v23 = *v27++ | (v23 << 8);
    a3 = v27;
  }
  v36 = v35 * (v34 >> 11);
  if ( v23 >= v36 )
  {
    v32 = v34 - v36;
    v23 -= v36;
    v37 = *(_WORD *)(v69 + 2 * v65 + 456);
    if ( v32 < 0x1000000 )
    {
      if ( (unsigned int)v27 >= v71 )
        return 0;
      v32 <<= 8;
      v23 = *v27++ | (v23 << 8);
      a3 = v27;
    }
    v33 = v37 * (v32 >> 11);
    if ( v23 >= v33 )
    {
LABEL_58:
      v26 = v32 - v33;
      v23 -= v33;
      goto LABEL_59;
    }
    v26 = v37 * (v32 >> 11);
  }
  else
  {
    v26 = v35 * (v34 >> 11);
  }
LABEL_59:
  v67 = 12;
  v28 = v69 + 2664;
LABEL_60:
  if ( v26 < 0x1000000 )
  {
    if ( (unsigned int)v27 >= v71 )
      return 0;
    v26 <<= 8;
    v23 = *v27 | (v23 << 8);
    a3 = v27 + 1;
  }
  v38 = *(_WORD *)v28;
  v39 = v38 * (v26 >> 11);
  if ( v23 < v39 )
  {
    v8 = v38 * (v26 >> 11);
    v40 = v28 + 16 * v6 + 4;
    v59 = 0;
    v63 = 8;
    goto LABEL_71;
  }
  v41 = v26 - v39;
  v23 -= v39;
  if ( v41 < 0x1000000 )
  {
    if ( (unsigned int)a3 < v71 )
    {
      v41 <<= 8;
      v23 = *a3++ | (v23 << 8);
      goto LABEL_68;
    }
    return 0;
  }
LABEL_68:
  v42 = *(_WORD *)(v28 + 2) * (v41 >> 11);
  if ( v23 >= v42 )
  {
    v8 = v41 - v42;
    v23 -= v42;
    v40 = v28 + 516;
    v59 = 16;
    v63 = 256;
  }
  else
  {
    v8 = *(_WORD *)(v28 + 2) * (v41 >> 11);
    v40 = v28 + 16 * v6 + 260;
    v59 = 8;
    v63 = 8;
  }
LABEL_71:
  v43 = 1;
  do
  {
    if ( v8 < 0x1000000 )
    {
      if ( (unsigned int)a3 >= v71 )
        return 0;
      v8 <<= 8;
      v23 = *a3++ | (v23 << 8);
    }
    v44 = *(_WORD *)(v40 + 2 * v43);
    v45 = v44 * (v8 >> 11);
    if ( v23 >= v45 )
    {
      v8 -= v45;
      v23 -= v45;
      v43 = 2 * v43 + 1;
    }
    else
    {
      v8 = v44 * (v8 >> 11);
      v43 *= 2;
    }
  }
  while ( v43 < v63 );
  v46 = v59 - v63 + v43;
  if ( v67 < 4 )
  {
    if ( v46 >= 4 )
      v46 = 3;
    v47 = (v46 << 7) + v69 + 864;
    v48 = a3;
    v49 = 1;
    do
    {
      v64 = *(_WORD *)(v47 + 2 * v49);
      if ( v8 < 0x1000000 )
      {
        if ( (unsigned int)v48 >= v71 )
          return 0;
        v8 <<= 8;
        v23 = *v48++ | (v23 << 8);
      }
      v50 = v64 * (v8 >> 11);
      if ( v23 >= v50 )
      {
        v8 -= v50;
        v23 -= v50;
        v49 = 2 * v49 + 1;
      }
      else
      {
        v8 = v64 * (v8 >> 11);
        v49 *= 2;
      }
    }
    while ( v49 < 0x40 );
    v51 = v49 - 64;
    a3 = v48;
    if ( v51 >= 4 )
    {
      v52 = (v51 >> 1) - 1;
      v60 = (v51 >> 1) - 1;
      if ( v51 >= 0xE )
      {
        v53 = (v51 >> 1) - 5;
        do
        {
          if ( v8 < 0x1000000 )
          {
            if ( (unsigned int)v48 >= v71 )
              return 0;
            v8 <<= 8;
            v23 = *v48++ | (v23 << 8);
          }
          v8 >>= 1;
          v23 -= v8 & (((v23 - v8) >> 31) - 1);
          --v53;
        }
        while ( v53 );
        v52 = 4;
        a3 = v48;
        v68 = v69 + 1604;
        v60 = 4;
      }
      else
      {
        v68 = v69 + 2 * (((v51 & 1 | 2) << v52) - v51) + 1374;
      }
      v54 = 1;
      do
      {
        v55 = *(_WORD *)(v68 + 2 * v54);
        if ( v8 < 0x1000000 )
        {
          if ( (unsigned int)a3 >= v71 )
            return 0;
          v23 = *a3 | (v23 << 8);
          v52 = v60;
          v8 <<= 8;
          ++a3;
        }
        v56 = v55 * (v8 >> 11);
        if ( v23 >= v56 )
        {
          v8 -= v56;
          v23 -= v56;
          v54 = 2 * v54 + 1;
        }
        else
        {
          v8 = v55 * (v8 >> 11);
          v54 *= 2;
        }
        v60 = --v52;
      }
      while ( v52 );
    }
  }
  result = v58;
LABEL_108:
  if ( v8 < 0x1000000 && (unsigned int)a3 >= v71 )
    return 0;
  return result;
}

//----- (10024130) --------------------------------------------------------
int __usercall sub_10024130@<eax>(int a1@<eax>, int a2, void *a3, int a4, int a5)
{
  _DWORD *v5; // ebx@1
  unsigned int v6; // edi@1
  int v7; // esi@1
  bool v8; // zf@1
  unsigned int v9; // ecx@4
  int v10; // ecx@12
  unsigned int v11; // ecx@13
  void *v12; // edi@13
  unsigned __int8 v13; // cf@13
  char *v14; // edi@13
  int i; // ecx@13
  unsigned int v16; // eax@18
  char *v17; // ebx@20
  char *v18; // eax@20
  int v19; // eax@24
  unsigned int v20; // ebx@25
  unsigned int v21; // edi@25
  int result; // eax@37
  int v23; // esi@43
  unsigned int v24; // [sp+Ch] [bp-8h]@25
  unsigned int v25; // [sp+10h] [bp-4h]@1

  v5 = (_DWORD *)a4;
  v6 = *(_DWORD *)a4;
  v7 = a1;
  v25 = *(_DWORD *)a4;
  *(_DWORD *)a4 = 0;
  sub_10023A60(a1, a2);
  v8 = *(_DWORD *)(v7 + 72) == 274;
  *(_DWORD *)a5 = 0;
  if ( v8 )
  {
LABEL_43:
    v23 = *(_DWORD *)(v7 + 32);
    if ( !v23 )
      *(_DWORD *)a5 = 1;
    result = v23 != 0;
  }
  else
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(v7 + 76) )
      {
        if ( v6 )
        {
          do
          {
            v9 = *(_DWORD *)(v7 + 88);
            if ( v9 >= 5 )
              break;
            *(_BYTE *)(v9 + v7 + 92) = *(_BYTE *)a3;
            ++*(_DWORD *)(v7 + 88);
            ++*v5;
            --v6;
            a3 = (char *)a3 + 1;
          }
          while ( v6 );
          v25 = v6;
        }
        if ( *(_DWORD *)(v7 + 88) < 5u )
          goto LABEL_42;
        if ( *(_BYTE *)(v7 + 92) )
          return 1;
        *(_DWORD *)(v7 + 32) = *(_BYTE *)(v7 + 96) | ((*(_BYTE *)(v7 + 95) | ((*(_BYTE *)(v7 + 94) | (*(_BYTE *)(v7 + 93) << 8)) << 8)) << 8);
        *(_DWORD *)(v7 + 28) = -1;
        *(_DWORD *)(v7 + 76) = 0;
        *(_DWORD *)(v7 + 88) = 0;
      }
      if ( *(_DWORD *)(v7 + 36) >= (unsigned int)a2 )
        break;
      if ( *(_DWORD *)(v7 + 80) )
      {
        v10 = *(_DWORD *)v7 + *(_DWORD *)(v7 + 4);
        if ( 768 << v10 != -1846 )
        {
          v5 = (_DWORD *)a4;
          v11 = (768 << v10) + 1846;
          v12 = *(void **)(v7 + 16);
          v13 = v11 & 1;
          v11 >>= 1;
          memset32(v12, 67109888, v11);
          v14 = (char *)v12 + 4 * v11;
          for ( i = v13; i; --i )
          {
            *(_WORD *)v14 = 1024;
            v14 += 2;
          }
          v6 = v25;
        }
        *(_DWORD *)(v7 + 68) = 1;
        *(_DWORD *)(v7 + 64) = 1;
        *(_DWORD *)(v7 + 60) = 1;
        *(_DWORD *)(v7 + 56) = 1;
        *(_DWORD *)(v7 + 52) = 0;
        *(_DWORD *)(v7 + 80) = 0;
      }
      v16 = *(_DWORD *)(v7 + 88);
      if ( v16 )
      {
        v20 = *(_DWORD *)(v7 + 88);
        v21 = 0;
        v24 = 0;
        if ( v16 < 0x14 )
        {
          do
          {
            if ( v21 >= v25 )
              break;
            *(_BYTE *)(v7 + v20++ + 92) = *((_BYTE *)a3 + v21++);
          }
          while ( v20 < 0x14 );
          v24 = v21;
        }
        *(_DWORD *)(v7 + 88) = v20;
        if ( v20 < 0x14 && !sub_10023B50(v20, v7, (_BYTE *)(v7 + 92)) )
        {
          *(_DWORD *)a4 += v21;
LABEL_42:
          *(_DWORD *)a5 = 3;
          return 0;
        }
        *(_DWORD *)(v7 + 24) = v7 + 92;
        if ( sub_10023AE0(v7, a2, v7 + 92) )
          return 1;
        v19 = v24 + *(_DWORD *)(v7 + 24) - v20 - v7 - 92;
        *(_DWORD *)a4 += v19;
        a3 = (char *)a3 + v19;
        *(_DWORD *)(v7 + 88) = 0;
      }
      else
      {
        if ( v6 < 0x14 )
        {
          if ( !sub_10023B50(v6, v7, a3) )
          {
            memcpy((void *)(v7 + 92), a3, v6);
            *(_DWORD *)(v7 + 88) = v6;
            *v5 += v6;
            *(_DWORD *)a5 = 3;
            return 0;
          }
          v18 = (char *)a3;
          v17 = (char *)a3;
        }
        else
        {
          v17 = (char *)a3;
          v18 = (char *)a3 + v6 - 20;
        }
        *(_DWORD *)(v7 + 24) = v17;
        if ( sub_10023AE0(v7, a2, (unsigned int)v18) )
          return 1;
        v19 = *(_DWORD *)(v7 + 24) - (_DWORD)v17;
        *(_DWORD *)a4 += v19;
        a3 = &v17[v19];
      }
      v25 -= v19;
      if ( *(_DWORD *)(v7 + 72) == 274 )
        goto LABEL_43;
      v5 = (_DWORD *)a4;
      v6 = v25;
    }
    if ( *(_DWORD *)(v7 + 72) || *(_DWORD *)(v7 + 32) )
    {
      *(_DWORD *)a5 = 2;
      result = 0;
    }
    else
    {
      *(_DWORD *)a5 = 4;
      result = 0;
    }
  }
  return result;
}

//----- (100243E0) --------------------------------------------------------
int __usercall sub_100243E0@<eax>(int a1@<eax>, void *a2, int a3, void *a4, int a5, int a6)
{
  int v6; // esi@1
  unsigned int v7; // edi@1
  unsigned int v8; // ecx@2
  int v9; // eax@4
  char *v10; // edi@7
  unsigned int v11; // ebx@7
  bool v12; // zf@7
  _DWORD *v13; // ecx@7
  unsigned int v14; // eax@10
  int v15; // ecx@18
  unsigned int v16; // ecx@19
  void *v17; // edi@19
  unsigned __int8 v18; // cf@19
  char *v19; // edi@19
  int i; // ecx@19
  unsigned int v21; // ebx@26
  int v22; // eax@30
  unsigned int v23; // ebx@31
  unsigned int v24; // eax@31
  signed int v25; // edi@43
  int v26; // eax@49
  size_t v27; // ebx@52
  int v29; // [sp+Ch] [bp-20h]@4
  size_t v30; // [sp+10h] [bp-1Ch]@1
  unsigned int v31; // [sp+14h] [bp-18h]@1
  unsigned int v32; // [sp+18h] [bp-14h]@31
  unsigned int v33; // [sp+1Ch] [bp-10h]@5
  char *v34; // [sp+20h] [bp-Ch]@7
  unsigned int v35; // [sp+24h] [bp-8h]@7
  int v36; // [sp+28h] [bp-4h]@7

  v6 = a1;
  v7 = *(_DWORD *)a3;
  v30 = *(_DWORD *)a5;
  v31 = *(_DWORD *)a3;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)a5 = 0;
  while ( 1 )
  {
    v8 = *(_DWORD *)(v6 + 40);
    if ( *(_DWORD *)(v6 + 36) == v8 )
      *(_DWORD *)(v6 + 36) = 0;
    v9 = *(_DWORD *)(v6 + 36);
    v29 = *(_DWORD *)(v6 + 36);
    if ( v7 <= v8 - v9 )
      v33 = v7 + v9;
    else
      v33 = v8;
    v10 = (char *)a4;
    v11 = v30;
    v34 = (char *)a4;
    v35 = v30;
    v36 = 0;
    sub_10023A60(v6, v33);
    v12 = *(_DWORD *)(v6 + 72) == 274;
    v13 = (_DWORD *)a6;
    *(_DWORD *)a6 = 0;
    if ( v12 )
    {
LABEL_49:
      v26 = *(_DWORD *)(v6 + 32);
      if ( !v26 )
        *v13 = 1;
      v25 = v26 != 0;
    }
    else
    {
      while ( 1 )
      {
        if ( *(_DWORD *)(v6 + 76) )
        {
          if ( v11 )
          {
            do
            {
              v14 = *(_DWORD *)(v6 + 88);
              if ( v14 >= 5 )
                break;
              *(_BYTE *)(v14 + v6 + 92) = *v10;
              ++*(_DWORD *)(v6 + 88);
              ++v36;
              ++v10;
              --v11;
            }
            while ( v11 );
            v34 = v10;
            v35 = v11;
          }
          if ( *(_DWORD *)(v6 + 88) < 5u )
            goto LABEL_48;
          if ( *(_BYTE *)(v6 + 92) )
            goto LABEL_44;
          *(_DWORD *)(v6 + 32) = *(_BYTE *)(v6 + 96) | ((*(_BYTE *)(v6 + 95) | ((*(_BYTE *)(v6 + 94) | (*(_BYTE *)(v6 + 93) << 8)) << 8)) << 8);
          *(_DWORD *)(v6 + 28) = -1;
          *(_DWORD *)(v6 + 76) = 0;
          *(_DWORD *)(v6 + 88) = 0;
        }
        if ( *(_DWORD *)(v6 + 36) >= v33 )
          break;
        if ( *(_DWORD *)(v6 + 80) )
        {
          v15 = *(_DWORD *)v6 + *(_DWORD *)(v6 + 4);
          if ( 768 << v15 != -1846 )
          {
            v11 = v35;
            v16 = (768 << v15) + 1846;
            v17 = *(void **)(v6 + 16);
            v18 = v16 & 1;
            v16 >>= 1;
            memset32(v17, 67109888, v16);
            v19 = (char *)v17 + 4 * v16;
            for ( i = v18; i; --i )
            {
              *(_WORD *)v19 = 1024;
              v19 += 2;
            }
            v10 = v34;
          }
          *(_DWORD *)(v6 + 68) = 1;
          *(_DWORD *)(v6 + 64) = 1;
          *(_DWORD *)(v6 + 60) = 1;
          *(_DWORD *)(v6 + 56) = 1;
          *(_DWORD *)(v6 + 52) = 0;
          *(_DWORD *)(v6 + 80) = 0;
        }
        if ( *(_DWORD *)(v6 + 88) )
        {
          v23 = *(_DWORD *)(v6 + 88);
          v24 = 0;
          v32 = 0;
          if ( v23 < 0x14 )
          {
            do
            {
              if ( v24 >= v35 )
                break;
              *(_BYTE *)(v6 + v23++ + 92) = v10[v24++];
            }
            while ( v23 < 0x14 );
            v32 = v24;
          }
          *(_DWORD *)(v6 + 88) = v23;
          if ( v23 < 0x14 && !sub_10023B50(v23, v6, (_BYTE *)(v6 + 92)) )
          {
            v36 += v32;
            v13 = (_DWORD *)a6;
LABEL_48:
            *v13 = 3;
            v25 = 0;
            goto LABEL_52;
          }
          *(_DWORD *)(v6 + 24) = v6 + 92;
          if ( sub_10023AE0(v6, v33, v6 + 92) )
          {
LABEL_44:
            v25 = 1;
            goto LABEL_52;
          }
          v22 = v32 + *(_DWORD *)(v6 + 24) - v23 - v6 - 92;
          v34 += v22;
          *(_DWORD *)(v6 + 88) = 0;
        }
        else
        {
          if ( v11 < 0x14 )
          {
            if ( !sub_10023B50(v11, v6, v10) )
            {
              memcpy((void *)(v6 + 92), v10, v11);
              v36 += v11;
              *(_DWORD *)(v6 + 88) = v11;
              *(_DWORD *)a6 = 3;
              v25 = 0;
              goto LABEL_52;
            }
            v21 = (unsigned int)v10;
          }
          else
          {
            v21 = (unsigned int)&v10[v11 - 20];
          }
          *(_DWORD *)(v6 + 24) = v10;
          if ( sub_10023AE0(v6, v33, v21) )
            goto LABEL_44;
          v22 = *(_DWORD *)(v6 + 24) - (_DWORD)v34;
          v34 = *(char **)(v6 + 24);
        }
        v36 += v22;
        v35 -= v22;
        v13 = (_DWORD *)a6;
        if ( *(_DWORD *)(v6 + 72) == 274 )
          goto LABEL_49;
        v10 = v34;
        v11 = v35;
      }
      if ( *(_DWORD *)(v6 + 72) || *(_DWORD *)(v6 + 32) )
      {
        *v13 = 2;
        v25 = 0;
      }
      else
      {
        *v13 = 4;
        v25 = 0;
      }
    }
LABEL_52:
    *(_DWORD *)a5 += v36;
    a4 = (char *)a4 + v36;
    v30 -= v36;
    v27 = *(_DWORD *)(v6 + 36) - v29;
    memcpy(a2, (const void *)(v29 + *(_DWORD *)(v6 + 20)), v27);
    a2 = (char *)a2 + v27;
    v31 -= v27;
    *(_DWORD *)a3 += v27;
    if ( v25 )
      return v25;
    if ( !v27 || !v31 )
      return 0;
    v7 = v31;
  }
}

//----- (100246F0) --------------------------------------------------------
int __usercall sub_100246F0@<eax>(int a1@<esi>)
{
  int v1; // ST04_4@1
  int result; // eax@1

  off_100ADF98(&off_100ADF94, *(_DWORD *)(a1 + 16));
  v1 = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 16) = 0;
  result = off_100ADF98(&off_100ADF94, v1);
  *(_DWORD *)(a1 + 20) = 0;
  return result;
}
// 100ADF94: using guessed type int (__cdecl *off_100ADF94)(int, size_t);
// 100ADF98: using guessed type int (__cdecl *off_100ADF98)(_DWORD, _DWORD);

//----- (10024720) --------------------------------------------------------
signed int __fastcall sub_10024720(int a1, int a2)
{
  unsigned int v2; // eax@1
  unsigned __int8 v3; // dl@3
  signed int result; // eax@4
  signed __int64 v5; // rax@5
  signed __int64 v6; // rax@5

  v2 = *(_BYTE *)(a2 + 1) | ((*(_BYTE *)(a2 + 2) | ((*(_BYTE *)(a2 + 3) | (*(_BYTE *)(a2 + 4) << 8)) << 8)) << 8);
  if ( v2 < 0x1000 )
    v2 = 4096;
  v3 = *(_BYTE *)a2;
  *(_DWORD *)(a1 + 12) = v2;
  if ( v3 < 0xE1u )
  {
    v5 = v3;
    *(_DWORD *)a1 = v5 % 9;
    v6 = (unsigned __int8)(v5 / 9);
    *(_DWORD *)(a1 + 8) = v6 / 5;
    *(_DWORD *)(a1 + 4) = v6 % 5;
    result = 0;
  }
  else
  {
    result = 4;
  }
  return result;
}

//----- (10024780) --------------------------------------------------------
signed int __usercall sub_10024780@<eax>(int a1@<edx>, int a2@<edi>)
{
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  int v5; // eax@4
  int v6; // edx@6
  int v7; // eax@6
  int v8; // ecx@6
  int v9; // [sp+8h] [bp-10h]@1
  int v10; // [sp+Ch] [bp-Ch]@2
  int v11; // [sp+10h] [bp-8h]@6
  int v12; // [sp+14h] [bp-4h]@6

  result = sub_10024720((int)&v9, a1);
  if ( !result )
  {
    v3 = v9;
    v4 = (768 << (v9 + v10)) + 1846;
    if ( *(_DWORD *)(a2 + 16) && v4 == *(_DWORD *)(a2 + 84)
      || (off_100ADF90(&off_100ADF8C, *(_DWORD *)(a2 + 16)),
          *(_DWORD *)(a2 + 16) = 0,
          v5 = off_100ADF8C(&off_100ADF8C, 2 * v4),
          *(_DWORD *)(a2 + 16) = v5,
          *(_DWORD *)(a2 + 84) = v4,
          v5) )
    {
      v6 = v10;
      v7 = v11;
      v8 = v12;
      *(_DWORD *)a2 = v3;
      *(_DWORD *)(a2 + 4) = v6;
      *(_DWORD *)(a2 + 8) = v7;
      *(_DWORD *)(a2 + 12) = v8;
      result = 0;
    }
    else
    {
      result = 2;
    }
  }
  return result;
}
// 100ADF8C: using guessed type int (__cdecl *off_100ADF8C)(_DWORD, _DWORD);
// 100ADF90: using guessed type int (__cdecl *off_100ADF90)(_DWORD, _DWORD);

//----- (10024810) --------------------------------------------------------
signed int __usercall sub_10024810@<eax>(int a1@<edx>, int a2@<esi>)
{
  signed int result; // eax@1
  int v3; // edi@2
  int v4; // eax@4
  size_t v5; // edi@5
  int v6; // eax@7
  int v7; // edx@10
  int v8; // eax@10
  int v9; // [sp+8h] [bp-10h]@1
  int v10; // [sp+Ch] [bp-Ch]@2
  int v11; // [sp+10h] [bp-8h]@10
  size_t v12; // [sp+14h] [bp-4h]@5

  result = sub_10024720((int)&v9, a1);
  if ( !result )
  {
    v3 = (768 << (v10 + v9)) + 1846;
    if ( !*(_DWORD *)(a2 + 16) || v3 != *(_DWORD *)(a2 + 84) )
    {
      off_100ADF98(&off_100ADF94, *(_DWORD *)(a2 + 16));
      *(_DWORD *)(a2 + 16) = 0;
      v4 = off_100ADF94((int)&off_100ADF94, 2 * v3);
      *(_DWORD *)(a2 + 16) = v4;
      *(_DWORD *)(a2 + 84) = v3;
      if ( !v4 )
        return 2;
    }
    v5 = v12;
    if ( !*(_DWORD *)(a2 + 20) || v12 != *(_DWORD *)(a2 + 40) )
    {
      off_100ADF98(&off_100ADF94, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a2 + 20) = 0;
      v6 = off_100ADF94((int)&off_100ADF94, v5);
      *(_DWORD *)(a2 + 20) = v6;
      if ( !v6 )
      {
        off_100ADF98(&off_100ADF94, *(_DWORD *)(a2 + 16));
        *(_DWORD *)(a2 + 16) = 0;
        return 2;
      }
    }
    v7 = v10;
    v8 = v11;
    *(_DWORD *)a2 = v9;
    *(_DWORD *)(a2 + 4) = v7;
    *(_DWORD *)(a2 + 8) = v8;
    *(_DWORD *)(a2 + 40) = v5;
    *(_DWORD *)(a2 + 12) = v5;
    result = 0;
  }
  return result;
}
// 100ADF94: using guessed type int (__cdecl *off_100ADF94)(int, size_t);
// 100ADF98: using guessed type int (__cdecl *off_100ADF98)(_DWORD, _DWORD);

//----- (100248F0) --------------------------------------------------------
signed int __usercall sub_100248F0@<eax>(_DWORD *a1@<edx>, void *a2@<ecx>, int *a3@<ebx>, int a4, unsigned int *a5, int a6)
{
  unsigned int v6; // eax@1
  signed int result; // eax@2
  int v8; // esi@4
  void *v9; // ST0C_4@7
  unsigned int v10; // [sp+10h] [bp-8Ch]@1
  void *v11; // [sp+14h] [bp-88h]@1
  int v12; // [sp+18h] [bp-84h]@1
  _DWORD *v13; // [sp+1Ch] [bp-80h]@1
  char v14; // [sp+20h] [bp-7Ch]@3
  void *v15; // [sp+30h] [bp-6Ch]@3
  int v16; // [sp+34h] [bp-68h]@3
  int v17; // [sp+44h] [bp-58h]@4
  int v18; // [sp+48h] [bp-54h]@4
  int v19; // [sp+4Ch] [bp-50h]@4
  int v20; // [sp+50h] [bp-4Ch]@4
  int v21; // [sp+68h] [bp-34h]@4
  int v22; // [sp+6Ch] [bp-30h]@4
  int v23; // [sp+70h] [bp-2Ch]@4
  int v24; // [sp+78h] [bp-24h]@4

  v11 = a2;
  v6 = *a5;
  v12 = *a3;
  *a3 = 0;
  v13 = a1;
  v10 = v6;
  *a5 = 0;
  if ( v6 >= 5 )
  {
    v16 = 0;
    v15 = 0;
    result = sub_10024780(a6, (int)&v14);
    if ( !result )
    {
      v16 = a4;
      v22 = 1;
      v23 = 1;
      *a5 = v10;
      v18 = v12;
      v17 = 0;
      v21 = 0;
      v24 = 0;
      v19 = 0;
      v20 = 0;
      v8 = sub_10024130((int)&v14, v12, v11, (int)a5, (int)v13);
      if ( !v8 && *v13 == 3 )
        v8 = 6;
      v9 = v15;
      *a3 = v17;
      off_100ADF90(&off_100ADF8C, v9);
      result = v8;
    }
  }
  else
  {
    result = 6;
  }
  return result;
}
// 100ADF8C: using guessed type int (__cdecl *off_100ADF8C)(_DWORD, _DWORD);
// 100ADF90: using guessed type int (__cdecl *off_100ADF90)(_DWORD, _DWORD);

//----- (100249F0) --------------------------------------------------------
int __usercall sub_100249F0@<eax>(int result@<eax>)
{
  signed int v1; // esi@1
  bool v2; // zf@3
  signed int v3; // edx@5
  unsigned int v4; // edx@9
  signed int v5; // ecx@9
  signed int v6; // edx@14
  signed int v7; // ecx@35

  v1 = *(_DWORD *)result;
  if ( *(_DWORD *)result < 0 )
    v1 = 5;
  v2 = *(_DWORD *)(result + 4) == 0;
  *(_DWORD *)result = v1;
  if ( v2 )
  {
    if ( v1 > 5 )
      v3 = v1 != 6 ? 0x4000000 : 0x2000000;
    else
      v3 = 1 << (2 * v1 + 14);
    *(_DWORD *)(result + 4) = v3;
  }
  if ( (unsigned __int64)*(_DWORD *)(result + 4) > *(_QWORD *)(result + 8) )
  {
    v4 = *(_DWORD *)(result + 8);
    v5 = 11;
    while ( 1 )
    {
      if ( v4 <= 2 << v5 )
      {
        v6 = 2;
        goto LABEL_16;
      }
      if ( v4 <= 3 << v5 )
        break;
      if ( (unsigned int)++v5 > 0x1E )
        goto LABEL_17;
    }
    v6 = 3;
LABEL_16:
    *(_DWORD *)(result + 4) = v6 << v5;
  }
LABEL_17:
  if ( *(_DWORD *)(result + 16) < 0 )
    *(_DWORD *)(result + 16) = 3;
  if ( *(_DWORD *)(result + 20) < 0 )
    *(_DWORD *)(result + 20) = 0;
  if ( *(_DWORD *)(result + 24) < 0 )
    *(_DWORD *)(result + 24) = 2;
  if ( *(_DWORD *)(result + 28) < 0 )
    *(_DWORD *)(result + 28) = v1 >= 5;
  if ( *(_DWORD *)(result + 32) < 0 )
    *(_DWORD *)(result + 32) = v1 >= 7 ? 64 : 32;
  if ( *(_DWORD *)(result + 36) < 0 )
    *(_DWORD *)(result + 36) = *(_DWORD *)(result + 28) != 0;
  if ( *(_DWORD *)(result + 40) < 0 )
    *(_DWORD *)(result + 40) = 4;
  if ( !*(_DWORD *)(result + 44) )
    *(_DWORD *)(result + 44) = ((*(_DWORD *)(result + 32) >> 1) + 16) >> (*(_DWORD *)(result + 36) == 0);
  if ( *(_DWORD *)(result + 52) < 0 )
  {
    if ( !*(_DWORD *)(result + 36) || (v7 = 2, !*(_DWORD *)(result + 28)) )
      v7 = 1;
    *(_DWORD *)(result + 52) = v7;
  }
  return result;
}

//----- (10024B20) --------------------------------------------------------
_WORD *__usercall sub_10024B20@<eax>(_WORD *result@<eax>)
{
  char *v1; // ebx@1
  unsigned int v2; // edi@1
  int v3; // ecx@2
  signed int v4; // esi@2

  *result = 256;
  v1 = (char *)(result + 1);
  v2 = 2;
  do
  {
    v3 = (v2 >> 1) - 1;
    v4 = 1 << v3;
    if ( 1 << v3 )
      result = memset(v1, v2, 1 << v3);
    ++v2;
    v1 += v4;
  }
  while ( v2 < 0x16 );
  return result;
}

//----- (10024B60) --------------------------------------------------------
signed int __usercall sub_10024B60@<eax>(const void *a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  int v3; // edx@2
  int v4; // ecx@3
  signed int v5; // eax@6
  bool v6; // zf@10
  int v7; // eax@10
  signed int v8; // ecx@10
  int v9; // eax@15
  int v10; // edx@15
  bool v11; // sf@15
  unsigned __int8 v12; // of@15
  signed int result; // eax@15
  char v14; // [sp+8h] [bp-38h]@1
  unsigned int v15; // [sp+Ch] [bp-34h]@4
  int v16; // [sp+18h] [bp-28h]@1
  int v17; // [sp+1Ch] [bp-24h]@2
  int v18; // [sp+20h] [bp-20h]@3
  int v19; // [sp+24h] [bp-1Ch]@10
  unsigned int v20; // [sp+28h] [bp-18h]@6
  int v21; // [sp+2Ch] [bp-14h]@10
  int v22; // [sp+30h] [bp-10h]@11
  int v23; // [sp+34h] [bp-Ch]@15
  int v24; // [sp+38h] [bp-8h]@15
  int v25; // [sp+3Ch] [bp-4h]@15

  qmemcpy(&v14, a1, 0x38u);
  sub_100249F0((int)&v14);
  v2 = v16;
  if ( v16 > 8 || (v3 = v17, v17 > 4) || (v4 = v18, v18 > 4) || v15 > 0x8000000 || v15 > 0x60000000 )
  {
    result = 5;
  }
  else
  {
    *(_DWORD *)(a2 + 140) = v15;
    v5 = v20;
    if ( v20 >= 5 )
    {
      if ( v20 > 0x111 )
        v5 = 273;
    }
    else
    {
      v5 = 5;
    }
    *(_DWORD *)(a2 + 44) = v5;
    v6 = v19 == 0;
    *(_DWORD *)(a2 + 80) = v4;
    *(_DWORD *)(a2 + 72) = v2;
    *(_DWORD *)(a2 + 76) = v3;
    *(_DWORD *)(a2 + 100) = v6;
    v7 = v21;
    *(_BYTE *)(a2 + 621) = v21 != 0;
    v8 = 4;
    if ( v7 )
    {
      if ( v22 >= 2 )
      {
        if ( v22 < 4 )
          v8 = v22;
      }
      else
      {
        v8 = 2;
      }
    }
    v9 = v24;
    v10 = v23;
    *(_DWORD *)(a2 + 664) = v8;
    v12 = __OFSUB__(v25, 1);
    v6 = v25 == 1;
    v11 = v25 - 1 < 0;
    *(_DWORD *)(a2 + 104) = v9;
    *(_DWORD *)(a2 + 640) = v10;
    result = 0;
    *(_DWORD *)(a2 + 112) = !((unsigned __int8)(v11 ^ v12) | v6);
  }
  return result;
}

//----- (10024C60) --------------------------------------------------------
int __usercall sub_10024C60@<eax>(int a1@<esi>)
{
  unsigned int v1; // edi@1
  char v2; // bl@3
  _BYTE *v3; // edi@4
  int v4; // edi@4
  int v5; // edi@6
  unsigned __int8 v6; // cf@8
  int result; // eax@11

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 < 0xFF000000 || *(_QWORD *)(a1 + 8) >> 32 )
  {
    v2 = *(_BYTE *)(a1 + 4);
    do
    {
      v3 = *(_BYTE **)(a1 + 24);
      *v3 = v2 + (*(_QWORD *)(a1 + 8) >> 32);
      v4 = (int)(v3 + 1);
      *(_DWORD *)(a1 + 24) = v4;
      if ( v4 == *(_DWORD *)(a1 + 28) && !*(_DWORD *)(a1 + 48) )
      {
        v5 = v4 - *(_DWORD *)(a1 + 32);
        if ( v5 != (**(int (__cdecl ***)(_DWORD, _DWORD, _DWORD))(a1 + 36))(
                     *(_DWORD *)(a1 + 36),
                     *(_DWORD *)(a1 + 32),
                     v5) )
          *(_DWORD *)(a1 + 48) = 9;
        v6 = __CFADD__(v5, *(_DWORD *)(a1 + 40));
        *(_DWORD *)(a1 + 40) += v5;
        *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 32);
        *(_DWORD *)(a1 + 44) += v6;
      }
      v2 = -1;
      v6 = __CFADD__((*(_DWORD *)(a1 + 16))--, -1);
      *(_DWORD *)(a1 + 20) = v6 + *(_DWORD *)(a1 + 20) - 1;
    }
    while ( *(_QWORD *)(a1 + 16) );
    v1 = *(_DWORD *)(a1 + 8);
    *(_BYTE *)(a1 + 4) = *(_DWORD *)(a1 + 8) >> 24;
  }
  v6 = __CFADD__((*(_DWORD *)(a1 + 16))++, 1);
  result = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 8) = v1 << 8;
  return result;
}

//----- (10024D10) --------------------------------------------------------
int __usercall sub_10024D10@<eax>(int a1@<esi>)
{
  unsigned int v1; // edi@2
  char v2; // bl@4
  _BYTE *v3; // edi@5
  int v4; // edi@5
  int v5; // edi@7
  unsigned __int8 v6; // cf@9
  int result; // eax@12
  bool v8; // zf@12
  signed int v9; // [sp+8h] [bp-4h]@1

  v9 = 5;
  do
  {
    v1 = *(_DWORD *)(a1 + 8);
    if ( v1 < 0xFF000000 || *(_QWORD *)(a1 + 8) >> 32 )
    {
      v2 = *(_BYTE *)(a1 + 4);
      do
      {
        v3 = *(_BYTE **)(a1 + 24);
        *v3 = v2 + (*(_QWORD *)(a1 + 8) >> 32);
        v4 = (int)(v3 + 1);
        *(_DWORD *)(a1 + 24) = v4;
        if ( v4 == *(_DWORD *)(a1 + 28) && !*(_DWORD *)(a1 + 48) )
        {
          v5 = v4 - *(_DWORD *)(a1 + 32);
          if ( v5 != (**(int (__cdecl ***)(_DWORD, _DWORD, _DWORD))(a1 + 36))(
                       *(_DWORD *)(a1 + 36),
                       *(_DWORD *)(a1 + 32),
                       v5) )
            *(_DWORD *)(a1 + 48) = 9;
          v6 = __CFADD__(v5, *(_DWORD *)(a1 + 40));
          *(_DWORD *)(a1 + 40) += v5;
          *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 32);
          *(_DWORD *)(a1 + 44) += v6;
        }
        v2 = -1;
        v6 = __CFADD__((*(_DWORD *)(a1 + 16))--, -1);
        *(_DWORD *)(a1 + 20) = v6 + *(_DWORD *)(a1 + 20) - 1;
      }
      while ( *(_QWORD *)(a1 + 16) );
      v1 = *(_DWORD *)(a1 + 8);
      *(_BYTE *)(a1 + 4) = *(_DWORD *)(a1 + 8) >> 24;
    }
    v6 = __CFADD__((*(_DWORD *)(a1 + 16))++, 1);
    result = 0;
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 20) += v6;
    v8 = v9-- == 1;
    *(_DWORD *)(a1 + 8) = v1 << 8;
  }
  while ( !v8 );
  return result;
}

//----- (10024DE0) --------------------------------------------------------
int __usercall sub_10024DE0@<eax>(int a1@<esi>, unsigned int a2, int a3)
{
  unsigned __int64 v3; // rax@1
  unsigned int v4; // edi@2
  unsigned __int64 v5; // rax@3
  char v6; // bl@4
  _BYTE *v7; // edi@5
  int v8; // edi@5
  int v9; // edi@7
  unsigned __int8 v10; // cf@9

  do
  {
    *(_DWORD *)a1 >>= 1;
    LODWORD(v3) = *(_DWORD *)a1;
    *(_QWORD *)(a1 + 8) += *(_DWORD *)a1 & -((a2 >> --a3) & 1);
    if ( (unsigned int)v3 < 0x1000000 )
    {
      v4 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)a1 = (_DWORD)v3 << 8;
      if ( v4 < 0xFF000000 || (HIDWORD(v5) = *(_DWORD *)(a1 + 12), LODWORD(v5) = v4, v3 = v5 >> 32, (_DWORD)v3) )
      {
        v6 = *(_BYTE *)(a1 + 4);
        do
        {
          v7 = *(_BYTE **)(a1 + 24);
          *v7 = v6 + (*(_QWORD *)(a1 + 8) >> 32);
          v8 = (int)(v7 + 1);
          *(_DWORD *)(a1 + 24) = v8;
          if ( v8 == *(_DWORD *)(a1 + 28) && !*(_DWORD *)(a1 + 48) )
          {
            v9 = v8 - *(_DWORD *)(a1 + 32);
            if ( v9 != (**(int (__cdecl ***)(_DWORD, _DWORD, _DWORD))(a1 + 36))(
                         *(_DWORD *)(a1 + 36),
                         *(_DWORD *)(a1 + 32),
                         v9) )
              *(_DWORD *)(a1 + 48) = 9;
            v10 = __CFADD__(v9, *(_DWORD *)(a1 + 40));
            *(_DWORD *)(a1 + 40) += v9;
            *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 32);
            *(_DWORD *)(a1 + 44) += v10;
          }
          v6 = -1;
          v10 = __CFADD__((*(_DWORD *)(a1 + 16))--, -1);
          *(_DWORD *)(a1 + 20) = v10 + *(_DWORD *)(a1 + 20) - 1;
          LODWORD(v3) = *(_DWORD *)(a1 + 20) | *(_DWORD *)(a1 + 16);
        }
        while ( *(_QWORD *)(a1 + 16) );
        v4 = *(_DWORD *)(a1 + 8);
        *(_BYTE *)(a1 + 4) = *(_DWORD *)(a1 + 8) >> 24;
      }
      v10 = __CFADD__((*(_DWORD *)(a1 + 16))++, 1);
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 20) += v10;
      *(_DWORD *)(a1 + 8) = v4 << 8;
    }
  }
  while ( a3 );
  return v3;
}

//----- (10024EC0) --------------------------------------------------------
int __usercall sub_10024EC0@<eax>(unsigned int *a1@<eax>, _WORD *a2@<edi>, int a3)
{
  unsigned int v3; // ecx@1
  int v4; // esi@1
  unsigned int v5; // edx@1
  int v6; // eax@1
  int result; // eax@4

  v3 = *a2;
  v4 = (int)a1;
  v5 = *a1;
  v6 = v3 * (*a1 >> 11);
  if ( a3 )
  {
    *(_QWORD *)(v4 + 8) += (unsigned int)v6;
    *(_DWORD *)v4 = v5 - v6;
    v3 -= v3 >> 5;
  }
  else
  {
    *(_DWORD *)v4 = v6;
    LOWORD(v3) = ((2048 - v3) >> 5) + v3;
  }
  *a2 = v3;
  result = *(_DWORD *)v4;
  if ( *(_DWORD *)v4 < 0x1000000u )
  {
    *(_DWORD *)v4 = result << 8;
    result = sub_10024C60(v4);
  }
  return result;
}

//----- (10024F20) --------------------------------------------------------
int __usercall sub_10024F20@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // esi@1
  unsigned int v4; // ebx@1
  int v5; // edi@2
  _WORD *v6; // edx@2
  unsigned int v7; // ecx@2
  int v8; // eax@2
  int result; // eax@5

  v3 = a2;
  v4 = a1 | 0x100;
  do
  {
    v5 = *(_DWORD *)v3;
    v6 = (_WORD *)(a3 + 2 * (v4 >> 8));
    v7 = *v6;
    v8 = v7 * (*(_DWORD *)v3 >> 11);
    if ( (v4 & 0x80u) != 0 )
    {
      *(_QWORD *)(v3 + 8) += (unsigned int)v8;
      *(_DWORD *)v3 = v5 - v8;
      v7 -= v7 >> 5;
    }
    else
    {
      *(_DWORD *)v3 = v8;
      LOWORD(v7) = ((2048 - v7) >> 5) + v7;
    }
    *v6 = v7;
    result = *(_DWORD *)v3;
    if ( *(_DWORD *)v3 < 0x1000000u )
    {
      *(_DWORD *)v3 = result << 8;
      result = sub_10024C60(v3);
    }
    v4 *= 2;
  }
  while ( v4 < 0x10000 );
  return result;
}

//----- (10024FA0) --------------------------------------------------------
int __usercall sub_10024FA0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4)
{
  int v4; // ebx@1
  signed int v5; // eax@1
  int v6; // esi@1
  unsigned int v7; // ebx@1
  int v8; // edi@3
  int v9; // edx@3
  _WORD *v10; // edx@3
  unsigned int v11; // ecx@3
  int v12; // eax@3
  int result; // eax@6
  signed int v14; // [sp+Ch] [bp-4h]@1

  v4 = a1;
  v5 = 256;
  v6 = a2;
  v14 = 256;
  v7 = v4 | 0x100;
  while ( 1 )
  {
    v8 = *(_DWORD *)v6;
    v9 = 2 * a4 & v5;
    a4 *= 2;
    v10 = (_WORD *)(a3 + 2 * (v5 + v9 + (v7 >> 8)));
    v11 = *v10;
    v12 = v11 * (*(_DWORD *)v6 >> 11);
    if ( (v7 & 0x80u) != 0 )
    {
      *(_QWORD *)(v6 + 8) += (unsigned int)v12;
      *(_DWORD *)v6 = v8 - v12;
      v11 -= v11 >> 5;
    }
    else
    {
      *(_DWORD *)v6 = v12;
      LOWORD(v11) = ((2048 - v11) >> 5) + v11;
    }
    *v10 = v11;
    result = *(_DWORD *)v6;
    if ( *(_DWORD *)v6 < 0x1000000u )
    {
      *(_DWORD *)v6 = result << 8;
      result = sub_10024C60(v6);
    }
    v7 *= 2;
    v14 &= ~(a4 ^ v7);
    if ( v7 >= 0x10000 )
      break;
    v5 = v14;
  }
  return result;
}

//----- (10025040) --------------------------------------------------------
int __usercall sub_10025040@<eax>(int a1@<edi>)
{
  unsigned int v1; // edx@1
  int v2; // ecx@2
  unsigned int v3; // eax@2
  signed int v4; // esi@2
  int result; // eax@6
  unsigned int v6; // ecx@6

  v1 = 8;
  do
  {
    v2 = 0;
    v3 = v1;
    v4 = 4;
    do
    {
      v3 *= v3;
      for ( v2 *= 2; v3 >= 0x10000; ++v2 )
        v3 >>= 1;
      --v4;
    }
    while ( v4 );
    result = 161 - v2;
    v6 = v1 >> 4;
    v1 += 16;
    *(_DWORD *)(a1 + 4 * v6) = result;
  }
  while ( v1 < 0x800 );
  return result;
}

//----- (10025090) --------------------------------------------------------
int __usercall sub_10025090@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>)
{
  int result; // eax@1
  unsigned int v4; // ecx@1

  result = 0;
  v4 = a2 | 0x100;
  do
  {
    result += *(_DWORD *)(a1
                        + 4
                        * (((signed int)-((v4 >> 7) & 1) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(a3 + 2 * (v4 >> 8)) >> 4)));
    v4 *= 2;
  }
  while ( v4 < 0x10000 );
  return result;
}

//----- (100250D0) --------------------------------------------------------
int __usercall sub_100250D0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4)
{
  int v4; // esi@1
  signed int v5; // edx@1
  int result; // eax@1
  unsigned int v7; // ecx@1

  v4 = a1;
  v5 = 256;
  result = 0;
  v7 = a2 | 0x100;
  do
  {
    v4 *= 2;
    result += *(_DWORD *)(a4
                        + 4
                        * (((signed int)-((v7 >> 7) & 1) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(a3
                                                                                                + 2
                                                                                                * (v5
                                                                                                 + (v4 & v5)
                                                                                                 + (v7 >> 8))) >> 4)));
    v7 *= 2;
    v5 &= ~(v4 ^ v7);
  }
  while ( v7 < 0x10000 );
  return result;
}

//----- (10025130) --------------------------------------------------------
int __usercall sub_10025130@<eax>(int result@<eax>, int a2@<ecx>, int a3, unsigned int a4)
{
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // edx@4
  int v7; // ecx@4
  unsigned int v8; // edi@4
  unsigned int v9; // ecx@4
  int v10; // eax@4
  int v11; // edi@4
  int v12; // [sp+8h] [bp-4h]@4

  v4 = result;
  v5 = 1;
  if ( a2 )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)v4;
      v7 = a2 - 1;
      v8 = a4 >> v7;
      v12 = v7;
      v9 = *(_WORD *)(a3 + 2 * v5);
      v10 = v9 * (*(_DWORD *)v4 >> 11);
      v11 = v8 & 1;
      if ( v11 )
      {
        *(_QWORD *)(v4 + 8) += (unsigned int)v10;
        *(_DWORD *)v4 = v6 - v10;
        v9 -= v9 >> 5;
      }
      else
      {
        *(_DWORD *)v4 = v10;
        LOWORD(v9) = ((2048 - v9) >> 5) + v9;
      }
      *(_WORD *)(a3 + 2 * v5) = v9;
      result = *(_DWORD *)v4;
      if ( *(_DWORD *)v4 < 0x1000000u )
      {
        *(_DWORD *)v4 <<= 8;
        result = sub_10024C60(v4);
      }
      v5 = v11 | 2 * v5;
      if ( !v12 )
        break;
      a2 = v12;
    }
  }
  return result;
}

//----- (100251C0) --------------------------------------------------------
int __usercall sub_100251C0@<eax>(int result@<eax>, int a2@<ecx>, int a3, unsigned int a4)
{
  int v4; // esi@1
  int v5; // ebx@1
  unsigned int v6; // ecx@3
  int v7; // edx@3
  int v8; // eax@3
  int v9; // edi@3
  int v10; // [sp+8h] [bp-4h]@2

  v4 = a2;
  v5 = 1;
  if ( result > 0 )
  {
    v10 = result;
    do
    {
      v6 = *(_WORD *)(a3 + 2 * v5);
      v7 = *(_DWORD *)v4;
      v8 = v6 * (*(_DWORD *)v4 >> 11);
      v9 = a4 & 1;
      if ( a4 & 1 )
      {
        *(_QWORD *)(v4 + 8) += (unsigned int)v8;
        *(_DWORD *)v4 = v7 - v8;
        v6 -= v6 >> 5;
      }
      else
      {
        *(_DWORD *)v4 = v8;
        LOWORD(v6) = ((2048 - v6) >> 5) + v6;
      }
      *(_WORD *)(a3 + 2 * v5) = v6;
      result = *(_DWORD *)v4;
      if ( *(_DWORD *)v4 < 0x1000000u )
      {
        *(_DWORD *)v4 = result << 8;
        result = sub_10024C60(v4);
      }
      a4 >>= 1;
      v5 = v9 | 2 * v5;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (10025240) --------------------------------------------------------
int __usercall sub_10025240@<eax>(int a1@<eax>, _WORD *a2@<edx>, unsigned int *a3@<ecx>, unsigned int a4)
{
  _WORD *v4; // edi@1
  int v5; // ebx@1
  unsigned int v6; // eax@1
  int v7; // esi@1
  int result; // eax@4
  unsigned int v9; // edx@5
  int v10; // ecx@5
  unsigned int v11; // eax@7
  int v12; // edx@11
  int v13; // ecx@11

  v4 = a2;
  v5 = a1;
  v6 = *a2;
  v7 = (int)a3;
  if ( a4 >= 8 )
  {
    v9 = *a3;
    v10 = v6 * (*a3 >> 11);
    *(_QWORD *)(v7 + 8) += (unsigned int)v10;
    *(_DWORD *)v7 = v9 - v10;
    *v4 = v6 - (v6 >> 5);
    if ( *(_DWORD *)v7 < 0x1000000u )
    {
      *(_DWORD *)v7 <<= 8;
      sub_10024C60(v7);
    }
    v11 = v4[1];
    if ( a4 >= 0x10 )
    {
      v12 = *(_DWORD *)v7;
      v13 = v11 * (*(_DWORD *)v7 >> 11);
      *(_QWORD *)(v7 + 8) += (unsigned int)v13;
      *(_DWORD *)v7 = v12 - v13;
      v4[1] = v11 - (v11 >> 5);
      if ( *(_DWORD *)v7 < 0x1000000u )
      {
        *(_DWORD *)v7 <<= 8;
        sub_10024C60(v7);
      }
      result = sub_10025130(v7, 8, (int)(v4 + 258), a4 - 16);
    }
    else
    {
      *(_DWORD *)v7 = v11 * (*(_DWORD *)v7 >> 11);
      v4[1] = v11 + ((2048 - v11) >> 5);
      if ( *(_DWORD *)v7 < 0x1000000u )
      {
        *(_DWORD *)v7 <<= 8;
        sub_10024C60(v7);
      }
      result = sub_10025130(v7, 3, (int)&v4[8 * v5 + 130], a4 - 8);
    }
  }
  else
  {
    *a3 = v6 * (*a3 >> 11);
    *a2 = v6 + ((2048 - v6) >> 5);
    if ( *a3 < 0x1000000 )
    {
      *a3 <<= 8;
      sub_10024C60((int)a3);
    }
    result = sub_10025130(v7, 3, (int)&v4[8 * v5 + 2], a4);
  }
  return result;
}

//----- (10025390) --------------------------------------------------------
unsigned int __usercall sub_10025390@<eax>(int a1@<esi>, int a2, int a3, unsigned int a4, int a5)
{
  int v5; // ebx@1
  unsigned int v6; // edx@1
  unsigned int result; // eax@1
  unsigned int v8; // edx@1
  int v9; // edi@3
  int v10; // edi@9
  unsigned int v11; // eax@9
  unsigned int v12; // eax@14
  int j; // edi@14
  int v14; // [sp+8h] [bp-14h]@1
  int v15; // [sp+Ch] [bp-10h]@1
  int v16; // [sp+10h] [bp-Ch]@1
  int v17; // [sp+14h] [bp-8h]@7
  int v18; // [sp+14h] [bp-8h]@13
  int i; // [sp+18h] [bp-4h]@3
  int k; // [sp+18h] [bp-4h]@9

  v5 = a2;
  v16 = *(_DWORD *)(a1 + 4 * ((unsigned int)*(_WORD *)a2 >> 4));
  v6 = *(_WORD *)(a2 + 2);
  result = *(_DWORD *)(a1 + 4 * ((*(_WORD *)a2 ^ 0x7F0u) >> 4));
  v15 = result + *(_DWORD *)(a1 + 4 * (v6 >> 4));
  v14 = result + *(_DWORD *)(a1 + 4 * ((v6 ^ 0x7F0) >> 4));
  v8 = 0;
  while ( v8 < a4 )
  {
    v9 = 0;
    result = v8 | 8;
    for ( i = 0; result != 1; i = v9 )
    {
      v9 = *(_DWORD *)(a1
                     + 4
                     * (((signed int)-(result & 1) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(a2
                                                                                          + 2 * ((result >> 1) + 8 * a3)
                                                                                          + 4) >> 4)))
         + i;
      result >>= 1;
    }
    *(_DWORD *)(a5 + 4 * v8++) = v16 + v9;
    if ( v8 >= 8 )
    {
      if ( v8 >= 0x10 )
      {
LABEL_12:
        if ( v8 < a4 )
        {
          result = v8 - 16;
          v18 = v8 - 16;
          do
          {
            v12 = result | 0x100;
            for ( j = 0; v12 != 1; v12 >>= 1 )
            {
              j += *(_DWORD *)(a1
                             + 4
                             * (((signed int)-(v12 & 1) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(v5
                                                                                               + 2 * (v12 >> 1)
                                                                                               + 516) >> 4)));
              v5 = a2;
            }
            *(_DWORD *)(a5 + 4 * v8++) = v14 + j;
            result = v18++ + 1;
          }
          while ( v8 < a4 );
        }
      }
      else
      {
        result = v8 - 8;
        v17 = v8 - 8;
        while ( v8 < a4 )
        {
          v10 = 0;
          v11 = result | 8;
          for ( k = 0; v11 != 1; k = v10 )
          {
            v10 = *(_DWORD *)(a1
                            + 4
                            * (((signed int)-(v11 & 1) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(a2
                                                                                              + 2
                                                                                              * ((v11 >> 1) + 8 * a3)
                                                                                              + 260) >> 4)))
                + k;
            v11 >>= 1;
          }
          *(_DWORD *)(a5 + 4 * v8++) = v15 + v10;
          result = v17++ + 1;
          if ( v8 >= 0x10 )
            goto LABEL_12;
        }
      }
      return result;
    }
  }
  return result;
}

//----- (10025510) --------------------------------------------------------
int __usercall sub_10025510@<eax>(int result@<eax>, int a2@<edi>, unsigned int a3)
{
  unsigned int v3; // ebx@1
  int v4; // esi@1
  _DWORD *v5; // [sp+8h] [bp-8h]@2
  int v6; // [sp+Ch] [bp-4h]@2

  v3 = 0;
  v4 = result;
  if ( a3 )
  {
    v5 = (_DWORD *)(a2 + 18440);
    v6 = a2 + 1032;
    do
    {
      sub_10025390(v4, a2, v3, *(_DWORD *)(a2 + 1028), v6);
      v6 += 1088;
      *v5 = *(_DWORD *)(a2 + 1028);
      ++v3;
      result = (int)(v5 + 1);
      ++v5;
    }
    while ( v3 < a3 );
  }
  return result;
}

//----- (10025570) --------------------------------------------------------
int __usercall sub_10025570@<eax>(_DWORD *a1@<esi>, int *a2)
{
  int v2; // edi@1
  int v3; // eax@1
  int (__cdecl *v4)(_DWORD, _DWORD); // ecx@1
  int v5; // eax@1
  int v6; // ebx@1
  int v7; // eax@5
  _BYTE *v8; // ecx@5
  int v10; // [sp+8h] [bp-8h]@1
  unsigned int v11; // [sp+Ch] [bp-4h]@3

  v2 = 0;
  v3 = ((int (__cdecl *)(_DWORD))a1[2])(*a1);
  v4 = (int (__cdecl *)(_DWORD, _DWORD))a1[4];
  a1[10] = v3;
  v5 = v4(*a1, a1 + 50253);
  v6 = v5;
  v10 = v5;
  if ( v5 )
  {
    v2 = a1[v5 + 50251];
    if ( v2 == a1[11] )
    {
      v11 = a1[10];
      if ( v11 > 0x111 )
        v11 = 273;
      v7 = ((int (__cdecl *)(_DWORD))a1[3])(*a1) - 1;
      v8 = (_BYTE *)(v7 + v2);
      if ( v7 + v2 != v7 + v11 )
      {
        do
        {
          if ( *v8 != v8[-1 - a1[v6 + 50252]] )
            break;
          ++v8;
        }
        while ( v8 != (_BYTE *)(v7 + v11) );
        v6 = v10;
      }
      v2 = (int)&v8[-v7];
    }
  }
  ++a1[12];
  *a2 = v6;
  return v2;
}

//----- (10025610) --------------------------------------------------------
int __usercall sub_10025610@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  int v4; // esi@1
  int result; // eax@2
  int v6; // eax@3

  v4 = a1;
  if ( a1 )
  {
    v6 = *(_DWORD *)(a3 + 4 * ((*(_WORD *)(a3 + 2 * a2 + 206752) ^ 0x7F0u) >> 4) + 200500);
    if ( v4 == 1 )
      result = *(_DWORD *)(a3 + 4 * ((unsigned int)*(_WORD *)(a3 + 2 * a2 + 206776) >> 4) + 200500) + v6;
    else
      result = *(_DWORD *)(a3 + 4 * ((*(_WORD *)(a3 + 2 * a2 + 206776) ^ 0x7F0u) >> 4) + 200500)
             + *(_DWORD *)(a3
                         + 4 * (((2 - v4) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(a3 + 2 * a2 + 206800) >> 4))
                         + 200500)
             + v6;
  }
  else
  {
    result = *(_DWORD *)(a3 + 4 * ((unsigned int)*(_WORD *)(a3 + 2 * a2 + 206752) >> 4) + 200500)
           + *(_DWORD *)(a3 + 4 * ((*(_WORD *)(a3 + 2 * (a4 + 16 * a2) + 206824) ^ 0x7F0u) >> 4) + 200500);
  }
  return result;
}

//----- (100256D0) --------------------------------------------------------
int __usercall sub_100256D0@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3)
{
  int v3; // edi@1
  int v4; // eax@1
  int v5; // esi@2
  int v6; // edx@3
  int v7; // ebx@5
  int v8; // edx@5
  int v9; // esi@5
  int v10; // ST0C_4@5
  int result; // eax@6
  int v12; // [sp+10h] [bp-4h]@1

  v3 = a1;
  v4 = *(_DWORD *)(a2 + 48 * a1 + 1868);
  v12 = *(_DWORD *)(a2 + 16 * (3 * v3 + 117));
  *(_DWORD *)(a2 + 24) = v3;
  do
  {
    v5 = a2 + 48 * v3;
    if ( *(_DWORD *)(v5 + 1852) )
    {
      *(_DWORD *)(a2 + 16 * (3 * v4 + 117)) = -1;
      v6 = a2 + 48 * v4;
      *(_DWORD *)(v6 + 1852) = 0;
      *(_DWORD *)(v6 + 1868) = v4 - 1;
      if ( *(_DWORD *)(v5 + 1856) )
      {
        *(_DWORD *)(v6 + 1804) = 0;
        *(_DWORD *)(v6 + 1820) = *(_DWORD *)(v5 + 1860);
        *(_DWORD *)(a2 + 16 * (3 * v4 + 114)) = *(_DWORD *)(v5 + 1864);
      }
    }
    v7 = v12;
    v8 = v4 + 39;
    v12 = *(_DWORD *)(a2 + 48 * (v4 + 39));
    v9 = 6 * v4;
    v10 = v4;
    v4 = *(_DWORD *)(a2 + 48 * v4 + 1868);
    *(_DWORD *)(a2 + 8 * v9 + 1868) = v3;
    v3 = v10;
    *(_DWORD *)(a2 + 48 * v8) = v7;
  }
  while ( v10 );
  *a3 = *(_DWORD *)(a2 + 1872);
  result = *(_DWORD *)(a2 + 1868);
  *(_DWORD *)(a2 + 28) = result;
  return result;
}

//----- (100257C0) --------------------------------------------------------
int __usercall sub_100257C0@<eax>(_DWORD *a1@<ecx>, _DWORD *a2@<ebx>, int a3)
{
  _DWORD *v3; // edi@1
  int v4; // ecx@1
  int result; // eax@2
  int v6; // edx@5
  unsigned int v7; // eax@6
  int v8; // eax@10
  int v9; // esi@10
  unsigned int v10; // edx@10
  unsigned int v11; // edi@11
  int v12; // eax@11
  _BYTE *v13; // ecx@11
  unsigned int v14; // eax@13
  _BYTE *v15; // edx@14
  int v16; // ecx@14
  int v17; // ecx@18
  unsigned int v18; // edi@22
  unsigned int v19; // ecx@22
  int v20; // ecx@27
  int v21; // eax@28
  char v22; // cl@29
  unsigned int v23; // edi@33
  int v24; // eax@33
  int v25; // edx@33
  unsigned int v26; // esi@33
  int v27; // esi@33
  int v28; // eax@34
  int v29; // esi@36
  int v30; // ecx@36
  int v31; // eax@36
  int v32; // ecx@36
  unsigned int v33; // eax@37
  unsigned int v34; // eax@39
  int v35; // ecx@44
  _DWORD *v36; // ecx@44
  unsigned int v37; // edi@46
  unsigned int v38; // esi@47
  _DWORD *v39; // eax@48
  unsigned int *v40; // ecx@48
  unsigned int v41; // edx@49
  unsigned int v42; // ecx@54
  unsigned int v43; // eax@57
  char *i; // edi@60
  unsigned int v45; // esi@61
  int v46; // edx@61
  int v47; // eax@61
  unsigned int v48; // edx@64
  signed int v49; // ecx@65
  int v50; // edi@71
  unsigned int v51; // eax@72
  int v52; // ecx@73
  int v53; // eax@73
  int v54; // esi@73
  int v55; // ecx@75
  int v56; // edx@76
  unsigned int v57; // ecx@86
  int v58; // edx@86
  int v59; // eax@91
  int v60; // edx@91
  unsigned int v61; // eax@92
  int v62; // eax@96
  int v63; // ecx@96
  int v64; // edx@96
  int v65; // eax@96
  unsigned int v66; // ecx@96
  int (__cdecl *v67)(int); // eax@96
  int v68; // ST04_4@96
  int v69; // edi@96
  int v70; // eax@96
  int v71; // eax@96
  unsigned int v72; // edx@96
  int v73; // eax@96
  unsigned int v74; // edx@96
  int v75; // eax@96
  int v76; // edx@96
  int v77; // eax@97
  int v78; // eax@98
  int v79; // ecx@98
  unsigned int v80; // eax@99
  int v81; // ecx@100
  unsigned int v82; // edx@102
  unsigned int v83; // eax@107
  unsigned int v84; // ecx@109
  unsigned int v85; // esi@112
  unsigned int v86; // eax@116
  unsigned int v87; // esi@118
  _BYTE *v88; // eax@119
  unsigned int v89; // esi@122
  int v90; // eax@123
  int v91; // edx@123
  int v92; // ecx@123
  int v93; // eax@123
  int v94; // edx@123
  int v95; // edx@123
  unsigned int v96; // eax@123
  int v97; // esi@124
  _DWORD *v98; // eax@124
  unsigned int v99; // eax@126
  int v100; // ecx@126
  int v101; // edx@127
  unsigned __int8 v102; // dl@129
  unsigned int v103; // esi@131
  _BYTE *v104; // eax@132
  int v105; // eax@137
  _DWORD *v106; // ecx@137
  int v107; // esi@139
  int v108; // eax@139
  unsigned int *v109; // ecx@139
  unsigned int v110; // edx@140
  unsigned int v111; // eax@145
  unsigned int v112; // ecx@145
  _BYTE *v113; // ecx@148
  int v114; // edx@152
  int v115; // eax@152
  int v116; // ecx@152
  unsigned int v117; // esi@152
  int v118; // edi@152
  int v119; // eax@152
  int v120; // edx@152
  int v121; // edi@152
  int v122; // esi@152
  int v123; // edx@152
  unsigned int v124; // ecx@152
  int v125; // esi@152
  int v126; // eax@152
  int v127; // ecx@152
  int v128; // edi@152
  int v129; // edx@152
  unsigned int v130; // eax@152
  unsigned int v131; // edi@152
  int v132; // eax@153
  _DWORD *v133; // edi@153
  unsigned int v134; // eax@155
  int v135; // ecx@155
  unsigned int v136; // eax@156
  unsigned int v137; // eax@156
  unsigned int v138; // edx@158
  int v139; // eax@159
  int v140; // eax@164
  _DWORD *v141; // ecx@164
  int v142; // eax@166
  unsigned int v143; // eax@169
  signed int v144; // ecx@169
  unsigned int v145; // esi@169
  int v146; // edx@170
  int v147; // ecx@170
  unsigned int v148; // edx@173
  int v149; // ecx@178
  unsigned int v150; // eax@178
  int v151; // ecx@178
  int v152; // edx@181
  _BYTE *j; // eax@181
  int v154; // ST10_4@186
  int v155; // eax@186
  int v156; // edx@186
  int v157; // esi@186
  int v158; // edx@186
  int v159; // eax@186
  int v160; // ecx@186
  unsigned int v161; // edi@186
  int v162; // esi@186
  int v163; // edx@186
  int v164; // edx@186
  unsigned int v165; // eax@186
  unsigned int v166; // edi@186
  int v167; // eax@187
  _DWORD *v168; // edi@187
  unsigned int v169; // eax@189
  int v170; // ecx@189
  int v171; // edx@190
  int v172; // eax@190
  int v173; // eax@191
  int v174; // [sp+4h] [bp-84h]@104
  int v175; // [sp+4h] [bp-84h]@163
  int v176; // [sp+8h] [bp-80h]@104
  int v177; // [sp+8h] [bp-80h]@186
  _DWORD *v178; // [sp+Ch] [bp-7Ch]@1
  unsigned int v179; // [sp+10h] [bp-78h]@72
  _DWORD *v180; // [sp+10h] [bp-78h]@169
  int v181; // [sp+14h] [bp-74h]@1
  int v182; // [sp+18h] [bp-70h]@139
  int v183; // [sp+18h] [bp-70h]@152
  int v184; // [sp+18h] [bp-70h]@186
  int v185; // [sp+1Ch] [bp-6Ch]@139
  unsigned int v186; // [sp+20h] [bp-68h]@6
  unsigned int v187; // [sp+20h] [bp-68h]@112
  int v188; // [sp+20h] [bp-68h]@169
  char *v189; // [sp+24h] [bp-64h]@10
  unsigned int v190; // [sp+28h] [bp-60h]@13
  unsigned int v191; // [sp+2Ch] [bp-5Ch]@96
  unsigned int v192; // [sp+30h] [bp-58h]@96
  unsigned int v193; // [sp+34h] [bp-54h]@82
  int v194; // [sp+38h] [bp-50h]@10
  unsigned int v195; // [sp+3Ch] [bp-4Ch]@10
  unsigned int v196; // [sp+40h] [bp-48h]@40
  unsigned int v197; // [sp+44h] [bp-44h]@22
  unsigned int v198; // [sp+48h] [bp-40h]@4
  unsigned int v199; // [sp+4Ch] [bp-3Ch]@71
  unsigned int v200; // [sp+50h] [bp-38h]@99
  int v201; // [sp+54h] [bp-34h]@33
  unsigned __int8 v202; // [sp+5Bh] [bp-2Dh]@29
  unsigned int v203; // [sp+5Ch] [bp-2Ch]@4
  unsigned __int8 v204; // [sp+63h] [bp-25h]@10
  int v205[4]; // [sp+64h] [bp-24h]@18
  unsigned int v206; // [sp+74h] [bp-14h]@11
  int v207; // [sp+78h] [bp-10h]@44
  int v208; // [sp+7Ch] [bp-Ch]@44
  int v209; // [sp+80h] [bp-8h]@44

  v3 = a1;
  v4 = a2[7];
  v181 = a3;
  v178 = v3;
  if ( a2[6] != v4 )
  {
    result = a2[12 * v4 + 467] - v4;
    *v3 = a2[12 * v4 + 468];
    a2[7] = a2[12 * v4 + 467];
    return result;
  }
  a2[6] = 0;
  a2[7] = 0;
  if ( a2[12] )
  {
    v6 = a2[9];
    v203 = a2[8];
    v198 = v6;
  }
  else
  {
    v203 = sub_10025570(a2, (int *)&v198);
  }
  v7 = a2[10];
  v186 = v7;
  if ( v7 < 2 )
  {
    *v3 = -1;
    return 1;
  }
  if ( v7 > 0x111 )
    v186 = 273;
  v8 = ((int (__stdcall *)(_DWORD))a2[3])(*a2);
  v9 = v8 - 1;
  LOBYTE(v8) = *(_BYTE *)(v8 - 1);
  v10 = 0;
  v194 = 0;
  v195 = 0;
  v204 = v8;
  v189 = 0;
  do
  {
    v11 = v10;
    v12 = a2[v10 + 13];
    *(&v206 + v10) = v12;
    v13 = (_BYTE *)(v9 - v12 - 1);
    if ( v204 != *v13 || *(_BYTE *)(v9 + 1) != *(_BYTE *)(v9 - v12) )
    {
      v205[v11] = 0;
    }
    else
    {
      v14 = 2;
      v190 = 2;
      if ( v186 > 2 )
      {
        v15 = (_BYTE *)(v9 + 2);
        v16 = (int)&v13[-v9];
        do
        {
          v14 = v190;
          if ( *v15 != v15[v16] )
            break;
          v14 = v190 + 1;
          ++v15;
          v190 = v14;
        }
        while ( v14 < v186 );
        v10 = v195;
      }
      v17 = (int)v189;
      v205[v11] = v14;
      if ( v14 > *(int *)((char *)v205 + v17) )
      {
        v194 = v10;
        v189 = (char *)(v11 * 4);
      }
    }
    v195 = ++v10;
  }
  while ( v10 < 4 );
  v18 = v205[v194];
  v19 = a2[11];
  v197 = v18;
  if ( v18 >= v19 )
  {
    *v178 = v194;
    if ( v18 != 1 )
    {
      a2[12] += v18 - 1;
      ((void (__cdecl *)(_DWORD, unsigned int))a2[5])(*a2, v18 - 1);
    }
    return v18;
  }
  result = v203;
  if ( v203 < v19 )
  {
    v22 = *(_BYTE *)(v9 - v206 - 1);
    v202 = *(_BYTE *)(v9 - v206 - 1);
    if ( v203 < 2 && v204 != v22 && v18 < 2 )
    {
      *v178 = -1;
      return 1;
    }
    v23 = a2[17];
    v24 = a3 & a2[22];
    v25 = a2[21] & a3;
    a2[462] = v23;
    v26 = *(_BYTE *)(v9 - 1);
    v201 = v24;
    v27 = a2[24] + 1536 * ((v25 << a2[18]) + (v26 >> (8 - a2[18])));
    if ( v23 < 7 )
      v28 = sub_10025090((int)(a2 + 50125), v204, v27);
    else
      v28 = sub_100250D0(v202, v204, v27, (int)(a2 + 50125));
    v29 = v201;
    v30 = v201 + 16 * v23;
    a2[473] = v28 + a2[((unsigned int)*((_WORD *)a2 + v30 + 103172) >> 4) + 50125];
    a2[480] = -1;
    a2[475] = 0;
    v31 = a2[((*((_WORD *)a2 + v30 + 103172) ^ 0x7F0u) >> 4) + 50125];
    v32 = v31 + a2[((*((_WORD *)a2 + v23 + 103364) ^ 0x7F0u) >> 4) + 50125];
    v194 = v31;
    v189 = (char *)v32;
    if ( v202 == v204 )
    {
      v33 = v32
          + a2[((unsigned int)*((_WORD *)a2 + v23 + 103376) >> 4) + 50125]
          + a2[((unsigned int)*((_WORD *)a2 + v29 + 16 * v23 + 103412) >> 4) + 50125];
      if ( v33 < a2[473] )
      {
        a2[473] = v33;
        a2[480] = 0;
        a2[475] = 0;
      }
    }
    v34 = v203;
    if ( v203 < v197 )
    {
      v196 = v197;
      v34 = v197;
    }
    else
    {
      v196 = v203;
    }
    if ( v34 < 2 )
    {
      *v178 = a2[480];
      return 1;
    }
    v35 = v206;
    a2[479] = 0;
    a2[469] = v35;
    a2[470] = v207;
    a2[471] = v208;
    a2[472] = v209;
    v36 = &a2[12 * v34 + 461];
    do
    {
      *v36 = 0x40000000;
      --v34;
      v36 -= 12;
    }
    while ( v34 >= 2 );
    v37 = 0;
    do
    {
      v38 = v205[v37];
      if ( v38 >= 2 )
      {
        v197 = (unsigned int)&v189[sub_10025610(v37, a2[17], (int)a2, v201)];
        v39 = &a2[272 * v201 + 56877] + v38;
        v40 = &a2[4 * (3 * v38 + 117)];
        do
        {
          v41 = v197 + *v39;
          if ( v41 < *(v40 - 7) )
          {
            *(v40 - 7) = v41;
            *(v40 - 1) = 0;
            *v40 = v37;
            *(v40 - 5) = 0;
          }
          --v38;
          --v39;
          v40 -= 12;
        }
        while ( v38 >= 2 );
      }
      ++v37;
    }
    while ( v37 < 4 );
    v197 = v194 + a2[((unsigned int)*((_WORD *)a2 + a2[17] + 103364) >> 4) + 50125];
    if ( v205[0] < 2u )
      v42 = 2;
    else
      v42 = v205[0] + 1;
    v190 = v42;
    if ( v42 <= v203 )
    {
      v43 = 0;
      v203 = 0;
      if ( v42 > a2[50253] )
      {
        do
          v43 += 2;
        while ( v42 > a2[v43 + 50253] );
        v203 = v43;
      }
      v195 = (unsigned int)(&a2[272 * v201 + 52251] + v42);
      for ( i = (char *)&a2[4 * (3 * v42 + 117)]; ; i += 48 )
      {
        v45 = a2[v203 + 50254];
        v46 = v197 + *(_DWORD *)v195;
        v189 = i;
        v47 = v42 - 2;
        if ( v42 >= 5 )
          v47 = 3;
        if ( v45 >= 0x80 )
        {
          v49 = v45 < 0x20000 ? 6 : 16;
          i = v189;
          v48 = a2[(v45 & 0xF) + 51570]
              + a2[*((_BYTE *)a2 + (v45 >> v49) + 198452) + 2 * (v49 + 32 * v47) + 50802]
              + v46;
          v42 = v190;
        }
        else
        {
          v48 = *(&a2[128 * v47 + 51058] + v45) + v46;
        }
        if ( v48 < *((_DWORD *)i - 7) )
        {
          *((_DWORD *)i - 7) = v48;
          *((_DWORD *)i - 1) = 0;
          *(_DWORD *)i = v45 + 4;
          *((_DWORD *)i - 5) = 0;
        }
        if ( v42 == a2[v203 + 50253] )
        {
          v203 += 2;
          if ( v203 == v198 )
            break;
        }
        v195 += 4;
        v190 = ++v42;
      }
    }
    v50 = 1;
    v199 = 1;
    if ( v196 == 1 )
      return sub_100256D0(v50, (int)a2, v178);
    while ( 1 )
    {
      v51 = sub_10025570(a2, (int *)&v189);
      v179 = v51;
      if ( v51 >= a2[11] )
      {
        a2[9] = v189;
        a2[8] = v51;
        return sub_100256D0(v50, (int)a2, v178);
      }
      ++v181;
      v52 = a2[12 * v50 + 463];
      v53 = a2[12 * v50 + 467];
      v54 = (int)&a2[12 * v50];
      v194 = (int)&a2[12 * v50];
      if ( v52 )
      {
        --v53;
        if ( *(_DWORD *)(v54 + 1856) )
        {
          v55 = a2[12 * *(_DWORD *)(v54 + 1860) + 462];
          v56 = *(_DWORD *)(v54 + 1864) >= 4u ? dword_100A1410[dword_100A1440[v55]] : dword_100A1410[dword_100A1470[v55]];
        }
        else
        {
          v56 = dword_100A1410[a2[12 * v53 + 462]];
        }
      }
      else
      {
        v56 = a2[12 * v53 + 462];
      }
      if ( v53 != v50 - 1 )
        break;
      if ( *(_DWORD *)(v54 + 1872) )
        v193 = dword_100A1410[v56];
      else
        v193 = dword_100A14A0[v56];
LABEL_96:
      v62 = v206;
      v63 = v207;
      *(_DWORD *)(v54 + 1848) = v193;
      v64 = v208;
      *(_DWORD *)(v54 + 1876) = v62;
      v65 = v209;
      *(_DWORD *)(v54 + 1880) = v63;
      v66 = *(_DWORD *)(v54 + 1844);
      *(_DWORD *)(v54 + 1884) = v64;
      *(_DWORD *)(v54 + 1888) = v65;
      v67 = (int (__cdecl *)(int))a2[3];
      v68 = *a2;
      v203 = v66;
      v198 = 0;
      v69 = v67(v68) - 1;
      v204 = *(_BYTE *)v69;
      v191 = v69 - v206 - 1;
      v202 = *(_BYTE *)v191;
      v70 = v181 & a2[22];
      v194 = v70;
      v71 = 16 * v193 + v70;
      v72 = (unsigned int)*((_WORD *)a2 + v71 + 103172) >> 4;
      v201 = v71;
      v73 = v203 + a2[v72 + 50125];
      v74 = *(_BYTE *)(v69 - 1);
      v192 = v73;
      v75 = a2[18];
      v197 = a2[21] & v181;
      v190 = v69;
      v76 = a2[24] + 1536 * ((v197 << v75) + (v74 >> (8 - v75)));
      if ( v193 < 7 )
      {
        v80 = v204 | 0x100;
        v200 = 0;
        v195 = v204 | 0x100;
        do
        {
          v81 = a2[(((signed int)-((v80 >> 7) & 1) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(v76 + 2 * (v80 >> 8)) >> 4))
                 + 50125]
              + v200;
          v80 = 2 * v195;
          v200 = v81;
          v195 = v80;
        }
        while ( v80 < 0x10000 );
        v77 = v81;
      }
      else
      {
        v77 = sub_100250D0(v202, v204, v76, (int)(a2 + 50125));
      }
      v82 = v77 + v192;
      v192 = v82;
      if ( v82 < *(_DWORD *)(v54 + 1892) )
      {
        *(_DWORD *)(v54 + 1892) = v82;
        *(_DWORD *)(v54 + 1916) = v199;
        *(_DWORD *)(v54 + 1920) = -1;
        *(_DWORD *)(v54 + 1900) = 0;
        v198 = 1;
      }
      v174 = v203 + a2[((*((_WORD *)a2 + v201 + 103172) ^ 0x7F0u) >> 4) + 50125];
      v176 = v203
           + a2[((*((_WORD *)a2 + v201 + 103172) ^ 0x7F0u) >> 4) + 50125]
           + a2[((*((_WORD *)a2 + v193 + 103364) ^ 0x7F0u) >> 4) + 50125];
      if ( v202 == v204 && (*(_DWORD *)(v54 + 1916) >= v199 || *(_DWORD *)(v54 + 1920)) )
      {
        v83 = v203
            + a2[((*((_WORD *)a2 + v201 + 103172) ^ 0x7F0u) >> 4) + 50125]
            + a2[((*((_WORD *)a2 + v193 + 103364) ^ 0x7F0u) >> 4) + 50125]
            + a2[((unsigned int)*((_WORD *)a2 + v201 + 103412) >> 4) + 50125]
            + a2[((unsigned int)*((_WORD *)a2 + v193 + 103376) >> 4) + 50125];
        if ( v83 <= *(_DWORD *)(v54 + 1892) )
        {
          *(_DWORD *)(v54 + 1892) = v83;
          *(_DWORD *)(v54 + 1916) = v199;
          *(_DWORD *)(v54 + 1920) = 0;
          *(_DWORD *)(v54 + 1900) = 0;
          v198 = 1;
        }
      }
      v84 = a2[10];
      v195 = v84;
      if ( 4095 - v199 < v84 )
      {
        v84 = 4095 - v199;
        v195 = 4095 - v199;
      }
      if ( v84 >= 2 )
      {
        v85 = a2[11];
        v187 = v195;
        if ( v195 > v85 )
          v187 = a2[11];
        if ( !v198 && v202 != v204 )
        {
          v86 = v85 + 1;
          v200 = v85 + 1;
          if ( v85 + 1 > v195 )
          {
            v86 = v195;
            v200 = v195;
          }
          v87 = 1;
          if ( v86 > 1 )
          {
            v88 = (_BYTE *)(v69 + 1);
            do
            {
              if ( *v88 != v88[v191 - v69] )
                break;
              ++v87;
              ++v88;
            }
            while ( v87 < v200 );
          }
          v89 = v87 - 1;
          v203 = v89;
          if ( v89 >= 2 )
          {
            v90 = dword_100A1410[v193];
            v91 = 16 * dword_100A1410[v193];
            v92 = a2[22] & (v181 + 1);
            v198 = v90;
            v93 = *((_WORD *)a2 + v90 + 103364);
            v94 = v92 + v91;
            v197 = v94;
            v191 = (*((_WORD *)a2 + v94 + 103172) ^ 0x7F0u) >> 4;
            v95 = v192 + a2[v191 + 50125] + a2[((v93 ^ 0x7F0u) >> 4) + 50125];
            v96 = v196;
            v200 = v89 + v199 + 1;
            if ( v196 < v200 )
            {
              v191 = (unsigned int)&a2[12 * v196 + 461];
              v97 = v200 - v196;
              v196 = v200;
              v98 = &a2[12 * v96 + 461];
              do
              {
                v98 += 12;
                --v97;
                *v98 = 0x40000000;
              }
              while ( v97 );
            }
            v99 = v95
                + *(&a2[272 * v92 + 56877] + v203)
                + a2[((unsigned int)*((_WORD *)a2 + v198 + 103376) >> 4) + 50125]
                + a2[((*((_WORD *)a2 + v197 + 103412) ^ 0x7F0u) >> 4) + 50125];
            v100 = (int)&a2[12 * v200 + 461];
            if ( v99 < *(_DWORD *)v100 )
            {
              v101 = v199 + 1;
              *(_DWORD *)v100 = v99;
              *(_DWORD *)(v100 + 24) = v101;
              *(_DWORD *)(v100 + 28) = 0;
              *(_DWORD *)(v100 + 8) = 1;
              *(_DWORD *)(v100 + 12) = 0;
            }
          }
        }
        v198 = 2;
        v203 = 0;
        do
        {
          v102 = *(_BYTE *)v69;
          v192 = v69 - *(&v206 + v203) - 1;
          if ( v102 == *(_BYTE *)v192 && *(_BYTE *)(v69 + 1) == *(_BYTE *)(v192 + 1) )
          {
            v103 = 2;
            v201 = 2;
            if ( v187 > 2 )
            {
              v104 = (_BYTE *)(v69 + 2);
              do
              {
                if ( *v104 != v104[v192 - v69] )
                  break;
                ++v103;
                ++v104;
              }
              while ( v103 < v187 );
              v201 = v103;
            }
            v191 = v103 + v199;
            if ( v196 < v103 + v199 )
            {
              v105 = v103 + v199 - v196;
              v106 = &a2[12 * v196 + 461];
              v196 = v103 + v199;
              do
              {
                v106 += 12;
                --v105;
                *v106 = 0x40000000;
              }
              while ( v105 );
            }
            v107 = v201;
            v197 = v201;
            v108 = v176 + sub_10025610(v203, v193, (int)a2, v194);
            v182 = 272 * v194;
            v200 = (unsigned int)(&a2[272 * v194 + 56877] + v107);
            v185 = v108;
            v109 = &a2[4 * (3 * v191 + 117)];
            do
            {
              v110 = v108 + *(_DWORD *)v200;
              if ( v110 < *(v109 - 7) )
              {
                *(v109 - 7) = v110;
                *(v109 - 1) = v199;
                *v109 = v203;
                *(v109 - 5) = 0;
              }
              --v201;
              v200 -= 4;
              v109 -= 12;
            }
            while ( (unsigned int)v201 >= 2 );
            if ( !v203 )
              v198 = v107 + 1;
            v111 = v107 + 1;
            v112 = v107 + 1 + a2[11];
            v201 = v107 + 1;
            v200 = v112;
            if ( v112 > v195 )
            {
              v112 = v195;
              v200 = v195;
            }
            if ( v111 < v112 )
            {
              v113 = (_BYTE *)(v111 + v69);
              do
              {
                v111 = v201;
                if ( *v113 != v113[v192 - v69] )
                  break;
                v111 = v201 + 1;
                ++v113;
                v201 = v111;
              }
              while ( v111 < v200 );
            }
            v201 = -1 - v107 + v111;
            if ( (unsigned int)v201 >= 2 )
            {
              v114 = a2[18];
              v200 = v107 + v181;
              v115 = *(_BYTE *)(v107 + v192);
              v116 = *(_BYTE *)(v107 + v69);
              v117 = *(_BYTE *)(v69 + v107 - 1);
              v118 = a2[21] & v200;
              v191 = v116;
              v119 = sub_100250D0(
                       v115,
                       v116,
                       a2[24] + 1536 * ((v118 << v114) + (v117 >> (8 - v114))),
                       (int)(a2 + 50125));
              v120 = dword_100A1470[v193];
              v121 = a2[22];
              v122 = v120;
              v123 = dword_100A1410[v120];
              v124 = *((_WORD *)a2 + 16 * v122 + (v121 & v200) + 103172);
              v125 = v197;
              v126 = *(&a2[v197 + 56877] + v182) + a2[(v124 >> 4) + 50125] + v119;
              v127 = v121 & (v181 + v197 + 1);
              v128 = v127 + 16 * v123;
              v191 = v123;
              v183 = v128;
              v129 = v185
                   + v126
                   + a2[((*((_WORD *)a2 + v128 + 103172) ^ 0x7F0u) >> 4) + 50125]
                   + a2[((*((_WORD *)a2 + v123 + 103364) ^ 0x7F0u) >> 4) + 50125];
              v130 = v197 + v201 + v199 + 1;
              v131 = v196;
              v197 = v130;
              if ( v196 < v130 )
              {
                v132 = v130 - v196;
                v196 += v132;
                v133 = &a2[12 * v131 + 461];
                do
                {
                  v133 += 12;
                  --v132;
                  *v133 = 0x40000000;
                }
                while ( v132 );
              }
              v69 = v190;
              v134 = v129
                   + *(&a2[272 * v127 + 56877] + v201)
                   + a2[((unsigned int)*((_WORD *)a2 + v191 + 103376) >> 4) + 50125]
                   + a2[((*((_WORD *)a2 + v183 + 103412) ^ 0x7F0u) >> 4) + 50125];
              v135 = (int)&a2[12 * v197 + 461];
              if ( v134 < *(_DWORD *)v135 )
              {
                *(_DWORD *)v135 = v134;
                v136 = v199;
                *(_DWORD *)(v135 + 24) = v125 + v199 + 1;
                *(_DWORD *)(v135 + 16) = v136;
                v137 = v203;
                *(_DWORD *)(v135 + 28) = 0;
                *(_DWORD *)(v135 + 8) = 1;
                *(_DWORD *)(v135 + 12) = 1;
                *(_DWORD *)(v135 + 20) = v137;
              }
            }
          }
          ++v203;
        }
        while ( v203 < 4 );
        v138 = v179;
        if ( v179 > v187 )
        {
          v138 = v187;
          v139 = 0;
          v179 = v187;
          if ( v187 > a2[50253] )
          {
            do
              v139 += 2;
            while ( v187 > a2[v139 + 50253] );
          }
          a2[v139 + 50253] = v187;
          v189 = (char *)(v139 + 2);
        }
        if ( v138 >= v198 )
        {
          v175 = v174 + a2[((unsigned int)*((_WORD *)a2 + v193 + 103364) >> 4) + 50125];
          if ( v196 < v199 + v179 )
          {
            v140 = v199 + v179 - v196;
            v141 = &a2[12 * v196 + 461];
            v196 = v199 + v179;
            do
            {
              v141 += 12;
              --v140;
              *v141 = 0x40000000;
            }
            while ( v140 );
          }
          v142 = 0;
          v192 = 0;
          if ( v198 > a2[50253] )
          {
            do
              v142 += 2;
            while ( v198 > a2[v142 + 50253] );
            v192 = v142;
          }
          v143 = a2[v142 + 50254];
          v144 = v143 < 0x20000 ? 6 : 16;
          v201 = v143;
          v188 = *((_BYTE *)a2 + (v143 >> v144) + 198452) + 2 * v144;
          v194 = (int)(&a2[272 * v194 + 52251] + v198);
          v145 = v198 + 1;
          v180 = &a2[12 * (v198 + v199 + 39)];
          while ( 1 )
          {
            v146 = v175 + *(_DWORD *)v194;
            v197 = v145;
            v198 = v146;
            v147 = v145 - 3;
            if ( v145 - 1 >= 5 )
              v147 = 3;
            if ( v143 >= 0x80 )
              v148 = a2[(v143 & 0xF) + 51570] + *(&a2[64 * v147 + 50802] + v188) + v198;
            else
              v148 = *(&a2[128 * v147 + 51058] + v143) + v146;
            v198 = v148;
            if ( v148 < *(v180 - 7) )
            {
              *(v180 - 7) = v148;
              *(v180 - 1) = v199;
              *v180 = v143 + 4;
              *(v180 - 5) = 0;
            }
            if ( v145 - 1 == a2[v192 + 50253] )
            {
              v149 = v69 - v143;
              v150 = v145 + a2[11];
              v151 = v149 - 1;
              v203 = v145;
              v200 = v150;
              if ( v150 > v195 )
              {
                v150 = v195;
                v200 = v195;
              }
              if ( v145 < v150 )
              {
                v152 = v69 - v151;
                for ( j = (_BYTE *)(v151 + v145); j[v152] == *j; ++j )
                {
                  if ( ++v203 >= v200 )
                    break;
                  v152 = v69 - v151;
                }
              }
              v203 += -1 - (v145 - 1);
              if ( v203 >= 2 )
              {
                v154 = (v181 + v145 - 1) & a2[22];
                v155 = sub_100250D0(
                         *(_BYTE *)(v151 + v145 - 1),
                         *(_BYTE *)(v69 + v145 - 1),
                         a2[24]
                       + 1536
                       * (((a2[21] & (v181 + v145 - 1)) << a2[18])
                        + ((unsigned int)*(_BYTE *)(v69 + v145 - 2) >> (8 - a2[18]))),
                         (int)(a2 + 50125));
                v156 = dword_100A1440[v193];
                v157 = v156;
                v158 = dword_100A1410[v156];
                v159 = a2[((unsigned int)*((_WORD *)a2 + v154 + 16 * v157 + 103172) >> 4) + 50125] + v155;
                v160 = a2[22] & (v154 + 1);
                v161 = *((_WORD *)a2 + v158 + 103364) ^ 0x7F0;
                v162 = v160 + 16 * v158;
                v184 = v162;
                v177 = v158;
                v163 = a2[((*((_WORD *)a2 + v162 + 103172) ^ 0x7F0u) >> 4) + 50125];
                v145 = v197;
                v164 = v198 + v159 + a2[(v161 >> 4) + 50125] + v163;
                v165 = v203 + v197 - 1 + v199 + 1;
                v166 = v196;
                v191 = v165;
                if ( v196 < v165 )
                {
                  v167 = v165 - v196;
                  v196 += v167;
                  v168 = &a2[12 * v166 + 461];
                  do
                  {
                    v168 += 12;
                    --v167;
                    *v168 = 0x40000000;
                  }
                  while ( v167 );
                }
                v69 = v190;
                v169 = v164
                     + *(&a2[272 * v160 + 56877] + v203)
                     + a2[((unsigned int)*((_WORD *)a2 + v177 + 103376) >> 4) + 50125]
                     + a2[((*((_WORD *)a2 + v184 + 103412) ^ 0x7F0u) >> 4) + 50125];
                v170 = (int)&a2[12 * v191 + 461];
                if ( v169 < *(_DWORD *)v170 )
                {
                  *(_DWORD *)v170 = v169;
                  v171 = v145 + v199;
                  *(_DWORD *)(v170 + 16) = v199;
                  v172 = v201;
                  *(_DWORD *)(v170 + 24) = v171;
                  *(_DWORD *)(v170 + 28) = 0;
                  *(_DWORD *)(v170 + 8) = 1;
                  *(_DWORD *)(v170 + 12) = 1;
                  *(_DWORD *)(v170 + 20) = v172 + 4;
                }
              }
              v173 = v192 + 2;
              v192 = v173;
              if ( (char *)v173 == v189 )
                break;
              v143 = a2[v173 + 50254];
              v201 = v143;
              if ( v143 >= 0x80 )
                v188 = *((_BYTE *)a2 + (v143 >> (v143 < 0x20000 ? 6 : 16)) + 198452) + 2 * (v143 < 0x20000 ? 6 : 16);
            }
            v194 += 4;
            v180 += 12;
            ++v145;
          }
        }
      }
      v50 = ++v199;
      if ( v199 == v196 )
        return sub_100256D0(v50, (int)a2, v178);
    }
    if ( *(_DWORD *)(v54 + 1852) && *(_DWORD *)(v54 + 1856) )
    {
      v57 = *(_DWORD *)(v54 + 1864);
      v53 = *(_DWORD *)(v54 + 1860);
      v58 = dword_100A1470[v56];
      v203 = *(_DWORD *)(v54 + 1864);
    }
    else
    {
      v203 = *(_DWORD *)(v54 + 1872);
      if ( v203 < 4 )
      {
        v193 = dword_100A1470[v56];
        v57 = v203;
        goto LABEL_91;
      }
      v58 = dword_100A1440[v56];
      v57 = v203;
    }
    v193 = v58;
LABEL_91:
    v59 = 6 * v53;
    v60 = (int)&a2[2 * v59 + 461];
    if ( v57 >= 4 )
    {
      v78 = a2[2 * v59 + 470];
      v206 = v57 - 4;
      v207 = *(_DWORD *)(v60 + 32);
      v79 = *(_DWORD *)(v60 + 40);
      v208 = v78;
      v209 = v79;
    }
    else
    {
      v206 = *(_DWORD *)(v60 + 4 * v57 + 32);
      v61 = 1;
      if ( v57 < 1 || (v61 = v203 + 1, qmemcpy(&v207, (const void *)(v60 + 32), 4 * v57), v61 < 4) )
        qmemcpy(&v206 + v61, (const void *)(v60 + 4 * v61 + 32), 4 * (4 - v61));
      v54 = v194;
    }
    goto LABEL_96;
  }
  *v178 = a2[v198 + 50252] + 4;
  v20 = result - 1;
  if ( result != 1 )
  {
    v21 = *a2;
    a2[12] += v20;
    ((void (__cdecl *)(int, int))a2[5])(v21, v20);
    result = v203;
  }
  return result;
}
// 100A1410: using guessed type int dword_100A1410[];
// 100A1440: using guessed type int dword_100A1440[];
// 100A1470: using guessed type int dword_100A1470[];
// 100A14A0: using guessed type int dword_100A14A0[];
// 100257C0: using guessed type int var_24[4];

//----- (10026960) --------------------------------------------------------
signed int __cdecl sub_10026960(_DWORD *a1, unsigned int *a2)
{
  int *v2; // esi@1
  unsigned int v3; // edx@3
  unsigned int v4; // eax@4
  signed int result; // eax@5
  int v6; // eax@8
  unsigned int v7; // edx@8
  _BYTE *v8; // ecx@9
  unsigned int v9; // edi@11
  _BYTE *v10; // edx@12
  int v11; // ecx@12
  unsigned int v12; // ebx@16
  unsigned int v13; // ecx@17
  int v14; // edx@25
  unsigned int *v15; // eax@29
  unsigned int v16; // edx@32
  int v17; // ecx@43
  int v18; // edx@44
  void (__cdecl *v19)(int, int); // eax@44
  unsigned int v20; // eax@47
  unsigned int v21; // edx@48
  unsigned int v22; // ecx@50
  bool v23; // cf@50
  bool v24; // zf@50
  int v25; // eax@57
  _BYTE *v26; // ecx@58
  unsigned int v27; // esi@60
  unsigned int v28; // edi@60
  _BYTE *v29; // edx@61
  int v30; // ecx@61
  int v31; // edx@70
  unsigned int v32; // [sp+8h] [bp-1Ch]@8
  _DWORD *v33; // [sp+Ch] [bp-18h]@8
  _DWORD *v34; // [sp+Ch] [bp-18h]@57
  unsigned int v35; // [sp+10h] [bp-14h]@4
  unsigned int v36; // [sp+14h] [bp-10h]@8
  unsigned int v37; // [sp+18h] [bp-Ch]@8
  unsigned int v38; // [sp+18h] [bp-Ch]@57
  unsigned int v39; // [sp+1Ch] [bp-8h]@2
  int v40; // [sp+20h] [bp-4h]@2

  v2 = a1;
  if ( a1[12] )
  {
    v3 = a1[9];
    v40 = a1[8];
    v39 = v3;
  }
  else
  {
    v40 = sub_10025570(a1, (int *)&v39);
  }
  v35 = a1[10];
  v4 = a1[10];
  *a2 = -1;
  if ( v4 < 2 )
    return 1;
  if ( v4 > 0x111 )
    v35 = 273;
  v6 = ((int (__stdcall *)(_DWORD))a1[3])(*a1) - 1;
  v7 = 0;
  v32 = 0;
  v36 = 0;
  v37 = 0;
  v33 = a1 + 13;
  while ( 1 )
  {
    v8 = (_BYTE *)(v6 - *v33 - 1);
    if ( *(_BYTE *)v6 == *v8 && *(_BYTE *)(v6 + 1) == *(_BYTE *)(v6 - *v33) )
      break;
    v13 = v39;
    v12 = v40;
LABEL_20:
    ++v33;
    v37 = ++v7;
    if ( v7 >= 4 )
    {
      if ( v12 >= a1[11] )
      {
        *a2 = a1[v13 + 50252] + 4;
        if ( v12 != 1 )
        {
          a1[12] += v12 - 1;
          ((void (__cdecl *)(_DWORD, unsigned int))a1[5])(*a1, v12 - 1);
          return v12;
        }
        return v12;
      }
      v39 = 0;
      if ( v12 >= 2 )
      {
        v39 = a1[v13 + 50252];
        if ( v13 > 2 )
        {
          v15 = &a1[v13 + 50250];
          do
          {
            if ( v12 != *(v15 - 1) + 1 )
              break;
            if ( v39 >> 7 <= *v15 )
              break;
            v16 = *v15;
            v12 = *(v15 - 1);
            v15 -= 2;
            v13 -= 2;
            v39 = v16;
          }
          while ( v13 > 2 );
          v40 = v12;
        }
        if ( v12 == 2 && v39 >= 0x80 )
        {
          v12 = 1;
          v40 = 1;
        }
      }
      result = v36;
      if ( v36 >= 2 && (v36 + 1 >= v12 || v36 + 2 >= v12 && v39 >= 0x200 || v36 + 3 >= v12 && v39 >= 0x8000) )
      {
        *a2 = v32;
        v17 = v36 - 1;
        if ( v36 != 1 )
        {
          v18 = *a1;
          v19 = (void (__cdecl *)(int, int))a1[5];
          a1[12] += v17;
          v19(v18, v17);
          result = v36;
        }
        return result;
      }
      if ( v12 >= 2 && v35 > 2 )
      {
        v20 = sub_10025570(a1, a1 + 9);
        a1[8] = v20;
        if ( v20 < 2 )
          goto LABEL_57;
        v21 = a1[a1[9] + 50252];
        if ( v20 < v12 || v21 >= v39 )
        {
          v22 = v12 + 1;
          v23 = v20 < v12 + 1;
          v24 = v20 == v12 + 1;
          if ( v20 == v12 + 1 )
          {
            if ( v21 >> 7 <= v39 )
              return 1;
            v23 = v20 < v22;
            v24 = v20 == v22;
          }
          if ( (v23 || v24) && (v20 + 1 < v12 || v12 < 3 || v39 >> 7 <= v21) )
          {
LABEL_57:
            v25 = ((int (__cdecl *)(_DWORD))a1[3])(*a1) - 1;
            v38 = 0;
            v34 = a1 + 13;
            do
            {
              v26 = (_BYTE *)(v25 - *v34 - 1);
              if ( *(_BYTE *)v25 == *v26 && *(_BYTE *)(v25 + 1) == *(_BYTE *)(v25 - *v34) )
              {
                v27 = v12 - 1;
                v28 = 2;
                if ( v12 - 1 <= 2 )
                  return 1;
                v29 = (_BYTE *)(v25 + 2);
                v30 = (int)&v26[-v25];
                while ( *v29 == v29[v30] )
                {
                  ++v28;
                  ++v29;
                  if ( v28 >= v27 )
                    return 1;
                }
                if ( v28 >= v27 )
                  return 1;
                v12 = v40;
                v2 = a1;
              }
              ++v34;
              ++v38;
            }
            while ( v38 < 4 );
            *a2 = v39 + 4;
            if ( v12 != 2 )
            {
              v31 = *v2;
              v2[12] += v12 - 2;
              ((void (__cdecl *)(int, unsigned int))v2[5])(v31, v12 - 2);
            }
            return v12;
          }
        }
      }
      return 1;
    }
  }
  v9 = 2;
  if ( v35 > 2 )
  {
    v10 = (_BYTE *)(v6 + 2);
    v11 = (int)&v8[-v6];
    do
    {
      if ( *v10 != v10[v11] )
        break;
      ++v9;
      ++v10;
    }
    while ( v9 < v35 );
    v7 = v37;
  }
  v12 = v40;
  if ( v9 < a1[11] )
  {
    v13 = v39;
    if ( v9 > v36 )
    {
      v32 = v7;
      v36 = v9;
    }
    goto LABEL_20;
  }
  *a2 = v7;
  if ( v9 != 1 )
  {
    v14 = *a1;
    a1[12] += v9 - 1;
    ((void (__cdecl *)(int, unsigned int))a1[5])(v14, v9 - 1);
  }
  return v9;
}

//----- (10026C60) --------------------------------------------------------
int __usercall sub_10026C60@<eax>(int a1@<eax>, int a2)
{
  int v2; // ebx@1
  int v3; // edx@1
  _WORD *v4; // esi@1
  unsigned int v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@1
  unsigned int v8; // eax@1
  int v9; // edx@3
  int v10; // eax@3
  bool v11; // zf@5
  int v12; // ST24_4@5

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 152);
  v4 = (_WORD *)(a1 + 2 * (a2 + 16 * *(_DWORD *)(a1 + 68)) + 206344);
  v5 = *v4;
  v6 = v2 + 152;
  v7 = v5 * (*(_DWORD *)(v2 + 152) >> 11);
  *(_QWORD *)(v6 + 8) = (unsigned int)v7 + *(_QWORD *)(v2 + 160);
  *(_DWORD *)v6 = v3 - v7;
  *v4 = v5 - (v5 >> 5);
  v8 = *(_DWORD *)(v2 + 152);
  if ( v8 < 0x1000000 )
  {
    *(_DWORD *)v6 = v8 << 8;
    sub_10024C60(v2 + 152);
  }
  v9 = *(_DWORD *)(v2 + 68);
  v10 = *(_WORD *)(v2 + 2 * v9 + 206728);
  *(_DWORD *)v6 = v10 * (*(_DWORD *)v6 >> 11);
  *(_WORD *)(v2 + 2 * v9 + 206728) = v10 + ((unsigned int)(2048 - v10) >> 5);
  if ( *(_DWORD *)v6 < 0x1000000u )
  {
    *(_DWORD *)v6 <<= 8;
    sub_10024C60(v2 + 152);
  }
  v11 = *(_DWORD *)(v2 + 100) == 0;
  *(_DWORD *)(v2 + 68) = dword_100A1440[*(_DWORD *)(v2 + 68)];
  v12 = v11;
  sub_10025240(a2, (_WORD *)(v2 + 207980), (unsigned int *)(v2 + 152), 0);
  if ( v12 )
  {
    v11 = (*(_DWORD *)(v2 + 4 * a2 + 226420))-- == 1;
    if ( v11 )
    {
      sub_10025390(v2 + 200500, v2 + 207980, a2, *(_DWORD *)(v2 + 209008), 1088 * a2 + v2 + 207980 + 1032);
      *(_DWORD *)(v2 + 4 * a2 + 226420) = *(_DWORD *)(v2 + 209008);
    }
  }
  sub_10025130(v2 + 152, 6, v2 + 207208, 0x3Fu);
  sub_10024DE0(v2 + 152, 0x3FFFFFFu, 26);
  return sub_100251C0(4, v6, v2 + 207948, 0xFu);
}
// 100A1440: using guessed type int dword_100A1440[];

//----- (10026DC0) --------------------------------------------------------
int __thiscall sub_10026DC0(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 144);
  if ( !result )
  {
    if ( *(_DWORD *)(this + 200) )
      *(_DWORD *)(this + 144) = 9;
    if ( *(_DWORD *)(this + 684) )
      *(_DWORD *)(this + 144) = 8;
    result = *(_DWORD *)(this + 144);
    if ( result )
      *(_DWORD *)(this + 108) = 1;
  }
  return result;
}

//----- (10026E10) --------------------------------------------------------
int __usercall sub_10026E10@<eax>(int a1@<edi>, int a2)
{
  bool v2; // zf@1
  int v3; // ebx@4
  unsigned __int8 v4; // cf@6
  int result; // eax@7

  v2 = *(_DWORD *)(a1 + 104) == 0;
  *(_DWORD *)(a1 + 108) = 1;
  if ( !v2 )
    sub_10026C60(a1, a2 & *(_DWORD *)(a1 + 88));
  sub_10024D10(a1 + 152);
  if ( !*(_DWORD *)(a1 + 200) )
  {
    v3 = *(_DWORD *)(a1 + 176) - *(_DWORD *)(a1 + 184);
    if ( v3 != (**(int (__cdecl ***)(_DWORD, _DWORD, _DWORD))(a1 + 188))(
                 *(_DWORD *)(a1 + 188),
                 *(_DWORD *)(a1 + 184),
                 v3) )
      *(_DWORD *)(a1 + 200) = 9;
    v4 = __CFADD__(v3, *(_DWORD *)(a1 + 192));
    *(_DWORD *)(a1 + 192) += v3;
    *(_DWORD *)(a1 + 176) = *(_DWORD *)(a1 + 184);
    *(_DWORD *)(a1 + 196) += v4;
  }
  result = *(_DWORD *)(a1 + 144);
  if ( !result )
  {
    if ( *(_DWORD *)(a1 + 200) )
      *(_DWORD *)(a1 + 144) = 9;
    if ( *(_DWORD *)(a1 + 684) )
      *(_DWORD *)(a1 + 144) = 8;
    result = *(_DWORD *)(a1 + 144);
    if ( result )
      *(_DWORD *)(a1 + 108) = 1;
  }
  return result;
}

//----- (10026EC0) --------------------------------------------------------
int __cdecl sub_10026EC0(int a1)
{
  int v1; // edi@1
  unsigned int v2; // esi@1
  int v3; // edx@2
  int v4; // ecx@2
  int v5; // eax@3
  unsigned int v6; // ebx@3
  int result; // eax@4
  _DWORD *v8; // [sp+Ch] [bp-Ch]@1
  unsigned int v9; // [sp+10h] [bp-8h]@1
  signed int v10; // [sp+14h] [bp-4h]@2

  v1 = a1;
  v2 = 0;
  v9 = 0;
  v8 = (_DWORD *)(a1 + 206280);
  do
  {
    v3 = 0;
    v4 = 1;
    v10 = 4;
    do
    {
      v5 = v2 & 1;
      v6 = (-v5 >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(v1 + 2 * v4 + 207948) >> 4);
      v1 = a1;
      v3 += *(_DWORD *)(a1 + 4 * v6 + 200500);
      v2 >>= 1;
      v4 = v5 | 2 * v4;
      --v10;
    }
    while ( v10 );
    v2 = v9 + 1;
    *v8 = v3;
    result = (int)(v8 + 1);
    v9 = v2;
    ++v8;
  }
  while ( v2 < 0x10 );
  *(_DWORD *)(a1 + 132) = 0;
  return result;
}

//----- (10026F50) --------------------------------------------------------
unsigned int __fastcall sub_10026F50(int a1, int a2)
{
  unsigned int v2; // edi@1
  unsigned int v3; // ebx@2
  int v4; // esi@2
  unsigned int v5; // edi@2
  int v6; // eax@5
  bool v7; // zf@5
  int v8; // ebx@7
  char *v9; // esi@7
  int v10; // edi@7
  unsigned int v11; // ecx@8
  unsigned int v12; // eax@9
  int v13; // esi@9
  unsigned int i; // eax@14
  unsigned int result; // eax@16
  int *v16; // ecx@16
  int v17; // ebx@17
  unsigned int v18; // [sp+Ch] [bp-218h]@2
  signed int v19; // [sp+Ch] [bp-218h]@7
  int v20; // [sp+10h] [bp-214h]@2
  unsigned int v21; // [sp+10h] [bp-214h]@8
  int v22; // [sp+14h] [bp-210h]@2
  char *v23; // [sp+14h] [bp-210h]@7
  int v24; // [sp+18h] [bp-20Ch]@2
  int v25; // [sp+18h] [bp-20Ch]@7
  signed int v26; // [sp+1Ch] [bp-208h]@1
  int v27; // [sp+1Ch] [bp-208h]@7
  int v28[128]; // [sp+20h] [bp-204h]@6

  v2 = 4;
  v26 = 4;
  do
  {
    v3 = *(_BYTE *)(a2 + v2 + 198452);
    v4 = (*(_BYTE *)(a2 + v2 + 198452) & 1 | 2) << ((*(_BYTE *)(a2 + v2 + 198452) >> 1) - 1);
    v18 = *(_BYTE *)(a2 + v2 + 198452);
    v24 = 0;
    v22 = 1;
    v5 = v2 - v4;
    v20 = (v3 >> 1) - 1;
    if ( v3 >> 1 != 1 )
    {
      while ( 1 )
      {
        v6 = v5 & 1;
        v24 += *(_DWORD *)(a2
                         + 4 * ((-v6 >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(a2 + 2 * (v4 + v22 - v3) + 207718) >> 4))
                         + 200500);
        v5 >>= 1;
        v7 = v20-- == 1;
        v22 = v6 | 2 * v22;
        if ( v7 )
          break;
        v3 = v18;
      }
    }
    v28[v26] = v24;
    v2 = v26 + 1;
    v26 = v2;
  }
  while ( v2 < 0x80 );
  v8 = a2 + 204240;
  v9 = (char *)&v28[-51058] - a2;
  v10 = a2 + 203208;
  v27 = a2 + 207208;
  v25 = a2 + 204240;
  v23 = (char *)&v28[-51058] - a2;
  v19 = 4;
  do
  {
    v11 = 0;
    v21 = 0;
    if ( *(_DWORD *)(a2 + 136) )
    {
      do
      {
        v12 = v11 | 0x40;
        v13 = 0;
        if ( (v11 | 0x40) != 1 )
        {
          do
          {
            v13 += *(_DWORD *)(a2
                             + 4
                             * (((signed int)-(v12 & 1) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(v27 + 2 * (v12 >> 1)) >> 4))
                             + 200500);
            v12 >>= 1;
          }
          while ( v12 != 1 );
          v8 = v25;
          v11 = v21;
        }
        *(_DWORD *)(v10 + 4 * v11++) = v13;
        v21 = v11;
      }
      while ( v11 < *(_DWORD *)(a2 + 136) );
      v9 = v23;
    }
    for ( i = 14; i < *(_DWORD *)(a2 + 136); ++i )
      *(_DWORD *)(v10 + 4 * i) += 16 * ((i >> 1) - 5);
    *(_DWORD *)(v8 - 8) = *(_DWORD *)v10;
    *(_DWORD *)(v8 - 4) = *(_DWORD *)(v10 + 4);
    *(_DWORD *)v8 = *(_DWORD *)(v10 + 8);
    *(_DWORD *)(v8 + 4) = *(_DWORD *)(v10 + 12);
    result = 4;
    v16 = (int *)(v8 + 8);
    do
    {
      v17 = *(int *)((char *)v16 + (_DWORD)v9) + *(_DWORD *)(v10 + 4 * *(_BYTE *)(a2 + result++ + 198452));
      *v16 = v17;
      ++v16;
    }
    while ( result < 0x80 );
    v27 += 128;
    v8 = v25 + 512;
    v9 -= 512;
    v10 += 256;
    v7 = v19-- == 1;
    v25 += 512;
    v23 = v9;
  }
  while ( !v7 );
  *(_DWORD *)(a2 + 128) = 0;
  return result;
}
// 10026F50: using guessed type int var_204[128];

//----- (100271A0) --------------------------------------------------------
int __usercall sub_100271A0@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // edi@1
  int result; // eax@1
  int v4; // [sp+10h] [bp-38h]@1
  int v5; // [sp+14h] [bp-34h]@1
  int v6; // [sp+18h] [bp-30h]@1
  int v7; // [sp+1Ch] [bp-2Ch]@1
  int v8; // [sp+20h] [bp-28h]@1
  int v9; // [sp+24h] [bp-24h]@1
  int v10; // [sp+28h] [bp-20h]@1
  int v11; // [sp+2Ch] [bp-1Ch]@1
  int v12; // [sp+30h] [bp-18h]@1
  int v13; // [sp+34h] [bp-14h]@1
  int v14; // [sp+38h] [bp-10h]@1
  int v15; // [sp+3Ch] [bp-Ch]@1
  int v16; // [sp+40h] [bp-8h]@1
  int v17; // [sp+44h] [bp-4h]@1

  v1 = a1;
  v2 = a1 + 592;
  *(_DWORD *)(a1 + 188) = 0;
  *(_DWORD *)(a1 + 184) = 0;
  sub_10028340(a1 + 592);
  *(_DWORD *)(v1 + 460) = 0;
  *(_DWORD *)(v1 + 508) = 0;
  *(_DWORD *)(v1 + 548) = 0;
  *(_DWORD *)(v1 + 552) = 0;
  *(_DWORD *)(v1 + 524) = 0;
  *(_DWORD *)(v1 + 528) = 0;
  *(_DWORD *)(v1 + 532) = 0;
  *(_DWORD *)(v1 + 536) = 0;
  *(_DWORD *)(v1 + 540) = 0;
  *(_DWORD *)(v1 + 544) = 0;
  v6 = -1;
  v7 = -1;
  v17 = -1;
  v14 = -1;
  v13 = -1;
  v12 = -1;
  v11 = -1;
  v10 = -1;
  v9 = -1;
  v8 = -1;
  *(_DWORD *)(v1 + 256) = 0;
  *(_DWORD *)(v1 + 296) = 0;
  *(_DWORD *)(v1 + 300) = 0;
  *(_DWORD *)(v1 + 272) = 0;
  *(_DWORD *)(v1 + 276) = 0;
  *(_DWORD *)(v1 + 280) = 0;
  *(_DWORD *)(v1 + 284) = 0;
  *(_DWORD *)(v1 + 288) = 0;
  *(_DWORD *)(v1 + 292) = 0;
  *(_DWORD *)(v1 + 588) = v2;
  v4 = 5;
  v15 = 0;
  v5 = 0;
  v16 = 0;
  sub_10024B60(&v4, v1);
  sub_10024B20((_WORD *)(v1 + 198452));
  result = sub_10025040(v1 + 200500);
  *(_DWORD *)(v1 + 96) = 0;
  *(_DWORD *)(v1 + 244988) = 0;
  return result;
}

//----- (100272A0) --------------------------------------------------------
int __usercall sub_100272A0@<eax>(int a1@<esi>)
{
  int result; // eax@3

  sub_10029400(a1 + 508);
  sub_10029400(a1 + 256);
  off_100ADF90(&off_100ADF8C, *(_DWORD *)(a1 + 460));
  *(_DWORD *)(a1 + 460) = 0;
  off_100ADF90(&off_100ADF8C, *(_DWORD *)(a1 + 628));
  *(_DWORD *)(a1 + 628) = 0;
  if ( !*(_BYTE *)(a1 + 623) )
  {
    off_100ADF90(&off_100ADF8C, *(_DWORD *)(a1 + 644));
    *(_DWORD *)(a1 + 644) = 0;
  }
  off_100ADF90(&off_100ADF8C, *(_DWORD *)(a1 + 96));
  off_100ADF90(&off_100ADF8C, *(_DWORD *)(a1 + 244988));
  *(_DWORD *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 244988) = 0;
  result = off_100ADF90(&off_100ADF8C, *(_DWORD *)(a1 + 184));
  *(_DWORD *)(a1 + 184) = 0;
  return result;
}
// 100ADF8C: using guessed type int (__cdecl *off_100ADF8C)(_DWORD, _DWORD);
// 100ADF90: using guessed type int (__cdecl *off_100ADF90)(_DWORD, _DWORD);

//----- (10027360) --------------------------------------------------------
int __usercall sub_10027360@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v1; // ebx@1
  int result; // eax@3
  int v3; // esi@11
  bool v4; // zf@11
  _WORD *v5; // ecx@13
  int v6; // eax@13
  _DWORD *v7; // esi@13
  unsigned int v8; // eax@13
  int (__cdecl *v9)(int); // eax@15
  int v10; // ST0C_4@15
  int v11; // eax@15
  signed int v12; // eax@20
  int v13; // esi@22
  int v14; // edx@24
  int v15; // eax@24
  _DWORD *v16; // esi@24
  unsigned int v17; // eax@24
  char *v18; // edi@26
  int v19; // eax@26
  unsigned int v20; // edx@26
  int v21; // ecx@26
  int v22; // edx@26
  unsigned int v23; // edx@29
  _WORD *v24; // eax@29
  unsigned int v25; // eax@29
  int v26; // ecx@29
  unsigned int v27; // eax@29
  unsigned int v28; // edx@31
  _WORD *v29; // eax@32
  unsigned int v30; // eax@32
  int v31; // ecx@32
  unsigned int v32; // eax@32
  _WORD *v33; // ecx@35
  int v34; // eax@35
  unsigned int v35; // eax@35
  _WORD *v36; // eax@38
  unsigned int v37; // edx@38
  unsigned int v38; // eax@38
  int v39; // ecx@38
  unsigned int v40; // eax@38
  int v41; // eax@40
  unsigned int v42; // edx@40
  _WORD *v43; // ecx@41
  int v44; // eax@41
  unsigned int v45; // eax@41
  _WORD *v46; // esi@43
  unsigned int v47; // eax@43
  int v48; // ecx@43
  unsigned int v49; // eax@43
  int v50; // ecx@49
  int v51; // edi@52
  int v52; // ecx@56
  int v53; // eax@56
  unsigned int v54; // eax@56
  unsigned int v55; // eax@58
  unsigned int v56; // eax@61
  unsigned int v57; // esi@62
  signed int v58; // ecx@63
  int v59; // eax@65
  int v60; // edx@68
  unsigned int v61; // ecx@68
  int v62; // ecx@71
  int v63; // edx@71
  int v64; // eax@71
  unsigned int v65; // ecx@71
  int v66; // ecx@72
  int v67; // eax@72
  int v68; // [sp+4h] [bp-20h]@13
  _WORD *v69; // [sp+8h] [bp-1Ch]@29
  int v70; // [sp+Ch] [bp-18h]@11
  unsigned int v71; // [sp+10h] [bp-14h]@22
  int v72; // [sp+14h] [bp-10h]@11
  unsigned int v73; // [sp+18h] [bp-Ch]@20
  int v74; // [sp+1Ch] [bp-8h]@22
  unsigned __int8 v75; // [sp+23h] [bp-1h]@26

  v1 = a1;
  if ( a1[29] )
  {
    ((void (__cdecl *)(_DWORD))a1[1])(*a1);
    v1[29] = 0;
  }
  result = v1[36];
  if ( v1[27] || result )
    return result;
  if ( v1[50] )
    v1[36] = 9;
  if ( v1[171] )
    v1[36] = 8;
  result = v1[36];
  if ( result )
  {
    v1[27] = 1;
    return result;
  }
  v3 = v1[30];
  v4 = *((_QWORD *)v1 + 15) == 0i64;
  v72 = v3;
  v70 = v3;
  if ( v4 )
  {
    if ( !((int (__cdecl *)(_DWORD))v1[2])(*v1) )
      return sub_10026E10((int)v1, v3);
    sub_10025570(v1, &v68);
    v5 = &v1[8 * v1[17] + 51586];
    v6 = *v5;
    v7 = v1 + 38;
    v1[38] = v6 * (v1[38] >> 11);
    *v5 = v6 + ((unsigned int)(2048 - v6) >> 5);
    v8 = v1[38];
    if ( v8 < 0x1000000 )
    {
      *v7 = v8 << 8;
      sub_10024C60((int)v7);
    }
    v9 = (int (__cdecl *)(int))v1[3];
    v10 = *v1;
    v1[17] = dword_100A1410[v1[17]];
    v11 = v9(v10);
    sub_10024F20(*(_BYTE *)(v11 - v1[12]), (int)(v1 + 38), v1[24]);
    --v1[12];
    v3 = ++v72;
  }
  if ( !((int (__cdecl *)(_DWORD))v1[2])(*v1) )
    goto LABEL_82;
  while ( 1 )
  {
    if ( v1[25] )
      v12 = sub_10026960(v1, &v73);
    else
      v12 = sub_100257C0(&v73, v1, v3);
    v13 = v72 & v1[22];
    v71 = v12;
    v74 = v13;
    if ( v12 == 1 && v73 == -1 )
    {
      v14 = v13 + 16 * v1[17];
      v15 = *((_WORD *)v1 + v14 + 103172);
      v16 = v1 + 38;
      v1[38] = v15 * (v1[38] >> 11);
      *((_WORD *)v1 + v14 + 103172) = v15 + ((unsigned int)(2048 - v15) >> 5);
      v17 = v1[38];
      if ( v17 < 0x1000000 )
      {
        *v16 = v17 << 8;
        sub_10024C60((int)v16);
      }
      v18 = (char *)(((int (__cdecl *)(_DWORD))v1[3])(*v1) - v1[12]);
      v19 = v1[18];
      v75 = *v18;
      v20 = (unsigned int)(unsigned __int8)*(v18 - 1) >> (8 - v19);
      v74 = v72 & v1[21];
      v21 = (int)(v1 + 38);
      v22 = v1[24] + 1536 * ((v74 << v19) + v20);
      if ( v1[17] >= 7u )
      {
        sub_10024FA0(v75, v21, v22, (unsigned __int8)v18[-v1[13] - 1]);
        v1[17] = dword_100A1410[v1[17]];
      }
      else
      {
        sub_10024F20(v75, v21, v22);
        v1[17] = dword_100A1410[v1[17]];
      }
      goto LABEL_72;
    }
    v23 = v1[38];
    v24 = (_DWORD *)((char *)v1 + 2 * (v13 + 16 * v1[17]) + 206344);
    v69 = v24;
    v25 = *v24;
    v26 = v25 * (v23 >> 11);
    *((_QWORD *)v1 + 20) += (unsigned int)v26;
    v1[38] = v23 - v26;
    *v69 = v25 - (v25 >> 5);
    v27 = v1[38];
    if ( v27 < 0x1000000 )
    {
      v1[38] = v27 << 8;
      sub_10024C60((int)(v1 + 38));
      v13 = v74;
    }
    v28 = v1[38];
    if ( v73 < 4 )
    {
      v29 = (_DWORD *)((char *)v1 + 2 * v1[17] + 206728);
      v69 = v29;
      v30 = *v29;
      v31 = v30 * (v28 >> 11);
      *((_QWORD *)v1 + 20) += (unsigned int)v31;
      v1[38] = v28 - v31;
      *v69 = v30 - (v30 >> 5);
      v32 = v1[38];
      if ( v32 < 0x1000000 )
      {
        v1[38] = v32 << 8;
        sub_10024C60((int)(v1 + 38));
        v13 = v74;
      }
      if ( !v73 )
      {
        v33 = (_DWORD *)((char *)v1 + 2 * v1[17] + 206752);
        v34 = *v33;
        v1[38] = v34 * (v1[38] >> 11);
        *v33 = v34 + ((unsigned int)(2048 - v34) >> 5);
        v35 = v1[38];
        if ( v35 < 0x1000000 )
        {
          v1[38] = v35 << 8;
          sub_10024C60((int)(v1 + 38));
          v13 = v74;
        }
        sub_10024EC0(v1 + 38, (_WORD *)v1 + v13 + 16 * v1[17] + 103412, v71 != 1);
        v13 = v74;
        goto LABEL_50;
      }
      v36 = (_DWORD *)((char *)v1 + 2 * v1[17] + 206752);
      v68 = v1[v73 + 13];
      v37 = v1[38];
      v69 = v36;
      v38 = *v36;
      v39 = v38 * (v37 >> 11);
      *((_QWORD *)v1 + 20) += (unsigned int)v39;
      v1[38] = v37 - v39;
      *v69 = v38 - (v38 >> 5);
      v40 = v1[38];
      if ( v40 < 0x1000000 )
      {
        v1[38] = v40 << 8;
        sub_10024C60((int)(v1 + 38));
        v13 = v74;
      }
      v41 = v1[17];
      v42 = v1[38];
      if ( v73 == 1 )
      {
        v43 = (_DWORD *)((char *)v1 + 2 * v41 + 206776);
        v44 = *v43;
        v1[38] = v44 * (v42 >> 11);
        *v43 = v44 + ((unsigned int)(2048 - v44) >> 5);
        v45 = v1[38];
        if ( v45 >= 0x1000000 )
        {
LABEL_49:
          v50 = v68;
          v1[14] = v1[13];
          v1[13] = v50;
LABEL_50:
          if ( v71 == 1 )
          {
            v1[17] = dword_100A14A0[v1[17]];
          }
          else
          {
            v51 = (int)(v1 + 56621);
            v68 = v1[25] == 0;
            sub_10025240(v13, (_WORD *)v1 + 113242, v1 + 38, v71 - 2);
            if ( v68 )
            {
              v4 = (*(_DWORD *)(v51 + 4 * v13 + 18440))-- == 1;
              if ( v4 )
              {
                sub_10025390((int)(v1 + 50125), (int)(v1 + 56621), v74, v1[56878], 1088 * v74 + v51 + 1032);
                v1[v74 + 61231] = v1[56878];
              }
            }
            v1[17] = dword_100A1470[v1[17]];
          }
          goto LABEL_72;
        }
        v1[38] = v45 << 8;
        sub_10024C60((int)(v1 + 38));
      }
      else
      {
        v46 = (_DWORD *)((char *)v1 + 2 * v41 + 206776);
        v47 = *v46;
        v48 = v47 * (v42 >> 11);
        *((_QWORD *)v1 + 20) += (unsigned int)v48;
        v1[38] = v42 - v48;
        *v46 = v47 - (v47 >> 5);
        v49 = v1[38];
        if ( v49 < 0x1000000 )
        {
          v1[38] = v49 << 8;
          sub_10024C60((int)(v1 + 38));
        }
        sub_10024EC0(v1 + 38, (_WORD *)v1 + v1[17] + 103400, v73 - 2);
        if ( v73 == 3 )
          v1[16] = v1[15];
        v1[15] = v1[14];
      }
      v13 = v74;
      goto LABEL_49;
    }
    v52 = v1[17];
    v53 = *((_WORD *)v1 + v52 + 103364);
    v1[38] = v53 * (v28 >> 11);
    *((_WORD *)v1 + v52 + 103364) = v53 + ((unsigned int)(2048 - v53) >> 5);
    v54 = v1[38];
    if ( v54 < 0x1000000 )
    {
      v1[38] = v54 << 8;
      sub_10024C60((int)(v1 + 38));
      v13 = v74;
    }
    v55 = v71;
    v4 = v1[25] == 0;
    v1[17] = dword_100A1440[v1[17]];
    v68 = v4;
    sub_10025240(v13, (_WORD *)v1 + 103990, v1 + 38, v55 - 2);
    if ( v68 )
    {
      v4 = v1[v13 + 56605]-- == 1;
      if ( v4 )
      {
        sub_10025390((int)(v1 + 50125), (int)(v1 + 51995), v74, v1[52252], (int)&v1[272 * v74 + 52253]);
        v1[v74 + 56605] = v1[52252];
      }
    }
    v56 = v73 - 4;
    v73 = v56;
    if ( v56 >= 0x80 )
    {
      v58 = v56 < 0x20000 ? 6 : 16;
      v57 = *((_BYTE *)v1 + (v56 >> v58) + 198452) + 2 * v58;
    }
    else
    {
      v57 = *((_BYTE *)v1 + v56 + 198452);
    }
    if ( v71 >= 5 )
      v59 = 3;
    else
      v59 = v71 - 2;
    sub_10025130((int)(v1 + 38), 6, (int)&v1[32 * v59 + 51802], v57);
    if ( v57 >= 4 )
    {
      v60 = (v57 & 1 | 2) << ((v57 >> 1) - 1);
      v61 = v73 - v60;
      v68 = v73 - v60;
      if ( v57 >= 0xE )
      {
        sub_10024DE0((int)(v1 + 38), v61 >> 4, (v57 >> 1) - 5);
        sub_100251C0(4, (int)(v1 + 38), (int)(v1 + 51987), v68 & 0xF);
        ++v1[33];
      }
      else
      {
        sub_100251C0((v57 >> 1) - 1, (int)(v1 + 38), (int)v1 + 2 * (v60 - v57) + 207718, v61);
      }
    }
    v62 = v1[15];
    v63 = v1[14];
    v64 = v1[13];
    ++v1[32];
    v1[16] = v62;
    v65 = v73;
    v1[15] = v63;
    v1[14] = v64;
    v1[13] = v65;
LABEL_72:
    v66 = v71;
    v1[12] -= v71;
    v67 = v1[12];
    v72 += v66;
    if ( v67 )
      goto LABEL_18;
    if ( !v1[25] )
    {
      if ( v1[32] >= 0x80u )
        sub_10026F50(v66, (int)v1);
      if ( v1[33] >= 0x10u )
        sub_10026EC0((int)v1);
    }
    if ( !((int (__cdecl *)(_DWORD))v1[2])(*v1) )
      break;
    if ( (unsigned int)(v72 - v70) >= 0x20000 )
    {
      *((_QWORD *)v1 + 15) += (unsigned int)(v72 - v70);
      return sub_10026DC0((int)v1);
    }
LABEL_18:
    v3 = v72;
  }
  v3 = v72;
LABEL_82:
  *((_QWORD *)v1 + 15) += (unsigned int)(v3 - v70);
  return sub_10026E10((int)v1, v3);
}
// 100A1410: using guessed type int dword_100A1410[];
// 100A1440: using guessed type int dword_100A1440[];
// 100A1470: using guessed type int dword_100A1470[];
// 100A14A0: using guessed type int dword_100A14A0[];

//----- (10027B80) --------------------------------------------------------
signed int __usercall sub_10027B80@<eax>(int (__cdecl **a1)(_DWORD, _DWORD)@<eax>, int a2@<esi>, int (__cdecl **a3)(_DWORD, _DWORD))
{
  int (__cdecl **v3)(_DWORD, _DWORD); // edi@1
  int v4; // eax@2
  int v5; // eax@7
  int v6; // ecx@9
  int v7; // eax@12
  int v8; // ecx@12
  unsigned int v9; // ecx@15
  bool v10; // zf@15
  signed int result; // eax@16
  int v12; // [sp+8h] [bp-4h]@9

  v3 = a1;
  if ( !*(_DWORD *)(a2 + 184) )
  {
    v4 = (*a1)(a1, 0x10000);
    *(_DWORD *)(a2 + 184) = v4;
    if ( !v4 )
      return 2;
    *(_DWORD *)(a2 + 180) = v4 + 0x10000;
  }
  v5 = *(_DWORD *)(a2 + 112) && !*(_DWORD *)(a2 + 100) && *(_BYTE *)(a2 + 621);
  v6 = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a2 + 208) = v5;
  v12 = *(_DWORD *)(a2 + 72) + *(_DWORD *)(a2 + 76);
  if ( !v6 || !*(_DWORD *)(a2 + 244988) || *(_DWORD *)(a2 + 92) != *(_DWORD *)(a2 + 72) + *(_DWORD *)(a2 + 76) )
  {
    ((int (__cdecl **)(int (__cdecl **)(_DWORD, _DWORD), int))v3)[1](v3, v6);
    ((int (__cdecl **)(int (__cdecl **)(_DWORD, _DWORD), _DWORD))v3)[1](v3, *(_DWORD *)(a2 + 244988));
    *(_DWORD *)(a2 + 96) = 0;
    *(_DWORD *)(a2 + 244988) = 0;
    *(_DWORD *)(a2 + 96) = (*v3)(v3, 2 * (768 << v12));
    v7 = (*v3)(v3, 2 * (768 << v12));
    v8 = *(_DWORD *)(a2 + 96);
    *(_DWORD *)(a2 + 244988) = v7;
    if ( v8 && v7 )
    {
      *(_DWORD *)(a2 + 92) = v12;
      goto LABEL_15;
    }
    ((int (__cdecl **)(int (__cdecl **)(_DWORD, _DWORD), int))v3)[1](v3, v8);
    v3[1](v3, *(_DWORD *)(a2 + 244988));
    *(_DWORD *)(a2 + 96) = 0;
    *(_DWORD *)(a2 + 244988) = 0;
    return 2;
  }
LABEL_15:
  v9 = *(_DWORD *)(a2 + 140);
  v10 = *(_DWORD *)(a2 + 208) == 0;
  *(_BYTE *)(a2 + 622) = v9 > 0x1000000;
  if ( v10 )
  {
    if ( sub_10028410((int)a3, a2 + 592, v9, 4096, *(_DWORD *)(a2 + 44), 273) )
    {
      *(_DWORD *)a2 = a2 + 592;
      sub_10029250(a2 + 4, a2 + 592);
      return 0;
    }
    return 2;
  }
  result = sub_10029D10(a3, *(_DWORD *)(a2 + 44), a2 + 212, v9, 4096);
  if ( !result )
  {
    *(_DWORD *)a2 = a2 + 212;
    sub_1002A3B0(a2 + 4, a2 + 212);
    result = 0;
  }
  return result;
}

//----- (10027D10) --------------------------------------------------------
int __fastcall sub_10027D10(int a1, int a2)
{
  int v2; // ecx@1
  _WORD *v3; // eax@1
  signed int v4; // esi@2
  int v5; // ecx@5
  void *v6; // edi@5
  unsigned int v7; // ecx@6
  unsigned __int8 v8; // cf@6
  char *v9; // edi@6
  int i; // ecx@6
  int v11; // ecx@9
  int result; // eax@9
  signed int v13; // [sp+Ch] [bp-4h]@1

  *(_DWORD *)(a2 + 68) = 0;
  *(_DWORD *)(a2 + 52) = 0;
  *(_DWORD *)(a2 + 56) = 0;
  *(_DWORD *)(a2 + 60) = 0;
  *(_DWORD *)(a2 + 64) = 0;
  *(_DWORD *)(a2 + 176) = *(_DWORD *)(a2 + 184);
  *(_DWORD *)(a2 + 160) = 0;
  *(_DWORD *)(a2 + 164) = 0;
  *(_DWORD *)(a2 + 152) = -1;
  *(_DWORD *)(a2 + 168) = 1;
  *(_DWORD *)(a2 + 172) = 0;
  *(_BYTE *)(a2 + 156) = 0;
  *(_DWORD *)(a2 + 192) = 0;
  *(_DWORD *)(a2 + 196) = 0;
  *(_DWORD *)(a2 + 200) = 0;
  v2 = a2 + 206752;
  v3 = (_WORD *)(a2 + 206824);
  v13 = 12;
  do
  {
    v4 = 16;
    do
    {
      *(v3 - 240) = 1024;
      *v3 = 1024;
      ++v3;
      --v4;
    }
    while ( v4 );
    *(_WORD *)(v2 - 24) = 1024;
    *(_WORD *)v2 = 1024;
    *(_WORD *)(v2 + 24) = 1024;
    *(_WORD *)(v2 + 48) = 1024;
    v2 += 2;
    --v13;
  }
  while ( v13 );
  v5 = *(_DWORD *)(a2 + 76) + *(_DWORD *)(a2 + 72);
  v6 = *(void **)(a2 + 96);
  if ( (unsigned int)(768 << v5) > 0 )
  {
    v7 = 768 << v5;
    v8 = v7 & 1;
    v7 >>= 1;
    memset32(v6, 1024, v7);
    v9 = (char *)v6 + 4 * v7;
    for ( i = v8; i; --i )
    {
      *(_WORD *)v9 = 1024;
      v9 += 2;
    }
  }
  memset32((void *)(a2 + 207208), 67109888, 0x80u);
  memset32((void *)(a2 + 207720), 67109888, 0x39u);
  *(_DWORD *)(a2 + 207980) = 67109888;
  memset32((void *)(a2 + 207984), 67109888, 0x40u);
  memset32((void *)(a2 + 208240), 67109888, 0x40u);
  memset32((void *)(a2 + 208496), 67109888, 0x80u);
  *(_DWORD *)(a2 + 226484) = 67109888;
  memset32((void *)(a2 + 226488), 67109888, 0x40u);
  memset32((void *)(a2 + 226744), 67109888, 0x40u);
  memset32((void *)(a2 + 227000), 67109888, 0x80u);
  *(_DWORD *)(a2 + 207948) = 67109888;
  *(_DWORD *)(a2 + 207952) = 67109888;
  *(_DWORD *)(a2 + 207956) = 67109888;
  *(_DWORD *)(a2 + 207960) = 67109888;
  *(_DWORD *)(a2 + 207964) = 67109888;
  *(_DWORD *)(a2 + 207968) = 67109888;
  *(_DWORD *)(a2 + 207972) = 67109888;
  *(_DWORD *)(a2 + 207976) = 67109888;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  v11 = *(_DWORD *)(a2 + 76);
  *(_DWORD *)(a2 + 88) = (1 << *(_DWORD *)(a2 + 80)) - 1;
  *(_DWORD *)(a2 + 48) = 0;
  result = (1 << v11) - 1;
  *(_DWORD *)(a2 + 84) = result;
  return result;
}

//----- (10027F50) --------------------------------------------------------
signed int __usercall sub_10027F50@<eax>(int a1@<eax>, int (__cdecl **a2)(_DWORD, _DWORD), int (__cdecl **a3)(_DWORD, _DWORD))
{
  int v3; // esi@1
  unsigned int v4; // edx@1
  unsigned int v5; // ecx@1
  unsigned int v6; // eax@1
  unsigned int v7; // eax@3
  unsigned int v8; // eax@4
  signed int result; // eax@9
  int v10; // ecx@9
  int v11; // edx@10
  int v12; // ecx@10
  int v13; // ecx@12
  int v14; // eax@12

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 140);
  v5 = 0;
  v6 = 1;
  while ( v4 > v6 )
  {
    v7 = __ROL4__(v6, 1);
    if ( v4 <= v7 )
    {
      ++v5;
      break;
    }
    v8 = __ROL4__(v7, 1);
    if ( v4 <= v8 )
    {
      v5 += 2;
      break;
    }
    v5 += 3;
    v6 = __ROL4__(v8, 1);
    if ( v5 >= 0x1B )
      break;
  }
  *(_DWORD *)(v3 + 136) = 2 * v5;
  *(_DWORD *)(v3 + 108) = 0;
  *(_DWORD *)(v3 + 144) = 0;
  result = sub_10027B80(a2, v3, a3);
  if ( !result )
  {
    sub_10027D10(v10, v3);
    if ( !*(_DWORD *)(v3 + 100) )
    {
      sub_10026F50(v12, v11);
      sub_10026EC0(v3);
    }
    v13 = *(_DWORD *)(v3 + 80);
    v14 = *(_DWORD *)(v3 + 44) - 1;
    *(_DWORD *)(v3 + 227512) = v14;
    *(_DWORD *)(v3 + 209008) = v14;
    sub_10025510(v3 + 200500, v3 + 207980, 1 << v13);
    sub_10025510(v3 + 200500, v3 + 226484, 1 << *(_DWORD *)(v3 + 80));
    result = 0;
    *(_DWORD *)(v3 + 120) = 0;
    *(_DWORD *)(v3 + 124) = 0;
  }
  return result;
}

//----- (10028020) --------------------------------------------------------
size_t __cdecl sub_10028020(int a1, void *a2, size_t a3)
{
  size_t v3; // edi@1

  v3 = a3;
  if ( *(_DWORD *)(a1 + 8) < a3 )
  {
    v3 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 12) = 1;
  }
  memcpy(*(void **)(a1 + 4), a2, v3);
  *(_DWORD *)(a1 + 8) -= v3;
  *(_DWORD *)(a1 + 4) += v3;
  return v3;
}

//----- (10028060) --------------------------------------------------------
int __usercall sub_10028060@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v1; // esi@1
  int i; // edi@1

  v1 = a1;
  for ( i = sub_10027360(a1); !i; i = sub_10027360(v1) )
  {
    if ( v1[27] )
      break;
  }
  if ( v1[52] )
    sub_10029370((int)(v1 + 64));
  return i;
}

//----- (100280A0) --------------------------------------------------------
signed int __usercall sub_100280A0@<eax>(_DWORD *a1@<ecx>, int a2@<edi>, int a3@<esi>)
{
  unsigned int v3; // eax@1
  signed int result; // eax@2
  signed int v5; // ecx@6
  signed int v6; // eax@11

  v3 = *(_DWORD *)(a3 + 140);
  if ( *a1 >= 5u )
  {
    *a1 = 5;
    *(_BYTE *)a2 = *(_BYTE *)(a3 + 72) + 9 * (*(_BYTE *)(a3 + 76) + 5 * *(_BYTE *)(a3 + 80));
    if ( v3 < 0x400000 )
    {
      v5 = 11;
      while ( 1 )
      {
        if ( v3 <= 2 << v5 )
        {
          v6 = 2;
          goto LABEL_13;
        }
        if ( v3 <= 3 << v5 )
          break;
        if ( (unsigned int)++v5 > 0x1E )
          goto LABEL_14;
      }
      v6 = 3;
LABEL_13:
      v3 = v6 << v5;
    }
    else if ( v3 < 0xFFF00000 )
    {
      v3 = (v3 + 0xFFFFF) & 0xFFF00000;
    }
LABEL_14:
    *(_BYTE *)(a2 + 1) = v3;
    *(_BYTE *)(a2 + 4) = BYTE3(v3);
    *(_BYTE *)(a2 + 2) = BYTE1(v3);
    *(_BYTE *)(a2 + 3) = v3 >> 16;
    result = 0;
  }
  else
  {
    result = 5;
  }
  return result;
}

//----- (10028140) --------------------------------------------------------
signed int __usercall sub_10028140@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<edi>, int a4@<esi>, int a5)
{
  signed int result; // eax@1
  size_t (__cdecl *v6)(int, void *, size_t); // [sp+8h] [bp-14h]@1
  int v7; // [sp+Ch] [bp-10h]@1
  int v8; // [sp+10h] [bp-Ch]@1
  int v9; // [sp+14h] [bp-8h]@1

  *(_DWORD *)(a4 + 668) = a1;
  v7 = a5;
  *(_BYTE *)(a4 + 623) = 1;
  *(_DWORD *)(a4 + 644) = a2;
  v8 = *a3;
  v9 = 0;
  *(_DWORD *)(a4 + 104) = 0;
  *(_DWORD *)(a4 + 668) = a1;
  v6 = sub_10028020;
  *(_DWORD *)(a4 + 188) = &v6;
  *(_BYTE *)(a4 + 623) = 1;
  *(_DWORD *)(a4 + 644) = a2;
  *(_DWORD *)(a4 + 116) = 1;
  result = sub_10027F50(a4, &off_100ADF8C, &off_100ADF8C);
  if ( !result )
    result = sub_10028060((_DWORD *)a4);
  *a3 -= v8;
  if ( v9 )
    result = 7;
  return result;
}
// 100ADF8C: using guessed type int (__cdecl *off_100ADF8C)(_DWORD, _DWORD);

//----- (100281D0) --------------------------------------------------------
signed int __usercall sub_100281D0@<eax>(int a1@<ebx>, int a2@<esi>, int a3)
{
  int v3; // edi@1
  signed int result; // eax@2

  v3 = a3 + *(_DWORD *)(a2 + 64) + *(_DWORD *)(a2 + 68);
  if ( *(_BYTE *)(a2 + 31) )
  {
    *(_DWORD *)(a2 + 60) = v3;
    result = 1;
  }
  else
  {
    if ( !*(_DWORD *)(a2 + 52) || *(_DWORD *)(a2 + 60) != v3 )
    {
      (*(void (__cdecl **)(int, _DWORD))(a1 + 4))(a1, *(_DWORD *)(a2 + 52));
      *(_DWORD *)(a2 + 52) = 0;
      *(_DWORD *)(a2 + 60) = v3;
      *(_DWORD *)(a2 + 52) = (*(int (__cdecl **)(int, int))a1)(a1, v3);
    }
    result = *(_DWORD *)(a2 + 52) != 0;
  }
  return result;
}

//----- (10028240) --------------------------------------------------------
int __cdecl sub_10028240(int a1)
{
  return *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
}

//----- (10028250) --------------------------------------------------------
void __usercall sub_10028250(int a1@<ecx>, int a2@<esi>)
{
  int v2; // ecx@4
  int v3; // eax@4
  bool v4; // zf@6
  int v5; // eax@9
  int v6; // eax@10
  int i; // [sp+0h] [bp-4h]@1

  i = a1;
  if ( !*(_BYTE *)(a2 + 28) && !*(_DWORD *)(a2 + 92) )
  {
    if ( *(_BYTE *)(a2 + 31) )
    {
      v2 = *(_DWORD *)(a2 + 12);
      v3 = -1 - v2;
      if ( (unsigned int)(-1 - v2) > *(_DWORD *)(a2 + 76) )
        v3 = *(_DWORD *)(a2 + 76);
      v4 = *(_DWORD *)(a2 + 76) == v3;
      *(_DWORD *)(a2 + 76) -= v3;
      *(_DWORD *)(a2 + 12) = v2 + v3;
      if ( v4 )
LABEL_7:
        *(_BYTE *)(a2 + 28) = 1;
    }
    else
    {
      v5 = *(_DWORD *)(a2 + 12) + *(_DWORD *)a2 - *(_DWORD *)(a2 + 4);
      for ( i = *(_DWORD *)(a2 + 60) + *(_DWORD *)(a2 + 52) - v5; i; i = *(_DWORD *)(a2 + 60)
                                                                       + *(_DWORD *)(a2 + 52)
                                                                       - v5 )
      {
        v6 = (**(int (__cdecl ***)(_DWORD, int, int *))(a2 + 56))(*(_DWORD *)(a2 + 56), v5, &i);
        *(_DWORD *)(a2 + 92) = v6;
        if ( v6 )
          break;
        if ( !i )
          goto LABEL_7;
        *(_DWORD *)(a2 + 12) += i;
        if ( (unsigned int)(*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4)) > *(_DWORD *)(a2 + 68) )
          break;
        v5 = *(_DWORD *)(a2 + 12) + *(_DWORD *)a2 - *(_DWORD *)(a2 + 4);
      }
    }
  }
}

//----- (100282F0) --------------------------------------------------------
void __usercall sub_100282F0(int a1@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  int v3; // eax@2
  void *v4; // edx@2

  v2 = a1;
  if ( !*(_BYTE *)(a1 + 31) )
  {
    v3 = *(_DWORD *)a1;
    v4 = *(void **)(v2 + 52);
    a2 = *(_DWORD *)(v2 + 68) >= (unsigned int)v4 + *(_DWORD *)(v2 + 60) - *(_DWORD *)v2;
    if ( *(_DWORD *)(v2 + 68) >= (unsigned int)v4 + *(_DWORD *)(v2 + 60) - *(_DWORD *)v2 )
    {
      memmove(
        v4,
        (const void *)(v3 - *(_DWORD *)(v2 + 64)),
        *(_DWORD *)(v2 + 64) + *(_DWORD *)(v2 + 12) - *(_DWORD *)(v2 + 4));
      *(_DWORD *)v2 = *(_DWORD *)(v2 + 52) + *(_DWORD *)(v2 + 64);
    }
  }
  sub_10028250(a2, v2);
}

//----- (10028340) --------------------------------------------------------
unsigned int __usercall sub_10028340@<eax>(int a1@<eax>)
{
  unsigned int v1; // edx@1
  unsigned int *v2; // esi@1
  unsigned int v3; // ecx@2
  unsigned int v4; // eax@2
  unsigned int v5; // ecx@2
  unsigned int result; // eax@2

  v1 = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 31) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 48) = 32;
  *(_DWORD *)(a1 + 72) = 4;
  *(_WORD *)(a1 + 29) = 1;
  v2 = (unsigned int *)(a1 + 96);
  do
  {
    v3 = ((((((((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1)
                                                                  - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1)
                                                                                             - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320) >> 1;
    v4 = v3 ^ ~((((unsigned __int8)(((((((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1)
                                                                                           - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1)
              - 1) & 0xEDB88320;
    v5 = (v4 >> 1) ^ ~((((unsigned __int8)v3 ^ ~((((unsigned __int8)(((((((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1)
                                               - 1) & 0x20) & 1)
                     - 1) & 0xEDB88320;
    result = ((v5 >> 1) ^ ~((v5 & 1) - 1) & 0xEDB88320) >> 1;
    *v2 = result ^ ~((((unsigned __int8)(v5 >> 1) ^ ~((v5 & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320;
    ++v1;
    ++v2;
  }
  while ( v1 < 0x100 );
  return result;
}

//----- (10028410) --------------------------------------------------------
signed int __usercall sub_10028410@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4, int a5, int a6)
{
  unsigned int v6; // edi@1
  int v7; // ebx@1
  int v8; // esi@1
  unsigned int v9; // eax@2
  unsigned int v10; // edx@7
  unsigned int v11; // eax@8
  unsigned int v12; // ecx@9
  int v13; // eax@13
  int v14; // eax@19
  bool v15; // zf@19
  int v16; // edi@19
  int v17; // edi@21
  int v18; // eax@24
  int v20; // [sp+Ch] [bp-4h]@7

  v6 = a3;
  v7 = a1;
  v8 = a2;
  if ( a3 <= 0xE0000000 )
  {
    v9 = a3 >> 1;
    if ( a3 < 0xC0000000 )
    {
      if ( a3 >= 0x80000000 )
        v9 = a3 >> 2;
    }
    else
    {
      v9 = a3 >> 3;
    }
    *(_DWORD *)(a2 + 64) = a3 + a4 + 1;
    *(_DWORD *)(a2 + 68) = a5 + a6;
    if ( sub_100281D0(v7, a2, ((unsigned int)(a6 + a5 + a4) >> 1) + v9 + 0x80000) )
    {
      *(_DWORD *)(v8 + 32) = a5;
      v10 = *(_DWORD *)(v8 + 72);
      v20 = v6 + 1;
      *(_DWORD *)(v8 + 84) = 0;
      if ( v10 == 2 )
      {
        v11 = 0xFFFF;
      }
      else
      {
        v12 = ((((((v6 - 1) >> 1) | (v6 - 1)) >> 2) | ((v6 - 1) >> 1) | (v6 - 1)) >> 4) | ((((v6 - 1) >> 1) | (v6 - 1)) >> 2) | ((v6 - 1) >> 1) | (v6 - 1);
        v11 = (v12 | ((v12 | 0x1FFFE00) >> 8)) >> 1;
        if ( v11 > 0x1000000 )
        {
          if ( v10 == 3 )
            v11 = 0xFFFFFF;
          else
            v11 = (v12 | ((((((((v6 - 1) >> 1) | (v6 - 1)) >> 2) | ((v6 - 1) >> 1) | (v6 - 1)) >> 4) | ((((v6 - 1) >> 1) | (v6 - 1)) >> 2) | ((v6 - 1) >> 1) | (v6 - 1) | 0x1FFFE00) >> 8)) >> 2;
        }
      }
      *(_DWORD *)(v8 + 44) = v11;
      v13 = v11 + 1;
      if ( v10 > 2 )
        *(_DWORD *)(v8 + 84) = 1024;
      if ( v10 > 3 )
        *(_DWORD *)(v8 + 84) += 0x10000;
      if ( v10 > 4 )
        *(_DWORD *)(v8 + 84) += 0x100000;
      v14 = *(_DWORD *)(v8 + 84) + v13;
      v15 = *(_BYTE *)(v8 + 29) == 0;
      *(_DWORD *)(v8 + 80) = v6;
      v16 = v6 + 1;
      *(_DWORD *)(v8 + 88) = v14;
      *(_DWORD *)(v8 + 24) = v20;
      if ( !v15 )
        v16 = 2 * v20;
      v17 = v14 + v16;
      if ( *(_DWORD *)(v8 + 36) && *(_DWORD *)(v8 + 1120) == v17 )
        return 1;
      (*(void (__cdecl **)(int, _DWORD))(v7 + 4))(v7, *(_DWORD *)(v8 + 36));
      *(_DWORD *)(v8 + 36) = 0;
      *(_DWORD *)(v8 + 1120) = v17;
      if ( (unsigned int)(4 * v17) >> 2 == v17 )
        v18 = (*(int (__cdecl **)(int, int))v7)(v7, 4 * v17);
      else
        v18 = 0;
      *(_DWORD *)(v8 + 36) = v18;
      if ( v18 )
      {
        *(_DWORD *)(v8 + 40) = v18 + 4 * *(_DWORD *)(v8 + 88);
        return 1;
      }
    }
  }
  (*(void (__cdecl **)(int, _DWORD))(v7 + 4))(v7, *(_DWORD *)(v8 + 36));
  v15 = *(_BYTE *)(v8 + 31) == 0;
  *(_DWORD *)(v8 + 36) = 0;
  if ( v15 )
  {
    (*(void (__cdecl **)(_DWORD, _DWORD))(v7 + 4))(v7, *(_DWORD *)(v8 + 52));
    *(_DWORD *)(v8 + 52) = 0;
  }
  return 0;
}

//----- (100285B0) --------------------------------------------------------
unsigned int __cdecl sub_100285B0(int a1)
{
  int v1; // ecx@1
  int v2; // eax@3
  int v3; // edi@3
  unsigned int result; // eax@3
  unsigned int v5; // edx@5
  int v6; // ebx@5
  unsigned int v7; // ecx@6

  v1 = *(_DWORD *)(a1 + 88);
  if ( v1 )
  {
    memset(*(void **)(a1 + 36), 0, 4 * v1);
    v1 = 0;
  }
  *(_DWORD *)a1 = *(_DWORD *)(a1 + 52);
  v2 = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 12) = v2;
  *(_DWORD *)(a1 + 4) = v2;
  *(_DWORD *)(a1 + 92) = 0;
  *(_BYTE *)(a1 + 28) = 0;
  sub_10028250(v1, a1);
  v3 = *(_DWORD *)(a1 + 4);
  result = -1 - v3;
  if ( *(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 20) < (unsigned int)(-1 - v3) )
    result = *(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 20);
  v5 = *(_DWORD *)(a1 + 12) - v3;
  v6 = *(_DWORD *)(a1 + 68);
  if ( v5 > v6 )
    v7 = v5 - v6;
  else
    v7 = *(_DWORD *)(a1 + 12) != v3;
  if ( v7 < result )
    result = v7;
  if ( v5 > *(_DWORD *)(a1 + 32) )
    v5 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 8) = result + v3;
  *(_DWORD *)(a1 + 16) = v5;
  return result;
}

//----- (10028630) --------------------------------------------------------
unsigned int __usercall sub_10028630@<eax>(unsigned int a1@<ecx>, int a2@<esi>)
{
  unsigned int v2; // ebx@2
  int v3; // edi@2
  unsigned int v4; // eax@2
  int v5; // edx@3
  int v6; // edx@4
  int v7; // ecx@11
  int v8; // ebx@13
  unsigned int v9; // ecx@13
  unsigned int result; // eax@13
  int v11; // edi@15
  unsigned int v12; // ecx@15
  unsigned int v13; // ecx@16
  unsigned int v14; // ecx@20

  if ( *(_DWORD *)(a2 + 4) == -1 )
  {
    v2 = *(_DWORD *)(a2 + 1120);
    v3 = *(_DWORD *)(a2 + 36);
    a1 = 0;
    v4 = (-2 - *(_DWORD *)(a2 + 80)) & 0xFFFFFC00;
    if ( v2 )
    {
      do
      {
        v5 = *(_DWORD *)(v3 + 4 * a1);
        if ( v5 > v4 )
          v6 = v5 - v4;
        else
          v6 = 0;
        *(_DWORD *)(v3 + 4 * a1++) = v6;
      }
      while ( a1 < v2 );
    }
    *(_DWORD *)(a2 + 8) -= v4;
    *(_DWORD *)(a2 + 4) -= v4;
    *(_DWORD *)(a2 + 12) -= v4;
  }
  if ( !*(_BYTE *)(a2 + 28) && *(_DWORD *)(a2 + 68) == *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4) )
    sub_100282F0(a2, a1);
  v7 = *(_DWORD *)(a2 + 24);
  if ( *(_DWORD *)(a2 + 20) == v7 )
    *(_DWORD *)(a2 + 20) = 0;
  v8 = *(_DWORD *)(a2 + 4);
  v9 = v7 - *(_DWORD *)(a2 + 20);
  result = -1 - v8;
  if ( v9 < -1 - v8 )
    result = v9;
  v11 = *(_DWORD *)(a2 + 68);
  v12 = *(_DWORD *)(a2 + 12) - v8;
  if ( v12 > v11 )
    v13 = v12 - v11;
  else
    v13 = *(_DWORD *)(a2 + 12) != v8;
  if ( v13 < result )
    result = v13;
  v14 = *(_DWORD *)(a2 + 12) - v8;
  if ( v14 > *(_DWORD *)(a2 + 32) )
    v14 = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 8) = result + v8;
  *(_DWORD *)(a2 + 16) = v14;
  return result;
}

//----- (100286F0) --------------------------------------------------------
int __usercall sub_100286F0@<eax>(_BYTE *a1@<ebx>, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, int a8, int a9, unsigned int a10)
{
  unsigned int v10; // eax@1
  unsigned int v11; // esi@1
  unsigned int v12; // ecx@1
  int v13; // edi@1
  _BYTE *v14; // edx@5
  unsigned int v15; // esi@7
  int v16; // edx@8
  _BYTE *v17; // edi@8
  int i; // [sp+8h] [bp-4h]@8
  int v20; // [sp+18h] [bp+Ch]@5

  v10 = a6;
  *(_DWORD *)(a5 + 4 * a6) = a3;
  v11 = a7;
  v12 = a4 - a3;
  v13 = a9;
  if ( a8 )
  {
    while ( 1 )
    {
      --a8;
      if ( v12 >= v11 )
        break;
      v14 = &a1[-v12];
      v20 = *(_DWORD *)(a5 + 4 * (v10 + (v10 < v12 ? v11 : 0) - v12));
      if ( *(&a1[a10] - v12) != a1[a10] || *v14 != *a1 )
      {
        v13 = a9;
      }
      else
      {
        v15 = 1;
        if ( a2 != 1 )
        {
          v16 = v14 - a1;
          v17 = a1 + 1;
          for ( i = v16; v17[v16] == *v17; v16 = i )
          {
            ++v15;
            ++v17;
            if ( v15 == a2 )
              break;
          }
        }
        v13 = a9;
        if ( a10 < v15 )
        {
          *(_DWORD *)a9 = v15;
          *(_DWORD *)(a9 + 4) = v12 - 1;
          v13 = a9 + 8;
          a10 = v15;
          a9 += 8;
          if ( v15 == a2 )
            return v13;
        }
      }
      v12 = a4 - v20;
      if ( !a8 )
        return v13;
      v11 = a7;
      v10 = a6;
    }
  }
  return v13;
}

//----- (100287C0) --------------------------------------------------------
int __cdecl sub_100287C0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, int a8, int a9, unsigned int a10)
{
  int v10; // eax@1
  unsigned int v11; // esi@1
  unsigned int v12; // edx@1
  unsigned int v13; // ecx@1
  unsigned int v14; // ebx@1
  int result; // eax@2
  int v16; // edi@5
  int v17; // esi@5
  _BYTE *v18; // edi@11
  int v19; // ebx@16
  int v20; // edx@18
  int v21; // edi@18
  int v22; // [sp+Ch] [bp-14h]@5
  unsigned int v23; // [sp+10h] [bp-10h]@1
  unsigned int v24; // [sp+14h] [bp-Ch]@1
  _DWORD *v25; // [sp+18h] [bp-8h]@1
  _DWORD *v26; // [sp+1Ch] [bp-4h]@1

  v10 = a4;
  v11 = a6;
  v25 = (_DWORD *)(a5 + 8 * a6 + 4);
  v12 = a3 - a2;
  v26 = (_DWORD *)(a5 + 8 * a6);
  v13 = 0;
  v14 = 0;
  v24 = 0;
  v23 = 0;
  if ( a8 )
  {
    while ( 1 )
    {
      --a8;
      if ( v12 >= a7 )
        break;
      v16 = a5 + 8 * (v11 + (v11 < v12 ? a7 : 0) - v12);
      v17 = v10 - v12;
      v22 = v16;
      if ( v13 >= v14 )
        v13 = v14;
      if ( *(_BYTE *)(v13 + v17) == *(_BYTE *)(v13 + v10) )
      {
        if ( ++v13 != a1 && *(_BYTE *)(v13 + v17) == *(_BYTE *)(v13 + v10) && ++v13 != a1 )
        {
          v18 = (_BYTE *)(v13 + v10);
          do
          {
            if ( v18[v17 - a4] != *v18 )
              break;
            ++v13;
            ++v18;
          }
          while ( v13 != a1 );
          v10 = a4;
          v16 = v22;
        }
        if ( a10 < v13 )
        {
          *(_DWORD *)a9 = v13;
          *(_DWORD *)(a9 + 4) = v12 - 1;
          v19 = a9 + 8;
          a10 = v13;
          a9 += 8;
          if ( v13 == a1 )
          {
            *v26 = *(_DWORD *)v16;
            *v25 = *(_DWORD *)(v16 + 4);
            return v19;
          }
        }
      }
      if ( *(_BYTE *)(v13 + v17) >= *(_BYTE *)(v13 + v10) )
      {
        v14 = v23;
        *v25 = a2;
        v25 = (_DWORD *)v16;
        v21 = *(_DWORD *)v16;
        v24 = v13;
      }
      else
      {
        *v26 = a2;
        v20 = v16 + 4;
        v21 = *(_DWORD *)(v16 + 4);
        v14 = v13;
        v13 = v24;
        v26 = (_DWORD *)v20;
        v23 = v14;
      }
      v12 = a3 - v21;
      a2 = v21;
      if ( !a8 )
        break;
      v11 = a6;
    }
  }
  result = a9;
  *v26 = 0;
  *v25 = 0;
  return result;
}

//----- (10028900) --------------------------------------------------------
_DWORD *__cdecl sub_10028900(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, int a8)
{
  unsigned int v8; // ecx@1
  int v9; // esi@1
  _DWORD *v10; // edx@1
  unsigned int v11; // ebx@1
  unsigned int v12; // eax@1
  int v13; // edi@3
  int v14; // ecx@3
  unsigned int v15; // eax@3
  _BYTE *v16; // esi@7
  _DWORD *result; // eax@10
  unsigned int v18; // [sp+Ch] [bp-10h]@1
  unsigned int v19; // [sp+10h] [bp-Ch]@1
  _DWORD *v20; // [sp+14h] [bp-8h]@1
  _DWORD *v21; // [sp+18h] [bp-4h]@1

  v8 = a6;
  v9 = a2;
  v20 = (_DWORD *)(a5 + 8 * a6 + 4);
  v10 = (_DWORD *)(a5 + 8 * a6);
  v11 = 0;
  v12 = a3 - a2;
  v21 = (_DWORD *)(a5 + 8 * a6);
  v19 = 0;
  v18 = 0;
  if ( a8 )
  {
    while ( 1 )
    {
      --a8;
      if ( v12 >= a7 )
        break;
      v13 = a5 + 8 * (v8 + (v8 < v12 ? a7 : 0) - v12);
      v14 = a4 - v12;
      v15 = v19;
      if ( v19 >= v11 )
        v15 = v11;
      if ( *(_BYTE *)(v15 + v14) == *(_BYTE *)(v15 + a4) )
      {
        if ( ++v15 == a1 )
          goto LABEL_10;
        v16 = (_BYTE *)(v15 + a4);
        while ( v16[v14 - a4] == *v16 )
        {
          ++v15;
          ++v16;
          if ( v15 == a1 )
            goto LABEL_10;
        }
        if ( v15 == a1 )
        {
LABEL_10:
          result = v21;
          *v21 = *(_DWORD *)v13;
          *v20 = *(_DWORD *)(v13 + 4);
          return result;
        }
        v9 = a2;
      }
      v10 = v21;
      if ( *(_BYTE *)(v15 + v14) >= *(_BYTE *)(v15 + a4) )
      {
        v11 = v18;
        *v20 = v9;
        v9 = *(_DWORD *)v13;
        v20 = (_DWORD *)v13;
        v19 = v15;
      }
      else
      {
        *v21 = v9;
        v9 = *(_DWORD *)(v13 + 4);
        v10 = (_DWORD *)(v13 + 4);
        v11 = v15;
        v21 = (_DWORD *)(v13 + 4);
        v18 = v15;
      }
      v12 = a3 - v9;
      a2 = v9;
      if ( !a8 )
        break;
      v8 = a6;
    }
  }
  result = v20;
  *v10 = 0;
  *v20 = 0;
  return result;
}

//----- (10028A10) --------------------------------------------------------
int __cdecl sub_10028A10(int a1, int a2)
{
  unsigned int v2; // ecx@0
  unsigned int v3; // edx@1
  int result; // eax@4
  int *v5; // eax@5
  int v6; // ecx@5
  int v7; // eax@5
  unsigned int v8; // ecx@5
  int v9; // edi@5

  v3 = *(_DWORD *)(a1 + 16);
  if ( v3 >= 2 )
  {
    v5 = (int *)(*(_DWORD *)(a1 + 36) + 4 * (**(_BYTE **)a1 | (*(_BYTE *)(*(_DWORD *)a1 + 1) << 8)));
    v6 = *v5;
    *v5 = *(_DWORD *)(a1 + 4);
    v7 = sub_100287C0(
           v3,
           v6,
           *(_DWORD *)(a1 + 4),
           *(_DWORD *)a1,
           *(_DWORD *)(a1 + 40),
           *(_DWORD *)(a1 + 20),
           *(_DWORD *)(a1 + 24),
           *(_DWORD *)(a1 + 48),
           a2,
           1u);
    ++*(_DWORD *)(a1 + 20);
    ++*(_DWORD *)a1;
    ++*(_DWORD *)(a1 + 4);
    v9 = (v7 - a2) >> 2;
    if ( *(_DWORD *)(a1 + 4) == *(_DWORD *)(a1 + 8) )
      sub_10028630(v8, a1);
    result = v9;
  }
  else
  {
    ++*(_DWORD *)(a1 + 20);
    ++*(_DWORD *)a1;
    if ( ++*(_DWORD *)(a1 + 4) == *(_DWORD *)(a1 + 8) )
      sub_10028630(v2, a1);
    result = 0;
  }
  return result;
}

//----- (10028AB0) --------------------------------------------------------
signed int __cdecl sub_10028AB0(int a1, int a2)
{
  unsigned int v2; // ecx@0
  int v3; // esi@1
  int v5; // ebx@5
  _BYTE *v6; // edi@5
  int v7; // eax@5
  int v8; // ecx@5
  int v9; // edx@5
  signed int v10; // ecx@5
  unsigned int v11; // eax@5
  _BYTE *i; // eax@7
  int v13; // edx@10
  unsigned int v14; // ecx@11
  int v15; // eax@15
  unsigned int v16; // ecx@15
  int v17; // edi@15
  int v18; // [sp+8h] [bp-8h]@5
  unsigned int v19; // [sp+Ch] [bp-4h]@1
  unsigned int v20; // [sp+18h] [bp+8h]@5

  v3 = a1;
  v19 = *(_DWORD *)(a1 + 16);
  if ( v19 < 3 )
  {
    ++*(_DWORD *)(a1 + 20);
    ++*(_DWORD *)a1;
    if ( ++*(_DWORD *)(a1 + 4) == *(_DWORD *)(a1 + 8) )
      sub_10028630(v2, a1);
    return 0;
  }
  v5 = *(_DWORD *)(a1 + 4);
  v6 = *(_BYTE **)a1;
  v7 = *(_DWORD *)(a1 + 44) & (*(_DWORD *)(a1 + 4 * **(_BYTE **)a1 + 96) ^ *(_BYTE *)(*(_DWORD *)a1 + 1) ^ (*(_BYTE *)(*(_DWORD *)a1 + 2) << 8));
  v8 = *(_DWORD *)(a1 + 36);
  v9 = (*(_WORD *)(a1 + 4 * **(_BYTE **)a1 + 96) ^ *(_BYTE *)(*(_DWORD *)a1 + 1)) & 0x3FF;
  v20 = v5 - *(_DWORD *)(v8 + 4 * v9);
  v18 = *(_DWORD *)(v8 + 4 * v7 + 4096);
  *(_DWORD *)(v8 + 4 * v9) = v5;
  *(_DWORD *)(v8 + 4 * v7 + 4096) = v5;
  v10 = 0;
  v11 = 2;
  if ( v20 >= *(_DWORD *)(v3 + 24) || v6[-v20] != *v6 )
  {
    v13 = v19;
  }
  else
  {
    for ( i = v6 + 2; i != &v6[v19]; ++i )
    {
      if ( i[-v20] != *i )
        break;
    }
    v13 = v19;
    v11 = i - v6;
    *(_DWORD *)(a2 + 4) = v20 - 1;
    *(_DWORD *)a2 = v11;
    v10 = 2;
    if ( v11 == v19 )
    {
      sub_10028900(
        v19,
        v18,
        *(_DWORD *)(v3 + 4),
        *(_DWORD *)v3,
        *(_DWORD *)(v3 + 40),
        *(_DWORD *)(v3 + 20),
        *(_DWORD *)(v3 + 24),
        *(_DWORD *)(v3 + 48));
      ++*(_DWORD *)(v3 + 20);
      ++*(_DWORD *)v3;
      if ( ++*(_DWORD *)(v3 + 4) == *(_DWORD *)(v3 + 8) )
        sub_10028630(v14, v3);
      return 2;
    }
  }
  v15 = sub_100287C0(
          v13,
          v18,
          *(_DWORD *)(v3 + 4),
          *(_DWORD *)v3,
          *(_DWORD *)(v3 + 40),
          *(_DWORD *)(v3 + 20),
          *(_DWORD *)(v3 + 24),
          *(_DWORD *)(v3 + 48),
          a2 + 4 * v10,
          v11);
  ++*(_DWORD *)(v3 + 20);
  ++*(_DWORD *)v3;
  ++*(_DWORD *)(v3 + 4);
  v17 = (v15 - a2) >> 2;
  if ( *(_DWORD *)(v3 + 4) == *(_DWORD *)(v3 + 8) )
    sub_10028630(v16, v3);
  return v17;
}

//----- (10028C30) --------------------------------------------------------
int __cdecl sub_10028C30(int a1, int a2)
{
  unsigned int v2; // ecx@0
  int v3; // esi@1
  int v5; // ecx@5
  int v6; // eax@5
  int v7; // edx@5
  int v8; // ebx@5
  __int16 v9; // di@5
  int v10; // eax@5
  int v11; // edi@5
  int v12; // ST44_4@5
  int v13; // ecx@5
  int v14; // eax@5
  int v15; // ecx@5
  unsigned int v16; // edx@5
  int v17; // ST34_4@5
  int v18; // edi@5
  int v19; // ebx@5
  unsigned int v20; // eax@5
  int v21; // edi@5
  int v22; // edx@13
  _BYTE *v23; // eax@13
  unsigned int v24; // ecx@18
  int v25; // [sp+4h] [bp-18h]@13
  int v26; // [sp+Ch] [bp-10h]@5
  unsigned int v27; // [sp+10h] [bp-Ch]@5
  unsigned int v28; // [sp+18h] [bp-4h]@1
  _BYTE *v29; // [sp+24h] [bp+8h]@5

  v3 = a1;
  v28 = *(_DWORD *)(a1 + 16);
  if ( v28 < 4 )
  {
    ++*(_DWORD *)(a1 + 20);
    ++*(_DWORD *)a1;
    if ( ++*(_DWORD *)(a1 + 4) == *(_DWORD *)(a1 + 8) )
      sub_10028630(v2, a1);
    return 0;
  }
  v5 = *(_DWORD *)a1;
  v6 = *(_DWORD *)(a1 + 4 * **(_BYTE **)a1 + 96) ^ *(_BYTE *)(*(_DWORD *)a1 + 1);
  v7 = *(_BYTE *)(*(_DWORD *)a1 + 2);
  v8 = *(_DWORD *)(a1 + 4);
  v29 = (_BYTE *)v5;
  v9 = v6;
  v10 = (v7 << 8) ^ v6;
  v11 = v9 & 0x3FF;
  v12 = (unsigned __int16)v10;
  v13 = v10 ^ 32 * *(_DWORD *)(v3 + 4 * *(_BYTE *)(v5 + 3) + 96);
  v14 = *(_DWORD *)(v3 + 36);
  v15 = *(_DWORD *)(v3 + 44) & v13;
  v16 = v8 - *(_DWORD *)(v14 + 4 * v11);
  v17 = v11;
  v27 = v8 - *(_DWORD *)(v14 + 4 * v12 + 4096);
  v26 = *(_DWORD *)(v14 + 4 * v15 + 266240);
  v18 = v8;
  *(_DWORD *)(v14 + 4 * v17) = v8;
  *(_DWORD *)(v14 + 4 * v12 + 4096) = v8;
  v19 = a2;
  *(_DWORD *)(v14 + 4 * v15 + 266240) = v18;
  v20 = 0;
  v21 = 0;
  if ( v16 < *(_DWORD *)(v3 + 24) )
  {
    v19 = a2;
    if ( v29[-v16] == *v29 )
    {
      v20 = 2;
      *(_DWORD *)a2 = 2;
      *(_DWORD *)(a2 + 4) = v16 - 1;
      v21 = 2;
    }
  }
  if ( v16 != v27 && v27 < *(_DWORD *)(v3 + 24) )
  {
    v19 = a2;
    if ( v29[-v27] == *v29 )
    {
      v16 = v27;
      *(_DWORD *)(a2 + 4 * v21 + 4) = v27 - 1;
      v20 = 3;
      v21 += 2;
    }
  }
  if ( !v21 )
  {
    v22 = v28;
LABEL_20:
    if ( v20 < 3 )
      v20 = 3;
    v21 = (sub_100287C0(
             v22,
             v26,
             *(_DWORD *)(v3 + 4),
             *(_DWORD *)v3,
             *(_DWORD *)(v3 + 40),
             *(_DWORD *)(v3 + 20),
             *(_DWORD *)(v3 + 24),
             *(_DWORD *)(v3 + 48),
             v19 + 4 * v21,
             v20)
         - v19) >> 2;
    goto LABEL_23;
  }
  v25 = -v16;
  v22 = v28;
  v23 = &v29[v20];
  if ( v23 != &v29[v28] )
  {
    do
    {
      if ( v23[v25] != *v23 )
        break;
      ++v23;
    }
    while ( v23 != &v29[v28] );
    v22 = v28;
  }
  v20 = v23 - v29;
  *(_DWORD *)(v19 + 4 * v21 - 8) = v20;
  if ( v20 != v22 )
    goto LABEL_20;
  sub_10028900(
    v22,
    v26,
    *(_DWORD *)(v3 + 4),
    *(_DWORD *)v3,
    *(_DWORD *)(v3 + 40),
    *(_DWORD *)(v3 + 20),
    *(_DWORD *)(v3 + 24),
    *(_DWORD *)(v3 + 48));
LABEL_23:
  ++*(_DWORD *)(v3 + 20);
  ++*(_DWORD *)v3;
  if ( ++*(_DWORD *)(v3 + 4) == *(_DWORD *)(v3 + 8) )
    sub_10028630(v24, v3);
  return v21;
}

//----- (10028E00) --------------------------------------------------------
signed int __cdecl sub_10028E00(int a1, int a2)
{
  unsigned int v2; // ecx@0
  int v3; // esi@1
  signed int result; // eax@4
  _BYTE *v5; // ecx@5
  int v6; // eax@5
  int v7; // edx@5
  int v8; // ebx@5
  __int16 v9; // di@5
  int v10; // eax@5
  int v11; // edi@5
  int v12; // ST40_4@5
  int v13; // ecx@5
  int v14; // eax@5
  int v15; // ecx@5
  unsigned int v16; // edx@5
  int v17; // ST30_4@5
  int v18; // edi@5
  _BYTE *v19; // ebx@5
  unsigned int v20; // eax@5
  signed int v21; // edi@5
  _BYTE *i; // eax@13
  int v23; // eax@22
  unsigned int v24; // ecx@22
  int v25; // ebx@22
  unsigned int v26; // [sp+Ch] [bp-10h]@5
  unsigned int v27; // [sp+10h] [bp-Ch]@5
  unsigned int v28; // [sp+18h] [bp-4h]@1
  _BYTE *v29; // [sp+24h] [bp+8h]@5

  v3 = a1;
  v28 = *(_DWORD *)(a1 + 16);
  if ( v28 >= 4 )
  {
    v5 = *(_BYTE **)a1;
    v6 = *(_DWORD *)(a1 + 4 * **(_BYTE **)a1 + 96) ^ *(_BYTE *)(*(_DWORD *)a1 + 1);
    v7 = *(_BYTE *)(*(_DWORD *)a1 + 2);
    v8 = *(_DWORD *)(a1 + 4);
    v29 = v5;
    v9 = v6;
    v10 = (v7 << 8) ^ v6;
    v11 = v9 & 0x3FF;
    v12 = (unsigned __int16)v10;
    v13 = v10 ^ 32 * *(_DWORD *)(v3 + 4 * v5[3] + 96);
    v14 = *(_DWORD *)(v3 + 36);
    v15 = *(_DWORD *)(v3 + 44) & v13;
    v16 = v8 - *(_DWORD *)(v14 + 4 * v11);
    v17 = v11;
    v27 = v8 - *(_DWORD *)(v14 + 4 * v12 + 4096);
    v26 = *(_DWORD *)(v14 + 4 * v15 + 266240);
    v18 = v8;
    *(_DWORD *)(v14 + 4 * v17) = v8;
    *(_DWORD *)(v14 + 4 * v12 + 4096) = v8;
    v19 = v29;
    *(_DWORD *)(v14 + 4 * v15 + 266240) = v18;
    v20 = 0;
    v21 = 0;
    if ( v16 < *(_DWORD *)(v3 + 24) && v29[-v16] == *v29 )
    {
      v20 = 2;
      *(_DWORD *)(a2 + 4) = v16 - 1;
      *(_DWORD *)a2 = 2;
      v21 = 2;
    }
    if ( v16 != v27 && v27 < *(_DWORD *)(v3 + 24) )
    {
      v19 = v29;
      if ( v29[-v27] == *v29 )
      {
        v16 = v27;
        *(_DWORD *)(a2 + 4 * v21 + 4) = v27 - 1;
        v19 = v29;
        v20 = 3;
        v21 += 2;
      }
    }
    if ( !v21 )
      goto LABEL_27;
    for ( i = &v19[v20]; i != &v19[v28]; ++i )
    {
      if ( i[-v16] != *i )
        break;
    }
    v20 = i - v19;
    *(_DWORD *)(a2 + 4 * v21 - 8) = v20;
    if ( v20 == v28 )
    {
      *(_DWORD *)(*(_DWORD *)(v3 + 40) + 4 * (*(_DWORD *)(v3 + 20))++) = v26;
      ++*(_DWORD *)v3;
      if ( ++*(_DWORD *)(v3 + 4) == *(_DWORD *)(v3 + 8) )
        sub_10028630(v26, v3);
      result = v21;
    }
    else
    {
LABEL_27:
      if ( v20 < 3 )
        v20 = 3;
      v23 = sub_100286F0(
              *(_BYTE **)v3,
              v28,
              v26,
              *(_DWORD *)(v3 + 4),
              *(_DWORD *)(v3 + 40),
              *(_DWORD *)(v3 + 20),
              *(_DWORD *)(v3 + 24),
              *(_DWORD *)(v3 + 48),
              a2 + 4 * v21,
              v20);
      ++*(_DWORD *)(v3 + 20);
      ++*(_DWORD *)v3;
      ++*(_DWORD *)(v3 + 4);
      v25 = (v23 - a2) >> 2;
      if ( *(_DWORD *)(v3 + 4) == *(_DWORD *)(v3 + 8) )
        sub_10028630(v24, v3);
      result = v25;
    }
  }
  else
  {
    ++*(_DWORD *)(a1 + 20);
    ++*(_DWORD *)a1;
    if ( ++*(_DWORD *)(a1 + 4) == *(_DWORD *)(a1 + 8) )
      sub_10028630(v2, a1);
    result = 0;
  }
  return result;
}

//----- (10028FD0) --------------------------------------------------------
unsigned int __cdecl sub_10028FD0(int a1, int a2)
{
  unsigned int v2; // ecx@0
  unsigned int v3; // edx@1
  int *v4; // eax@2
  int v5; // ecx@2
  unsigned int result; // eax@3

  do
  {
    v3 = *(_DWORD *)(a1 + 16);
    if ( v3 >= 2 )
    {
      v4 = (int *)(*(_DWORD *)(a1 + 36) + 4 * (**(_BYTE **)a1 | (*(_BYTE *)(*(_DWORD *)a1 + 1) << 8)));
      v5 = *v4;
      *v4 = *(_DWORD *)(a1 + 4);
      sub_10028900(
        v3,
        v5,
        *(_DWORD *)(a1 + 4),
        *(_DWORD *)a1,
        *(_DWORD *)(a1 + 40),
        *(_DWORD *)(a1 + 20),
        *(_DWORD *)(a1 + 24),
        *(_DWORD *)(a1 + 48));
    }
    result = ++*(_DWORD *)(a1 + 4);
    ++*(_DWORD *)(a1 + 20);
    ++*(_DWORD *)a1;
    if ( result == *(_DWORD *)(a1 + 8) )
      result = sub_10028630(v2, a1);
    --a2;
  }
  while ( a2 );
  return result;
}

//----- (10029050) --------------------------------------------------------
unsigned int __cdecl sub_10029050(int a1, int a2)
{
  unsigned int v2; // ecx@0
  int v3; // esi@1
  int v4; // eax@3
  int v5; // edx@3
  int v6; // edi@3
  int v7; // ecx@3
  int v8; // ebx@3
  unsigned int result; // eax@4
  unsigned int v10; // [sp+14h] [bp+8h]@2

  v3 = a1;
  do
  {
    v10 = *(_DWORD *)(v3 + 16);
    if ( v10 >= 3 )
    {
      v4 = *(_DWORD *)(v3 + 4 * **(_BYTE **)v3 + 96) ^ *(_BYTE *)(*(_DWORD *)v3 + 1);
      v5 = *(_DWORD *)(v3 + 36);
      v6 = *(_DWORD *)(v3 + 4);
      v7 = *(_DWORD *)(v3 + 44) & (v4 ^ (*(_BYTE *)(*(_DWORD *)v3 + 2) << 8));
      v8 = *(_DWORD *)(v5 + 4 * v7 + 4096);
      *(_DWORD *)(v5 + 4 * v7 + 4096) = v6;
      *(_DWORD *)(v5 + 4 * (v4 & 0x3FF)) = v6;
      sub_10028900(
        v10,
        v8,
        *(_DWORD *)(v3 + 4),
        *(_DWORD *)v3,
        *(_DWORD *)(v3 + 40),
        *(_DWORD *)(v3 + 20),
        *(_DWORD *)(v3 + 24),
        *(_DWORD *)(v3 + 48));
    }
    ++*(_DWORD *)(v3 + 20);
    ++*(_DWORD *)v3;
    result = ++*(_DWORD *)(v3 + 4);
    if ( result == *(_DWORD *)(v3 + 8) )
      result = sub_10028630(v2, v3);
    --a2;
  }
  while ( a2 );
  return result;
}

//----- (100290F0) --------------------------------------------------------
unsigned int __cdecl sub_100290F0(int a1, int a2)
{
  unsigned int v2; // ecx@0
  int v3; // esi@1
  int v4; // ecx@3
  int v5; // ebx@3
  int v6; // eax@3
  int v7; // edx@3
  int v8; // edi@3
  unsigned int result; // eax@4
  unsigned int v10; // [sp+Ch] [bp-4h]@2
  int v11; // [sp+18h] [bp+8h]@3

  v3 = a1;
  do
  {
    v10 = *(_DWORD *)(v3 + 16);
    if ( v10 >= 4 )
    {
      v4 = *(_DWORD *)(v3 + 44) & ((*(_BYTE *)(*(_DWORD *)v3 + 2) << 8) ^ *(_DWORD *)(v3 + 4 * **(_BYTE **)v3 + 96) ^ *(_BYTE *)(*(_DWORD *)v3 + 1) ^ 32 * *(_DWORD *)(v3 + 4 * *(_BYTE *)(*(_DWORD *)v3 + 3) + 96));
      v5 = (unsigned __int16)((*(_BYTE *)(*(_DWORD *)v3 + 2) << 8) ^ *(_WORD *)(v3 + 4 * **(_BYTE **)v3 + 96) ^ *(_BYTE *)(*(_DWORD *)v3 + 1));
      v6 = *(_DWORD *)(v3 + 36);
      v7 = (*(_WORD *)(v3 + 4 * **(_BYTE **)v3 + 96) ^ *(_BYTE *)(*(_DWORD *)v3 + 1)) & 0x3FF;
      v11 = *(_DWORD *)(v6 + 4 * v4 + 266240);
      v8 = *(_DWORD *)(v3 + 4);
      *(_DWORD *)(v6 + 4 * v4 + 266240) = v8;
      *(_DWORD *)(v6 + 4 * v5 + 4096) = v8;
      *(_DWORD *)(v6 + 4 * v7) = v8;
      sub_10028900(
        v10,
        v11,
        *(_DWORD *)(v3 + 4),
        *(_DWORD *)v3,
        *(_DWORD *)(v3 + 40),
        *(_DWORD *)(v3 + 20),
        *(_DWORD *)(v3 + 24),
        *(_DWORD *)(v3 + 48));
    }
    ++*(_DWORD *)(v3 + 20);
    ++*(_DWORD *)v3;
    result = ++*(_DWORD *)(v3 + 4);
    if ( result == *(_DWORD *)(v3 + 8) )
      result = sub_10028630(v2, v3);
    --a2;
  }
  while ( a2 );
  return result;
}

//----- (100291B0) --------------------------------------------------------
unsigned int __cdecl sub_100291B0(int a1, int a2)
{
  unsigned int v2; // ecx@0
  int v3; // esi@1
  int v4; // edx@3
  int v5; // ecx@3
  int v6; // ebx@3
  int v7; // eax@3
  int v8; // edi@3
  unsigned int result; // eax@4
  unsigned int v10; // [sp+14h] [bp+8h]@3

  v3 = a1;
  do
  {
    if ( *(_DWORD *)(v3 + 16) >= 4u )
    {
      v4 = (*(_WORD *)(v3 + 4 * **(_BYTE **)v3 + 96) ^ *(_BYTE *)(*(_DWORD *)v3 + 1)) & 0x3FF;
      v5 = *(_DWORD *)(v3 + 44) & ((*(_BYTE *)(*(_DWORD *)v3 + 2) << 8) ^ *(_DWORD *)(v3 + 4 * **(_BYTE **)v3 + 96) ^ *(_BYTE *)(*(_DWORD *)v3 + 1) ^ 32 * *(_DWORD *)(v3 + 4 * *(_BYTE *)(*(_DWORD *)v3 + 3) + 96));
      v6 = (unsigned __int16)((*(_BYTE *)(*(_DWORD *)v3 + 2) << 8) ^ *(_WORD *)(v3 + 4 * **(_BYTE **)v3 + 96) ^ *(_BYTE *)(*(_DWORD *)v3 + 1));
      v7 = *(_DWORD *)(v3 + 36);
      v10 = *(_DWORD *)(v7 + 4 * v5 + 266240);
      v8 = *(_DWORD *)(v3 + 4);
      *(_DWORD *)(v7 + 4 * v5 + 266240) = v8;
      v2 = v10;
      *(_DWORD *)(v7 + 4 * v6 + 4096) = v8;
      *(_DWORD *)(v7 + 4 * v4) = v8;
      *(_DWORD *)(*(_DWORD *)(v3 + 40) + 4 * *(_DWORD *)(v3 + 20)) = v10;
    }
    ++*(_DWORD *)(v3 + 20);
    ++*(_DWORD *)v3;
    result = ++*(_DWORD *)(v3 + 4);
    if ( result == *(_DWORD *)(v3 + 8) )
      result = sub_10028630(v2, v3);
    --a2;
  }
  while ( a2 );
  return result;
}

//----- (10029250) --------------------------------------------------------
int __usercall sub_10029250@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // ecx@3

  *(_DWORD *)result = sub_100285B0;
  *(_DWORD *)(result + 4) = sub_10028240;
  *(_DWORD *)(result + 8) = unknown_libname_1;
  if ( *(_BYTE *)(a2 + 29) )
  {
    v2 = *(_DWORD *)(a2 + 72);
    if ( v2 == 2 )
    {
      *(_DWORD *)(result + 12) = sub_10028A10;
      *(_DWORD *)(result + 16) = sub_10028FD0;
    }
    else if ( v2 == 3 )
    {
      *(_DWORD *)(result + 12) = sub_10028AB0;
      *(_DWORD *)(result + 16) = sub_10029050;
    }
    else
    {
      *(_DWORD *)(result + 12) = sub_10028C30;
      *(_DWORD *)(result + 16) = sub_100290F0;
    }
  }
  else
  {
    *(_DWORD *)(result + 12) = sub_10028E00;
    *(_DWORD *)(result + 16) = sub_100291B0;
  }
  return result;
}
// 10028230: using guessed type int __cdecl unknown_libname_1(int);

//----- (100292C0) --------------------------------------------------------
void __usercall sub_100292C0(int a1@<esi>)
{
  void *v1; // eax@2
  void *v2; // edx@9

  if ( *(_DWORD *)(a1 + 4) )
  {
    v1 = *(void **)(a1 + 24);
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 72) = 1;
    if ( !ResetEvent(v1) )
      GetLastError();
    if ( !ResetEvent(*(HANDLE *)(a1 + 28)) )
      GetLastError();
    if ( !SetEvent(*(HANDLE *)(a1 + 20)) )
      GetLastError();
    WaitForSingleObject(*(HANDLE *)(a1 + 24), 0xFFFFFFFF);
  }
  else
  {
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
    v2 = *(void **)(a1 + 32);
    ++*(_DWORD *)(a1 + 72);
    *(_DWORD *)(a1 + 44) = 0;
    if ( !ReleaseSemaphore(v2, 1, 0) )
      GetLastError();
  }
  WaitForSingleObject(*(HANDLE *)(a1 + 36), 0xFFFFFFFF);
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
  *(_DWORD *)(a1 + 44) = 1;
}

//----- (10029370) --------------------------------------------------------
void __usercall sub_10029370(int a1@<esi>)
{
  int v1; // edi@1
  bool v2; // zf@3

  v1 = *(_DWORD *)(a1 + 72);
  if ( *(_DWORD *)(a1 + 16) && !*(_DWORD *)(a1 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 44) == 0;
    *(_DWORD *)(a1 + 12) = 1;
    if ( !v2 )
    {
      LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
      *(_DWORD *)(a1 + 44) = 0;
    }
    if ( !ReleaseSemaphore(*(HANDLE *)(a1 + 32), 1, 0) )
      GetLastError();
    WaitForSingleObject(*(HANDLE *)(a1 + 28), 0xFFFFFFFF);
    while ( v1 != *(_DWORD *)(a1 + 72) )
    {
      ++v1;
      WaitForSingleObject(*(HANDLE *)(a1 + 36), 0xFFFFFFFF);
      if ( !ReleaseSemaphore(*(HANDLE *)(a1 + 32), 1, 0) )
        GetLastError();
    }
    *(_DWORD *)(a1 + 4) = 1;
  }
}

//----- (10029400) --------------------------------------------------------
DWORD __usercall sub_10029400@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  DWORD result; // eax@27

  v1 = a1;
  if ( *(_DWORD *)(a1 + 16) )
  {
    sub_10029370(a1);
    *(_DWORD *)(v1 + 8) = 1;
    if ( *(_DWORD *)(v1 + 4) && !SetEvent(*(HANDLE *)(v1 + 20)) )
      GetLastError();
    WaitForSingleObject(*(HANDLE *)(v1 + 16), 0xFFFFFFFF);
    if ( !*(_DWORD *)(v1 + 16) || CloseHandle(*(HANDLE *)(v1 + 16)) )
      *(_DWORD *)(v1 + 16) = 0;
    else
      GetLastError();
  }
  if ( *(_DWORD *)(v1 + 40) )
  {
    DeleteCriticalSection((LPCRITICAL_SECTION)(v1 + 48));
    *(_DWORD *)(v1 + 40) = 0;
  }
  if ( !*(_DWORD *)(v1 + 20) || CloseHandle(*(HANDLE *)(v1 + 20)) )
    *(_DWORD *)(v1 + 20) = 0;
  else
    GetLastError();
  if ( !*(_DWORD *)(v1 + 24) || CloseHandle(*(HANDLE *)(v1 + 24)) )
    *(_DWORD *)(v1 + 24) = 0;
  else
    GetLastError();
  if ( !*(_DWORD *)(v1 + 28) || CloseHandle(*(HANDLE *)(v1 + 28)) )
    *(_DWORD *)(v1 + 28) = 0;
  else
    GetLastError();
  if ( !*(_DWORD *)(v1 + 32) || CloseHandle(*(HANDLE *)(v1 + 32)) )
    *(_DWORD *)(v1 + 32) = 0;
  else
    GetLastError();
  result = *(_DWORD *)(v1 + 36);
  if ( !result || (result = CloseHandle(*(HANDLE *)(v1 + 36))) != 0 )
  {
    *(_DWORD *)(v1 + 36) = 0;
    *(_DWORD *)v1 = 0;
  }
  else
  {
    result = GetLastError();
    *(_DWORD *)v1 = 0;
  }
  return result;
}

//----- (10029500) --------------------------------------------------------
signed int __usercall sub_10029500@<eax>(LONG a1@<edi>, int a2@<esi>, int a3, int a4)
{
  HANDLE v4; // eax@3

  if ( !*(_DWORD *)a2 )
  {
    if ( sub_1002A4E0((LPCRITICAL_SECTION)(a2 + 48)) )
      return 12;
    *(_DWORD *)(a2 + 40) = 1;
    v4 = CreateEventW(0, 0, 0, 0);
    *(_DWORD *)(a2 + 20) = v4;
    if ( !v4 )
    {
      GetLastError();
      return 12;
    }
    if ( sub_1002A480((_DWORD *)(a2 + 24)) )
      return 12;
    if ( sub_1002A480((_DWORD *)(a2 + 28)) )
      return 12;
    if ( sub_1002A4B0(a1, a1, a2 + 32) )
      return 12;
    if ( sub_1002A4B0(0, a1, a2 + 36) )
      return 12;
    *(_DWORD *)(a2 + 4) = 1;
    if ( sub_1002A440(a3, a4, (int *)(a2 + 16)) )
      return 12;
    *(_DWORD *)a2 = 1;
  }
  return 0;
}

//----- (100295C0) --------------------------------------------------------
int __cdecl sub_100295C0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ecx@2
  int v7; // esi@2
  int result; // eax@3

  if ( a6 )
  {
    v6 = a2;
    v7 = a5;
    do
    {
      result = *(_BYTE *)(a1 - a2 + v6) | (*(_BYTE *)(a1 - a2 + v6 + 1) << 8);
      v7 += 4;
      *(_DWORD *)(v7 - 4) = v6 - *(_DWORD *)(a3 + 4 * result);
      *(_DWORD *)(a3 + 4 * result) = v6++;
      --a6;
    }
    while ( a6 );
  }
  return result;
}

//----- (10029610) --------------------------------------------------------
void __cdecl sub_10029610(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7)
{
  int v7; // edx@2
  _DWORD *v8; // esi@2
  int v9; // ecx@2
  int v10; // eax@3

  if ( a6 )
  {
    v7 = a2;
    v8 = a5;
    v9 = a1 + 1;
    do
    {
      v10 = a4 & (*(_BYTE *)v9 ^ *(_DWORD *)(a7 + 4 * *(_BYTE *)(v9 - 1)) ^ (*(_BYTE *)(v9 + 1) << 8));
      ++v9;
      *v8 = v7 - *(_DWORD *)(a3 + 4 * v10);
      *(_DWORD *)(a3 + 4 * v10) = v7;
      ++v8;
      ++v7;
      --a6;
    }
    while ( a6 );
  }
}

//----- (10029670) --------------------------------------------------------
void __cdecl sub_10029670(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7)
{
  int v7; // edx@2
  _DWORD *v8; // esi@2
  int v9; // ecx@2
  int v10; // eax@3

  if ( a6 )
  {
    v7 = a2;
    v8 = a5;
    v9 = a1 + 2;
    do
    {
      v10 = a4 & (*(_BYTE *)(v9 - 1) ^ *(_DWORD *)(a7 + 4 * *(_BYTE *)(v9 - 2)) ^ 32
                                                                                * (*(_DWORD *)(a7
                                                                                             + 4 * *(_BYTE *)(v9 + 1)) ^ 8 * *(_BYTE *)v9));
      ++v9;
      *v8 = v7 - *(_DWORD *)(a3 + 4 * v10);
      *(_DWORD *)(a3 + 4 * v10) = v7;
      ++v8;
      ++v7;
      --a6;
    }
    while ( a6 );
  }
}

//----- (100296E0) --------------------------------------------------------
void __cdecl sub_100296E0(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7)
{
  int v7; // edx@2
  _DWORD *v8; // esi@2
  int v9; // ecx@2
  int v10; // eax@3

  if ( a6 )
  {
    v7 = a2;
    v8 = a5;
    v9 = a1 + 2;
    do
    {
      v10 = a4 & (*(_BYTE *)(v9 - 1) ^ *(_DWORD *)(a7 + 4 * *(_BYTE *)(v9 - 2)) ^ ((*(_BYTE *)v9 ^ (*(_BYTE *)(v9 + 1) << 8)) << 8));
      ++v9;
      *v8 = v7 - *(_DWORD *)(a3 + 4 * v10);
      *(_DWORD *)(a3 + 4 * v10) = v7;
      ++v8;
      ++v7;
      --a6;
    }
    while ( a6 );
  }
}

//----- (10029740) --------------------------------------------------------
void __usercall sub_10029740(int a1@<ebx>)
{
  BOOL v1; // eax@1
  int v2; // esi@6
  int v3; // edi@8
  int v4; // eax@8
  int v5; // ecx@9
  unsigned int v6; // ecx@12
  int v7; // edx@13
  unsigned int v8; // eax@13
  int v9; // edi@13
  unsigned int v10; // ecx@13
  int v11; // edx@14
  int v12; // edx@15
  unsigned int v13; // edi@18
  int v14; // eax@18
  unsigned int v15; // ecx@18
  void *v16; // ST18_4@23
  unsigned int v17; // [sp+8h] [bp-8h]@13
  _DWORD *v18; // [sp+8h] [bp-8h]@18
  int v19; // [sp+Ch] [bp-4h]@1

LABEL_1:
  v19 = 0;
  WaitForSingleObject(*(HANDLE *)(a1 + 316), 0xFFFFFFFF);
  v1 = SetEvent(*(HANDLE *)(a1 + 320));
LABEL_2:
  if ( !v1 )
    GetLastError();
  while ( !*(_DWORD *)(a1 + 304) )
  {
    if ( *(_DWORD *)(a1 + 308) )
    {
      v16 = *(void **)(a1 + 324);
      *(_DWORD *)(a1 + 368) = v19;
      if ( !SetEvent(v16) )
        GetLastError();
      goto LABEL_1;
    }
    v2 = *(_DWORD *)(a1 + 376);
    if ( *(_BYTE *)(v2 + 31)
      || *(_DWORD *)(v2 + 68) < (unsigned int)(*(_DWORD *)(v2 + 52) + *(_DWORD *)(v2 + 60) - *(_DWORD *)v2) )
    {
      WaitForSingleObject(*(HANDLE *)(a1 + 328), 0xFFFFFFFF);
      if ( !*(_BYTE *)(v2 + 28) && *(_DWORD *)(v2 + 68) >= (unsigned int)(*(_DWORD *)(v2 + 12) - *(_DWORD *)(v2 + 4)) )
        sub_10028250(v5, v2);
      v6 = *(_DWORD *)(v2 + 4);
      if ( v6 > 0xFFFFDFFF )
      {
        v7 = *(_DWORD *)(v2 + 36);
        v8 = v6 - *(_DWORD *)(v2 + 80) - 1;
        *(_DWORD *)(v2 + 8) -= v8;
        *(_DWORD *)(v2 + 12) -= v8;
        *(_DWORD *)(v2 + 4) = v6 - v8;
        v17 = *(_DWORD *)(v2 + 44) + 1;
        v9 = v7 + 4 * *(_DWORD *)(v2 + 84);
        v10 = 0;
        if ( *(_DWORD *)(v2 + 44) != -1 )
        {
          do
          {
            v11 = *(_DWORD *)(v9 + 4 * v10);
            if ( v11 > v8 )
              v12 = v11 - v8;
            else
              v12 = 0;
            *(_DWORD *)(v9 + 4 * v10++) = v12;
          }
          while ( v10 < v17 );
        }
      }
      v13 = *(_DWORD *)(v2 + 12) - *(_DWORD *)(v2 + 4);
      v14 = *(_DWORD *)(a1 + 248) + ((v19++ & 7) << 15);
      *(_DWORD *)v14 = 2;
      *(_DWORD *)(v14 + 4) = v13;
      v15 = *(_DWORD *)(v2 + 72);
      v18 = (_DWORD *)v14;
      if ( v13 >= v15 )
      {
        v13 += 1 - v15;
        if ( v13 > 0x1FFE )
          v13 = 8190;
        (*(void (__cdecl **)(int, _DWORD, int, _DWORD, int, unsigned int, int))(a1 + 372))(
          *(_DWORD *)v2,
          *(_DWORD *)(v2 + 4),
          *(_DWORD *)(v2 + 36) + 4 * *(_DWORD *)(v2 + 84),
          *(_DWORD *)(v2 + 44),
          v14 + 8,
          v13,
          v2 + 96);
        *v18 += v13;
      }
      *(_DWORD *)(v2 + 4) += v13;
      *(_DWORD *)v2 += v13;
      v1 = ReleaseSemaphore(*(HANDLE *)(a1 + 332), 1, 0);
      goto LABEL_2;
    }
    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 92));
    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 344));
    v3 = *(_DWORD *)v2;
    memmove(
      *(void **)(v2 + 52),
      (const void *)(*(_DWORD *)v2 - *(_DWORD *)(v2 + 64)),
      *(_DWORD *)(v2 + 64) + *(_DWORD *)(v2 + 12) - *(_DWORD *)(v2 + 4));
    v4 = *(_DWORD *)(v2 + 52) + *(_DWORD *)(v2 + 64);
    *(_DWORD *)v2 = v4;
    *(_DWORD *)(a1 + 280) += v4 - v3;
    *(_DWORD *)a1 += v4 - v3;
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 92));
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 344));
  }
}

//----- (10029950) --------------------------------------------------------
_DWORD *__usercall sub_10029950@<eax>(int a1@<edi>, int a2)
{
  unsigned int v2; // ebx@1
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // ecx@3
  int v6; // eax@3
  int v7; // edx@3
  int v8; // ecx@3
  _DWORD *result; // eax@4
  unsigned int v10; // edx@7
  int v11; // esi@7
  int v12; // ebx@7
  unsigned int v13; // ecx@7
  unsigned int v14; // eax@7
  unsigned int v15; // eax@9
  _DWORD *v16; // esi@17
  int v17; // ecx@17
  int v18; // eax@17
  int v19; // eax@17
  int v20; // eax@18
  unsigned int v21; // [sp+8h] [bp-18h]@1
  int v22; // [sp+Ch] [bp-14h]@1
  int v23; // [sp+10h] [bp-10h]@7
  int v24; // [sp+14h] [bp-Ch]@16
  unsigned int v25; // [sp+18h] [bp-8h]@7
  unsigned int v26; // [sp+1Ch] [bp-4h]@1

  v2 = 2 * (0x2000 - *(_DWORD *)(a1 + 268));
  v22 = 0;
  v26 = 2;
  v21 = v2;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 260);
  if ( v2 <= 2 )
  {
LABEL_22:
    result = (_DWORD *)v26;
    *(_DWORD *)a2 = v26;
    return result;
  }
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 256);
    v4 = *(_DWORD *)(a1 + 252);
    if ( v4 != v3 )
    {
      v10 = *(_DWORD *)(a1 + 268);
      v11 = *(_DWORD *)(a1 + 284);
      v12 = *(_DWORD *)(a1 + 276);
      v13 = v3 - v4;
      v14 = *(_DWORD *)(a1 + 260);
      v23 = v10;
      v25 = *(_DWORD *)(a1 + 284);
      if ( v10 >= v14 )
      {
        v23 = *(_DWORD *)(a1 + 260);
        v10 = *(_DWORD *)(a1 + 260);
      }
      v15 = v14 - v10 + 1;
      if ( v15 < v13 )
        v13 = v15;
      if ( *(_DWORD *)(a1 + 288) - v11 < v13 )
        v13 = *(_DWORD *)(a1 + 288) - v11;
      if ( v26 < v21 )
      {
        while ( 1 )
        {
          v24 = v13 - 1;
          if ( !v13 )
            break;
          v16 = (_DWORD *)(a2 + 4 * v26);
          v17 = *(_DWORD *)(a1 + 252) + 1;
          v18 = v12 - *(_DWORD *)(*(_DWORD *)(a1 + 248) + 4 * v17 - 4);
          *(_DWORD *)(a1 + 252) = v17;
          v19 = (sub_100287C0(
                   v23,
                   v18,
                   v12,
                   *(_DWORD *)(a1 + 280),
                   *(_DWORD *)(a1 + 264),
                   v25,
                   *(_DWORD *)(a1 + 288),
                   *(_DWORD *)(a1 + 292),
                   (int)(v16 + 1),
                   *(_DWORD *)(a1 + 272) - 1)
               - (signed int)v16) >> 2;
          *v16 = v19 - 1;
          ++v25;
          ++*(_DWORD *)(a1 + 280);
          ++v12;
          v26 += v19;
          if ( v26 >= v21 )
            break;
          v13 = v24;
        }
      }
      v20 = *(_DWORD *)(a1 + 276);
      v22 += v12 - v20;
      *(_DWORD *)(a1 + 260) += v20 - v12;
      *(_DWORD *)(a1 + 276) = v12;
      if ( v25 == *(_DWORD *)(a1 + 288) )
        v25 = 0;
      v2 = v21;
      *(_DWORD *)(a1 + 284) = v25;
      goto LABEL_21;
    }
    sub_100292C0(a1 + 296);
    v5 = *(_DWORD *)(a1 + 248);
    v6 = (((unsigned __int8)*(_DWORD *)(a1 + 368) - 1) & 7) << 13;
    *(_DWORD *)(a1 + 252) = v6;
    *(_DWORD *)(a1 + 256) = v6;
    v7 = v6 + *(_DWORD *)(v5 + 4 * v6);
    *(_DWORD *)(a1 + 252) = ++v6;
    *(_DWORD *)(a1 + 256) = v7;
    v8 = *(_DWORD *)(v5 + 4 * v6);
    *(_DWORD *)(a1 + 260) = v8;
    *(_DWORD *)(a1 + 252) = v6 + 1;
    *(_DWORD *)(a2 + 4) = v22 + v8;
    if ( *(_DWORD *)(a1 + 260) < *(_DWORD *)(a1 + 272) )
      break;
LABEL_21:
    if ( v26 >= v2 )
      goto LABEL_22;
  }
  *(_DWORD *)a2 = v26 + *(_DWORD *)(a1 + 260);
  for ( result = (_DWORD *)(a2 + 4 * v26); *(_DWORD *)(a1 + 260); ++result )
  {
    *result = 0;
    --*(_DWORD *)(a1 + 260);
  }
  return result;
}

//----- (10029B90) --------------------------------------------------------
void __usercall sub_10029B90(char a1@<al>, int a2@<ecx>)
{
  int v2; // edi@1
  char v3; // si@1
  unsigned int v4; // eax@3
  int v5; // ecx@4
  int v6; // edx@4
  unsigned int v7; // ebx@4
  unsigned int v8; // esi@4
  unsigned int v9; // eax@4
  int v10; // ecx@5
  int v11; // ecx@6

  v2 = a2;
  v3 = a1;
  if ( !*(_DWORD *)(a2 + 300) )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(a2 + 344));
    *(_DWORD *)(v2 + 340) = 1;
  }
  sub_10029950(v2, *(_DWORD *)(v2 + 4) + ((v3 & 0x3F) << 16));
  v4 = *(_DWORD *)(v2 + 276);
  if ( v4 > 0xFFFFBFFF )
  {
    v5 = *(_DWORD *)(v2 + 288);
    v6 = *(_DWORD *)(v2 + 264);
    v7 = v4 - v5;
    v8 = 2 * v5;
    v9 = 0;
    if ( 2 * v5 )
    {
      do
      {
        v10 = *(_DWORD *)(v6 + 4 * v9);
        if ( v10 > v7 )
          v11 = v10 - v7;
        else
          v11 = 0;
        *(_DWORD *)(v6 + 4 * v9++) = v11;
      }
      while ( v9 < v8 );
    }
    *(_DWORD *)(v2 + 276) -= v7;
  }
  if ( !*(_DWORD *)(v2 + 300) )
  {
    LeaveCriticalSection((LPCRITICAL_SECTION)(v2 + 344));
    *(_DWORD *)(v2 + 340) = 0;
  }
}

//----- (10029C30) --------------------------------------------------------
int __stdcall sub_10029C30(int a1)
{
  sub_10029740(a1);
  return 0;
}

//----- (10029C50) --------------------------------------------------------
int __stdcall sub_10029C50(int a1)
{
  int v1; // esi@1
  BOOL i; // eax@1

LABEL_1:
  v1 = 0;
  WaitForSingleObject(*(HANDLE *)(a1 + 64), 0xFFFFFFFF);
  for ( i = SetEvent(*(HANDLE *)(a1 + 68)); ; i = ReleaseSemaphore(*(HANDLE *)(a1 + 80), 1, 0) )
  {
    if ( !i )
      GetLastError();
    if ( *(_DWORD *)(a1 + 52) )
      break;
    if ( *(_DWORD *)(a1 + 56) )
    {
      *(_DWORD *)(a1 + 116) = v1;
      sub_10029370(a1 + 296);
      if ( !SetEvent(*(HANDLE *)(a1 + 72)) )
        GetLastError();
      goto LABEL_1;
    }
    WaitForSingleObject(*(HANDLE *)(a1 + 76), 0xFFFFFFFF);
    sub_10029B90(v1++, a1);
  }
  return 0;
}

//----- (10029D10) --------------------------------------------------------
signed int __usercall sub_10029D10@<eax>(int (__cdecl **a1)(_DWORD, _DWORD)@<eax>, int a2@<ecx>, int a3@<ebx>, unsigned int a4, int a5)
{
  int v5; // edi@1
  int v6; // esi@1
  signed int result; // eax@2
  int v8; // eax@4
  int v9; // esi@8
  signed int v10; // edi@8
  int v11; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = (int)a1;
  v11 = *(_DWORD *)(a3 + 376);
  *(_DWORD *)(a3 + 32) = a4;
  if ( (unsigned int)(4 * a2) >= 0x4000 )
    return 5;
  if ( !*(_DWORD *)(a3 + 248) )
  {
    v8 = (*a1)(a1, 4456448);
    *(_DWORD *)(a3 + 248) = v8;
    if ( !v8 )
      return 2;
    *(_DWORD *)(a3 + 4) = v8 + 0x40000;
  }
  if ( !sub_10028410(v6, v11, a4, a5 + 1114112, v5, 8465) )
    return 2;
  v9 = a3 + 296;
  v10 = sub_10029500(8, a3 + 296, (int)sub_10029C30, a3);
  if ( v10 || (v9 = a3 + 44, result = sub_10029500(64, a3 + 44, (int)sub_10029C50, a3), (v10 = result) != 0) )
  {
    sub_10029400(v9);
    result = v10;
  }
  return result;
}

//----- (10029DF0) --------------------------------------------------------
int __cdecl sub_10029DF0(int a1)
{
  int v1; // edi@1
  int v2; // ST00_4@1
  int v3; // eax@1
  int v4; // ecx@1
  int result; // eax@1

  v1 = *(_DWORD *)(a1 + 376);
  v2 = *(_DWORD *)(a1 + 376);
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 252) = 0;
  sub_100285B0(v2);
  v3 = *(_DWORD *)v1;
  v4 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)a1 = v3;
  *(_DWORD *)(a1 + 16) = v4 + 1;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(v1 + 36);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(v1 + 84);
  *(_DWORD *)(a1 + 36) = v1 + 96;
  *(_DWORD *)(a1 + 264) = *(_DWORD *)(v1 + 40);
  *(_DWORD *)(a1 + 268) = *(_DWORD *)(v1 + 32);
  *(_DWORD *)(a1 + 272) = *(_DWORD *)(v1 + 72);
  *(_DWORD *)(a1 + 276) = *(_DWORD *)(v1 + 4);
  *(_DWORD *)(a1 + 280) = *(_DWORD *)v1;
  *(_DWORD *)(a1 + 284) = *(_DWORD *)(v1 + 20);
  *(_DWORD *)(a1 + 288) = *(_DWORD *)(v1 + 24);
  result = *(_DWORD *)(v1 + 48);
  *(_DWORD *)(a1 + 292) = result;
  return result;
}

//----- (10029E90) --------------------------------------------------------
unsigned int __usercall sub_10029E90@<eax>(int a1@<edi>)
{
  int v1; // ecx@1
  int v2; // eax@1
  int v3; // edx@1
  int v4; // ecx@1
  unsigned int result; // eax@1
  int v6; // esi@2
  unsigned int v7; // ebx@2
  unsigned int v8; // ecx@2
  int v9; // edx@3
  int v10; // edx@4

  sub_100292C0(a1 + 44);
  v1 = *(_DWORD *)(a1 + 4);
  v2 = (((unsigned __int8)*(_DWORD *)(a1 + 116) - 1) & 0x3F) << 14;
  *(_DWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 12) = v2;
  v3 = v2 + *(_DWORD *)(v1 + 4 * v2);
  *(_DWORD *)(a1 + 8) = ++v2;
  *(_DWORD *)(a1 + 12) = v3;
  v4 = *(_DWORD *)(v1 + 4 * v2);
  *(_DWORD *)(a1 + 8) = v2 + 1;
  result = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 20) = v4;
  if ( result >= 0xFFFFBFFF )
  {
    v6 = *(_DWORD *)(a1 + 24);
    v7 = *(_DWORD *)(a1 + 28);
    result = result - *(_DWORD *)(a1 + 32) - 1;
    v8 = 0;
    if ( v7 )
    {
      do
      {
        v9 = *(_DWORD *)(v6 + 4 * v8);
        if ( v9 > result )
          v10 = v9 - result;
        else
          v10 = 0;
        *(_DWORD *)(v6 + 4 * v8++) = v10;
      }
      while ( v8 < v7 );
    }
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 32) + 1;
  }
  return result;
}

//----- (10029F00) --------------------------------------------------------
int __cdecl sub_10029F00(int a1)
{
  if ( *(_DWORD *)(a1 + 8) == *(_DWORD *)(a1 + 12) )
    sub_10029E90(a1);
  return *(_DWORD *)(a1 + 20);
}

//----- (10029F20) --------------------------------------------------------
int __cdecl sub_10029F20(int a1, unsigned int a2, int a3)
{
  _BYTE *v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // eax@1
  unsigned int v7; // esi@1
  int result; // eax@2

  v3 = *(_BYTE **)a1;
  v4 = *(_DWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a1 + 24);
  v6 = (*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4 * **(_BYTE **)a1) ^ *(_BYTE *)(*(_DWORD *)a1 + 1)) & 0x3FF;
  v7 = *(_DWORD *)(v5 + 4 * v6);
  *(_DWORD *)(v5 + 4 * v6) = v4;
  if ( v7 < a2 )
  {
    result = a3;
  }
  else
  {
    result = a3;
    if ( v3[v7 - v4] == *v3 )
    {
      *(_DWORD *)a3 = 2;
      *(_DWORD *)(a3 + 4) = v4 - v7 - 1;
      result = a3 + 8;
    }
  }
  return result;
}

//----- (10029F80) --------------------------------------------------------
int __cdecl sub_10029F80(int a1, unsigned int a2, int a3)
{
  _BYTE *v3; // edx@1
  int v4; // ecx@1
  int v5; // esi@1
  int v6; // ebx@1
  int v7; // eax@1
  unsigned int v8; // edi@1
  int v10; // esi@5
  unsigned int v11; // [sp+14h] [bp+8h]@1

  v3 = *(_BYTE **)a1;
  v4 = *(_DWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a1 + 24);
  v6 = (*(_WORD *)(*(_DWORD *)(a1 + 36) + 4 * **(_BYTE **)a1) ^ *(_BYTE *)(*(_DWORD *)a1 + 1)) & 0x3FF;
  v7 = (unsigned __int16)(*(_WORD *)(*(_DWORD *)(a1 + 36) + 4 * **(_BYTE **)a1) ^ *(_BYTE *)(*(_DWORD *)a1 + 1) ^ (*(_BYTE *)(*(_DWORD *)a1 + 2) << 8));
  v11 = *(_DWORD *)(v5 + 4 * v6);
  v8 = *(_DWORD *)(v5 + 4 * v7 + 4096);
  *(_DWORD *)(v5 + 4 * v6) = v4;
  *(_DWORD *)(v5 + 4 * v7 + 4096) = v4;
  if ( v11 < a2 || v3[v11 - v4] != *v3 )
  {
    v10 = a3;
  }
  else
  {
    *(_DWORD *)(a3 + 4) = v4 - v11 - 1;
    if ( v3[v11 - v4 + 2] == v3[2] )
    {
      *(_DWORD *)a3 = 3;
      return a3 + 8;
    }
    *(_DWORD *)a3 = 2;
    v10 = a3 + 8;
  }
  if ( v8 >= a2 && v3[v8 - v4] == *v3 )
  {
    *(_DWORD *)v10 = 3;
    *(_DWORD *)(v10 + 4) = v4 - v8 - 1;
    v10 += 8;
  }
  return v10;
}

//----- (1002A040) --------------------------------------------------------
int __cdecl sub_1002A040(int a1, int a2)
{
  int v2; // edx@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // ecx@1
  int v6; // edx@2
  unsigned int v7; // edi@2

  v2 = *(_DWORD *)(a1 + 8);
  v3 = (int *)(*(_DWORD *)(a1 + 4) + 4 * v2);
  result = *v3;
  --*(_DWORD *)(a1 + 20);
  v5 = (int)(v3 + 1);
  *(_DWORD *)(a1 + 8) = v2 + result + 1;
  if ( result )
  {
    v6 = a2;
    v7 = ((unsigned int)(result - 1) >> 1) + 1;
    do
    {
      *(_DWORD *)v6 = *(_DWORD *)v5;
      *(_DWORD *)(v6 + 4) = *(_DWORD *)(v5 + 4);
      v6 += 8;
      v5 += 8;
      --v7;
    }
    while ( v7 );
  }
  ++*(_DWORD *)(a1 + 16);
  ++*(_DWORD *)a1;
  return result;
}

//----- (1002A090) --------------------------------------------------------
int __cdecl sub_1002A090(int a1, int a2)
{
  int v2; // eax@1
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // esi@1
  unsigned int v6; // eax@2
  int v7; // eax@3
  int v9; // edx@4
  int v10; // eax@4

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a1 + 4);
  v4 = *(_DWORD *)(v3 + 4 * v2);
  v5 = v3 + 4 * v2 + 4;
  *(_DWORD *)(a1 + 8) = v2 + v4 + 1;
  if ( v4 )
  {
    v9 = *(_DWORD *)(a1 + 16);
    --*(_DWORD *)(a1 + 20);
    v10 = (*(int (__cdecl **)(int, int, int))(a1 + 40))(a1, v9 - *(_DWORD *)(v3 + 4 * v2 + 8), a2);
    do
    {
      *(_DWORD *)v10 = *(_DWORD *)v5;
      *(_DWORD *)(v10 + 4) = *(_DWORD *)(v5 + 4);
      v10 += 8;
      v5 += 8;
      v4 -= 2;
    }
    while ( v4 );
    v4 = (v10 - a2) >> 2;
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 20) = v6 - 1;
    if ( v6 >= 4 )
    {
      v7 = (*(int (__cdecl **)(int, int, int))(a1 + 40))(a1, *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 32), a2);
      ++*(_DWORD *)(a1 + 16);
      ++*(_DWORD *)a1;
      return (v7 - a2) >> 2;
    }
  }
  ++*(_DWORD *)(a1 + 16);
  ++*(_DWORD *)a1;
  return v4;
}

//----- (1002A130) --------------------------------------------------------
int __cdecl sub_1002A130(int a1, int a2)
{
  int v2; // ecx@2
  int v3; // eax@2
  int v4; // edx@2
  int v5; // ecx@2
  unsigned int v6; // eax@2
  unsigned int v7; // ebx@3
  int v8; // esi@3
  unsigned int v9; // eax@3
  unsigned int v10; // ecx@3
  int v11; // edx@4
  int v12; // edx@5
  int v13; // eax@9
  int v14; // edx@9
  bool v15; // zf@9
  int result; // eax@9

  do
  {
    if ( *(_DWORD *)(a1 + 8) == *(_DWORD *)(a1 + 12) )
    {
      sub_100292C0(a1 + 44);
      v2 = *(_DWORD *)(a1 + 4);
      v3 = (((unsigned __int8)*(_DWORD *)(a1 + 116) - 1) & 0x3F) << 14;
      *(_DWORD *)(a1 + 8) = v3;
      *(_DWORD *)(a1 + 12) = v3;
      v4 = v3 + *(_DWORD *)(v2 + 4 * v3);
      *(_DWORD *)(a1 + 8) = ++v3;
      *(_DWORD *)(a1 + 12) = v4;
      v5 = *(_DWORD *)(v2 + 4 * v3);
      *(_DWORD *)(a1 + 8) = v3 + 1;
      v6 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 20) = v5;
      if ( v6 >= 0xFFFFBFFF )
      {
        v7 = *(_DWORD *)(a1 + 28);
        v8 = *(_DWORD *)(a1 + 24);
        v9 = v6 - *(_DWORD *)(a1 + 32) - 1;
        v10 = 0;
        if ( v7 )
        {
          do
          {
            v11 = *(_DWORD *)(v8 + 4 * v10);
            if ( v11 > v9 )
              v12 = v11 - v9;
            else
              v12 = 0;
            *(_DWORD *)(v8 + 4 * v10++) = v12;
          }
          while ( v10 < v7 );
        }
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 32) + 1;
      }
    }
    v13 = *(_DWORD *)(a1 + 8);
    --*(_DWORD *)(a1 + 20);
    v14 = *(_DWORD *)(a1 + 4);
    ++*(_DWORD *)(a1 + 16);
    ++*(_DWORD *)a1;
    v15 = a2-- == 1;
    result = *(_DWORD *)(v14 + 4 * v13) + v13 + 1;
    *(_DWORD *)(a1 + 8) = result;
  }
  while ( !v15 );
  return result;
}

//----- (1002A1E0) --------------------------------------------------------
int __cdecl sub_1002A1E0(int a1, int a2)
{
  int v2; // ecx@2
  int v3; // eax@2
  int v4; // edx@2
  int v5; // ecx@2
  unsigned int v6; // eax@2
  unsigned int v7; // ebx@3
  int v8; // esi@3
  unsigned int v9; // eax@3
  unsigned int v10; // ecx@3
  int v11; // edx@4
  int v12; // edx@5
  unsigned int v13; // eax@9
  int v14; // eax@11
  int v15; // edx@11
  bool v16; // zf@11
  int result; // eax@11

  do
  {
    if ( *(_DWORD *)(a1 + 8) == *(_DWORD *)(a1 + 12) )
    {
      sub_100292C0(a1 + 44);
      v2 = *(_DWORD *)(a1 + 4);
      v3 = (((unsigned __int8)*(_DWORD *)(a1 + 116) - 1) & 0x3F) << 14;
      *(_DWORD *)(a1 + 8) = v3;
      *(_DWORD *)(a1 + 12) = v3;
      v4 = v3 + *(_DWORD *)(v2 + 4 * v3);
      *(_DWORD *)(a1 + 8) = ++v3;
      *(_DWORD *)(a1 + 12) = v4;
      v5 = *(_DWORD *)(v2 + 4 * v3);
      *(_DWORD *)(a1 + 8) = v3 + 1;
      v6 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 20) = v5;
      if ( v6 >= 0xFFFFBFFF )
      {
        v7 = *(_DWORD *)(a1 + 28);
        v8 = *(_DWORD *)(a1 + 24);
        v9 = v6 - *(_DWORD *)(a1 + 32) - 1;
        v10 = 0;
        if ( v7 )
        {
          do
          {
            v11 = *(_DWORD *)(v8 + 4 * v10);
            if ( v11 > v9 )
              v12 = v11 - v9;
            else
              v12 = 0;
            *(_DWORD *)(v8 + 4 * v10++) = v12;
          }
          while ( v10 < v7 );
        }
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 32) + 1;
      }
    }
    v13 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 20) = v13 - 1;
    if ( v13 >= 2 )
      *(_DWORD *)(*(_DWORD *)(a1 + 24)
                + 4 * ((*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4 * **(_BYTE **)a1) ^ *(_BYTE *)(*(_DWORD *)a1 + 1)) & 0x3FF)) = *(_DWORD *)(a1 + 16);
    v14 = *(_DWORD *)(a1 + 8);
    v15 = *(_DWORD *)(a1 + 4);
    ++*(_DWORD *)(a1 + 16);
    ++*(_DWORD *)a1;
    v16 = a2-- == 1;
    result = *(_DWORD *)(v15 + 4 * v14) + v14 + 1;
    *(_DWORD *)(a1 + 8) = result;
  }
  while ( !v16 );
  return result;
}

//----- (1002A2C0) --------------------------------------------------------
int __cdecl sub_1002A2C0(int a1, int a2)
{
  int v2; // ecx@2
  int v3; // eax@2
  int v4; // edx@2
  int v5; // ecx@2
  unsigned int v6; // eax@2
  unsigned int v7; // ebx@3
  int v8; // esi@3
  unsigned int v9; // eax@3
  unsigned int v10; // ecx@3
  int v11; // edx@4
  int v12; // edx@5
  unsigned int v13; // eax@9
  int v14; // esi@10
  __int16 v15; // dx@10
  int v16; // ecx@10
  int v17; // eax@10
  int v18; // eax@11
  int v19; // edx@11
  bool v20; // zf@11
  int result; // eax@11

  do
  {
    if ( *(_DWORD *)(a1 + 8) == *(_DWORD *)(a1 + 12) )
    {
      sub_100292C0(a1 + 44);
      v2 = *(_DWORD *)(a1 + 4);
      v3 = (((unsigned __int8)*(_DWORD *)(a1 + 116) - 1) & 0x3F) << 14;
      *(_DWORD *)(a1 + 8) = v3;
      *(_DWORD *)(a1 + 12) = v3;
      v4 = v3 + *(_DWORD *)(v2 + 4 * v3);
      *(_DWORD *)(a1 + 8) = ++v3;
      *(_DWORD *)(a1 + 12) = v4;
      v5 = *(_DWORD *)(v2 + 4 * v3);
      *(_DWORD *)(a1 + 8) = v3 + 1;
      v6 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 20) = v5;
      if ( v6 >= 0xFFFFBFFF )
      {
        v7 = *(_DWORD *)(a1 + 28);
        v8 = *(_DWORD *)(a1 + 24);
        v9 = v6 - *(_DWORD *)(a1 + 32) - 1;
        v10 = 0;
        if ( v7 )
        {
          do
          {
            v11 = *(_DWORD *)(v8 + 4 * v10);
            if ( v11 > v9 )
              v12 = v11 - v9;
            else
              v12 = 0;
            *(_DWORD *)(v8 + 4 * v10++) = v12;
          }
          while ( v10 < v7 );
        }
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 32) + 1;
      }
    }
    v13 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 20) = v13 - 1;
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 24);
      v15 = *(_WORD *)(*(_DWORD *)(a1 + 36) + 4 * **(_BYTE **)a1) ^ *(_BYTE *)(*(_DWORD *)a1 + 1);
      v16 = *(_DWORD *)(a1 + 16);
      v17 = (unsigned __int16)(v15 ^ (*(_BYTE *)(*(_DWORD *)a1 + 2) << 8));
      *(_DWORD *)(v14 + 4 * (v15 & 0x3FF)) = v16;
      *(_DWORD *)(v14 + 4 * v17 + 4096) = v16;
    }
    v18 = *(_DWORD *)(a1 + 8);
    v19 = *(_DWORD *)(a1 + 4);
    ++*(_DWORD *)(a1 + 16);
    ++*(_DWORD *)a1;
    v20 = a2-- == 1;
    result = *(_DWORD *)(v19 + 4 * v18) + v18 + 1;
    *(_DWORD *)(a1 + 8) = result;
  }
  while ( !v20 );
  return result;
}

//----- (1002A3B0) --------------------------------------------------------
int __usercall sub_1002A3B0@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  void (__cdecl *v3)(int, int, int, int, _DWORD *, int, int); // edx@3

  *(_DWORD *)result = sub_10029DF0;
  *(_DWORD *)(result + 4) = sub_10029F00;
  *(_DWORD *)(result + 8) = unknown_libname_1;
  *(_DWORD *)(result + 12) = sub_1002A090;
  v2 = *(_DWORD *)(a2 + 376);
  if ( *(_DWORD *)(v2 + 72) == 2 )
  {
    *(_DWORD *)(a2 + 372) = sub_100295C0;
    *(_DWORD *)(a2 + 40) = 0;
    *(_DWORD *)(result + 16) = sub_1002A130;
    *(_DWORD *)(result + 12) = sub_1002A040;
  }
  else if ( *(_DWORD *)(v2 + 72) == 3 )
  {
    *(_DWORD *)(a2 + 372) = sub_10029610;
    *(_DWORD *)(a2 + 40) = sub_10029F20;
    *(_DWORD *)(result + 16) = sub_1002A1E0;
  }
  else
  {
    v3 = sub_100296E0;
    if ( !*(_BYTE *)(v2 + 30) )
      v3 = sub_10029670;
    *(_DWORD *)(a2 + 372) = v3;
    *(_DWORD *)(a2 + 40) = sub_10029F80;
    *(_DWORD *)(result + 16) = sub_1002A2C0;
  }
  return result;
}
// 10028230: using guessed type int __cdecl unknown_libname_1(int);

//----- (1002A440) --------------------------------------------------------
DWORD __usercall sub_1002A440@<eax>(int a1@<edx>, int a2@<ecx>, int *a3)
{
  int v3; // eax@1
  DWORD result; // eax@2
  int v5; // [sp+0h] [bp-4h]@1

  v5 = a2;
  v3 = beginthreadex(0, 0, a1, a2, 0, &v5);
  *a3 = v3;
  if ( v3 )
  {
    result = 0;
  }
  else
  {
    result = GetLastError();
    if ( !result )
      result = 1;
  }
  return result;
}
// 10099118: using guessed type int __cdecl beginthreadex(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002A480) --------------------------------------------------------
DWORD __cdecl sub_1002A480(_DWORD *a1)
{
  HANDLE v1; // eax@1
  DWORD result; // eax@2

  v1 = CreateEventW(0, 0, 0, 0);
  *a1 = v1;
  if ( v1 )
  {
    result = 0;
  }
  else
  {
    result = GetLastError();
    if ( !result )
      result = 1;
  }
  return result;
}

//----- (1002A4B0) --------------------------------------------------------
DWORD __usercall sub_1002A4B0@<eax>(LONG lInitialCount@<ecx>, LONG a2@<eax>, int a3)
{
  HANDLE v3; // eax@1
  DWORD result; // eax@2

  v3 = CreateSemaphoreW(0, lInitialCount, a2, 0);
  *(_DWORD *)a3 = v3;
  if ( v3 )
  {
    result = 0;
  }
  else
  {
    result = GetLastError();
    if ( !result )
      result = 1;
  }
  return result;
}

//----- (1002A4E0) --------------------------------------------------------
int __cdecl sub_1002A4E0(LPCRITICAL_SECTION lpCriticalSection)
{
  InitializeCriticalSection(lpCriticalSection);
  return 0;
}

//----- (1002A570) --------------------------------------------------------
int __usercall sub_1002A570@<eax>(int a1@<edx>, int a2@<ecx>, int a3, __int16 a4)
{
  int v4; // esi@1
  int v5; // edi@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // eax@7
  int v9; // ebx@7
  int v10; // edx@10
  int result; // eax@11
  int *v12; // ecx@13
  int v13; // [sp-4h] [bp-384h]@13
  int v14; // [sp+18h] [bp-368h]@1
  int v15; // [sp+1Ch] [bp-364h]@7
  int v16; // [sp+20h] [bp-360h]@9
  int v17; // [sp+168h] [bp-218h]@17
  int v18; // [sp+16Ch] [bp-214h]@18
  char v19; // [sp+170h] [bp-210h]@17
  int v20; // [sp+33Ch] [bp-44h]@10
  int v21; // [sp+340h] [bp-40h]@11
  char v22; // [sp+344h] [bp-3Ch]@10
  int v23; // [sp+37Ch] [bp-4h]@10
  int v24; // [sp+38Ch] [bp+Ch]@7

  v4 = a2;
  v5 = a1;
  v6 = a4 & 7;
  v7 = a4 & 0x118;
  v14 = v5;
  if ( v6 != 2 && v6 != 4 )
    v6 = 1;
  if ( v7 != 16 && v7 != 256 )
    v7 = 8;
  v8 = v6 | v7 | a4 & 0x80;
  v9 = v8;
  v24 = v6 | v7 | a4 & 0x80;
  v15 = v5;
  if ( v8 & 6 )
  {
    v5 += 8;
    v15 = v5;
  }
  sub_10031480(v8, v4, (int)&v16, a3);
  if ( v16 == 1 )
  {
    sub_1002CAA0(v9, (int)&v16, (int)&v20);
    v23 = 0;
    v10 = v20;
    if ( v22 & 1 )
    {
      result = (*(int (__thiscall **)(int *, int))(v20 + 4))(&v20, v15);
      if ( !*(_BYTE *)(v21 + 324) )
        result = (*(int (__thiscall **)(int *, int))(v20 + 8))(&v20, v15);
      goto LABEL_25;
    }
    v13 = v15;
    v12 = &v20;
LABEL_14:
    result = (*(int (__thiscall **)(int *, int))(v10 + 8))(v12, v13);
    goto LABEL_25;
  }
  if ( v9 & 0x10 || !v16 )
  {
    sub_1002ABF0(v9, (int)&v20, (int)&v16);
    v23 = 1;
    if ( v22 & 1 )
    {
      result = (*(int (__thiscall **)(int *, int))(v20 + 4))(&v20, v15);
      if ( !*(_BYTE *)(v21 + 324) )
        result = (*(int (__thiscall **)(int *, int))(v20 + 8))(&v20, v15);
    }
    else
    {
      result = (*(int (__thiscall **)(_DWORD, _DWORD))(v20 + 8))(&v20, v15);
    }
    LOBYTE(v9) = v24;
  }
  else
  {
    sub_1002CEE0(&v16, (int)&v17, v9);
    v23 = 2;
    v10 = v17;
    v13 = v5;
    v12 = &v17;
    if ( !(v19 & 1) )
      goto LABEL_14;
    result = (*(int (__thiscall **)(int *, int))(v17 + 4))(&v17, v5);
    if ( !*(_BYTE *)(v18 + 324) )
      result = (*(int (__thiscall **)(int *, int))(v17 + 8))(&v17, v5);
  }
LABEL_25:
  if ( v9 & 2 )
  {
    result = sub_1002B9A0(v4, a3, v14);
  }
  else if ( v9 & 4 )
  {
    result = sub_1002BF20(v4, a3);
  }
  return result;
}

//----- (1002A7A0) --------------------------------------------------------
int __cdecl sub_1002A7A0(int a1, int a2)
{
  __int16 v2; // cx@0
  __int16 v3; // dx@1
  int v4; // eax@1
  char v5; // cl@1
  int v6; // edx@1

  v3 = v2;
  v4 = v2 & 7;
  v5 = v2 & 0x80;
  v6 = v3 & 0x118;
  if ( v4 != 2 && v4 != 4 )
    LOBYTE(v4) = 1;
  if ( v6 != 16 && v6 != 256 )
    LOBYTE(v6) = 8;
  return (a1 + 3) / 4 * (8 * ((((unsigned __int8)v4 | (unsigned __int8)(v6 | v5)) & 1) == 0) + 8) * ((a2 + 3) / 4);
}

//----- (1002A820) --------------------------------------------------------
int __usercall sub_1002A820@<eax>(int a1@<edx>, int a2, int a3, int a4, __int16 a5)
{
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@1
  int v8; // edx@1
  int result; // eax@7
  signed int v10; // edi@9
  char *v11; // esi@9
  signed int v12; // edx@10
  int v13; // [sp+10h] [bp-58h]@9
  int v14; // [sp+14h] [bp-54h]@7
  int v15; // [sp+18h] [bp-50h]@7
  int i; // [sp+1Ch] [bp-4Ch]@8
  char v17; // [sp+20h] [bp-48h]@9
  int v18; // [sp+7Ch] [bp+14h]@7

  v5 = a3;
  v6 = a1;
  v7 = a5 & 7;
  v8 = a5 & 0x118;
  if ( v7 != 2 && v7 != 4 )
    v7 = 1;
  if ( v8 != 16 && v8 != 256 )
    v8 = 8;
  v18 = v7 | v8 | a5 & 0x80;
  v14 = v6;
  v15 = 0;
  result = 8 * ((v18 & 1) == 0) + 8;
  if ( a4 > 0 )
  {
    do
    {
      for ( i = 0; i < v5; i += 4 )
      {
        v10 = 0;
        v11 = &v17;
        v13 = 0;
        do
        {
          v12 = 0;
          do
          {
            if ( v12 + i >= v5 || (v5 = a3, v10 + v15 >= a4) )
            {
              v11 += 4;
            }
            else
            {
              *(_DWORD *)v11 = *(_DWORD *)(a2 + 4 * (v12 + i + a3 * (v10 + v15)));
              v11 += 4;
              v13 |= 1 << (v12 + 4 * v10);
            }
            ++v12;
          }
          while ( v12 < 4 );
          ++v10;
        }
        while ( v10 < 4 );
        sub_1002A570(v14, (int)&v17, v13, v18);
        v14 += 8 * ((v18 & 1) == 0) + 8;
      }
      result = v15 + 4;
      v15 = result;
    }
    while ( result < a4 );
  }
  return result;
}

//----- (1002A950) --------------------------------------------------------
int __usercall sub_1002A950@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, __int16 a5)
{
  int v5; // esi@1
  int v6; // edi@1
  int v7; // ecx@1
  int v8; // edx@1
  int result; // eax@7
  int v10; // edx@9
  int v11; // ecx@9
  int v12; // ebx@9
  signed int v13; // eax@11
  int v14; // ebx@17
  int v15; // ebx@21
  char *v16; // edx@21
  int v17; // ebx@22
  int v18; // ecx@22
  signed int v19; // esi@22
  int v20; // [sp+8h] [bp-6Ch]@9
  int v21; // [sp+Ch] [bp-68h]@1
  int i; // [sp+10h] [bp-64h]@7
  int j; // [sp+14h] [bp-60h]@9
  int v24; // [sp+18h] [bp-5Ch]@1
  int v25; // [sp+1Ch] [bp-58h]@9
  int v26; // [sp+20h] [bp-54h]@21
  int v27; // [sp+24h] [bp-50h]@8
  int v28; // [sp+28h] [bp-4Ch]@7
  int v29; // [sp+2Ch] [bp-48h]@7
  char v30; // [sp+30h] [bp-44h]@17
  int v31; // [sp+84h] [bp+10h]@7

  v5 = a4;
  v21 = a2;
  v6 = a1;
  v7 = a5 & 7;
  v8 = a5 & 0x118;
  v24 = v6;
  if ( v7 != 2 && v7 != 4 )
    v7 = 1;
  if ( v8 != 16 && v8 != 256 )
    v8 = 8;
  result = v7 | v8 | a5 & 0x80;
  v31 = result;
  v29 = a4;
  v28 = 0;
  for ( i = 8 * ((result & 1) == 0) + 8; v28 < a3; v28 += 4 )
  {
    v27 = 0;
    if ( v6 > 0 )
    {
      v10 = result & 7;
      v11 = result & 0x118;
      v12 = result & 0x80;
      v25 = result & 7;
      v20 = result & 0x118;
      for ( j = result & 0x80; ; v12 = j )
      {
        v13 = v10;
        if ( v10 != 2 && v10 != 4 )
          v13 = 1;
        if ( v11 != 16 && v11 != 256 )
          v11 = 8;
        v14 = v13 | v11 | v12;
        sub_1002C7D0((int)&v30, v14 & 1);
        if ( v14 & 2 )
        {
          sub_1002BA70((int)&v30, v5);
        }
        else if ( v14 & 4 )
        {
          sub_1002C2B0((int)&v30);
        }
        v15 = 0;
        v16 = &v30;
        v26 = 0;
        do
        {
          v17 = v28 + v15;
          v18 = v27;
          v19 = 4;
          do
          {
            if ( v18 < v6 && v17 < a3 )
            {
              *(_DWORD *)(v21 + 4 * (v18 + v17 * v6)) = *(_DWORD *)v16;
              v6 = v24;
            }
            v16 += 4;
            ++v18;
            --v19;
          }
          while ( v19 );
          v15 = v26 + 1;
          v26 = v15;
        }
        while ( v15 < 4 );
        v29 += i;
        v5 = v29;
        v27 += 4;
        if ( v27 >= v6 )
          break;
        v11 = v20;
        v10 = v25;
      }
      result = v31;
    }
  }
  return result;
}

//----- (1002AB10) --------------------------------------------------------
int __usercall sub_1002AB10@<eax>(int a1@<edi>, int a2@<esi>)
{
  float v2; // ST0C_4@2
  double v3; // st7@2
  float v4; // ST0C_4@3
  float v5; // ST10_4@5
  double v6; // st7@5
  float v7; // ST10_4@6
  float v8; // ST14_4@8
  double v9; // st7@8
  float v10; // ST14_4@9
  float v11; // ST14_4@10
  int result; // eax@10
  float v13; // [sp+Ch] [bp-Ch]@4
  float v14; // [sp+10h] [bp-8h]@7

  if ( *(float *)(a2 + 8) <= 0.0 )
  {
    v4 = ceil(*(float *)(a2 + 8));
    v3 = v4;
  }
  else
  {
    v2 = floor(*(float *)(a2 + 8));
    v3 = v2;
  }
  v13 = v3;
  if ( *(float *)(a2 + 4) <= 0.0 )
  {
    v7 = ceil(*(float *)(a2 + 4));
    v6 = v7;
  }
  else
  {
    v5 = floor(*(float *)(a2 + 4));
    v6 = v5;
  }
  v14 = v6;
  if ( *(float *)a2 <= 0.0 )
  {
    v10 = ceil(*(float *)a2);
    v9 = v10;
  }
  else
  {
    v8 = floor(*(float *)a2);
    v9 = v8;
  }
  v11 = v9;
  result = a1;
  *(float *)a1 = v11;
  *(float *)(a1 + 4) = v14;
  *(float *)(a1 + 8) = v13;
  return result;
}

//----- (1002ABF0) --------------------------------------------------------
int __userpurge sub_1002ABF0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3)
{
  float v3; // edx@1
  signed int v4; // edi@1
  float *v5; // esi@1
  int v6; // ecx@1
  float v7; // eax@2
  double v8; // st5@2
  float v9; // ecx@2
  float v10; // edx@2
  double v11; // st6@2
  double v12; // st4@2
  signed int v13; // eax@2
  double v14; // st3@2
  double v15; // st2@2
  double v16; // st6@2
  unsigned int v17; // edx@4
  int v18; // ecx@4
  float v19; // eax@6
  float v20; // eax@8
  float v21; // eax@10
  float v22; // eax@12
  float v23; // eax@14
  float v24; // eax@16
  float v25; // eax@18
  float v26; // eax@20
  int v27; // ecx@24
  int v28; // edi@24
  float v29; // edx@26
  float v30; // eax@26
  float v31; // edx@26
  float v32; // eax@28
  float v33; // edx@28
  float v34; // eax@28
  float *v35; // edx@30
  float *v36; // ecx@32
  float *v37; // eax@34
  double v38; // st5@36
  float *v39; // edx@36
  float *v40; // ecx@38
  float *v41; // eax@40
  double v42; // st5@42
  float *v43; // edx@42
  float *v44; // ecx@44
  float *v45; // eax@46
  double v46; // st6@48
  float *v47; // edx@48
  float *v48; // ecx@50
  float *v49; // eax@52
  int v50; // eax@54
  float v51; // ecx@54
  float v52; // edx@54
  double v53; // st7@54
  int v54; // eax@54
  float v55; // ecx@54
  float v56; // edx@54
  int v58; // [sp+4h] [bp-60h]@4
  float v59; // [sp+8h] [bp-5Ch]@36
  float v60; // [sp+Ch] [bp-58h]@36
  float v61; // [sp+10h] [bp-54h]@36
  float v62; // [sp+14h] [bp-50h]@5
  float v63; // [sp+18h] [bp-4Ch]@1
  float v64; // [sp+1Ch] [bp-48h]@1
  float v65; // [sp+20h] [bp-44h]@1
  float v66; // [sp+24h] [bp-40h]@2
  float v67; // [sp+28h] [bp-3Ch]@2
  float v68; // [sp+2Ch] [bp-38h]@1
  float v69; // [sp+30h] [bp-34h]@1
  float v70; // [sp+34h] [bp-30h]@1
  float v71; // [sp+38h] [bp-2Ch]@1
  float v72; // [sp+3Ch] [bp-28h]@1
  float v73; // [sp+40h] [bp-24h]@1
  float v74; // [sp+50h] [bp-14h]@30
  float v75; // [sp+54h] [bp-10h]@30
  float v76; // [sp+58h] [bp-Ch]@30

  v63 = 1.0;
  *(_DWORD *)(a2 + 8) = a1;
  v64 = 1.0;
  v65 = 1.0;
  *(float *)(a2 + 12) = v63;
  v3 = v65;
  *(float *)(a2 + 48) = 3.4028235e38;
  *(float *)(a2 + 16) = 1.0;
  *(_DWORD *)(a2 + 4) = a3;
  *(_DWORD *)a2 = &off_100A4D64;
  *(float *)(a2 + 20) = v3;
  v4 = *(_DWORD *)a3;
  v5 = (float *)(a3 + 4);
  sub_10031690(*(_DWORD *)a3, a3 + 4, a3 + 196);
  sub_10031CC0(v6, (int)&v63);
  v68 = 0.0;
  v69 = 0.0;
  v70 = 0.0;
  v71 = 0.0;
  v72 = 0.0;
  v73 = 0.0;
  if ( v4 > 0 )
  {
    v7 = *(float *)(a3 + 12);
    v8 = v64;
    v9 = *v5;
    v10 = *(float *)(a3 + 8);
    v11 = *(float *)(a3 + 8) * v64;
    v73 = v7;
    v12 = v63;
    v70 = v7;
    v13 = 1;
    v14 = v63 * *v5;
    v71 = v9;
    v72 = v10;
    v68 = v9;
    v69 = v10;
    v15 = v11 + v14;
    v16 = v65;
    v67 = *(float *)(a3 + 12) * v65 + v15;
    v66 = v67;
    if ( v4 > 1 )
    {
      if ( v4 - 1 >= 4 )
      {
        v17 = ((unsigned int)(v4 - 5) >> 2) + 1;
        v18 = a3 + 36;
        v58 = 4 * v17 + 1;
        do
        {
          v62 = *(float *)(v18 - 16) * v8 + *(float *)(v18 - 20) * v12 + *(float *)(v18 - 12) * v16;
          if ( v66 <= (double)v62 )
          {
            if ( v67 < (double)v62 )
            {
              v20 = *(float *)(v18 - 20);
              v67 = v62;
              v71 = v20;
              v72 = *(float *)(v18 - 16);
              v73 = *(float *)(v18 - 12);
            }
          }
          else
          {
            v19 = *(float *)(v18 - 20);
            v66 = v62;
            v68 = v19;
            v69 = *(float *)(v18 - 16);
            v70 = *(float *)(v18 - 12);
          }
          v62 = *(float *)(v18 - 4) * v8 + *(float *)(v18 - 8) * v12 + *(float *)v18 * v16;
          if ( v66 <= (double)v62 )
          {
            if ( v67 < (double)v62 )
            {
              v22 = *(float *)(v18 - 8);
              v67 = v62;
              v71 = v22;
              v72 = *(float *)(v18 - 4);
              v73 = *(float *)v18;
            }
          }
          else
          {
            v21 = *(float *)(v18 - 8);
            v66 = v62;
            v68 = v21;
            v69 = *(float *)(v18 - 4);
            v70 = *(float *)v18;
          }
          v62 = *(float *)(v18 + 8) * v8 + v12 * *(float *)(v18 + 4) + *(float *)(v18 + 12) * v16;
          if ( v66 <= (double)v62 )
          {
            if ( v67 < (double)v62 )
            {
              v24 = *(float *)(v18 + 4);
              v67 = v62;
              v71 = v24;
              v72 = *(float *)(v18 + 8);
              v73 = *(float *)(v18 + 12);
            }
          }
          else
          {
            v23 = *(float *)(v18 + 4);
            v66 = v62;
            v68 = v23;
            v69 = *(float *)(v18 + 8);
            v70 = *(float *)(v18 + 12);
          }
          v62 = *(float *)(v18 + 20) * v8 + *(float *)(v18 + 16) * v12 + *(float *)(v18 + 24) * v16;
          if ( v66 <= (double)v62 )
          {
            if ( v67 < (double)v62 )
            {
              v26 = *(float *)(v18 + 16);
              v67 = v62;
              v71 = v26;
              v72 = *(float *)(v18 + 20);
              v73 = *(float *)(v18 + 24);
            }
          }
          else
          {
            v25 = *(float *)(v18 + 16);
            v66 = v62;
            v68 = v25;
            v69 = *(float *)(v18 + 20);
            v70 = *(float *)(v18 + 24);
          }
          v18 += 48;
          --v17;
        }
        while ( v17 );
        v13 = v58;
      }
      if ( v13 < v4 )
      {
        v27 = (int)&v5[3 * v13];
        v28 = v4 - v13;
        do
        {
          v62 = *(float *)(v27 + 4) * v8 + *(float *)v27 * v12 + *(float *)(v27 + 8) * v16;
          if ( v66 <= (double)v62 )
          {
            if ( v67 < (double)v62 )
            {
              v32 = *(float *)v27;
              v67 = v62;
              v33 = *(float *)(v27 + 4);
              v71 = v32;
              v34 = *(float *)(v27 + 8);
              v72 = v33;
              v73 = v34;
            }
          }
          else
          {
            v29 = *(float *)v27;
            v66 = v62;
            v30 = *(float *)(v27 + 4);
            v68 = v29;
            v31 = *(float *)(v27 + 8);
            v69 = v30;
            v70 = v31;
          }
          v27 += 12;
          --v28;
        }
        while ( v28 );
      }
    }
  }
  v35 = &v70;
  v63 = 1.0;
  v64 = 1.0;
  v65 = 1.0;
  v74 = 0.0;
  v75 = 0.0;
  v76 = 0.0;
  if ( v70 <= 0.0 )
    v35 = &v76;
  v36 = &v69;
  if ( v69 <= 0.0 )
    v36 = &v75;
  v37 = &v68;
  if ( v68 <= 0.0 )
    v37 = &v74;
  v59 = *v37;
  v60 = *v36;
  v38 = *v35;
  v39 = &v61;
  v61 = v38;
  if ( v61 >= 1.0 )
    v39 = &v65;
  v40 = &v60;
  if ( v60 >= 1.0 )
    v40 = &v64;
  v41 = &v59;
  if ( v59 >= 1.0 )
    v41 = &v63;
  v68 = *v41;
  v69 = *v40;
  v42 = *v39;
  v43 = &v73;
  v70 = v42;
  if ( v73 <= 0.0 )
    v43 = &v76;
  v44 = &v72;
  if ( v72 <= 0.0 )
    v44 = &v75;
  v45 = &v71;
  if ( v71 <= 0.0 )
    v45 = &v74;
  v59 = *v45;
  v60 = *v44;
  v46 = *v43;
  v47 = &v61;
  v61 = v46;
  if ( v61 >= 1.0 )
    v47 = &v65;
  v48 = &v60;
  if ( v60 >= 1.0 )
    v48 = &v64;
  v49 = &v59;
  if ( v59 >= 1.0 )
    v49 = &v63;
  v74 = *v49;
  v75 = *v48;
  v76 = *v47;
  v63 = 31.0;
  v64 = 63.0;
  v65 = 31.0;
  v71 = v68 * 31.0;
  v72 = (float)63.0 * v69;
  v73 = (float)31.0 * v70;
  v68 = v71 + 0.5;
  v59 = v68;
  v69 = v72 + 0.5;
  v60 = v69;
  v70 = v73 + 0.5;
  v61 = v70;
  v50 = sub_1002AB10((int)&v68, (int)&v59);
  v51 = *(float *)v50;
  v52 = *(float *)(v50 + 4);
  v73 = *(float *)(v50 + 8);
  v71 = v51 * 0.03225806355476379;
  *(float *)(a2 + 24) = v71;
  v72 = v52 * 0.01587301678955555;
  *(float *)(a2 + 28) = v72;
  v72 = v64;
  v73 = 0.03225806355476379 * v73;
  v53 = v74;
  *(float *)(a2 + 32) = v73;
  v71 = v53 * 31.0;
  v72 = v72 * v75;
  v73 = v65 * v76;
  v68 = v71 + 0.5;
  v63 = v68;
  v69 = v72 + 0.5;
  v64 = v69;
  v70 = v73 + 0.5;
  v65 = v70;
  v54 = sub_1002AB10((int)&v74, (int)&v63);
  v55 = *(float *)v54;
  v56 = *(float *)(v54 + 4);
  v73 = *(float *)(v54 + 8);
  v71 = v55 * 0.03225806355476379;
  *(float *)(a2 + 36) = v71;
  v72 = v56 * 0.01587301678955555;
  *(float *)(a2 + 40) = v72;
  v73 = 0.03225806355476379 * v73;
  *(float *)(a2 + 44) = v73;
  return a2;
}
// 100A4D64: using guessed type int (__stdcall *off_100A4D64)(char);

//----- (1002B1D0) --------------------------------------------------------
void __thiscall sub_1002B1D0(int this, int a2)
{
  int v2; // edi@1
  int v3; // edx@1
  int v4; // esi@1
  float v5; // ST28_4@1
  float v6; // ST2C_4@1
  int *v7; // eax@1
  float v8; // ST30_4@1
  float v9; // ST34_4@1
  float v10; // ST38_4@1
  float v11; // ST3C_4@1
  int v12; // ebx@1
  int v13; // ecx@2
  float v14; // ST28_4@3
  float v15; // ST2C_4@3
  float v16; // ST30_4@3
  float v17; // ST1C_4@3
  float v18; // ST28_4@5
  float v19; // ST2C_4@5
  float v20; // ST30_4@5
  float v21; // ST1C_4@5
  float v22; // ST28_4@7
  float v23; // ST2C_4@7
  float v24; // ST30_4@7
  float v25; // ST1C_4@7
  char v26; // al@8
  signed int v27; // eax@12
  int *v28; // ecx@12
  int v29; // ecx@13
  int v30; // [sp+Ch] [bp-78h]@1
  float v31; // [sp+14h] [bp-70h]@1
  char v32; // [sp+1Ch] [bp-68h]@3
  int v33; // [sp+1Ch] [bp-68h]@12
  float v34; // [sp+20h] [bp-64h]@3
  float v35; // [sp+30h] [bp-54h]@3
  float v36; // [sp+30h] [bp-54h]@5
  float v37; // [sp+30h] [bp-54h]@7
  float v38; // [sp+34h] [bp-50h]@3
  float v39; // [sp+34h] [bp-50h]@5
  float v40; // [sp+34h] [bp-50h]@7
  float v41; // [sp+38h] [bp-4Ch]@3
  float v42; // [sp+38h] [bp-4Ch]@5
  float v43; // [sp+38h] [bp-4Ch]@7
  float v44; // [sp+3Ch] [bp-48h]@1
  float v45; // [sp+40h] [bp-44h]@1
  float v46; // [sp+44h] [bp-40h]@1
  float v47; // [sp+48h] [bp-3Ch]@1
  float v48; // [sp+4Ch] [bp-38h]@1
  float v49; // [sp+50h] [bp-34h]@1
  char v50[16]; // [sp+60h] [bp-24h]@10
  char v51[4]; // [sp+70h] [bp-14h]@14
  float v52; // [sp+74h] [bp-10h]@1
  float v53; // [sp+78h] [bp-Ch]@1
  float v54; // [sp+7Ch] [bp-8h]@1

  v2 = this;
  v3 = this + 24;
  v44 = *(float *)(this + 24);
  v47 = *(float *)(this + 36);
  v45 = *(float *)(this + 28);
  v48 = *(float *)(this + 40);
  v46 = *(float *)(this + 32);
  v4 = this + 36;
  v49 = *(float *)(this + 44);
  v5 = *(float *)(this + 36) * 0.5;
  v6 = *(float *)(this + 40) * 0.5;
  v7 = *(int **)(this + 4);
  v8 = *(float *)(this + 44) * 0.5;
  v30 = *v7;
  v9 = *(float *)(this + 24) * 0.5;
  v10 = *(float *)(this + 28) * 0.5;
  v11 = 0.5 * *(float *)(this + 32);
  v12 = 0;
  v52 = v9 + v5;
  v53 = v10 + v6;
  v54 = v11 + v8;
  v31 = 0.0;
  if ( v30 > 0 )
  {
    v13 = (int)(v7 + 1);
    do
    {
      v34 = 3.4028235e38;
      v14 = *(float *)v13 - v44;
      v15 = *(float *)(v13 + 4) - v45;
      v32 = 0;
      v16 = *(float *)(v13 + 8) - v46;
      v35 = *(float *)(v2 + 12) * v14;
      v38 = *(float *)(v2 + 16) * v15;
      v41 = *(float *)(v2 + 20) * v16;
      v17 = v41 * v41 + v35 * v35 + v38 * v38;
      if ( v17 < 3.402823466385289e38 )
      {
        v34 = v41 * v41 + v35 * v35 + v38 * v38;
        v32 = 0;
      }
      v18 = *(float *)v13 - v47;
      v19 = *(float *)(v13 + 4) - v48;
      v20 = *(float *)(v13 + 8) - v49;
      v36 = *(float *)(v2 + 12) * v18;
      v39 = *(float *)(v2 + 16) * v19;
      v42 = *(float *)(v2 + 20) * v20;
      v21 = v42 * v42 + v36 * v36 + v39 * v39;
      if ( v34 > (double)v21 )
      {
        v34 = v42 * v42 + v36 * v36 + v39 * v39;
        v32 = 1;
      }
      v22 = *(float *)v13 - v52;
      v23 = *(float *)(v13 + 4) - v53;
      v24 = *(float *)(v13 + 8) - v54;
      v37 = *(float *)(v2 + 12) * v22;
      v40 = *(float *)(v2 + 16) * v23;
      v43 = *(float *)(v2 + 20) * v24;
      v25 = v43 * v43 + v37 * v37 + v40 * v40;
      if ( v34 <= (double)v25 )
      {
        v26 = v32;
      }
      else
      {
        v34 = v43 * v43 + v37 * v37 + v40 * v40;
        v26 = 2;
      }
      v50[v12++] = v26;
      v13 += 12;
      v31 = v34 + v31;
    }
    while ( v12 < v30 );
  }
  if ( *(float *)(v2 + 48) > (double)v31 )
  {
    v27 = 0;
    v28 = (int *)(*(_DWORD *)(v2 + 4) + 260);
    v33 = *(_DWORD *)(v2 + 4) + 260;
    do
    {
      v29 = *v28;
      if ( v29 == -1 )
        v51[v27] = 3;
      else
        v51[v27] = v50[v29];
      ++v27;
      v28 = (int *)(v33 + 4);
      v33 += 4;
    }
    while ( v27 < 16 );
    sub_1002C590(v3, (int)v51, a2, v4);
    *(float *)(v2 + 48) = v31;
  }
}
// 1002B1D0: using guessed type char var_24[16];
// 1002B1D0: using guessed type char var_14[4];

//----- (1002B520) --------------------------------------------------------
void __thiscall sub_1002B520(int this, int a2)
{
  int v2; // edi@1
  float v3; // ST34_4@1
  float v4; // ST38_4@1
  int *v5; // eax@1
  float v6; // ST3C_4@1
  float v7; // ST40_4@1
  float v8; // ST44_4@1
  float v9; // ST48_4@1
  float v10; // ST34_4@1
  float v11; // ST38_4@1
  float v12; // ST3C_4@1
  float v13; // ST40_4@1
  float v14; // ST44_4@1
  float v15; // ST48_4@1
  int v16; // esi@2
  float v17; // ST34_4@3
  float v18; // ST38_4@3
  char v19; // bl@3
  float v20; // ST3C_4@3
  float v21; // ST2C_4@3
  float v22; // ST34_4@5
  float v23; // ST38_4@5
  float v24; // ST3C_4@5
  float v25; // ST2C_4@5
  float v26; // ST34_4@7
  float v27; // ST38_4@7
  float v28; // ST3C_4@7
  float v29; // ST2C_4@7
  float v30; // ST34_4@9
  float v31; // ST38_4@9
  float v32; // ST3C_4@9
  float v33; // ST2C_4@9
  signed int v34; // esi@13
  int *v35; // eax@13
  int v36; // eax@14
  int v37; // [sp+Ch] [bp-90h]@1
  float v38; // [sp+14h] [bp-88h]@1
  float v39; // [sp+18h] [bp-84h]@1
  float v40; // [sp+1Ch] [bp-80h]@1
  float v41; // [sp+20h] [bp-7Ch]@1
  int v42; // [sp+24h] [bp-78h]@1
  int v43; // [sp+24h] [bp-78h]@13
  float v44; // [sp+2Ch] [bp-70h]@3
  float v45; // [sp+3Ch] [bp-60h]@3
  float v46; // [sp+3Ch] [bp-60h]@5
  float v47; // [sp+3Ch] [bp-60h]@7
  float v48; // [sp+3Ch] [bp-60h]@9
  float v49; // [sp+40h] [bp-5Ch]@3
  float v50; // [sp+40h] [bp-5Ch]@5
  float v51; // [sp+40h] [bp-5Ch]@7
  float v52; // [sp+40h] [bp-5Ch]@9
  float v53; // [sp+44h] [bp-58h]@3
  float v54; // [sp+44h] [bp-58h]@5
  float v55; // [sp+44h] [bp-58h]@7
  float v56; // [sp+44h] [bp-58h]@9
  float v57; // [sp+48h] [bp-54h]@1
  float v58; // [sp+4Ch] [bp-50h]@1
  float v59; // [sp+50h] [bp-4Ch]@1
  float v60; // [sp+54h] [bp-48h]@1
  float v61; // [sp+58h] [bp-44h]@1
  float v62; // [sp+5Ch] [bp-40h]@1
  char v63[16]; // [sp+78h] [bp-24h]@11
  char v64[4]; // [sp+88h] [bp-14h]@15
  float v65; // [sp+8Ch] [bp-10h]@1
  float v66; // [sp+90h] [bp-Ch]@1
  float v67; // [sp+94h] [bp-8h]@1

  v2 = this;
  v57 = *(float *)(this + 24);
  v60 = *(float *)(this + 36);
  v58 = *(float *)(this + 28);
  v61 = *(float *)(this + 40);
  v59 = *(float *)(this + 32);
  v62 = *(float *)(this + 44);
  v3 = *(float *)(this + 36) * 0.3333333432674408;
  v4 = *(float *)(this + 40) * 0.3333333432674408;
  v5 = *(int **)(this + 4);
  v6 = *(float *)(this + 44) * 0.3333333432674408;
  v37 = *v5;
  v7 = *(float *)(this + 24) * 0.6666666865348816;
  v8 = *(float *)(this + 28) * 0.6666666865348816;
  v9 = *(float *)(this + 32) * 0.6666666865348816;
  v38 = v7 + v3;
  v39 = v8 + v4;
  v40 = v9 + v6;
  v10 = *(float *)(this + 36) * 0.6666666865348816;
  v11 = *(float *)(this + 40) * 0.6666666865348816;
  v42 = 0;
  v12 = 0.6666666865348816 * *(float *)(this + 44);
  v13 = *(float *)(this + 24) * 0.3333333432674408;
  v14 = *(float *)(this + 28) * 0.3333333432674408;
  v15 = 0.3333333432674408 * *(float *)(this + 32);
  v65 = v13 + v10;
  v66 = v14 + v11;
  v67 = v15 + v12;
  v41 = 0.0;
  if ( v37 > 0 )
  {
    v16 = (int)(v5 + 1);
    do
    {
      v44 = 3.4028235e38;
      v17 = *(float *)v16 - v57;
      v18 = *(float *)(v16 + 4) - v58;
      v19 = 0;
      v20 = *(float *)(v16 + 8) - v59;
      v45 = *(float *)(this + 12) * v17;
      v49 = *(float *)(this + 16) * v18;
      v53 = *(float *)(this + 20) * v20;
      v21 = v53 * v53 + v45 * v45 + v49 * v49;
      if ( v21 < 3.402823466385289e38 )
        v44 = v53 * v53 + v45 * v45 + v49 * v49;
      v22 = *(float *)v16 - v60;
      v23 = *(float *)(v16 + 4) - v61;
      v24 = *(float *)(v16 + 8) - v62;
      v46 = *(float *)(this + 12) * v22;
      v50 = *(float *)(this + 16) * v23;
      v54 = *(float *)(this + 20) * v24;
      v25 = v54 * v54 + v46 * v46 + v50 * v50;
      if ( v44 > (double)v25 )
      {
        v44 = v54 * v54 + v46 * v46 + v50 * v50;
        v19 = 1;
      }
      v26 = *(float *)v16 - v38;
      v27 = *(float *)(v16 + 4) - v39;
      v28 = *(float *)(v16 + 8) - v40;
      v47 = *(float *)(this + 12) * v26;
      v51 = *(float *)(this + 16) * v27;
      v55 = *(float *)(this + 20) * v28;
      v29 = v55 * v55 + v47 * v47 + v51 * v51;
      if ( v44 > (double)v29 )
      {
        v44 = v55 * v55 + v47 * v47 + v51 * v51;
        v19 = 2;
      }
      v30 = *(float *)v16 - v65;
      v31 = *(float *)(v16 + 4) - v66;
      v32 = *(float *)(v16 + 8) - v67;
      v48 = *(float *)(this + 12) * v30;
      v52 = *(float *)(this + 16) * v31;
      v56 = *(float *)(this + 20) * v32;
      v33 = v56 * v56 + v48 * v48 + v52 * v52;
      if ( v44 > (double)v33 )
      {
        v44 = v56 * v56 + v48 * v48 + v52 * v52;
        v19 = 3;
      }
      v63[v42] = v19;
      v16 += 12;
      v41 = v44 + v41;
      ++v42;
    }
    while ( v42 < v37 );
  }
  if ( *(float *)(this + 48) > (double)v41 )
  {
    v34 = 0;
    v35 = (int *)(*(_DWORD *)(this + 4) + 260);
    v43 = *(_DWORD *)(this + 4) + 260;
    do
    {
      v36 = *v35;
      if ( v36 == -1 )
        v64[v34] = 3;
      else
        v64[v34] = v63[v36];
      ++v34;
      v35 = (int *)(v43 + 4);
      v43 += 4;
    }
    while ( v34 < 16 );
    sub_1002C6B0(this + 24, (int)v64, a2, this + 36);
    *(float *)(v2 + 48) = v41;
  }
}
// 1002B520: using guessed type char var_24[16];
// 1002B520: using guessed type char var_14[4];

//----- (1002B9A0) --------------------------------------------------------
int __usercall sub_1002B9A0@<eax>(int a1@<eax>, int a2, int a3)
{
  signed int v3; // esi@1
  int result; // eax@1
  float v5; // ST10_4@2
  signed int v6; // eax@2
  char v7; // bl@6
  signed int v8; // eax@6
  float v9; // [sp+Ch] [bp-10h]@2
  int v10; // [sp+14h] [bp-8h]@1
  int v11; // [sp+18h] [bp-4h]@1

  v3 = 0;
  result = a1 + 3;
  v11 = 0;
  v10 = result;
  do
  {
    v9 = (double)*(_BYTE *)(result + 4) * 0.05882352963089943;
    v5 = (double)*(_BYTE *)result * 0.05882352963089943;
    v6 = (signed int)(v5 + 0.5);
    if ( v6 >= 0 )
    {
      if ( v6 > 15 )
        LOBYTE(v6) = 15;
    }
    else
    {
      LOBYTE(v6) = 0;
    }
    v7 = v6;
    v8 = (signed int)(v9 + 0.5);
    if ( v8 >= 0 )
    {
      if ( v8 > 15 )
        LOBYTE(v8) = 15;
    }
    else
    {
      LOBYTE(v8) = 0;
    }
    if ( !((1 << v3) & a2) )
      v7 = 0;
    if ( !((1 << (v3 + 1)) & a2) )
      LOBYTE(v8) = 0;
    *(_BYTE *)(v11 + a3) = v7 | 16 * v8;
    result = v10 + 8;
    v3 += 2;
    ++v11;
    v10 += 8;
  }
  while ( v3 < 16 );
  return result;
}

//----- (1002BA70) --------------------------------------------------------
int __usercall sub_1002BA70@<eax>(int result@<eax>, int a2@<esi>)
{
  char v2; // cl@1
  unsigned __int8 v3; // cl@1
  unsigned __int8 v4; // cl@1
  char v5; // bl@1
  char v6; // bl@1
  char v7; // dl@1
  unsigned __int8 v8; // cl@1
  char v9; // dl@1

  v2 = *(_BYTE *)a2;
  *(_BYTE *)(result + 3) = *(_BYTE *)a2 & 0xF | 16 * (*(_BYTE *)a2 & 0xF);
  *(_BYTE *)(result + 7) = v2 & 0xF0 | ((unsigned __int8)(v2 & 0xF0) >> 4);
  v3 = *(_BYTE *)(a2 + 1) & 0xF0;
  *(_BYTE *)(result + 11) = *(_BYTE *)(a2 + 1) & 0xF | 16 * (*(_BYTE *)(a2 + 1) & 0xF);
  *(_BYTE *)(result + 15) = v3 | (v3 >> 4);
  v4 = *(_BYTE *)(a2 + 2) & 0xF0;
  *(_BYTE *)(result + 19) = *(_BYTE *)(a2 + 2) & 0xF | 16 * (*(_BYTE *)(a2 + 2) & 0xF);
  *(_BYTE *)(result + 23) = v4 | (v4 >> 4);
  v5 = *(_BYTE *)(a2 + 3) & 0xF | 16 * (*(_BYTE *)(a2 + 3) & 0xF);
  *(_BYTE *)(result + 31) = *(_BYTE *)(a2 + 3) & 0xF0 | ((unsigned __int8)(*(_BYTE *)(a2 + 3) & 0xF0) >> 4);
  *(_BYTE *)(result + 27) = v5;
  v6 = *(_BYTE *)(a2 + 4) & 0xF | 16 * (*(_BYTE *)(a2 + 4) & 0xF);
  *(_BYTE *)(result + 39) = *(_BYTE *)(a2 + 4) & 0xF0 | ((unsigned __int8)(*(_BYTE *)(a2 + 4) & 0xF0) >> 4);
  *(_BYTE *)(result + 35) = v6;
  v7 = *(_BYTE *)(a2 + 5) & 0xF0 | ((unsigned __int8)(*(_BYTE *)(a2 + 5) & 0xF0) >> 4);
  *(_BYTE *)(result + 43) = *(_BYTE *)(a2 + 5) & 0xF | 16 * (*(_BYTE *)(a2 + 5) & 0xF);
  *(_BYTE *)(result + 47) = v7;
  v8 = *(_BYTE *)(a2 + 6) & 0xF0;
  *(_BYTE *)(result + 51) = *(_BYTE *)(a2 + 6) & 0xF | 16 * (*(_BYTE *)(a2 + 6) & 0xF);
  *(_BYTE *)(result + 55) = v8 | (v8 >> 4);
  v9 = *(_BYTE *)(a2 + 7) & 0xF0 | ((unsigned __int8)(*(_BYTE *)(a2 + 7) & 0xF0) >> 4);
  *(_BYTE *)(result + 59) = *(_BYTE *)(a2 + 7) & 0xF | 16 * (*(_BYTE *)(a2 + 7) & 0xF);
  *(_BYTE *)(result + 63) = v9;
  return result;
}

//----- (1002BB70) --------------------------------------------------------
int __usercall sub_1002BB70@<eax>(int a1@<edi>, int a2, int a3, int a4)
{
  int v4; // edx@1
  signed int v5; // eax@1
  signed int v6; // ecx@1
  int v7; // edx@4
  int v8; // eax@4
  int v9; // ecx@4
  char v10; // bl@4
  int v11; // eax@6
  int v12; // eax@8
  int v13; // eax@10
  int v14; // eax@12
  int v15; // eax@14
  int v16; // eax@16
  int v17; // edx@18
  signed int v19; // [sp+8h] [bp-10h]@1
  signed int v20; // [sp+Ch] [bp-Ch]@1
  int v21; // [sp+10h] [bp-8h]@1
  _BYTE *v22; // [sp+14h] [bp-4h]@1

  v4 = a4;
  v5 = 0;
  v6 = 1;
  v21 = 0;
  v20 = 0;
  v19 = 1;
  v22 = (_BYTE *)(a2 + 3);
  do
  {
    if ( v6 & a3 )
    {
      v7 = *v22;
      v8 = *(_BYTE *)a1;
      v9 = 0x7FFFFFFF;
      v10 = 0;
      if ( (v7 - v8) * (v7 - v8) < 0x7FFFFFFF )
        v9 = (*v22 - v8) * (*v22 - v8);
      v11 = *(_BYTE *)(a1 + 1);
      if ( (v7 - v11) * (v7 - v11) < v9 )
      {
        v9 = (v7 - v11) * (v7 - v11);
        v10 = 1;
      }
      v12 = *(_BYTE *)(a1 + 2);
      if ( (v7 - v12) * (v7 - v12) < v9 )
      {
        v9 = (v7 - v12) * (v7 - v12);
        v10 = 2;
      }
      v13 = *(_BYTE *)(a1 + 3);
      if ( (v7 - v13) * (v7 - v13) < v9 )
      {
        v9 = (v7 - v13) * (v7 - v13);
        v10 = 3;
      }
      v14 = *(_BYTE *)(a1 + 4);
      if ( (v7 - v14) * (v7 - v14) < v9 )
      {
        v9 = (v7 - v14) * (v7 - v14);
        v10 = 4;
      }
      v15 = *(_BYTE *)(a1 + 5);
      if ( (v7 - v15) * (v7 - v15) < v9 )
      {
        v9 = (v7 - v15) * (v7 - v15);
        v10 = 5;
      }
      v16 = *(_BYTE *)(a1 + 6);
      if ( (v7 - v16) * (v7 - v16) < v9 )
      {
        v9 = (v7 - v16) * (v7 - v16);
        v10 = 6;
      }
      v17 = (v7 - *(_BYTE *)(a1 + 7)) * (v7 - *(_BYTE *)(a1 + 7));
      if ( v17 < v9 )
      {
        v9 = v17;
        v10 = 7;
      }
      v5 = v20;
      v4 = a4;
      v21 += v9;
      v6 = v19;
      *(_BYTE *)(v20 + a4) = v10;
    }
    else
    {
      *(_BYTE *)(v5 + v4) = 0;
    }
    v22 += 4;
    ++v5;
    v6 = __ROL4__(v6, 1);
    v20 = v5;
    v19 = v6;
  }
  while ( v5 < 16 );
  return v21;
}

//----- (1002BC90) --------------------------------------------------------
int __usercall sub_1002BC90@<eax>(int a1@<eax>, char a2, char a3, int a4)
{
  int v4; // esi@1
  int v5; // ecx@1
  signed int v6; // edi@1
  int v7; // eax@2
  int v8; // edx@2
  int result; // eax@2

  *(_BYTE *)a1 = a2;
  *(_BYTE *)(a1 + 1) = a3;
  v4 = a1 + 2;
  v5 = a4 + 2;
  v6 = 2;
  do
  {
    v7 = (*(_BYTE *)(v5 + 5) << 21) | (*(_BYTE *)(v5 + 4) << 18) | (*(_BYTE *)(v5 + 3) << 15) | (*(_BYTE *)(v5 + 2) << 12) | (*(_BYTE *)(v5 + 1) << 9) | (*(_BYTE *)v5 << 6) | 8 * *(_BYTE *)(v5 - 1) | *(_BYTE *)(v5 - 2);
    *(_BYTE *)v4 = (*(_BYTE *)v5 << 6) | 8 * *(_BYTE *)(v5 - 1) | *(_BYTE *)(v5 - 2);
    v8 = v7 >> 8;
    result = v7 >> 16;
    *(_BYTE *)(v4 + 1) = v8;
    *(_BYTE *)(v4 + 2) = result;
    v5 += 8;
    v4 += 3;
    --v6;
  }
  while ( v6 );
  return result;
}

//----- (1002BD20) --------------------------------------------------------
int __cdecl sub_1002BD20(int a1, int a2, int a3)
{
  int v3; // ecx@0
  signed int v4; // esi@2
  int v5; // eax@2
  char *v6; // edx@3
  char v7; // cl@3
  int v8; // esi@11
  char *v9; // ecx@11
  signed int v10; // edi@11
  int v11; // eax@12
  int v12; // edx@12
  int result; // eax@12
  char v14[2]; // [sp+4h] [bp-14h]@2
  char v15; // [sp+6h] [bp-12h]@11

  if ( a1 <= a2 )
  {
    result = sub_1002BC90(a3, a1, a2, v3);
  }
  else
  {
    v4 = 0;
    v5 = v3 - (_DWORD)v14;
    do
    {
      v6 = &v14[v4];
      v7 = *(&v14[v4] + v5);
      if ( v7 )
      {
        if ( v7 == 1 )
        {
          *v6 = 0;
        }
        else if ( (unsigned __int8)v7 > 5u )
        {
          *v6 = v7;
        }
        else
        {
          *v6 = 7 - v7;
        }
      }
      else
      {
        *v6 = 1;
      }
      ++v4;
    }
    while ( v4 < 16 );
    *(_BYTE *)a3 = a2;
    *(_BYTE *)(a3 + 1) = a1;
    v8 = a3 + 2;
    v9 = &v15;
    v10 = 2;
    do
    {
      v11 = ((unsigned __int8)v9[5] << 21) | ((unsigned __int8)v9[4] << 18) | ((unsigned __int8)v9[3] << 15) | ((unsigned __int8)v9[2] << 12) | ((unsigned __int8)v9[1] << 9) | ((unsigned __int8)*v9 << 6) | 8 * (unsigned __int8)*(v9 - 1) | (unsigned __int8)*(v9 - 2);
      *(_BYTE *)v8 = (*v9 << 6) | 8 * *(v9 - 1) | *(v9 - 2);
      v12 = v11 >> 8;
      result = v11 >> 16;
      *(_BYTE *)(v8 + 1) = v12;
      *(_BYTE *)(v8 + 2) = result;
      v9 += 8;
      v8 += 3;
      --v10;
    }
    while ( v10 );
  }
  return result;
}
// 1002BD20: using guessed type char var_14[2];

//----- (1002BE20) --------------------------------------------------------
int __cdecl sub_1002BE20(int a1, int a2, int a3)
{
  int v3; // ecx@0
  signed int v4; // esi@2
  int v5; // eax@2
  char *v6; // ecx@3
  char v7; // dl@3
  int v8; // esi@9
  char *v9; // ecx@9
  signed int v10; // edi@9
  int v11; // eax@10
  int v12; // edx@10
  int result; // eax@10
  char v14[2]; // [sp+4h] [bp-14h]@2
  char v15; // [sp+6h] [bp-12h]@9

  if ( a1 >= a2 )
  {
    result = sub_1002BC90(a3, a1, a2, v3);
  }
  else
  {
    v4 = 0;
    v5 = v3 - (_DWORD)v14;
    do
    {
      v6 = &v14[v4];
      v7 = *(&v14[v4] + v5);
      if ( v7 )
      {
        if ( v7 == 1 )
          *v6 = 0;
        else
          *v6 = 9 - v7;
      }
      else
      {
        *v6 = 1;
      }
      ++v4;
    }
    while ( v4 < 16 );
    *(_BYTE *)a3 = a2;
    *(_BYTE *)(a3 + 1) = a1;
    v8 = a3 + 2;
    v9 = &v15;
    v10 = 2;
    do
    {
      v11 = ((unsigned __int8)v9[5] << 21) | ((unsigned __int8)v9[4] << 18) | ((unsigned __int8)v9[3] << 15) | ((unsigned __int8)v9[2] << 12) | ((unsigned __int8)v9[1] << 9) | ((unsigned __int8)*v9 << 6) | 8 * (unsigned __int8)*(v9 - 1) | (unsigned __int8)*(v9 - 2);
      *(_BYTE *)v8 = (*v9 << 6) | 8 * *(v9 - 1) | *(v9 - 2);
      v12 = v11 >> 8;
      result = v11 >> 16;
      *(_BYTE *)(v8 + 1) = v12;
      *(_BYTE *)(v8 + 2) = result;
      v9 += 8;
      v8 += 3;
      --v10;
    }
    while ( v10 );
  }
  return result;
}
// 1002BE20: using guessed type char var_14[2];

//----- (1002BF20) --------------------------------------------------------
int __cdecl sub_1002BF20(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // ecx@1
  int v4; // ebx@1
  signed int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@3
  int v8; // edx@13
  int v9; // eax@14
  int v10; // edx@24
  int v11; // eax@25
  int v12; // edx@35
  int v13; // eax@36
  int v14; // eax@51
  int *v15; // edx@52
  int *v16; // eax@56
  int *v17; // ecx@60
  int *v18; // edx@64
  int v19; // eax@67
  int result; // eax@68
  int v21; // [sp+Ch] [bp-48h]@1
  int v22; // [sp+14h] [bp-40h]@1
  int v23; // [sp+18h] [bp-3Ch]@1
  int v24; // [sp+1Ch] [bp-38h]@1
  char v25; // [sp+20h] [bp-34h]@67
  char v26; // [sp+30h] [bp-24h]@67
  char v27; // [sp+40h] [bp-14h]@67
  char v28; // [sp+41h] [bp-13h]@67
  char v29; // [sp+42h] [bp-12h]@67
  char v30; // [sp+43h] [bp-11h]@67
  int v31; // [sp+44h] [bp-10h]@64
  char v32; // [sp+48h] [bp-Ch]@67
  char v33; // [sp+49h] [bp-Bh]@67
  char v34; // [sp+4Ah] [bp-Ah]@67
  char v35; // [sp+4Bh] [bp-9h]@67
  int v36; // [sp+4Ch] [bp-8h]@1

  v21 = v2;
  v3 = 0;
  v4 = 255;
  v23 = 255;
  v24 = 0;
  v22 = 0;
  v5 = 1;
  v6 = a1 + 7;
  v36 = 4;
  do
  {
    if ( v5 & a2 )
    {
      v7 = *(_BYTE *)(v6 - 4);
      if ( v7 < v4 )
        v4 = *(_BYTE *)(v6 - 4);
      if ( v7 > v3 )
      {
        v22 = *(_BYTE *)(v6 - 4);
        v3 = v7;
      }
      if ( v7 && v7 < v23 )
        v23 = v7;
      if ( v7 != 255 && v7 > v24 )
        v24 = v7;
    }
    v8 = __ROL4__(v5, 1);
    if ( v8 & a2 )
    {
      v9 = *(_BYTE *)v6;
      if ( v9 < v4 )
        v4 = *(_BYTE *)v6;
      if ( v9 > v3 )
      {
        v22 = *(_BYTE *)v6;
        v3 = v9;
      }
      if ( v9 && v9 < v23 )
        v23 = v9;
      if ( v9 != 255 && v9 > v24 )
        v24 = v9;
    }
    v10 = __ROL4__(v8, 1);
    if ( v10 & a2 )
    {
      v11 = *(_BYTE *)(v6 + 4);
      if ( v11 < v4 )
        v4 = *(_BYTE *)(v6 + 4);
      if ( v11 > v3 )
      {
        v22 = *(_BYTE *)(v6 + 4);
        v3 = v11;
      }
      if ( v11 && v11 < v23 )
        v23 = v11;
      if ( v11 != 255 && v11 > v24 )
        v24 = v11;
    }
    v12 = __ROL4__(v10, 1);
    if ( v12 & a2 )
    {
      v13 = *(_BYTE *)(v6 + 8);
      if ( v13 < v4 )
        v4 = *(_BYTE *)(v6 + 8);
      if ( v13 > v3 )
      {
        v22 = *(_BYTE *)(v6 + 8);
        v3 = v13;
      }
      if ( v13 && v13 < v23 )
        v23 = v13;
      if ( v13 != 255 && v13 > v24 )
        v24 = v13;
    }
    v5 = __ROL4__(v12, 1);
    v6 += 16;
    --v36;
  }
  while ( v36 );
  if ( v23 > v24 )
    v23 = v24;
  if ( v4 > v3 )
    v4 = v3;
  LOBYTE(v14) = v23;
  if ( v24 - v23 < 5 )
  {
    v24 = v23 + 5;
    v36 = 255;
    v15 = &v36;
    if ( v23 + 5 <= 255 )
      v15 = &v24;
    v24 = *v15;
  }
  if ( v24 - v23 < 5 )
  {
    v36 = v24 - 5;
    v23 = 0;
    v16 = &v36;
    if ( v24 - 5 <= 0 )
      v16 = &v23;
    v14 = *v16;
    v23 = v14;
  }
  if ( v3 - v4 < 7 )
  {
    v22 = v4 + 7;
    v36 = 255;
    v17 = &v36;
    if ( v4 + 7 <= 255 )
      v17 = &v22;
    v3 = *v17;
    v22 = v3;
  }
  if ( v3 - v4 < 7 )
  {
    v36 = v3 - 7;
    v31 = 0;
    v18 = &v36;
    if ( v3 - 7 <= 0 )
      v18 = &v31;
    v4 = *v18;
  }
  v32 = v14;
  v33 = v24;
  v34 = ((signed int)((unsigned __int64)(1717986919i64 * (v24 + 4 * v23)) >> 32) >> 1)
      + ((unsigned int)((unsigned __int64)(1717986919i64 * (v24 + 4 * v23)) >> 32) >> 31);
  v35 = ((signed int)((unsigned __int64)(1717986919i64 * (3 * v23 + 2 * v24)) >> 32) >> 1)
      + ((unsigned int)((unsigned __int64)(1717986919i64 * (3 * v23 + 2 * v24)) >> 32) >> 31);
  LOBYTE(v36) = ((signed int)((unsigned __int64)(1717986919i64 * (3 * v24 + 2 * v23)) >> 32) >> 1)
              + ((unsigned int)((unsigned __int64)(1717986919i64 * (3 * v24 + 2 * v23)) >> 32) >> 31);
  BYTE1(v36) = ((signed int)((unsigned __int64)(1717986919i64 * (v23 + 4 * v24)) >> 32) >> 1)
             + ((unsigned int)((unsigned __int64)(1717986919i64 * (v23 + 4 * v24)) >> 32) >> 31);
  v29 = ((signed int)(v3 + 6 * v4 + ((unsigned __int64)(-1840700269i64 * (v3 + 6 * v4)) >> 32)) >> 2)
      + ((unsigned int)(v3 + 6 * v4 + ((unsigned __int64)(-1840700269i64 * (v3 + 6 * v4)) >> 32)) >> 31);
  v30 = ((signed int)(5 * v4 + 2 * v3 + ((unsigned __int64)(-1840700269i64 * (5 * v4 + 2 * v3)) >> 32)) >> 2)
      + ((unsigned int)(5 * v4 + 2 * v3 + ((unsigned __int64)(-1840700269i64 * (5 * v4 + 2 * v3)) >> 32)) >> 31);
  HIWORD(v36) = -256;
  v27 = v4;
  v28 = v3;
  LOBYTE(v31) = ((signed int)(3 * v3 + 4 * v4 + ((unsigned __int64)(-1840700269i64 * (3 * v3 + 4 * v4)) >> 32)) >> 2)
              + ((unsigned int)(3 * v3 + 4 * v4 + ((unsigned __int64)(-1840700269i64 * (3 * v3 + 4 * v4)) >> 32)) >> 31);
  BYTE1(v31) = ((signed int)(3 * v4 + 4 * v3 + ((unsigned __int64)(-1840700269i64 * (3 * v4 + 4 * v3)) >> 32)) >> 2)
             + ((unsigned int)(3 * v4 + 4 * v3 + ((unsigned __int64)(-1840700269i64 * (3 * v4 + 4 * v3)) >> 32)) >> 31);
  BYTE2(v31) = ((signed int)(5 * v3 + 2 * v4 + ((unsigned __int64)(-1840700269i64 * (5 * v3 + 2 * v4)) >> 32)) >> 2)
             + ((unsigned int)(5 * v3 + 2 * v4 + ((unsigned __int64)(-1840700269i64 * (5 * v3 + 2 * v4)) >> 32)) >> 31);
  BYTE3(v31) = ((signed int)(v4 + 6 * v3 + ((unsigned __int64)(-1840700269i64 * (v4 + 6 * v3)) >> 32)) >> 2)
             + ((unsigned int)(v4 + 6 * v3 + ((unsigned __int64)(-1840700269i64 * (v4 + 6 * v3)) >> 32)) >> 31);
  v31 = sub_1002BB70((int)&v27, a1, a2, (int)&v26);
  v19 = sub_1002BB70((int)&v32, a1, a2, (int)&v25);
  if ( v19 > v31 )
    result = sub_1002BE20(v4, v22, v21);
  else
    result = sub_1002BD20(v23, v24, v21);
  return result;
}

//----- (1002C2B0) --------------------------------------------------------
int __cdecl sub_1002C2B0(int a1)
{
  _BYTE *v1; // ecx@0
  _BYTE *v2; // edi@1
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // esi@4
  char *v6; // ecx@4
  signed int v7; // edi@4
  int v8; // eax@5
  signed int v9; // ecx@6
  int result; // eax@6
  char v11; // [sp+14h] [bp-1Ch]@7
  char v12; // [sp+15h] [bp-1Bh]@7
  char v13; // [sp+16h] [bp-1Ah]@4
  char v14[13]; // [sp+17h] [bp-19h]@7
  char v15; // [sp+24h] [bp-Ch]@1
  char v16; // [sp+25h] [bp-Bh]@1
  char v17; // [sp+26h] [bp-Ah]@2
  char v18; // [sp+27h] [bp-9h]@2
  char v19; // [sp+28h] [bp-8h]@2
  char v20; // [sp+29h] [bp-7h]@2
  __int16 v21; // [sp+2Ah] [bp-6h]@2

  v2 = v1;
  v3 = *v1;
  v4 = v2[1];
  v15 = v3;
  v16 = v4;
  if ( v3 > v4 )
  {
    v17 = ((signed int)(v4 + 6 * v3 + ((unsigned __int64)(-1840700269i64 * (v4 + 6 * v3)) >> 32)) >> 2)
        + ((unsigned int)(v4 + 6 * v3 + ((unsigned __int64)(-1840700269i64 * (v4 + 6 * v3)) >> 32)) >> 31);
    v18 = ((signed int)(5 * v3 + 2 * v4 + ((unsigned __int64)(-1840700269i64 * (5 * v3 + 2 * v4)) >> 32)) >> 2)
        + ((unsigned int)(5 * v3 + 2 * v4 + ((unsigned __int64)(-1840700269i64 * (5 * v3 + 2 * v4)) >> 32)) >> 31);
    v19 = ((signed int)(3 * v4 + 4 * v3 + ((unsigned __int64)(-1840700269i64 * (3 * v4 + 4 * v3)) >> 32)) >> 2)
        + ((unsigned int)(3 * v4 + 4 * v3 + ((unsigned __int64)(-1840700269i64 * (3 * v4 + 4 * v3)) >> 32)) >> 31);
    v20 = ((signed int)(3 * v3 + 4 * v4 + ((unsigned __int64)(-1840700269i64 * (3 * v3 + 4 * v4)) >> 32)) >> 2)
        + ((unsigned int)(3 * v3 + 4 * v4 + ((unsigned __int64)(-1840700269i64 * (3 * v3 + 4 * v4)) >> 32)) >> 31);
    LOBYTE(v21) = ((signed int)(5 * v4 + 2 * v3 + ((unsigned __int64)(-1840700269i64 * (5 * v4 + 2 * v3)) >> 32)) >> 2)
                + ((unsigned int)(5 * v4 + 2 * v3 + ((unsigned __int64)(-1840700269i64 * (5 * v4 + 2 * v3)) >> 32)) >> 31);
    HIBYTE(v21) = (v3 + 6 * v4) / 7;
  }
  else
  {
    v17 = ((signed int)((unsigned __int64)(1717986919i64 * (v4 + 4 * v3)) >> 32) >> 1)
        + ((unsigned int)((unsigned __int64)(1717986919i64 * (v4 + 4 * v3)) >> 32) >> 31);
    v18 = ((signed int)((unsigned __int64)(1717986919i64 * (3 * v3 + 2 * v4)) >> 32) >> 1)
        + ((unsigned int)((unsigned __int64)(1717986919i64 * (3 * v3 + 2 * v4)) >> 32) >> 31);
    v19 = ((signed int)((unsigned __int64)(1717986919i64 * (3 * v4 + 2 * v3)) >> 32) >> 1)
        + ((unsigned int)((unsigned __int64)(1717986919i64 * (3 * v4 + 2 * v3)) >> 32) >> 31);
    v20 = (v3 + 4 * v4) / 5;
    v21 = -256;
  }
  v5 = (int)(v2 + 2);
  v6 = &v13;
  v7 = 2;
  do
  {
    v8 = (*(_BYTE *)(v5 + 2) << 16) | (*(_BYTE *)(v5 + 1) << 8) | *(_BYTE *)v5;
    *(v6 - 2) = *(_BYTE *)v5 & 7;
    *(v6 - 1) = (v8 >> 3) & 7;
    *v6 = (v8 >> 6) & 7;
    v6[1] = (v8 >> 9) & 7;
    v6[2] = (v8 >> 12) & 7;
    v6[3] = (v8 >> 15) & 7;
    v6[4] = (v8 >> 18) & 7;
    v6[5] = (v8 >> 21) & 7;
    v5 += 3;
    v6 += 8;
    --v7;
  }
  while ( v7 );
  v9 = 0;
  result = a1 + 7;
  do
  {
    *(_BYTE *)(result - 4) = *(&v15 + (unsigned __int8)*(&v11 + v9));
    *(_BYTE *)result = *(&v15 + (unsigned __int8)*(&v12 + v9));
    *(_BYTE *)(result + 4) = *(&v15 + (unsigned __int8)*(&v13 + v9));
    *(_BYTE *)(result + 8) = *(&v15 + (unsigned __int8)v14[v9]);
    v9 += 4;
    result += 16;
  }
  while ( v9 < 16 );
  return result;
}
// 1002C2B0: using guessed type char var_19[13];

//----- (1002C4E0) --------------------------------------------------------
int __usercall sub_1002C4E0@<eax>(int a1@<ebx>)
{
  float v1; // ST08_4@1
  double v2; // st5@1
  signed int v3; // edi@1
  float v4; // ST08_4@5
  double v5; // st5@5
  signed int v6; // esi@5
  float v7; // ST08_4@9
  double v8; // st7@9
  signed int v9; // ecx@9
  int result; // eax@10

  v1 = *(float *)a1 * 31.0;
  v2 = v1 + 0.5;
  v3 = (signed int)v2;
  if ( (signed int)v2 >= 0 )
  {
    if ( (signed int)v2 > 31 )
      v3 = 31;
  }
  else
  {
    v3 = 0;
  }
  v4 = *(float *)(a1 + 4) * 63.0;
  v5 = v4 + 0.5;
  v6 = (signed int)v5;
  if ( (signed int)v5 >= 0 )
  {
    if ( (signed int)v5 > 63 )
      v6 = 63;
  }
  else
  {
    v6 = 0;
  }
  v7 = 31.0 * *(float *)(a1 + 8);
  v8 = v7 + 0.5;
  v9 = (signed int)v8;
  if ( (signed int)v8 >= 0 )
  {
    if ( (signed int)v8 > 31 )
      v9 = 31;
    result = v9 | 32 * (v6 | (v3 << 6));
  }
  else
  {
    result = 32 * (v6 | (v3 << 6));
  }
  return result;
}

//----- (1002C590) --------------------------------------------------------
char __usercall sub_1002C590@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4)
{
  int v4; // edi@1
  int v5; // ST0C_4@1
  int v6; // eax@1
  __int16 v7; // cx@1
  int v8; // ebx@2
  int v9; // edx@2
  signed int v10; // edx@3
  int v11; // ebx@3
  char *v12; // edi@4
  char v13; // cl@4
  char v14; // cl@9
  char v15; // al@9
  char v16; // al@9
  char result; // al@9
  int v18; // [sp+8h] [bp-1Ch]@3
  __int16 v19; // [sp+Ch] [bp-18h]@3
  int v20; // [sp+10h] [bp-14h]@2
  int v21; // [sp+14h] [bp-10h]@2
  int v22; // [sp+18h] [bp-Ch]@2
  int v23; // [sp+1Ch] [bp-8h]@2

  v4 = a2;
  v5 = sub_1002C4E0(a1);
  v6 = sub_1002C4E0(a4);
  v7 = v5;
  if ( v5 > v6 )
  {
    v19 = v6;
    LOWORD(v6) = v7;
    v10 = 0;
    v11 = v4 - (_DWORD)&v20;
    v18 = v4 - (_DWORD)&v20;
    do
    {
      v12 = (char *)&v20 + v10;
      v13 = *((_BYTE *)&v20 + v10 + v11);
      if ( v13 )
      {
        *v12 = v13 != 1 ? v13 : 0;
        v11 = v18;
      }
      else
      {
        *v12 = 1;
      }
      ++v10;
    }
    while ( v10 < 16 );
    LOWORD(v9) = v23;
    LOWORD(v8) = v22;
    v7 = v19;
  }
  else
  {
    v8 = *(_DWORD *)(v4 + 8);
    v20 = *(_DWORD *)v4;
    v21 = *(_DWORD *)(v4 + 4);
    v9 = *(_DWORD *)(v4 + 12);
    v22 = v8;
    v23 = v9;
  }
  *(_BYTE *)a3 = v7;
  *(_BYTE *)(a3 + 1) = HIBYTE(v7);
  v14 = BYTE2(v20) | 4 * BYTE3(v20);
  *(_BYTE *)(a3 + 2) = v6;
  *(_BYTE *)(a3 + 3) = BYTE1(v6);
  *(_BYTE *)(a3 + 4) = v20 | 4 * (BYTE1(v20) | 4 * v14);
  v15 = BYTE3(v22);
  *(_BYTE *)(a3 + 5) = v21 | 4 * (BYTE1(v21) | 4 * (BYTE2(v21) | 4 * BYTE3(v21)));
  v16 = 4 * (BYTE1(v8) | 4 * (BYTE2(v22) | 4 * v15));
  *(_BYTE *)(a3 + 7) = v9 | 4 * (BYTE1(v9) | 4 * (BYTE2(v23) | 4 * BYTE3(v23)));
  result = v8 | v16;
  *(_BYTE *)(a3 + 6) = result;
  return result;
}

//----- (1002C6B0) --------------------------------------------------------
char __usercall sub_1002C6B0@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4)
{
  int v4; // edi@1
  int v5; // eax@1
  __int16 v6; // cx@1
  signed int v7; // ecx@2
  int v8; // edx@2
  char *v9; // edi@3
  char v10; // bl@3
  int v11; // ebx@4
  int v12; // edx@4
  char v13; // al@9
  char v14; // al@9
  char v15; // dl@9
  char v16; // cl@9
  char v17; // dl@9
  char v18; // al@9
  char result; // al@9
  int v20; // [sp+8h] [bp-18h]@1
  __int16 v21; // [sp+8h] [bp-18h]@2
  int v22; // [sp+Ch] [bp-14h]@2
  int v23; // [sp+10h] [bp-10h]@6
  int v24; // [sp+14h] [bp-Ch]@6
  int v25; // [sp+18h] [bp-8h]@4

  v4 = a2;
  v20 = sub_1002C4E0(a1);
  v5 = sub_1002C4E0(a4);
  v6 = v20;
  if ( v20 >= v5 )
  {
    if ( v20 == v5 )
    {
      v12 = 0;
      v23 = 0;
      v24 = 0;
      v11 = 0;
    }
    else
    {
      v12 = *(_DWORD *)v4;
      v23 = *(_DWORD *)(v4 + 4);
      v24 = *(_DWORD *)(v4 + 8);
      v11 = *(_DWORD *)(v4 + 12);
    }
    v25 = v11;
    v22 = v12;
  }
  else
  {
    v21 = v5;
    LOWORD(v5) = v6;
    v7 = 0;
    v8 = v4 - (_DWORD)&v22;
    do
    {
      v9 = (char *)&v22 + v7;
      v10 = (*((_BYTE *)&v22 + v7++ + v8) ^ 1) & 3;
      *v9 = v10;
    }
    while ( v7 < 16 );
    LOWORD(v11) = v25;
    LOWORD(v12) = v22;
    v6 = v21;
  }
  *(_BYTE *)(a3 + 2) = v5;
  *(_BYTE *)(a3 + 3) = BYTE1(v5);
  v13 = BYTE2(v22) | 4 * BYTE3(v22);
  *(_BYTE *)a3 = v6;
  *(_BYTE *)(a3 + 1) = HIBYTE(v6);
  v14 = v12 | 4 * (BYTE1(v12) | 4 * v13);
  v15 = BYTE3(v24);
  v16 = BYTE2(v23) | 4 * BYTE3(v23);
  *(_BYTE *)(a3 + 4) = v14;
  v17 = v24 | 4 * (BYTE1(v24) | 4 * (BYTE2(v24) | 4 * v15));
  v18 = BYTE2(v25) | 4 * BYTE3(v25);
  *(_BYTE *)(a3 + 5) = v23 | 4 * (BYTE1(v23) | 4 * v16);
  result = v11 | 4 * (BYTE1(v11) | 4 * v18);
  *(_BYTE *)(a3 + 6) = v17;
  *(_BYTE *)(a3 + 7) = result;
  return result;
}

//----- (1002C7D0) --------------------------------------------------------
int __cdecl sub_1002C7D0(int a1, char a2)
{
  int v2; // ecx@0
  int v3; // esi@1
  int v4; // ecx@1
  int v5; // eax@1
  int v6; // edx@1
  int v7; // eax@1
  char v8; // bl@1
  int v9; // eax@1
  int v10; // edi@3
  int v11; // ebx@3
  int v12; // eax@5
  unsigned __int8 v13; // al@11
  char v14; // cl@11
  unsigned __int8 v15; // al@11
  unsigned __int8 v16; // dl@11
  unsigned __int8 v17; // al@11
  char v18; // cl@11
  unsigned __int8 v19; // cl@11
  char v20; // dl@11
  unsigned __int8 v21; // al@11
  signed int v22; // esi@11
  int result; // eax@11
  int v24; // ecx@12
  char v25; // dl@12
  int v26; // ecx@12
  char v27; // dl@12
  int v28; // ecx@12
  char v29; // dl@12
  int v30; // ecx@12
  char v31; // dl@12
  int v32; // [sp+10h] [bp-30h]@1
  int v33; // [sp+14h] [bp-2Ch]@1
  char v34; // [sp+1Ch] [bp-24h]@11
  char v35; // [sp+1Dh] [bp-23h]@11
  char v36; // [sp+1Eh] [bp-22h]@11
  char v37; // [sp+1Fh] [bp-21h]@11
  char v38; // [sp+20h] [bp-20h]@11
  char v39; // [sp+21h] [bp-1Fh]@11
  char v40; // [sp+22h] [bp-1Eh]@11
  char v41; // [sp+23h] [bp-1Dh]@11
  char v42; // [sp+24h] [bp-1Ch]@11
  char v43; // [sp+25h] [bp-1Bh]@11
  char v44; // [sp+26h] [bp-1Ah]@11
  char v45; // [sp+27h] [bp-19h]@11
  char v46; // [sp+28h] [bp-18h]@11
  char v47; // [sp+29h] [bp-17h]@11
  char v48; // [sp+2Ah] [bp-16h]@11
  char v49; // [sp+2Bh] [bp-15h]@11
  char v50; // [sp+2Ch] [bp-14h]@1
  char v51; // [sp+2Dh] [bp-13h]@1
  char v52; // [sp+2Eh] [bp-12h]@1
  char v53; // [sp+2Fh] [bp-11h]@1
  char v54; // [sp+30h] [bp-10h]@1
  char v55; // [sp+31h] [bp-Fh]@1
  char v56; // [sp+32h] [bp-Eh]@1
  char v57; // [sp+33h] [bp-Dh]@1
  char v58[3]; // [sp+34h] [bp-Ch]@5
  char v59; // [sp+37h] [bp-9h]@8
  char v60[3]; // [sp+38h] [bp-8h]@5
  char v61; // [sp+3Bh] [bp-5h]@9

  v3 = v2;
  v4 = *(_BYTE *)v2 | (*(_BYTE *)(v2 + 1) << 8);
  v50 = 8 * ((v4 >> 11) & 0x1F) | ((unsigned __int8)((v4 >> 11) & 0x1F) >> 2);
  v5 = *(_BYTE *)(v3 + 3);
  v52 = 8 * (v4 & 0x1F) | ((unsigned __int8)(v4 & 0x1F) >> 2);
  v6 = *(_BYTE *)(v3 + 2);
  v51 = 4 * ((v4 >> 5) & 0x3F) | ((unsigned __int8)((v4 >> 5) & 0x3F) >> 4);
  v7 = v6 | (v5 << 8);
  v54 = 8 * ((v7 >> 11) & 0x1F) | ((unsigned __int8)((v7 >> 11) & 0x1F) >> 2);
  v32 = v7;
  v8 = 4 * ((v7 >> 5) & 0x3F) | ((unsigned __int8)((v7 >> 5) & 0x3F) >> 4);
  LOBYTE(v6) = 8 * (v7 & 0x1F) | ((unsigned __int8)(v7 & 0x1F) >> 2);
  v9 = 0;
  v53 = -1;
  v55 = v8;
  v56 = v6;
  v57 = -1;
  v33 = 0;
  while ( 1 )
  {
    v10 = (unsigned __int8)*(&v50 + v9);
    v11 = (unsigned __int8)*(&v54 + v9);
    if ( a2 && v4 <= v32 )
    {
      v12 = v33;
      v58[v33] = (v11 + v10) / 2;
      v60[v33] = 0;
    }
    else
    {
      v58[v33] = ((unsigned __int64)(1431655766i64 * (v11 + 2 * v10)) >> 32)
               + ((unsigned int)((unsigned __int64)(1431655766i64 * (v11 + 2 * v10)) >> 32) >> 31);
      v60[v33] = (char)(v10 + 2 * v11) / 3;
      v12 = v33;
    }
    v33 = v12 + 1;
    if ( v12 + 1 >= 3 )
      break;
    v9 = v12 + 1;
  }
  v59 = -1;
  if ( !a2 || (v61 = 0, v4 > v32) )
    v61 = -1;
  v13 = *(_BYTE *)(v3 + 4);
  v34 = *(_BYTE *)(v3 + 4) & 3;
  v35 = (v13 >> 2) & 3;
  v14 = v13 >> 4;
  v37 = v13 >> 6;
  v15 = *(_BYTE *)(v3 + 5);
  v36 = v14 & 3;
  v38 = v15 & 3;
  v16 = v15;
  v39 = (v15 >> 2) & 3;
  v41 = v15 >> 6;
  v17 = *(_BYTE *)(v3 + 6);
  v18 = *(_BYTE *)(v3 + 6) & 3;
  v40 = (v16 >> 4) & 3;
  v42 = v18;
  v19 = v17;
  v20 = (v17 >> 2) & 3;
  v45 = v17 >> 6;
  v21 = *(_BYTE *)(v3 + 7);
  v43 = v20;
  v44 = (v19 >> 4) & 3;
  v46 = v21 & 3;
  v49 = v21 >> 6;
  v22 = 0;
  v47 = (v21 >> 2) & 3;
  v48 = (v21 >> 4) & 3;
  result = a1 + 2;
  do
  {
    v24 = (unsigned __int8)(4 * *(&v34 + v22));
    *(_BYTE *)(result - 2) = *(&v50 + v24);
    *(_BYTE *)(result - 1) = *(&v51 + v24);
    v25 = *(&v52 + v24);
    *(_BYTE *)(result + 1) = *(&v53 + v24);
    LOBYTE(v24) = *(&v35 + v22);
    *(_BYTE *)result = v25;
    v26 = (unsigned __int8)(4 * v24);
    *(_BYTE *)(result + 2) = *(&v50 + v26);
    *(_BYTE *)(result + 3) = *(&v51 + v26);
    v27 = *(&v52 + v26);
    LOBYTE(v26) = *(&v53 + v26);
    *(_BYTE *)(result + 4) = v27;
    *(_BYTE *)(result + 5) = v26;
    v28 = (unsigned __int8)(4 * *(&v36 + v22));
    *(_BYTE *)(result + 6) = *(&v50 + v28);
    *(_BYTE *)(result + 7) = *(&v51 + v28);
    v29 = *(&v52 + v28);
    LOBYTE(v28) = *(&v53 + v28);
    *(_BYTE *)(result + 8) = v29;
    *(_BYTE *)(result + 9) = v28;
    v30 = (unsigned __int8)(4 * *(&v37 + v22));
    *(_BYTE *)(result + 10) = *(&v50 + v30);
    *(_BYTE *)(result + 11) = *(&v51 + v30);
    v31 = *(&v52 + v30);
    LOBYTE(v30) = *(&v53 + v30);
    *(_BYTE *)(result + 12) = v31;
    *(_BYTE *)(result + 13) = v30;
    v22 += 4;
    result += 16;
  }
  while ( v22 < 16 );
  return result;
}
// 1002C7D0: using guessed type char var_C[3];
// 1002C7D0: using guessed type char var_8[3];

//----- (1002CAA0) --------------------------------------------------------
int __usercall sub_1002CAA0@<eax>(int a1@<eax>, int a2@<edi>, int a3@<esi>)
{
  float v3; // ST00_4@1
  signed int v4; // eax@1
  float v5; // ST00_4@5
  signed int v6; // eax@5
  float v7; // ST00_4@9
  signed int v8; // eax@9
  int result; // eax@10

  *(_DWORD *)(a3 + 8) = a1;
  *(_DWORD *)(a3 + 4) = a2;
  *(_DWORD *)a3 = &off_100A4D84;
  v3 = *(float *)(a2 + 4) * 255.0;
  v4 = (signed int)(v3 + 0.5);
  if ( v4 >= 0 )
  {
    if ( v4 > 255 )
      LOBYTE(v4) = -1;
  }
  else
  {
    LOBYTE(v4) = 0;
  }
  *(_BYTE *)(a3 + 12) = v4;
  v5 = *(float *)(a2 + 8) * 255.0;
  v6 = (signed int)(v5 + 0.5);
  if ( v6 >= 0 )
  {
    if ( v6 > 255 )
      LOBYTE(v6) = -1;
  }
  else
  {
    LOBYTE(v6) = 0;
  }
  *(_BYTE *)(a3 + 13) = v6;
  v7 = 255.0 * *(float *)(a2 + 12);
  v8 = (signed int)(v7 + 0.5);
  if ( v8 >= 0 )
  {
    if ( v8 > 255 )
      LOBYTE(v8) = -1;
    *(_BYTE *)(a3 + 14) = v8;
    *(_DWORD *)(a3 + 48) = 0x7FFFFFFF;
    result = a3;
  }
  else
  {
    *(_BYTE *)(a3 + 14) = 0;
    *(_DWORD *)(a3 + 48) = 0x7FFFFFFF;
    result = a3;
  }
  return result;
}
// 100A4D84: using guessed type int (__stdcall *off_100A4D84)(char);

//----- (1002CB60) --------------------------------------------------------
int __thiscall sub_1002CB60(_DWORD *this, int a2)
{
  _DWORD *v2; // edi@1
  int result; // eax@1
  signed int v4; // eax@2
  _DWORD *v5; // edx@2
  char v6[4]; // [sp+8h] [bp-14h]@4
  void *v7; // [sp+Ch] [bp-10h]@1
  void *v8; // [sp+10h] [bp-Ch]@1
  void *v9; // [sp+14h] [bp-8h]@1

  v7 = &unk_1009FC10;
  v9 = &unk_1009FC10;
  v2 = this;
  v8 = &unk_100A0210;
  sub_1002CC80((int)&v7, (int)this);
  result = v2[11];
  if ( result < v2[12] )
  {
    v4 = 0;
    v5 = (_DWORD *)(v2[1] + 260);
    do
    {
      if ( *v5 == -1 )
        v6[v4] = 3;
      else
        v6[v4] = *((_BYTE *)v2 + *v5 + 40);
      ++v4;
      ++v5;
    }
    while ( v4 < 16 );
    sub_1002C590((int)(v2 + 4), (int)v6, a2, (int)(v2 + 7));
    result = v2[11];
    v2[12] = result;
  }
  return result;
}
// 1002CB60: using guessed type char var_14[4];

//----- (1002CBF0) --------------------------------------------------------
int __thiscall sub_1002CBF0(_DWORD *this, int a2)
{
  _DWORD *v2; // edi@1
  int result; // eax@1
  signed int v4; // eax@2
  _DWORD *v5; // edx@2
  char v6[4]; // [sp+8h] [bp-14h]@4
  void *v7; // [sp+Ch] [bp-10h]@1
  void *v8; // [sp+10h] [bp-Ch]@1
  void *v9; // [sp+14h] [bp-8h]@1

  v7 = &unk_100A0810;
  v9 = &unk_100A0810;
  v2 = this;
  v8 = &unk_100A0E10;
  sub_1002CC80((int)&v7, (int)this);
  result = v2[11];
  if ( result < v2[12] )
  {
    v4 = 0;
    v5 = (_DWORD *)(v2[1] + 260);
    do
    {
      if ( *v5 == -1 )
        v6[v4] = 3;
      else
        v6[v4] = *((_BYTE *)v2 + *v5 + 40);
      ++v4;
      ++v5;
    }
    while ( v4 < 16 );
    sub_1002C6B0((int)(v2 + 4), (int)v6, a2, (int)(v2 + 7));
    result = v2[11];
    v2[12] = result;
  }
  return result;
}
// 1002CBF0: using guessed type char var_14[4];

//----- (1002CC80) --------------------------------------------------------
int __usercall sub_1002CC80@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // edi@1
  int v3; // eax@1
  int v4; // edx@1
  int v5; // eax@2
  int v6; // edx@2
  int v7; // edi@2
  int v8; // esi@2
  int v9; // ebx@2
  int result; // eax@2
  float v11; // ST24_4@3
  double v12; // st5@3
  signed int v13; // ST3C_4@3
  float v14; // ST28_4@3
  float v15; // ST2C_4@3
  double v16; // st5@3
  signed int v17; // ST3C_4@3
  signed int v18; // edx@3
  float v19; // ST18_4@3
  float v20; // ST1C_4@3
  float v21; // ST20_4@3
  int v22; // edx@3
  int v23; // [sp+14h] [bp-30h]@2
  int v24; // [sp+30h] [bp-14h]@1
  int v25; // [sp+34h] [bp-10h]@1
  int v26; // [sp+38h] [bp-Ch]@1
  signed int v27; // [sp+3Ch] [bp-8h]@1
  int v28; // [sp+40h] [bp-4h]@1

  v26 = *(_DWORD *)a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a1 + 8);
  v4 = 0;
  *(_DWORD *)(a2 + 44) = 0x7FFFFFFF;
  v28 = 0;
  v25 = v2;
  v24 = v3;
  v27 = 0x7FFFFFFF;
  do
  {
    v5 = v4 + 2 * *(_BYTE *)(a2 + 12);
    v6 = v4 + 2 * *(_BYTE *)(a2 + 13);
    v7 = v6 + v25 + 2 * v6;
    v8 = v5 + v26 + 2 * v5;
    v9 = v28 + 2 * *(_BYTE *)(a2 + 14);
    v23 = v9 + v24 + 2 * v9;
    result = *(_BYTE *)(v23 + 2) * *(_BYTE *)(v23 + 2)
           + *(_BYTE *)(v7 + 2) * *(_BYTE *)(v7 + 2)
           + *(_BYTE *)(v8 + 2) * *(_BYTE *)(v8 + 2);
    if ( result >= v27 )
    {
      v22 = v28;
    }
    else
    {
      v11 = (double)*(_BYTE *)v8 / 31.0;
      v12 = (double)*(_BYTE *)v7;
      v13 = *(_BYTE *)v23;
      *(float *)(a2 + 16) = v11;
      v14 = v12 / 63.0;
      *(float *)(a2 + 20) = v14;
      v15 = (double)v13 / 31.0;
      *(float *)(a2 + 24) = v15;
      v16 = (double)*(_BYTE *)(v8 + 1);
      v17 = *(_BYTE *)(v7 + 1);
      v18 = *(_BYTE *)(v23 + 1);
      *(_DWORD *)(a2 + 44) = result;
      v19 = v16 / 31.0;
      *(float *)(a2 + 28) = v19;
      v20 = (double)v17 / 63.0;
      *(float *)(a2 + 32) = v20;
      v27 = result;
      v21 = (double)v18 / 31.0;
      *(float *)(a2 + 36) = v21;
      v22 = v28;
      *(_BYTE *)(a2 + 40) = 2 * v28;
    }
    v4 = v22 + 1;
    v28 = v4;
  }
  while ( v4 < 2 );
  return result;
}

//----- (1002CDC0) --------------------------------------------------------
int __usercall sub_1002CDC0@<eax>(int a1@<edi>, int a2@<esi>)
{
  float v2; // ST08_4@2
  double v3; // st7@2
  float v4; // ST08_4@3
  float v5; // ST0C_4@5
  double v6; // st7@5
  float v7; // ST0C_4@6
  float v8; // ST10_4@8
  double v9; // st7@8
  float v10; // ST10_4@9
  float v11; // ST14_4@11
  double v12; // st7@11
  float v13; // ST14_4@12
  float v14; // ST14_4@13
  int result; // eax@13
  float v16; // [sp+8h] [bp-10h]@4
  float v17; // [sp+Ch] [bp-Ch]@7
  float v18; // [sp+10h] [bp-8h]@10

  if ( *(float *)(a2 + 12) <= 0.0 )
  {
    v4 = ceil(*(float *)(a2 + 12));
    v3 = v4;
  }
  else
  {
    v2 = floor(*(float *)(a2 + 12));
    v3 = v2;
  }
  v16 = v3;
  if ( *(float *)(a2 + 8) <= 0.0 )
  {
    v7 = ceil(*(float *)(a2 + 8));
    v6 = v7;
  }
  else
  {
    v5 = floor(*(float *)(a2 + 8));
    v6 = v5;
  }
  v17 = v6;
  if ( *(float *)(a2 + 4) <= 0.0 )
  {
    v10 = ceil(*(float *)(a2 + 4));
    v9 = v10;
  }
  else
  {
    v8 = floor(*(float *)(a2 + 4));
    v9 = v8;
  }
  v18 = v9;
  if ( *(float *)a2 <= 0.0 )
  {
    v13 = ceil(*(float *)a2);
    v12 = v13;
  }
  else
  {
    v11 = floor(*(float *)a2);
    v12 = v11;
  }
  v14 = v12;
  result = a1;
  *(float *)a1 = v14;
  *(float *)(a1 + 4) = v18;
  *(float *)(a1 + 8) = v17;
  *(float *)(a1 + 12) = v16;
  return result;
}

//----- (1002CEE0) --------------------------------------------------------
int __userpurge sub_1002CEE0@<eax>(signed int *a1@<ecx>, int a2@<esi>, int a3)
{
  float v3; // eax@1
  float v4; // edx@1
  float v5; // eax@1
  float v6; // edx@1
  int v7; // eax@1
  float v9; // [sp+8h] [bp-2Ch]@1
  float v10; // [sp+Ch] [bp-28h]@1
  float v11; // [sp+10h] [bp-24h]@1
  char v12; // [sp+14h] [bp-20h]@1

  *(_DWORD *)(a2 + 8) = a3;
  v10 = 1.0;
  v11 = 1.0;
  *(_DWORD *)(a2 + 12) = (a3 & 0x100) != 0 ? 8 : 1;
  *(float *)(a2 + 428) = 1.0;
  v9 = 3.4028235e38;
  v3 = v10;
  v10 = 3.4028235e38;
  *(float *)(a2 + 432) = 1.0;
  v4 = v11;
  v11 = 3.4028235e38;
  *(float *)(a2 + 436) = v3;
  *(float *)(a2 + 444) = 3.4028235e38;
  v5 = v10;
  *(float *)(a2 + 440) = v4;
  *(float *)(a2 + 448) = v9;
  v6 = v11;
  *(float *)(a2 + 452) = v5;
  *(float *)(a2 + 456) = v6;
  *(_DWORD *)(a2 + 4) = a1;
  *(_DWORD *)a2 = &off_100A4D94;
  sub_10031690(*a1, (int)(a1 + 1), (int)(a1 + 49));
  v7 = sub_10031CC0((int)&v12, (int)&v9);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)v7;
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(v7 + 4);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(v7 + 8);
  return a2;
}
// 100A4D94: using guessed type int (__stdcall *off_100A4D94)(char);

//----- (1002CFD0) --------------------------------------------------------
void *__thiscall sub_1002CFD0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_100A4D74;
  if ( a2 & 1 )
    operator delete(this);
  return v2;
}
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100A4D74: using guessed type int (__stdcall *off_100A4D74)(char);

//----- (1002D000) --------------------------------------------------------
char __fastcall sub_1002D000(int a1, int a2, int a3)
{
  signed int *v3; // esi@1
  signed int v4; // eax@1
  _BYTE *v5; // ebx@1
  signed int v6; // edx@1
  int v7; // esi@2
  double v8; // st7@3
  double v9; // st7@3
  double v10; // st6@3
  signed int v11; // edx@4
  signed int v12; // edi@6
  int v13; // esi@7
  float *v14; // edx@7
  char v15; // al@9
  char v16; // al@9
  double v17; // st7@9
  double v18; // st6@9
  char v19; // al@10
  char v20; // al@10
  double v21; // st7@10
  double v22; // st6@10
  char v23; // al@11
  char v24; // al@11
  double v25; // st7@11
  double v26; // st6@11
  double v27; // st7@12
  char v28; // al@12
  double v29; // st7@12
  char v30; // dl@16
  char v31; // al@16
  double v32; // st7@16
  char result; // al@25
  int v34; // edx@27
  int v35; // esi@27
  int v36; // eax@28
  float v37; // ST20_4@29
  float v38; // ST24_4@29
  float v39; // ST28_4@29
  double v40; // st6@29
  float v41; // ST30_4@29
  float v42; // ST34_4@29
  float v43; // ST38_4@29
  float v44; // ST3C_4@29
  float v45; // ST20_4@29
  float v46; // ST24_4@29
  float v47; // ST28_4@29
  double v48; // st6@29
  float v49; // ST30_4@29
  double v50; // st5@29
  float v51; // ST34_4@29
  float v52; // ST38_4@29
  float v53; // ST3C_4@29
  float v54; // ST20_4@29
  float v55; // ST24_4@29
  float v56; // ST28_4@29
  double v57; // st6@29
  float v58; // ST30_4@29
  float v59; // ST34_4@29
  float v60; // ST38_4@29
  float v61; // ST3C_4@29
  int v62; // edi@29
  float v63; // ST20_4@29
  float v64; // ST24_4@29
  float v65; // ST28_4@29
  double v66; // st6@29
  float v67; // ST30_4@29
  float v68; // ST34_4@29
  float v69; // ST38_4@29
  float v70; // ST3C_4@29
  int v71; // eax@32
  int v72; // edi@33
  float v73; // ST20_4@33
  float v74; // ST24_4@33
  float v75; // ST28_4@33
  double v76; // st7@33
  float v77; // ST30_4@33
  float v78; // ST34_4@33
  float v79; // ST38_4@33
  float v80; // ST3C_4@33
  int v81; // [sp+Ch] [bp-88h]@19
  int v82; // [sp+10h] [bp-84h]@1
  int v83; // [sp+14h] [bp-80h]@1
  signed int v84; // [sp+18h] [bp-7Ch]@4
  int v85; // [sp+18h] [bp-7Ch]@21
  float *v86; // [sp+1Ch] [bp-78h]@5
  int v87; // [sp+1Ch] [bp-78h]@20
  float v88; // [sp+2Ch] [bp-68h]@28
  _BYTE *v89; // [sp+40h] [bp-54h]@5
  float v90; // [sp+44h] [bp-50h]@3
  float v91[17]; // [sp+48h] [bp-4Ch]@15

  v3 = *(signed int **)(a1 + 4);
  v4 = *v3;
  v82 = a2;
  v5 = (_BYTE *)(a1 + 16 * a2 + 28);
  v6 = 0;
  v83 = *v3;
  if ( *v3 > 0 )
  {
    v7 = (int)(v3 + 3);
    do
    {
      v8 = *(float *)(v7 - 8);
      v7 += 12;
      v9 = v8 * *(float *)a3 + *(float *)(v7 - 16) * *(float *)(a3 + 4);
      v10 = *(float *)(v7 - 12) * *(float *)(a3 + 8);
      v5[v6] = v6;
      *(&v90 + ++v6) = v9 + v10;
    }
    while ( v6 < v4 );
  }
  v11 = 0;
  v84 = 0;
  if ( v4 > 0 )
  {
    v86 = (float *)&v89;
    while ( 1 )
    {
      v12 = v11;
      if ( v11 >= 4 )
        break;
LABEL_14:
      if ( v12 > 0 )
      {
        do
        {
          if ( *(&v90 + v12) <= (double)v91[v12] )
            break;
          v30 = v5[v12 - 1];
          v31 = v5[v12];
          v89 = (_BYTE *)LODWORD(v91[v12]);
          v32 = *(&v90 + v12);
          v5[v12] = v30;
          v91[v12] = v32;
          v5[v12-- - 1] = v31;
          v91[v12] = *(float *)&v89;
        }
        while ( v12 > 0 );
LABEL_17:
        v11 = v84;
        v4 = v83;
      }
      ++v86;
      v84 = ++v11;
      if ( v11 >= v4 )
        goto LABEL_19;
    }
    v13 = (int)&v5[v11 - 2];
    v14 = v86;
    while ( v14[1] > (double)v14[2] )
    {
      v15 = *(_BYTE *)(v13 + 2);
      v89 = *((_BYTE **)v14 + 2);
      BYTE3(v90) = v15;
      v16 = *(_BYTE *)(v13 + 1);
      v14[2] = v14[1];
      v14[1] = *(float *)&v89;
      *(_BYTE *)(v13 + 2) = v16;
      v17 = v14[1];
      v18 = *v14;
      *(_BYTE *)(v13 + 1) = BYTE3(v90);
      if ( v18 <= v17 )
        break;
      v19 = *(_BYTE *)(v13 + 1);
      v89 = *((_BYTE **)v14 + 1);
      BYTE3(v90) = v19;
      v20 = *(_BYTE *)v13;
      v14[1] = *v14;
      *v14 = *(float *)&v89;
      *(_BYTE *)(v13 + 1) = v20;
      v21 = *v14;
      v22 = *(v14 - 1);
      *(_BYTE *)v13 = BYTE3(v90);
      if ( v22 <= v21 )
        break;
      v23 = *(_BYTE *)v13;
      v89 = *(_BYTE **)v14;
      BYTE3(v90) = v23;
      v24 = *(_BYTE *)(v13 - 1);
      *v14 = *(v14 - 1);
      *(v14 - 1) = *(float *)&v89;
      *(_BYTE *)v13 = v24;
      v25 = *(v14 - 1);
      v26 = *(v14 - 2);
      *(_BYTE *)(v13 - 1) = BYTE3(v90);
      if ( v26 <= v25 )
        break;
      v27 = *(v14 - 1);
      BYTE3(v90) = *(_BYTE *)(v13 - 1);
      *(float *)&v89 = v27;
      v28 = *(_BYTE *)(v13 - 2);
      *(v14 - 1) = *(v14 - 2);
      v29 = *(float *)&v89;
      *(_BYTE *)(v13 - 1) = v28;
      *(v14 - 2) = v29;
      *(_BYTE *)(v13 - 2) = BYTE3(v90);
      v12 -= 4;
      v14 -= 4;
      v13 -= 4;
      if ( v12 <= 3 )
      {
        v11 = v84;
        v4 = v83;
        goto LABEL_14;
      }
    }
    goto LABEL_17;
  }
LABEL_19:
  v81 = 0;
  if ( v82 <= 0 )
  {
LABEL_27:
    v34 = *(_DWORD *)(a1 + 4);
    *(float *)(a1 + 412) = 0.0;
    *(float *)(a1 + 416) = 0.0;
    *(float *)(a1 + 420) = 0.0;
    *(float *)(a1 + 424) = 0.0;
    v35 = 0;
    if ( v4 >= 4 )
    {
      v88 = 1.0;
      v36 = a1 + 172;
      do
      {
        v37 = *(float *)(v34 + 12 * v5[v35] + 4);
        v38 = *(float *)(v34 + 12 * v5[v35] + 8);
        v39 = *(float *)(v34 + 12 * v5[v35] + 12);
        v89 = *(_BYTE **)(v34 + 4 * v5[v35] + 196);
        v40 = *(float *)&v89;
        v41 = v37 * *(float *)&v89;
        *(float *)(v36 - 16) = v41;
        v42 = v38 * v40;
        *(float *)(v36 - 12) = v42;
        v43 = v39 * v40;
        *(float *)(v36 - 8) = v43;
        v44 = v40 * v88;
        *(float *)(v36 - 4) = v44;
        *(float *)(a1 + 412) = v41 + *(float *)(a1 + 412);
        *(float *)(a1 + 416) = *(float *)(a1 + 416) + v42;
        *(float *)(a1 + 420) = *(float *)(a1 + 420) + v43;
        *(float *)(a1 + 424) = *(float *)(a1 + 424) + v44;
        v45 = *(float *)(v34 + 12 * v5[v35 + 1] + 4);
        v46 = *(float *)(v34 + 12 * v5[v35 + 1] + 8);
        v47 = *(float *)(v34 + 12 * v5[v35 + 1] + 12);
        v89 = *(_BYTE **)(v34 + 4 * v5[v35 + 1] + 196);
        v48 = *(float *)&v89;
        v49 = v45 * *(float *)&v89;
        v50 = v46 * *(float *)&v89;
        *(float *)v36 = v49;
        v51 = v50;
        *(float *)(v36 + 4) = v51;
        v52 = v47 * v48;
        *(float *)(v36 + 8) = v52;
        v53 = v48 * v88;
        *(float *)(v36 + 12) = v53;
        *(float *)(a1 + 412) = v49 + *(float *)(a1 + 412);
        *(float *)(a1 + 416) = *(float *)(a1 + 416) + v51;
        *(float *)(a1 + 420) = *(float *)(a1 + 420) + v52;
        *(float *)(a1 + 424) = *(float *)(a1 + 424) + v53;
        v54 = *(float *)(v34 + 12 * v5[v35 + 2] + 4);
        v55 = *(float *)(v34 + 12 * v5[v35 + 2] + 8);
        v56 = *(float *)(v34 + 12 * v5[v35 + 2] + 12);
        v89 = *(_BYTE **)(v34 + 4 * v5[v35 + 2] + 196);
        v57 = *(float *)&v89;
        v58 = v54 * *(float *)&v89;
        *(float *)(v36 + 16) = v58;
        v59 = v55 * v57;
        *(float *)(v36 + 20) = v59;
        v60 = v56 * v57;
        *(float *)(v36 + 24) = v60;
        v61 = v57 * v88;
        *(float *)(v36 + 28) = v61;
        *(float *)(a1 + 412) = v58 + *(float *)(a1 + 412);
        *(float *)(a1 + 416) = *(float *)(a1 + 416) + v59;
        *(float *)(a1 + 420) = *(float *)(a1 + 420) + v60;
        *(float *)(a1 + 424) = *(float *)(a1 + 424) + v61;
        v62 = v34 + 12 * v5[v35 + 3] + 4;
        v35 += 4;
        v36 += 64;
        v63 = *(float *)v62;
        v64 = *(float *)(v62 + 4);
        v65 = *(float *)(v62 + 8);
        v89 = *(_BYTE **)(v34 + 4 * v5[v35 - 1] + 196);
        v66 = *(float *)&v89;
        v67 = v63 * *(float *)&v89;
        *(float *)(v36 - 32) = v67;
        v68 = v64 * v66;
        *(float *)(v36 - 28) = v68;
        v69 = v65 * v66;
        *(float *)(v36 - 24) = v69;
        v70 = v66 * v88;
        *(float *)(v36 - 20) = v70;
        *(float *)(a1 + 412) = v67 + *(float *)(a1 + 412);
        *(float *)(a1 + 416) = *(float *)(a1 + 416) + v68;
        *(float *)(a1 + 420) = *(float *)(a1 + 420) + v69;
        *(float *)(a1 + 424) = *(float *)(a1 + 424) + v70;
      }
      while ( v35 < v83 - 3 );
      v4 = v83;
    }
    if ( v35 < v4 )
    {
      v71 = a1 + 16 * v35 + 156;
      do
      {
        v72 = v34 + 12 * v5[v35++] + 4;
        v71 += 16;
        v73 = *(float *)v72;
        v74 = *(float *)(v72 + 4);
        v75 = *(float *)(v72 + 8);
        v89 = *(_BYTE **)(v34 + 4 * v5[v35 - 1] + 196);
        v76 = *(float *)&v89;
        v77 = v73 * *(float *)&v89;
        *(float *)(v71 - 16) = v77;
        v78 = v74 * v76;
        *(float *)(v71 - 12) = v78;
        v79 = v75 * v76;
        *(float *)(v71 - 8) = v79;
        v80 = v76 * (float)1.0;
        *(float *)(v71 - 4) = v80;
        *(float *)(a1 + 412) = v77 + *(float *)(a1 + 412);
        *(float *)(a1 + 416) = *(float *)(a1 + 416) + v78;
        *(float *)(a1 + 420) = *(float *)(a1 + 420) + v79;
        *(float *)(a1 + 424) = *(float *)(a1 + 424) + v80;
      }
      while ( v35 < v83 );
    }
    result = 1;
  }
  else
  {
    v87 = a1 - (_DWORD)v5 + 28;
    while ( 1 )
    {
      v85 = 0;
      if ( v4 <= 0 )
        break;
      v89 = v5;
      while ( *v89 == v89[v87] )
      {
        ++v89;
        if ( ++v85 >= v4 )
          goto LABEL_25;
      }
      v87 += 16;
      if ( ++v81 >= v82 )
        goto LABEL_27;
    }
LABEL_25:
    result = 0;
  }
  return result;
}
// 1002D000: using guessed type float var_4C[17];

//----- (1002D6A0) --------------------------------------------------------
void __thiscall sub_1002D6A0(int this, int a2)
{
  int v2; // ebx@1
  int *v3; // ecx@1
  int v4; // edx@1
  double v5; // st7@1
  float v6; // ecx@1
  float v7; // eax@1
  float v8; // edx@1
  float v9; // ecx@1
  double v10; // st6@1
  double v11; // st5@1
  double v12; // st4@1
  double v13; // rt0@3
  double v14; // st4@3
  double v15; // st7@3
  int v16; // esi@4
  int v17; // edx@5
  int v18; // edx@11
  int v19; // eax@11
  int i; // ecx@11
  int v21; // esi@12
  int v22; // esi@13
  int j; // eax@13
  int v24; // edi@14
  int v25; // edx@15
  int k; // eax@15
  int v27; // esi@16
  _DWORD *v28; // edi@17
  signed int v29; // eax@17
  signed int v30; // edi@21
  float *v31; // eax@22
  float v32; // esi@24
  float v33; // edx@24
  float v34; // ecx@24
  float v35; // eax@24
  double v36; // st4@26
  float v37; // edi@27
  float *v38; // esi@27
  float *v39; // edx@29
  float *v40; // ecx@31
  float *v41; // eax@33
  double v42; // st5@35
  float *v43; // esi@35
  float *v44; // edx@37
  float *v45; // ecx@39
  float *v46; // eax@41
  double v47; // st4@43
  float *v48; // esi@43
  float *v49; // edx@45
  float *v50; // ecx@47
  float *v51; // eax@49
  double v52; // st5@51
  float *v53; // esi@51
  float *v54; // edx@53
  float *v55; // ecx@55
  float *v56; // eax@57
  int v57; // eax@59
  float v58; // edx@59
  float v59; // ecx@59
  float v60; // edx@59
  int v61; // eax@59
  float v62; // edx@59
  float v63; // ecx@59
  float v64; // edx@59
  double v65; // st7@65
  int v66; // eax@65
  int v67; // eax@66
  double v68; // st7@66
  float v69; // edx@70
  float v70; // eax@70
  float v71; // ecx@70
  float v72; // [sp+4h] [bp-448h]@59
  float v73; // [sp+8h] [bp-444h]@59
  float v74; // [sp+Ch] [bp-440h]@59
  float v75; // [sp+10h] [bp-43Ch]@59
  float v76; // [sp+14h] [bp-438h]@27
  float v77; // [sp+18h] [bp-434h]@27
  float v78; // [sp+1Ch] [bp-430h]@27
  float v79; // [sp+20h] [bp-42Ch]@27
  float v80; // [sp+24h] [bp-428h]@27
  float v81; // [sp+28h] [bp-424h]@27
  float v82; // [sp+2Ch] [bp-420h]@27
  float v83; // [sp+30h] [bp-41Ch]@27
  float v84; // [sp+34h] [bp-418h]@24
  float v85; // [sp+38h] [bp-414h]@24
  float v86; // [sp+3Ch] [bp-410h]@24
  float v87; // [sp+40h] [bp-40Ch]@24
  float v88; // [sp+44h] [bp-408h]@1
  float v89; // [sp+48h] [bp-404h]@1
  float v90; // [sp+4Ch] [bp-400h]@1
  float v91; // [sp+50h] [bp-3FCh]@1
  int v92; // [sp+54h] [bp-3F8h]@3
  float v93; // [sp+58h] [bp-3F4h]@3
  float v94; // [sp+5Ch] [bp-3F0h]@3
  float v95; // [sp+60h] [bp-3ECh]@3
  float v96; // [sp+64h] [bp-3E8h]@3
  int v97; // [sp+68h] [bp-3E4h]@26
  float v98; // [sp+6Ch] [bp-3E0h]@59
  float v99; // [sp+70h] [bp-3DCh]@59
  float v100; // [sp+74h] [bp-3D8h]@59
  float v101; // [sp+78h] [bp-3D4h]@59
  float v102; // [sp+7Ch] [bp-3D0h]@27
  float v103; // [sp+80h] [bp-3CCh]@27
  float v104; // [sp+84h] [bp-3C8h]@27
  float v105; // [sp+88h] [bp-3C4h]@27
  float v106; // [sp+8Ch] [bp-3C0h]@59
  float v107; // [sp+90h] [bp-3BCh]@59
  float v108; // [sp+94h] [bp-3B8h]@59
  float v109; // [sp+98h] [bp-3B4h]@59
  float v110; // [sp+9Ch] [bp-3B0h]@27
  float v111; // [sp+A0h] [bp-3ACh]@27
  float v112; // [sp+A4h] [bp-3A8h]@27
  float v113; // [sp+A8h] [bp-3A4h]@27
  float v114; // [sp+ACh] [bp-3A0h]@27
  float v115; // [sp+B0h] [bp-39Ch]@27
  float v116; // [sp+B4h] [bp-398h]@27
  float v117; // [sp+B8h] [bp-394h]@27
  float v118; // [sp+BCh] [bp-390h]@59
  float v119; // [sp+C0h] [bp-38Ch]@59
  float v120; // [sp+C4h] [bp-388h]@59
  float v121; // [sp+C8h] [bp-384h]@59
  float v122; // [sp+CCh] [bp-380h]@27
  float v123; // [sp+D0h] [bp-37Ch]@27
  float v124; // [sp+D4h] [bp-378h]@27
  float v125; // [sp+D8h] [bp-374h]@27
  float v126; // [sp+DCh] [bp-370h]@59
  float v127; // [sp+E0h] [bp-36Ch]@59
  float v128; // [sp+E4h] [bp-368h]@59
  float v129; // [sp+E8h] [bp-364h]@59
  int v130; // [sp+ECh] [bp-360h]@1
  float v131; // [sp+F0h] [bp-35Ch]@59
  float v132; // [sp+F4h] [bp-358h]@59
  float v133; // [sp+F8h] [bp-354h]@59
  float v134; // [sp+FCh] [bp-350h]@59
  float v135; // [sp+100h] [bp-34Ch]@27
  float v136; // [sp+104h] [bp-348h]@27
  float v137; // [sp+108h] [bp-344h]@27
  float v138; // [sp+10Ch] [bp-340h]@27
  float v139; // [sp+110h] [bp-33Ch]@59
  float v140; // [sp+114h] [bp-338h]@59
  float v141; // [sp+118h] [bp-334h]@59
  float v142; // [sp+11Ch] [bp-330h]@59
  float v143; // [sp+120h] [bp-32Ch]@27
  float v144; // [sp+124h] [bp-328h]@27
  float v145; // [sp+128h] [bp-324h]@27
  float v146; // [sp+12Ch] [bp-320h]@27
  float v147; // [sp+130h] [bp-31Ch]@59
  float v148; // [sp+134h] [bp-318h]@59
  float v149; // [sp+138h] [bp-314h]@59
  float v150; // [sp+13Ch] [bp-310h]@59
  float v151; // [sp+140h] [bp-30Ch]@27
  float v152; // [sp+144h] [bp-308h]@27
  float v153; // [sp+148h] [bp-304h]@27
  float v154; // [sp+14Ch] [bp-300h]@27
  float v155; // [sp+150h] [bp-2FCh]@59
  float v156; // [sp+154h] [bp-2F8h]@59
  float v157; // [sp+158h] [bp-2F4h]@59
  float v158; // [sp+15Ch] [bp-2F0h]@59
  float v159; // [sp+160h] [bp-2ECh]@1
  float v160; // [sp+164h] [bp-2E8h]@1
  float v161; // [sp+168h] [bp-2E4h]@1
  int v162; // [sp+16Ch] [bp-2E0h]@1
  float v163; // [sp+170h] [bp-2DCh]@59
  float v164; // [sp+174h] [bp-2D8h]@59
  float v165; // [sp+178h] [bp-2D4h]@59
  float v166; // [sp+17Ch] [bp-2D0h]@59
  float v167; // [sp+180h] [bp-2CCh]@27
  float v168; // [sp+184h] [bp-2C8h]@27
  float v169; // [sp+188h] [bp-2C4h]@27
  float v170; // [sp+18Ch] [bp-2C0h]@27
  float v171; // [sp+190h] [bp-2BCh]@59
  float v172; // [sp+194h] [bp-2B8h]@59
  float v173; // [sp+198h] [bp-2B4h]@59
  float v174; // [sp+19Ch] [bp-2B0h]@59
  float v175; // [sp+1A0h] [bp-2ACh]@27
  float v176; // [sp+1A4h] [bp-2A8h]@27
  float v177; // [sp+1A8h] [bp-2A4h]@27
  float v178; // [sp+1ACh] [bp-2A0h]@27
  float v179; // [sp+1B0h] [bp-29Ch]@59
  float v180; // [sp+1B4h] [bp-298h]@59
  float v181; // [sp+1B8h] [bp-294h]@59
  float v182; // [sp+1BCh] [bp-290h]@59
  float v183; // [sp+1C0h] [bp-28Ch]@27
  float v184; // [sp+1C4h] [bp-288h]@27
  float v185; // [sp+1C8h] [bp-284h]@27
  float v186; // [sp+1CCh] [bp-280h]@27
  float v187; // [sp+1D0h] [bp-27Ch]@59
  float v188; // [sp+1D4h] [bp-278h]@59
  float v189; // [sp+1D8h] [bp-274h]@59
  float v190; // [sp+1DCh] [bp-270h]@59
  int v191; // [sp+1E0h] [bp-26Ch]@1
  float v192; // [sp+1E4h] [bp-268h]@59
  float v193; // [sp+1E8h] [bp-264h]@59
  float v194; // [sp+1ECh] [bp-260h]@59
  float v195; // [sp+1F0h] [bp-25Ch]@59
  float v196; // [sp+1F4h] [bp-258h]@27
  float v197; // [sp+1F8h] [bp-254h]@27
  float v198; // [sp+1FCh] [bp-250h]@27
  float v199; // [sp+200h] [bp-24Ch]@27
  float v200; // [sp+204h] [bp-248h]@59
  float v201; // [sp+208h] [bp-244h]@59
  float v202; // [sp+20Ch] [bp-240h]@59
  float v203; // [sp+210h] [bp-23Ch]@59
  float v204; // [sp+214h] [bp-238h]@59
  float v205; // [sp+218h] [bp-234h]@59
  float v206; // [sp+21Ch] [bp-230h]@59
  float v207; // [sp+220h] [bp-22Ch]@59
  float v208; // [sp+224h] [bp-228h]@27
  float v209; // [sp+228h] [bp-224h]@27
  float v210; // [sp+22Ch] [bp-220h]@27
  float v211; // [sp+230h] [bp-21Ch]@27
  float v212; // [sp+234h] [bp-218h]@59
  float v213; // [sp+238h] [bp-214h]@59
  float v214; // [sp+23Ch] [bp-210h]@59
  float v215; // [sp+240h] [bp-20Ch]@59
  float v216; // [sp+244h] [bp-208h]@27
  float v217; // [sp+248h] [bp-204h]@27
  float v218; // [sp+24Ch] [bp-200h]@27
  float v219; // [sp+250h] [bp-1FCh]@27
  float v220; // [sp+254h] [bp-1F8h]@59
  float v221; // [sp+258h] [bp-1F4h]@59
  float v222; // [sp+25Ch] [bp-1F0h]@59
  float v223; // [sp+260h] [bp-1ECh]@59
  float v224; // [sp+264h] [bp-1E8h]@27
  float v225; // [sp+268h] [bp-1E4h]@27
  float v226; // [sp+26Ch] [bp-1E0h]@27
  float v227; // [sp+270h] [bp-1DCh]@27
  float v228; // [sp+274h] [bp-1D8h]@59
  float v229; // [sp+278h] [bp-1D4h]@59
  float v230; // [sp+27Ch] [bp-1D0h]@59
  float v231; // [sp+280h] [bp-1CCh]@59
  float v232; // [sp+284h] [bp-1C8h]@59
  float v233; // [sp+288h] [bp-1C4h]@59
  float v234; // [sp+28Ch] [bp-1C0h]@59
  float v235; // [sp+290h] [bp-1BCh]@59
  float v236; // [sp+294h] [bp-1B8h]@27
  float v237; // [sp+298h] [bp-1B4h]@27
  float v238; // [sp+29Ch] [bp-1B0h]@27
  float v239; // [sp+2A0h] [bp-1ACh]@27
  float v240; // [sp+2A4h] [bp-1A8h]@59
  float v241; // [sp+2A8h] [bp-1A4h]@59
  float v242; // [sp+2ACh] [bp-1A0h]@59
  float v243; // [sp+2B0h] [bp-19Ch]@59
  float v244; // [sp+2B4h] [bp-198h]@1
  float v245; // [sp+2B8h] [bp-194h]@1
  float v246; // [sp+2BCh] [bp-190h]@1
  float v247; // [sp+2C0h] [bp-18Ch]@63
  float v248; // [sp+2C4h] [bp-188h]@1
  float v249; // [sp+2C8h] [bp-184h]@1
  float v250; // [sp+2CCh] [bp-180h]@1
  float v251; // [sp+2D0h] [bp-17Ch]@1
  int v252; // [sp+2D4h] [bp-178h]@1
  float v253; // [sp+2D8h] [bp-174h]@51
  float v254; // [sp+2DCh] [bp-170h]@51
  float v255; // [sp+2E0h] [bp-16Ch]@51
  float v256; // [sp+2E4h] [bp-168h]@51
  int v257; // [sp+2E8h] [bp-164h]@1
  float v258; // [sp+2ECh] [bp-160h]@1
  float v259; // [sp+2F0h] [bp-15Ch]@1
  float v260; // [sp+2F4h] [bp-158h]@1
  float v261; // [sp+2F8h] [bp-154h]@1
  float v262; // [sp+2FCh] [bp-150h]@35
  float v263; // [sp+300h] [bp-14Ch]@35
  float v264; // [sp+304h] [bp-148h]@35
  float v265; // [sp+308h] [bp-144h]@35
  float v266; // [sp+30Ch] [bp-140h]@1
  float v267; // [sp+310h] [bp-13Ch]@1
  float v268; // [sp+314h] [bp-138h]@1
  float v269; // [sp+318h] [bp-134h]@1
  int v270; // [sp+31Ch] [bp-130h]@1
  float v271; // [sp+320h] [bp-12Ch]@59
  float v272; // [sp+324h] [bp-128h]@59
  float v273; // [sp+328h] [bp-124h]@59
  float v274; // [sp+32Ch] [bp-120h]@59
  int v275; // [sp+330h] [bp-11Ch]@26
  float v276; // [sp+334h] [bp-118h]@6
  float v277; // [sp+338h] [bp-114h]@6
  float v278; // [sp+33Ch] [bp-110h]@6
  int v279; // [sp+340h] [bp-10Ch]@6
  float v280; // [sp+344h] [bp-108h]@27
  float v281; // [sp+348h] [bp-104h]@27
  float v282; // [sp+34Ch] [bp-100h]@27
  float v283; // [sp+350h] [bp-FCh]@27
  float v284; // [sp+354h] [bp-F8h]@6
  float v285; // [sp+358h] [bp-F4h]@6
  float v286; // [sp+35Ch] [bp-F0h]@6
  float v287; // [sp+360h] [bp-ECh]@59
  float v288; // [sp+364h] [bp-E8h]@59
  float v289; // [sp+368h] [bp-E4h]@59
  float v290; // [sp+36Ch] [bp-E0h]@59
  float v291; // [sp+370h] [bp-DCh]@1
  float v292; // [sp+374h] [bp-D8h]@1
  float v293; // [sp+378h] [bp-D4h]@1
  float v294; // [sp+37Ch] [bp-D0h]@1
  int v295; // [sp+380h] [bp-CCh]@1
  float v296; // [sp+384h] [bp-C8h]@59
  float v297; // [sp+388h] [bp-C4h]@59
  float v298; // [sp+38Ch] [bp-C0h]@59
  float v299; // [sp+390h] [bp-BCh]@59
  float v300; // [sp+394h] [bp-B8h]@27
  float v301; // [sp+398h] [bp-B4h]@27
  float v302; // [sp+39Ch] [bp-B0h]@27
  float v303; // [sp+3A0h] [bp-ACh]@27
  float v304; // [sp+3A4h] [bp-A8h]@27
  float v305; // [sp+3A8h] [bp-A4h]@27
  float v306; // [sp+3ACh] [bp-A0h]@27
  float v307; // [sp+3B0h] [bp-9Ch]@27
  float v308; // [sp+3B4h] [bp-98h]@27
  float v309; // [sp+3B8h] [bp-94h]@27
  float v310; // [sp+3BCh] [bp-90h]@27
  float v311; // [sp+3C0h] [bp-8Ch]@27
  float v312; // [sp+3C4h] [bp-88h]@27
  float v313; // [sp+3C8h] [bp-84h]@43
  float v314; // [sp+3CCh] [bp-80h]@43
  float v315; // [sp+3D0h] [bp-7Ch]@43
  float v316; // [sp+3D4h] [bp-78h]@43
  float v317; // [sp+3D8h] [bp-74h]@27
  float v318; // [sp+3DCh] [bp-70h]@27
  float v319; // [sp+3E0h] [bp-6Ch]@27
  float v320; // [sp+3E4h] [bp-68h]@27
  float v321; // [sp+3E8h] [bp-64h]@23
  float v322; // [sp+3ECh] [bp-60h]@23
  float v323; // [sp+3F0h] [bp-5Ch]@23
  float v324; // [sp+3F4h] [bp-58h]@23
  float v325; // [sp+3F8h] [bp-54h]@59
  float v326; // [sp+3FCh] [bp-50h]@59
  float v327; // [sp+400h] [bp-4Ch]@59
  float v328; // [sp+404h] [bp-48h]@59
  char v329; // [sp+408h] [bp-44h]@59
  char v330; // [sp+418h] [bp-34h]@59
  float v331; // [sp+428h] [bp-24h]@12
  float v332; // [sp+42Ch] [bp-20h]@59
  float v333; // [sp+430h] [bp-1Ch]@59
  float v334; // [sp+434h] [bp-18h]@59
  char v335[12]; // [sp+438h] [bp-14h]@19
  float v336; // [sp+444h] [bp-8h]@27

  v291 = 2.0;
  v292 = 2.0;
  v2 = this;
  v3 = *(int **)(this + 4);
  v293 = 2.0;
  v4 = *v3;
  v294 = 2.0;
  v258 = 1.0;
  v295 = a2;
  v259 = 1.0;
  v260 = 1.0;
  v261 = 1.0;
  v191 = v4;
  v248 = 0.0;
  v249 = 0.0;
  v250 = 0.0;
  v251 = 0.0;
  v266 = 31.0;
  v267 = 63.0;
  v268 = 31.0;
  v269 = 0.0;
  sub_1002D000(v2, 0, v2 + 16);
  v5 = 0.0;
  v6 = *(float *)(v2 + 444);
  v7 = *(float *)(v2 + 452);
  v244 = 0.0;
  v8 = *(float *)(v2 + 448);
  v245 = 0.0;
  v246 = 0.0;
  v88 = v6;
  v9 = *(float *)(v2 + 456);
  v159 = 0.0;
  v160 = 0.0;
  v90 = v7;
  v161 = 0.0;
  *(float *)&v162 = 0.0;
  v89 = v8;
  v10 = 0.5;
  v91 = v9;
  v11 = 0.25;
  v257 = 0;
  v12 = 1.0;
  v252 = 0;
  v270 = 0;
  v130 = 0;
  while ( 1 )
  {
    v13 = v12;
    v14 = v5;
    v15 = v13;
    v93 = v14;
    v92 = 0;
    v94 = v14;
    v95 = v14;
    v96 = v14;
    if ( v191 > 0 )
    {
      while ( 1 )
      {
        v30 = v92;
        if ( v92 )
        {
          v321 = v14;
          v31 = &v321;
          v322 = v14;
          v323 = v14;
          v324 = v14;
        }
        else
        {
          v31 = (float *)(v2 + 156);
        }
        v32 = *v31;
        v33 = v31[1];
        v34 = v31[2];
        v35 = v31[3];
        v84 = v32;
        v85 = v33;
        v86 = v34;
        v87 = v35;
        if ( !v92 )
          v30 = 1;
        v36 = v96;
        v97 = v30;
        v275 = v2 + 16 * v30 + 164;
        while ( 1 )
        {
          v114 = *(float *)(v2 + 412);
          v115 = *(float *)(v2 + 416);
          v116 = *(float *)(v2 + 420);
          v37 = *(float *)(v2 + 424);
          v114 = v114 - v84;
          v115 = v115 - v85;
          v116 = v116 - v86;
          v117 = v37 - v87;
          v208 = v114 - v93;
          v209 = v115 - v94;
          v210 = v116 - v95;
          v211 = v117 - v36;
          v304 = v84 * v10;
          v135 = v304;
          v136 = v33 * v10;
          v137 = v34 * v10;
          v138 = v35 * v11;
          v80 = v304 + v93;
          v81 = v136 + v94;
          v82 = v137 + v95;
          v83 = v36 + v138;
          v309 = v83;
          v310 = v83;
          v311 = v83;
          v312 = v83;
          v167 = v304;
          v168 = v33 * v10;
          v169 = v34 * v10;
          v170 = v35 * v11;
          v76 = v304 + v208;
          v77 = v168 + v209;
          v78 = v169 + v210;
          v79 = v170 + v211;
          v336 = v11 * v87;
          v300 = v336;
          v301 = v336;
          v302 = v336;
          v303 = v336;
          v143 = v79 * v83;
          v144 = v83 * v79;
          v145 = v83 * v79;
          v146 = v83 * v79;
          v224 = v336 * v336;
          v225 = v336 * v336;
          v226 = v336 * v336;
          v227 = v336 * v336;
          v216 = v143 - v224;
          v217 = v144 - v225;
          v218 = v145 - v226;
          v219 = v146 - v227;
          v280 = v15 / v216;
          v281 = v15 / v217;
          v282 = v15 / v218;
          v283 = v15 / v219;
          v183 = v79 * v80;
          v184 = v79 * v81;
          v185 = v79 * v82;
          v186 = v79 * v83;
          v196 = v336 * v76;
          v197 = v336 * v77;
          v198 = v336 * v78;
          v199 = v336 * v79;
          v151 = v183 - v196;
          v152 = v184 - v197;
          v153 = v185 - v198;
          v154 = v186 - v199;
          v102 = v151 * v280;
          v317 = v102;
          v103 = v152 * v281;
          v318 = v103;
          v104 = v153 * v282;
          v319 = v104;
          v105 = v154 * v283;
          v320 = v105;
          v175 = v76 * v83;
          v176 = v83 * v77;
          v177 = v83 * v78;
          v178 = v83 * v79;
          v236 = v80 * v336;
          v38 = &v320;
          v237 = v336 * v81;
          v238 = v336 * v82;
          v239 = v336 * v83;
          v122 = v175 - v236;
          v123 = v176 - v237;
          v124 = v177 - v238;
          v125 = v178 - v239;
          v110 = v280 * v122;
          v305 = v110;
          v111 = v123 * v281;
          v306 = v111;
          v112 = v124 * v282;
          v307 = v112;
          v113 = v125 * v283;
          v308 = v113;
          if ( v105 <= 0.0 )
            v38 = &v251;
          v39 = &v319;
          if ( v104 <= 0.0 )
            v39 = &v250;
          v40 = &v318;
          if ( v103 <= 0.0 )
            v40 = &v249;
          v41 = &v317;
          if ( v102 <= 0.0 )
            v41 = &v248;
          v262 = *v41;
          v263 = *v40;
          v264 = *v39;
          v42 = *v38;
          v43 = &v265;
          v265 = v42;
          if ( v265 >= 1.0 )
            v43 = &v261;
          v44 = &v264;
          if ( v264 >= 1.0 )
            v44 = &v260;
          v45 = &v263;
          if ( v263 >= 1.0 )
            v45 = &v259;
          v46 = &v262;
          if ( v262 >= 1.0 )
            v46 = &v258;
          v313 = *v46;
          v314 = *v45;
          v315 = *v44;
          v47 = *v43;
          v48 = &v308;
          v316 = v47;
          if ( v113 <= 0.0 )
            v48 = &v251;
          v49 = &v307;
          if ( v112 <= 0.0 )
            v49 = &v250;
          v50 = &v306;
          if ( v111 <= 0.0 )
            v50 = &v249;
          v51 = &v305;
          if ( v110 <= 0.0 )
            v51 = &v248;
          v253 = *v51;
          v254 = *v50;
          v255 = *v49;
          v52 = *v48;
          v53 = &v256;
          v256 = v52;
          if ( v256 >= 1.0 )
            v53 = &v261;
          v54 = &v255;
          if ( v255 >= 1.0 )
            v54 = &v260;
          v55 = &v254;
          if ( v254 >= 1.0 )
            v55 = &v259;
          v56 = &v253;
          if ( v253 >= 1.0 )
            v56 = &v258;
          v287 = *v56;
          v126 = v266;
          v288 = *v55;
          v289 = *v54;
          v127 = v267;
          v290 = *v53;
          v126 = v313 * 31.0;
          v127 = v267 * v314;
          v128 = v268 * v315;
          v129 = v269 * v316;
          v200 = v126 + v10;
          v325 = v200;
          v201 = v127 + v10;
          v326 = v201;
          v202 = v128 + v10;
          v327 = v202;
          v203 = v10 + v129;
          v328 = v203;
          v57 = sub_1002CDC0((int)&v330, (int)&v325);
          v58 = *(float *)(v57 + 4);
          v98 = *(float *)v57;
          v59 = *(float *)(v57 + 8);
          v99 = v58;
          v60 = *(float *)(v57 + 12);
          v98 = v98 * 0.03225806355476379;
          v99 = v99 * 0.01587301678955555;
          v100 = 0.03225806355476379 * v59;
          v101 = v60 * 0.0;
          v131 = v287 * 31.0;
          v132 = v267 * v288;
          v133 = v268 * v289;
          v134 = v269 * v290;
          v204 = v131 + 0.5;
          v331 = v204;
          v205 = v132 + 0.5;
          v332 = v205;
          v206 = v133 + 0.5;
          v333 = v206;
          v207 = v134 + 0.5;
          v334 = v207;
          v61 = sub_1002CDC0((int)&v329, (int)&v331);
          v62 = *(float *)(v61 + 4);
          v72 = *(float *)v61;
          v63 = *(float *)(v61 + 8);
          v73 = v62;
          v64 = *(float *)(v61 + 12);
          v72 = v72 * 0.03225806355476379;
          v73 = v73 * 0.01587301678955555;
          v74 = 0.03225806355476379 * v63;
          v75 = v64 * 0.0;
          v139 = v72 * v72;
          v140 = v73 * v73;
          v141 = v74 * v74;
          v142 = v75 * v75;
          v212 = v79 * v139;
          v213 = v79 * v140;
          v214 = v79 * v141;
          v215 = v79 * v142;
          v147 = v98 * v98;
          v148 = v99 * v99;
          v149 = v100 * v100;
          v150 = v101 * v101;
          v155 = v83 * v147;
          v156 = v83 * v148;
          v157 = v83 * v149;
          v158 = v83 * v150;
          v228 = v155 + v212;
          v229 = v156 + v213;
          v230 = v157 + v214;
          v231 = v158 + v215;
          v163 = v72 * v98;
          v164 = v73 * v99;
          v165 = v74 * v100;
          v166 = v101 * v75;
          v171 = v336 * v163;
          v172 = v336 * v164;
          v173 = v336 * v165;
          v174 = v336 * v166;
          v220 = v98 * v80;
          v221 = v81 * v99;
          v222 = v82 * v100;
          v223 = v83 * v101;
          v179 = v171 - v220;
          v180 = v172 - v221;
          v181 = v173 - v222;
          v182 = v174 - v223;
          v232 = v72 * v76;
          v233 = v77 * v73;
          v234 = v78 * v74;
          v235 = v79 * v75;
          v240 = v179 - v232;
          v241 = v180 - v233;
          v242 = v181 - v234;
          v243 = v182 - v235;
          v118 = v240 + v240;
          v119 = v292 * v241;
          v120 = v293 * v242;
          v121 = v294 * v243;
          v187 = v118 + v228;
          v271 = v187;
          v188 = v119 + v229;
          v272 = v188;
          v189 = v120 + v230;
          v273 = v189;
          v190 = v121 + v231;
          v274 = v190;
          v271 = v187 * *(float *)(v2 + 428);
          v272 = *(float *)(v2 + 432) * v188;
          v273 = *(float *)(v2 + 436) * v189;
          v296 = v271;
          v297 = v271;
          v298 = v271;
          v299 = v271;
          v192 = v271 + v272;
          v193 = v271 + v272;
          v194 = v271 + v272;
          v195 = v272 + v271;
          v106 = v192 + v273;
          v107 = v193 + v273;
          v108 = v194 + v273;
          v109 = v273 + v195;
          if ( v88 > (double)v106 || v89 > (double)v107 || v90 > (double)v108 || v91 > (double)v109 )
          {
            v244 = v98;
            v245 = v99;
            v159 = v72;
            v160 = v73;
            v161 = v74;
            *(float *)&v162 = v75;
            v252 = v92;
            v270 = v97;
            v88 = v106;
            v89 = v107;
            v246 = v100;
            v247 = v101;
            v90 = v108;
            v91 = v109;
            v257 = v130;
          }
          if ( v97 == v191 )
            break;
          v65 = *(float *)(v275 - 8);
          ++v97;
          v66 = v275 + 16;
          v275 = v66;
          v84 = v65 + v84;
          v85 = *(float *)(v66 - 20) + v85;
          v33 = v85;
          v86 = v86 + *(float *)(v66 - 16);
          v34 = v86;
          v87 = *(float *)(v66 - 12) + v87;
          v35 = v87;
          v15 = 1.0;
          v10 = 0.5;
          v36 = v96;
          v11 = 0.25;
        }
        v67 = v2 + 16 * v92 + 156;
        v68 = *(float *)v67 + v93;
        ++v92;
        v93 = v68;
        v94 = *(float *)(v67 + 4) + v94;
        v95 = *(float *)(v67 + 8) + v95;
        v96 = *(float *)(v67 + 12) + v96;
        if ( v92 >= v191 )
          break;
        v15 = 1.0;
        v10 = 0.5;
        v14 = 0.0;
        v11 = 0.25;
      }
    }
    v16 = v257;
    if ( v257 != v130 )
      break;
    v17 = v130 + 1;
    v130 = v17;
    if ( v17 == *(_DWORD *)(v2 + 12) )
      break;
    v276 = v159 - v244;
    v277 = v160 - v245;
    v279 = v162;
    v278 = v161 - v246;
    v284 = v276;
    v285 = v277;
    v286 = v278;
    if ( !sub_1002D000(v2, v17, (int)&v284) )
      break;
    v5 = 0.0;
    v10 = 0.5;
    v12 = 1.0;
    v11 = 0.25;
  }
  if ( *(float *)(v2 + 444) > (double)v88
    || *(float *)(v2 + 448) > (double)v89
    || *(float *)(v2 + 452) > (double)v90
    || *(float *)(v2 + 456) > (double)v91 )
  {
    v18 = v252;
    v19 = 0;
    for ( i = v2 + 16 * v16 + 28; v19 < v18; *((_BYTE *)&v331 + v21) = 0 )
      v21 = *(_BYTE *)(v19++ + i);
    v22 = v270;
    for ( j = v18; j < v22; *((_BYTE *)&v331 + v24) = 2 )
      v24 = *(_BYTE *)(j++ + i);
    v25 = v191;
    for ( k = v22; k < v25; *((_BYTE *)&v331 + v27) = 1 )
      v27 = *(_BYTE *)(k++ + i);
    v28 = (_DWORD *)(*(_DWORD *)(v2 + 4) + 260);
    v29 = 0;
    do
    {
      if ( *v28 == -1 )
        v335[v29] = 3;
      else
        v335[v29] = *((_BYTE *)&v331 + *v28);
      ++v29;
      ++v28;
    }
    while ( v29 < 16 );
    v284 = v159;
    v285 = v160;
    v286 = v161;
    v72 = v244;
    v73 = v245;
    v74 = v246;
    sub_1002C590((int)&v72, (int)v335, v295, (int)&v284);
    v69 = v89;
    v70 = v90;
    *(float *)(v2 + 444) = v88;
    v71 = v91;
    *(float *)(v2 + 448) = v69;
    *(float *)(v2 + 452) = v70;
    *(float *)(v2 + 456) = v71;
  }
}
// 1002D6A0: using guessed type char var_14[12];

//----- (1002F380) --------------------------------------------------------
void __thiscall sub_1002F380(int this, int a2)
{
  int v2; // ebx@1
  int *v3; // ecx@1
  int v4; // edx@1
  double v5; // st7@1
  float v6; // ecx@1
  float v7; // eax@1
  float v8; // edx@1
  float v9; // ecx@1
  double v10; // st6@1
  double v11; // st5@1
  double v12; // st4@1
  double v13; // rt2@3
  double v14; // st4@3
  double v15; // st7@3
  int v16; // edi@6
  float *v17; // eax@8
  float v18; // esi@10
  float v19; // edx@10
  float v20; // ecx@10
  float v21; // eax@10
  double v22; // st4@12
  float v23; // edi@13
  float *v24; // esi@13
  float *v25; // edx@15
  float *v26; // ecx@17
  float *v27; // eax@19
  double v28; // st6@21
  float *v29; // esi@21
  float *v30; // edx@23
  float *v31; // ecx@25
  float *v32; // eax@27
  double v33; // st5@29
  float *v34; // esi@29
  float *v35; // edx@31
  float *v36; // ecx@33
  float *v37; // eax@35
  double v38; // st6@37
  float *v39; // esi@37
  float *v40; // edx@39
  float *v41; // ecx@41
  float *v42; // eax@43
  int v43; // eax@45
  float v44; // edx@45
  float v45; // ecx@45
  float v46; // edx@45
  int v47; // eax@45
  float v48; // edx@45
  float v49; // ecx@45
  float v50; // edx@45
  double v51; // st7@51
  int v52; // eax@51
  int v53; // eax@53
  double v54; // st7@53
  double v55; // st7@54
  int v56; // esi@55
  int v57; // edx@56
  int v58; // edx@62
  int v59; // ecx@62
  int i; // eax@62
  int v61; // esi@63
  int j; // esi@64
  int v63; // edi@65
  int v64; // edi@66
  int k; // ecx@66
  int v66; // esi@67
  int v67; // esi@68
  int l; // ecx@68
  int v69; // edi@69
  signed int v70; // eax@70
  _DWORD *v71; // esi@70
  float v72; // ecx@75
  float v73; // edx@75
  float v74; // eax@75
  float v75; // [sp+4h] [bp-4C8h]@45
  float v76; // [sp+8h] [bp-4C4h]@45
  float v77; // [sp+Ch] [bp-4C0h]@45
  float v78; // [sp+10h] [bp-4BCh]@45
  float v79; // [sp+14h] [bp-4B8h]@6
  float v80; // [sp+18h] [bp-4B4h]@6
  float v81; // [sp+1Ch] [bp-4B0h]@6
  float v82; // [sp+20h] [bp-4ACh]@6
  float v83; // [sp+24h] [bp-4A8h]@13
  float v84; // [sp+28h] [bp-4A4h]@13
  float v85; // [sp+2Ch] [bp-4A0h]@13
  float v86; // [sp+30h] [bp-49Ch]@13
  float v87; // [sp+34h] [bp-498h]@13
  float v88; // [sp+38h] [bp-494h]@13
  float v89; // [sp+3Ch] [bp-490h]@13
  float v90; // [sp+40h] [bp-48Ch]@13
  float v91; // [sp+44h] [bp-488h]@13
  float v92; // [sp+48h] [bp-484h]@13
  float v93; // [sp+4Ch] [bp-480h]@13
  float v94; // [sp+50h] [bp-47Ch]@13
  float v95; // [sp+54h] [bp-478h]@3
  float v96; // [sp+58h] [bp-474h]@3
  float v97; // [sp+5Ch] [bp-470h]@3
  float v98; // [sp+60h] [bp-46Ch]@3
  int v99; // [sp+64h] [bp-468h]@6
  float v100; // [sp+68h] [bp-464h]@1
  float v101; // [sp+6Ch] [bp-460h]@1
  float v102; // [sp+70h] [bp-45Ch]@1
  float v103; // [sp+74h] [bp-458h]@1
  int v104; // [sp+78h] [bp-454h]@12
  int v105; // [sp+7Ch] [bp-450h]@3
  float v106; // [sp+80h] [bp-44Ch]@10
  float v107; // [sp+84h] [bp-448h]@10
  float v108; // [sp+88h] [bp-444h]@10
  float v109; // [sp+8Ch] [bp-440h]@10
  float v110; // [sp+90h] [bp-43Ch]@45
  float v111; // [sp+94h] [bp-438h]@45
  float v112; // [sp+98h] [bp-434h]@45
  float v113; // [sp+9Ch] [bp-430h]@45
  float v114; // [sp+A0h] [bp-42Ch]@13
  float v115; // [sp+A4h] [bp-428h]@13
  float v116; // [sp+A8h] [bp-424h]@13
  float v117; // [sp+ACh] [bp-420h]@13
  float v118; // [sp+B0h] [bp-41Ch]@45
  float v119; // [sp+B4h] [bp-418h]@45
  float v120; // [sp+B8h] [bp-414h]@45
  float v121; // [sp+BCh] [bp-410h]@45
  float v122; // [sp+C0h] [bp-40Ch]@13
  float v123; // [sp+C4h] [bp-408h]@13
  float v124; // [sp+C8h] [bp-404h]@13
  float v125; // [sp+CCh] [bp-400h]@13
  float v126; // [sp+D0h] [bp-3FCh]@13
  float v127; // [sp+D4h] [bp-3F8h]@13
  float v128; // [sp+D8h] [bp-3F4h]@13
  float v129; // [sp+DCh] [bp-3F0h]@13
  float v130; // [sp+E0h] [bp-3ECh]@45
  float v131; // [sp+E4h] [bp-3E8h]@45
  float v132; // [sp+E8h] [bp-3E4h]@45
  float v133; // [sp+ECh] [bp-3E0h]@45
  float v134; // [sp+F0h] [bp-3DCh]@13
  float v135; // [sp+F4h] [bp-3D8h]@13
  float v136; // [sp+F8h] [bp-3D4h]@13
  float v137; // [sp+FCh] [bp-3D0h]@13
  float v138; // [sp+100h] [bp-3CCh]@1
  float v139; // [sp+104h] [bp-3C8h]@1
  float v140; // [sp+108h] [bp-3C4h]@1
  int v141; // [sp+10Ch] [bp-3C0h]@1
  float v142; // [sp+110h] [bp-3BCh]@45
  float v143; // [sp+114h] [bp-3B8h]@45
  float v144; // [sp+118h] [bp-3B4h]@45
  float v145; // [sp+11Ch] [bp-3B0h]@45
  float v146; // [sp+120h] [bp-3ACh]@13
  float v147; // [sp+124h] [bp-3A8h]@13
  float v148; // [sp+128h] [bp-3A4h]@13
  float v149; // [sp+12Ch] [bp-3A0h]@13
  float v150; // [sp+130h] [bp-39Ch]@45
  float v151; // [sp+134h] [bp-398h]@45
  float v152; // [sp+138h] [bp-394h]@45
  float v153; // [sp+13Ch] [bp-390h]@45
  float v154; // [sp+140h] [bp-38Ch]@13
  float v155; // [sp+144h] [bp-388h]@13
  float v156; // [sp+148h] [bp-384h]@13
  float v157; // [sp+14Ch] [bp-380h]@13
  float v158; // [sp+150h] [bp-37Ch]@45
  float v159; // [sp+154h] [bp-378h]@45
  float v160; // [sp+158h] [bp-374h]@45
  float v161; // [sp+15Ch] [bp-370h]@45
  float v162; // [sp+160h] [bp-36Ch]@13
  float v163; // [sp+164h] [bp-368h]@13
  float v164; // [sp+168h] [bp-364h]@13
  float v165; // [sp+16Ch] [bp-360h]@13
  float v166; // [sp+170h] [bp-35Ch]@45
  float v167; // [sp+174h] [bp-358h]@45
  float v168; // [sp+178h] [bp-354h]@45
  float v169; // [sp+17Ch] [bp-350h]@45
  float v170; // [sp+180h] [bp-34Ch]@13
  float v171; // [sp+184h] [bp-348h]@13
  float v172; // [sp+188h] [bp-344h]@13
  float v173; // [sp+18Ch] [bp-340h]@13
  float v174; // [sp+190h] [bp-33Ch]@45
  float v175; // [sp+194h] [bp-338h]@45
  float v176; // [sp+198h] [bp-334h]@45
  float v177; // [sp+19Ch] [bp-330h]@45
  float v178; // [sp+1A0h] [bp-32Ch]@13
  float v179; // [sp+1A4h] [bp-328h]@13
  float v180; // [sp+1A8h] [bp-324h]@13
  float v181; // [sp+1ACh] [bp-320h]@13
  int v182; // [sp+1B0h] [bp-31Ch]@1
  float v183; // [sp+1B4h] [bp-318h]@13
  float v184; // [sp+1B8h] [bp-314h]@13
  float v185; // [sp+1BCh] [bp-310h]@13
  float v186; // [sp+1C0h] [bp-30Ch]@13
  float v187; // [sp+1C4h] [bp-308h]@45
  float v188; // [sp+1C8h] [bp-304h]@45
  float v189; // [sp+1CCh] [bp-300h]@45
  float v190; // [sp+1D0h] [bp-2FCh]@45
  float v191; // [sp+1D4h] [bp-2F8h]@13
  float v192; // [sp+1D8h] [bp-2F4h]@13
  float v193; // [sp+1DCh] [bp-2F0h]@13
  float v194; // [sp+1E0h] [bp-2ECh]@13
  float v195; // [sp+1E4h] [bp-2E8h]@45
  float v196; // [sp+1E8h] [bp-2E4h]@45
  float v197; // [sp+1ECh] [bp-2E0h]@45
  float v198; // [sp+1F0h] [bp-2DCh]@45
  int v199; // [sp+1F4h] [bp-2D8h]@1
  float v200; // [sp+1F8h] [bp-2D4h]@45
  float v201; // [sp+1FCh] [bp-2D0h]@45
  float v202; // [sp+200h] [bp-2CCh]@45
  float v203; // [sp+204h] [bp-2C8h]@45
  float v204; // [sp+208h] [bp-2C4h]@13
  float v205; // [sp+20Ch] [bp-2C0h]@13
  float v206; // [sp+210h] [bp-2BCh]@13
  float v207; // [sp+214h] [bp-2B8h]@13
  float v208; // [sp+218h] [bp-2B4h]@45
  float v209; // [sp+21Ch] [bp-2B0h]@45
  float v210; // [sp+220h] [bp-2ACh]@45
  float v211; // [sp+224h] [bp-2A8h]@45
  float v212; // [sp+228h] [bp-2A4h]@13
  float v213; // [sp+22Ch] [bp-2A0h]@13
  float v214; // [sp+230h] [bp-29Ch]@13
  float v215; // [sp+234h] [bp-298h]@13
  float v216; // [sp+238h] [bp-294h]@45
  float v217; // [sp+23Ch] [bp-290h]@45
  float v218; // [sp+240h] [bp-28Ch]@45
  float v219; // [sp+244h] [bp-288h]@45
  float v220; // [sp+248h] [bp-284h]@13
  float v221; // [sp+24Ch] [bp-280h]@13
  float v222; // [sp+250h] [bp-27Ch]@13
  float v223; // [sp+254h] [bp-278h]@13
  float v224; // [sp+258h] [bp-274h]@45
  float v225; // [sp+25Ch] [bp-270h]@45
  float v226; // [sp+260h] [bp-26Ch]@45
  float v227; // [sp+264h] [bp-268h]@45
  float v228; // [sp+268h] [bp-264h]@13
  float v229; // [sp+26Ch] [bp-260h]@13
  float v230; // [sp+270h] [bp-25Ch]@13
  float v231; // [sp+274h] [bp-258h]@13
  float v232; // [sp+278h] [bp-254h]@13
  float v233; // [sp+27Ch] [bp-250h]@13
  float v234; // [sp+280h] [bp-24Ch]@13
  float v235; // [sp+284h] [bp-248h]@13
  float v236; // [sp+288h] [bp-244h]@13
  float v237; // [sp+28Ch] [bp-240h]@13
  float v238; // [sp+290h] [bp-23Ch]@13
  float v239; // [sp+294h] [bp-238h]@13
  float v240; // [sp+298h] [bp-234h]@45
  float v241; // [sp+29Ch] [bp-230h]@45
  float v242; // [sp+2A0h] [bp-22Ch]@45
  float v243; // [sp+2A4h] [bp-228h]@45
  float v244; // [sp+2A8h] [bp-224h]@13
  float v245; // [sp+2ACh] [bp-220h]@13
  float v246; // [sp+2B0h] [bp-21Ch]@13
  float v247; // [sp+2B4h] [bp-218h]@13
  float v248; // [sp+2B8h] [bp-214h]@45
  float v249; // [sp+2BCh] [bp-210h]@45
  float v250; // [sp+2C0h] [bp-20Ch]@45
  float v251; // [sp+2C4h] [bp-208h]@45
  float v252; // [sp+2C8h] [bp-204h]@45
  float v253; // [sp+2CCh] [bp-200h]@45
  float v254; // [sp+2D0h] [bp-1FCh]@45
  float v255; // [sp+2D4h] [bp-1F8h]@45
  float v256; // [sp+2D8h] [bp-1F4h]@45
  float v257; // [sp+2DCh] [bp-1F0h]@45
  float v258; // [sp+2E0h] [bp-1ECh]@45
  float v259; // [sp+2E4h] [bp-1E8h]@45
  float v260; // [sp+2E8h] [bp-1E4h]@13
  float v261; // [sp+2ECh] [bp-1E0h]@13
  float v262; // [sp+2F0h] [bp-1DCh]@13
  float v263; // [sp+2F4h] [bp-1D8h]@13
  float v264; // [sp+2F8h] [bp-1D4h]@45
  float v265; // [sp+2FCh] [bp-1D0h]@45
  float v266; // [sp+300h] [bp-1CCh]@45
  float v267; // [sp+304h] [bp-1C8h]@45
  float v268; // [sp+308h] [bp-1C4h]@13
  float v269; // [sp+30Ch] [bp-1C0h]@13
  float v270; // [sp+310h] [bp-1BCh]@13
  float v271; // [sp+314h] [bp-1B8h]@13
  float v272; // [sp+318h] [bp-1B4h]@45
  float v273; // [sp+31Ch] [bp-1B0h]@45
  float v274; // [sp+320h] [bp-1ACh]@45
  float v275; // [sp+324h] [bp-1A8h]@45
  float v276; // [sp+328h] [bp-1A4h]@1
  float v277; // [sp+32Ch] [bp-1A0h]@1
  float v278; // [sp+330h] [bp-19Ch]@1
  float v279; // [sp+334h] [bp-198h]@49
  float v280; // [sp+338h] [bp-194h]@1
  float v281; // [sp+33Ch] [bp-190h]@1
  float v282; // [sp+340h] [bp-18Ch]@1
  float v283; // [sp+344h] [bp-188h]@1
  float v284; // [sp+348h] [bp-184h]@45
  float v285; // [sp+34Ch] [bp-180h]@45
  float v286; // [sp+350h] [bp-17Ch]@45
  float v287; // [sp+354h] [bp-178h]@45
  int v288; // [sp+358h] [bp-174h]@1
  float v289; // [sp+35Ch] [bp-170h]@57
  float v290; // [sp+360h] [bp-16Ch]@57
  float v291; // [sp+364h] [bp-168h]@57
  int v292; // [sp+368h] [bp-164h]@57
  float v293; // [sp+36Ch] [bp-160h]@21
  float v294; // [sp+370h] [bp-15Ch]@21
  float v295; // [sp+374h] [bp-158h]@21
  float v296; // [sp+378h] [bp-154h]@21
  int v297; // [sp+37Ch] [bp-150h]@12
  float v298; // [sp+380h] [bp-14Ch]@1
  float v299; // [sp+384h] [bp-148h]@1
  float v300; // [sp+388h] [bp-144h]@1
  float v301; // [sp+38Ch] [bp-140h]@1
  int v302; // [sp+390h] [bp-13Ch]@4
  float v303; // [sp+394h] [bp-138h]@37
  float v304; // [sp+398h] [bp-134h]@37
  float v305; // [sp+39Ch] [bp-130h]@37
  float v306; // [sp+3A0h] [bp-12Ch]@37
  float v307; // [sp+3A4h] [bp-128h]@13
  float v308; // [sp+3A8h] [bp-124h]@13
  float v309; // [sp+3ACh] [bp-120h]@13
  float v310; // [sp+3B0h] [bp-11Ch]@13
  float v311; // [sp+3B4h] [bp-118h]@1
  float v312; // [sp+3B8h] [bp-114h]@1
  float v313; // [sp+3BCh] [bp-110h]@1
  float v314; // [sp+3C0h] [bp-10Ch]@1
  int v315; // [sp+3C4h] [bp-108h]@1
  int v316; // [sp+3C8h] [bp-104h]@1
  int v317; // [sp+3CCh] [bp-100h]@1
  float v318; // [sp+3D0h] [bp-FCh]@57
  float v319; // [sp+3D4h] [bp-F8h]@57
  float v320; // [sp+3D8h] [bp-F4h]@57
  int v321; // [sp+3DCh] [bp-F0h]@1
  float v322; // [sp+3E0h] [bp-ECh]@45
  float v323; // [sp+3E4h] [bp-E8h]@45
  float v324; // [sp+3E8h] [bp-E4h]@45
  float v325; // [sp+3ECh] [bp-E0h]@45
  float v326; // [sp+3F0h] [bp-DCh]@1
  float v327; // [sp+3F4h] [bp-D8h]@1
  float v328; // [sp+3F8h] [bp-D4h]@1
  float v329; // [sp+3FCh] [bp-D0h]@1
  float v330; // [sp+400h] [bp-CCh]@12
  float v331; // [sp+404h] [bp-C8h]@45
  float v332; // [sp+408h] [bp-C4h]@45
  float v333; // [sp+40Ch] [bp-C0h]@45
  float v334; // [sp+410h] [bp-BCh]@45
  float v335; // [sp+414h] [bp-B8h]@13
  float v336; // [sp+418h] [bp-B4h]@13
  float v337; // [sp+41Ch] [bp-B0h]@13
  float v338; // [sp+420h] [bp-ACh]@13
  float v339; // [sp+424h] [bp-A8h]@12
  float v340; // [sp+428h] [bp-A4h]@13
  float v341; // [sp+42Ch] [bp-A0h]@13
  float v342; // [sp+430h] [bp-9Ch]@13
  float v343; // [sp+434h] [bp-98h]@13
  float v344; // [sp+438h] [bp-94h]@1
  float v345; // [sp+43Ch] [bp-90h]@1
  float v346; // [sp+440h] [bp-8Ch]@1
  float v347; // [sp+444h] [bp-88h]@1
  float v348; // [sp+448h] [bp-84h]@29
  float v349; // [sp+44Ch] [bp-80h]@29
  float v350; // [sp+450h] [bp-7Ch]@29
  float v351; // [sp+454h] [bp-78h]@29
  float v352; // [sp+458h] [bp-74h]@13
  float v353; // [sp+45Ch] [bp-70h]@13
  float v354; // [sp+460h] [bp-6Ch]@13
  float v355; // [sp+464h] [bp-68h]@13
  float v356; // [sp+468h] [bp-64h]@9
  float v357; // [sp+46Ch] [bp-60h]@9
  float v358; // [sp+470h] [bp-5Ch]@9
  float v359; // [sp+474h] [bp-58h]@9
  float v360; // [sp+484h] [bp-48h]@13
  char v361; // [sp+488h] [bp-44h]@45
  char v362; // [sp+498h] [bp-34h]@45
  float v363; // [sp+4A8h] [bp-24h]@45
  float v364; // [sp+4ACh] [bp-20h]@45
  float v365; // [sp+4B0h] [bp-1Ch]@45
  float v366; // [sp+4B4h] [bp-18h]@45
  float v367; // [sp+4B8h] [bp-14h]@45
  float v368; // [sp+4BCh] [bp-10h]@45
  float v369; // [sp+4C0h] [bp-Ch]@45
  float v370; // [sp+4C4h] [bp-8h]@45

  v326 = 2.0;
  v327 = 2.0;
  v2 = this;
  v328 = 2.0;
  v3 = *(int **)(this + 4);
  v329 = 2.0;
  v4 = *v3;
  v311 = 1.0;
  v321 = a2;
  v312 = 1.0;
  v313 = 1.0;
  v314 = 1.0;
  v182 = v4;
  v344 = 0.22222222;
  v345 = 0.22222222;
  v346 = 0.22222222;
  v347 = 0.22222222;
  v298 = 0.0;
  v299 = 0.0;
  v300 = 0.0;
  v301 = 0.0;
  v280 = 31.0;
  v281 = 63.0;
  v282 = 31.0;
  v283 = 0.0;
  sub_1002D000(v2, 0, v2 + 16);
  v5 = 0.0;
  v6 = *(float *)(v2 + 444);
  v7 = *(float *)(v2 + 452);
  v276 = 0.0;
  v8 = *(float *)(v2 + 448);
  v277 = 0.0;
  v278 = 0.0;
  v100 = v6;
  v9 = *(float *)(v2 + 456);
  v138 = 0.0;
  v139 = 0.0;
  v102 = v7;
  v140 = 0.0;
  *(float *)&v141 = 0.0;
  v101 = v8;
  v10 = 0.6666666865348816;
  v103 = v9;
  v11 = 0.3333333432674408;
  v315 = 0;
  v12 = 1.0;
  v316 = 0;
  v288 = 0;
  v317 = 0;
  v199 = 0;
  while ( 1 )
  {
    v13 = v12;
    v14 = v5;
    v15 = v13;
    v95 = v14;
    v105 = 0;
    v96 = v14;
    v97 = v14;
    v98 = v14;
    if ( v182 > 0 )
    {
      v302 = v2 + 164;
      while ( 1 )
      {
        v16 = v105;
        v79 = v14;
        v80 = v14;
        v99 = v105;
        v81 = v14;
        v82 = v14;
        while ( 1 )
        {
          if ( v16 )
          {
            v356 = v14;
            v17 = &v356;
            v357 = v14;
            v358 = v14;
            v359 = v14;
          }
          else
          {
            v17 = (float *)(v2 + 156);
          }
          v18 = *v17;
          v19 = v17[1];
          v20 = v17[2];
          v21 = v17[3];
          v106 = v18;
          v107 = v19;
          v108 = v20;
          v109 = v21;
          if ( !v16 )
            v16 = 1;
          v104 = v16;
          v297 = v2 + 16 * v16 + 164;
          v339 = v79 * v10;
          v330 = v79 * v11;
          v22 = v82;
          while ( 1 )
          {
            v126 = *(float *)(v2 + 412);
            v127 = *(float *)(v2 + 416);
            v128 = *(float *)(v2 + 420);
            v23 = *(float *)(v2 + 424);
            v126 = v126 - v106;
            v127 = v127 - v107;
            v128 = v128 - v108;
            v129 = v23 - v109;
            v146 = v126 - v79;
            v147 = v127 - v80;
            v148 = v128 - v81;
            v149 = v129 - v22;
            v220 = v146 - v95;
            v221 = v147 - v96;
            v222 = v148 - v97;
            v223 = v149 - v98;
            v183 = v339;
            v184 = v80 * v10;
            v185 = v81 * v10;
            v186 = v82 * 0.4444444477558136;
            v236 = v339 + v95;
            v237 = v184 + v96;
            v238 = v185 + v97;
            v239 = v186 + v98;
            v154 = v106 * v11;
            v155 = v19 * v11;
            v156 = v20 * v11;
            v157 = v21 * 0.1111111119389534;
            v91 = v154 + v236;
            v92 = v155 + v237;
            v93 = v156 + v238;
            v94 = v157 + v239;
            v335 = v94;
            v336 = v94;
            v337 = v94;
            v338 = v94;
            v212 = v106 * v10;
            v213 = v19 * v10;
            v214 = v10 * v20;
            v215 = v21 * 0.4444444477558136;
            v268 = v212 + v220;
            v269 = v213 + v221;
            v270 = v214 + v222;
            v271 = v215 + v223;
            v162 = v330;
            v163 = v80 * v11;
            v164 = v11 * v81;
            v165 = v82 * 0.1111111119389534;
            v83 = v330 + v268;
            v84 = v163 + v269;
            v85 = v164 + v270;
            v86 = v165 + v271;
            v360 = v109 + v22;
            v87 = 0.2222222238779068 * v360;
            v88 = v345 * v360;
            v89 = v346 * v360;
            v90 = v360 * v347;
            v191 = v86 * v94;
            v192 = v94 * v86;
            v193 = v94 * v86;
            v194 = v94 * v86;
            v244 = v87 * v87;
            v245 = v88 * v88;
            v246 = v89 * v89;
            v247 = v90 * v90;
            v260 = v191 - v244;
            v261 = v192 - v245;
            v262 = v193 - v246;
            v263 = v194 - v247;
            v307 = v15 / v260;
            v308 = v15 / v261;
            v309 = v15 / v262;
            v310 = v15 / v263;
            v170 = v91 * v86;
            v171 = v92 * v86;
            v172 = v93 * v86;
            v173 = v86 * v94;
            v228 = v87 * v83;
            v229 = v84 * v88;
            v230 = v85 * v89;
            v231 = v86 * v90;
            v204 = v170 - v228;
            v205 = v171 - v229;
            v206 = v172 - v230;
            v207 = v173 - v231;
            v114 = v204 * v307;
            v115 = v205 * v308;
            v352 = v114;
            v353 = v115;
            v116 = v206 * v309;
            v354 = v116;
            v117 = v207 * v310;
            v355 = v117;
            v178 = v83 * v94;
            v179 = v84 * v94;
            v180 = v85 * v94;
            v181 = v94 * v86;
            v232 = v91 * v87;
            v233 = v88 * v92;
            v234 = v89 * v93;
            v235 = v94 * v90;
            v134 = v178 - v232;
            v135 = v179 - v233;
            v136 = v180 - v234;
            v137 = v181 - v235;
            v122 = v134 * v307;
            v123 = v135 * v308;
            v340 = v122;
            v341 = v123;
            v24 = &v355;
            v124 = v136 * v309;
            v342 = v124;
            v125 = v137 * v310;
            v343 = v125;
            if ( v117 <= 0.0 )
              v24 = &v301;
            v25 = &v354;
            if ( v116 <= 0.0 )
              v25 = &v300;
            v26 = &v353;
            if ( v115 <= 0.0 )
              v26 = &v299;
            v27 = &v352;
            if ( v114 <= 0.0 )
              v27 = &v298;
            v293 = *v27;
            v294 = *v26;
            v295 = *v25;
            v28 = *v24;
            v29 = &v296;
            v296 = v28;
            if ( v296 >= 1.0 )
              v29 = &v314;
            v30 = &v295;
            if ( v295 >= 1.0 )
              v30 = &v313;
            v31 = &v294;
            if ( v294 >= 1.0 )
              v31 = &v312;
            v32 = &v293;
            if ( v293 >= 1.0 )
              v32 = &v311;
            v348 = *v32;
            v349 = *v31;
            v350 = *v30;
            v33 = *v29;
            v34 = &v343;
            v351 = v33;
            if ( v125 <= 0.0 )
              v34 = &v301;
            v35 = &v342;
            if ( v124 <= 0.0 )
              v35 = &v300;
            v36 = &v341;
            if ( v123 <= 0.0 )
              v36 = &v299;
            v37 = &v340;
            if ( v122 <= 0.0 )
              v37 = &v298;
            v303 = *v37;
            v304 = *v36;
            v305 = *v35;
            v38 = *v34;
            v39 = &v306;
            v306 = v38;
            if ( v306 >= 1.0 )
              v39 = &v314;
            v40 = &v305;
            if ( v305 >= 1.0 )
              v40 = &v313;
            v41 = &v304;
            if ( v304 >= 1.0 )
              v41 = &v312;
            v42 = &v303;
            if ( v303 >= 1.0 )
              v42 = &v311;
            v322 = *v42;
            v144 = v282;
            v323 = *v41;
            v142 = v280;
            v324 = *v40;
            v325 = *v39;
            v142 = v348 * 31.0;
            v143 = v281 * v349;
            v144 = v282 * v350;
            v145 = v283 * v351;
            v240 = v142 + 0.5;
            v367 = v240;
            v241 = v143 + 0.5;
            v368 = v241;
            v242 = v144 + 0.5;
            v369 = v242;
            v243 = v145 + 0.5;
            v370 = v243;
            v43 = sub_1002CDC0((int)&v361, (int)&v367);
            v44 = *(float *)(v43 + 4);
            v110 = *(float *)v43;
            v45 = *(float *)(v43 + 8);
            v111 = v44;
            v46 = *(float *)(v43 + 12);
            v110 = v110 * 0.03225806355476379;
            v111 = v111 * 0.01587301678955555;
            v112 = 0.03225806355476379 * v45;
            v113 = v46 * 0.0;
            v150 = v322 * 31.0;
            v151 = v281 * v323;
            v152 = v282 * v324;
            v153 = v283 * v325;
            v248 = v150 + 0.5;
            v363 = v248;
            v249 = v151 + 0.5;
            v364 = v249;
            v250 = v152 + 0.5;
            v365 = v250;
            v251 = v153 + 0.5;
            v366 = v251;
            v47 = sub_1002CDC0((int)&v362, (int)&v363);
            v48 = *(float *)(v47 + 4);
            v75 = *(float *)v47;
            v49 = *(float *)(v47 + 8);
            v76 = v48;
            v50 = *(float *)(v47 + 12);
            v75 = v75 * 0.03225806355476379;
            v76 = v76 * 0.01587301678955555;
            v77 = 0.03225806355476379 * v49;
            v78 = v50 * 0.0;
            v158 = v75 * v75;
            v159 = v76 * v76;
            v160 = v77 * v77;
            v161 = v78 * v78;
            v256 = v158 * v86;
            v257 = v159 * v86;
            v258 = v160 * v86;
            v259 = v161 * v86;
            v166 = v110 * v110;
            v167 = v111 * v111;
            v168 = v112 * v112;
            v169 = v113 * v113;
            v174 = v166 * v94;
            v175 = v167 * v94;
            v176 = v168 * v94;
            v177 = v169 * v94;
            v224 = v174 + v256;
            v225 = v175 + v257;
            v226 = v176 + v258;
            v227 = v177 + v259;
            v130 = v75 * v110;
            v131 = v76 * v111;
            v132 = v77 * v112;
            v133 = v113 * v78;
            v187 = v130 * v87;
            v188 = v131 * v88;
            v189 = v132 * v89;
            v190 = v133 * v90;
            v264 = v110 * v91;
            v265 = v111 * v92;
            v266 = v112 * v93;
            v267 = v94 * v113;
            v195 = v187 - v264;
            v196 = v188 - v265;
            v197 = v189 - v266;
            v198 = v190 - v267;
            v272 = v75 * v83;
            v273 = v76 * v84;
            v274 = v77 * v85;
            v275 = v86 * v78;
            v252 = v195 - v272;
            v253 = v196 - v273;
            v254 = v197 - v274;
            v255 = v198 - v275;
            v200 = v252 + v252;
            v201 = v327 * v253;
            v202 = v328 * v254;
            v203 = v329 * v255;
            v208 = v200 + v224;
            v284 = v208;
            v209 = v201 + v225;
            v285 = v209;
            v210 = v202 + v226;
            v286 = v210;
            v211 = v203 + v227;
            v287 = v211;
            v284 = v208 * *(float *)(v2 + 428);
            v285 = *(float *)(v2 + 432) * v209;
            v286 = *(float *)(v2 + 436) * v210;
            v331 = v284;
            v332 = v284;
            v333 = v284;
            v334 = v284;
            v216 = v284 + v285;
            v217 = v284 + v285;
            v218 = v284 + v285;
            v219 = v285 + v284;
            v118 = v216 + v286;
            v119 = v217 + v286;
            v120 = v218 + v286;
            v121 = v286 + v219;
            if ( v100 > (double)v118 || v101 > (double)v119 || v102 > (double)v120 || v103 > (double)v121 )
            {
              v276 = v110;
              v277 = v111;
              v138 = v75;
              v139 = v76;
              v140 = v77;
              *(float *)&v141 = v78;
              v100 = v118;
              v101 = v119;
              v102 = v120;
              v103 = v121;
              v316 = v105;
              v278 = v112;
              v279 = v113;
              v288 = v99;
              v317 = v104;
              v315 = v199;
            }
            if ( v104 == v182 )
              break;
            v51 = *(float *)(v297 - 8);
            ++v104;
            v52 = v297 + 16;
            v297 = v52;
            v106 = v51 + v106;
            v107 = *(float *)(v52 - 20) + v107;
            v19 = v107;
            v108 = *(float *)(v52 - 16) + v108;
            v20 = v108;
            v109 = *(float *)(v52 - 12) + v109;
            v21 = v109;
            v10 = 0.6666666865348816;
            v15 = 1.0;
            v22 = v82;
            v11 = 0.3333333432674408;
          }
          if ( v99 == v182 )
            break;
          v53 = v2 + 16 * v99 + 156;
          v54 = *(float *)v53 + v79;
          v16 = ++v99;
          v79 = v54;
          v80 = *(float *)(v53 + 4) + v80;
          v81 = *(float *)(v53 + 8) + v81;
          v82 = *(float *)(v53 + 12) + v82;
          v10 = 0.6666666865348816;
          v15 = 1.0;
          v14 = 0.0;
          v11 = 0.3333333432674408;
        }
        v55 = *(float *)(v302 - 8) + v95;
        ++v105;
        v95 = v55;
        v302 += 16;
        v96 = *(float *)(v302 - 20) + v96;
        v97 = v97 + *(float *)(v302 - 16);
        v98 = *(float *)(v302 - 12) + v98;
        if ( v105 >= v182 )
          break;
        v10 = 0.6666666865348816;
        v15 = 1.0;
        v14 = 0.0;
        v11 = 0.3333333432674408;
      }
    }
    v56 = v315;
    if ( v315 != v199 )
      break;
    v57 = v199 + 1;
    v199 = v57;
    if ( v57 == *(_DWORD *)(v2 + 12) )
      break;
    v289 = v138 - v276;
    v292 = v141;
    v290 = v139 - v277;
    v291 = v140 - v278;
    v318 = v289;
    v319 = v290;
    v320 = v291;
    if ( !sub_1002D000(v2, v57, (int)&v318) )
      break;
    v10 = 0.6666666865348816;
    v5 = 0.0;
    v12 = 1.0;
    v11 = 0.3333333432674408;
  }
  if ( *(float *)(v2 + 444) > (double)v100
    || *(float *)(v2 + 448) > (double)v101
    || *(float *)(v2 + 452) > (double)v102
    || *(float *)(v2 + 456) > (double)v103 )
  {
    v58 = v316;
    v59 = 0;
    for ( i = v2 + 16 * v56 + 28; v59 < v58; *((_BYTE *)&v363 + v61) = 0 )
      v61 = *(_BYTE *)(v59++ + i);
    for ( j = v288; v58 < j; *((_BYTE *)&v363 + v63) = 2 )
      v63 = *(_BYTE *)(v58++ + i);
    v64 = v317;
    for ( k = j; k < v64; *((_BYTE *)&v363 + v66) = 3 )
      v66 = *(_BYTE *)(k++ + i);
    v67 = v182;
    for ( l = v64; l < v67; *((_BYTE *)&v363 + v69) = 1 )
      v69 = *(_BYTE *)(l++ + i);
    v70 = 0;
    v71 = (_DWORD *)(*(_DWORD *)(v2 + 4) + 260);
    do
    {
      if ( *v71 == -1 )
        *((_BYTE *)&v367 + v70) = 3;
      else
        *((_BYTE *)&v367 + v70) = *((_BYTE *)&v363 + *v71);
      ++v70;
      ++v71;
    }
    while ( v70 < 16 );
    v318 = v138;
    v319 = v139;
    v320 = v140;
    v75 = v276;
    v76 = v277;
    v77 = v278;
    sub_1002C6B0((int)&v75, (int)&v367, v321, (int)&v318);
    v72 = v101;
    v73 = v102;
    *(float *)(v2 + 444) = v100;
    v74 = v103;
    *(float *)(v2 + 448) = v72;
    *(float *)(v2 + 452) = v73;
    *(float *)(v2 + 456) = v74;
  }
}

//----- (10031480) --------------------------------------------------------
int __userpurge sub_10031480@<eax>(unsigned int a1@<eax>, int a2@<edx>, int a3@<esi>, int a4)
{
  signed int v4; // ebx@1
  _DWORD *v5; // edi@1
  int v6; // edx@1
  int v7; // ecx@7
  int v8; // edi@8
  float v9; // ST24_4@17
  double v10; // st4@17
  signed int v11; // ST1C_4@17
  int v12; // ecx@17
  float v13; // ST28_4@17
  float v14; // ST2C_4@17
  int v15; // ecx@20
  signed int v16; // ecx@24
  int v17; // ebx@25
  float *v18; // edi@26
  float v19; // ST20_4@27
  char v21; // [sp+Eh] [bp-22h]@1
  char v22; // [sp+Fh] [bp-21h]@1
  signed int v23; // [sp+10h] [bp-20h]@1
  _DWORD *v24; // [sp+14h] [bp-1Ch]@1
  float v25; // [sp+14h] [bp-1Ch]@17
  signed int v26; // [sp+18h] [bp-18h]@1
  float v27; // [sp+1Ch] [bp-14h]@21
  int v28; // [sp+20h] [bp-10h]@1

  v4 = 0;
  v5 = (_DWORD *)(a3 + 260);
  v6 = a2 + 2;
  *(_DWORD *)a3 = 0;
  *(_BYTE *)(a3 + 324) = 0;
  v21 = a1 & 1;
  v22 = (a1 >> 7) & 1;
  v23 = 0;
  v26 = 1;
  v24 = (_DWORD *)(a3 + 260);
  v28 = v6;
  do
  {
    if ( a4 & v26 )
    {
      if ( v21 && *(_BYTE *)(v6 + 1) < 0x80u )
      {
        *v5 = -1;
        *(_BYTE *)(a3 + 324) = 1;
      }
      else
      {
        v7 = 0;
        if ( v4 )
        {
          v8 = v28;
          while ( !((1 << v7) & a4)
               || *(_BYTE *)(v6 - 2) != *(_BYTE *)(v8 - 2)
               || *(_BYTE *)(v6 - 1) != *(_BYTE *)(v8 - 1)
               || *(_BYTE *)v6 != *(_BYTE *)v8
               || *(_BYTE *)(v8 + 1) < 0x80u && v21 )
          {
            v4 = v23;
            ++v7;
            v8 += 4;
            if ( v7 == v23 )
            {
              v5 = v24;
              goto LABEL_17;
            }
          }
          v15 = *(_DWORD *)(a3 + 4 * v7 + 260);
          if ( v22 )
            v27 = (double)(*(_BYTE *)(v6 + 1) + 1) * 0.00390625;
          else
            v27 = 1.0;
          v5 = v24;
          v4 = v23;
          *(float *)(a3 + 4 * v15 + 196) = *(float *)(a3 + 4 * v15 + 196) + v27;
          *v24 = v15;
        }
        else
        {
LABEL_17:
          v25 = (double)(*(_BYTE *)(v6 + 1) + 1) * 0.00390625;
          v9 = (double)*(_BYTE *)(v6 - 2) / 255.0;
          v10 = (double)*(_BYTE *)(v6 - 1);
          v11 = *(_BYTE *)v6;
          v12 = a3 + 12 * *(_DWORD *)a3 + 4;
          *(float *)v12 = v9;
          v13 = v10 / 255.0;
          *(float *)(v12 + 4) = v13;
          v14 = (double)v11 / 255.0;
          *(float *)(v12 + 8) = v14;
          if ( !v22 )
            v25 = 1.0;
          *(float *)(a3 + 4 * *(_DWORD *)a3 + 196) = v25;
          *v5 = (*(_DWORD *)a3)++;
        }
      }
    }
    else
    {
      *v5 = -1;
    }
    ++v4;
    ++v5;
    v6 += 4;
    v16 = __ROL4__(v26, 1);
    v23 = v4;
    v24 = v5;
    v26 = v16;
  }
  while ( v4 < 16 );
  v17 = 0;
  if ( *(_DWORD *)a3 > 0 )
  {
    v18 = (float *)(a3 + 196);
    do
    {
      v19 = sqrt(*v18);
      ++v17;
      *v18 = v19;
      ++v18;
    }
    while ( v17 < *(_DWORD *)a3 );
  }
  return a3;
}

//----- (10031690) --------------------------------------------------------
int __cdecl sub_10031690(signed int a1, int a2, int a3)
{
  int v3; // ecx@0
  int v4; // edx@1
  int v5; // edi@1
  int v6; // esi@1
  float *v7; // edx@2
  int v8; // eax@2
  float v9; // ST2C_4@3
  float v10; // ST18_4@3
  float v11; // ST1C_4@3
  float v12; // ST20_4@3
  float v13; // ST0C_4@3
  float v14; // ST10_4@3
  float v15; // ST14_4@3
  float v16; // ST2C_4@3
  float v17; // ST18_4@3
  float v18; // ST1C_4@3
  float v19; // ST20_4@3
  float v20; // ST0C_4@3
  float v21; // ST10_4@3
  float v22; // ST14_4@3
  float v23; // ST2C_4@3
  float v24; // ST18_4@3
  float v25; // ST1C_4@3
  float v26; // ST20_4@3
  float v27; // ST0C_4@3
  float v28; // ST10_4@3
  float v29; // ST18_4@3
  float v30; // ST1C_4@3
  float v31; // ST14_4@3
  float v32; // ST20_4@3
  double v33; // st6@3
  bool v34; // zf@3
  float v35; // ST28_4@3
  float v36; // ST28_4@3
  float v37; // ST28_4@3
  double v38; // st4@3
  float v39; // ST18_4@3
  float v40; // ST1C_4@3
  float v41; // ST20_4@3
  int v42; // eax@6
  float v43; // ST18_4@7
  float v44; // ST1C_4@7
  float v45; // ST20_4@7
  float v46; // ST2C_4@7
  float v47; // ST18_4@7
  float v48; // ST1C_4@7
  float v49; // ST20_4@7
  float v50; // ST24_4@9
  int v51; // esi@10
  double v52; // st7@10
  double v53; // st6@10
  double v54; // st5@10
  int v55; // edx@11
  int v56; // eax@11
  unsigned int v57; // edi@11
  float v58; // ST18_4@12
  float v59; // ST1C_4@12
  float v60; // ST20_4@12
  float v61; // ST2C_4@12
  float v62; // ST0C_4@12
  float v63; // ST10_4@12
  float v64; // ST14_4@12
  float v65; // ST18_4@12
  float v66; // ST1C_4@12
  float v67; // ST20_4@12
  float v68; // ST2C_4@12
  float v69; // ST0C_4@12
  float v70; // ST10_4@12
  float v71; // ST14_4@12
  float v72; // ST18_4@12
  float v73; // ST1C_4@12
  float v74; // ST20_4@12
  float v75; // ST2C_4@12
  float v76; // ST0C_4@12
  float v77; // ST10_4@12
  float v78; // ST14_4@12
  float v79; // ST18_4@12
  float v80; // ST1C_4@12
  float v81; // ST20_4@12
  float v82; // ST2C_4@12
  float v83; // ST0C_4@12
  float v84; // ST10_4@12
  float v85; // ST14_4@12
  int v86; // eax@15
  float v87; // ST1C_4@16
  float v88; // ebx@16
  float v89; // ST18_4@16
  float v90; // ST1C_4@16
  float v91; // ST20_4@16
  float v92; // ST2C_4@16
  float v93; // ST0C_4@16
  float v94; // ST10_4@16
  float v95; // ST14_4@16
  float v97; // [sp+4h] [bp-24h]@1
  float v98; // [sp+8h] [bp-20h]@1
  float v99; // [sp+Ch] [bp-1Ch]@1
  unsigned int v100; // [sp+1Ch] [bp-Ch]@2
  float v101; // [sp+20h] [bp-8h]@1

  v4 = a3;
  v101 = 0.0;
  v97 = 0.0;
  v98 = 0.0;
  v5 = a1;
  v99 = 0.0;
  v6 = 0;
  if ( a1 >= 4 )
  {
    v100 = ((unsigned int)(a1 - 4) >> 2) + 1;
    v7 = (float *)(a3 + 8);
    v8 = a2 + 24;
    v6 = 4 * v100;
    do
    {
      v9 = *(v7 - 2);
      v10 = *(float *)(v8 - 24) * v9;
      v11 = *(float *)(v8 - 20) * v9;
      v12 = v9 * *(float *)(v8 - 16);
      v13 = v10 + v97;
      v14 = v11 + v98;
      v15 = v12 + v99;
      v16 = *(v7 - 1);
      v17 = *(float *)(v8 - 12) * v16;
      v18 = *(float *)(v8 - 8) * v16;
      v19 = v16 * *(float *)(v8 - 4);
      v20 = v17 + v13;
      v21 = v18 + v14;
      v22 = v19 + v15;
      v23 = *v7;
      v24 = *(float *)v8 * v23;
      v25 = *(float *)(v8 + 4) * v23;
      v26 = v23 * *(float *)(v8 + 8);
      v27 = v24 + v20;
      v28 = v25 + v21;
      v29 = *(float *)(v8 + 12);
      v30 = *(float *)(v8 + 16);
      v31 = v26 + v22;
      v32 = *(float *)(v8 + 20);
      v33 = v101 + *(v7 - 2);
      v8 += 48;
      v7 += 4;
      v34 = v100-- == 1;
      v35 = v33;
      v36 = v35 + *(v7 - 5);
      v37 = v36 + *(v7 - 4);
      v101 = v37 + *(v7 - 3);
      v38 = *(v7 - 3);
      v39 = v29 * v38;
      v40 = v30 * v38;
      v41 = v38 * v32;
      v97 = v39 + v27;
      v98 = v40 + v28;
      v99 = v41 + v31;
    }
    while ( !v34 );
    v4 = a3;
  }
  if ( v6 < a1 )
  {
    v42 = a2 + 12 * v6;
    do
    {
      v43 = *(float *)v42;
      v44 = *(float *)(v42 + 4);
      v101 = *(float *)(v4 + 4 * v6) + v101;
      v45 = *(float *)(v42 + 8);
      v46 = *(float *)(v4 + 4 * v6++);
      v42 += 12;
      v47 = v43 * v46;
      v48 = v44 * v46;
      v49 = v46 * v45;
      v97 = v47 + v97;
      v98 = v48 + v98;
      v99 = v49 + v99;
    }
    while ( v6 < a1 );
  }
  if ( v101 > 0.00000011920929 )
  {
    v50 = 1.0 / v101;
    v97 = v50 * v97;
    v98 = v98 * v50;
    v99 = v50 * v99;
  }
  *(float *)v3 = 0.0;
  v51 = 0;
  *(float *)(v3 + 4) = 0.0;
  *(float *)(v3 + 8) = 0.0;
  *(float *)(v3 + 12) = 0.0;
  *(float *)(v3 + 16) = 0.0;
  *(float *)(v3 + 20) = 0.0;
  v52 = v99;
  v53 = v98;
  v54 = v97;
  if ( a1 >= 4 )
  {
    v55 = v4 + 8;
    v56 = a2 + 24;
    v57 = ((unsigned int)(a1 - 4) >> 2) + 1;
    v51 = 4 * v57;
    do
    {
      v58 = *(float *)(v56 - 24) - v54;
      v59 = *(float *)(v56 - 20) - v53;
      v60 = *(float *)(v56 - 16) - v52;
      v61 = *(float *)(v55 - 8);
      v62 = v58 * v61;
      v63 = v59 * v61;
      v64 = v61 * v60;
      *(float *)v3 = v62 * v58 + *(float *)v3;
      *(float *)(v3 + 4) = v63 * v58 + *(float *)(v3 + 4);
      *(float *)(v3 + 8) = v58 * v64 + *(float *)(v3 + 8);
      *(float *)(v3 + 12) = v63 * v59 + *(float *)(v3 + 12);
      *(float *)(v3 + 16) = v59 * v64 + *(float *)(v3 + 16);
      *(float *)(v3 + 20) = v64 * v60 + *(float *)(v3 + 20);
      v65 = *(float *)(v56 - 12) - v54;
      v66 = *(float *)(v56 - 8) - v53;
      v67 = *(float *)(v56 - 4) - v52;
      v68 = *(float *)(v55 - 4);
      v69 = v65 * v68;
      v70 = v66 * v68;
      v71 = v68 * v67;
      *(float *)v3 = v69 * v65 + *(float *)v3;
      *(float *)(v3 + 4) = v70 * v65 + *(float *)(v3 + 4);
      *(float *)(v3 + 8) = v65 * v71 + *(float *)(v3 + 8);
      *(float *)(v3 + 12) = v70 * v66 + *(float *)(v3 + 12);
      *(float *)(v3 + 16) = v66 * v71 + *(float *)(v3 + 16);
      *(float *)(v3 + 20) = v71 * v67 + *(float *)(v3 + 20);
      v72 = *(float *)v56 - v54;
      v73 = *(float *)(v56 + 4) - v53;
      v74 = *(float *)(v56 + 8) - v52;
      v75 = *(float *)v55;
      v76 = v72 * v75;
      v77 = v73 * v75;
      v78 = v75 * v74;
      *(float *)v3 = v76 * v72 + *(float *)v3;
      *(float *)(v3 + 4) = v77 * v72 + *(float *)(v3 + 4);
      *(float *)(v3 + 8) = v72 * v78 + *(float *)(v3 + 8);
      *(float *)(v3 + 12) = v77 * v73 + *(float *)(v3 + 12);
      *(float *)(v3 + 16) = v73 * v78 + *(float *)(v3 + 16);
      *(float *)(v3 + 20) = v78 * v74 + *(float *)(v3 + 20);
      v79 = *(float *)(v56 + 12) - v54;
      v80 = *(float *)(v56 + 16) - v53;
      v81 = *(float *)(v56 + 20) - v52;
      v82 = *(float *)(v55 + 4);
      v83 = v79 * v82;
      v84 = v80 * v82;
      v85 = v82 * v81;
      *(float *)v3 = v83 * v79 + *(float *)v3;
      *(float *)(v3 + 4) = v84 * v79 + *(float *)(v3 + 4);
      *(float *)(v3 + 8) = v79 * v85 + *(float *)(v3 + 8);
      v56 += 48;
      v55 += 16;
      --v57;
      *(float *)(v3 + 12) = v84 * v80 + *(float *)(v3 + 12);
      *(float *)(v3 + 16) = v80 * v85 + *(float *)(v3 + 16);
      *(float *)(v3 + 20) = v85 * v81 + *(float *)(v3 + 20);
    }
    while ( v57 );
    v5 = a1;
    v4 = a3;
  }
  if ( v51 < v5 )
  {
    v86 = a2 + 12 * v51;
    do
    {
      v87 = *(float *)(v86 + 4);
      v88 = *(float *)(v86 + 8);
      v89 = *(float *)v86 - v54;
      ++v51;
      v86 += 12;
      v90 = v87 - v53;
      v91 = v88 - v52;
      v92 = *(float *)(v4 + 4 * v51 - 4);
      v93 = v89 * v92;
      v94 = v90 * v92;
      v95 = v92 * v91;
      *(float *)v3 = v93 * v89 + *(float *)v3;
      *(float *)(v3 + 4) = v94 * v89 + *(float *)(v3 + 4);
      *(float *)(v3 + 8) = v89 * v95 + *(float *)(v3 + 8);
      *(float *)(v3 + 12) = v94 * v90 + *(float *)(v3 + 12);
      *(float *)(v3 + 16) = v90 * v95 + *(float *)(v3 + 16);
      *(float *)(v3 + 20) = v95 * v91 + *(float *)(v3 + 20);
    }
    while ( v51 < v5 );
  }
  return v3;
}

//----- (10031CC0) --------------------------------------------------------
int __usercall sub_10031CC0@<eax>(int a1@<eax>, int a2)
{
  float *v2; // esi@2
  double v3; // st3@2
  double v4; // st2@2
  float *v5; // edx@4
  float *v6; // ecx@6
  float *v7; // eax@8
  double v8; // st3@10
  float *v9; // esi@10
  double v10; // st3@10
  float *v11; // edx@12
  float *v12; // ecx@14
  float *v13; // eax@16
  bool v14; // zf@18
  float v15; // ST0C_4@18
  float v16; // ST10_4@18
  float v17; // ST14_4@18
  float v18; // ST18_4@18
  int result; // eax@19
  float v20; // [sp+14h] [bp-F8h]@2
  float v21; // [sp+18h] [bp-F4h]@2
  float v22; // [sp+1Ch] [bp-F0h]@2
  float v23; // [sp+20h] [bp-ECh]@2
  float v24; // [sp+24h] [bp-E8h]@18
  float v25; // [sp+28h] [bp-E4h]@18
  float v26; // [sp+2Ch] [bp-E0h]@18
  float v27; // [sp+30h] [bp-DCh]@18
  float v28; // [sp+34h] [bp-D8h]@10
  float v29; // [sp+38h] [bp-D4h]@10
  float v30; // [sp+3Ch] [bp-D0h]@10
  float v31; // [sp+40h] [bp-CCh]@10
  float v32; // [sp+44h] [bp-C8h]@2
  float v33; // [sp+48h] [bp-C4h]@2
  float v34; // [sp+4Ch] [bp-C0h]@2
  float v35; // [sp+50h] [bp-BCh]@2
  float v36; // [sp+54h] [bp-B8h]@1
  float v37; // [sp+58h] [bp-B4h]@1
  float v38; // [sp+5Ch] [bp-B0h]@1
  float v39; // [sp+60h] [bp-ACh]@1
  float v40; // [sp+64h] [bp-A8h]@1
  float v41; // [sp+68h] [bp-A4h]@1
  float v42; // [sp+6Ch] [bp-A0h]@1
  float v43; // [sp+70h] [bp-9Ch]@1
  float v44; // [sp+74h] [bp-98h]@1
  float v45; // [sp+78h] [bp-94h]@1
  float v46; // [sp+7Ch] [bp-90h]@1
  float v47; // [sp+80h] [bp-8Ch]@1
  float v48; // [sp+84h] [bp-88h]@1
  float v49; // [sp+88h] [bp-84h]@1
  float v50; // [sp+8Ch] [bp-80h]@1
  float v51; // [sp+90h] [bp-7Ch]@18
  float v52; // [sp+94h] [bp-78h]@10
  float v53; // [sp+98h] [bp-74h]@10
  float v54; // [sp+9Ch] [bp-70h]@10
  float v55; // [sp+A0h] [bp-6Ch]@10
  int v56; // [sp+A4h] [bp-68h]@1
  float v57; // [sp+A8h] [bp-64h]@2
  float v58; // [sp+ACh] [bp-60h]@2
  float v59; // [sp+B0h] [bp-5Ch]@2
  float v60; // [sp+B4h] [bp-58h]@2
  float v61; // [sp+B8h] [bp-54h]@2
  float v62; // [sp+BCh] [bp-50h]@2
  float v63; // [sp+C0h] [bp-4Ch]@2
  float v64; // [sp+C4h] [bp-48h]@2
  float v65; // [sp+C8h] [bp-44h]@2
  float v66; // [sp+CCh] [bp-40h]@2
  float v67; // [sp+D0h] [bp-3Ch]@2
  float v68; // [sp+D4h] [bp-38h]@2
  float v69; // [sp+D8h] [bp-34h]@2
  float v70; // [sp+DCh] [bp-30h]@2
  float v71; // [sp+E0h] [bp-2Ch]@2
  float v72; // [sp+E4h] [bp-28h]@2
  float v73; // [sp+E8h] [bp-24h]@2
  float v74; // [sp+ECh] [bp-20h]@2
  float v75; // [sp+F0h] [bp-1Ch]@2
  float v76; // [sp+F4h] [bp-18h]@2
  float v77; // [sp+F8h] [bp-14h]@18
  float v78; // [sp+FCh] [bp-10h]@18
  float v79; // [sp+100h] [bp-Ch]@18
  float v80; // [sp+104h] [bp-8h]@18

  v40 = *(float *)a1;
  v41 = *(float *)(a1 + 4);
  v56 = 8;
  v42 = *(float *)(a1 + 8);
  v43 = 0.0;
  v44 = *(float *)(a1 + 4);
  v45 = *(float *)(a1 + 12);
  v46 = *(float *)(a1 + 16);
  v47 = 0.0;
  v36 = *(float *)(a1 + 8);
  v37 = *(float *)(a1 + 16);
  v38 = *(float *)(a1 + 20);
  v39 = 0.0;
  v48 = 1.0;
  v49 = 1.0;
  v50 = 1.0;
  do
  {
    v61 = v48 * v40;
    v62 = v41 * v48;
    v63 = v42 * v48;
    v64 = v48 * (float)0.0;
    v69 = v49 * v44;
    v70 = v45 * v49;
    v71 = v46 * v49;
    v72 = v49 * v47;
    v57 = v69 + v61;
    v58 = v70 + v62;
    v59 = v71 + v63;
    v60 = v72 + v64;
    v65 = v50 * v36;
    v66 = v37 * v50;
    v67 = v38 * v50;
    v68 = v50 * v39;
    v73 = v65 + v57;
    v2 = &v35;
    v74 = v66 + v58;
    v75 = v67 + v59;
    v76 = v68 + v60;
    v3 = v75;
    v32 = v75;
    v33 = v75;
    v34 = v75;
    v35 = v75;
    v4 = v74;
    v20 = v74;
    v21 = v74;
    v22 = v74;
    v23 = v74;
    if ( v74 >= (double)v75 )
      v2 = &v23;
    v5 = &v34;
    if ( v4 >= v3 )
      v5 = &v22;
    v6 = &v33;
    if ( v4 >= v3 )
      v6 = &v21;
    v7 = &v32;
    if ( v4 >= v3 )
      v7 = &v20;
    v52 = *v7;
    v53 = *v6;
    v54 = *v5;
    v8 = *v2;
    v9 = &v55;
    v55 = v8;
    v10 = v73;
    v28 = v73;
    v29 = v73;
    v30 = v73;
    v31 = v73;
    if ( v55 <= (double)v73 )
      v9 = &v31;
    v11 = &v54;
    if ( v54 <= v10 )
      v11 = &v30;
    v12 = &v53;
    if ( v53 <= v10 )
      v12 = &v29;
    v13 = &v52;
    if ( v52 <= v10 )
      v13 = &v28;
    v14 = v56-- == 1;
    v24 = *v13;
    v25 = *v12;
    v77 = v73;
    v26 = *v11;
    v27 = *v9;
    v15 = 1.0 / v24;
    v16 = 1.0 / v25;
    v17 = 1.0 / v26;
    v18 = 1.0 / v27;
    v77 = v10 * v15;
    v48 = v77;
    v78 = v74 * v16;
    v49 = v78;
    v79 = v75 * v17;
    v50 = v79;
    v80 = v76 * v18;
    v51 = v80;
  }
  while ( !v14 );
  result = a2;
  *(float *)a2 = v77;
  *(float *)(a2 + 4) = v78;
  *(float *)(a2 + 8) = v79;
  return result;
}

//----- (100320A0) --------------------------------------------------------
bool __usercall sub_100320A0@<al>(int a1@<eax>)
{
  signed int v1; // ecx@2
  int v2; // ecx@5
  unsigned int v3; // ecx@7
  unsigned int v4; // ecx@9
  unsigned int v5; // ecx@11
  signed int v6; // ecx@13
  unsigned int v7; // ecx@15
  unsigned int v8; // ecx@18
  unsigned int v9; // ecx@21
  unsigned int v10; // ecx@24
  bool result; // al@31

  result = 0;
  if ( *(_DWORD *)(a1 + 4) <= 1 )
  {
    v1 = *(_DWORD *)(a1 + 420);
    if ( v1 >= 0 && v1 <= 255 && *(_DWORD *)(a1 + 424) <= 0xFFu )
    {
      v2 = *(_DWORD *)(a1 + 8);
      if ( v2 == 1 || v2 == 6 )
      {
        v3 = *(_DWORD *)(a1 + 12);
        if ( v3 >= 1 && v3 <= 0x1000 )
        {
          v4 = *(_DWORD *)(a1 + 16);
          if ( v4 >= 1 && v4 <= 0x1000 )
          {
            v5 = *(_DWORD *)(a1 + 20);
            if ( v5 >= 1 && v5 <= 0x10 )
            {
              v6 = *(_DWORD *)(a1 + 24);
              if ( v6 >= 0 && v6 < 11 )
              {
                v7 = *(_DWORD *)(a1 + 448);
                if ( !v7 || v7 >= 8 && v7 <= 0x2000 )
                {
                  v8 = *(_DWORD *)(a1 + 452);
                  if ( !v8 || v8 >= 8 && v8 <= 0x2000 )
                  {
                    v9 = *(_DWORD *)(a1 + 456);
                    if ( !v9 || v9 >= 8 && v9 <= 0x2000 )
                    {
                      v10 = *(_DWORD *)(a1 + 460);
                      if ( (!v10 || v10 >= 8 && v10 <= 0x2000)
                        && *(_DWORD *)(a1 + 436) <= 3u
                        && *(_DWORD *)(a1 + 464) <= 0x10u
                        && *(_DWORD *)(a1 + 428) <= 4
                        && *(_DWORD *)(a1 + 432) < 3 )
                      {
                        result = 1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (100321D0) --------------------------------------------------------
signed int __usercall sub_100321D0@<eax>(signed int a1@<eax>)
{
  int v2; // eax@19
  int v3; // eax@20

  if ( a1 <= 894720068 )
  {
    if ( a1 != 894720068 )
    {
      if ( a1 <= 843666497 )
      {
        if ( a1 == 843666497 )
          return 6;
        if ( a1 == 826496069 )
          return 7;
        if ( a1 == 826889281 )
          return 4;
        if ( a1 == 827611204 )
          return 0;
        return -1;
      }
      if ( a1 == 844388420 || a1 == 861165636 )
        return 2;
      if ( a1 != 877942852 )
        return -1;
    }
    return 3;
  }
  if ( a1 <= 1383614328 )
  {
    if ( a1 != 1383614328 )
    {
      v2 = a1 - 1093752900;
      if ( !v2 )
        return 1;
      v3 = v2 - 286322429;
      if ( v3 )
      {
        if ( v3 == 55 )
          return 3;
        return -1;
      }
    }
    return 3;
  }
  if ( a1 != 1498952257 )
  {
    if ( a1 != 1501053763 )
      return -1;
    return 3;
  }
  return 5;
}

//----- (100322C0) --------------------------------------------------------
unsigned __int32 AssetFile::GetFileDataIndex()
{
  return 0;
}

//----- (100322D0) --------------------------------------------------------
char __thiscall sub_100322D0(int this)
{
  *(_BYTE *)(this + 14) &= 0xF8u;
  return 1;
}

//----- (100322E0) --------------------------------------------------------
char sub_100322E0()
{
  return 1;
}

//----- (100322F0) --------------------------------------------------------
void *__thiscall sub_100322F0(int this, char a2)
{
  void *v2; // esi@1
  int v3; // eax@1
  int v4; // ecx@2

  v2 = (void *)this;
  *(_DWORD *)this = &off_100A4DB0;
  v3 = *(_DWORD *)(this + 8);
  if ( v3 )
  {
    v4 = v3 - 8;
    if ( *(_DWORD *)(v3 - 4) == ~*(_DWORD *)(v3 - 8) && v3 != 8 )
    {
      if ( v4 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
    }
  }
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100A4DB0: using guessed type int (__stdcall *off_100A4DB0)(char);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10032380) --------------------------------------------------------
int __usercall sub_10032380@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int result; // eax@1

  *(_BYTE *)(a2 + 16) = *(_BYTE *)(a1 + 28) & 1;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 464);
  *(_BYTE *)(a2 + 19) = (*(_DWORD *)(a1 + 28) >> 3) & 1;
  *(_BYTE *)(a2 + 21) = (*(_DWORD *)(a1 + 28) >> 4) & 1;
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 424);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 428);
  *(_BYTE *)(a2 + 20) = ~(unsigned __int8)(*(_DWORD *)(a1 + 28) >> 5) & 1;
  *(_BYTE *)(a2 + 18) = (*(_WORD *)(a1 + 28) >> 8) & 1;
  result = *(_DWORD *)(a1 + 432);
  *(_DWORD *)(a2 + 12) = result;
  return result;
}

//----- (100323E0) --------------------------------------------------------
int __usercall sub_100323E0@<eax>(int a1@<eax>)
{
  int result; // eax@2

  if ( *(_DWORD *)(a1 + 28) )
    result = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4);
  else
    result = 0;
  return result;
}

//----- (100323F0) --------------------------------------------------------
void __thiscall sub_100323F0(int this)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // esi@5
  int v4; // eax@6

  v1 = this;
  *(_DWORD *)this = &off_100A4DE4;
  v2 = *(_DWORD *)(this + 16);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
  }
  *(_DWORD *)v1 = &off_100A4DB0;
  v3 = *(_DWORD *)(v1 + 8);
  if ( v3 )
  {
    v4 = v3 - 8;
    if ( *(_DWORD *)(v3 - 4) == ~*(_DWORD *)(v3 - 8) && v3 != 8 )
    {
      if ( v4 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100A4DB0: using guessed type int (__stdcall *off_100A4DB0)(char);
// 100A4DE4: using guessed type int (__stdcall *off_100A4DE4)(char);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100324C0) --------------------------------------------------------
char __usercall sub_100324C0@<al>(int a1@<esi>)
{
  int v1; // eax@1
  unsigned int v2; // eax@6

  (*(void (__thiscall **)(int))(*(_DWORD *)a1 + 8))(a1);
  *(_BYTE *)(a1 + 14) |= 1u;
  v1 = *(_DWORD *)(a1 + 16);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 24) = 0;
  }
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 )
  {
    if ( v2 <= 0 )
      memset((void *)(v2 + *(_DWORD *)(a1 + 16)), 0, -v2);
    *(_DWORD *)(a1 + 20) = 0;
  }
  *(_DWORD *)(a1 + 28) = 0;
  sub_10092080(a1 + 4, "dynamic_stream");
  *(_WORD *)(a1 + 12) = 7;
  return 1;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10032550) --------------------------------------------------------
char __thiscall sub_10032550(int this)
{
  int v1; // esi@1
  char v2; // al@1
  int v3; // eax@2
  char result; // al@4

  v1 = this;
  v2 = *(_BYTE *)(this + 14);
  if ( v2 & 1 )
  {
    *(_BYTE *)(this + 14) = v2 & 0xFE;
    v3 = *(_DWORD *)(this + 16);
    if ( v3 )
    {
      if ( v3 & 7 )
      {
        sub_100927E0((int)"crnlib_free: bad ptr");
        *(_DWORD *)(v1 + 16) = 0;
        *(_DWORD *)(v1 + 20) = 0;
        *(_DWORD *)(v1 + 24) = 0;
        *(_DWORD *)(v1 + 28) = 0;
        return 1;
      }
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
      *(_DWORD *)(v1 + 16) = 0;
      *(_DWORD *)(v1 + 20) = 0;
      *(_DWORD *)(v1 + 24) = 0;
    }
    *(_DWORD *)(v1 + 28) = 0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100325C0) --------------------------------------------------------
int __thiscall sub_100325C0(int this)
{
  int result; // eax@2

  if ( *(_DWORD *)(this + 20) )
    result = *(_DWORD *)(this + 16);
  else
    result = 0;
  return result;
}

//----- (100325D0) --------------------------------------------------------
int __thiscall sub_100325D0(int this, void *a2, size_t a3)
{
  int v3; // esi@1
  int v4; // edi@3
  int v5; // ecx@4
  int result; // eax@8

  v3 = this;
  if ( *(_BYTE *)(this + 14) & 1 && *(_BYTE *)(this + 12) & 1 && (v4 = a3) != 0 )
  {
    v5 = *(_DWORD *)(this + 28);
    if ( a3 >= *(_DWORD *)(v3 + 20) - v5 )
      v4 = *(_DWORD *)(v3 + 20) - v5;
    if ( v4 )
      memcpy(a2, (const void *)(v5 + *(_DWORD *)(v3 + 16)), v4);
    *(_DWORD *)(v3 + 28) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10032620) --------------------------------------------------------
size_t __thiscall sub_10032620(int this, void *a2, size_t a3)
{
  int v3; // ebx@1
  unsigned int v4; // esi@4
  size_t result; // eax@6

  v3 = this;
  if ( *(_BYTE *)(this + 14) & 1 && (*(_BYTE *)(this + 12) >> 1) & 1 && a3 )
  {
    v4 = a3 + *(_DWORD *)(this + 28);
    if ( v4 > *(_DWORD *)(this + 20) )
      sub_10033010(this + 16, v4);
    memcpy((void *)(*(_DWORD *)(v3 + 28) + *(_DWORD *)(v3 + 16)), a2, a3);
    *(_DWORD *)(v3 + 28) = v4;
    result = a3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10032680) --------------------------------------------------------
char __thiscall sub_10032680(int this)
{
  return *(_BYTE *)(this + 14) & 1;
}

//----- (10032690) --------------------------------------------------------
__int64 __thiscall sub_10032690(int this)
{
  __int64 result; // rax@2

  if ( *(_BYTE *)(this + 14) & 1 )
    result = *(_DWORD *)(this + 20);
  else
    result = 0i64;
  return result;
}

//----- (100326B0) --------------------------------------------------------
__int64 __thiscall sub_100326B0(int this)
{
  __int64 result; // rax@2

  if ( *(_BYTE *)(this + 14) & 1 )
    result = (unsigned int)(*(_DWORD *)(this + 20) - *(_DWORD *)(this + 28));
  else
    result = 0i64;
  return result;
}

//----- (100326D0) --------------------------------------------------------
__int64 __thiscall sub_100326D0(int this)
{
  __int64 result; // rax@2

  if ( *(_BYTE *)(this + 14) & 1 )
    result = *(_DWORD *)(this + 28);
  else
    result = 0i64;
  return result;
}

//----- (100326F0) --------------------------------------------------------
char __thiscall sub_100326F0(int this, __int64 a2, char a3)
{
  char v3; // bl@1
  int v4; // eax@4
  unsigned int v5; // edx@4
  char result; // al@7

  v3 = *(_BYTE *)(this + 14);
  if ( v3 & 1
    && (*(_BYTE *)(this + 12) >> 2) & 1
    && (!a3 ? (v4 = HIDWORD(a2), v5 = a2) : (v4 = (a2 + (unsigned __int64)*(_DWORD *)(this + 28)) >> 32,
                                             v5 = a2 + *(_DWORD *)(this + 28)),
        v4 >= 0) )
  {
    if ( v4 < 0 || v4 <= 0 && v5 <= *(_DWORD *)(this + 20) )
    {
      *(_BYTE *)(this + 14) = v3 & 0xFB;
      *(_DWORD *)(this + 28) = v5;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10032760) --------------------------------------------------------
void *__thiscall sub_10032760(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_100323F0((int)this);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10032780) --------------------------------------------------------
int __stdcall sub_10032780(int a1)
{
  int v1; // ST20_4@1

  sub_1007DB20(a1);
  sub_10093EF0(a1 + 336);
  v1 = a1 + 1424;
  *(_DWORD *)(v1 + 36) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  *(_DWORD *)(v1 + 44) = 0;
  `eh vector constructor iterator'((void *)(a1 + 1472), 0xCu, 2, (int)unknown_libname_3, sub_10038C00);
  *(_DWORD *)(a1 + 1504) = 0;
  *(_DWORD *)(a1 + 1508) = 0;
  *(_DWORD *)(a1 + 1512) = 0;
  *(_DWORD *)(a1 + 1516) = 0;
  *(_DWORD *)(a1 + 1520) = 0;
  *(_DWORD *)(a1 + 1524) = 0;
  *(_DWORD *)(a1 + 1528) = 0;
  *(_DWORD *)(a1 + 1532) = 0;
  *(_BYTE *)(a1 + 1536) = 0;
  *(_DWORD *)(a1 + 1540) = 0;
  *(_DWORD *)(a1 + 1544) = 0;
  *(_DWORD *)(a1 + 1548) = 0;
  *(_BYTE *)(a1 + 1560) = 0;
  *(_DWORD *)(a1 + 1552) = -1;
  *(_DWORD *)(a1 + 1556) = -1;
  *(_DWORD *)(a1 + 1568) = 0;
  *(_DWORD *)(a1 + 1572) = 0;
  *(_BYTE *)(a1 + 1576) = 0;
  *(_DWORD *)(a1 + 1580) = 0;
  *(_DWORD *)(a1 + 1584) = 0;
  *(_DWORD *)(a1 + 1588) = 0;
  *(_DWORD *)(a1 + 1592) = -1;
  *(_DWORD *)(a1 + 1596) = -1;
  *(_BYTE *)(a1 + 1600) = 0;
  *(_DWORD *)(a1 + 1608) = 0;
  *(_DWORD *)(a1 + 1612) = 0;
  *(_DWORD *)(a1 + 1616) = 0;
  *(_DWORD *)v1 = 0;
  *(_DWORD *)(a1 + 1428) = 0;
  *(_DWORD *)(a1 + 1500) = 0;
  *(_DWORD *)(a1 + 1496) = 0;
  return a1;
}
// 1003F6D0: using guessed type int unknown_libname_3();

//----- (10032890) --------------------------------------------------------
void __stdcall sub_10032890(int a1)
{
  sub_10032D20(a1 + 1424);
  sub_10032BC0(a1 + 336);
  sub_100328F0(a1);
}

//----- (100328F0) --------------------------------------------------------
void __stdcall sub_100328F0(int a1)
{
  int v1; // eax@1
  int v2; // eax@5
  int v3; // eax@9
  int v4; // eax@13
  int v5; // eax@17
  int v6; // eax@21
  int v7; // eax@25
  int v8; // eax@29
  int v9; // eax@33
  int v10; // eax@37
  int v11; // eax@41
  int v12; // eax@45

  sub_1003F520(a1 + 304);
  v1 = *(_DWORD *)(a1 + 276);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
  v2 = *(_DWORD *)(a1 + 244);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
  }
  v3 = *(_DWORD *)(a1 + 220);
  if ( v3 )
  {
    if ( v3 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
  }
  v4 = *(_DWORD *)(a1 + 208);
  if ( v4 )
  {
    if ( v4 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
  }
  v5 = *(_DWORD *)(a1 + 176);
  if ( v5 )
  {
    if ( v5 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
  }
  v6 = *(_DWORD *)(a1 + 164);
  if ( v6 )
  {
    if ( v6 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v6, 0, 0, 1, dword_100AE9F4);
  }
  v7 = *(_DWORD *)(a1 + 152);
  if ( v7 )
  {
    if ( v7 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v7, 0, 0, 1, dword_100AE9F4);
  }
  v8 = *(_DWORD *)(a1 + 140);
  if ( v8 )
  {
    if ( v8 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v8, 0, 0, 1, dword_100AE9F4);
  }
  v9 = *(_DWORD *)(a1 + 100);
  if ( v9 )
  {
    if ( v9 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v9, 0, 0, 1, dword_100AE9F4);
  }
  v10 = *(_DWORD *)(a1 + 76);
  if ( v10 )
  {
    if ( v10 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v10, 0, 0, 1, dword_100AE9F4);
  }
  v11 = *(_DWORD *)(a1 + 56);
  if ( v11 )
  {
    if ( v11 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v11, 0, 0, 1, dword_100AE9F4);
  }
  v12 = *(_DWORD *)(a1 + 44);
  if ( v12 )
  {
    if ( v12 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v12, 0, 0, 1, dword_100AE9F4);
  }
  sub_1003F520(a1 + 16);
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10032BC0) --------------------------------------------------------
void __stdcall sub_10032BC0(int a1)
{
  int v1; // eax@1
  int v2; // eax@5
  int v3; // eax@9
  int v4; // eax@13

  sub_1007C770(a1 + 1080);
  v1 = *(_DWORD *)(a1 + 44);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
  v2 = *(_DWORD *)(a1 + 32);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
  }
  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 )
  {
    if ( v3 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
  }
  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 )
  {
    if ( v4 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10032D20) --------------------------------------------------------
void __stdcall sub_10032D20(int a1)
{
  int v1; // eax@1
  int v2; // eax@5
  int v3; // eax@9
  int v4; // eax@13
  int v5; // eax@17
  int v6; // eax@21

  v1 = *(_DWORD *)(a1 + 184);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
  v2 = *(_DWORD *)(a1 + 156);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
  }
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
  }
  v4 = *(_DWORD *)(a1 + 92);
  if ( v4 )
  {
    if ( v4 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
  }
  v5 = *(_DWORD *)(a1 + 80);
  if ( v5 )
  {
    if ( v5 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
  }
  `eh vector destructor iterator'((void *)(a1 + 48), 0xCu, 2, sub_10038C00);
  v6 = *(_DWORD *)(a1 + 36);
  if ( v6 )
  {
    if ( v6 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v6, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10032EC0) --------------------------------------------------------
int __usercall sub_10032EC0@<eax>(int result@<eax>, int a2@<ebx>)
{
  int v2; // edi@1

  v2 = result;
  if ( result != a2 )
  {
    if ( *(_DWORD *)(result + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003C8F0(result);
      sub_100943C0(*(_DWORD *)(a2 + 4), 0, v2, 0, 1u, 0);
    }
    else
    {
      sub_10033010(result, 0);
    }
    memcpy(*(void **)v2, *(const void **)a2, *(_DWORD *)(a2 + 4));
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
    result = v2;
  }
  return result;
}

//----- (10032F10) --------------------------------------------------------
void __thiscall sub_10032F10(int this, unsigned int a2)
{
  unsigned int v2; // eax@1
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // eax@6
  int v6; // ecx@6
  int v7; // edx@6
  int v8; // [sp+4h] [bp-18h]@4
  int v9; // [sp+8h] [bp-14h]@4
  int v10; // [sp+Ch] [bp-10h]@4
  int v11; // [sp+18h] [bp-4h]@4

  v2 = a2;
  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ( a2 <= v4 )
  {
    if ( a2 < v4 )
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      if ( *(_DWORD *)(v3 + 4) > a2 )
        v2 = *(_DWORD *)(v3 + 4);
      sub_100943C0(v2, 0, (int)&v8, 0, 1u, 0);
      sub_10032EC0((int)&v8, v3);
      v5 = *(_DWORD *)v3;
      v6 = v9;
      *(_DWORD *)v3 = v8;
      v7 = v10;
      *(_DWORD *)(v3 + 4) = v6;
      *(_DWORD *)(v3 + 8) = v7;
      v11 = -1;
      if ( v5 )
      {
        if ( v5 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(a2, 0, v3, 0, 1u, 0);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10033010) --------------------------------------------------------
void *__usercall sub_10033010@<eax>(int a1@<edi>, unsigned int a2@<esi>)
{
  void *result; // eax@1

  result = *(void **)(a1 + 4);
  if ( (void *)a2 != result )
  {
    if ( a2 >= (unsigned int)result )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, 0, a1, a2 == (_DWORD)result + 1, 1u, 0);
      result = memset((void *)(*(_DWORD *)(a1 + 4) + *(_DWORD *)a1), 0, a2 - *(_DWORD *)(a1 + 4));
    }
    *(_DWORD *)(a1 + 4) = a2;
  }
  return result;
}

//----- (10033060) --------------------------------------------------------
void __usercall sub_10033060(int a1@<esi>)
{
  int v1; // eax@2

  if ( *(_DWORD *)(a1 + 4) )
  {
    v1 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 )
    {
      if ( v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
      *(_DWORD *)a1 = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 8) = 0;
    }
    *(_DWORD *)(a1 + 12) = 32;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 24) = 0;
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100330F0) --------------------------------------------------------
int __usercall sub_100330F0@<eax>(int result@<eax>, int a2@<ecx>)
{
  if ( a2 > result )
    result = a2;
  return result;
}

//----- (10033100) --------------------------------------------------------
PSINGLE_LIST_ENTRY __stdcall sub_10033100(PSLIST_HEADER ListHead)
{
  PSINGLE_LIST_ENTRY i; // eax@1
  FILE *v2; // eax@3
  char DstBuf; // [sp+0h] [bp-200h]@3

  for ( i = InterlockedPopEntrySList(ListHead); i; i = InterlockedPopEntrySList(ListHead) )
  {
    if ( (unsigned __int8)i & 7 )
    {
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v2 = _iob_func();
      fputs(&DstBuf, v2 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(i, 0, 0, 1, dword_100AE9F4);
    }
  }
  return sub_10033230((PSINGLE_LIST_ENTRY)ListHead);
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100331D0) --------------------------------------------------------
char __usercall sub_100331D0@<al>(int a1@<edi>, int a2@<esi>)
{
  PSINGLE_LIST_ENTRY v2; // eax@2
  char result; // al@4

  if ( *(_BYTE *)(a1 + 16) && (v2 = InterlockedPopEntrySList((PSLIST_HEADER)(a1 + 8))) != 0
    || (v2 = (PSINGLE_LIST_ENTRY)sub_10092A80(32)) != 0 )
  {
    if ( v2 != (PSINGLE_LIST_ENTRY)-8 )
    {
      v2[2].Next = *(struct _SINGLE_LIST_ENTRY **)a2;
      v2[3].Next = *(struct _SINGLE_LIST_ENTRY **)(a2 + 4);
      v2[4].Next = *(struct _SINGLE_LIST_ENTRY **)(a2 + 8);
      v2[5].Next = *(struct _SINGLE_LIST_ENTRY **)(a2 + 12);
      v2[6].Next = *(struct _SINGLE_LIST_ENTRY **)(a2 + 16);
      v2[7].Next = *(struct _SINGLE_LIST_ENTRY **)(a2 + 20);
    }
    InterlockedPushEntrySList((PSLIST_HEADER)a1, v2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10033230) --------------------------------------------------------
PSINGLE_LIST_ENTRY __usercall sub_10033230@<eax>(PSINGLE_LIST_ENTRY result@<eax>)
{
  FILE *v1; // eax@4
  union _SLIST_HEADER *ListHead; // [sp+0h] [bp-204h]@2
  char DstBuf; // [sp+4h] [bp-200h]@4

  if ( LOBYTE(result[4].Next) )
  {
    ListHead = (union _SLIST_HEADER *)&result[2];
    for ( result = InterlockedPopEntrySList((PSLIST_HEADER)&result[2]); result; result = InterlockedPopEntrySList(ListHead) )
    {
      if ( (unsigned __int8)result & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v1 = _iob_func();
        fputs(&DstBuf, v1 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(result, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10033300) --------------------------------------------------------
int __usercall sub_10033300@<eax>(int a1@<esi>)
{
  FILE *v1; // eax@1
  char DstBuf; // [sp+0h] [bp-200h]@1

  sprintf_s(
    &DstBuf,
    0x200u,
    "%s(%u): Assertion failed: \"%s\"\n",
    "j:\\programme\\sdks\\crunch-104\\crnlib\\crn_threading_win32.h",
    116,
    "((ptr_bits_t)this & (CRNLIB_GET_ALIGNMENT(tsstack) - 1)) == 0");
  OutputDebugStringA(&DstBuf);
  v1 = _iob_func();
  fputs(&DstBuf, v1 + 2);
  if ( IsDebuggerPresent() )
    DebugBreak();
  InitializeSListHead((PSLIST_HEADER)a1);
  InitializeSListHead((PSLIST_HEADER)(a1 + 8));
  return a1;
}

//----- (10033380) --------------------------------------------------------
signed int __userpurge sub_10033380@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>, int a4)
{
  int v4; // esi@1
  signed int v5; // eax@1
  unsigned __int8 v6; // dl@1
  char v7; // bl@1
  unsigned __int8 v8; // dl@1
  signed int result; // eax@1

  v4 = a1;
  v5 = a2 * (*(_BYTE *)(a1 + 2) - *(_BYTE *)(a3 + 2)) + 128;
  v6 = *(_BYTE *)(a3 + 1);
  *(_BYTE *)(a4 + 2) = *(_BYTE *)(a3 + 2) + ((v5 + (v5 >> 8)) >> 8);
  v7 = v6 + ((a2 * (*(_BYTE *)(v4 + 1) - v6) + 128 + ((a2 * (*(_BYTE *)(v4 + 1) - v6) + 128) >> 8)) >> 8);
  v8 = *(_BYTE *)a3;
  *(_BYTE *)(a4 + 1) = v7;
  result = a2 * (*(_BYTE *)v4 - v8) + 128;
  *(_BYTE *)a4 = v8 + ((result + (result >> 8)) >> 8);
  return result;
}

//----- (100333F0) --------------------------------------------------------
int __usercall sub_100333F0@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // edx@1
  unsigned int v5; // edi@1
  unsigned int v6; // ecx@1
  int v7; // ecx@2
  int v8; // edx@2
  int v9; // edi@2
  int v10; // esi@2
  unsigned int v11; // edi@3
  int v12; // esi@4
  char v13; // cl@8

  v2 = a2;
  v3 = *(_BYTE *)(a2 + 8) == 0;
  v4 = *(_BYTE *)a2;
  v5 = *(_BYTE *)(a2 + 1);
  v6 = *(_BYTE *)a2;
  if ( v3 )
  {
    v7 = 8 * v4 | (v6 >> 2);
    v8 = 8 * v5 | (v5 >> 2);
    v11 = *(_BYTE *)(v2 + 2);
    v10 = v11 >> 2;
    v9 = 8 * v11;
  }
  else
  {
    v7 = v4 | 16 * v6;
    v8 = v5 | 16 * v5;
    v9 = *(_BYTE *)(v2 + 2);
    v10 = 16 * v9;
  }
  v12 = v9 | v10;
  if ( v7 & 0xFFFFFF00 )
    LOBYTE(v7) = ~(v7 >> 31);
  *(_BYTE *)result = v7;
  if ( v8 & 0xFFFFFF00 )
    LOBYTE(v8) = ~(v8 >> 31);
  *(_BYTE *)(result + 1) = v8;
  v13 = v12;
  if ( v12 & 0xFFFFFF00 )
    v13 = ~(v12 >> 31);
  *(_BYTE *)(result + 2) = v13;
  *(_BYTE *)(result + 3) = -1;
  return result;
}

//----- (10033490) --------------------------------------------------------
int __usercall sub_10033490@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_DWORD *)result = *(_DWORD *)a2;
  *(_DWORD *)(result + 4) = *(_DWORD *)(a2 + 4);
  *(_BYTE *)(result + 8) = *(_BYTE *)(a2 + 8);
  *(_BYTE *)(result + 12) = *(_BYTE *)(a2 + 12);
  *(_BYTE *)(result + 13) = *(_BYTE *)(a2 + 13);
  *(_BYTE *)(result + 14) = *(_BYTE *)(a2 + 14);
  *(_BYTE *)(result + 15) = *(_BYTE *)(a2 + 15);
  *(_BYTE *)(result + 16) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(result + 17) = *(_BYTE *)(a2 + 17);
  *(_BYTE *)(result + 18) = *(_BYTE *)(a2 + 18);
  *(_BYTE *)(result + 19) = *(_BYTE *)(a2 + 19);
  *(_DWORD *)(result + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(result + 28) = *(_DWORD *)(a2 + 28);
  *(_BYTE *)(result + 32) = *(_BYTE *)(a2 + 32);
  return result;
}

//----- (100334F0) --------------------------------------------------------
int __cdecl sub_100334F0(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // ebx@1
  int i; // edx@1
  int v5; // ecx@2
  int v6; // eax@2
  int v7; // esi@2
  int v8; // eax@3
  int *v9; // ebp@3
  int v10; // edi@3
  signed int v11; // edx@3
  int v12; // ecx@5
  signed int v13; // esi@5
  int v14; // ecx@6
  int v15; // ecx@7
  int v16; // edi@10
  int v17; // ebx@10
  int v18; // edx@10
  int v19; // ecx@10
  int v20; // esi@10
  bool v21; // zf@10
  int *v22; // edx@10
  int v23; // edx@12
  int v25; // [sp+10h] [bp-1414h]@3
  int v26; // [sp+14h] [bp-1410h]@7
  unsigned int v27; // [sp+18h] [bp-140Ch]@3
  signed int v28; // [sp+1Ch] [bp-1408h]@3
  int *v29; // [sp+20h] [bp-1404h]@7
  int v30; // [sp+24h] [bp-1400h]@10
  char v31; // [sp+28h] [bp-13FCh]@3
  int v32[256]; // [sp+424h] [bp-1000h]@1
  int v33[768]; // [sp+824h] [bp-C00h]@2

  v3 = v2;
  memset(v32, 0, 0x800u);
  for ( i = v3; i != v3 + 32; i += 8 )
  {
    v5 = *(_DWORD *)(a2 + 2 * *(_DWORD *)(i + 4));
    v6 = (*(_DWORD *)(a2 + 2 * *(_DWORD *)i) >> 8) & 0xFF;
    v7 = (unsigned __int8)*(_DWORD *)(a2 + 2 * *(_DWORD *)i);
    ++v32[v7];
    ++v33[v6];
    ++v32[(unsigned __int8)v5];
    ++v33[(unsigned __int16)v5 >> 8];
  }
  v8 = a1;
  v9 = v32;
  v10 = v3;
  v11 = &v31 - (char *)v32;
  v25 = v3;
  v27 = 0;
  v28 = &v31 - (char *)v32;
  while ( 1 )
  {
    v12 = 0;
    v13 = 128;
    do
    {
      *(int *)((char *)v9 + v11 - 4) = v12;
      v14 = *v9 + v12;
      v9 += 2;
      *(int *)((char *)v9 + v11 - 8) = v14;
      v12 = *(v9 - 1) + v14;
      --v13;
    }
    while ( v13 );
    v15 = v10;
    v29 = v9;
    v26 = v10;
    if ( v10 != v10 + 32 )
    {
      while ( 1 )
      {
        v16 = *(_DWORD *)v15;
        v17 = *(_DWORD *)(v15 + 4);
        v18 = (*(_DWORD *)(a2 + 2 * *(_DWORD *)v15) >> 8 * v27) & 0xFF;
        v19 = *(&v30 + v18);
        v20 = (*(_DWORD *)(a2 + 2 * v17) >> 8 * v27) & 0xFF;
        v21 = v18 == v20;
        v22 = &v30 + v18;
        *(_DWORD *)(v8 + 4 * v19) = v16;
        if ( v21 )
        {
          *v22 = v19 + 2;
          *(_DWORD *)(v8 + 4 * v19 + 4) = v17;
        }
        else
        {
          *v22 = v19 + 1;
          v23 = *(&v30 + v20);
          *(&v30 + v20) = v23 + 1;
          v9 = v29;
          *(_DWORD *)(v8 + 4 * v23) = v17;
        }
        v26 += 8;
        if ( v26 == v25 + 32 )
          break;
        v15 = v26;
      }
      v11 = v28;
      v10 = v25;
    }
    v25 = v8;
    v8 = v10;
    v11 -= 1024;
    ++v27;
    v28 = v11;
    if ( v27 >= 2 )
      break;
    v10 = v25;
  }
  return v25;
}
// 100334F0: using guessed type int var_1000[256];
// 100334F0: using guessed type int var_C00[768];

//----- (100336C0) --------------------------------------------------------
void __thiscall sub_100336C0(void *this)
{
  int v1; // eax@1

  v1 = *((_DWORD *)this + 6);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100336F0) --------------------------------------------------------
int __thiscall sub_100336F0(int this)
{
  int result; // eax@1

  result = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 15;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  return result;
}

//----- (10033720) --------------------------------------------------------
void __usercall sub_10033720(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int v2; // eax@1
  int v3; // edx@6
  int v4; // eax@6
  int i; // ecx@6

  v2 = *(_DWORD *)(a1 + 4);
  if ( a2 != v2 )
  {
    if ( a2 >= v2 )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, 0, a1, a2 == v2 + 1, 0xCu, 0);
      v3 = *(_DWORD *)(a1 + 4);
      v4 = *(_DWORD *)a1 + 12 * v3;
      for ( i = v4 + 12 * (a2 - v3); v4 != i; v4 += 12 )
      {
        if ( v4 )
        {
          *(_DWORD *)v4 = 0;
          *(_DWORD *)(v4 + 4) = 0;
          *(_DWORD *)(v4 + 8) = 0;
        }
      }
      *(_DWORD *)(a1 + 4) = a2;
    }
    else
    {
      sub_1003E4E0(v2 - a2, (int *)(*(_DWORD *)a1 + 12 * a2));
      *(_DWORD *)(a1 + 4) = a2;
    }
  }
}

//----- (100337A0) --------------------------------------------------------
void __usercall sub_100337A0(void (__thiscall ***a1)(_DWORD, _DWORD)@<ebx>)
{
  if ( a1 )
  {
    (**a1)(a1, 0);
    if ( (unsigned __int8)a1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(a1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100337E0) --------------------------------------------------------
int sub_100337E0()
{
  int result; // eax@1

  result = sub_10092A80(28);
  if ( result )
  {
    *(_DWORD *)result = 0;
    *(_DWORD *)(result + 4) = 0;
    *(_DWORD *)(result + 8) = 15;
    *(_DWORD *)(result + 12) = 0;
    *(_DWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 20) = 0;
    *(_DWORD *)(result + 24) = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10033810) --------------------------------------------------------
char __usercall sub_10033810@<al>(signed int a1@<eax>)
{
  bool v1; // zf@6

  if ( a1 > 1093752900 )
  {
    if ( a1 > 1098414200 )
    {
      v1 = a1 == 1380075329;
    }
    else
    {
      if ( a1 == 1098414200 || a1 == 1094862674 )
        return 1;
      v1 = a1 == 1098414156;
    }
  }
  else
  {
    if ( a1 == 1093752900 )
      return 1;
    if ( a1 > 861165636 )
    {
      if ( a1 == 877942852 )
        return 1;
      v1 = a1 == 894720068;
    }
    else
    {
      if ( a1 == 861165636 || a1 == 826889281 )
        return 1;
      v1 = a1 == 844388420;
    }
  }
  if ( !v1 )
    return 0;
  return 1;
}

//----- (10033870) --------------------------------------------------------
bool __usercall sub_10033870@<al>(int a1@<eax>)
{
  return a1 == 826889281 || a1 == 1098414200;
}

//----- (10033890) --------------------------------------------------------
signed int __usercall sub_10033890@<eax>(signed int a1@<eax>)
{
  bool v1; // zf@7
  int v2; // eax@13
  int v3; // eax@14

  if ( a1 > 894720068 )
  {
    if ( a1 > 1383614328 )
    {
      if ( a1 == 1498952257 )
        return 1;
      v1 = a1 == 1501053763;
    }
    else
    {
      if ( a1 == 1383614328 )
        return 1;
      v2 = a1 - 1093752900;
      if ( !v2 )
        return 1;
      v3 = v2 - 286322429;
      if ( !v3 )
        return 1;
      v1 = v3 == 55;
    }
  }
  else
  {
    if ( a1 == 894720068 )
      return 1;
    if ( a1 > 843666497 )
    {
      if ( a1 == 844388420 || a1 == 861165636 )
        return 1;
      v1 = a1 == 877942852;
    }
    else
    {
      if ( a1 == 843666497 || a1 == 826496069 || a1 == 826889281 )
        return 1;
      v1 = a1 == 827611204;
    }
  }
  if ( !v1 )
    return 0;
  return 1;
}

//----- (10033900) --------------------------------------------------------
signed int __usercall sub_10033900@<eax>(signed int a1@<eax>)
{
  bool v2; // zf@10
  int v3; // eax@24

  if ( a1 <= 1094862674 )
  {
    if ( a1 == 1094862674 )
      return 32;
    if ( a1 > 844388420 )
    {
      if ( a1 > 894720068 )
      {
        if ( a1 == 1093752900 )
          return 4;
        return 0;
      }
      if ( a1 == 894720068 || a1 == 861165636 )
        return 8;
      v2 = a1 == 877942852;
      goto LABEL_11;
    }
    if ( a1 != 844388420 )
    {
      if ( a1 <= 827611204 )
      {
        if ( a1 != 827611204 && a1 != 826496069 )
        {
          if ( a1 == 826889281 )
            return 4;
          return 0;
        }
        return 4;
      }
      v2 = a1 == 843666497;
      goto LABEL_11;
    }
    return 8;
  }
  if ( a1 > 1383614328 )
  {
    if ( a1 > 2017609554 )
    {
      if ( a1 == 2021161036 )
        return 8;
      return 0;
    }
    if ( a1 == 2017609554 )
      return 24;
    if ( a1 != 1498952257 )
    {
      v2 = a1 == 1501053763;
      goto LABEL_11;
    }
    return 8;
  }
  if ( a1 == 1383614328 )
    return 8;
  if ( a1 > 1380075329 )
  {
    v2 = a1 == 1380075384;
  }
  else
  {
    if ( a1 == 1380075329 )
      return 8;
    v3 = a1 - 1098414156;
    if ( !v3 )
      return 16;
    v2 = v3 == 44;
  }
LABEL_11:
  if ( v2 )
    return 8;
  return 0;
}

//----- (100339C0) --------------------------------------------------------
int __userpurge sub_100339C0@<eax>(int result@<eax>, int a2@<ecx>, int a3, char a4)
{
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_BYTE *)(result + 14) = a4;
  *(_BYTE *)(result + 12) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(result + 13) = *(_BYTE *)(a2 + 19);
  *(_DWORD *)result = a3;
  *(_DWORD *)(result + 4) = *(_DWORD *)a2;
  return result;
}

//----- (100339F0) --------------------------------------------------------
int __thiscall sub_100339F0(int this)
{
  int v1; // esi@1

  v1 = this;
  *(_DWORD *)this = 255;
  *(_DWORD *)(this + 4) = 4;
  *(_DWORD *)(this + 1552) = 0;
  *(_DWORD *)(this + 1556) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_BYTE *)(this + 8) = 1;
  memset((void *)(this + 16), 0, 0x600u);
  *(_DWORD *)(v1 + 1560) = 0;
  *(_DWORD *)(v1 + 1568) = 3;
  *(_DWORD *)(v1 + 1564) = 100;
  *(_BYTE *)(v1 + 1572) = 1;
  return v1;
}

//----- (10033A50) --------------------------------------------------------
int __userpurge sub_10033A50@<eax>(int result@<eax>, int a2@<ecx>, int a3, char a4)
{
  *(_DWORD *)(result + 4) = *(_DWORD *)(a2 + 8);
  *(_BYTE *)(result + 8) = a4;
  *(_DWORD *)(result + 1568) = 3;
  *(_BYTE *)(result + 1572) = *(_BYTE *)(a2 + 19);
  *(_DWORD *)result = a3;
  return result;
}

//----- (10033A80) --------------------------------------------------------
int __thiscall sub_10033A80(void *this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  signed int v4; // edi@1

  v2 = (int)this;
  *(_DWORD *)a2 = 0;
  sub_1006EA70((int)this, a2 + 8);
  sub_1006C0C0(v2, a2 + 5224);
  sub_1006C0C0(v2, a2 + 10440);
  *(_DWORD *)(a2 + 15656) = 0;
  *(_DWORD *)(a2 + 15660) = 0;
  *(_DWORD *)(a2 + 15664) = 0;
  *(_DWORD *)(a2 + 15668) = 255;
  *(_DWORD *)(a2 + 15676) = 4;
  *(_DWORD *)(a2 + 15672) = 0;
  *(_WORD *)(a2 + 15680) = 257;
  *(_DWORD *)(a2 + 17224) = 0;
  *(_DWORD *)(a2 + 17228) = 0;
  *(_DWORD *)(a2 + 15684) = 0;
  *(_BYTE *)(a2 + 15682) = 1;
  memset((void *)(a2 + 15688), 0, 0x600u);
  *(_DWORD *)(a2 + 17232) = 0;
  *(_DWORD *)(a2 + 17236) = 100;
  v3 = a2 + 17240;
  v4 = 1;
  do
  {
    *(_DWORD *)v3 = 255;
    *(_DWORD *)(v3 + 4) = 4;
    *(_DWORD *)(v3 + 1552) = 0;
    *(_DWORD *)(v3 + 1556) = 0;
    *(_DWORD *)(v3 + 12) = 0;
    *(_BYTE *)(v3 + 8) = 1;
    memset((void *)(v3 + 16), 0, 0x600u);
    *(_DWORD *)(v3 + 1568) = 3;
    *(_DWORD *)(v3 + 1560) = 0;
    *(_DWORD *)(v3 + 1564) = 100;
    *(_BYTE *)(v3 + 1572) = 1;
    v3 += 1576;
    --v4;
  }
  while ( v4 >= 0 );
  return a2;
}

//----- (10033BD0) --------------------------------------------------------
void __stdcall sub_10033BD0(int a1)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 15656);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
  sub_1006BE80(a1 + 10440);
  sub_1006BE80(a1 + 5224);
  sub_1006E990(a1 + 8);
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10033C70) --------------------------------------------------------
int __userpurge sub_10033C70@<eax>(int a1@<ebx>, int a2)
{
  unsigned int v2; // edi@3
  unsigned int v3; // eax@5
  _DWORD *v4; // esi@5

  if ( a1 != a2 )
  {
    if ( *(_DWORD *)(a2 + 28) )
    {
      sub_100342E0(a1 + 24, a2 + 24);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 24);
    }
    else
    {
      v2 = *(_DWORD *)(a2 + 4) * *(_DWORD *)(a2 + 8);
      if ( v2 && *(_DWORD *)(a2 + 20) )
      {
        v3 = *(_DWORD *)(a1 + 28);
        v4 = (_DWORD *)(a1 + 24);
        if ( v2 != v3 )
        {
          if ( v2 >= v3 && v2 > *(_DWORD *)(a1 + 32) )
            sub_100943C0(v2, 0, a1 + 24, v2 == v3 + 1, 4u, 0);
          *(_DWORD *)(a1 + 28) = v2;
        }
        sub_10034380((int)v4, *(void **)(a2 + 20), *(_DWORD *)(a1 + 28));
        *(_DWORD *)(a1 + 20) = *v4;
      }
      else
      {
        sub_1003C8F0(a1 + 24);
        *(_DWORD *)(a1 + 20) = 0;
      }
    }
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  }
  return a1;
}

//----- (10033D30) --------------------------------------------------------
unsigned int __usercall sub_10033D30@<eax>(int a1@<esi>)
{
  unsigned int result; // eax@1
  unsigned int v2; // edx@1
  unsigned int v3; // edi@2
  int v4; // ebp@3
  int v5; // eax@3
  int v6; // ecx@3
  char v7; // ST0C_1@3
  char v8; // ST0D_1@3
  char v9; // ST0E_1@3
  int v10; // eax@3
  char v11; // ST0F_1@3
  int v12; // ecx@3
  int v13; // eax@3
  unsigned int v14; // [sp+4h] [bp-4h]@1

  result = *(_DWORD *)a1 >> 1;
  v2 = 0;
  v14 = *(_DWORD *)a1 >> 1;
  if ( *(_DWORD *)(a1 + 4) )
  {
    do
    {
      v3 = 0;
      if ( result )
      {
        do
        {
          v4 = *(_DWORD *)(a1 + 20);
          v5 = v2 * *(_DWORD *)(a1 + 8);
          v6 = v4 + 4 * (v5 + v3);
          v7 = *(_BYTE *)(v4 + 4 * (v5 + v3));
          v8 = *(_BYTE *)(v6 + 1);
          v9 = *(_BYTE *)(v6 + 2);
          v10 = v4 + 4 * (*(_DWORD *)a1 + v5 - v3) - 4;
          v11 = *(_BYTE *)(v6 + 3);
          *(_BYTE *)v6 = *(_BYTE *)v10;
          *(_BYTE *)(v6 + 1) = *(_BYTE *)(v10 + 1);
          *(_BYTE *)(v6 + 2) = *(_BYTE *)(v10 + 2);
          *(_BYTE *)(v6 + 3) = *(_BYTE *)(v10 + 3);
          v12 = *(_DWORD *)a1 + v2 * *(_DWORD *)(a1 + 8) - v3++;
          v13 = *(_DWORD *)(a1 + 20) + 4 * v12 - 4;
          *(_BYTE *)v13 = v7;
          *(_BYTE *)(v13 + 1) = v8;
          *(_BYTE *)(v13 + 2) = v9;
          *(_BYTE *)(v13 + 3) = v11;
          result = v14;
        }
        while ( v3 < v14 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)(a1 + 4) );
  }
  return result;
}

//----- (10033E00) --------------------------------------------------------
void __thiscall sub_10033E00(int this)
{
  unsigned int v1; // edx@1
  unsigned int v2; // ebp@1
  int v3; // eax@2
  unsigned int v4; // esi@3
  int v5; // edx@4
  int v6; // eax@4
  char v7; // bl@4
  int v8; // eax@4
  char v9; // ST11_1@4
  char v10; // ST12_1@4
  char v11; // ST13_1@4
  int v12; // edi@4
  int v13; // eax@4
  unsigned int v14; // [sp+8h] [bp-4h]@1

  v1 = *(_DWORD *)(this + 4) >> 1;
  v14 = v1;
  v2 = 0;
  if ( v1 )
  {
    v3 = *(_DWORD *)this;
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = *(_DWORD *)(this + 20);
          v6 = v4 + v2 * *(_DWORD *)(this + 8);
          v7 = *(_BYTE *)(v5 + 4 * v6);
          v8 = v5 + 4 * v6;
          v9 = *(_BYTE *)(v8 + 1);
          v10 = *(_BYTE *)(v8 + 2);
          v11 = *(_BYTE *)(v8 + 3);
          v12 = v5 + 4 * (v4 + *(_DWORD *)(this + 8) * (*(_DWORD *)(this + 4) - v2 - 1));
          *(_BYTE *)v8 = *(_BYTE *)v12;
          *(_BYTE *)(v8 + 1) = *(_BYTE *)(v12 + 1);
          *(_BYTE *)(v8 + 2) = *(_BYTE *)(v12 + 2);
          *(_BYTE *)(v8 + 3) = *(_BYTE *)(v12 + 3);
          v13 = *(_DWORD *)(this + 20) + 4 * (v4 + *(_DWORD *)(this + 8) * (*(_DWORD *)(this + 4) - v2 - 1));
          *(_BYTE *)v13 = v7;
          *(_BYTE *)(v13 + 1) = v9;
          *(_BYTE *)(v13 + 2) = v10;
          *(_BYTE *)(v13 + 3) = v11;
          v3 = *(_DWORD *)this;
          ++v4;
        }
        while ( v4 < *(_DWORD *)this );
        v1 = v14;
      }
      ++v2;
    }
    while ( v2 < v1 );
  }
}

//----- (10033EE0) --------------------------------------------------------
void __thiscall sub_10033EE0(int this)
{
  unsigned int v1; // edi@1
  int v2; // eax@2
  unsigned int v3; // esi@3
  int v4; // edx@4
  int v5; // eax@4
  unsigned __int8 v6; // bl@4
  int v7; // eax@4
  unsigned __int8 v8; // ST12_1@4
  int v9; // ebp@4

  v1 = 0;
  if ( *(_DWORD *)(this + 4) )
  {
    v2 = *(_DWORD *)this;
    do
    {
      v3 = 0;
      if ( v2 )
      {
        do
        {
          v4 = *(_DWORD *)(this + 20);
          v5 = v3 + v1 * *(_DWORD *)(this + 8);
          v6 = *(_BYTE *)(v4 + 4 * v5 + 1);
          v7 = v4 + 4 * v5;
          v8 = *(_BYTE *)(v7 + 2);
          v9 = 7471 * v8 + 19595 * *(_BYTE *)v7;
          *(_BYTE *)v7 = *(_BYTE *)v7;
          *(_BYTE *)(v7 + 1) = v6;
          *(_BYTE *)(v7 + 2) = v8;
          *(_BYTE *)(v7 + 3) = (38470 * (unsigned int)v6 + v9 + 0x8000) >> 16;
          v2 = *(_DWORD *)this;
          ++v3;
        }
        while ( v3 < *(_DWORD *)this );
      }
      ++v1;
    }
    while ( v1 < *(_DWORD *)(this + 4) );
  }
  *(_DWORD *)(this + 16) |= 8u;
}

//----- (10033F70) --------------------------------------------------------
char __userpurge sub_10033F70@<al>(char *a1@<eax>, int a2@<esi>, void *a3, int a4, int a5, int a6)
{
  char *v6; // ebx@1
  int v7; // ebp@1
  int v8; // edi@1
  char *v9; // edi@5
  size_t v10; // ebp@6
  bool v11; // zf@7
  int v13; // eax@10
  char *v14; // ecx@13
  int v15; // edx@13
  int v16; // ebx@13
  int v17; // eax@21
  int v18; // eax@21
  char *v19; // [sp+Ch] [bp-4h]@10
  char *v20; // [sp+14h] [bp+4h]@5
  char *v21; // [sp+14h] [bp+4h]@13
  int v22; // [sp+1Ch] [bp+Ch]@12

  v6 = (char *)a3;
  v7 = a5;
  v8 = a4;
  if ( (unsigned int)a4 >= *(_DWORD *)a2 || (unsigned int)a5 >= *(_DWORD *)(a2 + 4) )
    return 0;
  if ( (unsigned int)(a4 + a6) > *(_DWORD *)a2 || (unsigned int)&a1[a5] > *(_DWORD *)(a2 + 4) )
  {
    if ( a1 )
    {
      v19 = a1;
      v13 = a6;
      do
      {
        if ( v13 )
        {
          v22 = v13;
          do
          {
            v14 = v6;
            v21 = v6 + 4;
            v15 = v7;
            v16 = v8;
            if ( v8 >= 0 )
            {
              if ( v8 > *(_DWORD *)a2 - 1 )
                v16 = *(_DWORD *)a2 - 1;
            }
            else
            {
              v16 = 0;
            }
            if ( v7 >= 0 )
            {
              if ( v7 > *(_DWORD *)(a2 + 4) - 1 )
                v15 = *(_DWORD *)(a2 + 4) - 1;
            }
            else
            {
              v15 = 0;
            }
            v17 = v16 + v15 * *(_DWORD *)(a2 + 8);
            v6 = v21;
            v18 = *(_DWORD *)(a2 + 20) + 4 * v17;
            *v14 = *(_BYTE *)v18;
            v14[1] = *(_BYTE *)(v18 + 1);
            v14[2] = *(_BYTE *)(v18 + 2);
            ++v8;
            v11 = v22-- == 1;
            v14[3] = *(_BYTE *)(v18 + 3);
          }
          while ( !v11 );
          v8 = a4;
          v13 = a6;
        }
        ++v7;
        --v19;
      }
      while ( v19 );
    }
    return 1;
  }
  v9 = (char *)(*(_DWORD *)(a2 + 20) + 4 * (a4 + a5 * *(_DWORD *)(a2 + 8)));
  v20 = a1;
  if ( !a1 )
    return 1;
  v10 = 4 * a6;
  do
  {
    memcpy(v6, v9, v10);
    v6 += v10;
    v11 = v20-- == (char *)1;
    v9 += 4 * *(_DWORD *)(a2 + 8);
  }
  while ( !v11 );
  return 1;
}

//----- (10034090) --------------------------------------------------------
char __userpurge sub_10034090@<al>(int a1@<ebx>, unsigned int a2, unsigned int a3, int a4)
{
  unsigned int v4; // ebp@1
  char result; // al@4
  void *v6; // edx@7
  int v7; // edi@7
  int v8; // esi@7
  int v9; // edx@7
  unsigned int v10; // ecx@9
  int v11; // esi@10
  unsigned int v12; // ebp@11
  char *v13; // ecx@14
  int v14; // eax@14
  int v15; // eax@15
  int v16; // edi@19
  void *v17; // eax@19
  unsigned int v18; // [sp+4h] [bp-28h]@9
  int v19; // [sp+8h] [bp-24h]@10
  int v20; // [sp+Ch] [bp-20h]@10
  void *v21; // [sp+14h] [bp-18h]@7
  int v22; // [sp+18h] [bp-14h]@7
  int v23; // [sp+1Ch] [bp-10h]@7
  int v24; // [sp+28h] [bp-4h]@7

  v4 = a2;
  if ( a2 == *(_DWORD *)a1 && a3 == *(_DWORD *)(a1 + 4) && a2 == *(_DWORD *)(a1 + 8) )
    return 1;
  if ( a2 && a3 )
  {
    v24 = 0;
    v6 = *(void **)(a1 + 24);
    v7 = a1 + 24;
    v8 = a3 * a2;
    *(_DWORD *)v7 = 0;
    v21 = v6;
    v9 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(v7 + 4) = 0;
    v22 = v9;
    v23 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(v7 + 8) = 0;
    if ( !sub_10034340(a1 + 24, a3 * a2) )
    {
      sub_10034290(a1);
      v24 = -1;
      sub_10037D80((int *)&v21);
      return 0;
    }
    v10 = 0;
    v18 = 0;
    if ( a3 )
    {
      v11 = 0;
      v19 = 0;
      v20 = 4 * a2;
      do
      {
        v12 = 0;
        if ( a2 )
        {
          do
          {
            if ( v12 >= *(_DWORD *)a1 || v10 >= *(_DWORD *)(a1 + 4) )
            {
              v15 = v11 + *(_DWORD *)v7;
              *(_BYTE *)v15 = a4;
              *(_BYTE *)(v15 + 1) = BYTE1(a4);
              *(_BYTE *)(v15 + 2) = BYTE2(a4);
              *(_BYTE *)(v15 + 3) = BYTE3(a4);
            }
            else
            {
              v13 = (char *)v21 + 4 * (v12 + v10 * *(_DWORD *)(a1 + 8));
              v14 = v11 + *(_DWORD *)v7;
              *(_BYTE *)v14 = *v13;
              *(_BYTE *)(v14 + 1) = v13[1];
              *(_BYTE *)(v14 + 2) = v13[2];
              *(_BYTE *)(v14 + 3) = v13[3];
              v10 = v18;
            }
            ++v12;
            v11 += 4;
          }
          while ( v12 < a2 );
        }
        v11 = v20 + v19;
        v18 = ++v10;
        v19 += v20;
      }
      while ( v10 < a3 );
      v4 = a2;
      v8 = a3 * a2;
    }
    v16 = *(_DWORD *)v7;
    *(_DWORD *)(a1 + 4) = a3;
    v24 = -1;
    v17 = v21;
    *(_DWORD *)a1 = v4;
    *(_DWORD *)(a1 + 8) = v4;
    *(_DWORD *)(a1 + 12) = v8;
    *(_DWORD *)(a1 + 20) = v16;
    if ( v17 )
    {
      if ( (unsigned __int8)v17 & 7 )
      {
        sub_100927E0((int)"crnlib_free: bad ptr");
        return 1;
      }
      off_100AD9F4(v17, 0, 0, 1, dword_100AE9F4);
    }
    result = 1;
  }
  else
  {
    sub_10034290(a1);
    result = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10034290) --------------------------------------------------------
void __usercall sub_10034290(int a1@<esi>)
{
  int v1; // eax@1

  *(_DWORD *)(a1 + 20) = 0;
  v1 = *(_DWORD *)(a1 + 24);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
  }
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 15;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100342E0) --------------------------------------------------------
int __usercall sub_100342E0@<eax>(int result@<eax>, int a2@<edi>)
{
  int v2; // esi@1

  v2 = result;
  if ( result != a2 )
  {
    if ( *(_DWORD *)(result + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003C8F0(result);
      sub_100943C0(*(_DWORD *)(a2 + 4), 0, v2, 0, 4u, 0);
    }
    else if ( *(_DWORD *)(result + 4) )
    {
      *(_DWORD *)(result + 4) = 0;
    }
    memcpy(*(void **)v2, *(const void **)a2, 4 * *(_DWORD *)(a2 + 4));
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
    result = v2;
  }
  return result;
}

//----- (10034340) --------------------------------------------------------
char __usercall sub_10034340@<al>(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int v2; // eax@1
  char result; // al@4

  v2 = *(_DWORD *)(a1 + 4);
  if ( a2 == v2 )
    goto LABEL_6;
  if ( a2 < v2 || a2 <= *(_DWORD *)(a1 + 8) || (result = sub_100943C0(a2, 0, a1, a2 == v2 + 1, 4u, 1)) != 0 )
  {
    *(_DWORD *)(a1 + 4) = a2;
LABEL_6:
    result = 1;
  }
  return result;
}

//----- (10034380) --------------------------------------------------------
void *__userpurge sub_10034380@<eax>(int a1@<esi>, void *a2, int a3)
{
  unsigned int v3; // ebx@2
  unsigned int v4; // edi@2
  void *result; // eax@7

  if ( a3 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    v4 = v3 + a3;
    if ( v3 + a3 != v3 )
    {
      if ( v3 + a3 >= v3 && v4 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(v3 + a3, 0, a1, 1, 4u, 0);
      *(_DWORD *)(a1 + 4) = v4;
    }
    memmove((void *)(4 * a3 + *(_DWORD *)a1), *(const void **)a1, 4 * v3);
    result = memcpy(*(void **)a1, a2, 4 * a3);
  }
  return result;
}

//----- (100343F0) --------------------------------------------------------
int __cdecl sub_100343F0(int a1)
{
  int v1; // eax@1
  int v2; // ebx@1
  int v3; // ST08_4@1
  int result; // eax@1

  v1 = sub_10092A80(36);
  v2 = v1;
  v3 = v1;
  result = 0;
  if ( v3 )
  {
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
    *(_DWORD *)(v2 + 12) = 0;
    *(_DWORD *)(v2 + 16) = 15;
    *(_DWORD *)(v2 + 20) = 0;
    *(_DWORD *)(v2 + 24) = 0;
    *(_DWORD *)(v2 + 28) = 0;
    *(_DWORD *)(v2 + 32) = 0;
    sub_10033C70(v2, a1);
    result = v2;
  }
  return result;
}

//----- (10034460) --------------------------------------------------------
void __usercall sub_10034460(int a1@<ebx>)
{
  int v1; // eax@2

  if ( a1 )
  {
    v1 = *(_DWORD *)(a1 + 24);
    if ( v1 )
    {
      if ( v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    }
    if ( a1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(a1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100344C0) --------------------------------------------------------
void __usercall sub_100344C0(int *a1@<ebx>)
{
  int v1; // eax@2

  if ( a1 )
  {
    v1 = *a1;
    if ( *a1 )
    {
      if ( v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    }
    if ( (unsigned __int8)a1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(a1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10034520) --------------------------------------------------------
int sub_10034520()
{
  int result; // eax@1

  result = sub_10092A80(64);
  if ( result )
  {
    *(_DWORD *)result = 0;
    *(_DWORD *)(result + 4) = 0;
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 12) = 0;
    *(_DWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 20) = 0;
    *(_DWORD *)(result + 24) = 0;
    *(_DWORD *)(result + 28) = 0;
    *(_DWORD *)(result + 32) = 0;
    *(_DWORD *)(result + 36) = 0;
    *(_DWORD *)(result + 40) = 0;
    *(_DWORD *)(result + 44) = 0;
    *(_DWORD *)(result + 60) = -1;
    *(_DWORD *)(result + 52) = 0;
    *(_DWORD *)(result + 56) = 0;
    *(_WORD *)(result + 48) = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10034570) --------------------------------------------------------
int __cdecl sub_10034570(int *a1, int *a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v4; // ST08_4@2
  int v5; // ST04_4@2
  int result; // eax@2
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+Ch] [bp-4h]@1

  v7 = v2;
  v3 = sub_10092A80(36);
  v8 = 0;
  if ( v3 )
  {
    v4 = *a2;
    v5 = *a1;
    v7 = -16777216;
    result = sub_100345E0(v3, v5, v4, (int)&v7);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100345E0) --------------------------------------------------------
int __stdcall sub_100345E0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1
  unsigned int v5; // ebx@1
  int v6; // eax@5

  v4 = a1 + 24;
  *(_DWORD *)(a1 + 16) = 15;
  *(_DWORD *)v4 = 0;
  *(_DWORD *)(v4 + 4) = 0;
  *(_DWORD *)(v4 + 8) = 0;
  v5 = a3 * a2;
  if ( a3 * a2 )
  {
    if ( v5 > 0 )
      sub_100943C0(a3 * a2, 0, v4, v5 == 1, 4u, 0);
    *(_DWORD *)(a1 + 28) = v5;
  }
  v6 = *(_DWORD *)v4;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = v5;
  *(_DWORD *)(a1 + 20) = v6;
  sub_10034680(a4, a1);
  return a1;
}

//----- (10034680) --------------------------------------------------------
int __usercall sub_10034680@<eax>(int a1@<ecx>, int a2@<edi>)
{
  unsigned int v2; // esi@1
  int result; // eax@2

  v2 = 0;
  if ( *(_DWORD *)(a2 + 12) )
  {
    do
    {
      result = *(_DWORD *)(a2 + 20) + 4 * v2;
      *(_BYTE *)result = *(_BYTE *)a1;
      *(_BYTE *)(result + 1) = *(_BYTE *)(a1 + 1);
      *(_BYTE *)(result + 2) = *(_BYTE *)(a1 + 2);
      ++v2;
      *(_BYTE *)(result + 3) = *(_BYTE *)(a1 + 3);
    }
    while ( v2 < *(_DWORD *)(a2 + 12) );
  }
  return result;
}

//----- (100346C0) --------------------------------------------------------
int __stdcall sub_100346C0(int a1, unsigned int a2)
{
  int result; // eax@1
  unsigned int v3; // edx@1
  int v4; // esi@2
  char v5; // ST1C_1@3
  char v6; // ST20_1@3
  char v7; // bl@3
  char v8; // al@3
  char v9; // ST13_1@3
  char v10; // cl@3
  char v11; // dl@3
  unsigned int v12; // ebp@3
  char v13; // ST16_1@3
  char v14; // cl@3
  int v15; // ST20_4@3
  unsigned __int8 v16; // [sp+3h] [bp-19h]@2
  unsigned __int8 v17; // [sp+4h] [bp-18h]@2
  unsigned __int8 v18; // [sp+5h] [bp-17h]@2
  unsigned __int8 v19; // [sp+6h] [bp-16h]@2
  unsigned int v20; // [sp+14h] [bp-8h]@1

  result = a1;
  LOBYTE(v3) = 0;
  v20 = 0;
  if ( a2 >> 1 )
  {
    v16 = *(_BYTE *)(a1 + 4);
    v17 = *(_BYTE *)(a1 + 5);
    v18 = *(_BYTE *)(a1 + 6);
    v19 = *(_BYTE *)(a1 + 7);
    v4 = 0;
    do
    {
      v5 = 2 * v3;
      v6 = 2 * (a2 - v3) - 2;
      v7 = (v16 >> 2 * v3) & 3;
      v8 = ~(3 << v4);
      v9 = ((((unsigned int)v16 >> v6) & 3) << v4) | v8 & v16;
      v10 = 2 * (a2 - v20) - 2;
      v11 = ~(3 << v10);
      v16 = (v7 << v10) | v11 & v9;
      v17 = ((((unsigned int)v17 >> v5) & 3) << v10) | v11 & (((((unsigned int)v17 >> v6) & 3) << v4) | v8 & v17);
      v12 = v19;
      v13 = v8 & v19;
      v18 = ((((unsigned int)v18 >> v5) & 3) << v10) | v11 & (((((unsigned int)v18 >> v6) & 3) << v4) | v8 & v18);
      v14 = v4;
      v4 += 2;
      v15 = (v12 >> v6) & 3;
      result = (unsigned __int8)v15;
      LOBYTE(result) = v11 & (((_BYTE)v15 << v14) | v13);
      v3 = v20 + 1;
      LOBYTE(result) = (((v12 >> v5) & 3) << (2 * (a2 - v20) - 2)) | result;
      v19 = result;
      v20 = v3;
    }
    while ( v3 < a2 >> 1 );
    *(_BYTE *)(a1 + 4) = v16;
    *(_BYTE *)(a1 + 5) = v17;
    *(_BYTE *)(a1 + 6) = v18;
    *(_BYTE *)(a1 + 7) = result;
  }
  return result;
}

//----- (10034890) --------------------------------------------------------
unsigned __int8 *__fastcall sub_10034890(int a1, int a2, unsigned int a3)
{
  unsigned __int8 *result; // eax@1
  int v4; // edi@2
  int v5; // esi@2
  unsigned __int8 *v6; // ebp@2
  unsigned __int8 v7; // cl@4
  int v8; // esi@4
  char v9; // cl@4
  unsigned int v10; // ecx@4
  unsigned __int8 v11; // dl@4
  int i; // [sp+8h] [bp-8h]@2

  result = (unsigned __int8 *)(a3 >> 1);
  if ( a3 >> 1 )
  {
    v4 = a1 + 4;
    v5 = -4 - a1;
    result = (unsigned __int8 *)(a1 + 4);
    v6 = (unsigned __int8 *)(a1 + a3 + 3);
    for ( i = -4 - a1; ; v5 = i )
    {
      v7 = *result;
      *result = *v6 & 3 | *result & 0xFC;
      v8 = a3 - v5 - (_DWORD)result - 1;
      *(_BYTE *)(v4 + v8) = v7 & 3 | *(_BYTE *)(v4 + v8) & 0xFC;
      v9 = (*result >> 2) & 3;
      *result = 4 * ((*v6 >> 2) & 3) | *result & 0xF3;
      *(_BYTE *)(v4 + v8) = 4 * v9 | *(_BYTE *)(v4 + v8) & 0xF3;
      v10 = (unsigned int)*result >> 4;
      *result = 16 * ((*v6 >> 4) & 3) | *result & 0xCF;
      *(_BYTE *)(v4 + v8) = 16 * (v10 & 3) | *(_BYTE *)(v4 + v8) & 0xCF;
      v11 = *result;
      *result = *v6 & 0xC0 | *result & 0x3F;
      ++result;
      --v6;
      *(_BYTE *)(v4 + v8) = v11 & 0xC0 | *(_BYTE *)(v4 + v8) & 0x3F;
      if ( (unsigned int)&result[i] >= a3 >> 1 )
        break;
    }
  }
  return result;
}

//----- (100349A0) --------------------------------------------------------
unsigned int __userpurge sub_100349A0@<eax>(int a1@<esi>, unsigned int a2)
{
  unsigned int result; // eax@1
  unsigned int v3; // ebp@2
  unsigned int v4; // ebx@2
  char v5; // dl@2
  unsigned int v6; // ecx@4
  unsigned int v7; // edi@4
  unsigned int v8; // eax@4
  char v9; // bl@4
  char v10; // al@6
  unsigned int v11; // ebx@6
  unsigned int v12; // edx@8
  char v13; // bl@8
  unsigned int v14; // ebx@10
  unsigned int v15; // edx@12
  char v16; // bl@12
  unsigned int v17; // ebx@14
  unsigned int v18; // edx@16
  char v19; // bl@16
  char v20; // [sp+3h] [bp-19h]@6
  char v21; // [sp+4h] [bp-18h]@4
  char v22; // [sp+8h] [bp-14h]@6
  int v23; // [sp+Ch] [bp-10h]@2
  char v24; // [sp+10h] [bp-Ch]@6
  unsigned int v25; // [sp+14h] [bp-8h]@1

  result = 0;
  v25 = 0;
  if ( a2 >> 1 )
  {
    do
    {
      v3 = result >> 1;
      v4 = *(_BYTE *)(a1 + (result >> 1));
      v5 = result & 1;
      v23 = result & 1;
      if ( result & 1 )
        v4 >>= 4;
      v6 = a2 - result - 1;
      v7 = v6 >> 1;
      v8 = *(_BYTE *)((v6 >> 1) + a1);
      v9 = v4 & 0xF;
      v21 = v6 & 1;
      if ( v6 & 1 )
        v8 >>= 4;
      v22 = 4 * v5;
      v20 = ~(15 << 4 * v5);
      *(_BYTE *)(a1 + v3) = *(_BYTE *)(a1 + v3) & v20 | ((v8 & 0xF) << 4 * v5);
      v24 = 4 * v21;
      v10 = ~(15 << 4 * v21);
      *(_BYTE *)(v7 + a1) = (v9 << v24) | *(_BYTE *)(v7 + a1) & ~(15 << v24);
      v11 = *(_BYTE *)(a1 + v3 + 2);
      if ( v23 )
        v11 >>= 4;
      v12 = *(_BYTE *)(v7 + a1 + 2);
      v13 = v11 & 0xF;
      if ( v6 & 1 )
        v12 >>= 4;
      *(_BYTE *)(a1 + v3 + 2) = *(_BYTE *)(a1 + v3 + 2) & v20 | ((v12 & 0xF) << v22);
      *(_BYTE *)(v7 + a1 + 2) = (v13 << v24) | *(_BYTE *)(v7 + a1 + 2) & v10;
      v14 = *(_BYTE *)(a1 + v3 + 4);
      if ( v23 )
        v14 >>= 4;
      v15 = *(_BYTE *)(v7 + a1 + 4);
      v16 = v14 & 0xF;
      if ( v6 & 1 )
        v15 >>= 4;
      *(_BYTE *)(a1 + v3 + 4) = *(_BYTE *)(a1 + v3 + 4) & v20 | ((v15 & 0xF) << v22);
      *(_BYTE *)(v7 + a1 + 4) = (v16 << v24) | *(_BYTE *)(v7 + a1 + 4) & v10;
      v17 = *(_BYTE *)(a1 + v3 + 6);
      if ( v23 )
        v17 >>= 4;
      v18 = *(_BYTE *)(v7 + a1 + 6);
      v19 = v17 & 0xF;
      if ( v6 & 1 )
        v18 >>= 4;
      *(_BYTE *)(a1 + v3 + 6) = *(_BYTE *)(a1 + v3 + 6) & v20 | ((v18 & 0xF) << v22);
      *(_BYTE *)(v7 + a1 + 6) = (v19 << v24) | *(_BYTE *)(v7 + a1 + 6) & v10;
      result = v25 + 1;
      v25 = result;
    }
    while ( result < a2 >> 1 );
  }
  return result;
}

//----- (10034B30) --------------------------------------------------------
int __userpurge sub_10034B30@<eax>(int result@<eax>, unsigned int a2)
{
  unsigned int v2; // edi@1
  unsigned int v3; // esi@1
  int v4; // ebp@2
  char v5; // cl@4
  int v6; // edi@4
  unsigned __int8 v7; // cl@4
  char v8; // cl@4
  unsigned __int8 v9; // dl@4

  v2 = a2;
  v3 = 0;
  if ( a2 >> 1 )
  {
    v4 = result + 2 * a2 - 2;
    while ( 1 )
    {
      v5 = *(_BYTE *)(result + 2 * v3) & 0xF;
      *(_BYTE *)(result + 2 * v3) = *(_BYTE *)v4 & 0xF | *(_BYTE *)(result + 2 * v3) & 0xF0;
      v6 = 2 * (v2 - v3) - 2;
      *(_BYTE *)(v6 + result) = v5 | *(_BYTE *)(v6 + result) & 0xF0;
      v7 = *(_BYTE *)(result + 2 * v3);
      *(_BYTE *)(result + 2 * v3) = 16 * ((*(_BYTE *)v4 >> 4) & 0xF) | v7 & 0xF;
      *(_BYTE *)(v6 + result) = 16 * (v7 >> 4) | *(_BYTE *)(v6 + result) & 0xF;
      v8 = *(_BYTE *)(result + 2 * v3 + 1);
      *(_BYTE *)(result + 2 * v3 + 1) = *(_BYTE *)(v4 + 1) & 0xF | v8 & 0xF0;
      *(_BYTE *)(v6 + result + 1) = v8 & 0xF | *(_BYTE *)(v6 + result + 1) & 0xF0;
      v9 = *(_BYTE *)(result + 2 * v3 + 1);
      *(_BYTE *)(result + 2 * v3++ + 1) = 16 * ((*(_BYTE *)(v4 + 1) >> 4) & 0xF) | v9 & 0xF;
      v4 -= 2;
      *(_BYTE *)(v6 + result + 1) = 16 * (v9 >> 4) | *(_BYTE *)(v6 + result + 1) & 0xF;
      if ( v3 >= a2 >> 1 )
        break;
      v2 = a2;
    }
  }
  return result;
}

//----- (10034C20) --------------------------------------------------------
unsigned int __userpurge sub_10034C20@<eax>(int a1@<edi>, unsigned int a2)
{
  unsigned int result; // eax@1
  unsigned int v3; // ebx@3
  unsigned int v4; // ebp@3
  unsigned int v5; // esi@5
  unsigned int v6; // eax@5
  char v7; // bl@5
  unsigned int v8; // edx@7
  char v9; // bp@7
  unsigned int v10; // eax@7
  int v11; // eax@11
  int v12; // esi@13
  int v13; // eax@15
  int v14; // [sp+0h] [bp-24h]@9
  unsigned int v15; // [sp+4h] [bp-20h]@3
  int v16; // [sp+8h] [bp-1Ch]@3
  unsigned int v17; // [sp+Ch] [bp-18h]@1
  unsigned int v18; // [sp+10h] [bp-14h]@2
  signed int v19; // [sp+14h] [bp-10h]@3
  int v20; // [sp+1Ch] [bp-8h]@7

  result = a2 >> 1;
  v17 = 0;
  if ( a2 >> 1 )
  {
    v18 = 0;
    do
    {
      v3 = v18;
      v4 = 3 * (a2 - v17) - 3;
      v15 = v18;
      v16 = 3 * (a2 - v17) - 3;
      v19 = 4;
      while ( 1 )
      {
        v5 = v3 >> 3;
        v6 = *(_BYTE *)(a1 + (v3 >> 3) + 2);
        v7 = v3 & 7;
        if ( v5 < 5 )
          v6 |= *(_BYTE *)(v5 + a1 + 3) << 8;
        v8 = v4 >> 3;
        v9 = v4 & 7;
        v20 = (v6 >> v7) & 7;
        v10 = *(_BYTE *)(a1 + v8 + 2);
        if ( v8 < 5 )
          v10 |= *(_BYTE *)(v8 + a1 + 3) << 8;
        v14 = *(_BYTE *)(a1 + v5 + 2);
        if ( v5 < 5 )
          v14 |= *(_BYTE *)(v5 + a1 + 3) << 8;
        v11 = v14 & ~(7 << v7) | (((v10 >> v9) & 7) << v7);
        *(_BYTE *)(a1 + v5 + 2) = v11;
        if ( v5 < 5 )
          *(_BYTE *)(v5 + a1 + 3) = BYTE1(v11);
        v12 = *(_BYTE *)(a1 + v8 + 2);
        if ( v8 < 5 )
          v12 |= *(_BYTE *)(v8 + a1 + 3) << 8;
        v13 = (v20 << v9) | v12 & ~(7 << v9);
        *(_BYTE *)(a1 + v8 + 2) = v13;
        if ( v8 < 5 )
          *(_BYTE *)(v8 + a1 + 3) = BYTE1(v13);
        v15 += 12;
        v16 += 12;
        if ( !--v19 )
          break;
        v4 = v16;
        v3 = v15;
      }
      v18 += 3;
      result = v17 + 1;
      v17 = result;
    }
    while ( result < a2 >> 1 );
  }
  return result;
}

//----- (10034D70) --------------------------------------------------------
unsigned int __userpurge sub_10034D70@<eax>(int a1@<edi>, unsigned int a2)
{
  unsigned int v2; // ebx@1
  unsigned int result; // eax@1
  unsigned int v4; // ebp@2
  unsigned int v5; // esi@4
  unsigned int v6; // eax@4
  char v7; // bl@4
  unsigned int v8; // edx@6
  char v9; // bp@6
  unsigned int v10; // eax@6
  int v11; // eax@10
  int v12; // esi@12
  int v13; // eax@14
  bool v14; // zf@16
  unsigned int v15; // [sp+4h] [bp-20h]@2
  int v16; // [sp+8h] [bp-1Ch]@8
  int v17; // [sp+Ch] [bp-18h]@2
  unsigned int v18; // [sp+10h] [bp-14h]@1
  signed int v19; // [sp+14h] [bp-10h]@2
  int v20; // [sp+1Ch] [bp-8h]@6

  v2 = 0;
  result = a2 >> 1;
  v18 = 0;
  if ( a2 >> 1 )
  {
    do
    {
      v15 = v2;
      v4 = 4 * (3 * (a2 - v18) - 3);
      v17 = 4 * (3 * (a2 - v18) - 3);
      v19 = 4;
      while ( 1 )
      {
        v5 = v2 >> 3;
        v6 = *(_BYTE *)(a1 + (v2 >> 3) + 2);
        v7 = v2 & 7;
        if ( v5 < 5 )
          v6 |= *(_BYTE *)(v5 + a1 + 3) << 8;
        v8 = v4 >> 3;
        v9 = v4 & 7;
        v20 = (v6 >> v7) & 7;
        v10 = *(_BYTE *)(a1 + v8 + 2);
        if ( v8 < 5 )
          v10 |= *(_BYTE *)(v8 + a1 + 3) << 8;
        v16 = *(_BYTE *)(a1 + v5 + 2);
        if ( v5 < 5 )
          v16 |= *(_BYTE *)(v5 + a1 + 3) << 8;
        v11 = v16 & ~(7 << v7) | (((v10 >> v9) & 7) << v7);
        *(_BYTE *)(a1 + v5 + 2) = v11;
        if ( v5 < 5 )
          *(_BYTE *)(v5 + a1 + 3) = BYTE1(v11);
        v12 = *(_BYTE *)(a1 + v8 + 2);
        if ( v8 < 5 )
          v12 |= *(_BYTE *)(v8 + a1 + 3) << 8;
        v13 = (v20 << v9) | v12 & ~(7 << v9);
        *(_BYTE *)(a1 + v8 + 2) = v13;
        if ( v8 < 5 )
          *(_BYTE *)(v8 + a1 + 3) = BYTE1(v13);
        v15 += 3;
        v17 += 3;
        v14 = v19-- == 1;
        v2 = v15;
        if ( v14 )
          break;
        v4 = v17;
      }
      result = v18 + 1;
      v18 = result;
    }
    while ( result < a2 >> 1 );
  }
  return result;
}

//----- (10034EC0) --------------------------------------------------------
int __stdcall sub_10034EC0(int a1, int a2)
{
  int v2; // edi@1

  v2 = a1 + 24;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)v2 = 0;
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  if ( a1 + 24 != a2 + 24 )
  {
    if ( *(_DWORD *)(a1 + 32) < *(_DWORD *)(a2 + 28) )
    {
      sub_1003C8F0(v2);
      sub_100943C0(*(_DWORD *)(a2 + 28), 0, v2, 0, 1u, 0);
    }
    else
    {
      sub_10033010(v2, 0);
    }
    memcpy(*(void **)v2, *(const void **)(a2 + 24), *(_DWORD *)(a2 + 28));
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  }
  *(_DWORD *)(a1 + 12) = *(_DWORD *)v2;
  return a1;
}

//----- (10034F80) --------------------------------------------------------
int __stdcall sub_10034F80(int a1, int a2)
{
  int v2; // eax@1
  void **v3; // edi@1

  v2 = a2;
  v3 = (void **)(a1 + 4);
  *(_DWORD *)a1 = *(_DWORD *)a2;
  if ( a1 + 4 != a2 + 4 )
  {
    if ( *(_DWORD *)(a1 + 12) < *(_DWORD *)(a2 + 8) )
    {
      sub_1003C8F0((int)v3);
      sub_100943C0(*(_DWORD *)(a2 + 8), 0, (int)v3, 0, 1u, 0);
    }
    else
    {
      sub_10033010((int)v3, 0);
    }
    memcpy(*v3, *(const void **)(a2 + 4), *(_DWORD *)(a2 + 8));
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
    v2 = a2;
  }
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 16);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(v2 + 20);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(v2 + 24);
  *(_BYTE *)(a1 + 25) = *(_BYTE *)(v2 + 25);
  return a1;
}

//----- (10035010) --------------------------------------------------------
int __userpurge sub_10035010@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, char a4)
{
  int v4; // edx@2
  int result; // eax@2
  int v6; // ebx@3
  signed int v7; // eax@4
  int v8; // edx@4
  bool v9; // zf@5
  int v10; // esi@5
  int v11; // edi@5
  int v12; // edx@5
  int v13; // edx@6
  int v14; // esi@6
  int v15; // edi@6

  if ( a4 )
  {
    v4 = *(_BYTE *)a1 - *(_BYTE *)a3;
    result = (*(_BYTE *)(a1 + 2) - *(_BYTE *)(a3 + 2)) * (*(_BYTE *)(a1 + 2) - *(_BYTE *)(a3 + 2))
           + 25 * (*(_BYTE *)(a1 + 1) - *(_BYTE *)(a3 + 1)) * (*(_BYTE *)(a1 + 1) - *(_BYTE *)(a3 + 1))
           + 8 * v4 * v4;
  }
  else
  {
    v6 = *(_DWORD *)a2;
    if ( *(_BYTE *)(*(_DWORD *)a2 + 23) )
    {
      v7 = 38470 * *(_BYTE *)(a1 + 1) + 7471 * *(_BYTE *)(a1 + 2) + 19595 * *(_BYTE *)a1 + 0x8000;
      v8 = (38470 * *(_BYTE *)(a3 + 1) + 7471 * *(_BYTE *)(a3 + 2) + 19595 * *(_BYTE *)a3 + 0x8000) >> 16;
      result = ((v7 >> 16) - v8) * ((v7 >> 16) - v8);
    }
    else
    {
      v9 = *(_BYTE *)(a2 + 13) == 0;
      v10 = *(_BYTE *)a3;
      v11 = *(_BYTE *)(a3 + 1);
      v12 = *(_BYTE *)a1;
      if ( v9 )
      {
        result = (v12 - v10) * (v12 - v10)
               + (*(_BYTE *)(a1 + 1) - v11) * (*(_BYTE *)(a1 + 1) - v11)
               + (*(_BYTE *)(a1 + 2) - *(_BYTE *)(a3 + 2)) * (*(_BYTE *)(a1 + 2) - *(_BYTE *)(a3 + 2));
      }
      else
      {
        v13 = v12 - v10;
        v14 = *(_BYTE *)(a1 + 1) - v11;
        v15 = *(_BYTE *)(a1 + 2) - *(_BYTE *)(a3 + 2);
        result = v13 * v13 * *(_DWORD *)(v6 + 28) + v15 * v15 * *(_DWORD *)(v6 + 36) + v14 * v14 * *(_DWORD *)(v6 + 32);
      }
    }
  }
  return result;
}

//----- (10035120) --------------------------------------------------------
int __usercall sub_10035120@<eax>(int a1@<ecx>, int a2@<esi>, float a3, float a4)
{
  double v4; // st7@1
  double v5; // st6@1
  double v6; // st5@2
  double v7; // st7@2
  unsigned int v8; // eax@3
  int v9; // edx@3
  unsigned int v10; // eax@11
  int v11; // edx@11
  int result; // eax@17
  float v13; // ST00_4@17
  unsigned int v14; // eax@19
  int v15; // edx@19
  double v16; // rtt@19
  double v17; // st5@19
  double v18; // st7@19
  float v19; // ST00_4@20
  float v20; // [sp+0h] [bp-4h]@2
  float v21; // [sp+0h] [bp-4h]@9
  float v22; // [sp+0h] [bp-4h]@19

  v4 = a3;
  v5 = a4;
  if ( a4 > (double)a3 )
  {
    v8 = *(_DWORD *)a1 ^ (*(_DWORD *)a1 << 17) ^ ((unsigned int)(*(_DWORD *)a1 ^ (*(_DWORD *)a1 << 17)) >> 13) ^ 32 * (*(_DWORD *)a1 ^ (*(_DWORD *)a1 << 17) ^ ((unsigned int)(*(_DWORD *)a1 ^ (*(_DWORD *)a1 << 17)) >> 13));
    v9 = 69069 * *(_DWORD *)(a1 + 4) + 1234567;
    *(_DWORD *)a1 = v8;
    *(_DWORD *)(a1 + 4) = v9;
    v20 = (double)(v9 ^ v8) * 2.328306436538696e-10 * (v5 - v4) + v4;
    if ( v20 >= v4 )
    {
      if ( v20 > v5 )
        v20 = a4;
      v6 = a3;
      v7 = 2.328306436538696e-10;
    }
    else
    {
      v6 = a3;
      v7 = 2.328306436538696e-10;
      v20 = a3;
    }
  }
  else
  {
    v6 = a3;
    v7 = 2.328306436538696e-10;
    v20 = a3;
  }
  *(float *)a2 = v20;
  if ( v6 < v5 )
  {
    v10 = *(_DWORD *)a1 ^ (*(_DWORD *)a1 << 17) ^ ((unsigned int)(*(_DWORD *)a1 ^ (*(_DWORD *)a1 << 17)) >> 13) ^ 32 * (*(_DWORD *)a1 ^ (*(_DWORD *)a1 << 17) ^ ((unsigned int)(*(_DWORD *)a1 ^ (*(_DWORD *)a1 << 17)) >> 13));
    v11 = 69069 * *(_DWORD *)(a1 + 4) + 1234567;
    *(_DWORD *)a1 = v10;
    *(_DWORD *)(a1 + 4) = v11;
    v21 = (double)(v11 ^ v10) * v7 * (v5 - v6) + v6;
    if ( v21 >= v6 )
    {
      if ( v21 > v5 )
        v21 = a4;
    }
    else
    {
      v21 = v6;
    }
  }
  else
  {
    v21 = v6;
  }
  *(float *)(a2 + 4) = v21;
  if ( v6 >= v5 )
  {
    v5 = v6;
LABEL_17:
    result = a2;
    v13 = v5;
    *(float *)(a2 + 8) = v13;
    return result;
  }
  v14 = *(_DWORD *)a1 ^ (*(_DWORD *)a1 << 17) ^ ((unsigned int)(*(_DWORD *)a1 ^ (*(_DWORD *)a1 << 17)) >> 13) ^ 32 * (*(_DWORD *)a1 ^ (*(_DWORD *)a1 << 17) ^ ((unsigned int)(*(_DWORD *)a1 ^ (*(_DWORD *)a1 << 17)) >> 13));
  v15 = 69069 * *(_DWORD *)(a1 + 4) + 1234567;
  *(_DWORD *)a1 = v14;
  *(_DWORD *)(a1 + 4) = v15;
  v16 = v6;
  v17 = v7 * (double)(v15 ^ v14) * (v5 - v6) + v6;
  v18 = v16;
  v22 = v17;
  if ( v22 >= v16 )
  {
    if ( v5 < v22 )
      goto LABEL_17;
    result = a2;
    *(float *)(a2 + 8) = v22;
  }
  else
  {
    result = a2;
    v19 = v18;
    *(float *)(a2 + 8) = v19;
  }
  return result;
}

//----- (100352F0) --------------------------------------------------------
int __userpurge sub_100352F0@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<ebx>, _DWORD *a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // edx@1
  unsigned int v7; // eax@2
  FILE *v8; // eax@5
  char DstBuf; // [sp+10h] [bp-200h]@5

  v4 = a1;
  v5 = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  if ( !sub_10035A10(a1, a2, a3, a4) )
  {
    v7 = 2 * *(_DWORD *)(v5 + 4);
    if ( v7 < 4 )
      v7 = 4;
    sub_10035C50(v7, v6, v5);
    if ( !sub_10035A10(v4, v5, a3, a4) )
    {
      sprintf_s(
        &DstBuf,
        0x200u,
        "%s(%u): Failure: \"%s\"\n",
        "j:\\programme\\sdks\\crunch-104\\crnlib\\crn_hash_map.h",
        392,
        "\"insert() failed\"");
      OutputDebugStringA(&DstBuf);
      v8 = _iob_func();
      fputs(&DstBuf, v8 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
      if ( !byte_100AE9F8 )
        exit(1);
      RaiseException(0x100u, 0, 0, 0);
    }
  }
  return v4;
}
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (100353E0) --------------------------------------------------------
int __usercall sub_100353E0@<eax>(int result@<eax>, int a2@<edi>)
{
  int v2; // esi@1

  v2 = result;
  if ( result != a2 )
  {
    if ( *(_DWORD *)(result + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003C8F0(result);
      sub_100943C0(*(_DWORD *)(a2 + 4), 0, v2, 0, 8u, 0);
    }
    else if ( *(_DWORD *)(result + 4) )
    {
      *(_DWORD *)(result + 4) = 0;
    }
    memcpy(*(void **)v2, *(const void **)a2, 8 * *(_DWORD *)(a2 + 4));
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
    result = v2;
  }
  return result;
}

//----- (10035440) --------------------------------------------------------
void __thiscall sub_10035440(int this)
{
  int v1; // edi@1
  unsigned int v2; // eax@1
  unsigned int v3; // eax@4
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // edx@6
  int v7; // [sp+4h] [bp-18h]@4
  int v8; // [sp+8h] [bp-14h]@4
  int v9; // [sp+Ch] [bp-10h]@4
  int v10; // [sp+18h] [bp-4h]@4

  v1 = this;
  v2 = *(_DWORD *)(this + 8);
  if ( v2 >= 0x200 )
  {
    if ( v2 > 0x200 )
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v3 = *(_DWORD *)(this + 4);
      if ( v3 <= 0x200 )
        v3 = 512;
      sub_100943C0(v3, 0, (int)&v7, 0, 8u, 0);
      sub_100353E0((int)&v7, v1);
      v4 = *(_DWORD *)v1;
      v5 = v8;
      *(_DWORD *)v1 = v7;
      v6 = v9;
      *(_DWORD *)(v1 + 4) = v5;
      *(_DWORD *)(v1 + 8) = v6;
      v10 = -1;
      if ( v4 )
      {
        if ( v4 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(0x200u, 0, this, 0, 8u, 0);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10035540) --------------------------------------------------------
void __thiscall sub_10035540(int this)
{
  int v1; // edi@1
  unsigned int v2; // eax@1
  unsigned int v3; // eax@4
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // edx@6
  int v7; // [sp+4h] [bp-18h]@4
  int v8; // [sp+8h] [bp-14h]@4
  int v9; // [sp+Ch] [bp-10h]@4
  int v10; // [sp+18h] [bp-4h]@4

  v1 = this;
  v2 = *(_DWORD *)(this + 8);
  if ( v2 >= 0x200 )
  {
    if ( v2 > 0x200 )
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v3 = *(_DWORD *)(this + 4);
      if ( v3 <= 0x200 )
        v3 = 512;
      sub_100943C0(v3, 0, (int)&v7, 0, 0xCu, 0);
      sub_10035B30((int)&v7, v1);
      v4 = *(_DWORD *)v1;
      v5 = v8;
      *(_DWORD *)v1 = v7;
      v6 = v9;
      *(_DWORD *)(v1 + 4) = v5;
      *(_DWORD *)(v1 + 8) = v6;
      v10 = -1;
      if ( v4 )
      {
        if ( v4 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(0x200u, 0, this, 0, 0xCu, 0);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10035640) --------------------------------------------------------
void __thiscall sub_10035640(int this, unsigned int a2)
{
  unsigned int v2; // eax@1
  int v3; // edi@1
  unsigned int v4; // ecx@1
  int v5; // eax@6
  int v6; // ecx@6
  int v7; // edx@6
  int v8; // [sp+4h] [bp-18h]@4
  int v9; // [sp+8h] [bp-14h]@4
  int v10; // [sp+Ch] [bp-10h]@4
  int v11; // [sp+18h] [bp-4h]@4

  v2 = a2;
  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ( a2 <= v4 )
  {
    if ( a2 < v4 )
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      if ( *(_DWORD *)(v3 + 4) > a2 )
        v2 = *(_DWORD *)(v3 + 4);
      sub_100943C0(v2, 0, (int)&v8, 0, 2u, 0);
      sub_10035AD0((int)&v8, v3);
      v5 = *(_DWORD *)v3;
      v6 = v9;
      *(_DWORD *)v3 = v8;
      v7 = v10;
      *(_DWORD *)(v3 + 4) = v6;
      *(_DWORD *)(v3 + 8) = v7;
      v11 = -1;
      if ( v5 )
      {
        if ( v5 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(a2, 0, v3, 0, 2u, 0);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10035740) --------------------------------------------------------
void __thiscall sub_10035740(int this)
{
  int v1; // edi@1
  unsigned int v2; // eax@1
  unsigned int v3; // eax@4
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // edx@6
  int v7; // [sp+4h] [bp-18h]@4
  int v8; // [sp+8h] [bp-14h]@4
  int v9; // [sp+Ch] [bp-10h]@4
  int v10; // [sp+18h] [bp-4h]@4

  v1 = this;
  v2 = *(_DWORD *)(this + 8);
  if ( v2 >= 0x80 )
  {
    if ( v2 > 0x80 )
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v3 = *(_DWORD *)(this + 4);
      if ( v3 <= 0x80 )
        v3 = 128;
      sub_100943C0(v3, 0, (int)&v7, 0, 0xCu, 0);
      sub_10035B30((int)&v7, v1);
      v4 = *(_DWORD *)v1;
      v5 = v8;
      *(_DWORD *)v1 = v7;
      v6 = v9;
      *(_DWORD *)(v1 + 4) = v5;
      *(_DWORD *)(v1 + 8) = v6;
      v10 = -1;
      if ( v4 )
      {
        if ( v4 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(0x80u, 0, this, 0, 0xCu, 0);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10035840) --------------------------------------------------------
int __userpurge sub_10035840@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<ebx>, _BYTE *a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // edx@1
  unsigned int v7; // eax@2
  FILE *v8; // eax@5
  char DstBuf; // [sp+10h] [bp-200h]@5

  v4 = a1;
  v5 = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  if ( !sub_10035B90(a1, a2, a3, a4) )
  {
    v7 = 2 * *(_DWORD *)(v5 + 4);
    if ( v7 < 4 )
      v7 = 4;
    sub_10035C50(v7, v6, v5);
    if ( !sub_10035B90(v4, v5, a3, a4) )
    {
      sprintf_s(
        &DstBuf,
        0x200u,
        "%s(%u): Failure: \"%s\"\n",
        "j:\\programme\\sdks\\crunch-104\\crnlib\\crn_hash_map.h",
        392,
        "\"insert() failed\"");
      OutputDebugStringA(&DstBuf);
      v8 = _iob_func();
      fputs(&DstBuf, v8 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
      if ( !byte_100AE9F8 )
        exit(1);
      RaiseException(0x100u, 0, 0, 0);
    }
  }
  return v4;
}
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (10035930) --------------------------------------------------------
void __usercall sub_10035930(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int v2; // ecx@1
  int v3; // edx@6
  int v4; // eax@6
  int v5; // edx@6
  _DWORD *v6; // ecx@7

  v2 = *(_DWORD *)(a1 + 4);
  if ( a2 != v2 )
  {
    if ( a2 >= v2 )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_10035DA0, a1, a2 == v2 + 1, 0x28u, 0);
      v3 = *(_DWORD *)(a1 + 4);
      v4 = *(_DWORD *)a1 + 40 * v3;
      v5 = v4 + 40 * (a2 - v3);
      if ( v4 != v5 )
      {
        v6 = (_DWORD *)(v4 + 32);
        do
        {
          if ( v4 )
          {
            *(v6 - 5) = 0;
            *(v6 - 2) = 0;
            *(v6 - 1) = 0;
            *v6 = 0;
          }
          v4 += 40;
          v6 += 10;
        }
        while ( v4 != v5 );
      }
      *(_DWORD *)(a1 + 4) = a2;
    }
    else
    {
      sub_10036230(*(_DWORD *)a1 + 40 * a2, v2 - a2);
      *(_DWORD *)(a1 + 4) = a2;
    }
  }
}
// 10035DA0: using guessed type int sub_10035DA0();

//----- (100359B0) --------------------------------------------------------
unsigned int __usercall sub_100359B0@<eax>(int *a1@<eax>, int a2@<edx>)
{
  int v2; // edi@2
  unsigned int result; // eax@2
  int v4; // ecx@2
  unsigned int v5; // ebx@4

  if ( *(_DWORD *)(a2 + 20) )
  {
    v2 = *a1;
    result = (unsigned int)(-1640531527 * *a1) >> *(_DWORD *)(a2 + 12);
    v4 = *(_DWORD *)a2 + 12 * result;
    if ( *(_BYTE *)(v4 + 8) )
    {
      if ( *(_DWORD *)v4 == v2 )
        return result;
      v5 = result;
      while ( 1 )
      {
        if ( result )
        {
          --result;
          v4 -= 12;
        }
        else
        {
          result = *(_DWORD *)(a2 + 4) - 1;
          v4 = *(_DWORD *)a2 + 12 * result;
        }
        if ( result == v5 || !*(_BYTE *)(v4 + 8) )
          break;
        if ( *(_DWORD *)v4 == v2 )
          return result;
      }
    }
  }
  return *(_DWORD *)(a2 + 4);
}

//----- (10035A10) --------------------------------------------------------
char __userpurge sub_10035A10@<al>(int a1@<edi>, int a2@<esi>, int *a3, _DWORD *a4)
{
  char result; // al@2
  int v5; // ebx@3
  unsigned int v6; // edx@3
  int v7; // ecx@3

  if ( !*(_DWORD *)(a2 + 4) )
    return 0;
  v5 = *a3;
  v6 = (unsigned int)(-1640531527 * *a3) >> *(_DWORD *)(a2 + 12);
  result = 1;
  v7 = *(_DWORD *)a2 + 12 * v6;
  if ( *(_BYTE *)(v7 + 8) )
  {
    if ( *(_DWORD *)v7 != v5 )
    {
      while ( 1 )
      {
        if ( v6 )
        {
          --v6;
          v7 -= 12;
        }
        else
        {
          v6 = *(_DWORD *)(a2 + 4) - 1;
          v7 = *(_DWORD *)a2 + 12 * v6;
        }
        if ( (unsigned int)(-1640531527 * *a3) >> *(_DWORD *)(a2 + 12) == v6 )
          return 0;
        if ( !*(_BYTE *)(v7 + 8) )
        {
          result = 1;
          goto LABEL_14;
        }
        if ( *(_DWORD *)v7 == v5 )
        {
          *(_BYTE *)(a1 + 8) = 0;
          result = 1;
          *(_DWORD *)a1 = a2;
          *(_DWORD *)(a1 + 4) = v6;
          return result;
        }
      }
    }
    *(_BYTE *)(a1 + 8) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 4) = v6;
  }
  else
  {
LABEL_14:
    if ( *(_DWORD *)(a2 + 20) >= *(_DWORD *)(a2 + 24) )
      return 0;
    *(_DWORD *)v7 = v5;
    *(_DWORD *)(v7 + 4) = *a4;
    *(_BYTE *)(v7 + 8) = 1;
    ++*(_DWORD *)(a2 + 20);
    *(_BYTE *)(a1 + 8) = 1;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 4) = v6;
  }
  return result;
}

//----- (10035AD0) --------------------------------------------------------
int __usercall sub_10035AD0@<eax>(int result@<eax>, int a2@<edi>)
{
  int v2; // esi@1

  v2 = result;
  if ( result != a2 )
  {
    if ( *(_DWORD *)(result + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003C8F0(result);
      sub_100943C0(*(_DWORD *)(a2 + 4), 0, v2, 0, 2u, 0);
    }
    else if ( *(_DWORD *)(result + 4) )
    {
      *(_DWORD *)(result + 4) = 0;
    }
    memcpy(*(void **)v2, *(const void **)a2, 2 * *(_DWORD *)(a2 + 4));
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
    result = v2;
  }
  return result;
}

//----- (10035B30) --------------------------------------------------------
int __usercall sub_10035B30@<eax>(int result@<eax>, int a2@<edi>)
{
  int v2; // esi@1

  v2 = result;
  if ( result != a2 )
  {
    if ( *(_DWORD *)(result + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003C8F0(result);
      sub_100943C0(*(_DWORD *)(a2 + 4), 0, v2, 0, 0xCu, 0);
    }
    else if ( *(_DWORD *)(result + 4) )
    {
      *(_DWORD *)(result + 4) = 0;
    }
    memcpy(*(void **)v2, *(const void **)a2, 12 * *(_DWORD *)(a2 + 4));
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
    result = v2;
  }
  return result;
}

//----- (10035B90) --------------------------------------------------------
char __userpurge sub_10035B90@<al>(int a1@<edi>, int a2@<esi>, int *a3, _BYTE *a4)
{
  char result; // al@2
  int v5; // ebx@3
  unsigned int v6; // edx@3
  int v7; // ecx@3

  if ( !*(_DWORD *)(a2 + 4) )
    return 0;
  v5 = *a3;
  v6 = (unsigned int)(-1640531527 * *a3) >> *(_DWORD *)(a2 + 12);
  result = 1;
  v7 = *(_DWORD *)a2 + 12 * v6;
  if ( *(_BYTE *)(v7 + 8) )
  {
    if ( *(_DWORD *)v7 != v5 )
    {
      while ( 1 )
      {
        if ( v6 )
        {
          --v6;
          v7 -= 12;
        }
        else
        {
          v6 = *(_DWORD *)(a2 + 4) - 1;
          v7 = *(_DWORD *)a2 + 12 * v6;
        }
        if ( (unsigned int)(-1640531527 * *a3) >> *(_DWORD *)(a2 + 12) == v6 )
          return 0;
        if ( !*(_BYTE *)(v7 + 8) )
        {
          result = 1;
          goto LABEL_14;
        }
        if ( *(_DWORD *)v7 == v5 )
        {
          *(_BYTE *)(a1 + 8) = 0;
          result = 1;
          *(_DWORD *)a1 = a2;
          *(_DWORD *)(a1 + 4) = v6;
          return result;
        }
      }
    }
    *(_BYTE *)(a1 + 8) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 4) = v6;
  }
  else
  {
LABEL_14:
    if ( *(_DWORD *)(a2 + 20) >= *(_DWORD *)(a2 + 24) )
      return 0;
    *(_DWORD *)v7 = v5;
    *(_BYTE *)(v7 + 4) = *a4;
    *(_BYTE *)(v7 + 8) = 1;
    ++*(_DWORD *)(a2 + 20);
    *(_BYTE *)(a1 + 8) = 1;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 4) = v6;
  }
  return result;
}

//----- (10035C50) --------------------------------------------------------
void __fastcall sub_10035C50(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // esi@1
  int v4; // eax@3
  unsigned int i; // ecx@3
  int v6; // edi@5
  int v7; // ebx@5
  int v8; // eax@9
  int v9; // edx@9
  int v10; // ecx@9
  int v11; // eax@9
  int v12; // edx@9
  int v13; // eax@9
  int v14; // ecx@9
  int v15; // eax@9
  unsigned int v16; // edx@9
  int v17; // eax@9
  int v18; // [sp+8h] [bp-28h]@3
  int v19; // [sp+Ch] [bp-24h]@3
  int v20; // [sp+10h] [bp-20h]@3
  int v21; // [sp+14h] [bp-1Ch]@3
  int v22; // [sp+1Ch] [bp-14h]@3
  unsigned int j; // [sp+20h] [bp-10h]@3
  int v24; // [sp+2Ch] [bp-4h]@3

  v3 = a1;
  if ( a1 >= *(_DWORD *)(a3 + 20) && a1 != *(_DWORD *)(a3 + 4) )
  {
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v21 = 32;
    v22 = 0;
    j = 0;
    v24 = 0;
    sub_10035ED0((int)&v18, a1);
    v4 = 0;
    for ( i = v3; i > 1; ++v4 )
      i >>= 1;
    v6 = *(_DWORD *)a3;
    v7 = *(_DWORD *)a3 + 12 * *(_DWORD *)(a3 + 4);
    v21 = 32 - v4;
    for ( j = -1; v6 != v7; v6 += 12 )
    {
      if ( *(_BYTE *)(v6 + 8) )
      {
        sub_10035F30((int)&v18, v6);
        if ( v22 == *(_DWORD *)(a3 + 20) )
          break;
      }
    }
    j = (v3 + 1) >> 1;
    sub_1003C8F0(a3);
    v8 = *(_DWORD *)a3;
    v9 = v19;
    *(_DWORD *)a3 = v18;
    v10 = v20;
    *(_DWORD *)(a3 + 12) = 32;
    v18 = v8;
    v11 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a3 + 4) = v9;
    v12 = v21;
    v19 = v11;
    v13 = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(a3 + 8) = v10;
    v14 = v22;
    v20 = v13;
    v15 = *(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 12) = v12;
    v16 = j;
    v21 = v15;
    v17 = *(_DWORD *)(a3 + 20);
    *(_DWORD *)(a3 + 20) = v14;
    v22 = v17;
    j = *(_DWORD *)(a3 + 24);
    *(_DWORD *)(a3 + 24) = v16;
    v24 = -1;
    sub_1003F520((int)&v18);
  }
}

//----- (10035ED0) --------------------------------------------------------
unsigned int __usercall sub_10035ED0@<eax>(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int result; // eax@1
  int v3; // edx@5
  int i; // ecx@5

  result = *(_DWORD *)(a1 + 4);
  if ( a2 != result )
  {
    if ( a2 >= result )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_10035F90, a1, a2 == result + 1, 0xCu, 0);
      v3 = *(_DWORD *)(a1 + 4);
      result = *(_DWORD *)a1 + 12 * v3;
      for ( i = result + 12 * (a2 - v3); result != i; result += 12 )
      {
        if ( result )
          *(_BYTE *)(result + 8) = 0;
      }
    }
    *(_DWORD *)(a1 + 4) = a2;
  }
  return result;
}
// 10035F90: using guessed type int sub_10035F90();

//----- (10035F30) --------------------------------------------------------
unsigned int __usercall sub_10035F30@<eax>(int a1@<edx>, int a2@<edi>)
{
  unsigned int result; // eax@1
  int v3; // ecx@1

  result = (unsigned int)(-1640531527 * *(_DWORD *)a2) >> *(_DWORD *)(a1 + 12);
  v3 = *(_DWORD *)a1 + 12 * result;
  if ( *(_BYTE *)(v3 + 8) )
  {
    while ( 1 )
    {
      if ( result )
      {
        --result;
        v3 -= 12;
      }
      else
      {
        result = *(_DWORD *)(a1 + 4) - 1;
        v3 = *(_DWORD *)a1 + 12 * result;
      }
      if ( result == (unsigned int)(-1640531527 * *(_DWORD *)a2) >> *(_DWORD *)(a1 + 12) )
        break;
      if ( !*(_BYTE *)(v3 + 8) )
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    *(_DWORD *)v3 = *(_DWORD *)a2;
    *(_DWORD *)(v3 + 4) = *(_DWORD *)(a2 + 4);
    result = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(v3 + 8) = result;
    *(_BYTE *)(a2 + 8) = 0;
    ++*(_DWORD *)(a1 + 20);
  }
  return result;
}

//----- (10035FE0) --------------------------------------------------------
signed int __usercall sub_10035FE0@<eax>(int a1@<eax>, int a2@<edx>, int a3, float *a4)
{
  char v4; // bl@1
  signed int v5; // ecx@2
  signed int v6; // ebp@7
  double v7; // st7@12
  signed int v8; // esi@12
  signed int result; // eax@22
  double v10; // st7@30
  double v11; // st6@30
  signed int v12; // ebx@32
  float *v13; // ecx@37
  float *v14; // esi@37
  int v15; // ebp@37
  char *v16; // edx@37
  signed int v17; // [sp+10h] [bp-24h]@32
  float *v18; // [sp+14h] [bp-20h]@36
  float v19; // [sp+18h] [bp-1Ch]@39
  float v20; // [sp+1Ch] [bp-18h]@16
  float v21; // [sp+20h] [bp-14h]@26
  float v22; // [sp+24h] [bp-10h]@32
  float v23; // [sp+28h] [bp-Ch]@2
  float v24; // [sp+2Ch] [bp-8h]@7
  float v25; // [sp+30h] [bp-4h]@13

  v4 = 1;
  if ( *(float *)a2 <= (double)*(float *)a1 )
  {
    if ( *(float *)(a2 + 12) >= (double)*(float *)a1 )
    {
      v5 = 2;
    }
    else
    {
      v5 = 0;
      v23 = *(float *)(a2 + 12);
      v4 = 0;
    }
  }
  else
  {
    v5 = 1;
    v23 = *(float *)a2;
    v4 = 0;
  }
  if ( *(float *)(a2 + 4) <= (double)*(float *)(a1 + 4) )
  {
    if ( *(float *)(a2 + 16) >= (double)*(float *)(a1 + 4) )
    {
      v6 = 2;
    }
    else
    {
      v6 = 0;
      v24 = *(float *)(a2 + 16);
      v4 = 0;
    }
  }
  else
  {
    v6 = 1;
    v24 = *(float *)(a2 + 4);
    v4 = 0;
  }
  if ( *(float *)(a2 + 8) > (double)*(float *)(a1 + 8) )
  {
    v7 = *(float *)(a2 + 8);
    v8 = 1;
LABEL_13:
    v25 = v7;
    goto LABEL_14;
  }
  if ( *(float *)(a2 + 20) < (double)*(float *)(a1 + 8) )
  {
    v7 = *(float *)(a2 + 20);
    v8 = 0;
    goto LABEL_13;
  }
  v8 = 2;
  if ( v4 )
  {
    if ( a3 != a1 )
    {
      *(float *)a3 = *(float *)a1;
      *(float *)(a3 + 4) = *(float *)(a1 + 4);
      *(float *)(a3 + 8) = *(float *)(a1 + 8);
    }
    *a4 = 0.0;
    return 3;
  }
LABEL_14:
  if ( v5 == 2 || 0.0 == *(float *)(a1 + 12) )
    v20 = -1.0;
  else
    v20 = (v23 - *(float *)a1) / *(float *)(a1 + 12);
  if ( v6 == 2 || 0.0 == *(float *)(a1 + 16) )
    v21 = -1.0;
  else
    v21 = (v24 - *(float *)(a1 + 4)) / *(float *)(a1 + 16);
  if ( v8 == 2 || 0.0 == *(float *)(a1 + 20) )
  {
    v11 = -1.0;
    v10 = 0.0;
  }
  else
  {
    v10 = 0.0;
    v11 = (v25 - *(float *)(a1 + 8)) / *(float *)(a1 + 20);
  }
  v22 = v11;
  v12 = 0;
  v17 = 0;
  if ( v21 > (double)v20 )
    v17 = 1;
  if ( v22 > (double)*(&v20 + v17) )
    v17 = 2;
  v18 = &v20 + v17;
  if ( v10 > *(&v20 + v17) )
  {
LABEL_45:
    result = 0;
  }
  else
  {
    v13 = (float *)a3;
    v14 = (float *)(a2 + 12);
    v15 = a1 - a2;
    v16 = (char *)&v23 - a3;
    do
    {
      if ( v12 == v17 )
      {
        *v13 = *(float *)((char *)v13 + (_DWORD)v16);
      }
      else
      {
        v19 = *(float *)((char *)v14 + v15) * *v18 + *(float *)((char *)v13 + (_DWORD)&v16[a1 - (_DWORD)&v23]);
        *v13 = v19;
        if ( *(v14 - 3) > (double)v19 || *v14 < (double)v19 )
          goto LABEL_45;
      }
      ++v12;
      ++v14;
      ++v13;
    }
    while ( v12 < 3 );
    *a4 = *v18;
    result = 1;
  }
  return result;
}

//----- (10036230) --------------------------------------------------------
int __usercall sub_10036230@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // edi@1
  int *v3; // esi@2
  int v4; // eax@3

  v2 = result + 40 * a2;
  if ( result != v2 )
  {
    v3 = (int *)(result + 24);
    do
    {
      v4 = *v3;
      if ( *v3 )
      {
        if ( v4 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
      }
      v3 += 10;
      result = (int)(v3 - 6);
    }
    while ( v3 - 6 != (int *)v2 );
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10036280) --------------------------------------------------------
void *sub_10036280()
{
  void *v0; // esi@1
  FILE *v1; // eax@2
  char DstBuf; // [sp+4h] [bp-200h]@2

  v0 = (void *)sub_10092A80(64);
  if ( !v0 )
  {
    sprintf_s(
      &DstBuf,
      0x200u,
      "%s(%u): Assertion failed: \"%s\"\n",
      "j:\\programme\\sdks\\crunch-104\\crnlib\\crn_sparse_bit_array.h",
      163,
      "p");
    OutputDebugStringA(&DstBuf);
    v1 = _iob_func();
    fputs(&DstBuf, v1 + 2);
    if ( IsDebuggerPresent() )
      DebugBreak();
  }
  memset(v0, 0, 0x40u);
  return v0;
}

//----- (10036310) --------------------------------------------------------
void __thiscall sub_10036310(int this, unsigned int a2)
{
  unsigned int v2; // eax@1
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // eax@6
  int v6; // ecx@6
  int v7; // edx@6
  int v8; // [sp+4h] [bp-18h]@4
  int v9; // [sp+8h] [bp-14h]@4
  int v10; // [sp+Ch] [bp-10h]@4
  int v11; // [sp+18h] [bp-4h]@4

  v2 = a2;
  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ( a2 <= v4 )
  {
    if ( a2 < v4 )
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      if ( *(_DWORD *)(v3 + 4) > a2 )
        v2 = *(_DWORD *)(v3 + 4);
      sub_100943C0(v2, 0, (int)&v8, 0, 4u, 0);
      sub_10036410((int)&v8, v3);
      v5 = *(_DWORD *)v3;
      v6 = v9;
      *(_DWORD *)v3 = v8;
      v7 = v10;
      *(_DWORD *)(v3 + 4) = v6;
      *(_DWORD *)(v3 + 8) = v7;
      v11 = -1;
      if ( v5 )
      {
        if ( v5 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(a2, 0, v3, 0, 4u, 0);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10036410) --------------------------------------------------------
int __usercall sub_10036410@<eax>(int result@<eax>, int a2@<ebx>)
{
  int v2; // edi@1

  v2 = result;
  if ( result != a2 )
  {
    if ( *(_DWORD *)(result + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003C8F0(result);
      sub_100943C0(*(_DWORD *)(a2 + 4), 0, v2, 0, 4u, 0);
    }
    else
    {
      sub_100366C0(result, 0);
    }
    memcpy(*(void **)v2, *(const void **)a2, 4 * *(_DWORD *)(a2 + 4));
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
    result = v2;
  }
  return result;
}

//----- (10036480) --------------------------------------------------------
int __usercall sub_10036480@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // eax@1
  int result; // eax@6

  v2 = *(_BYTE *)(a1 + 2);
  v3 = *(_BYTE *)(a1 + 1);
  v4 = *(_BYTE *)a1;
  *(_BYTE *)(a2 + 3) = (7471 * v2 + 19595 * v4 + 38470 * v3 + 0x8000) >> 16;
  v5 = ((((v2 + 1) << 15) - 21709 * v3 - 11059 * v4) >> 16) + 123;
  if ( (unsigned int)v5 > 0xFF )
  {
    if ( v5 >= 0 )
    {
      if ( v5 > 255 )
        LOBYTE(v5) = -1;
    }
    else
    {
      LOBYTE(v5) = 0;
    }
  }
  *(_BYTE *)a2 = v5;
  result = ((((v4 + 1) << 15) - 27439 * v3 - 5329 * v2) >> 16) + 125;
  if ( (unsigned int)result <= 0xFF )
    goto LABEL_14;
  if ( result < 0 )
  {
    result = 0;
    *(_WORD *)(a2 + 1) = 0;
    return result;
  }
  if ( result <= 255 )
  {
LABEL_14:
    *(_BYTE *)(a2 + 2) = 0;
    *(_BYTE *)(a2 + 1) = result;
  }
  else
  {
    *(_WORD *)(a2 + 1) = 255;
  }
  return result;
}

//----- (10036540) --------------------------------------------------------
int __usercall sub_10036540@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // eax@1
  int v6; // edx@1
  int result; // eax@6
  int v8; // ecx@6
  int v9; // edx@11

  v2 = *(_BYTE *)a1;
  v3 = *(_BYTE *)(a1 + 1) - 125;
  v4 = *(_BYTE *)(a1 + 3);
  v5 = v4 + ((91881 * v3 + 0x8000) >> 16);
  v6 = v2 - 123;
  if ( (unsigned int)v5 > 0xFF )
  {
    if ( v5 >= 0 )
    {
      if ( v5 > 255 )
        LOBYTE(v5) = -1;
    }
    else
    {
      LOBYTE(v5) = 0;
    }
  }
  *(_BYTE *)a2 = v5;
  result = 22554 * v6;
  v8 = v4 + ((-46802 * v3 - 22554 * v6 + 0x8000) >> 16);
  if ( (unsigned int)v8 > 0xFF )
  {
    if ( v8 >= 0 )
    {
      if ( v8 > 255 )
        LOBYTE(v8) = -1;
    }
    else
    {
      LOBYTE(v8) = 0;
    }
  }
  v9 = v4 + ((116130 * v6 + 0x8000) >> 16);
  *(_BYTE *)(a2 + 1) = v8;
  if ( (unsigned int)v9 <= 0xFF )
  {
    *(_BYTE *)(a2 + 3) = -1;
  }
  else
  {
    if ( v9 < 0 )
    {
      *(_WORD *)(a2 + 2) = -256;
      return result;
    }
    *(_BYTE *)(a2 + 3) = -1;
    if ( v9 > 255 )
    {
      result = 255;
      *(_BYTE *)(a2 + 2) = -1;
      return result;
    }
  }
  *(_BYTE *)(a2 + 2) = v9;
  return result;
}

//----- (100365F0) --------------------------------------------------------
int __fastcall sub_100365F0(int a1, int a2, float a3, float a4)
{
  double v4; // st6@1
  double v5; // st7@2
  int result; // eax@11
  float v7; // [sp+0h] [bp-4h]@1
  float v8; // [sp+0h] [bp-4h]@5
  float v9; // [sp+0h] [bp-4h]@10
  float v10; // [sp+8h] [bp+4h]@6
  float v11; // [sp+8h] [bp+4h]@11
  float v12; // [sp+8h] [bp+4h]@14

  v7 = *(float *)a1;
  v4 = a3;
  if ( a3 <= (double)v7 )
  {
    if ( a4 >= (double)v7 )
    {
      v5 = a4;
      a3 = v7;
    }
    else
    {
      a3 = a4;
      v5 = a4;
    }
  }
  else
  {
    v5 = a4;
  }
  *(float *)a1 = a3;
  v8 = *(float *)(a1 + 4);
  if ( v8 >= v4 )
  {
    if ( v8 <= v5 )
      v10 = v8;
    else
      v10 = v5;
  }
  else
  {
    v10 = v4;
  }
  *(float *)(a1 + 4) = v10;
  v9 = *(float *)(a1 + 8);
  if ( v9 < v4 || (v4 = v9, v9 <= v5) )
  {
    result = a1;
    v11 = v4;
    *(float *)(a1 + 8) = v11;
  }
  else
  {
    result = a1;
    v12 = v5;
    *(float *)(a1 + 8) = v12;
  }
  return result;
}

//----- (100366C0) --------------------------------------------------------
void *__usercall sub_100366C0@<eax>(int a1@<edi>, unsigned int a2@<esi>)
{
  void *result; // eax@1

  result = *(void **)(a1 + 4);
  if ( (void *)a2 != result )
  {
    if ( a2 >= (unsigned int)result )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, 0, a1, a2 == (_DWORD)result + 1, 4u, 0);
      result = memset((void *)(*(_DWORD *)a1 + 4 * *(_DWORD *)(a1 + 4)), 0, 4 * (a2 - *(_DWORD *)(a1 + 4)));
    }
    *(_DWORD *)(a1 + 4) = a2;
  }
  return result;
}

//----- (10036710) --------------------------------------------------------
char __usercall sub_10036710@<al>(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int v2; // eax@1
  char result; // al@4

  v2 = *(_DWORD *)(a1 + 4);
  if ( a2 == v2 )
    return 1;
  if ( a2 < v2 )
  {
LABEL_6:
    *(_DWORD *)(a1 + 4) = a2;
    return 1;
  }
  if ( a2 <= *(_DWORD *)(a1 + 8) || (result = sub_100943C0(a2, 0, a1, a2 == v2 + 1, 4u, 1)) != 0 )
  {
    memset((void *)(*(_DWORD *)a1 + 4 * *(_DWORD *)(a1 + 4)), 0, 4 * (a2 - *(_DWORD *)(a1 + 4)));
    goto LABEL_6;
  }
  return result;
}

//----- (10036770) --------------------------------------------------------
int __cdecl sub_10036770(int *a1, int *a2, int *a3, int *a4, int *a5, float *a6, float *a7, int *a8, int *a9, int *a10, float *a11, float *a12)
{
  int v12; // esi@1
  int result; // eax@1

  v12 = sub_10092A80(80);
  result = 0;
  if ( v12 )
    result = sub_100670C0(*a3, *a2, *a1, v12, *a4, *a5, COERCE_INT(*a6), *a7, *a8, *a9, *a10, *a11, *a12, 0.0, 0.0);
  return result;
}

//----- (10036820) --------------------------------------------------------
unsigned int __thiscall sub_10036820(int this)
{
  unsigned int result; // eax@1

  result = 0;
  if ( *(_DWORD *)(this + 4) )
  {
    do
      *(_DWORD *)(*(_DWORD *)this + 4 * result++) = 0;
    while ( result < *(_DWORD *)(this + 4) );
  }
  return result;
}

//----- (10036840) --------------------------------------------------------
int __usercall sub_10036840@<eax>(int result@<eax>)
{
  _DWORD *v1; // ecx@1
  signed int v2; // esi@1

  *(float *)(result + 16) = 2.0;
  *(float *)(result + 20) = 2.0;
  *(_DWORD *)result = 3072;
  *(_DWORD *)(result + 4) = 3072;
  *(float *)(result + 24) = 3.0;
  *(_DWORD *)(result + 8) = 3072;
  *(_DWORD *)(result + 12) = 3072;
  *(_DWORD *)(result + 164) = 0;
  *(_DWORD *)(result + 168) = 0;
  *(_WORD *)(result + 172) = 257;
  *(_BYTE *)(result + 174) = 0;
  *(_DWORD *)(result + 176) = 0;
  *(_DWORD *)(result + 180) = 0;
  *(_DWORD *)(result + 28) = 3;
  *(_DWORD *)(result + 32) = 0;
  v1 = (_DWORD *)(result + 40);
  v2 = 16;
  do
  {
    *(v1 - 1) = 0;
    *v1 = 0;
    v1 += 2;
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (100368C0) --------------------------------------------------------
void *__thiscall sub_100368C0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_100A4FF4;
  if ( a2 & 1 )
    operator delete(this);
  return v2;
}
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100A4FF4: using guessed type int (__stdcall *off_100A4FF4)(char);

//----- (100368E0) --------------------------------------------------------
const char *sub_100368E0()
{
  return "CRN";
}

//----- (100368F0) --------------------------------------------------------
int __thiscall sub_100368F0(char *this)
{
  return (int)(this + 4260);
}

//----- (10036900) --------------------------------------------------------
void *__thiscall sub_10036900(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_10075740((int)this);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10036930) --------------------------------------------------------
void __stdcall sub_10036930(int a1)
{
  int v1; // eax@1
  int v2; // eax@5
  int v3; // eax@9

  v1 = *(_DWORD *)(a1 + 64);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
  v2 = *(_DWORD *)(a1 + 52);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
  }
  v3 = *(_DWORD *)(a1 + 40);
  if ( v3 )
  {
    if ( v3 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10036A10) --------------------------------------------------------
int __usercall sub_10036A10@<eax>(unsigned int a1@<edi>, int a2@<esi>)
{
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  if ( a1 )
  {
    sub_100943C0(a1, 0, a2, a1 == 1, 4u, 0);
    memset((void *)(*(_DWORD *)a2 + 4 * *(_DWORD *)(a2 + 4)), 0, 4 * (a1 - *(_DWORD *)(a2 + 4)));
    *(_DWORD *)(a2 + 4) = a1;
  }
  return a2;
}

//----- (10036A70) --------------------------------------------------------
void __thiscall sub_10036A70(int this, unsigned int a2)
{
  unsigned int v2; // eax@1
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // eax@6
  int v6; // ecx@6
  int v7; // edx@6
  int v8; // [sp+4h] [bp-18h]@4
  int v9; // [sp+8h] [bp-14h]@4
  int v10; // [sp+Ch] [bp-10h]@4
  int v11; // [sp+18h] [bp-4h]@4

  v2 = a2;
  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ( a2 <= v4 )
  {
    if ( a2 < v4 )
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      if ( *(_DWORD *)(v3 + 4) > a2 )
        v2 = *(_DWORD *)(v3 + 4);
      sub_100943C0(v2, 0, (int)&v8, 0, 0x104u, 0);
      sub_10036C90((int)&v8, v3);
      v5 = *(_DWORD *)v3;
      v6 = v9;
      *(_DWORD *)v3 = v8;
      v7 = v10;
      *(_DWORD *)(v3 + 4) = v6;
      *(_DWORD *)(v3 + 8) = v7;
      v11 = -1;
      if ( v5 )
      {
        if ( v5 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(a2, 0, v3, 0, 0x104u, 0);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10036B80) --------------------------------------------------------
char *__usercall sub_10036B80@<eax>(int a1@<edi>, unsigned int a2@<esi>)
{
  char *result; // eax@1

  result = *(char **)(a1 + 4);
  if ( (char *)a2 != result )
  {
    if ( a2 >= (unsigned int)result )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, 0, a1, a2 == (_DWORD)(result + 1), 0x104u, 0);
      result = sub_10036CF0((void *)(*(_DWORD *)a1 + 260 * *(_DWORD *)(a1 + 4)), a2 - *(_DWORD *)(a1 + 4));
    }
    *(_DWORD *)(a1 + 4) = a2;
  }
  return result;
}

//----- (10036BD0) --------------------------------------------------------
unsigned int __usercall sub_10036BD0@<eax>(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int result; // eax@1
  int v3; // ecx@5
  int i; // edx@5

  result = *(_DWORD *)(a1 + 4);
  if ( a2 != result )
  {
    if ( a2 >= result )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004AAB0, a1, a2 == result + 1, 8u, 0);
      v3 = *(_DWORD *)(a1 + 4);
      result = *(_DWORD *)a1 + 8 * v3;
      for ( i = result + 8 * (a2 - v3); result != i; result += 8 )
      {
        if ( result )
        {
          *(_DWORD *)result = 0;
          *(_DWORD *)(result + 4) = 0;
        }
      }
    }
    *(_DWORD *)(a1 + 4) = a2;
  }
  return result;
}

//----- (10036C30) --------------------------------------------------------
unsigned int __usercall sub_10036C30@<eax>(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int result; // eax@1
  int i; // ecx@5

  result = *(_DWORD *)(a1 + 4);
  if ( a2 != result )
  {
    if ( a2 >= result )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, 0, a1, a2 == result + 1, 0x10u, 0);
      result = *(_DWORD *)a1 + 16 * *(_DWORD *)(a1 + 4);
      for ( i = result + 16 * (a2 - *(_DWORD *)(a1 + 4)); result != i; result += 16 )
      {
        if ( result )
        {
          *(_DWORD *)result = 0;
          *(_DWORD *)(result + 4) = 0;
          *(_DWORD *)(result + 8) = 0;
          *(_DWORD *)(result + 12) = 0;
        }
      }
    }
    *(_DWORD *)(a1 + 4) = a2;
  }
  return result;
}

//----- (10036C90) --------------------------------------------------------
int __usercall sub_10036C90@<eax>(int result@<eax>, int a2@<ebx>)
{
  int v2; // edi@1

  v2 = result;
  if ( result != a2 )
  {
    if ( *(_DWORD *)(result + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003C8F0(result);
      sub_100943C0(*(_DWORD *)(a2 + 4), 0, v2, 0, 0x104u, 0);
    }
    else
    {
      sub_10036B80(result, 0);
    }
    memcpy(*(void **)v2, *(const void **)a2, 260 * *(_DWORD *)(a2 + 4));
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
    result = v2;
  }
  return result;
}

//----- (10036CF0) --------------------------------------------------------
char *__usercall sub_10036CF0@<eax>(void *a1@<ecx>, int a2@<eax>)
{
  char *result; // eax@1
  char *v3; // esi@1
  char *v4; // edi@1

  result = (char *)(260 * a2);
  v3 = (char *)a1;
  v4 = &result[(_DWORD)a1];
  if ( a1 != &result[(_DWORD)a1] )
  {
    do
    {
      if ( v3 )
      {
        result = (char *)memset(v3, 0, 0x104u);
        *((float *)v3 + 64) = 1.0;
      }
      v3 += 260;
    }
    while ( v3 != v4 );
  }
  return result;
}

//----- (10036D30) --------------------------------------------------------
void *sub_10036D30()
{
  return &unk_100A502C;
}

//----- (10036D40) --------------------------------------------------------
int __thiscall sub_10036D40(char *this)
{
  return (int)(this + 100);
}

//----- (10036D50) --------------------------------------------------------
void *__thiscall sub_10036D50(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_10072060((int)this);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10036D80) --------------------------------------------------------
unsigned int __usercall sub_10036D80@<eax>(int a1@<ebx>, int a2@<esi>)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edi@1
  unsigned int v4; // eax@7
  unsigned int result; // eax@9

  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 != v2 )
  {
    if ( v3 >= v2 )
    {
      if ( v3 > *(_DWORD *)(a2 + 8) )
        sub_100943C0(v3, 0, a2, v3 == v2 + 1, 4u, 0);
      memset((void *)(*(_DWORD *)a2 + 4 * *(_DWORD *)(a2 + 4)), 0, 4 * (v3 - *(_DWORD *)(a2 + 4)));
    }
    *(_DWORD *)(a2 + 4) = v3;
  }
  v4 = 0;
  if ( *(_DWORD *)(a1 + 4) )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)a2 + 4 * v4) = *(_DWORD *)(*(_DWORD *)a1 + 4 * v4);
      ++v4;
    }
    while ( v4 < *(_DWORD *)(a1 + 4) );
  }
  sub_1003E5E0(*(char **)a2, (unsigned int *)(*(_DWORD *)a2 + 4 * *(_DWORD *)(a2 + 4)), 4 * *(_DWORD *)(a2 + 4) >> 2);
  result = sub_1005B000(4 * *(_DWORD *)(a2 + 4), *(_DWORD *)a2);
  *(_DWORD *)(a2 + 12) = result;
  return result;
}

//----- (10036E20) --------------------------------------------------------
void __stdcall sub_10036E20(int a1)
{
  int v1; // eax@1
  int v2; // eax@5
  int v3; // eax@9
  int v4; // eax@13
  int v5; // ecx@17
  int v6; // eax@18
  int v7; // eax@22

  v1 = *(_DWORD *)(a1 + 76);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
  v2 = *(_DWORD *)(a1 + 64);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
  }
  v3 = *(_DWORD *)(a1 + 44);
  if ( v3 )
  {
    if ( v3 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
  }
  v4 = *(_DWORD *)(a1 + 24);
  if ( v4 )
  {
    if ( v4 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
  }
  v5 = *(_DWORD *)(a1 + 12);
  if ( v5 )
  {
    sub_1004CEA0(*(_DWORD *)(a1 + 16), v5);
    v6 = *(_DWORD *)(a1 + 12);
    if ( v6 )
    {
      if ( v6 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v6, 0, 0, 1, dword_100AE9F4);
    }
  }
  v7 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
  {
    if ( v7 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v7, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10036FD0) --------------------------------------------------------
void __thiscall sub_10036FD0(void *this)
{
  void *v1; // esi@1
  int v2; // eax@1
  int v3; // eax@5
  int v4; // eax@9
  int v5; // eax@13
  int v6; // ecx@17
  int v7; // eax@18
  int v8; // eax@22

  v1 = this;
  v2 = *((_DWORD *)this + 19);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
  }
  v3 = *((_DWORD *)v1 + 16);
  if ( v3 )
  {
    if ( v3 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
  }
  v4 = *((_DWORD *)v1 + 11);
  if ( v4 )
  {
    if ( v4 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
  }
  v5 = *((_DWORD *)v1 + 6);
  if ( v5 )
  {
    if ( v5 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
  }
  v6 = *((_DWORD *)v1 + 3);
  if ( v6 )
  {
    sub_1004CF40(*((_DWORD *)v1 + 4), v6);
    v7 = *((_DWORD *)v1 + 3);
    if ( v7 )
    {
      if ( v7 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v7, 0, 0, 1, dword_100AE9F4);
    }
  }
  v8 = *(_DWORD *)v1;
  if ( *(_DWORD *)v1 )
  {
    if ( v8 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v8, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10037150) --------------------------------------------------------
bool __usercall sub_10037150@<al>(int a1@<eax>, int a2@<edx>)
{
  int *v2; // esi@1
  int v3; // eax@1
  int v5; // edx@4
  int v6; // esi@4
  unsigned int v7; // ecx@4
  signed int v8; // eax@8

  v2 = (int *)a1;
  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 != *(_DWORD *)(a2 + 4) )
    return 0;
  if ( v3 )
  {
    v5 = *(_DWORD *)a2;
    v6 = *v2;
    v7 = 4 * v3;
    if ( (unsigned int)(4 * v3) < 4 )
    {
LABEL_7:
      if ( !v7 )
        return 1;
    }
    else
    {
      while ( *(_DWORD *)v6 == *(_DWORD *)v5 )
      {
        v7 -= 4;
        v5 += 4;
        v6 += 4;
        if ( v7 < 4 )
          goto LABEL_7;
      }
    }
    v8 = *(_BYTE *)v6 - *(_BYTE *)v5;
    if ( *(_BYTE *)v6 != *(_BYTE *)v5 )
      return ((v8 >> 31) | 1) == 0;
    if ( v7 > 1 )
    {
      v8 = *(_BYTE *)(v6 + 1) - *(_BYTE *)(v5 + 1);
      if ( *(_BYTE *)(v6 + 1) != *(_BYTE *)(v5 + 1) )
        return ((v8 >> 31) | 1) == 0;
      if ( v7 > 2 )
      {
        v8 = *(_BYTE *)(v6 + 2) - *(_BYTE *)(v5 + 2);
        if ( *(_BYTE *)(v6 + 2) == *(_BYTE *)(v5 + 2) )
        {
          if ( v7 > 3 )
          {
            v8 = *(_BYTE *)(v6 + 3) - *(_BYTE *)(v5 + 3);
            return ((v8 >> 31) | 1) == 0;
          }
          return 1;
        }
        return ((v8 >> 31) | 1) == 0;
      }
    }
    return 1;
  }
  return 1;
}

//----- (100371F0) --------------------------------------------------------
void __thiscall sub_100371F0(void *this)
{
  void *v1; // esi@1
  int *v2; // ecx@1
  int v3; // eax@2

  v1 = this;
  v2 = *(int **)this;
  if ( v2 )
  {
    sub_1003E4E0(*((_DWORD *)v1 + 1), v2);
    v3 = *(_DWORD *)v1;
    if ( *(_DWORD *)v1 )
    {
      if ( v3 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10037230) --------------------------------------------------------
void __usercall sub_10037230(int a1@<esi>)
{
  int *v1; // eax@2

  if ( *(_DWORD *)a1 )
  {
    sub_1003E4E0(*(_DWORD *)(a1 + 4), *(int **)a1);
    v1 = *(int **)a1;
    if ( *(_DWORD *)a1 )
    {
      if ( (unsigned __int8)v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10037280) --------------------------------------------------------
void __userpurge sub_10037280(int a1@<edi>, unsigned int a2@<esi>, char a3)
{
  unsigned int v3; // eax@1
  bool v4; // zf@6
  int v5; // edx@9
  int v6; // eax@9
  int i; // ecx@9
  char v8; // [sp+4h] [bp+4h]@6

  v3 = *(_DWORD *)(a1 + 4);
  if ( a2 != v3 )
  {
    if ( a2 >= v3 )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
      {
        if ( a2 == v3 + 1 || (v4 = a3 == 0, v8 = 0, !v4) )
          v8 = 1;
        sub_100943C0(a2, 0, a1, v8, 0xCu, 0);
      }
      v5 = *(_DWORD *)(a1 + 4);
      v6 = *(_DWORD *)a1 + 12 * v5;
      for ( i = v6 + 12 * (a2 - v5); v6 != i; v6 += 12 )
      {
        if ( v6 )
        {
          *(_DWORD *)v6 = 0;
          *(_DWORD *)(v6 + 4) = 0;
          *(_DWORD *)(v6 + 8) = 0;
        }
      }
      *(_DWORD *)(a1 + 4) = a2;
    }
    else
    {
      sub_1003E4E0(v3 - a2, (int *)(*(_DWORD *)a1 + 12 * a2));
      *(_DWORD *)(a1 + 4) = a2;
    }
  }
}

//----- (10037300) --------------------------------------------------------
void __usercall sub_10037300(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // eax@6
  int v3; // ecx@11
  int v4; // eax@12

  v1 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
  }
  v2 = *(_DWORD *)(a1 + 24);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
  }
  v3 = *(_DWORD *)(a1 + 12);
  if ( v3 )
  {
    sub_1004CEA0(*(_DWORD *)(a1 + 16), v3);
    v4 = *(_DWORD *)(a1 + 12);
    if ( v4 )
    {
      if ( v4 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
  }
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(float *)(a1 + 36) = 0.0;
  *(_BYTE *)(a1 + 60) = 0;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100373C0) --------------------------------------------------------
char __userpurge sub_100373C0@<al>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // ecx@1
  unsigned int v5; // edi@1
  unsigned int v6; // eax@3
  int v7; // ebx@3
  int v8; // esi@4
  unsigned int v9; // ecx@4
  unsigned int v10; // kr00_4@4
  double v11; // st7@4
  double v12; // st6@4
  float v13; // ST38_4@4
  float v14; // ST3C_4@4
  float v15; // ST40_4@4
  float v16; // ST44_4@4
  float v17; // ST48_4@4
  float v18; // ST4C_4@4
  int *v19; // ebx@7
  int v20; // ecx@7
  float v21; // ST24_4@7
  int v22; // eax@8
  unsigned int v23; // eax@13
  int v24; // edi@15
  bool v25; // zf@15
  int v26; // edi@15
  unsigned int v27; // eax@17
  int v28; // esi@17
  char v29; // bl@23
  unsigned int v30; // ST10_4@23
  unsigned int v31; // edi@23
  int v32; // ecx@24
  int v33; // eax@25
  int v34; // edx@25
  int v35; // esi@25
  int v36; // eax@33
  int *v37; // edi@33
  unsigned int v39; // ebx@43
  int v40; // esi@45
  unsigned int v41; // eax@46
  int v42; // edx@48
  int v43; // eax@48
  int v44; // eax@48
  int v45; // eax@51
  int v46; // eax@56
  int v47; // eax@61
  int *v48; // [sp+4h] [bp-78h]@23
  double v49; // [sp+Ch] [bp-70h]@2
  int *v50; // [sp+Ch] [bp-70h]@23
  float v51; // [sp+2Ch] [bp-50h]@2
  float v52; // [sp+30h] [bp-4Ch]@2
  float v53; // [sp+34h] [bp-48h]@2
  float v54; // [sp+38h] [bp-44h]@2
  float v55; // [sp+3Ch] [bp-40h]@2
  float v56; // [sp+40h] [bp-3Ch]@2
  unsigned __int64 v57; // [sp+44h] [bp-38h]@2
  float v58; // [sp+4Ch] [bp-30h]@7
  void *v59; // [sp+50h] [bp-2Ch]@2
  unsigned int v60; // [sp+54h] [bp-28h]@2
  unsigned int v61; // [sp+58h] [bp-24h]@2
  int v62; // [sp+5Ch] [bp-20h]@2
  int v63; // [sp+60h] [bp-1Ch]@2
  int v64; // [sp+64h] [bp-18h]@2
  char v65; // [sp+68h] [bp-14h]@2
  int v66; // [sp+70h] [bp-Ch]@1
  int (__thiscall *v67)(void *); // [sp+74h] [bp-8h]@1
  int v68; // [sp+78h] [bp-4h]@1
  float v69; // [sp+80h] [bp+4h]@4
  float v70; // [sp+80h] [bp+4h]@6
  float v71; // [sp+80h] [bp+4h]@6
  float v72; // [sp+80h] [bp+4h]@6
  float v73; // [sp+80h] [bp+4h]@6
  float v74; // [sp+80h] [bp+4h]@6
  float v75; // [sp+80h] [bp+4h]@6
  float v76; // [sp+80h] [bp+4h]@7
  float v77; // [sp+80h] [bp+4h]@7
  float v78; // [sp+80h] [bp+4h]@7
  float v79; // [sp+80h] [bp+4h]@7
  float v80; // [sp+80h] [bp+4h]@7
  float v81; // [sp+80h] [bp+4h]@7
  float v82; // [sp+80h] [bp+4h]@7
  unsigned int v83; // [sp+80h] [bp+4h]@23
  int v84; // [sp+80h] [bp+4h]@44

  v68 = -1;
  v67 = sub_10097D9D;
  v66 = a1;
  v3 = a2;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = 0;
  if ( v4 )
  {
    v51 = 0.0;
    v49 = 0.0;
    v52 = 0.0;
    v53 = 0.0;
    v54 = 0.0;
    v55 = 0.0;
    v56 = 0.0;
    *(_BYTE *)(a2 + 60) = 0;
    v57 = 0i64;
    v59 = 0;
    v60 = 0;
    v61 = 0;
    v62 = -1;
    v63 = -1;
    v64 = -1;
    v65 = 0;
    v68 = 0;
    sub_10036310((int)&v59, v4);
    if ( *(_DWORD *)(a2 + 4) > 0u )
    {
      v6 = v60;
      v7 = 0;
      do
      {
        v8 = v7 + *(_DWORD *)v3;
        v9 = *(_DWORD *)(v8 + 24);
        v69 = (double)*(unsigned int *)(v8 + 24);
        v10 = v57;
        LODWORD(v57) = v9 + v57;
        v11 = v69;
        v12 = v69 * *(float *)v8;
        v57 = __PAIR__(HIDWORD(v57), v9) + v10;
        v13 = v12;
        v14 = v69 * *(float *)(v8 + 4);
        v15 = *(float *)(v8 + 8) * v69;
        v16 = v69 * *(float *)(v8 + 12);
        v17 = v69 * *(float *)(v8 + 16);
        v18 = v69 * *(float *)(v8 + 20);
        v51 = v13 + v51;
        v52 = v52 + v14;
        v53 = v53 + v15;
        v54 = v54 + v16;
        v55 = v55 + v17;
        v56 = v56 + v18;
        if ( v6 >= v61 )
        {
          sub_100943C0(v6 + 1, 0, (int)&v59, 1, 4u, 0);
          v11 = v69;
          v6 = v60;
        }
        *((_DWORD *)v59 + v6++) = v5++;
        v7 += 28;
        v70 = *(float *)v8 * *(float *)v8;
        v60 = v6;
        v71 = *(float *)(v8 + 4) * *(float *)(v8 + 4) + v70;
        v72 = *(float *)(v8 + 8) * *(float *)(v8 + 8) + v71;
        v73 = *(float *)(v8 + 12) * *(float *)(v8 + 12) + v72;
        v74 = *(float *)(v8 + 16) * *(float *)(v8 + 16) + v73;
        v75 = *(float *)(v8 + 20) * *(float *)(v8 + 20) + v74;
        v49 = v11 * v75 + v49;
      }
      while ( v5 < *(_DWORD *)(v3 + 4) );
    }
    v76 = v51 * v51;
    v19 = (int *)(v3 + 12);
    v77 = v52 * v52 + v76;
    v78 = v53 * v53 + v77;
    v79 = v54 * v54 + v78;
    v80 = v55 * v55 + v79;
    v81 = v56 * v56 + v80;
    v20 = *(_DWORD *)(v3 + 12);
    v21 = (double)v57;
    v58 = v49 - v81 / v21;
    v82 = 1.0 / v21;
    v51 = v51 * v82;
    v52 = v52 * v82;
    v53 = v53 * v82;
    v54 = v54 * v82;
    v55 = v55 * v82;
    v56 = v82 * v56;
    if ( v20 )
    {
      sub_1004CEA0(*(_DWORD *)(v3 + 16), v20);
      v22 = *v19;
      if ( *v19 )
      {
        if ( v22 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v22, 0, 0, 1, dword_100AE9F4);
      }
      *v19 = 0;
      *(_DWORD *)(v3 + 16) = 0;
      *(_DWORD *)(v3 + 20) = 0;
    }
    sub_10039990(v3 + 12);
    v23 = *(_DWORD *)(v3 + 16);
    if ( v23 >= *(_DWORD *)(v3 + 20) )
      sub_100943C0(v23 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003CE50, v3 + 12, 1, 0x40u, 0);
    v24 = *(_DWORD *)(v3 + 16) << 6;
    v25 = *v19 + v24 == 0;
    v26 = *v19 + v24;
    LOBYTE(v68) = 1;
    if ( !v25 )
      sub_1003E110(v26, (int)&v51);
    LOBYTE(v68) = 0;
    ++*(_DWORD *)(v3 + 16);
    v27 = *(_DWORD *)(v3 + 48);
    v28 = v3 + 44;
    if ( v27 != 0x10000 )
    {
      if ( v27 <= 0x10000 )
      {
        if ( *(_DWORD *)(v3 + 52) < 0x10000u )
          sub_100943C0(0x10000u, 0, v3 + 44, v27 == 0xFFFF, 4u, 0);
        memset((void *)(*(_DWORD *)v28 + 4 * *(_DWORD *)(v3 + 48)), 0, 4 * (0x10000 - *(_DWORD *)(v3 + 48)));
      }
      *(_DWORD *)(v3 + 48) = 0x10000;
    }
    *(_DWORD *)(*(_DWORD *)v28 + 4) = 0;
    v29 = 1;
    v30 = *(_DWORD *)(v3 + 4) + 1;
    *(_DWORD *)(v3 + 56) = 1;
    *(_DWORD *)(v3 + 40) = 0;
    v48 = (int *)(v3 + 64);
    sub_10036310(v3 + 64, v30);
    v50 = (int *)(v3 + 76);
    sub_10036310(v3 + 76, *(_DWORD *)(v3 + 4) + 1);
    v83 = -1;
    v31 = 32867;
    while ( 1 )
    {
      v32 = *(_DWORD *)(v3 + 56);
      if ( !v32 )
      {
LABEL_33:
        v36 = *(_DWORD *)(v3 + 24);
        v37 = (int *)(v3 + 24);
        if ( v36 )
        {
          if ( v36 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v36, 0, 0, 1, dword_100AE9F4);
          *v37 = 0;
          *(_DWORD *)(v3 + 28) = 0;
          *(_DWORD *)(v3 + 32) = 0;
        }
        v39 = 0;
        *(float *)(v3 + 36) = 0.0;
        if ( *(_DWORD *)(v3 + 16) )
        {
          v84 = 0;
          do
          {
            v40 = v84 + *(_DWORD *)(v3 + 12);
            if ( *(_DWORD *)(v40 + 48) == -1 )
            {
              *(_DWORD *)(v40 + 56) = *(_DWORD *)(v3 + 28);
              v41 = *(_DWORD *)(v3 + 28);
              if ( v41 >= *(_DWORD *)(v3 + 32) )
                sub_100943C0(v41 + 1, 0, v3 + 24, 1, 0x18u, 0);
              v42 = 3 * *(_DWORD *)(v3 + 28);
              v43 = *v37;
              *(_DWORD *)(v43 + 8 * v42) = *(_DWORD *)v40;
              v44 = v43 + 8 * v42;
              *(_DWORD *)(v44 + 4) = *(_DWORD *)(v40 + 4);
              *(_DWORD *)(v44 + 8) = *(_DWORD *)(v40 + 8);
              *(_DWORD *)(v44 + 12) = *(_DWORD *)(v40 + 12);
              *(_DWORD *)(v44 + 16) = *(_DWORD *)(v40 + 16);
              *(_DWORD *)(v44 + 20) = *(_DWORD *)(v40 + 20);
              ++*(_DWORD *)(v3 + 28);
              *(float *)(v3 + 36) = *(float *)(v40 + 32) + *(float *)(v3 + 36);
            }
            v84 += 64;
            ++v39;
          }
          while ( v39 < *(_DWORD *)(v3 + 16) );
          v28 = v3 + 44;
        }
        v45 = *(_DWORD *)v28;
        if ( *(_DWORD *)v28 )
        {
          if ( v45 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v45, 0, 0, 1, dword_100AE9F4);
          *(_DWORD *)v28 = 0;
          *(_DWORD *)(v28 + 4) = 0;
          *(_DWORD *)(v28 + 8) = 0;
        }
        v46 = *v48;
        if ( *v48 )
        {
          if ( v46 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v46, 0, 0, 1, dword_100AE9F4);
          *v48 = 0;
          *(_DWORD *)(v3 + 68) = 0;
          *(_DWORD *)(v3 + 72) = 0;
        }
        v47 = *v50;
        if ( *v50 )
        {
          if ( v47 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v47, 0, 0, 1, dword_100AE9F4);
          *v50 = 0;
          *(_DWORD *)(v3 + 80) = 0;
          *(_DWORD *)(v3 + 84) = 0;
        }
        v68 = -1;
        if ( v59 )
        {
          if ( (unsigned __int8)v59 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v59, 0, 0, 1, dword_100AE9F4);
        }
        return 1;
      }
      v33 = *(_DWORD *)v28;
      v34 = *(_DWORD *)(*(_DWORD *)v28 + 4 * v32);
      v35 = *(_DWORD *)(*(_DWORD *)v28 + 4);
      *(_DWORD *)(v33 + 4) = v34;
      v25 = (*(_DWORD *)(v3 + 56))-- == 1;
      if ( !v25 )
        sub_10038DF0(v3);
      sub_10038EA0(v35, v3);
      ++v29;
      v31 += 100;
      if ( sub_1006E2D0 && !(v29 & 0x3F) && v31 / 0xFFFF != v83 )
      {
        if ( !sub_1006E2D0(v31 / 0xFFFF, a3) )
        {
          v68 = -1;
          if ( !v59 )
            return 0;
          if ( (unsigned __int8)v59 & 7 )
          {
            sub_100927E0((int)"crnlib_free: bad ptr");
            return 0;
          }
          off_100AD9F4(v59, 0, 0, 1, dword_100AE9F4);
          return 0;
        }
        v83 = v31 / 0xFFFF;
      }
      v28 = v3 + 44;
      if ( v31 >= 0x647F9B )
        goto LABEL_33;
    }
  }
  return 0;
}
// 1003CE50: using guessed type int sub_1003CE50();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10037AF0) --------------------------------------------------------
void __thiscall sub_10037AF0(void *this, int a2, signed int a3)
{
  int v3; // edi@1
  unsigned int v4; // ebx@1
  int v5; // esi@1
  int v6; // ebp@2
  int v7; // ebp@4
  unsigned int v8; // eax@7
  unsigned int v9; // esi@7
  int v10; // eax@12
  int v11; // ecx@12
  int v12; // eax@12
  int i; // ecx@12
  int v14; // ebp@17
  int v15; // esi@17
  void *v16; // eax@21
  void *v17; // [sp+14h] [bp-18h]@1
  unsigned int v18; // [sp+18h] [bp-14h]@1
  unsigned int v19; // [sp+1Ch] [bp-10h]@1
  int v20; // [sp+28h] [bp-4h]@1

  v3 = (int)this;
  sub_10037280((int)this, 0, 0);
  sub_10038CE0(v3, a3);
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  sub_10036310((int)&v17, 0x200u);
  v4 = v18;
  v5 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(a2 + 12) + (v5 << 6);
      v5 = *(_DWORD *)(v6 + 48);
      if ( v5 < 0 || *(_DWORD *)(v6 + 56) + 2 > a3 )
        break;
      v7 = *(_DWORD *)(v6 + 52);
      if ( v4 >= v19 )
      {
        sub_100943C0(v4 + 1, 0, (int)&v17, 1, 4u, 0);
        v4 = v18;
      }
      *((_DWORD *)v17 + v4++) = v7;
      v18 = v4;
    }
    v8 = *(_DWORD *)(v3 + 4);
    v9 = v8 + 1;
    if ( v8 + 1 != v8 )
    {
      if ( v8 + 1 >= v8 )
      {
        if ( v9 > *(_DWORD *)(v3 + 8) )
          sub_100943C0(v8 + 1, 0, v3, v9 == v8 + 1, 0xCu, 0);
        v10 = *(_DWORD *)(v3 + 4);
        v11 = v9 - v10;
        v12 = *(_DWORD *)v3 + 12 * v10;
        for ( i = v12 + 12 * v11; v12 != i; v12 += 12 )
        {
          if ( v12 )
          {
            *(_DWORD *)v12 = 0;
            *(_DWORD *)(v12 + 4) = 0;
            *(_DWORD *)(v12 + 8) = 0;
          }
        }
      }
      else
      {
        sub_1003E4E0(-1, (int *)(*(_DWORD *)v3 + 12 * v9));
      }
      *(_DWORD *)(v3 + 4) = v9;
    }
    v14 = v6 + 36;
    v15 = *(_DWORD *)v3 + 12 * *(_DWORD *)(v3 + 4) - 12;
    if ( v15 != v14 )
    {
      if ( *(_DWORD *)(v15 + 8) < *(_DWORD *)(v14 + 4) )
      {
        v16 = *(void **)v15;
        if ( *(_DWORD *)v15 )
        {
          if ( (unsigned __int8)v16 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v16, 0, 0, 1, dword_100AE9F4);
          *(_DWORD *)v15 = 0;
          *(_DWORD *)(v15 + 4) = 0;
          *(_DWORD *)(v15 + 8) = 0;
        }
        sub_100943C0(*(_DWORD *)(v14 + 4), 0, v15, 0, 4u, 0);
      }
      else if ( *(_DWORD *)(v15 + 4) )
      {
        *(_DWORD *)(v15 + 4) = 0;
      }
      memcpy(*(void **)v15, *(const void **)v14, 4 * *(_DWORD *)(v14 + 4));
      *(_DWORD *)(v15 + 4) = *(_DWORD *)(v14 + 4);
    }
    if ( !v4 )
      break;
    v5 = *((_DWORD *)v17 + v4-- - 1);
    v18 = v4;
  }
  v20 = -1;
  if ( v17 )
  {
    if ( (unsigned __int8)v17 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v17, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10037D10) --------------------------------------------------------
unsigned int __usercall sub_10037D10@<eax>(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int result; // eax@1
  int v3; // edx@5
  int i; // ecx@5

  result = *(_DWORD *)(a1 + 4);
  if ( a2 != result )
  {
    if ( a2 >= result )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003B7E0, a1, a2 == result + 1, 0x1Cu, 0);
      v3 = *(_DWORD *)(a1 + 4);
      result = *(_DWORD *)a1 + 28 * v3;
      for ( i = result + 28 * (a2 - v3); result != i; result += 28 )
      {
        if ( result )
          *(_DWORD *)(result + 24) = 0;
      }
    }
    *(_DWORD *)(a1 + 4) = a2;
  }
  return result;
}

//----- (10037D80) --------------------------------------------------------
void __usercall sub_10037D80(int *a1@<eax>)
{
  int v1; // eax@1

  v1 = *a1;
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10037DB0) --------------------------------------------------------
void __usercall sub_10037DB0(int a1@<eax>)
{
  int v1; // esi@1
  signed int v2; // edi@1
  int v3; // eax@2
  int v4; // eax@7
  int v5; // ecx@12
  int v6; // eax@13

  v1 = a1 + 32;
  v2 = 4;
  do
  {
    v3 = *(_DWORD *)(v1 - 16);
    if ( v3 )
    {
      if ( v3 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
      *(_DWORD *)(v1 - 16) = 0;
      *(_DWORD *)(v1 - 12) = 0;
      *(_DWORD *)(v1 - 8) = 0;
    }
    v4 = *(_DWORD *)(v1 + 8);
    if ( v4 )
    {
      if ( v4 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      *(_DWORD *)(v1 + 16) = 0;
    }
    v5 = *(_DWORD *)(v1 - 4);
    if ( v5 )
    {
      sub_1004CF40(*(_DWORD *)v1, v5);
      v6 = *(_DWORD *)(v1 - 4);
      if ( v6 )
      {
        if ( v6 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v6, 0, 0, 1, dword_100AE9F4);
      }
      *(_DWORD *)(v1 - 4) = 0;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    *(_DWORD *)(v1 + 24) = 0;
    *(float *)(v1 + 20) = 0.0;
    *(_DWORD *)(v1 + 40) = 0;
    *(_BYTE *)(v1 + 44) = 0;
    v1 += 88;
    --v2;
  }
  while ( v2 );
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10037E90) --------------------------------------------------------
bool __stdcall sub_10037E90(int a1, int a2, unsigned int a3, int a4, int a5, int a6)
{
  int v6; // edi@1
  unsigned int v7; // eax@2
  bool v8; // zf@4
  char *v9; // ebx@12
  int v10; // esi@14
  int v11; // ST14_4@14
  int v12; // eax@14
  struct _SINGLE_LIST_ENTRY *v13; // edi@14
  FILE *v14; // eax@16
  int v15; // ebx@18
  PSINGLE_LIST_ENTRY v16; // eax@19
  FILE *v17; // eax@22
  FILE *v18; // eax@29
  FILE *v19; // eax@38
  int v21; // ebx@44
  int v22; // eax@44
  int *v23; // esi@45
  int v24; // eax@47
  FILE *v25; // eax@49
  unsigned int v28; // eax@60
  unsigned int v29; // esi@60
  int *v30; // edi@62
  int v31; // eax@63
  FILE *v32; // eax@65
  int v33; // eax@72
  int v34; // ecx@72
  int v35; // eax@72
  int j; // ecx@72
  unsigned int v37; // esi@77
  int v38; // edi@78
  int v39; // edx@78
  int v40; // ecx@79
  int v41; // eax@79
  FILE *v42; // eax@83
  int v43; // esi@86
  int v44; // edi@88
  int v45; // eax@88
  unsigned int v46; // eax@88
  int v47; // edi@90
  int v48; // eax@92
  unsigned int v49; // [sp+Ch] [bp-77Ch]@4
  int *v50; // [sp+Ch] [bp-77Ch]@59
  int i; // [sp+10h] [bp-778h]@20
  int k; // [sp+14h] [bp-774h]@14
  unsigned int v53; // [sp+18h] [bp-770h]@12
  char *v54; // [sp+1Ch] [bp-76Ch]@12
  char *v55; // [sp+20h] [bp-768h]@12
  void *v56; // [sp+24h] [bp-764h]@2
  char v57; // [sp+30h] [bp-758h]@4
  char v58; // [sp+3Ch] [bp-74Ch]@4
  char v59; // [sp+48h] [bp-740h]@4
  int v60; // [sp+4Ch] [bp-73Ch]@4
  char v61; // [sp+54h] [bp-734h]@4
  int v62; // [sp+58h] [bp-730h]@6
  char v63; // [sp+60h] [bp-728h]@4
  int v64; // [sp+64h] [bp-724h]@8
  char v65; // [sp+6Ch] [bp-71Ch]@4
  int v66; // [sp+70h] [bp-718h]@10
  int v67; // [sp+78h] [bp-710h]@4
  int v68; // [sp+B8h] [bp-6D0h]@88
  int v69; // [sp+C0h] [bp-6C8h]@4
  char v70; // [sp+100h] [bp-688h]@4
  int v71; // [sp+10Ch] [bp-67Ch]@44
  int v72; // [sp+124h] [bp-664h]@44
  int v73; // [sp+13Ch] [bp-64Ch]@44
  int v74; // [sp+154h] [bp-634h]@44
  struct _SINGLE_LIST_ENTRY *v75; // [sp+174h] [bp-614h]@27
  CHAR v76; // [sp+178h] [bp-610h]@29
  CHAR OutputString; // [sp+378h] [bp-410h]@22
  char DstBuf; // [sp+578h] [bp-210h]@16
  int v79; // [sp+784h] [bp-4h]@2

  v6 = a1;
  *(_DWORD *)(a1 + 8) = GetCurrentThreadId();
  *(_DWORD *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 380) = 0;
  *(_DWORD *)(a1 + 372) = a5;
  *(_DWORD *)(a1 + 376) = a6;
  if ( a3 < 0x80 )
  {
    v43 = a1 + 16;
    sub_10039CE0(a1 + 16);
    sub_1003A580(a1 + 16, *(_DWORD *)(a2 + 4));
    i = 0;
    if ( *(_DWORD *)(a2 + 4) )
    {
      v53 = 0;
      do
      {
        v44 = v53 + *(_DWORD *)a2;
        v45 = sub_1003DDC0((int)&v69, v53 + *(_DWORD *)a2);
        sub_1003DDC0((int)&v67, v45);
        v68 = *(_DWORD *)(v44 + 64);
        v46 = *(_DWORD *)(a1 + 20);
        if ( v46 >= *(_DWORD *)(a1 + 24) )
          sub_100943C0(v46 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003DD80, v43, 1, 0x44u, 0);
        v47 = *(_DWORD *)(a1 + 16) + 68 * *(_DWORD *)(a1 + 20);
        if ( v47 )
        {
          sub_1003DDC0(*(_DWORD *)(a1 + 16) + 68 * *(_DWORD *)(a1 + 20), (int)&v67);
          *(_DWORD *)(v47 + 64) = v68;
        }
        v48 = i;
        ++*(_DWORD *)(a1 + 20);
        v53 += 68;
        i = v48 + 1;
      }
      while ( (unsigned int)(v48 + 1) < *(_DWORD *)(a2 + 4) );
      v6 = a1;
    }
    sub_10039DA0(v43, a3, (int (__cdecl *)(unsigned int, int))sub_10039AA0, v6);
    sub_1003A360((void *)a4, v43, *(_DWORD *)(a1 + 44));
    return *(_BYTE *)(a1 + 380) == 0;
  }
  sub_10036A10(*(_DWORD *)(a2 + 4), (int)&v56);
  v7 = 0;
  v79 = 0;
  if ( *(_DWORD *)(a2 + 4) )
  {
    do
    {
      *((_DWORD *)v56 + v7) = v7;
      ++v7;
    }
    while ( v7 < *(_DWORD *)(a2 + 4) );
  }
  `eh vector constructor iterator'(&v57, 0xCu, 6, (int)unknown_libname_3, sub_10038C00);
  LOBYTE(v79) = 1;
  sub_1003B960((int)&v56, &v69, (int)&v67, a2);
  sub_1003C100((int)&v58, (int)&v57, (float *)&v69, (int)&v67, (_DWORD *)a2, (int)&v56);
  sub_1003B960((int)&v57, &v67, (int)&v69, a2);
  sub_1003C100((int)&v61, (int)&v59, (float *)&v67, (int)&v69, (_DWORD *)a2, (int)&v57);
  sub_1003B960((int)&v58, &v67, (int)&v69, a2);
  sub_1003C100((int)&v65, (int)&v63, (float *)&v67, (int)&v69, (_DWORD *)a2, (int)&v58);
  `eh vector constructor iterator'(&v70, 0x18u, 4, (int)AssetTypeTemplateField::AssetTypeTemplateField, sub_10038C90);
  LOBYTE(v79) = 2;
  v8 = v60 == 0;
  *(_BYTE *)(a1 + 368) = 0;
  v49 = 0;
  if ( !v8 )
    v49 = 1;
  if ( v62 )
    ++v49;
  if ( v64 )
    ++v49;
  if ( v66 )
    ++v49;
  v9 = &v70;
  v53 = 0;
  v54 = &v70;
  v55 = &v59;
  do
  {
    if ( *((_DWORD *)v55 + 1) )
    {
      *((_DWORD *)v9 + 1) = v55;
      *(_DWORD *)v9 = a2;
      v10 = *(_DWORD *)a1;
      v11 = dword_100AE9F4;
      k = 16;
      *((_DWORD *)v9 + 5) = (a3 + (v49 >> 1)) / v49;
      v12 = off_100AD9F4(0, 16, &k, 1, v11);
      v13 = (struct _SINGLE_LIST_ENTRY *)v12;
      if ( v12 && (unsigned int)k >= 0x10 )
      {
        *(_DWORD *)v12 = &off_100A4F34;
        *(_DWORD *)(v12 + 4) = a1;
        *(_DWORD *)(v12 + 8) = sub_10039AE0;
        *(_DWORD *)(v12 + 12) = 1;
        InterlockedIncrement((LPLONG)(v10 + 80));
        v15 = *(_DWORD *)v10;
        if ( *(_BYTE *)(*(_DWORD *)v10 + 16) )
        {
          v16 = InterlockedPopEntrySList((PSLIST_HEADER)(v15 + 8));
          if ( v16 )
            goto LABEL_98;
        }
        i = 32;
        v16 = (PSINGLE_LIST_ENTRY)off_100AD9F4(0, 32, &i, 1, dword_100AE9F4);
        if ( !v16 || (unsigned int)i < 0x20 )
        {
          sprintf_s(
            &OutputString,
            0x200u,
            "%s(%u): Assertion failed: \"%s\"\n",
            "crn_mem.cpp",
            216,
            "crnlib_malloc: out of memory");
          OutputDebugStringA(&OutputString);
          v17 = _iob_func();
          fputs(&OutputString, v17 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
          v16 = 0;
        }
        if ( v16 )
        {
LABEL_98:
          if ( v16 != (PSINGLE_LIST_ENTRY)-8 )
          {
            v16[2].Next = (struct _SINGLE_LIST_ENTRY *)v53;
            v16[3].Next = 0;
            v16[4].Next = (struct _SINGLE_LIST_ENTRY *)v54;
            v16[5].Next = v13;
            v16[6].Next = (struct _SINGLE_LIST_ENTRY *)1;
            v16[7].Next = v75;
          }
          InterlockedPushEntrySList((PSLIST_HEADER)v15, v16);
          if ( !ReleaseSemaphore(*(HANDLE *)(v10 + 72), 1, 0) )
          {
            sprintf_s(
              &v76,
              0x200u,
              "%s(%u): Failure: \"%s\"\n",
              "crn_threading_win32.cpp",
              198,
              "\"semaphore: ReleaseSemaphore() failed\"");
            OutputDebugStringA(&v76);
            v18 = _iob_func();
            fputs(&v76, v18 + 2);
            if ( IsDebuggerPresent() )
              DebugBreak();
            if ( !byte_100AE9F8 )
              exit(1);
            RaiseException(0x100u, 0, 0, 0);
          }
        }
        else
        {
          InterlockedIncrement((LPLONG)(v10 + 84));
        }
        v9 = v54;
      }
      else
      {
        sprintf_s(
          &DstBuf,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_malloc: out of memory");
        OutputDebugStringA(&DstBuf);
        v14 = _iob_func();
        fputs(&DstBuf, v14 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
    }
    v55 += 12;
    v9 += 24;
    ++v53;
    v54 = v9;
  }
  while ( v53 < 4 );
  sub_10091500(*(_DWORD *)a1);
  if ( !*(_BYTE *)(a1 + 380) )
  {
    v21 = a4;
    sub_10038CE0(a4, v74 + v73 + v71 + v72);
    v22 = *(_DWORD *)(a4 + 4);
    if ( v22 )
    {
      v23 = *(int **)a4;
      if ( v22 )
      {
        for ( i = (int)&v23[3 * v22]; v23 != (int *)i; v23 += 3 )
        {
          v24 = *v23;
          if ( *v23 )
          {
            if ( v24 & 7 )
            {
              sprintf_s(&v76, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
              OutputDebugStringA(&v76);
              v25 = _iob_func();
              fputs(&v76, v25 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v24, 0, 0, 1, dword_100AE9F4);
            }
          }
        }
      }
      *(_DWORD *)(a4 + 4) = 0;
    }
    v50 = &v71;
    i = 4;
    do
    {
      v28 = *(_DWORD *)(v21 + 4);
      v29 = v28 + *v50;
      v54 = *(char **)(v21 + 4);
      if ( v29 != v28 )
      {
        if ( v29 >= v28 )
        {
          if ( v29 > *(_DWORD *)(v21 + 8) )
          {
            LOBYTE(v53) = v29 == v28 + 1;
            sub_100943C0(v29, 0, v21, v29 == v28 + 1, 0xCu, 0);
          }
          v33 = *(_DWORD *)(v21 + 4);
          v34 = v29 - v33;
          v35 = *(_DWORD *)v21 + 12 * v33;
          for ( j = v35 + 12 * v34; v35 != j; v35 += 12 )
          {
            if ( v35 )
            {
              *(_DWORD *)v35 = 0;
              *(_DWORD *)(v35 + 4) = 0;
              *(_DWORD *)(v35 + 8) = 0;
            }
          }
        }
        else
        {
          v30 = (int *)(*(_DWORD *)v21 + 12 * v29);
          for ( k = (int)&v30[3 * (v28 - v29)]; v30 != (int *)k; v30 += 3 )
          {
            v31 = *v30;
            if ( *v30 )
            {
              if ( v31 & 7 )
              {
                sprintf_s(
                  &OutputString,
                  0x200u,
                  "%s(%u): Assertion failed: \"%s\"\n",
                  "crn_mem.cpp",
                  216,
                  "crnlib_free: bad ptr");
                OutputDebugStringA(&OutputString);
                v32 = _iob_func();
                fputs(&OutputString, v32 + 2);
                if ( IsDebuggerPresent() )
                  DebugBreak();
              }
              else
              {
                off_100AD9F4(v31, 0, 0, 1, dword_100AE9F4);
              }
            }
          }
        }
        *(_DWORD *)(v21 + 4) = v29;
      }
      v37 = 0;
      if ( *v50 )
      {
        v38 = 0;
        v39 = 12 * (_DWORD)v54;
        do
        {
          v40 = v39 + *(_DWORD *)v21;
          v41 = v38 + *(v50 - 1);
          k = *(_DWORD *)(*(_DWORD *)v21 + v39);
          *(_DWORD *)v40 = *(_DWORD *)v41;
          *(_DWORD *)v41 = k;
          k = *(_DWORD *)(v40 + 4);
          *(_DWORD *)(v40 + 4) = *(_DWORD *)(v41 + 4);
          *(_DWORD *)(v41 + 4) = k;
          k = *(_DWORD *)(v40 + 8);
          *(_DWORD *)(v40 + 8) = *(_DWORD *)(v41 + 8);
          v21 = a4;
          *(_DWORD *)(v41 + 8) = k;
          ++v37;
          v38 += 12;
          v39 += 12;
        }
        while ( v37 < *v50 );
      }
      v50 += 6;
      --i;
    }
    while ( i );
    LOBYTE(v79) = 1;
    `eh vector destructor iterator'(&v70, 0x18u, 4, sub_10038C90);
    LOBYTE(v79) = 0;
    `eh vector destructor iterator'(&v57, 0xCu, 6, sub_10038C00);
    v79 = -1;
    if ( v56 )
    {
      if ( (unsigned __int8)v56 & 7 )
      {
        sprintf_s(&v76, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&v76);
        v42 = _iob_func();
        fputs(&v76, v42 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v56, 0, 0, 1, dword_100AE9F4);
      }
    }
    return *(_BYTE *)(a1 + 380) == 0;
  }
  LOBYTE(v79) = 1;
  `eh vector destructor iterator'(&v70, 0x18u, 4, sub_10038C90);
  LOBYTE(v79) = 0;
  `eh vector destructor iterator'(&v57, 0xCu, 6, sub_10038C00);
  v79 = -1;
  if ( v56 )
  {
    if ( (unsigned __int8)v56 & 7 )
    {
      sprintf_s(&v76, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&v76);
      v19 = _iob_func();
      fputs(&v76, v19 + 2);
      if ( IsDebuggerPresent() )
      {
        DebugBreak();
        return 0;
      }
    }
    else
    {
      off_100AD9F4(v56, 0, 0, 1, dword_100AE9F4);
    }
  }
  return 0;
}
// 10039AA0: using guessed type int __cdecl sub_10039AA0(int, int);
// 1003F6D0: using guessed type int unknown_libname_3();
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (100388E0) --------------------------------------------------------
void __stdcall sub_100388E0(int a1)
{
  int v1; // eax@2

  sub_10038970(a1);
  if ( *(_DWORD *)a1 )
  {
    sub_1003E530(*(_DWORD *)(a1 + 4), *(_DWORD *)a1);
    v1 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 )
    {
      if ( v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10038970) --------------------------------------------------------
int __usercall sub_10038970@<eax>(int a1@<edi>)
{
  int result; // eax@1
  int v2; // ebx@2
  int v3; // esi@2
  int v4; // ebp@2
  int v5; // eax@4
  int v6; // eax@10

  result = *(_DWORD *)(a1 + 4);
  if ( result )
  {
    v2 = *(_DWORD *)(a1 + 20);
    v3 = *(_DWORD *)a1;
    v4 = *(_DWORD *)a1 + 24 * result;
    if ( *(_DWORD *)a1 != v4 )
    {
      do
      {
        if ( *(_BYTE *)(v3 + 20) )
        {
          v5 = *(_DWORD *)v3;
          if ( *(_DWORD *)v3 )
          {
            if ( v5 & 7 )
              sub_100927E0((int)"crnlib_free: bad ptr");
            else
              off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
          }
          if ( !--v2 )
            break;
        }
        v3 += 24;
      }
      while ( v3 != v4 );
    }
    v6 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 )
    {
      if ( v6 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v6, 0, 0, 1, dword_100AE9F4);
      *(_DWORD *)a1 = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 8) = 0;
    }
    result = 0;
    *(_DWORD *)(a1 + 12) = 32;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 24) = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10038A20) --------------------------------------------------------
int __userpurge sub_10038A20@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, _DWORD *a4)
{
  int v4; // edx@1
  unsigned int v5; // eax@2
  FILE *v6; // eax@5
  char DstBuf; // [sp+8h] [bp-200h]@5

  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_BYTE *)(a3 + 8) = 0;
  if ( !sub_1003A730(a1, a2, a3, a4) )
  {
    v5 = 2 * *(_DWORD *)(a2 + 4);
    if ( v5 < 4 )
      v5 = 4;
    sub_1003CB20(v5, v4, a2);
    if ( !sub_1003A730(a1, a2, a3, a4) )
    {
      sprintf_s(
        &DstBuf,
        0x200u,
        "%s(%u): Failure: \"%s\"\n",
        "j:\\programme\\sdks\\crunch-104\\crnlib\\crn_hash_map.h",
        392,
        "\"insert() failed\"");
      OutputDebugStringA(&DstBuf);
      v6 = _iob_func();
      fputs(&DstBuf, v6 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
      if ( !byte_100AE9F8 )
        exit(1);
      RaiseException(0x100u, 0, 0, 0);
    }
  }
  return a3;
}
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (10038B00) --------------------------------------------------------
void __thiscall sub_10038B00(int this, unsigned int a2)
{
  unsigned int v2; // eax@1
  int v3; // edi@1
  unsigned int v4; // ecx@1
  int v5; // eax@6
  int v6; // ecx@6
  int v7; // edx@6
  int v8; // [sp+4h] [bp-18h]@4
  int v9; // [sp+8h] [bp-14h]@4
  int v10; // [sp+Ch] [bp-10h]@4
  int v11; // [sp+18h] [bp-4h]@4

  v2 = a2;
  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ( a2 <= v4 )
  {
    if ( a2 < v4 )
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      if ( *(_DWORD *)(v3 + 4) > a2 )
        v2 = *(_DWORD *)(v3 + 4);
      sub_100943C0(v2, 0, (int)&v8, 0, 4u, 0);
      sub_100342E0((int)&v8, v3);
      v5 = *(_DWORD *)v3;
      v6 = v9;
      *(_DWORD *)v3 = v8;
      v7 = v10;
      *(_DWORD *)(v3 + 4) = v6;
      *(_DWORD *)(v3 + 8) = v7;
      v11 = -1;
      if ( v5 )
      {
        if ( v5 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(a2, 0, v3, 0, 4u, 0);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10038C00) --------------------------------------------------------
void __thiscall sub_10038C00(void *this)
{
  int v1; // eax@1

  v1 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10038C30) --------------------------------------------------------
int __usercall sub_10038C30@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  int v3; // edx@2
  int v4; // ecx@2
  int v5; // esi@2
  signed int v6; // edi@2

  v2 = a2;
  if ( result != a2 )
  {
    v3 = a2 + 12;
    v4 = result + 4;
    v5 = v2 - result;
    v6 = 2;
    do
    {
      v4 += 32;
      *(float *)(v4 - 36) = *(float *)(v3 - 12);
      v3 += 32;
      --v6;
      *(float *)(v4 - 32) = *(float *)(v5 + v4 - 32);
      *(float *)(v4 - 28) = *(float *)(v3 - 36);
      *(float *)(v4 - 24) = *(float *)(v3 - 32);
      *(float *)(v4 - 20) = *(float *)(v3 - 28);
      *(float *)(v4 - 16) = *(float *)(v3 - 24);
      *(float *)(v4 - 12) = *(float *)(v3 - 20);
      *(float *)(v4 - 8) = *(float *)(v3 - 16);
    }
    while ( v6 );
  }
  return result;
}

//----- (10038C90) --------------------------------------------------------
void __thiscall sub_10038C90(void *this)
{
  void *v1; // esi@1
  int *v2; // ecx@1
  int v3; // eax@2

  v1 = this;
  v2 = (int *)*((_DWORD *)this + 2);
  if ( v2 )
  {
    sub_1003E4E0(*((_DWORD *)v1 + 3), v2);
    v3 = *((_DWORD *)v1 + 2);
    if ( v3 )
    {
      if ( v3 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10038CE0) --------------------------------------------------------
void __userpurge sub_10038CE0(int a1@<esi>, unsigned int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // ecx@1
  int *v4; // ebx@6
  int v5; // ecx@6
  int v6; // edx@6
  int v7; // eax@6
  int v8; // [sp+0h] [bp-18h]@4
  int v9; // [sp+4h] [bp-14h]@4
  int v10; // [sp+8h] [bp-10h]@4
  int v11; // [sp+14h] [bp-4h]@4

  v2 = a2;
  v3 = *(_DWORD *)(a1 + 8);
  if ( a2 <= v3 )
  {
    if ( a2 < v3 )
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      if ( *(_DWORD *)(a1 + 4) > a2 )
        v2 = *(_DWORD *)(a1 + 4);
      sub_100943C0(v2, 0, (int)&v8, 0, 0xCu, 0);
      sub_1003A860((int)&v8, a1);
      v4 = *(int **)a1;
      v5 = v9;
      v6 = v10;
      *(_DWORD *)a1 = v8;
      v7 = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a1 + 4) = v5;
      *(_DWORD *)(a1 + 8) = v6;
      v11 = -1;
      if ( v4 )
      {
        sub_1003E4E0(v7, v4);
        if ( (unsigned __int8)v4 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(a2, 0, a1, 0, 0xCu, 0);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10038DF0) --------------------------------------------------------
void __thiscall sub_10038DF0(int this)
{
  int v1; // ebx@1
  unsigned int v2; // eax@1
  signed int v3; // esi@1
  unsigned int v4; // edx@1
  bool v5; // cf@2
  unsigned int v6; // eax@7
  float v7; // [sp+8h] [bp-4h]@1

  v1 = *(_DWORD *)(*(_DWORD *)(this + 44) + 4);
  v2 = *(_DWORD *)(this + 56);
  v7 = *(float *)((*(_DWORD *)(*(_DWORD *)(this + 44) + 4) << 6) + *(_DWORD *)(this + 12) + 32);
  v3 = 1;
  v4 = 2;
  if ( v2 < 2 )
  {
    *(_DWORD *)(*(_DWORD *)(this + 44) + 4) = v1;
  }
  else
  {
    v5 = v2 > 2;
    while ( 1 )
    {
      if ( v5
        && *(float *)((*(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v4 + 4) << 6) + *(_DWORD *)(this + 12) + 32) > (double)*(float *)(*(_DWORD *)(this + 12) + (*(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v4) << 6) + 32) )
      {
        ++v4;
      }
      if ( *(float *)((*(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v4) << 6) + *(_DWORD *)(this + 12) + 32) < (double)v7 )
        break;
      *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v3) = *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v4);
      v6 = *(_DWORD *)(this + 56);
      v3 = v4;
      v4 *= 2;
      v5 = v4 < v6;
      if ( v4 > v6 )
      {
        *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v3) = v1;
        return;
      }
    }
    *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v3) = v1;
  }
}

//----- (10038EA0) --------------------------------------------------------
void __userpurge sub_10038EA0(int a1@<eax>, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  char v4; // al@5
  int v5; // ecx@5
  _DWORD *v6; // esi@6
  _DWORD *v7; // ebx@6
  unsigned int v8; // ecx@7
  unsigned int v9; // ecx@11
  _DWORD *v10; // eax@18
  int v11; // edx@18
  int v12; // eax@18
  unsigned int v13; // ebp@18
  int v14; // edi@18
  float v15; // ST24_4@18
  unsigned int v16; // eax@19
  float v17; // ST2C_4@21
  double v18; // st7@21
  float v19; // ST2C_4@21
  float v20; // ST24_4@21
  float v21; // ST24_4@21
  float v22; // ST24_4@21
  float v23; // ST24_4@21
  float v24; // ST2C_4@21
  unsigned int v25; // eax@22
  float v26; // ST2C_4@24
  double v27; // st7@24
  float v28; // ST2C_4@24
  float v29; // ST24_4@24
  float v30; // ST24_4@24
  float v31; // ST24_4@24
  float v32; // ST24_4@24
  float v33; // ST2C_4@24
  float v34; // ST28_4@28
  float v35; // ST24_4@28
  float v36; // ST24_4@28
  float v37; // ST24_4@28
  float v38; // ST24_4@28
  float v39; // ST28_4@28
  float v40; // ST24_4@28
  float v41; // ST28_4@28
  float v42; // ST28_4@28
  float v43; // ST28_4@28
  float v44; // ST28_4@28
  float v45; // ST28_4@28
  float v46; // ST28_4@28
  float v47; // ST30_4@28
  double v48; // st5@28
  float v49; // ST30_4@28
  float v50; // ST50_4@28
  float v51; // ST54_4@28
  float v52; // ST58_4@28
  float v53; // ST5C_4@28
  float v54; // ST60_4@28
  float v55; // ST64_4@28
  float v56; // ST30_4@28
  float v57; // ST38_4@28
  float v58; // ST3C_4@28
  float v59; // ST40_4@28
  float v60; // ST44_4@28
  float v61; // ST48_4@28
  float v62; // ST4C_4@28
  int v63; // esi@36
  unsigned int v64; // ecx@36
  int *v65; // ebx@36
  unsigned int v66; // edi@36
  int v67; // ebx@43
  int v68; // eax@43
  int v69; // edi@43
  int v70; // ecx@45
  int v71; // ecx@45
  int v72; // ecx@45
  int v73; // eax@50
  int v74; // eax@50
  int v75; // eax@50
  float v76; // [sp+18h] [bp-F0h]@5
  int v77; // [sp+18h] [bp-F0h]@15
  float v78; // [sp+1Ch] [bp-ECh]@5
  _DWORD *v79; // [sp+1Ch] [bp-ECh]@18
  float v80; // [sp+20h] [bp-E8h]@28
  int v81; // [sp+24h] [bp-E4h]@1
  float v82; // [sp+28h] [bp-E0h]@15
  float v83; // [sp+2Ch] [bp-DCh]@15
  float v84; // [sp+30h] [bp-D8h]@15
  float v85; // [sp+34h] [bp-D4h]@15
  float v86; // [sp+38h] [bp-D0h]@15
  float v87; // [sp+3Ch] [bp-CCh]@15
  float v88; // [sp+40h] [bp-C8h]@15
  float v89; // [sp+44h] [bp-C4h]@15
  float v90; // [sp+48h] [bp-C0h]@15
  float v91; // [sp+4Ch] [bp-BCh]@15
  float v92; // [sp+50h] [bp-B8h]@15
  float v93; // [sp+54h] [bp-B4h]@15
  unsigned __int64 v94; // [sp+58h] [bp-B0h]@5
  int v95; // [sp+64h] [bp-A4h]@5
  int v96; // [sp+64h] [bp-A4h]@36
  unsigned __int64 v97; // [sp+68h] [bp-A0h]@5
  unsigned int v98; // [sp+70h] [bp-98h]@5
  float v99; // [sp+74h] [bp-94h]@5
  float v100; // [sp+78h] [bp-90h]@3
  float v101; // [sp+7Ch] [bp-8Ch]@28
  float v102; // [sp+80h] [bp-88h]@28
  float v103; // [sp+84h] [bp-84h]@28
  float v104; // [sp+88h] [bp-80h]@28
  float v105; // [sp+8Ch] [bp-7Ch]@28
  float v106; // [sp+90h] [bp-78h]@3
  float v107; // [sp+94h] [bp-74h]@28
  float v108; // [sp+98h] [bp-70h]@28
  float v109; // [sp+9Ch] [bp-6Ch]@28
  float v110; // [sp+A0h] [bp-68h]@28
  float v111; // [sp+A4h] [bp-64h]@28
  double v112; // [sp+A8h] [bp-60h]@15
  double v113; // [sp+B0h] [bp-58h]@15
  float v114; // [sp+B8h] [bp-50h]@24
  float v115; // [sp+BCh] [bp-4Ch]@24
  float v116; // [sp+C0h] [bp-48h]@24
  float v117; // [sp+C4h] [bp-44h]@24
  float v118; // [sp+C8h] [bp-40h]@24
  float v119; // [sp+CCh] [bp-3Ch]@24
  float v120; // [sp+D0h] [bp-38h]@21
  float v121; // [sp+D4h] [bp-34h]@21
  float v122; // [sp+D8h] [bp-30h]@21
  float v123; // [sp+DCh] [bp-2Ch]@21
  float v124; // [sp+E0h] [bp-28h]@21
  float v125; // [sp+E4h] [bp-24h]@21
  unsigned __int64 v126; // [sp+E8h] [bp-20h]@28
  unsigned __int64 v127; // [sp+F0h] [bp-18h]@28
  unsigned __int64 v128; // [sp+F8h] [bp-10h]@28
  unsigned __int64 v129; // [sp+100h] [bp-8h]@28

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 12) + (a1 << 6);
  v81 = *(_DWORD *)(a2 + 12) + (a1 << 6);
  if ( *(_DWORD *)(v3 + 40) != 1 )
  {
    if ( *(_BYTE *)(a2 + 60) )
      sub_1003A9D0(v3, (int *)a2, (int)&v106, (int)&v100);
    else
      sub_1003AC90((int *)a2, (int)&v106, (int)&v100, v3);
    v4 = 0;
    v99 = 1.0e10;
    v78 = 0.0;
    v5 = *(_BYTE *)(a2 + 60) != 0 ? 0xFFFFFFFA : 0;
    v76 = 0.0;
    v94 = 0i64;
    v97 = 0i64;
    v98 = v5 + 8;
    v95 = 0;
    if ( v5 != -8 )
    {
      v6 = (_DWORD *)(a2 + 64);
      v7 = (_DWORD *)(a2 + 76);
      while ( 1 )
      {
        v8 = *(_DWORD *)(a2 + 68);
        if ( v8 )
        {
          if ( v8 <= 0 )
            memset((void *)(*v6 + 4 * v8), 0, -4 * v8);
          *(_DWORD *)(a2 + 68) = 0;
        }
        v9 = *(_DWORD *)(a2 + 80);
        if ( v9 )
        {
          if ( v9 <= 0 )
            memset((void *)(*v7 + 4 * v9), 0, -4 * v9);
          *(_DWORD *)(a2 + 80) = 0;
        }
        v88 = 0.0;
        v112 = 0.0;
        v89 = 0.0;
        v113 = 0.0;
        v90 = 0.0;
        v91 = 0.0;
        v92 = 0.0;
        v93 = 0.0;
        v82 = 0.0;
        v83 = 0.0;
        v84 = 0.0;
        v85 = 0.0;
        v86 = 0.0;
        v87 = 0.0;
        v94 = 0i64;
        v97 = 0i64;
        v77 = 0;
        if ( *(_DWORD *)(v3 + 40) <= 0u )
          goto LABEL_33;
        while ( 1 )
        {
          v10 = (_DWORD *)(*(_DWORD *)(v3 + 36) + 4 * v77);
          v11 = *(_DWORD *)v2;
          v79 = v10;
          v12 = *v10;
          v13 = *(_DWORD *)(*(_DWORD *)v2 + 28 * v12 + 24);
          v14 = v11 + 28 * v12;
          v15 = sub_1003CC80(v11 + 28 * v12, (int)&v106);
          if ( v15 >= sub_1003CC80(v14, (int)&v100) )
          {
            v25 = *(_DWORD *)(a2 + 80);
            if ( v25 >= *(_DWORD *)(a2 + 84) )
              sub_100943C0(v25 + 1, 0, (int)v7, 1, 4u, 0);
            *(_DWORD *)(*(_DWORD *)(a2 + 76) + 4 * (*(_DWORD *)(a2 + 80))++) = *v79;
            v26 = (double)v13;
            v97 += v13;
            v27 = v26;
            v114 = *(float *)v14 * v26;
            v115 = *(float *)(v14 + 4) * v26;
            v116 = *(float *)(v14 + 8) * v26;
            v117 = *(float *)(v14 + 12) * v26;
            v118 = v26 * *(float *)(v14 + 16);
            v119 = *(float *)(v14 + 20) * v26;
            v82 = v114 + v82;
            v83 = v83 + v115;
            v84 = v84 + v116;
            v85 = v85 + v117;
            v86 = v86 + v118;
            v87 = v87 + v119;
            v28 = *(float *)v14 * *(float *)v14;
            v29 = *(float *)(v14 + 4) * *(float *)(v14 + 4) + v28;
            v30 = *(float *)(v14 + 8) * *(float *)(v14 + 8) + v29;
            v31 = *(float *)(v14 + 12) * *(float *)(v14 + 12) + v30;
            v32 = *(float *)(v14 + 16) * *(float *)(v14 + 16) + v31;
            v33 = *(float *)(v14 + 20) * *(float *)(v14 + 20) + v32;
            v113 = v27 * v33 + v113;
          }
          else
          {
            v16 = *(_DWORD *)(a2 + 68);
            if ( v16 >= *(_DWORD *)(a2 + 72) )
              sub_100943C0(v16 + 1, 0, (int)v6, 1, 4u, 0);
            *(_DWORD *)(*(_DWORD *)(a2 + 64) + 4 * (*(_DWORD *)(a2 + 68))++) = *v79;
            v17 = (double)v13;
            v94 += v13;
            v18 = v17;
            v120 = *(float *)v14 * v17;
            v121 = *(float *)(v14 + 4) * v17;
            v122 = *(float *)(v14 + 8) * v17;
            v123 = *(float *)(v14 + 12) * v17;
            v124 = v17 * *(float *)(v14 + 16);
            v125 = *(float *)(v14 + 20) * v17;
            v88 = v120 + v88;
            v89 = v89 + v121;
            v90 = v90 + v122;
            v91 = v91 + v123;
            v92 = v92 + v124;
            v93 = v93 + v125;
            v19 = *(float *)v14 * *(float *)v14;
            v20 = *(float *)(v14 + 4) * *(float *)(v14 + 4) + v19;
            v21 = *(float *)(v14 + 8) * *(float *)(v14 + 8) + v20;
            v22 = *(float *)(v14 + 12) * *(float *)(v14 + 12) + v21;
            v23 = *(float *)(v14 + 16) * *(float *)(v14 + 16) + v22;
            v24 = *(float *)(v14 + 20) * *(float *)(v14 + 20) + v23;
            v112 = v18 * v24 + v112;
          }
          if ( (unsigned int)++v77 >= *(_DWORD *)(v81 + 40) )
            break;
          v2 = a2;
          v3 = v81;
        }
        if ( !v94 || !v97 )
        {
          v3 = v81;
LABEL_33:
          *(_BYTE *)(v3 + 60) = 1;
          return;
        }
        v127 = v94 & 0x7FFFFFFFFFFFFFFFi64;
        v34 = v88 * v88;
        v126 = v94 & 0x8000000000000000ui64;
        v35 = v89 * v89 + v34;
        v36 = v90 * v90 + v35;
        v37 = v91 * v91 + v36;
        v38 = v92 * v92 + v37;
        v39 = v93 * v93 + v38;
        v40 = (double)v94;
        v78 = v112 - v39 / v40;
        v41 = v82 * v82;
        v42 = v83 * v83 + v41;
        v43 = v84 * v84 + v42;
        v44 = v85 * v85 + v43;
        v45 = v86 * v86 + v44;
        v46 = v87 * v87 + v45;
        v128 = v97 & 0x7FFFFFFFFFFFFFFFi64;
        v129 = v97 & 0x8000000000000000ui64;
        v47 = (double)v97;
        v48 = v47;
        v76 = v113 - v46 / v47;
        v49 = 1.0 / v40;
        v50 = v88 * v49;
        v106 = v50;
        v51 = v89 * v49;
        v107 = v51;
        v52 = v49 * v90;
        v108 = v52;
        v53 = v49 * v91;
        v109 = v53;
        v54 = v49 * v92;
        v110 = v54;
        v55 = v49 * v93;
        v56 = 1.0 / v48;
        v57 = v56 * v82;
        v58 = v56 * v83;
        v59 = v56 * v84;
        v60 = v56 * v85;
        v61 = v56 * v86;
        v62 = v56 * v87;
        v100 = v57;
        v80 = v76 + v78;
        v111 = v55;
        v103 = v60;
        v101 = v58;
        v102 = v59;
        v104 = v61;
        v105 = v62;
        if ( v80 < 0.0000099999997 || (v99 - v80) / v80 < 0.001249999972060323 )
          break;
        v99 = v76 + v78;
        v3 = v81;
        v2 = a2;
        if ( ++v95 >= v98 )
          goto LABEL_35;
      }
      v3 = v81;
      v2 = a2;
LABEL_35:
      v4 = 0;
    }
    v63 = *(_DWORD *)(v2 + 16);
    *(_DWORD *)(v3 + 48) = v63;
    *(_DWORD *)(v3 + 52) = *(_DWORD *)(v2 + 16) + 1;
    v96 = v63 + 1;
    *(_DWORD *)(v3 + 56) = (*(_DWORD *)(v2 + 40))++;
    v64 = *(_DWORD *)(v2 + 16);
    v65 = (int *)(v2 + 12);
    v66 = *(_DWORD *)(v2 + 16) + 2;
    if ( v66 != v64 )
    {
      if ( v66 >= v64 )
      {
        if ( v66 > *(_DWORD *)(v2 + 20) )
          sub_100943C0(v66, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003CE50, v2 + 12, v66 == v64 + 1, 0x40u, v4);
        sub_1003E580(v66 - *(_DWORD *)(v2 + 16), *v65 + (*(_DWORD *)(v2 + 16) << 6));
      }
      else
      {
        sub_1004CEA0(-2, *v65 + ((*(_DWORD *)(v2 + 16) + 2) << 6));
      }
      *(_DWORD *)(v2 + 16) = v66;
    }
    v67 = *v65;
    v68 = v67 + (v63 << 6);
    v69 = v67 + (v96 << 6);
    if ( (float *)v68 != &v106 )
    {
      *(float *)v68 = v106;
      *(float *)(v68 + 4) = v107;
      *(float *)(v68 + 8) = v108;
      *(float *)(v68 + 12) = v109;
      *(float *)(v68 + 16) = v110;
      *(float *)(v68 + 20) = v111;
    }
    *(_QWORD *)(v68 + 24) = v94;
    v70 = *(_DWORD *)(v68 + 36);
    *(_DWORD *)(v68 + 36) = *(_DWORD *)(v2 + 64);
    *(_DWORD *)(v2 + 64) = v70;
    v71 = *(_DWORD *)(v68 + 40);
    *(_DWORD *)(v68 + 40) = *(_DWORD *)(v2 + 68);
    *(_DWORD *)(v2 + 68) = v71;
    v72 = *(_DWORD *)(v68 + 44);
    *(_DWORD *)(v68 + 44) = *(_DWORD *)(v2 + 72);
    *(_DWORD *)(v2 + 72) = v72;
    *(float *)(v68 + 32) = v78;
    if ( *(_DWORD *)(v68 + 40) > 1u && v78 > 0.0 )
      sub_1003A940(v2, v63);
    if ( (float *)v69 != &v100 )
    {
      *(float *)v69 = v100;
      *(float *)(v69 + 4) = v101;
      *(float *)(v69 + 8) = v102;
      *(float *)(v69 + 12) = v103;
      *(float *)(v69 + 16) = v104;
      *(float *)(v69 + 20) = v105;
    }
    *(_QWORD *)(v69 + 24) = v97;
    v73 = *(_DWORD *)(v69 + 36);
    *(_DWORD *)(v69 + 36) = *(_DWORD *)(v2 + 76);
    *(_DWORD *)(v2 + 76) = v73;
    v74 = *(_DWORD *)(v69 + 40);
    *(_DWORD *)(v69 + 40) = *(_DWORD *)(v2 + 80);
    *(_DWORD *)(v2 + 80) = v74;
    v75 = *(_DWORD *)(v69 + 44);
    *(_DWORD *)(v69 + 44) = *(_DWORD *)(v2 + 84);
    *(_DWORD *)(v2 + 84) = v75;
    *(float *)(v69 + 32) = v76;
    if ( *(_DWORD *)(v69 + 40) > 1u && v76 > 0.0 )
      sub_1003A940(v2, v96);
  }
}
// 1003CE50: using guessed type int sub_1003CE50();

//----- (10039830) --------------------------------------------------------
void __thiscall sub_10039830(int this, unsigned int a2)
{
  unsigned int v2; // eax@1
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // eax@6
  int v6; // ecx@6
  int v7; // edx@6
  int v8; // [sp+4h] [bp-18h]@4
  int v9; // [sp+8h] [bp-14h]@4
  int v10; // [sp+Ch] [bp-10h]@4
  int v11; // [sp+18h] [bp-4h]@4

  v2 = a2;
  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ( a2 <= v4 )
  {
    if ( a2 < v4 )
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      if ( *(_DWORD *)(v3 + 4) > a2 )
        v2 = *(_DWORD *)(v3 + 4);
      sub_100943C0(v2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003B7E0, (int)&v8, 0, 0x1Cu, 0);
      sub_1003B760((int)&v8, v3);
      v5 = *(_DWORD *)v3;
      v6 = v9;
      *(_DWORD *)v3 = v8;
      v7 = v10;
      *(_DWORD *)(v3 + 4) = v6;
      *(_DWORD *)(v3 + 8) = v7;
      v11 = -1;
      if ( v5 )
      {
        if ( v5 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003B7E0, v3, 0, 0x1Cu, 0);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10039940) --------------------------------------------------------
void __usercall sub_10039940(int a1@<esi>)
{
  int v1; // eax@2

  if ( *(_DWORD *)a1 )
  {
    sub_1004CEA0(*(_DWORD *)(a1 + 4), *(_DWORD *)a1);
    v1 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 )
    {
      if ( v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10039990) --------------------------------------------------------
void __usercall sub_10039990(int a1@<esi>)
{
  unsigned int v1; // eax@1
  unsigned int v2; // eax@4
  int v3; // ebx@6
  int v4; // ecx@6
  int v5; // edx@6
  int v6; // eax@6
  int v7; // [sp+0h] [bp-18h]@4
  int v8; // [sp+4h] [bp-14h]@4
  int v9; // [sp+8h] [bp-10h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 >= 0x1FFFF )
  {
    if ( v1 > 0x1FFFF )
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v2 = *(_DWORD *)(a1 + 4);
      if ( v2 <= 0x1FFFF )
        v2 = 0x1FFFF;
      sub_100943C0(v2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003CE50, (int)&v7, 0, 0x40u, 0);
      sub_1003B850((int)&v7, a1);
      v3 = *(_DWORD *)a1;
      v4 = v8;
      v5 = v9;
      *(_DWORD *)a1 = v7;
      v6 = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a1 + 4) = v4;
      *(_DWORD *)(a1 + 8) = v5;
      v10 = -1;
      if ( v3 )
      {
        sub_1004CEA0(v6, v3);
        if ( v3 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(0x1FFFFu, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003CE50, a1, 0, 0x40u, 0);
  }
}
// 1003CE50: using guessed type int sub_1003CE50();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10039AE0) --------------------------------------------------------
void __thiscall sub_10039AE0(int this, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // esi@2
  int v6; // esi@2
  int v7; // eax@2
  int v8; // ebx@3
  int v9; // eax@3
  unsigned int v10; // eax@3
  int v11; // ebx@5
  int (__cdecl *v12)(unsigned int, int); // eax@12
  int v13; // eax@19
  unsigned int v14; // ecx@19
  int v15; // esi@20
  _DWORD *v16; // edx@20
  char v17; // [sp+Fh] [bp-91h]@12
  int v18; // [sp+10h] [bp-90h]@1
  int v19; // [sp+10h] [bp-90h]@18
  unsigned int v20; // [sp+14h] [bp-8Ch]@2
  unsigned int v21; // [sp+14h] [bp-8Ch]@17
  int v22; // [sp+18h] [bp-88h]@2
  char v23; // [sp+1Ch] [bp-84h]@3
  int v24; // [sp+5Ch] [bp-44h]@3
  char v25; // [sp+60h] [bp-40h]@3

  v4 = this;
  v18 = this;
  if ( !*(_BYTE *)(this + 380) )
  {
    v5 = this + 88 * a2;
    v22 = v5;
    v6 = v5 + 16;
    sub_10039CE0(v6);
    v7 = *(_DWORD *)(a4 + 4);
    v20 = 0;
    if ( *(_DWORD *)(v7 + 4) )
    {
      do
      {
        v8 = **(_DWORD **)a4 + 68 * *(_DWORD *)(*(_DWORD *)v7 + 4 * v20);
        v9 = sub_1003DDC0((int)&v25, v8);
        sub_1003DDC0((int)&v23, v9);
        v10 = *(_DWORD *)(v6 + 4);
        v24 = *(_DWORD *)(v8 + 64);
        if ( v10 >= *(_DWORD *)(v6 + 8) )
          sub_100943C0(v10 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003DD80, v6, 1, 0x44u, 0);
        v11 = *(_DWORD *)v6 + 68 * *(_DWORD *)(v6 + 4);
        if ( v11 )
        {
          sub_1003DDC0(*(_DWORD *)v6 + 68 * *(_DWORD *)(v6 + 4), (int)&v23);
          *(_DWORD *)(v11 + 64) = v24;
        }
        ++*(_DWORD *)(v6 + 4);
        v7 = *(_DWORD *)(a4 + 4);
        ++v20;
      }
      while ( v20 < *(_DWORD *)(v7 + 4) );
      v4 = v18;
    }
    if ( !*(_BYTE *)(v4 + 380) )
    {
      if ( GetCurrentThreadId() != *(_DWORD *)(v4 + 8) || 0 != *(_DWORD *)(v4 + 12) )
      {
        v17 = 0;
      }
      else
      {
        v17 = 1;
        v12 = (int (__cdecl *)(unsigned int, int))sub_10039AA0;
        if ( !*(_BYTE *)(v4 + 368) )
        {
LABEL_14:
          sub_10039DA0(v6, *(_DWORD *)(a4 + 20), v12, v4);
          if ( v17 )
            *(_BYTE *)(v18 + 368) = 1;
          if ( !*(_BYTE *)(v18 + 380) )
          {
            sub_1003A360((void *)(a4 + 8), v6, *(_DWORD *)(v22 + 44));
            v21 = 0;
            if ( *(_DWORD *)(a4 + 12) > 0u )
            {
              v19 = 0;
              do
              {
                v13 = v19 + *(_DWORD *)(a4 + 8);
                v14 = 0;
                if ( *(_DWORD *)(v13 + 4) )
                {
                  do
                  {
                    v15 = *(_DWORD *)(**(_DWORD **)(a4 + 4) + 4 * *(_DWORD *)(*(_DWORD *)v13 + 4 * v14));
                    v16 = (_DWORD *)(*(_DWORD *)v13 + 4 * v14++);
                    *v16 = v15;
                  }
                  while ( v14 < *(_DWORD *)(v13 + 4) );
                }
                v19 += 12;
                ++v21;
              }
              while ( v21 < *(_DWORD *)(a4 + 12) );
            }
          }
          return;
        }
      }
      v12 = (int (__cdecl *)(unsigned int, int))sub_1003C200;
      goto LABEL_14;
    }
  }
}
// 10039AA0: using guessed type int __cdecl sub_10039AA0(int, int);
// 1003C200: using guessed type int sub_1003C200();

//----- (10039C90) --------------------------------------------------------
int __thiscall sub_10039C90(int this)
{
  int result; // eax@1

  result = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(float *)(this + 36) = 0.0;
  *(_DWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 44) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_DWORD *)(this + 56) = 0;
  *(_BYTE *)(this + 60) = 0;
  *(_DWORD *)(this + 64) = 0;
  *(_DWORD *)(this + 68) = 0;
  *(_DWORD *)(this + 72) = 0;
  *(_DWORD *)(this + 76) = 0;
  *(_DWORD *)(this + 80) = 0;
  *(_DWORD *)(this + 84) = 0;
  return result;
}

//----- (10039CE0) --------------------------------------------------------
void __usercall sub_10039CE0(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // eax@6
  int v3; // ecx@11
  int v4; // eax@12

  v1 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
  }
  v2 = *(_DWORD *)(a1 + 24);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
  }
  v3 = *(_DWORD *)(a1 + 12);
  if ( v3 )
  {
    sub_1004CF40(*(_DWORD *)(a1 + 16), v3);
    v4 = *(_DWORD *)(a1 + 12);
    if ( v4 )
    {
      if ( v4 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
  }
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(float *)(a1 + 36) = 0.0;
  *(_BYTE *)(a1 + 60) = 0;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10039DA0) --------------------------------------------------------
char __userpurge sub_10039DA0@<al>(int a1@<ebx>, unsigned int a2, int (__cdecl *a3)(unsigned int, int), int a4)
{
  unsigned int v4; // esi@1
  char v5; // di@1
  unsigned int v6; // edi@4
  int v7; // esi@4
  int v8; // eax@4
  unsigned int v9; // eax@4
  float v10; // ST20_4@8
  float v11; // ST24_4@8
  float v12; // ST20_4@8
  int v13; // ecx@8
  int *v14; // esi@8
  int v15; // eax@9
  unsigned int v16; // eax@14
  int v17; // edi@16
  bool v18; // zf@16
  int v19; // edi@16
  unsigned int v20; // eax@18
  int v21; // edi@18
  unsigned int v22; // esi@18
  int v23; // esi@24
  unsigned int v24; // ST10_4@24
  int v25; // ecx@26
  int v26; // esi@27
  unsigned int v27; // ecx@31
  int v28; // eax@37
  int v30; // edi@49
  unsigned int v31; // eax@50
  int v32; // eax@55
  int v33; // eax@60
  int v34; // eax@65
  unsigned int v35; // [sp+10h] [bp-DCh]@2
  unsigned int v36; // [sp+10h] [bp-DCh]@24
  unsigned int v37; // [sp+10h] [bp-DCh]@47
  float v38; // [sp+14h] [bp-D8h]@4
  signed int v39; // [sp+14h] [bp-D8h]@25
  int v40; // [sp+14h] [bp-D8h]@48
  int v41; // [sp+18h] [bp-D4h]@3
  unsigned int v42; // [sp+18h] [bp-D4h]@24
  int v43; // [sp+18h] [bp-D4h]@49
  int *v44; // [sp+1Ch] [bp-D0h]@24
  double v45; // [sp+24h] [bp-C8h]@2
  int *v46[3]; // [sp+24h] [bp-C8h]@24
  char v47; // [sp+34h] [bp-B8h]@2
  unsigned __int64 v48; // [sp+74h] [bp-78h]@2
  float v49; // [sp+7Ch] [bp-70h]@8
  void *v50; // [sp+80h] [bp-6Ch]@2
  unsigned int v51; // [sp+84h] [bp-68h]@2
  unsigned int v52; // [sp+88h] [bp-64h]@2
  int v53; // [sp+8Ch] [bp-60h]@2
  int v54; // [sp+90h] [bp-5Ch]@2
  int v55; // [sp+94h] [bp-58h]@2
  char v56; // [sp+98h] [bp-54h]@2
  char v57; // [sp+9Ch] [bp-50h]@4
  int v58; // [sp+E8h] [bp-4h]@2

  v4 = *(_DWORD *)(a1 + 4);
  v5 = 0;
  if ( !v4 )
    return 0;
  v45 = 0.0;
  *(_BYTE *)(a1 + 60) = 0;
  memset(&v47, 0, 0x40u);
  v48 = 0i64;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v53 = -1;
  v54 = -1;
  v55 = -1;
  v56 = 0;
  v58 = 0;
  sub_10036310((int)&v50, v4);
  v35 = 0;
  if ( *(_DWORD *)(a1 + 4) > 0u )
  {
    v41 = 0;
    do
    {
      v6 = *(_DWORD *)(v41 + *(_DWORD *)a1 + 64);
      v7 = *(_DWORD *)a1 + v41;
      v38 = (double)*(unsigned int *)(v7 + 64);
      v8 = sub_1003CDE0((int)&v57, v7, v38);
      sub_1003CD10((int)&v47, v8);
      v9 = v51;
      v48 += v6;
      if ( v51 >= v52 )
      {
        sub_100943C0(v51 + 1, 0, (int)&v50, 1, 4u, 0);
        v9 = v51;
      }
      *((_DWORD *)v50 + v9) = v35;
      v51 = v9 + 1;
      v41 += 68;
      ++v35;
      v45 = sub_1003DE10((float *)v7, (float *)v7) * v38 + v45;
    }
    while ( v35 < *(_DWORD *)(a1 + 4) );
    v5 = 0;
  }
  v10 = sub_1003DE10((float *)&v47, (float *)&v47);
  v11 = (double)v48;
  v49 = v45 - v10 / v11;
  v12 = 1.0 / v11;
  sub_1003CD80((int)&v47, v12);
  v13 = *(_DWORD *)(a1 + 12);
  v14 = (int *)(a1 + 12);
  if ( v13 )
  {
    sub_1004CF40(*(_DWORD *)(a1 + 16), v13);
    v15 = *v14;
    if ( *v14 )
    {
      if ( v15 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v15, 0, 0, 1, dword_100AE9F4);
    }
    *v14 = 0;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
  }
  sub_1003C990((int)v14, 2 * a2 + 1);
  v16 = *(_DWORD *)(a1 + 16);
  if ( v16 >= *(_DWORD *)(a1 + 20) )
    sub_100943C0(v16 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003E1A0, a1 + 12, 1, 0x68u, v5);
  v17 = 104 * *(_DWORD *)(a1 + 16);
  v18 = *v14 + v17 == 0;
  v19 = *v14 + v17;
  LOBYTE(v58) = 1;
  if ( !v18 )
    sub_1003E350(v19, (int)&v47);
  LOBYTE(v58) = 0;
  ++*(_DWORD *)(a1 + 16);
  v20 = *(_DWORD *)(a1 + 48);
  v21 = a1 + 44;
  v22 = a2 + 1;
  if ( a2 + 1 != v20 )
  {
    if ( v22 >= v20 )
    {
      if ( v22 > *(_DWORD *)(a1 + 52) )
        sub_100943C0(v22, 0, a1 + 44, v22 == v20 + 1, 4u, 0);
      memset((void *)(*(_DWORD *)v21 + 4 * *(_DWORD *)(a1 + 48)), 0, 4 * (v22 - *(_DWORD *)(a1 + 48)));
    }
    *(_DWORD *)(a1 + 48) = v22;
  }
  v23 = 0;
  *(_DWORD *)(*(_DWORD *)v21 + 4) = 0;
  *(_DWORD *)(a1 + 56) = 1;
  v42 = 1;
  v24 = *(_DWORD *)(a1 + 4) + 1;
  *(_DWORD *)(a1 + 40) = 0;
  v46[0] = (int *)(a1 + 64);
  sub_10036310(a1 + 64, v24);
  v44 = (int *)(a1 + 76);
  sub_10036310(a1 + 76, *(_DWORD *)(a1 + 4) + 1);
  v36 = -1;
  if ( a2 > 1 )
  {
    v39 = 100;
    do
    {
      v25 = *(_DWORD *)(a1 + 56);
      if ( !v25 )
        break;
      v26 = *(_DWORD *)(*(_DWORD *)v21 + 4);
      *(_DWORD *)(*(_DWORD *)v21 + 4) = *(_DWORD *)(*(_DWORD *)v21 + 4 * v25);
      v18 = (*(_DWORD *)(a1 + 56))-- == 1;
      if ( !v18 )
        sub_1003C210(a1);
      sub_1003C2C0(v26, a1);
      ++v42;
      v39 += 100;
      if ( a3 && !(v42 & 0x3F) )
      {
        v27 = a2;
        if ( !a2 || (v39 + (a2 >> 1)) / a2 == v36 )
          goto LABEL_36;
        if ( !(unsigned __int8)a3((v39 + (a2 >> 1)) / a2, a4) )
        {
          v58 = -1;
          if ( !v50 )
            return 0;
          if ( (unsigned __int8)v50 & 7 )
          {
            sub_100927E0((int)"crnlib_free: bad ptr");
            return 0;
          }
          off_100AD9F4(v50, 0, 0, 1, dword_100AE9F4);
          return 0;
        }
        v36 = (v39 + (a2 >> 1)) / a2;
      }
      v27 = a2;
LABEL_36:
      v23 = 0;
    }
    while ( v42 < v27 );
  }
  v28 = *(_DWORD *)(a1 + 24);
  if ( v28 )
  {
    if ( v28 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v28, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
  }
  v37 = 0;
  *(float *)(a1 + 36) = 0.0;
  if ( *(_DWORD *)(a1 + 16) > 0u )
  {
    v40 = 0;
    do
    {
      v30 = v23 + *(_DWORD *)(a1 + 12);
      v43 = v23 + *(_DWORD *)(a1 + 12);
      if ( *(_DWORD *)(v30 + 88) == -1 )
      {
        *(_DWORD *)(v30 + 96) = *(_DWORD *)(a1 + 28);
        v31 = *(_DWORD *)(a1 + 28);
        if ( v31 >= *(_DWORD *)(a1 + 32) )
          sub_100943C0(v31 + 1, 0, a1 + 24, 1, 0x40u, 0);
        qmemcpy((void *)(*(_DWORD *)(a1 + 24) + ((*(_DWORD *)(a1 + 28))++ << 6)), (const void *)v30, 0x40u);
        *(float *)(a1 + 36) = *(float *)(v43 + 72) + *(float *)(a1 + 36);
      }
      v23 = v40 + 104;
      ++v37;
      v40 += 104;
    }
    while ( v37 < *(_DWORD *)(a1 + 16) );
    v21 = a1 + 44;
  }
  v32 = *(_DWORD *)v21;
  if ( *(_DWORD *)v21 )
  {
    if ( v32 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v32, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)v21 = 0;
    *(_DWORD *)(v21 + 4) = 0;
    *(_DWORD *)(v21 + 8) = 0;
  }
  v33 = *v46[0];
  if ( *v46[0] )
  {
    if ( v33 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v33, 0, 0, 1, dword_100AE9F4);
    *v46[0] = 0;
    *(_DWORD *)(a1 + 68) = 0;
    *(_DWORD *)(a1 + 72) = 0;
  }
  v34 = *v44;
  if ( *v44 )
  {
    if ( v34 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v34, 0, 0, 1, dword_100AE9F4);
    *v44 = 0;
    *(_DWORD *)(a1 + 80) = 0;
    *(_DWORD *)(a1 + 84) = 0;
  }
  v58 = -1;
  if ( v50 )
  {
    if ( (unsigned __int8)v50 & 7 )
    {
      sub_100927E0((int)"crnlib_free: bad ptr");
      return 1;
    }
    off_100AD9F4(v50, 0, 0, 1, dword_100AE9F4);
  }
  return 1;
}
// 1003E1A0: using guessed type int sub_1003E1A0();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003A360) --------------------------------------------------------
void __thiscall sub_1003A360(void *this, int a2, signed int a3)
{
  int v3; // edi@1
  unsigned int v4; // ebx@1
  int v5; // esi@1
  int v6; // ebp@2
  int v7; // ebp@4
  unsigned int v8; // eax@7
  unsigned int v9; // esi@7
  int v10; // eax@12
  int v11; // ecx@12
  int v12; // eax@12
  int i; // ecx@12
  int v14; // ebp@17
  int v15; // esi@17
  void *v16; // eax@21
  void *v17; // [sp+14h] [bp-18h]@1
  unsigned int v18; // [sp+18h] [bp-14h]@1
  unsigned int v19; // [sp+1Ch] [bp-10h]@1
  int v20; // [sp+28h] [bp-4h]@1

  v3 = (int)this;
  sub_10037280((int)this, 0, 0);
  sub_10038CE0(v3, a3);
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  sub_10036310((int)&v17, 0x200u);
  v4 = v18;
  v5 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(a2 + 12) + 104 * v5;
      v5 = *(_DWORD *)(v6 + 88);
      if ( v5 < 0 || *(_DWORD *)(v6 + 96) + 2 > a3 )
        break;
      v7 = *(_DWORD *)(v6 + 92);
      if ( v4 >= v19 )
      {
        sub_100943C0(v4 + 1, 0, (int)&v17, 1, 4u, 0);
        v4 = v18;
      }
      *((_DWORD *)v17 + v4++) = v7;
      v18 = v4;
    }
    v8 = *(_DWORD *)(v3 + 4);
    v9 = v8 + 1;
    if ( v8 + 1 != v8 )
    {
      if ( v8 + 1 >= v8 )
      {
        if ( v9 > *(_DWORD *)(v3 + 8) )
          sub_100943C0(v8 + 1, 0, v3, v9 == v8 + 1, 0xCu, 0);
        v10 = *(_DWORD *)(v3 + 4);
        v11 = v9 - v10;
        v12 = *(_DWORD *)v3 + 12 * v10;
        for ( i = v12 + 12 * v11; v12 != i; v12 += 12 )
        {
          if ( v12 )
          {
            *(_DWORD *)v12 = 0;
            *(_DWORD *)(v12 + 4) = 0;
            *(_DWORD *)(v12 + 8) = 0;
          }
        }
      }
      else
      {
        sub_1003E4E0(-1, (int *)(*(_DWORD *)v3 + 12 * v9));
      }
      *(_DWORD *)(v3 + 4) = v9;
    }
    v14 = v6 + 76;
    v15 = *(_DWORD *)v3 + 12 * *(_DWORD *)(v3 + 4) - 12;
    if ( v15 != v14 )
    {
      if ( *(_DWORD *)(v15 + 8) < *(_DWORD *)(v14 + 4) )
      {
        v16 = *(void **)v15;
        if ( *(_DWORD *)v15 )
        {
          if ( (unsigned __int8)v16 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v16, 0, 0, 1, dword_100AE9F4);
          *(_DWORD *)v15 = 0;
          *(_DWORD *)(v15 + 4) = 0;
          *(_DWORD *)(v15 + 8) = 0;
        }
        sub_100943C0(*(_DWORD *)(v14 + 4), 0, v15, 0, 4u, 0);
      }
      else if ( *(_DWORD *)(v15 + 4) )
      {
        *(_DWORD *)(v15 + 4) = 0;
      }
      memcpy(*(void **)v15, *(const void **)v14, 4 * *(_DWORD *)(v14 + 4));
      *(_DWORD *)(v15 + 4) = *(_DWORD *)(v14 + 4);
    }
    if ( !v4 )
      break;
    v5 = *((_DWORD *)v17 + v4-- - 1);
    v18 = v4;
  }
  v20 = -1;
  if ( v17 )
  {
    if ( (unsigned __int8)v17 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v17, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003A580) --------------------------------------------------------
void __userpurge sub_1003A580(int a1@<esi>, unsigned int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // ecx@1
  int v4; // eax@6
  int v5; // edx@6
  int v6; // ecx@6
  int v7; // [sp+0h] [bp-18h]@4
  int v8; // [sp+4h] [bp-14h]@4
  int v9; // [sp+8h] [bp-10h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v2 = a2;
  v3 = *(_DWORD *)(a1 + 8);
  if ( a2 <= v3 )
  {
    if ( a2 < v3 )
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      if ( *(_DWORD *)(a1 + 4) > a2 )
        v2 = *(_DWORD *)(a1 + 4);
      sub_100943C0(v2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003DD80, (int)&v7, 0, 0x44u, 0);
      sub_1003C840((int)&v7, a1);
      v4 = *(_DWORD *)a1;
      v5 = v8;
      *(_DWORD *)a1 = v7;
      v6 = v9;
      *(_DWORD *)(a1 + 4) = v5;
      *(_DWORD *)(a1 + 8) = v6;
      v10 = -1;
      if ( v4 )
      {
        if ( v4 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003DD80, a1, 0, 0x44u, 0);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003A680) --------------------------------------------------------
unsigned int __userpurge sub_1003A680@<eax>(int a1@<ebx>, int a2)
{
  int v2; // eax@2
  int v3; // ebp@2
  unsigned int v4; // esi@2
  int v5; // edi@2
  int v7; // [sp+Ch] [bp-8h]@2
  unsigned int v8; // [sp+10h] [bp-4h]@6

  if ( *(_DWORD *)(a1 + 20) )
  {
    v2 = *(_DWORD *)(a2 + 12);
    v3 = *(_DWORD *)a1;
    v4 = (unsigned int)(-1640531527 * *(_DWORD *)(a2 + 12)) >> *(_DWORD *)(a1 + 12);
    v7 = *(_DWORD *)(a2 + 12);
    v5 = *(_DWORD *)a1 + 24 * v4;
    if ( *(_BYTE *)(v5 + 20) )
    {
      if ( *(_DWORD *)(v5 + 12) == v2 )
      {
        if ( sub_10037150(v3 + 24 * v4, a2) )
          return v4;
        v2 = v7;
      }
      v8 = v4;
      while ( 1 )
      {
        if ( v4 )
        {
          --v4;
          v5 -= 24;
        }
        else
        {
          v4 = *(_DWORD *)(a1 + 4) - 1;
          v5 = v3 + 24 * v4;
        }
        if ( v4 == v8 || !*(_BYTE *)(v5 + 20) )
          break;
        if ( *(_DWORD *)(v5 + 12) == v2 )
        {
          if ( sub_10037150(v5, a2) )
            return v4;
          v2 = v7;
        }
      }
    }
  }
  return *(_DWORD *)(a1 + 4);
}

//----- (1003A730) --------------------------------------------------------
char __userpurge sub_1003A730@<al>(int a1@<eax>, int a2, int a3, _DWORD *a4)
{
  int v4; // edi@1
  char result; // al@2
  unsigned int v6; // ebp@3
  int v7; // esi@3
  unsigned int v8; // [sp+10h] [bp-4h]@7

  v4 = a1;
  if ( !*(_DWORD *)(a2 + 4) )
    return 0;
  v6 = (unsigned int)(-1640531527 * *(_DWORD *)(a1 + 12)) >> *(_DWORD *)(a2 + 12);
  v7 = *(_DWORD *)a2 + 24 * v6;
  if ( *(_BYTE *)(v7 + 20) )
  {
    if ( *(_DWORD *)(v7 + 12) != *(_DWORD *)(a1 + 12) || !sub_10037150(*(_DWORD *)a2 + 24 * v6, a1) )
    {
      v8 = v6;
      do
      {
        if ( v6 )
        {
          --v6;
          v7 -= 24;
        }
        else
        {
          v6 = *(_DWORD *)(a2 + 4) - 1;
          v7 = *(_DWORD *)a2 + 24 * v6;
        }
        if ( v8 == v6 )
          return 0;
        if ( !*(_BYTE *)(v7 + 20) )
          goto LABEL_16;
      }
      while ( *(_DWORD *)(v7 + 12) != *(_DWORD *)(v4 + 12) || !sub_10037150(v7, v4) );
    }
    *(_DWORD *)a3 = a2;
    *(_DWORD *)(a3 + 4) = v6;
    *(_BYTE *)(a3 + 8) = 0;
    result = 1;
  }
  else
  {
LABEL_16:
    if ( *(_DWORD *)(a2 + 20) >= *(_DWORD *)(a2 + 24) )
      return 0;
    sub_1003CAA0(a4, v4, v7);
    result = 1;
    *(_BYTE *)(v7 + 20) = 1;
    ++*(_DWORD *)(a2 + 20);
    *(_DWORD *)(a3 + 4) = v6;
    *(_DWORD *)a3 = a2;
    *(_BYTE *)(a3 + 8) = 1;
  }
  return result;
}

//----- (1003A860) --------------------------------------------------------
int __stdcall sub_1003A860(int a1, int a2)
{
  int v2; // edi@5
  int v3; // esi@5
  int i; // ebx@5
  int v5; // eax@7
  void *v6; // ecx@7

  if ( a1 != a2 )
  {
    if ( *(_DWORD *)(a1 + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_10037230(a1);
      sub_100943C0(*(_DWORD *)(a2 + 4), 0, a1, 0, 0xCu, 0);
    }
    else
    {
      sub_10037280(a1, 0, 0);
    }
    v2 = *(_DWORD *)(a2 + 4);
    v3 = *(_DWORD *)a1;
    for ( i = *(_DWORD *)a2; v2; --v2 )
    {
      if ( v3 )
      {
        *(_DWORD *)v3 = 0;
        *(_DWORD *)(v3 + 4) = 0;
        *(_DWORD *)(v3 + 8) = 0;
        sub_100943C0(*(_DWORD *)(i + 4), 0, v3, 0, 4u, 0);
        v5 = *(_DWORD *)(i + 4);
        v6 = *(void **)v3;
        *(_DWORD *)(v3 + 4) = v5;
        memcpy(v6, *(const void **)i, 4 * v5);
      }
      v3 += 12;
      i += 12;
    }
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  }
  return a1;
}

//----- (1003A940) --------------------------------------------------------
void __userpurge sub_1003A940(int a1@<ebx>, int a2)
{
  double v2; // st7@1
  float v3; // ST0C_4@4
  unsigned int v4; // ebp@1
  unsigned int v5; // ecx@3
  int v6; // edx@4

  v2 = *(float *)((a2 << 6) + *(_DWORD *)(a1 + 12) + 32);
  v4 = ++*(_DWORD *)(a1 + 56);
  if ( v4 >= *(_DWORD *)(a1 + 48) )
    sub_100366C0(a1 + 44, v4 + 1);
  v5 = v4 >> 1;
  if ( v4 >> 1 )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(a1 + 44);
      v3 = v2;
      if ( *(float *)((*(_DWORD *)(v6 + 4 * v5) << 6) + *(_DWORD *)(a1 + 12) + 32) > (double)v3 )
        break;
      *(_DWORD *)(v6 + 4 * v4) = *(_DWORD *)(v6 + 4 * v5);
      v4 = v5;
      v5 >>= 1;
      if ( !v5 )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 44) + 4 * v4) = a2;
        return;
      }
    }
    *(_DWORD *)(v6 + 4 * v4) = a2;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 44) + 4 * v4) = a2;
  }
}

//----- (1003A9D0) --------------------------------------------------------
int __userpurge sub_1003A9D0@<eax>(int a1@<esi>, int *a2, int a3, int a4)
{
  double v4; // st7@1
  int v5; // ebp@1
  _DWORD *v6; // ebx@2
  int v7; // edi@3
  double v8; // st7@3
  float v9; // eax@5
  float v10; // ecx@5
  float v11; // edx@5
  float v12; // eax@5
  float v13; // ecx@5
  _DWORD *v14; // ebx@9
  int v15; // edi@10
  double v16; // st7@10
  float v17; // edx@12
  float v18; // eax@12
  float v19; // ecx@12
  float v20; // edx@12
  float v21; // eax@12
  int result; // eax@16
  int v23; // [sp+8h] [bp-58h]@2
  int v24; // [sp+8h] [bp-58h]@9
  int v25; // [sp+Ch] [bp-54h]@2
  double v26; // [sp+10h] [bp-50h]@1
  double v27; // [sp+10h] [bp-50h]@8
  float v28; // [sp+18h] [bp-48h]@1
  float v29; // [sp+1Ch] [bp-44h]@1
  float v30; // [sp+20h] [bp-40h]@1
  float v31; // [sp+24h] [bp-3Ch]@1
  float v32; // [sp+28h] [bp-38h]@1
  float v33; // [sp+2Ch] [bp-34h]@1
  float v34; // [sp+30h] [bp-30h]@8
  float v35; // [sp+34h] [bp-2Ch]@8
  float v36; // [sp+38h] [bp-28h]@8
  float v37; // [sp+3Ch] [bp-24h]@8
  float v38; // [sp+40h] [bp-20h]@8
  float v39; // [sp+44h] [bp-1Ch]@8
  float v40; // [sp+48h] [bp-18h]@14
  float v41; // [sp+4Ch] [bp-14h]@14
  float v42; // [sp+50h] [bp-10h]@14
  float v43; // [sp+54h] [bp-Ch]@14
  float v44; // [sp+58h] [bp-8h]@14
  float v45; // [sp+5Ch] [bp-4h]@14

  v4 = 0.0;
  v28 = 0.0;
  v5 = *(_DWORD *)(a1 + 40);
  v29 = 0.0;
  v30 = 0.0;
  v31 = 0.0;
  v32 = 0.0;
  v33 = 0.0;
  v26 = -1.0;
  if ( v5 )
  {
    v6 = *(_DWORD **)(a1 + 36);
    v23 = *a2;
    v25 = v5;
    do
    {
      v7 = v23 + 28 * *v6;
      v8 = sub_1003CC80(a1, v23 + 28 * *v6);
      if ( v26 < v8 )
      {
        v26 = v8;
        if ( &v28 != (float *)v7 )
        {
          v9 = *(float *)(v7 + 4);
          v10 = *(float *)(v7 + 8);
          v28 = *(float *)v7;
          v11 = *(float *)(v7 + 12);
          v29 = v9;
          v12 = *(float *)(v7 + 16);
          v30 = v10;
          v13 = *(float *)(v7 + 20);
          v31 = v11;
          v32 = v12;
          v33 = v13;
        }
      }
      ++v6;
      --v25;
    }
    while ( v25 );
    v4 = 0.0;
  }
  v34 = v4;
  v35 = v4;
  v36 = v4;
  v37 = v4;
  v38 = v4;
  v39 = v4;
  v27 = -1.0;
  if ( v5 )
  {
    v14 = *(_DWORD **)(a1 + 36);
    v24 = *a2;
    do
    {
      v15 = v24 + 28 * *v14;
      v16 = sub_1003CC80((int)&v28, v24 + 28 * *v14);
      if ( v27 < v16 )
      {
        v27 = v16;
        if ( &v34 != (float *)v15 )
        {
          v17 = *(float *)(v15 + 4);
          v18 = *(float *)(v15 + 8);
          v34 = *(float *)v15;
          v19 = *(float *)(v15 + 12);
          v35 = v17;
          v20 = *(float *)(v15 + 16);
          v36 = v18;
          v21 = *(float *)(v15 + 20);
          v37 = v19;
          v38 = v20;
          v39 = v21;
        }
      }
      ++v14;
      --v5;
    }
    while ( v5 );
  }
  v40 = v28 + *(float *)a1;
  v41 = v29 + *(float *)(a1 + 4);
  v42 = v30 + *(float *)(a1 + 8);
  v43 = v31 + *(float *)(a1 + 12);
  v44 = *(float *)(a1 + 16) + v32;
  v45 = v33 + *(float *)(a1 + 20);
  v28 = v40 * 0.5;
  v29 = v41 * 0.5;
  v30 = v42 * 0.5;
  v31 = v43 * 0.5;
  v32 = v44 * 0.5;
  v33 = v45 * 0.5;
  if ( (float *)a3 != &v28 )
  {
    *(float *)a3 = v28;
    *(float *)(a3 + 4) = v29;
    *(float *)(a3 + 8) = v30;
    *(float *)(a3 + 12) = v31;
    *(float *)(a3 + 16) = v32;
    *(float *)(a3 + 20) = v33;
  }
  result = a4;
  v40 = v34 + *(float *)a1;
  v41 = v35 + *(float *)(a1 + 4);
  v42 = v36 + *(float *)(a1 + 8);
  v43 = v37 + *(float *)(a1 + 12);
  v44 = *(float *)(a1 + 16) + v38;
  v45 = v39 + *(float *)(a1 + 20);
  v34 = v40 * 0.5;
  v35 = v41 * 0.5;
  v36 = v42 * 0.5;
  v37 = v43 * 0.5;
  v38 = v44 * 0.5;
  v39 = 0.5 * v45;
  if ( (float *)a4 != &v34 )
  {
    *(float *)a4 = v34;
    *(float *)(a4 + 4) = v35;
    *(float *)(a4 + 8) = v36;
    *(float *)(a4 + 12) = v37;
    *(float *)(a4 + 16) = v38;
    *(float *)(a4 + 20) = v39;
  }
  return result;
}

//----- (1003AC90) --------------------------------------------------------
int __stdcall sub_1003AC90(int *a1, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // ecx@2
  int v6; // eax@2
  int result; // eax@4
  int v8; // eax@8
  int v9; // ecx@8
  double v10; // st7@8
  unsigned int v11; // edi@10
  char *v12; // ecx@10
  unsigned int v13; // esi@10
  double v14; // st5@10
  float *v15; // edx@10
  double v16; // st7@10
  signed int v17; // ebx@10
  unsigned int v18; // eax@11
  double v19; // st7@13
  char *v20; // ecx@15
  double v21; // st7@16
  unsigned int v22; // eax@19
  unsigned int v23; // edi@19
  unsigned int v24; // edx@19
  char *v25; // ebx@19
  float v26; // ST20_4@19
  double v27; // st7@19
  unsigned int v28; // esi@20
  unsigned int v29; // ecx@22
  char *v30; // eax@22
  double v31; // st6@23
  float *v32; // eax@25
  int v33; // ecx@25
  double v34; // st6@26
  int v35; // ebx@28
  unsigned int v36; // esi@28
  unsigned int v37; // edi@29
  unsigned int v38; // edx@31
  char *v39; // eax@31
  char *v40; // ecx@31
  double v41; // st7@32
  float *v42; // ecx@34
  float *v43; // edx@34
  int v44; // eax@34
  double v45; // st7@35
  unsigned int v46; // esi@37
  int v47; // eax@37
  double v48; // st4@38
  float v49; // ST20_4@38
  float v50; // ebx@39
  float v51; // edi@39
  float v52; // esi@39
  unsigned int v53; // edx@39
  char *v54; // ecx@39
  double v55; // st7@39
  double v56; // st6@39
  double v57; // st5@39
  double v58; // st4@39
  double v59; // st3@39
  double i; // st2@39
  long double v61; // rt2@42
  long double v62; // st2@42
  long double v63; // st3@42
  long double v64; // st2@42
  double v65; // st7@46
  float v66; // ST20_4@46
  double v67; // st6@48
  double v68; // st6@48
  double v69; // st6@48
  double v70; // st6@48
  double v71; // st6@48
  double v72; // st6@48
  float v73; // ST24_4@48
  float v74; // ST20_4@48
  float v75; // ST20_4@48
  float v76; // ST20_4@48
  float v77; // ST20_4@48
  float v78; // ST24_4@48
  double v79; // st7@50
  int v80; // eax@50
  int v81; // esi@51
  _DWORD *v82; // edx@51
  double v83; // st3@51
  int v84; // edi@51
  double v85; // rtt@52
  int v86; // ecx@53
  float v87; // ST28_4@53
  float v88; // ST24_4@53
  float v89; // ST20_4@53
  float v90; // ST20_4@53
  float v91; // ST20_4@53
  float v92; // ST20_4@53
  float v93; // ST24_4@53
  double v94; // rt0@53
  double v95; // st3@53
  double v96; // st7@53
  double v97; // st2@53
  double v98; // st1@53
  double v99; // st7@58
  float v100; // ST20_4@59
  float v101; // ST20_4@61
  int v102; // [sp+14h] [bp-140h]@7
  _DWORD *v103; // [sp+18h] [bp-13Ch]@7
  signed int v104; // [sp+18h] [bp-13Ch]@19
  signed int v105; // [sp+18h] [bp-13Ch]@28
  int v106; // [sp+1Ch] [bp-138h]@7
  signed int v107; // [sp+1Ch] [bp-138h]@28
  int v108; // [sp+1Ch] [bp-138h]@39
  float v109; // [sp+20h] [bp-134h]@42
  float v110; // [sp+24h] [bp-130h]@46
  float v111; // [sp+28h] [bp-12Ch]@46
  float v112; // [sp+2Ch] [bp-128h]@46
  float v113; // [sp+30h] [bp-124h]@46
  float v114; // [sp+34h] [bp-120h]@46
  float v115; // [sp+38h] [bp-11Ch]@8
  float v116; // [sp+3Ch] [bp-118h]@8
  float v117; // [sp+40h] [bp-114h]@8
  float v118; // [sp+44h] [bp-110h]@8
  float v119; // [sp+48h] [bp-10Ch]@8
  float v120; // [sp+4Ch] [bp-108h]@8
  float v121; // [sp+50h] [bp-104h]@39
  float v122; // [sp+54h] [bp-100h]@39
  float v123; // [sp+58h] [bp-FCh]@39
  float v124; // [sp+5Ch] [bp-F8h]@39
  float v125; // [sp+60h] [bp-F4h]@39
  float v126; // [sp+64h] [bp-F0h]@39
  double v127; // [sp+68h] [bp-ECh]@19
  double v128; // [sp+70h] [bp-E4h]@10
  float v129; // [sp+78h] [bp-DCh]@48
  float v130; // [sp+7Ch] [bp-D8h]@48
  float v131; // [sp+80h] [bp-D4h]@48
  float v132; // [sp+84h] [bp-D0h]@13
  float v133; // [sp+88h] [bp-CCh]@13
  float v134; // [sp+8Ch] [bp-C8h]@13
  float v135; // [sp+90h] [bp-C4h]@10
  float v136; // [sp+94h] [bp-C0h]@10
  float v137; // [sp+98h] [bp-BCh]@10
  float v138; // [sp+9Ch] [bp-B8h]@10
  float v139; // [sp+A0h] [bp-B4h]@10
  float v140; // [sp+A4h] [bp-B0h]@10
  float v141; // [sp+A8h] [bp-ACh]@54
  float v142; // [sp+ACh] [bp-A8h]@54
  float v143; // [sp+B0h] [bp-A4h]@54
  float v144; // [sp+B4h] [bp-A0h]@54
  float v145; // [sp+B8h] [bp-9Ch]@54
  float v146; // [sp+BCh] [bp-98h]@34
  char v147[4]; // [sp+C0h] [bp-94h]@6
  char v148[40]; // [sp+C4h] [bp-90h]@10
  char v149[104]; // [sp+ECh] [bp-68h]@31

  v4 = *(_DWORD *)(a4 + 40);
  if ( v4 == 2 )
  {
    v5 = *a1;
    v6 = *a1 + 28 * **(_DWORD **)(a4 + 36);
    if ( a2 != v6 )
    {
      *(float *)a2 = *(float *)v6;
      *(float *)(a2 + 4) = *(float *)(v6 + 4);
      *(float *)(a2 + 8) = *(float *)(v6 + 8);
      *(float *)(a2 + 12) = *(float *)(v6 + 12);
      *(float *)(a2 + 16) = *(float *)(v6 + 16);
      *(float *)(a2 + 20) = *(float *)(v6 + 20);
    }
    result = v5 + 28 * *(_DWORD *)(*(_DWORD *)(a4 + 36) + 4);
    if ( a3 != result )
    {
      *(float *)a3 = *(float *)result;
      *(float *)(a3 + 4) = *(float *)(result + 4);
      *(float *)(a3 + 8) = *(float *)(result + 8);
      *(float *)(a3 + 12) = *(float *)(result + 12);
      *(float *)(a3 + 16) = *(float *)(result + 16);
      *(float *)(a3 + 20) = *(float *)(result + 20);
    }
  }
  else
  {
    memset(v147, 0, 0x90u);
    if ( v4 )
    {
      v102 = *a1;
      v103 = *(_DWORD **)(a4 + 36);
      v106 = v4;
      do
      {
        v8 = v102 + 28 * *v103;
        v9 = *(_DWORD *)(v8 + 24);
        v115 = *(float *)(v102 + 28 * *v103) - *(float *)a4;
        v116 = *(float *)(v8 + 4) - *(float *)(a4 + 4);
        v117 = *(float *)(v8 + 8) - *(float *)(a4 + 8);
        v118 = *(float *)(v8 + 12) - *(float *)(a4 + 12);
        v119 = *(float *)(v8 + 16) - *(float *)(a4 + 16);
        v120 = *(float *)(v8 + 20) - *(float *)(a4 + 20);
        v10 = (double)*(signed int *)(v8 + 24);
        if ( v9 < 0 )
          v10 = v10 + 4294967300.0;
        *(float *)&v128 = v10;
        v11 = 0;
        v12 = v148;
        v13 = 0;
        v14 = *(float *)&v128;
        v15 = &v115;
        v16 = v115 * *(float *)&v128;
        LODWORD(v128) = v148;
        v17 = 6;
        v135 = v16;
        v136 = v116 * v14;
        v137 = v117 * v14;
        v138 = v118 * v14;
        v139 = v119 * v14;
        v140 = v14 * v120;
        do
        {
          v18 = v11;
          if ( v11 < 6 )
          {
            if ( v17 >= 4 )
            {
              do
              {
                v19 = *(&v135 + v18);
                v18 += 4;
                v12 += 16;
                *((float *)v12 - 5) = v19 * *v15 + *((float *)v12 - 5);
                *((float *)v12 - 4) = *(&v132 + v18) * *v15 + *((float *)v12 - 4);
                *((float *)v12 - 3) = *(&v133 + v18) * *v15 + *((float *)v12 - 3);
                *((float *)v12 - 2) = *(&v134 + v18) * *v15 + *((float *)v12 - 2);
              }
              while ( v18 < 3 );
            }
            if ( v18 < 6 )
            {
              v20 = &v147[4 * (v13 + v18)];
              do
              {
                v21 = *(&v135 + v18++);
                v20 += 4;
                *((float *)v20 - 1) = v21 * *v15 + *((float *)v20 - 1);
              }
              while ( v18 < 6 );
            }
          }
          v12 = (char *)(LODWORD(v128) + 28);
          v13 += 6;
          ++v11;
          --v17;
          ++v15;
          LODWORD(v128) += 28;
        }
        while ( v13 < 0x24 );
        ++v103;
        --v106;
      }
      while ( v106 );
    }
    v22 = *(_DWORD *)(a4 + 28);
    v23 = 0;
    HIDWORD(v127) = v22 & 0x80000000;
    LODWORD(v127) = 0;
    v24 = 0;
    v25 = v148;
    v104 = 6;
    v26 = 1.0 / (double)__PAIR__(v22, *(_DWORD *)(a4 + 24));
    v27 = v26;
    do
    {
      v28 = v24;
      if ( v24 < 6 )
      {
        if ( v104 >= 4 )
        {
          v29 = ((2 - v24) >> 2) + 1;
          v30 = v25;
          v28 = v24 + 4 * v29;
          do
          {
            v31 = *((float *)v30 - 1);
            v30 += 16;
            --v29;
            *((float *)v30 - 5) = v31 * v27;
            *((float *)v30 - 4) = *((float *)v30 - 4) * v27;
            *((float *)v30 - 3) = *((float *)v30 - 3) * v27;
            *((float *)v30 - 2) = *((float *)v30 - 2) * v27;
          }
          while ( v29 );
        }
        if ( v28 < 6 )
        {
          v32 = (float *)&v147[4 * (v23 + v28)];
          v33 = 6 - v28;
          do
          {
            v34 = *v32;
            ++v32;
            --v33;
            *(v32 - 1) = v34 * v27;
          }
          while ( v33 );
        }
      }
      --v104;
      v23 += 6;
      ++v24;
      v25 += 28;
    }
    while ( v23 < 0x24 );
    v35 = 0;
    v36 = 1;
    v105 = 5;
    v107 = 5;
    do
    {
      v37 = v36;
      if ( v36 < 6 )
      {
        if ( v105 >= 4 )
        {
          v38 = ((2 - v36) >> 2) + 1;
          v39 = &v148[4 * (v36 + v35)];
          v40 = &v149[4 * (v36 + v35)];
          v37 = v36 + 4 * v38;
          do
          {
            v41 = *((float *)v39 - 1);
            v39 += 16;
            *((float *)v40 - 6) = v41;
            v40 += 96;
            --v38;
            *((float *)v40 - 24) = *((float *)v39 - 4);
            *((float *)v40 - 18) = *((float *)v39 - 3);
            *((float *)v40 - 12) = *((float *)v39 - 2);
          }
          while ( v38 );
        }
        if ( v37 < 6 )
        {
          v42 = (float *)&v147[4 * (v35 + v37)];
          v43 = &v146 + v36 + 6 * v37;
          v44 = 6 - v37;
          do
          {
            v45 = *v42;
            ++v42;
            *v43 = v45;
            v43 += 6;
            --v44;
          }
          while ( v44 );
        }
      }
      --v105;
      ++v36;
      v35 += 6;
      --v107;
    }
    while ( v107 );
    v46 = 0;
    v47 = sub_100330F0(1, 5);
    do
    {
      v48 = (double)v46++;
      v49 = v48 * (1.0 / (double)v47);
      *(&v120 + v46) = v49 * 0.5 + 0.75;
    }
    while ( v46 < 6 );
    v50 = v123;
    v51 = v122;
    v52 = v121;
    v108 = 0;
    v115 = v121;
    v53 = 0;
    v54 = v148;
    v116 = v122;
    v55 = v123;
    v117 = v123;
    v56 = v124;
    v118 = v124;
    v57 = v125;
    v119 = v125;
    v58 = v126;
    v120 = v126;
    v59 = 0.0;
    for ( i = 0.0; ; i = v59 )
    {
      while ( 1 )
      {
        v61 = i;
        v62 = v59
            + *((float *)v54 - 1) * v121
            + *(float *)v54 * v122
            + *((float *)v54 + 1) * v55
            + *((float *)v54 + 2) * v56
            + *((float *)v54 + 3) * v57
            + *((float *)v54 + 4) * v58;
        v63 = v61;
        *(&v109 + v53) = v62;
        v64 = fabs(v62);
        if ( v64 >= v61 )
          v63 = v64;
        ++v53;
        v54 += 24;
        if ( v53 >= 6 )
          break;
        i = v63;
        v59 = 0.0;
      }
      if ( 0.0 == v63 )
      {
        v65 = 0.0;
      }
      else
      {
        v65 = 0.0;
        v66 = 1.0 / v63;
        v109 = v109 * v66;
        v110 = v110 * v66;
        v111 = v111 * v66;
        v112 = v112 * v66;
        v113 = v113 * v66;
        v114 = v66 * v114;
      }
      v67 = v115 - v109;
      v115 = v52;
      v129 = v67;
      v52 = v109;
      v68 = v116;
      v116 = v51;
      v51 = v110;
      v121 = v109;
      v122 = v110;
      v130 = v68 - v110;
      v69 = v117;
      v117 = v50;
      v50 = v111;
      v123 = v111;
      v131 = v69 - v111;
      v70 = v118;
      v118 = v124;
      v124 = v112;
      v132 = v70 - v112;
      v71 = v119;
      v119 = v125;
      v125 = v113;
      v133 = v71 - v113;
      v72 = v120;
      v120 = v126;
      v126 = v114;
      v134 = v72 - v114;
      v73 = v129 * v129;
      v74 = v130 * v130 + v73;
      v75 = v131 * v131 + v74;
      v76 = v132 * v132 + v75;
      v77 = v133 * v133 + v76;
      v78 = v134 * v134 + v77;
      if ( v78 < 0.0024999999 )
        break;
      if ( (unsigned int)++v108 >= 0xA )
        break;
      v53 = 0;
      v57 = v125;
      v54 = v148;
      v59 = v65;
      v55 = v123;
      v56 = v124;
      v58 = v126;
    }
    sub_1003DCF0((int)&v121);
    v79 = 0.0;
    v80 = *(_DWORD *)(a4 + 40);
    v109 = 0.0;
    v110 = 0.0;
    v111 = 0.0;
    v112 = 0.0;
    v113 = 0.0;
    v114 = 0.0;
    v115 = 0.0;
    v116 = 0.0;
    v117 = 0.0;
    v118 = 0.0;
    v119 = 0.0;
    v120 = 0.0;
    v128 = 0.0;
    v127 = 0.0;
    if ( !v80 )
      goto LABEL_66;
    v81 = *a1;
    v82 = *(_DWORD **)(a4 + 36);
    v83 = v123;
    v84 = v80;
    while ( 1 )
    {
      v86 = v81 + 28 * *v82;
      v87 = (double)*(unsigned int *)(v81 + 28 * *v82 + 24);
      v129 = *(float *)v86 - *(float *)a4;
      v130 = *(float *)(v86 + 4) - *(float *)(a4 + 4);
      v131 = *(float *)(v86 + 8) - *(float *)(a4 + 8);
      v132 = *(float *)(v86 + 12) - *(float *)(a4 + 12);
      v133 = *(float *)(v86 + 16) - *(float *)(a4 + 16);
      v134 = *(float *)(v86 + 20) - *(float *)(a4 + 20);
      v88 = v121 * v129;
      v89 = v130 * v122 + v88;
      v90 = v89 + v131 * v83;
      v91 = v90 + v132 * v124;
      v92 = v91 + v133 * v125;
      v93 = v92 + v134 * v126;
      v94 = v83;
      v95 = v79;
      v96 = v94;
      v97 = v87;
      v98 = v87 * *(float *)v86;
      if ( v95 <= v93 )
      {
        v135 = v98;
        v136 = *(float *)(v86 + 4) * v97;
        v137 = *(float *)(v86 + 8) * v97;
        v138 = *(float *)(v86 + 12) * v97;
        v139 = *(float *)(v86 + 16) * v97;
        v140 = *(float *)(v86 + 20) * v97;
        v115 = v135 + v115;
        v116 = v136 + v116;
        v117 = v137 + v117;
        v118 = v138 + v118;
        v119 = v139 + v119;
        v120 = v140 + v120;
        v127 = v97 + v127;
      }
      else
      {
        v141 = v98;
        v142 = *(float *)(v86 + 4) * v97;
        v143 = *(float *)(v86 + 8) * v97;
        v144 = *(float *)(v86 + 12) * v97;
        v145 = *(float *)(v86 + 16) * v97;
        v146 = *(float *)(v86 + 20) * v97;
        v109 = v141 + v109;
        v110 = v142 + v110;
        v111 = v143 + v111;
        v112 = v144 + v112;
        v113 = v145 + v113;
        v114 = v146 + v114;
        v128 = v97 + v128;
      }
      ++v82;
      if ( !--v84 )
        break;
      v85 = v95;
      v83 = v96;
      v79 = v85;
    }
    if ( v128 > 0.0 && (v99 = v127, v127 > 0.0) )
    {
      v100 = 1.0 / v128;
      v121 = v100 * v109;
      v122 = v100 * v110;
      v123 = v100 * v111;
      v124 = v100 * v112;
      v125 = v100 * v113;
      v126 = v100 * v114;
      if ( (float *)a2 != &v121 )
      {
        *(float *)a2 = v121;
        *(float *)(a2 + 4) = v122;
        *(float *)(a2 + 8) = v123;
        *(float *)(a2 + 12) = v124;
        *(float *)(a2 + 16) = v125;
        *(float *)(a2 + 20) = v126;
      }
      result = a3;
      v101 = 1.0 / v99;
      v109 = v101 * v115;
      v110 = v101 * v116;
      v111 = v101 * v117;
      v112 = v101 * v118;
      v113 = v101 * v119;
      v114 = v101 * v120;
      if ( (float *)a3 != &v109 )
      {
        *(float *)a3 = v109;
        *(float *)(a3 + 4) = v110;
        *(float *)(a3 + 8) = v111;
        *(float *)(a3 + 12) = v112;
        *(float *)(a3 + 16) = v113;
        *(float *)(a3 + 20) = v114;
      }
    }
    else
    {
LABEL_66:
      result = sub_1003A9D0(a4, a1, a2, a3);
    }
  }
  return result;
}
// 1003AC90: using guessed type char var_94[4];
// 1003AC90: using guessed type char var_90[40];
// 1003AC90: using guessed type char var_68[104];

//----- (1003B760) --------------------------------------------------------
int __usercall sub_1003B760@<eax>(int result@<eax>, int a2@<ebx>)
{
  int v2; // edi@1
  int v3; // edx@5
  int v4; // eax@5
  int i; // ecx@5

  v2 = result;
  if ( result != a2 )
  {
    if ( *(_DWORD *)(result + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003C8F0(result);
      sub_100943C0(*(_DWORD *)(a2 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003B7E0, v2, 0, 0x1Cu, 0);
    }
    else
    {
      sub_10037D10(result, 0);
    }
    v3 = *(_DWORD *)(a2 + 4);
    v4 = *(_DWORD *)v2;
    for ( i = *(_DWORD *)a2; v3; --v3 )
    {
      if ( v4 )
      {
        *(float *)v4 = *(float *)i;
        *(float *)(v4 + 4) = *(float *)(i + 4);
        *(float *)(v4 + 8) = *(float *)(i + 8);
        *(float *)(v4 + 12) = *(float *)(i + 12);
        *(float *)(v4 + 16) = *(float *)(i + 16);
        *(float *)(v4 + 20) = *(float *)(i + 20);
        *(_DWORD *)(v4 + 24) = *(_DWORD *)(i + 24);
      }
      v4 += 28;
      i += 28;
    }
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
    result = v2;
  }
  return result;
}

//----- (1003B7E0) --------------------------------------------------------
int __cdecl sub_1003B7E0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edi@1
  int v5; // ecx@2

  result = a3;
  v4 = a2 + 28 * a3;
  if ( a2 != v4 )
  {
    v5 = a2 + 12;
    result = a1 + 8;
    do
    {
      if ( result != 8 )
      {
        *(float *)(result - 8) = *(float *)(v5 - 12);
        *(float *)(result - 4) = *(float *)(v5 - 8);
        *(float *)result = *(float *)(a2 - a1 + result);
        *(float *)(result + 4) = *(float *)v5;
        *(float *)(result + 8) = *(float *)(v5 + 4);
        *(float *)(result + 12) = *(float *)(v5 + 8);
        *(_DWORD *)(result + 16) = *(_DWORD *)(v5 + 12);
      }
      v5 += 28;
      result += 28;
    }
    while ( v5 - 12 != v4 );
  }
  return result;
}

//----- (1003B850) --------------------------------------------------------
int __stdcall sub_1003B850(int a1, int a2)
{
  int v2; // esi@5
  int v3; // ebx@5
  int i; // edi@5

  if ( a1 != a2 )
  {
    if ( *(_DWORD *)(a1 + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_10039940(a1);
      sub_100943C0(*(_DWORD *)(a2 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003CE50, a1, 0, 0x40u, 0);
    }
    else
    {
      sub_1003B900(a1, 0);
    }
    v2 = *(_DWORD *)a2;
    v3 = *(_DWORD *)(a2 + 4);
    for ( i = *(_DWORD *)a1; v3; --v3 )
    {
      if ( i )
        sub_1003E110(i, v2);
      i += 64;
      v2 += 64;
    }
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  }
  return a1;
}
// 1003CE50: using guessed type int sub_1003CE50();

//----- (1003B900) --------------------------------------------------------
void __usercall sub_1003B900(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int v2; // eax@1

  v2 = *(_DWORD *)(a1 + 4);
  if ( a2 != v2 )
  {
    if ( a2 >= v2 )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003CE50, a1, a2 == v2 + 1, 0x40u, 0);
      sub_1003E580(a2 - *(_DWORD *)(a1 + 4), *(_DWORD *)a1 + (*(_DWORD *)(a1 + 4) << 6));
      *(_DWORD *)(a1 + 4) = a2;
    }
    else
    {
      sub_1004CEA0(v2 - a2, *(_DWORD *)a1 + (a2 << 6));
      *(_DWORD *)(a1 + 4) = a2;
    }
  }
}
// 1003CE50: using guessed type int sub_1003CE50();

//----- (1003B960) --------------------------------------------------------
int __thiscall sub_1003B960(int this, void *a2, int a3, int a4)
{
  char *v4; // ebp@1
  float v5; // edx@2
  char *v6; // edi@2
  char *v7; // ebx@2
  char *v8; // esi@3
  float v9; // ST08_4@3
  int v10; // eax@3
  double v11; // st7@3
  unsigned int v12; // eax@6
  double v13; // st7@6
  double v14; // st6@7
  int v15; // esi@10
  float v16; // ST08_4@10
  unsigned int v17; // edi@10
  unsigned int v18; // esi@10
  float *v19; // edx@10
  char *v20; // ebx@10
  signed int v21; // ebp@10
  unsigned int v22; // eax@11
  char *v23; // ecx@13
  double v24; // st7@14
  char *v25; // ecx@16
  double v26; // st7@17
  double v27; // st7@20
  unsigned int v28; // edx@20
  unsigned int v29; // edi@20
  char *v30; // ebx@20
  signed int v31; // ebp@20
  unsigned int v32; // esi@21
  unsigned int v33; // ecx@23
  char *v34; // eax@23
  double v35; // st6@24
  float *v36; // eax@26
  int v37; // ecx@26
  double v38; // st6@27
  signed int v39; // ebp@29
  int v40; // ebx@29
  unsigned int v41; // esi@29
  unsigned int v42; // edi@30
  unsigned int v43; // edx@32
  char *v44; // eax@32
  char *v45; // ecx@32
  double v46; // st7@33
  float *v47; // ecx@35
  float *v48; // edx@35
  int v49; // eax@35
  double v50; // st7@36
  unsigned int v51; // eax@38
  double v52; // st4@39
  int v53; // esi@40
  int v54; // edi@40
  int v55; // ebx@40
  int v56; // ebp@40
  unsigned int v57; // edx@41
  double v58; // st6@41
  char *v59; // ecx@41
  long double v60; // st5@42
  unsigned int v61; // eax@42
  double v62; // st4@43
  double v63; // st4@43
  long double v64; // st5@44
  float v66; // [sp+8h] [bp-56Ch]@43
  float v67; // [sp+Ch] [bp-568h]@43
  float v68; // [sp+10h] [bp-564h]@43
  float v69; // [sp+14h] [bp-560h]@43
  char *v70; // [sp+18h] [bp-55Ch]@2
  char *v71; // [sp+1Ch] [bp-558h]@3
  float v72; // [sp+20h] [bp-554h]@2
  int v73; // [sp+24h] [bp-550h]@40
  int v74; // [sp+28h] [bp-54Ch]@40
  int v75; // [sp+2Ch] [bp-548h]@40
  int v76; // [sp+30h] [bp-544h]@40
  int v77; // [sp+34h] [bp-540h]@40
  int v78; // [sp+38h] [bp-53Ch]@40
  int v79; // [sp+3Ch] [bp-538h]@40
  int v80; // [sp+40h] [bp-534h]@40
  float v81; // [sp+44h] [bp-530h]@40
  float v82; // [sp+48h] [bp-52Ch]@40
  float v83; // [sp+4Ch] [bp-528h]@40
  float v84; // [sp+50h] [bp-524h]@40
  float v85; // [sp+54h] [bp-520h]@40
  float v86; // [sp+58h] [bp-51Ch]@40
  float v87; // [sp+5Ch] [bp-518h]@40
  float v88; // [sp+60h] [bp-514h]@40
  double v89; // [sp+64h] [bp-510h]@1
  int v90; // [sp+6Ch] [bp-508h]@10
  int v91; // [sp+70h] [bp-504h]@40
  int v92; // [sp+74h] [bp-500h]@40
  int v93; // [sp+78h] [bp-4FCh]@40
  int v94; // [sp+7Ch] [bp-4F8h]@40
  int v95; // [sp+80h] [bp-4F4h]@40
  int v96; // [sp+84h] [bp-4F0h]@40
  int v97; // [sp+88h] [bp-4ECh]@40
  float v98; // [sp+8Ch] [bp-4E8h]@7
  float v99; // [sp+90h] [bp-4E4h]@7
  float v100; // [sp+94h] [bp-4E0h]@7
  float v101; // [sp+98h] [bp-4DCh]@7
  float v102; // [sp+9Ch] [bp-4D8h]@7
  float v103; // [sp+A0h] [bp-4D4h]@7
  float v104; // [sp+A4h] [bp-4D0h]@7
  float v105; // [sp+A8h] [bp-4CCh]@7
  int v106; // [sp+ACh] [bp-4C8h]@1
  int v107; // [sp+B0h] [bp-4C4h]@1
  int v108; // [sp+B4h] [bp-4C0h]@1
  int v109; // [sp+B8h] [bp-4BCh]@1
  int v110; // [sp+BCh] [bp-4B8h]@1
  int v111; // [sp+C0h] [bp-4B4h]@1
  int v112; // [sp+C4h] [bp-4B0h]@1
  int v113; // [sp+C8h] [bp-4ACh]@1
  int v114; // [sp+CCh] [bp-4A8h]@1
  int v115; // [sp+D0h] [bp-4A4h]@1
  int v116; // [sp+D4h] [bp-4A0h]@1
  int v117; // [sp+D8h] [bp-49Ch]@1
  int v118; // [sp+DCh] [bp-498h]@1
  int v119; // [sp+E0h] [bp-494h]@1
  int v120; // [sp+E4h] [bp-490h]@1
  int v121; // [sp+E8h] [bp-48Ch]@1
  int v122; // [sp+ECh] [bp-488h]@10
  int v123; // [sp+F0h] [bp-484h]@49
  int v124; // [sp+F4h] [bp-480h]@49
  int v125; // [sp+F8h] [bp-47Ch]@49
  int v126; // [sp+FCh] [bp-478h]@49
  int v127; // [sp+100h] [bp-474h]@49
  int v128; // [sp+104h] [bp-470h]@49
  int v129; // [sp+108h] [bp-46Ch]@49
  float v130; // [sp+10Ch] [bp-468h]@49
  float v131; // [sp+110h] [bp-464h]@49
  float v132; // [sp+114h] [bp-460h]@49
  float v133; // [sp+118h] [bp-45Ch]@49
  float v134; // [sp+11Ch] [bp-458h]@49
  float v135; // [sp+120h] [bp-454h]@49
  float v136; // [sp+124h] [bp-450h]@49
  float v137; // [sp+128h] [bp-44Ch]@49
  double v138; // [sp+12Ch] [bp-448h]@6
  char v139; // [sp+134h] [bp-440h]@3
  char v140[4]; // [sp+170h] [bp-404h]@35
  char v141[4]; // [sp+174h] [bp-400h]@8
  char v142[120]; // [sp+178h] [bp-3FCh]@10
  char v143[900]; // [sp+1F0h] [bp-384h]@32

  v89 = 0.0;
  v4 = *(char **)(this + 4);
  v106 = 0;
  v107 = 0;
  v108 = 0;
  v109 = 0;
  v110 = 0;
  v111 = 0;
  v112 = 0;
  v113 = 0;
  v114 = 0;
  v115 = 0;
  v116 = 0;
  v117 = 0;
  v118 = 0;
  v119 = 0;
  v120 = 0;
  v121 = 0;
  if ( *(float *)&v4 == 0.0 )
    goto LABEL_55;
  v5 = *(float *)a4;
  v70 = *(char **)this;
  v72 = v5;
  v6 = v70;
  v7 = v4;
  do
  {
    v8 = *(char **)(LODWORD(v72) + 68 * *(_DWORD *)v6 + 64);
    v9 = (double)*(unsigned int *)(LODWORD(v72) + 68 * *(_DWORD *)v6 + 64);
    v10 = sub_1003CDE0((int)&v139, LODWORD(v72) + 68 * *(_DWORD *)v6, v9);
    sub_1003CD10((int)&v106, v10);
    v71 = v8;
    v11 = (double)(unsigned int)v8 + v89;
    v6 += 4;
    --v7;
    v89 = v11;
  }
  while ( v7 );
  if ( 0.0 != v11 )
  {
    v12 = 0;
    v13 = 1.0 / v11;
    v138 = v13;
    do
    {
      v14 = *((float *)&v106 + v12);
      v12 += 8;
      *(&v98 + v12) = v14 * v13;
      *(&v99 + v12) = *(&v99 + v12) * v13;
      *(&v100 + v12) = *(&v100 + v12) * v13;
      *(&v101 + v12) = *(&v101 + v12) * v13;
      *(&v102 + v12) = *(&v102 + v12) * v13;
      *(&v103 + v12) = *(&v103 + v12) * v13;
      *(&v104 + v12) = *(&v104 + v12) * v13;
      *(&v105 + v12) = *(&v105 + v12) * v13;
    }
    while ( v12 < 0x10 );
    memset(v141, 0, 0x400u);
    if ( *(float *)&v4 != 0.0 )
    {
      v71 = v70;
      v70 = v4;
      do
      {
        v15 = LODWORD(v72) + 68 * *(_DWORD *)v71;
        sub_1003DE90(v15, (int)&v90, (int)&v106);
        v16 = (double)*(unsigned int *)(v15 + 64);
        sub_1003CDE0((int)&v122, (int)&v90, v16);
        v17 = 0;
        v18 = 0;
        v19 = (float *)&v90;
        v20 = v142;
        v21 = 16;
        do
        {
          v22 = v17;
          if ( v17 < 0x10 )
          {
            if ( v21 >= 4 )
            {
              v23 = v20;
              do
              {
                v24 = *((float *)&v122 + v22);
                v22 += 4;
                v23 += 16;
                *((float *)v23 - 5) = v24 * *v19 + *((float *)v23 - 5);
                *((float *)v23 - 4) = *((float *)&v119 + v22) * *v19 + *((float *)v23 - 4);
                *((float *)v23 - 3) = *((float *)&v120 + v22) * *v19 + *((float *)v23 - 3);
                *((float *)v23 - 2) = *((float *)&v121 + v22) * *v19 + *((float *)v23 - 2);
              }
              while ( v22 < 0xD );
            }
            if ( v22 < 0x10 )
            {
              v25 = &v141[4 * (v22 + v18)];
              do
              {
                v26 = *((float *)&v122 + v22++);
                v25 += 4;
                *((float *)v25 - 1) = v26 * *v19 + *((float *)v25 - 1);
              }
              while ( v22 < 0x10 );
            }
          }
          v18 += 16;
          ++v17;
          --v21;
          v20 += 68;
          ++v19;
        }
        while ( v18 < 0x100 );
        v71 += 4;
        --v70;
      }
      while ( *(float *)&v70 != 0.0 );
    }
    v27 = v138;
    v28 = 0;
    v29 = 0;
    v30 = v142;
    v31 = 16;
    do
    {
      v32 = v28;
      if ( v28 < 0x10 )
      {
        if ( v31 >= 4 )
        {
          v33 = ((12 - v28) >> 2) + 1;
          v34 = v30;
          v32 = v28 + 4 * v33;
          do
          {
            v35 = *((float *)v34 - 1);
            v34 += 16;
            --v33;
            *((float *)v34 - 5) = v35 * v27;
            *((float *)v34 - 4) = *((float *)v34 - 4) * v27;
            *((float *)v34 - 3) = *((float *)v34 - 3) * v27;
            *((float *)v34 - 2) = *((float *)v34 - 2) * v27;
          }
          while ( v33 );
        }
        if ( v32 < 0x10 )
        {
          v36 = (float *)&v141[4 * (v29 + v32)];
          v37 = 16 - v32;
          do
          {
            v38 = *v36;
            ++v36;
            --v37;
            *(v36 - 1) = v38 * v27;
          }
          while ( v37 );
        }
      }
      v29 += 16;
      ++v28;
      --v31;
      v30 += 68;
    }
    while ( v29 < 0x100 );
    v39 = 15;
    v40 = 0;
    v41 = 1;
    v70 = (char *)15;
    do
    {
      v42 = v41;
      if ( v41 < 0x10 )
      {
        if ( v39 >= 4 )
        {
          v43 = ((12 - v41) >> 2) + 1;
          v44 = &v142[4 * (v41 + v40)];
          v45 = &v143[4 * (v41 + v40)];
          v42 = v41 + 4 * v43;
          do
          {
            v46 = *((float *)v44 - 1);
            v44 += 16;
            *((float *)v45 - 16) = v46;
            v45 += 256;
            --v43;
            *((float *)v45 - 64) = *((float *)v44 - 4);
            *((float *)v45 - 48) = *((float *)v44 - 3);
            *((float *)v45 - 32) = *((float *)v44 - 2);
          }
          while ( v43 );
        }
        if ( v42 < 0x10 )
        {
          v47 = (float *)&v141[4 * (v40 + v42)];
          v48 = (float *)&v140[4 * (v41 + 16 * v42)];
          v49 = 16 - v42;
          do
          {
            v50 = *v47;
            ++v47;
            *v48 = v50;
            v48 += 16;
            --v49;
          }
          while ( v49 );
        }
      }
      --v39;
      ++v41;
      v40 += 16;
      --v70;
    }
    while ( *(float *)&v70 != 0.0 );
    v51 = 0;
    do
    {
      LODWORD(v89) = v51;
      v52 = (double)v51++;
      *(float *)&v70 = v52 * 0.06666667014360428;
      *(&v72 + v51) = *(float *)&v70 * 0.5 + 0.75;
    }
    while ( v51 < 0x10 );
    v53 = v73;
    v54 = v74;
    v55 = v75;
    v56 = v76;
    v94 = v77;
    v95 = v78;
    v96 = v79;
    v97 = v80;
    v98 = v81;
    v99 = v82;
    v100 = v83;
    v101 = v84;
    v102 = v85;
    v90 = v73;
    v91 = v74;
    v92 = v75;
    v93 = v76;
    v103 = v86;
    v104 = v87;
    v105 = v88;
    *(float *)&v70 = 0.0;
    do
    {
      v57 = 0;
      v58 = 0.0;
      v59 = v142;
      do
      {
        v60 = 0.0;
        v61 = 0;
        do
        {
          v62 = *((float *)&v73 + v61);
          v61 += 8;
          v63 = v62 * *((float *)v59 - 1);
          v59 += 32;
          v60 = v60
              + v63
              + *(&v66 + v61) * *((float *)v59 - 8)
              + *(&v67 + v61) * *((float *)v59 - 7)
              + *(&v68 + v61) * *((float *)v59 - 6)
              + *(&v69 + v61) * *((float *)v59 - 5)
              + *(float *)&(&v70)[4 * v61] * *((float *)v59 - 4)
              + *(float *)&(&v71)[4 * v61] * *((float *)v59 - 3)
              + *(&v72 + v61) * *((float *)v59 - 2);
        }
        while ( v61 < 0x10 );
        *((float *)&v122 + v57) = v60;
        v64 = fabs(v60);
        if ( v64 >= v58 )
          v58 = v64;
        ++v57;
      }
      while ( v57 < 0x10 );
      if ( v58 != 0.0 )
      {
        v72 = 1.0 / v58;
        sub_1003CD80((int)&v122, v72);
      }
      sub_1003DE90((int)&v90, (int)&v139, (int)&v122);
      v96 = v79;
      v94 = v77;
      v95 = v78;
      v99 = v82;
      v97 = v80;
      v98 = v81;
      v102 = v85;
      v100 = v83;
      v101 = v84;
      v105 = v88;
      v103 = v86;
      v104 = v87;
      v79 = v128;
      v77 = v126;
      v78 = v127;
      v82 = v131;
      v80 = v129;
      v81 = v130;
      v85 = v134;
      v83 = v132;
      v84 = v133;
      v90 = v53;
      v53 = v122;
      v91 = v54;
      v54 = v123;
      v92 = v55;
      v55 = v124;
      v93 = v56;
      v56 = v125;
      v88 = v137;
      v73 = v122;
      v74 = v123;
      v75 = v124;
      v76 = v125;
      v86 = v135;
      v87 = v136;
      if ( sub_1003DF20((float *)&v139) < 0.0024999999 )
        break;
      ++v70;
    }
    while ( (unsigned int)v70 < 0xA );
    sub_1003E090((float *)&v73);
    sub_10038C30((int)a2, (int)&v73);
  }
  else
  {
LABEL_55:
    memset(a2, 0, 0x40u);
  }
  return sub_10038C30(a3, (int)&v106);
}
// 1003B960: using guessed type char var_400[4];
// 1003B960: using guessed type char var_3FC[120];
// 1003B960: using guessed type char var_384[900];
// 1003B960: using guessed type char var_404[4];

//----- (1003C100) --------------------------------------------------------
void *__userpurge sub_1003C100@<eax>(int a1@<ebx>, int a2@<edi>, float *a3, int a4, _DWORD *a5, int a6)
{
  int v6; // eax@1
  unsigned int v7; // ebp@1
  int v8; // eax@3
  void *result; // eax@5
  int v10; // esi@10
  unsigned int v11; // eax@11
  unsigned int v12; // eax@14
  char v13; // [sp+8h] [bp-44h]@10

  v6 = *(_DWORD *)(a2 + 4);
  v7 = 0;
  if ( v6 )
  {
    if ( !v6 )
      v8 = *(_DWORD *)a2;
    *(_DWORD *)(a2 + 4) = 0;
  }
  result = *(void **)(a1 + 4);
  if ( result )
  {
    if ( (unsigned int)result <= 0 )
      result = memset((void *)(*(_DWORD *)a1 + 4 * (_DWORD)result), 0, -4 * (_DWORD)result);
    *(_DWORD *)(a1 + 4) = 0;
  }
  if ( *(_DWORD *)(a6 + 4) > 0u )
  {
    do
    {
      v10 = *(_DWORD *)(*(_DWORD *)a6 + 4 * v7);
      sub_1003DE90(*a5 + 68 * *(_DWORD *)(*(_DWORD *)a6 + 4 * v7), (int)&v13, a4);
      if ( sub_1003DE10(a3, (float *)&v13) >= 0.0 )
      {
        v12 = *(_DWORD *)(a1 + 4);
        if ( v12 >= *(_DWORD *)(a1 + 8) )
          sub_100943C0(v12 + 1, 0, a1, 1, 4u, 0);
        result = *(void **)a1;
        *(_DWORD *)(*(_DWORD *)a1 + 4 * (*(_DWORD *)(a1 + 4))++) = v10;
      }
      else
      {
        v11 = *(_DWORD *)(a2 + 4);
        if ( v11 >= *(_DWORD *)(a2 + 8) )
          sub_100943C0(v11 + 1, 0, a2, 1, 4u, 0);
        result = *(void **)(a2 + 4);
        *(_DWORD *)(*(_DWORD *)a2 + 4 * (_DWORD)result) = v10;
        ++*(_DWORD *)(a2 + 4);
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)(a6 + 4) );
  }
  return result;
}

//----- (1003C210) --------------------------------------------------------
void __thiscall sub_1003C210(int this)
{
  int v1; // ebx@1
  signed int v2; // esi@1
  unsigned int v3; // eax@1
  unsigned int v4; // edx@1
  bool v5; // cf@2
  unsigned int v6; // eax@7
  float v7; // [sp+8h] [bp-4h]@1

  v1 = *(_DWORD *)(*(_DWORD *)(this + 44) + 4);
  v2 = 1;
  v3 = *(_DWORD *)(this + 56);
  v4 = 2;
  v7 = *(float *)(104 * *(_DWORD *)(*(_DWORD *)(this + 44) + 4) + *(_DWORD *)(this + 12) + 72);
  if ( v3 < 2 )
  {
    *(_DWORD *)(*(_DWORD *)(this + 44) + 4) = v1;
  }
  else
  {
    v5 = v3 > 2;
    while ( 1 )
    {
      if ( v5
        && *(float *)(104 * *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v4 + 4) + *(_DWORD *)(this + 12) + 72) > (double)*(float *)(*(_DWORD *)(this + 12) + 104 * *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v4) + 72) )
      {
        ++v4;
      }
      if ( *(float *)(104 * *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v4) + *(_DWORD *)(this + 12) + 72) < (double)v7 )
        break;
      *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v2) = *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v4);
      v6 = *(_DWORD *)(this + 56);
      v2 = v4;
      v4 *= 2;
      v5 = v4 < v6;
      if ( v4 > v6 )
      {
        *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v2) = v1;
        return;
      }
    }
    *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v2) = v1;
  }
}

//----- (1003C2C0) --------------------------------------------------------
void __usercall sub_1003C2C0(int a1@<eax>, int a2@<ecx>)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v4; // eax@5
  _DWORD *v5; // eax@13
  int v6; // eax@13
  unsigned int v7; // edi@13
  float *v8; // esi@13
  float v9; // ST24_4@13
  unsigned int v10; // eax@14
  float v11; // ST20_4@16
  int v12; // eax@16
  unsigned int v13; // eax@17
  float v14; // ST20_4@19
  int v15; // eax@19
  float v16; // ST4C_4@23
  float v17; // ST24_4@23
  float v18; // ST4C_4@23
  float v19; // ST24_4@23
  int v20; // ebp@30
  int *v21; // edi@30
  unsigned int v22; // eax@30
  unsigned int v23; // esi@30
  int v24; // eax@37
  int v25; // esi@37
  int v26; // edi@37
  int v27; // eax@37
  int v28; // eax@37
  int v29; // eax@37
  bool v30; // cf@37
  bool v31; // zf@37
  int v32; // eax@40
  int v33; // eax@40
  int v34; // eax@40
  float v35; // [sp+14h] [bp-1ACh]@5
  _DWORD *v36; // [sp+14h] [bp-1ACh]@13
  float v37; // [sp+18h] [bp-1A8h]@23
  float v38; // [sp+1Ch] [bp-1A4h]@5
  int v39; // [sp+1Ch] [bp-1A4h]@10
  int v40; // [sp+20h] [bp-1A0h]@1
  unsigned __int64 v41; // [sp+24h] [bp-19Ch]@5
  int v42; // [sp+30h] [bp-190h]@5
  int v43; // [sp+30h] [bp-190h]@30
  unsigned __int64 v44; // [sp+34h] [bp-18Ch]@5
  unsigned int v45; // [sp+44h] [bp-17Ch]@5
  float v46; // [sp+48h] [bp-178h]@5
  double v47; // [sp+4Ch] [bp-174h]@10
  double v48; // [sp+54h] [bp-16Ch]@10
  char v49; // [sp+7Ch] [bp-144h]@10
  char v50; // [sp+BCh] [bp-104h]@10
  char v51; // [sp+FCh] [bp-C4h]@3
  char v52; // [sp+13Ch] [bp-84h]@3
  char v53; // [sp+17Ch] [bp-44h]@16

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 12) + 104 * a1;
  v40 = *(_DWORD *)(a2 + 12) + 104 * a1;
  if ( *(_DWORD *)(v3 + 80) != 1 )
  {
    if ( *(_BYTE *)(a2 + 60) )
      sub_1003D000((int *)a2, (int)&v51, (int)&v52, v3);
    else
      sub_1003D200((int *)a2, (int)&v51, (int)&v52, v3);
    v46 = 1.0e10;
    v38 = 0.0;
    v4 = *(_BYTE *)(v2 + 60) != 0 ? 0xFFFFFFFA : 0;
    v35 = 0.0;
    v44 = 0i64;
    v41 = 0i64;
    v45 = v4 + 8;
    v42 = 0;
    if ( v4 != -8 )
    {
      while ( 1 )
      {
        if ( *(_DWORD *)(v2 + 68) )
          *(_DWORD *)(v2 + 68) = 0;
        if ( *(_DWORD *)(v2 + 80) )
          *(_DWORD *)(v2 + 80) = 0;
        memset(&v49, 0, 0x40u);
        memset(&v50, 0, 0x40u);
        v47 = 0.0;
        v48 = 0.0;
        v44 = 0i64;
        v41 = 0i64;
        v39 = 0;
        if ( *(_DWORD *)(v3 + 80) <= 0u )
          goto LABEL_28;
        while ( 1 )
        {
          v5 = (_DWORD *)(*(_DWORD *)(v3 + 76) + 4 * v39);
          v36 = v5;
          v6 = *v5;
          v7 = *(_DWORD *)(*(_DWORD *)v2 + 68 * v6 + 64);
          v8 = (float *)(*(_DWORD *)v2 + 68 * v6);
          v9 = sub_1003DF90((int)v8, (int)&v51);
          if ( v9 >= sub_1003DF90((int)v8, (int)&v52) )
          {
            v13 = *(_DWORD *)(v2 + 80);
            if ( v13 >= *(_DWORD *)(v2 + 84) )
              sub_100943C0(v13 + 1, 0, v2 + 76, 1, 4u, 0);
            *(_DWORD *)(*(_DWORD *)(v2 + 76) + 4 * (*(_DWORD *)(v2 + 80))++) = *v36;
            v14 = (double)v7;
            v15 = sub_1003CDE0((int)&v53, (int)v8, v14);
            sub_1003CD10((int)&v50, v15);
            v41 += v7;
            v48 = sub_1003DE10(v8, v8) * v14 + v48;
          }
          else
          {
            v10 = *(_DWORD *)(v2 + 68);
            if ( v10 >= *(_DWORD *)(v2 + 72) )
              sub_100943C0(v10 + 1, 0, v2 + 64, 1, 4u, 0);
            *(_DWORD *)(*(_DWORD *)(v2 + 64) + 4 * (*(_DWORD *)(v2 + 68))++) = *v36;
            v11 = (double)v7;
            v12 = sub_1003CDE0((int)&v53, (int)v8, v11);
            sub_1003CD10((int)&v49, v12);
            v44 += v7;
            v47 = sub_1003DE10(v8, v8) * v11 + v47;
          }
          if ( (unsigned int)++v39 >= *(_DWORD *)(v40 + 80) )
            break;
          v3 = v40;
        }
        if ( !v44 || !v41 )
        {
          v3 = v40;
LABEL_28:
          *(_BYTE *)(v3 + 100) = 1;
          return;
        }
        v16 = (double)v44;
        v38 = v47 - sub_1003DE10((float *)&v49, (float *)&v49) / v16;
        v17 = (double)v41;
        v35 = v48 - sub_1003DE10((float *)&v50, (float *)&v50) / v17;
        v18 = 1.0 / v16;
        sub_1003CD80((int)&v49, v18);
        v19 = 1.0 / v17;
        sub_1003CD80((int)&v50, v19);
        sub_10038C30((int)&v51, (int)&v49);
        sub_10038C30((int)&v52, (int)&v50);
        v37 = v35 + v38;
        if ( v37 < 0.0000099999997 || (v46 - v37) / v37 < 0.001249999972060323 )
          break;
        v46 = v35 + v38;
        v3 = v40;
        if ( ++v42 >= v45 )
          goto LABEL_30;
      }
      v3 = v40;
    }
LABEL_30:
    v20 = *(_DWORD *)(v2 + 16);
    *(_DWORD *)(v3 + 88) = v20;
    *(_DWORD *)(v3 + 92) = *(_DWORD *)(v2 + 16) + 1;
    *(_DWORD *)(v3 + 96) = (*(_DWORD *)(v2 + 40))++;
    v21 = (int *)(v2 + 12);
    v43 = v20 + 1;
    v22 = *(_DWORD *)(v2 + 16);
    v23 = *(_DWORD *)(v2 + 16) + 2;
    if ( v23 != v22 )
    {
      if ( v23 >= v22 )
      {
        if ( v23 > *(_DWORD *)(v2 + 20) )
          sub_100943C0(v23, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003E1A0, v2 + 12, v23 == v22 + 1, 0x68u, 0);
        sub_1004D040(v23 - *(_DWORD *)(v2 + 16), (char *)(*v21 + 104 * *(_DWORD *)(v2 + 16)));
      }
      else
      {
        sub_1004CF40(v22 - v23, *v21 + 104 * v23);
      }
      *(_DWORD *)(v2 + 16) = v23;
    }
    v24 = *v21;
    v25 = *v21 + 104 * v20;
    v26 = *v21 + 104 * v43;
    sub_10038C30(v24 + 104 * v20, (int)&v51);
    *(_QWORD *)(v25 + 64) = v44;
    v27 = *(_DWORD *)(v25 + 76);
    *(_DWORD *)(v25 + 76) = *(_DWORD *)(v2 + 64);
    *(_DWORD *)(v2 + 64) = v27;
    v28 = *(_DWORD *)(v25 + 80);
    *(_DWORD *)(v25 + 80) = *(_DWORD *)(v2 + 68);
    *(_DWORD *)(v2 + 68) = v28;
    v29 = *(_DWORD *)(v25 + 84);
    *(_DWORD *)(v25 + 84) = *(_DWORD *)(v2 + 72);
    *(_DWORD *)(v2 + 72) = v29;
    v30 = *(_DWORD *)(v25 + 80) < 1u;
    v31 = *(_DWORD *)(v25 + 80) == 1;
    *(float *)(v25 + 72) = v38;
    if ( !v30 && !v31 && v38 > 0.0 )
      sub_1003CF70(v2, v20);
    sub_10038C30(v26, (int)&v52);
    *(_QWORD *)(v26 + 64) = v41;
    v32 = *(_DWORD *)(v26 + 76);
    *(_DWORD *)(v26 + 76) = *(_DWORD *)(v2 + 76);
    *(_DWORD *)(v2 + 76) = v32;
    v33 = *(_DWORD *)(v26 + 80);
    *(_DWORD *)(v26 + 80) = *(_DWORD *)(v2 + 80);
    *(_DWORD *)(v2 + 80) = v33;
    v34 = *(_DWORD *)(v26 + 84);
    *(_DWORD *)(v26 + 84) = *(_DWORD *)(v2 + 84);
    *(_DWORD *)(v2 + 84) = v34;
    *(float *)(v26 + 72) = v35;
    if ( *(_DWORD *)(v26 + 80) > 1u && v35 > 0.0 )
      sub_1003CF70(v2, v43);
  }
}
// 1003E1A0: using guessed type int sub_1003E1A0();

//----- (1003C840) --------------------------------------------------------
int __stdcall sub_1003C840(int a1, int a2)
{
  int v2; // esi@6
  int v3; // edi@6
  int i; // ebx@6

  if ( a1 != a2 )
  {
    if ( *(_DWORD *)(a1 + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003C8F0(a1);
      sub_100943C0(*(_DWORD *)(a2 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003DD80, a1, 0, 0x44u, 0);
    }
    else if ( *(_DWORD *)(a1 + 4) )
    {
      *(_DWORD *)(a1 + 4) = 0;
    }
    v2 = *(_DWORD *)(a2 + 4);
    v3 = *(_DWORD *)a1;
    for ( i = *(_DWORD *)a2; v2; --v2 )
    {
      if ( v3 )
      {
        sub_1003DDC0(v3, i);
        *(_DWORD *)(v3 + 64) = *(_DWORD *)(i + 64);
      }
      v3 += 68;
      i += 68;
    }
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  }
  return a1;
}

//----- (1003C8F0) --------------------------------------------------------
void __usercall sub_1003C8F0(int a1@<esi>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003C940) --------------------------------------------------------
void __usercall sub_1003C940(int a1@<esi>)
{
  int v1; // eax@2

  if ( *(_DWORD *)a1 )
  {
    sub_1004CF40(*(_DWORD *)(a1 + 4), *(_DWORD *)a1);
    v1 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 )
    {
      if ( v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003C990) --------------------------------------------------------
void __userpurge sub_1003C990(int a1@<esi>, unsigned int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // ecx@1
  int v4; // ebx@6
  int v5; // ecx@6
  int v6; // edx@6
  int v7; // eax@6
  int v8; // [sp+0h] [bp-18h]@4
  int v9; // [sp+4h] [bp-14h]@4
  int v10; // [sp+8h] [bp-10h]@4
  int v11; // [sp+14h] [bp-4h]@4

  v2 = a2;
  v3 = *(_DWORD *)(a1 + 8);
  if ( a2 <= v3 )
  {
    if ( a2 < v3 )
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      if ( *(_DWORD *)(a1 + 4) > a2 )
        v2 = *(_DWORD *)(a1 + 4);
      sub_100943C0(v2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003E1A0, (int)&v8, 0, 0x68u, 0);
      sub_1003DAF0((int)&v8, a1);
      v4 = *(_DWORD *)a1;
      v5 = v9;
      v6 = v10;
      *(_DWORD *)a1 = v8;
      v7 = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a1 + 4) = v5;
      *(_DWORD *)(a1 + 8) = v6;
      v11 = -1;
      if ( v4 )
      {
        sub_1004CF40(v7, v4);
        if ( v4 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003E1A0, a1, 0, 0x68u, 0);
  }
}
// 1003E1A0: using guessed type int sub_1003E1A0();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003CAA0) --------------------------------------------------------
int __usercall sub_1003CAA0@<eax>(_DWORD *a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  int result; // eax@1
  int v4; // eax@2
  void *v5; // edx@2

  result = 0;
  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)(a3 + 8) = 0;
    sub_100943C0(*(_DWORD *)(a2 + 4), 0, a3, 0, 4u, 0);
    v4 = *(_DWORD *)(a2 + 4);
    v5 = *(void **)a3;
    *(_DWORD *)(a3 + 4) = v4;
    memcpy(v5, *(const void **)a2, 4 * v4);
    result = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a3 + 12) = result;
    *(_DWORD *)(a3 + 16) = *a1;
  }
  else
  {
    v10 = *a1;
  }
  return result;
}

//----- (1003CB20) --------------------------------------------------------
void __fastcall sub_1003CB20(unsigned int a1, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // ebx@1
  int v5; // eax@3
  unsigned int i; // ecx@3
  int v7; // edi@5
  int v8; // ecx@5
  int v9; // eax@5
  int v10; // eax@10
  int v11; // edx@10
  int v12; // ecx@10
  int v13; // eax@10
  int v14; // edx@10
  int v15; // eax@10
  int v16; // ecx@10
  int v17; // eax@10
  unsigned int v18; // edx@10
  int v19; // eax@10
  int v20; // [sp+8h] [bp-28h]@3
  int v21; // [sp+Ch] [bp-24h]@3
  int v22; // [sp+10h] [bp-20h]@3
  int v23; // [sp+14h] [bp-1Ch]@3
  int v24; // [sp+1Ch] [bp-14h]@3
  unsigned int v25; // [sp+20h] [bp-10h]@3
  int v26; // [sp+2Ch] [bp-4h]@3
  int j; // [sp+34h] [bp+4h]@5

  v3 = a3;
  v4 = a1;
  if ( a1 >= *(_DWORD *)(a3 + 20) && a1 != *(_DWORD *)(a3 + 4) )
  {
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = 32;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    sub_1003DC70((int)&v20, a1);
    v5 = 0;
    for ( i = v4; i > 1; ++v5 )
      i >>= 1;
    v7 = *(_DWORD *)a3;
    v8 = 32 - v5;
    v9 = *(_DWORD *)a3 + 24 * *(_DWORD *)(a3 + 4);
    v23 = v8;
    v25 = -1;
    for ( j = v9; v7 != v9; v7 += 24 )
    {
      if ( *(_BYTE *)(v7 + 20) )
      {
        sub_1003DC00(v7, (int)&v20);
        if ( v24 == *(_DWORD *)(v3 + 20) )
          break;
        v9 = j;
      }
    }
    v25 = (v4 + 1) >> 1;
    sub_1003C8F0(v3);
    v10 = *(_DWORD *)v3;
    v11 = v21;
    *(_DWORD *)v3 = v20;
    v12 = v22;
    *(_DWORD *)(v3 + 12) = 32;
    v20 = v10;
    v13 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 4) = v11;
    v14 = v23;
    v21 = v13;
    v15 = *(_DWORD *)(v3 + 8);
    *(_DWORD *)(v3 + 8) = v12;
    v16 = v24;
    v22 = v15;
    v17 = *(_DWORD *)(v3 + 12);
    *(_DWORD *)(v3 + 12) = v14;
    v18 = v25;
    v23 = v17;
    v19 = *(_DWORD *)(v3 + 20);
    *(_DWORD *)(v3 + 20) = v16;
    v24 = v19;
    v25 = *(_DWORD *)(v3 + 24);
    *(_DWORD *)(v3 + 24) = v18;
    v26 = -1;
    sub_100388E0((int)&v20);
  }
}

//----- (1003CC80) --------------------------------------------------------
double __usercall sub_1003CC80@<st0>(int a1@<eax>, int a2@<ecx>)
{
  float v2; // ST00_4@1
  float v3; // ST04_4@1
  float v4; // ST00_4@1
  float v5; // ST04_4@1
  float v6; // ST00_4@1
  float v7; // ST04_4@1
  float v8; // ST00_4@1
  float v9; // ST04_4@1
  float v10; // ST00_4@1
  float v11; // ST04_4@1
  float v12; // ST00_4@1

  v2 = *(float *)a2 - *(float *)a1;
  v3 = v2 * v2 + 0.0;
  v4 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
  v5 = v4 * v4 + v3;
  v6 = *(float *)(a2 + 8) - *(float *)(a1 + 8);
  v7 = v6 * v6 + v5;
  v8 = *(float *)(a2 + 12) - *(float *)(a1 + 12);
  v9 = v8 * v8 + v7;
  v10 = *(float *)(a2 + 16) - *(float *)(a1 + 16);
  v11 = v10 * v10 + v9;
  v12 = *(float *)(a2 + 20) - *(float *)(a1 + 20);
  return (float)(v12 * v12 + v11);
}

//----- (1003CD10) --------------------------------------------------------
int __usercall sub_1003CD10@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // esi@1
  signed int v6; // edi@1
  double v7; // st7@2

  v2 = a2;
  v3 = a2 + 12;
  v4 = result + 4;
  v5 = v2 - result;
  v6 = 2;
  do
  {
    v4 += 32;
    v7 = *(float *)(v3 - 12) + *(float *)(v4 - 36);
    v3 += 32;
    --v6;
    *(float *)(v4 - 36) = v7;
    *(float *)(v4 - 32) = *(float *)(v4 + v5 - 32) + *(float *)(v4 - 32);
    *(float *)(v4 - 28) = *(float *)(v3 - 36) + *(float *)(v4 - 28);
    *(float *)(v4 - 24) = *(float *)(v3 - 32) + *(float *)(v4 - 24);
    *(float *)(v4 - 20) = *(float *)(v3 - 28) + *(float *)(v4 - 20);
    *(float *)(v4 - 16) = *(float *)(v3 - 24) + *(float *)(v4 - 16);
    *(float *)(v4 - 12) = *(float *)(v3 - 20) + *(float *)(v4 - 12);
    *(float *)(v4 - 8) = *(float *)(v3 - 16) + *(float *)(v4 - 8);
  }
  while ( v6 );
  return result;
}

//----- (1003CD80) --------------------------------------------------------
int __userpurge sub_1003CD80@<eax>(int result@<eax>, float a2)
{
  double v2; // st7@1
  int v3; // ecx@1
  signed int v4; // edx@1
  double v5; // st6@2

  v2 = a2;
  v3 = result + 8;
  v4 = 2;
  do
  {
    v5 = *(float *)(v3 - 8);
    v3 += 32;
    --v4;
    *(float *)(v3 - 40) = v5 * v2;
    *(float *)(v3 - 36) = v2 * *(float *)(v3 - 36);
    *(float *)(v3 - 32) = *(float *)(v3 - 32) * v2;
    *(float *)(v3 - 28) = *(float *)(v3 - 28) * v2;
    *(float *)(v3 - 24) = *(float *)(v3 - 24) * v2;
    *(float *)(v3 - 20) = *(float *)(v3 - 20) * v2;
    *(float *)(v3 - 16) = v2 * *(float *)(v3 - 16);
    *(float *)(v3 - 12) = *(float *)(v3 - 12) * v2;
  }
  while ( v4 );
  return result;
}

//----- (1003CDE0) --------------------------------------------------------
int __usercall sub_1003CDE0@<eax>(int result@<eax>, int a2@<ecx>, float a3)
{
  double v3; // st7@1
  int v4; // esi@1
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // esi@1
  signed int v8; // edi@1
  double v9; // st6@2

  v3 = a3;
  v4 = a2;
  v5 = a2 + 12;
  v6 = result + 4;
  v7 = v4 - result;
  v8 = 2;
  do
  {
    v6 += 32;
    v9 = *(float *)(v5 - 12) * v3;
    v5 += 32;
    --v8;
    *(float *)(v6 - 36) = v9;
    *(float *)(v6 - 32) = *(float *)(v7 + v6 - 32) * v3;
    *(float *)(v6 - 28) = *(float *)(v5 - 36) * v3;
    *(float *)(v6 - 24) = *(float *)(v5 - 32) * v3;
    *(float *)(v6 - 20) = *(float *)(v5 - 28) * v3;
    *(float *)(v6 - 16) = *(float *)(v5 - 24) * v3;
    *(float *)(v6 - 12) = *(float *)(v5 - 20) * v3;
    *(float *)(v6 - 8) = *(float *)(v5 - 16) * v3;
  }
  while ( v8 );
  return result;
}

//----- (1003CF70) --------------------------------------------------------
void __userpurge sub_1003CF70(int a1@<ebx>, int a2)
{
  double v2; // st7@1
  unsigned int v3; // ebp@1
  float v4; // ST0C_4@4
  unsigned int v5; // ecx@3
  int v6; // edx@4

  v2 = *(float *)(104 * a2 + *(_DWORD *)(a1 + 12) + 72);
  v3 = ++*(_DWORD *)(a1 + 56);
  if ( v3 >= *(_DWORD *)(a1 + 48) )
    sub_100366C0(a1 + 44, v3 + 1);
  v5 = v3 >> 1;
  if ( v3 >> 1 )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(a1 + 44);
      v4 = v2;
      if ( *(float *)(104 * *(_DWORD *)(v6 + 4 * v5) + *(_DWORD *)(a1 + 12) + 72) > (double)v4 )
        break;
      *(_DWORD *)(v6 + 4 * v3) = *(_DWORD *)(v6 + 4 * v5);
      v3 = v5;
      v5 >>= 1;
      if ( !v5 )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 44) + 4 * v3) = a2;
        return;
      }
    }
    *(_DWORD *)(v6 + 4 * v3) = a2;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 44) + 4 * v3) = a2;
  }
}

//----- (1003D000) --------------------------------------------------------
int __stdcall sub_1003D000(int *a1, int a2, int a3, int a4)
{
  int v4; // edi@1
  _DWORD *v5; // esi@2
  int v6; // ebx@3
  double v7; // st7@3
  _DWORD *v8; // esi@7
  int v9; // ebx@7
  int v10; // edi@8
  double v11; // st7@8
  int v12; // eax@11
  int v13; // eax@11
  int v14; // eax@11
  int v15; // eax@11
  int v17; // [sp+18h] [bp-D8h]@2
  int v18; // [sp+18h] [bp-D8h]@7
  double v19; // [sp+1Ch] [bp-D4h]@1
  double v20; // [sp+1Ch] [bp-D4h]@6
  int v21; // [sp+28h] [bp-C8h]@2
  int v22; // [sp+2Ch] [bp-C4h]@1
  int v23; // [sp+30h] [bp-C0h]@1
  int v24; // [sp+34h] [bp-BCh]@1
  int v25; // [sp+38h] [bp-B8h]@1
  int v26; // [sp+3Ch] [bp-B4h]@1
  int v27; // [sp+40h] [bp-B0h]@1
  int v28; // [sp+44h] [bp-ACh]@1
  int v29; // [sp+48h] [bp-A8h]@1
  int v30; // [sp+4Ch] [bp-A4h]@1
  int v31; // [sp+50h] [bp-A0h]@1
  int v32; // [sp+54h] [bp-9Ch]@1
  int v33; // [sp+58h] [bp-98h]@1
  int v34; // [sp+5Ch] [bp-94h]@1
  int v35; // [sp+60h] [bp-90h]@1
  int v36; // [sp+64h] [bp-8Ch]@1
  int v37; // [sp+68h] [bp-88h]@1
  int v38; // [sp+6Ch] [bp-84h]@6
  int v39; // [sp+70h] [bp-80h]@6
  int v40; // [sp+74h] [bp-7Ch]@6
  int v41; // [sp+78h] [bp-78h]@6
  int v42; // [sp+7Ch] [bp-74h]@6
  int v43; // [sp+80h] [bp-70h]@6
  int v44; // [sp+84h] [bp-6Ch]@6
  int v45; // [sp+88h] [bp-68h]@6
  int v46; // [sp+8Ch] [bp-64h]@6
  int v47; // [sp+90h] [bp-60h]@6
  int v48; // [sp+94h] [bp-5Ch]@6
  int v49; // [sp+98h] [bp-58h]@6
  int v50; // [sp+9Ch] [bp-54h]@6
  int v51; // [sp+A0h] [bp-50h]@6
  int v52; // [sp+A4h] [bp-4Ch]@6
  int v53; // [sp+A8h] [bp-48h]@6
  char v54; // [sp+ACh] [bp-44h]@11

  v19 = -1.0;
  v4 = *(_DWORD *)(a4 + 80);
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  if ( v4 )
  {
    v5 = *(_DWORD **)(a4 + 76);
    v17 = *a1;
    v21 = v4;
    do
    {
      v6 = v17 + 68 * *v5;
      v7 = sub_1003DF90(a4, v17 + 68 * *v5);
      if ( v19 < v7 )
      {
        v19 = v7;
        sub_10038C30((int)&v22, v6);
      }
      ++v5;
      --v21;
    }
    while ( v21 );
  }
  v20 = -1.0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v53 = 0;
  if ( v4 )
  {
    v8 = *(_DWORD **)(a4 + 76);
    v18 = *a1;
    v9 = v4;
    do
    {
      v10 = v18 + 68 * *v8;
      v11 = sub_1003DF90((int)&v22, v18 + 68 * *v8);
      if ( v20 < v11 )
      {
        v20 = v11;
        sub_10038C30((int)&v38, v10);
      }
      ++v8;
      --v9;
    }
    while ( v9 );
  }
  v12 = sub_1003E2C0((int)&v22, (int)&v54, a4);
  v13 = sub_1003CDE0((int)&v22, v12, 0.5);
  sub_10038C30(a2, v13);
  v14 = sub_1003E2C0((int)&v38, (int)&v54, a4);
  v15 = sub_1003CDE0((int)&v38, v14, 0.5);
  return sub_10038C30(a3, v15);
}

//----- (1003D200) --------------------------------------------------------
int __stdcall sub_1003D200(int *a1, int a2, int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // esi@1
  int result; // eax@2
  _DWORD *v7; // eax@4
  int v8; // esi@5
  float v9; // ST0C_4@5
  unsigned int v10; // edi@5
  unsigned int v11; // esi@5
  float *v12; // edx@5
  char *v13; // ebp@5
  signed int v14; // ebx@5
  unsigned int v15; // eax@6
  char *v16; // ecx@8
  double v17; // st7@9
  char *v18; // ecx@11
  double v19; // st7@12
  bool v20; // zf@14
  unsigned int v21; // eax@15
  unsigned int v22; // kr00_4@15
  unsigned int v23; // edi@15
  unsigned int v24; // edx@15
  char *v25; // ebx@15
  signed int v26; // ebp@15
  double v27; // st7@15
  unsigned int v28; // esi@16
  unsigned int v29; // ecx@18
  char *v30; // eax@18
  char *v31; // eax@21
  int v32; // ecx@21
  signed int v33; // ebp@24
  int v34; // ebx@24
  unsigned int v35; // esi@24
  unsigned int v36; // edi@25
  unsigned int v37; // edx@27
  char *v38; // eax@27
  char *v39; // ecx@27
  double v40; // st7@28
  float *v41; // ecx@30
  float *v42; // edx@30
  int v43; // eax@30
  double v44; // st7@31
  float v45; // esi@33
  double v46; // st7@33
  double v47; // st4@34
  int v48; // esi@35
  int v49; // edi@35
  int v50; // ebx@35
  int v51; // ebp@35
  unsigned int v52; // edx@36
  double v53; // st6@36
  char *v54; // ecx@36
  long double v55; // st5@37
  unsigned int v56; // eax@37
  double v57; // st4@38
  double v58; // st4@38
  long double v59; // st5@39
  int v60; // ebp@47
  _DWORD *v61; // edi@47
  int v62; // esi@48
  float *v63; // eax@48
  int v64; // eax@49
  int v65; // eax@50
  int v66; // eax@54
  int v67; // eax@54
  float v68; // [sp+10h] [bp-528h]@38
  unsigned int v69; // [sp+14h] [bp-524h]@4
  _DWORD *v70; // [sp+18h] [bp-520h]@4
  double v71; // [sp+1Ch] [bp-51Ch]@4
  double v72; // [sp+24h] [bp-514h]@15
  int v73; // [sp+2Ch] [bp-50Ch]@35
  int v74; // [sp+30h] [bp-508h]@35
  int v75; // [sp+34h] [bp-504h]@35
  int v76; // [sp+38h] [bp-500h]@35
  int v77; // [sp+3Ch] [bp-4FCh]@35
  int v78; // [sp+40h] [bp-4F8h]@35
  int v79; // [sp+44h] [bp-4F4h]@35
  int v80; // [sp+48h] [bp-4F0h]@35
  int v81; // [sp+4Ch] [bp-4ECh]@35
  int v82; // [sp+50h] [bp-4E8h]@35
  int v83; // [sp+54h] [bp-4E4h]@35
  int v84; // [sp+58h] [bp-4E0h]@35
  int v85; // [sp+5Ch] [bp-4DCh]@35
  int v86; // [sp+60h] [bp-4D8h]@35
  int v87; // [sp+64h] [bp-4D4h]@35
  float v88; // [sp+68h] [bp-4D0h]@35
  int v89; // [sp+6Ch] [bp-4CCh]@5
  int v90; // [sp+70h] [bp-4C8h]@35
  int v91; // [sp+74h] [bp-4C4h]@35
  int v92; // [sp+78h] [bp-4C0h]@35
  int v93; // [sp+7Ch] [bp-4BCh]@35
  int v94; // [sp+80h] [bp-4B8h]@35
  int v95; // [sp+84h] [bp-4B4h]@35
  int v96; // [sp+88h] [bp-4B0h]@35
  int v97; // [sp+8Ch] [bp-4ACh]@35
  int v98; // [sp+90h] [bp-4A8h]@35
  int v99; // [sp+94h] [bp-4A4h]@35
  int v100; // [sp+98h] [bp-4A0h]@35
  int v101; // [sp+9Ch] [bp-49Ch]@35
  int v102; // [sp+A0h] [bp-498h]@35
  int v103; // [sp+A4h] [bp-494h]@35
  float v104; // [sp+A8h] [bp-490h]@9
  float v105; // [sp+ACh] [bp-48Ch]@9
  float v106; // [sp+B0h] [bp-488h]@9
  int v107; // [sp+B4h] [bp-484h]@5
  int v108; // [sp+B8h] [bp-480h]@44
  int v109; // [sp+BCh] [bp-47Ch]@44
  int v110; // [sp+C0h] [bp-478h]@44
  int v111; // [sp+C4h] [bp-474h]@44
  int v112; // [sp+C8h] [bp-470h]@44
  int v113; // [sp+CCh] [bp-46Ch]@44
  int v114; // [sp+D0h] [bp-468h]@44
  int v115; // [sp+D4h] [bp-464h]@44
  int v116; // [sp+D8h] [bp-460h]@44
  int v117; // [sp+DCh] [bp-45Ch]@44
  int v118; // [sp+E0h] [bp-458h]@44
  int v119; // [sp+E4h] [bp-454h]@44
  int v120; // [sp+E8h] [bp-450h]@44
  int v121; // [sp+ECh] [bp-44Ch]@44
  float v122; // [sp+F0h] [bp-448h]@44
  char v123; // [sp+F4h] [bp-444h]@44
  char v124[4]; // [sp+130h] [bp-408h]@30
  char v125[4]; // [sp+134h] [bp-404h]@3
  char v126[120]; // [sp+138h] [bp-400h]@5
  char v127[904]; // [sp+1B0h] [bp-388h]@27

  v4 = a4;
  v5 = *(_DWORD *)(a4 + 80);
  if ( v5 == 2 )
  {
    sub_10038C30(a2, *a1 + 68 * **(_DWORD **)(a4 + 76));
    result = sub_10038C30(a3, *a1 + 68 * *(_DWORD *)(*(_DWORD *)(a4 + 76) + 4));
  }
  else
  {
    memset(v125, 0, 0x400u);
    if ( v5 )
    {
      v7 = *(_DWORD **)(a4 + 76);
      LODWORD(v71) = *a1;
      v70 = v7;
      v69 = v5;
      do
      {
        v8 = LODWORD(v71) + 68 * *v70;
        sub_1003DE90(v8, (int)&v89, v4);
        v9 = (double)*(unsigned int *)(v8 + 64);
        sub_1003CDE0((int)&v107, (int)&v89, v9);
        v10 = 0;
        v11 = 0;
        v12 = (float *)&v89;
        v13 = v126;
        v14 = 16;
        do
        {
          v15 = v10;
          if ( v10 < 0x10 )
          {
            if ( v14 >= 4 )
            {
              v16 = v13;
              do
              {
                v17 = *((float *)&v107 + v15);
                v15 += 4;
                v16 += 16;
                *((float *)v16 - 5) = v17 * *v12 + *((float *)v16 - 5);
                *((float *)v16 - 4) = *(&v104 + v15) * *v12 + *((float *)v16 - 4);
                *((float *)v16 - 3) = *(&v105 + v15) * *v12 + *((float *)v16 - 3);
                *((float *)v16 - 2) = *(&v106 + v15) * *v12 + *((float *)v16 - 2);
              }
              while ( v15 < 0xD );
            }
            if ( v15 < 0x10 )
            {
              v18 = &v125[4 * (v11 + v15)];
              do
              {
                v19 = *((float *)&v107 + v15++);
                v18 += 4;
                *((float *)v18 - 1) = v19 * *v12 + *((float *)v18 - 1);
              }
              while ( v15 < 0x10 );
            }
          }
          v11 += 16;
          ++v10;
          --v14;
          v13 += 68;
          ++v12;
        }
        while ( v11 < 0x100 );
        ++v70;
        v20 = v69-- == 1;
        v4 = a4;
      }
      while ( !v20 );
    }
    v21 = *(_DWORD *)(v4 + 68);
    v22 = *(_DWORD *)(v4 + 64);
    v23 = 0;
    HIDWORD(v72) = v21 & 0x80000000;
    LODWORD(v72) = 0;
    v24 = 0;
    v25 = v126;
    v26 = 16;
    *(float *)&v71 = 1.0 / (double)__PAIR__(v21, v22);
    v27 = *(float *)&v71;
    do
    {
      v28 = v24;
      if ( v24 < 0x10 )
      {
        if ( v26 >= 4 )
        {
          v29 = ((12 - v24) >> 2) + 1;
          v30 = v25;
          v28 = v24 + 4 * v29;
          do
          {
            v30 += 16;
            --v29;
            *((float *)v30 - 5) = v27 * *((float *)v30 - 5);
            *((float *)v30 - 4) = v27 * *((float *)v30 - 4);
            *((float *)v30 - 3) = *((float *)v30 - 3) * v27;
            *((float *)v30 - 2) = *((float *)v30 - 2) * v27;
          }
          while ( v29 );
        }
        if ( v28 < 0x10 )
        {
          v31 = &v125[4 * (v23 + v28)];
          v32 = 16 - v28;
          do
          {
            v31 += 4;
            --v32;
            *((float *)v31 - 1) = v27 * *((float *)v31 - 1);
          }
          while ( v32 );
        }
      }
      v23 += 16;
      ++v24;
      --v26;
      v25 += 68;
    }
    while ( v23 < 0x100 );
    v33 = 15;
    v34 = 0;
    v35 = 1;
    v69 = 15;
    do
    {
      v36 = v35;
      if ( v35 < 0x10 )
      {
        if ( v33 >= 4 )
        {
          v37 = ((12 - v35) >> 2) + 1;
          v38 = &v126[4 * (v35 + v34)];
          v39 = &v127[4 * (v35 + v34)];
          v36 = v35 + 4 * v37;
          do
          {
            v40 = *((float *)v38 - 1);
            v38 += 16;
            *((float *)v39 - 16) = v40;
            v39 += 256;
            --v37;
            *((float *)v39 - 64) = *((float *)v38 - 4);
            *((float *)v39 - 48) = *((float *)v38 - 3);
            *((float *)v39 - 32) = *((float *)v38 - 2);
          }
          while ( v37 );
        }
        if ( v36 < 0x10 )
        {
          v41 = (float *)&v125[4 * (v34 + v36)];
          v42 = (float *)&v124[4 * (v35 + 16 * v36)];
          v43 = 16 - v36;
          do
          {
            v44 = *v41;
            ++v41;
            *v42 = v44;
            v42 += 16;
            --v43;
          }
          while ( v43 );
        }
      }
      --v33;
      ++v35;
      v34 += 16;
      --v69;
    }
    while ( v69 );
    v45 = 0.0;
    v46 = 1.0 / (double)sub_100330F0(1, 15);
    do
    {
      v106 = v45;
      v47 = (double)LODWORD(v45);
      ++LODWORD(v45);
      *(float *)&v71 = v47 * v46;
      *((float *)&v72 + LODWORD(v45) + 1) = *(float *)&v71 * 0.5 + 0.75;
    }
    while ( LODWORD(v45) < 0x10 );
    v48 = v73;
    v49 = v74;
    v50 = v75;
    v51 = v76;
    v93 = v77;
    v94 = v78;
    v95 = v79;
    v96 = v80;
    v97 = v81;
    v98 = v82;
    v99 = v83;
    v100 = v84;
    v101 = v85;
    v89 = v73;
    v90 = v74;
    v91 = v75;
    v92 = v76;
    v102 = v86;
    v103 = v87;
    v104 = v88;
    v69 = 0;
    do
    {
      v52 = 0;
      v53 = 0.0;
      v54 = v126;
      do
      {
        v55 = 0.0;
        v56 = 0;
        do
        {
          v57 = *((float *)&v73 + v56);
          v56 += 8;
          v58 = v57 * *((float *)v54 - 1);
          v54 += 32;
          v55 = v55
              + v58
              + *(&v68 + v56) * *((float *)v54 - 8)
              + *((float *)&v69 + v56) * *((float *)v54 - 7)
              + *(float *)&(&v70)[v56] * *((float *)v54 - 6)
              + *((float *)&v71 + v56) * *((float *)v54 - 5)
              + *((float *)&v71 + v56 + 1) * *((float *)v54 - 4)
              + *((float *)&v72 + v56) * *((float *)v54 - 3)
              + *((float *)&v72 + v56 + 1) * *((float *)v54 - 2);
        }
        while ( v56 < 0x10 );
        *((float *)&v107 + v52) = v55;
        v59 = fabs(v55);
        if ( v59 >= v53 )
          v53 = v59;
        ++v52;
      }
      while ( v52 < 0x10 );
      if ( v53 != 0.0 )
      {
        *(float *)&v71 = 1.0 / v53;
        sub_1003CD80((int)&v107, *(float *)&v71);
      }
      sub_1003DE90((int)&v89, (int)&v123, (int)&v107);
      v93 = v77;
      v94 = v78;
      v95 = v79;
      v96 = v80;
      v97 = v81;
      v98 = v82;
      v99 = v83;
      v100 = v84;
      v101 = v85;
      v102 = v86;
      v103 = v87;
      v104 = v88;
      v77 = v111;
      v78 = v112;
      v79 = v113;
      v80 = v114;
      v81 = v115;
      v82 = v116;
      v83 = v117;
      v84 = v118;
      v85 = v119;
      v89 = v48;
      v48 = v107;
      v90 = v49;
      v49 = v108;
      v91 = v50;
      v50 = v109;
      v92 = v51;
      v51 = v110;
      v86 = v120;
      v73 = v107;
      v74 = v108;
      v75 = v109;
      v76 = v110;
      v87 = v121;
      v88 = v122;
      if ( sub_1003DF20((float *)&v123) < 0.0024999999 )
        break;
      ++v69;
    }
    while ( v69 < 0xA );
    sub_1003E090((float *)&v73);
    v71 = 0.0;
    *(float *)&v107 = 0.0;
    v72 = 0.0;
    v108 = 0;
    v109 = 0;
    v110 = 0;
    v111 = 0;
    v112 = 0;
    v113 = 0;
    v114 = 0;
    v115 = 0;
    v116 = 0;
    v117 = 0;
    v118 = 0;
    v119 = 0;
    v120 = 0;
    v121 = 0;
    v122 = 0.0;
    v89 = 0;
    v90 = 0;
    v91 = 0;
    v92 = 0;
    v93 = 0;
    v94 = 0;
    v95 = 0;
    v96 = 0;
    v97 = 0;
    v98 = 0;
    v99 = 0;
    v100 = 0;
    v101 = 0;
    v102 = 0;
    v103 = 0;
    v104 = 0.0;
    if ( !*(_DWORD *)(a4 + 80) )
      goto LABEL_58;
    v60 = *a1;
    v61 = *(_DWORD **)(a4 + 76);
    v69 = *(_DWORD *)(a4 + 80);
    do
    {
      v62 = v60 + 68 * *v61;
      *(float *)&v70 = (double)*(unsigned int *)(v60 + 68 * *v61 + 64);
      v63 = (float *)sub_1003DE90(v62, (int)&v123, a4);
      if ( sub_1003DE10((float *)&v73, v63) >= 0.0 )
      {
        v65 = sub_1003CDE0((int)&v123, v62, *(float *)&v70);
        sub_1003CD10((int)&v89, v65);
        v72 = *(float *)&v70 + v72;
      }
      else
      {
        v64 = sub_1003CDE0((int)&v123, v62, *(float *)&v70);
        sub_1003CD10((int)&v107, v64);
        v71 = *(float *)&v70 + v71;
      }
      ++v61;
      --v69;
    }
    while ( v69 );
    if ( v71 > 0.0 && v72 > 0.0 )
    {
      *(float *)&v71 = 1.0 / v71;
      v66 = sub_1003CDE0((int)&v123, (int)&v107, *(float *)&v71);
      sub_10038C30(a2, v66);
      *(float *)&v71 = 1.0 / v72;
      v67 = sub_1003CDE0((int)&v123, (int)&v89, *(float *)&v71);
      result = sub_10038C30(a3, v67);
    }
    else
    {
LABEL_58:
      result = sub_1003D000(a1, a2, a3, a4);
    }
  }
  return result;
}
// 1003D200: using guessed type char var_404[4];
// 1003D200: using guessed type char var_400[120];
// 1003D200: using guessed type char var_388[904];
// 1003D200: using guessed type char var_408[4];

//----- (1003DAF0) --------------------------------------------------------
int __stdcall sub_1003DAF0(int a1, int a2)
{
  int v2; // esi@5
  int v3; // ebx@5
  int i; // edi@5

  if ( a1 != a2 )
  {
    if ( *(_DWORD *)(a1 + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003C940(a1);
      sub_100943C0(*(_DWORD *)(a2 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003E1A0, a1, 0, 0x68u, 0);
    }
    else
    {
      sub_1003DBA0(a1, 0);
    }
    v2 = *(_DWORD *)a2;
    v3 = *(_DWORD *)(a2 + 4);
    for ( i = *(_DWORD *)a1; v3; --v3 )
    {
      if ( i )
        sub_1003E350(i, v2);
      i += 104;
      v2 += 104;
    }
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  }
  return a1;
}
// 1003E1A0: using guessed type int sub_1003E1A0();

//----- (1003DBA0) --------------------------------------------------------
void __usercall sub_1003DBA0(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int v2; // eax@1

  v2 = *(_DWORD *)(a1 + 4);
  if ( a2 != v2 )
  {
    if ( a2 >= v2 )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003E1A0, a1, a2 == v2 + 1, 0x68u, 0);
      sub_1004D040(a2 - *(_DWORD *)(a1 + 4), (char *)(*(_DWORD *)a1 + 104 * *(_DWORD *)(a1 + 4)));
      *(_DWORD *)(a1 + 4) = a2;
    }
    else
    {
      sub_1004CF40(v2 - a2, *(_DWORD *)a1 + 104 * a2);
      *(_DWORD *)(a1 + 4) = a2;
    }
  }
}
// 1003E1A0: using guessed type int sub_1003E1A0();

//----- (1003DC00) --------------------------------------------------------
unsigned int __usercall sub_1003DC00@<eax>(int a1@<edx>, int a2@<esi>)
{
  unsigned int result; // eax@1
  int v3; // ecx@1

  result = (unsigned int)(-1640531527 * *(_DWORD *)(a1 + 12)) >> *(_DWORD *)(a2 + 12);
  v3 = *(_DWORD *)a2 + 24 * result;
  if ( *(_BYTE *)(v3 + 20) )
  {
    while ( 1 )
    {
      if ( result )
      {
        --result;
        v3 -= 24;
      }
      else
      {
        result = *(_DWORD *)(a2 + 4) - 1;
        v3 = *(_DWORD *)a2 + 24 * result;
      }
      if ( result == (unsigned int)(-1640531527 * *(_DWORD *)(a1 + 12)) >> *(_DWORD *)(a2 + 12) )
        break;
      if ( !*(_BYTE *)(v3 + 20) )
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    *(_DWORD *)v3 = *(_DWORD *)a1;
    *(_DWORD *)(v3 + 4) = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(v3 + 8) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(v3 + 12) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(v3 + 16) = *(_DWORD *)(a1 + 16);
    result = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(v3 + 20) = result;
    *(_BYTE *)(a1 + 20) = 0;
    ++*(_DWORD *)(a2 + 20);
  }
  return result;
}

//----- (1003DC70) --------------------------------------------------------
void __usercall sub_1003DC70(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int v2; // eax@1
  int v3; // edx@6
  int v4; // eax@6
  int i; // ecx@6

  v2 = *(_DWORD *)(a1 + 4);
  if ( a2 != v2 )
  {
    if ( a2 >= v2 )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, sub_1003E3D0, a1, a2 == v2 + 1, 0x18u, 0);
      v3 = *(_DWORD *)(a1 + 4);
      v4 = *(_DWORD *)a1 + 24 * v3;
      for ( i = v4 + 24 * (a2 - v3); v4 != i; v4 += 24 )
      {
        if ( v4 )
          *(_BYTE *)(v4 + 20) = 0;
      }
      *(_DWORD *)(a1 + 4) = a2;
    }
    else
    {
      sub_1003E530(v2 - a2, *(_DWORD *)a1 + 24 * a2);
      *(_DWORD *)(a1 + 4) = a2;
    }
  }
}

//----- (1003DCF0) --------------------------------------------------------
double __usercall sub_1003DCF0@<st0>(int a1@<esi>)
{
  double result; // st7@1
  float v2; // ST04_4@2

  result = *(float *)(a1 + 16) * *(float *)(a1 + 16)
         + *(float *)(a1 + 8) * *(float *)(a1 + 8)
         + *(float *)a1 * *(float *)a1
         + *(float *)(a1 + 4) * *(float *)(a1 + 4)
         + *(float *)(a1 + 12) * *(float *)(a1 + 12)
         + *(float *)(a1 + 20) * *(float *)(a1 + 20);
  if ( 0.0 != result )
  {
    v2 = 1.0 / sqrt(result);
    *(float *)a1 = *(float *)a1 * v2;
    *(float *)(a1 + 4) = *(float *)(a1 + 4) * v2;
    *(float *)(a1 + 8) = v2 * *(float *)(a1 + 8);
    *(float *)(a1 + 12) = *(float *)(a1 + 12) * v2;
    *(float *)(a1 + 16) = v2 * *(float *)(a1 + 16);
    *(float *)(a1 + 20) = v2 * *(float *)(a1 + 20);
  }
  return result;
}

//----- (1003DD80) --------------------------------------------------------
int __cdecl sub_1003DD80(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // edi@2

  result = a3;
  v4 = a2;
  v5 = a2 + 68 * a3;
  if ( a2 != v5 )
  {
    v6 = a1 - a2;
    do
    {
      result = v6 + v4;
      if ( v6 + v4 )
      {
        result = sub_1003DDC0(result, v4);
        *(_DWORD *)(v6 + v4 + 64) = *(_DWORD *)(v4 + 64);
      }
      v4 += 68;
    }
    while ( v4 != v5 );
  }
  return result;
}

//----- (1003DDC0) --------------------------------------------------------
int __usercall sub_1003DDC0@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // esi@1
  signed int v6; // edi@1

  v2 = a2;
  v3 = a2 + 12;
  v4 = result + 4;
  v5 = v2 - result;
  v6 = 2;
  do
  {
    v4 += 32;
    *(float *)(v4 - 36) = *(float *)(v3 - 12);
    v3 += 32;
    --v6;
    *(float *)(v4 - 32) = *(float *)(v5 + v4 - 32);
    *(float *)(v4 - 28) = *(float *)(v3 - 36);
    *(float *)(v4 - 24) = *(float *)(v3 - 32);
    *(float *)(v4 - 20) = *(float *)(v3 - 28);
    *(float *)(v4 - 16) = *(float *)(v3 - 24);
    *(float *)(v4 - 12) = *(float *)(v3 - 20);
    *(float *)(v4 - 8) = *(float *)(v3 - 16);
  }
  while ( v6 );
  return result;
}

//----- (1003DE10) --------------------------------------------------------
double __usercall sub_1003DE10@<st0>(float *a1@<eax>, float *a2@<edx>)
{
  float *v2; // esi@1
  double v3; // st7@1
  int v4; // ecx@1
  int v5; // eax@1
  int v6; // edx@1
  signed int v7; // esi@1
  double v8; // st7@2
  double v9; // st7@2
  float v10; // ST04_4@2
  float v11; // ST04_4@2
  float v12; // ST04_4@2
  float v13; // ST04_4@2
  float v15; // [sp+4h] [bp-4h]@1

  v2 = a1;
  v3 = *a2 * *a1;
  v4 = (int)(a2 + 4);
  v5 = (int)(a1 + 2);
  v6 = (char *)a2 - (char *)v2;
  v15 = v3;
  v7 = 3;
  do
  {
    v8 = *(float *)(v5 - 4);
    v5 += 20;
    v9 = v8 * *(float *)(v4 - 12);
    v4 += 20;
    --v7;
    v10 = v9 + v15;
    v11 = v10 + *(float *)(v6 + v5 - 20) * *(float *)(v5 - 20);
    v12 = v11 + *(float *)(v5 - 16) * *(float *)(v4 - 24);
    v13 = v12 + *(float *)(v5 - 12) * *(float *)(v4 - 20);
    v15 = v13 + *(float *)(v5 - 8) * *(float *)(v4 - 16);
  }
  while ( v7 );
  return v15;
}

//----- (1003DE90) --------------------------------------------------------
int __usercall sub_1003DE90@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // ebp@1
  int v7; // esi@1
  signed int v8; // eax@1
  double v9; // st7@2

  v3 = a2 + 8;
  v4 = a3 + 4;
  v5 = a1 - a3;
  v6 = a1 - a2;
  v7 = a1 + 16;
  v8 = 2;
  do
  {
    v4 += 32;
    v9 = *(float *)(v7 - 16) - *(float *)(v4 - 36);
    v3 += 32;
    v7 += 32;
    --v8;
    *(float *)(v3 - 40) = v9;
    *(float *)(v4 + a2 - a3 - 32) = *(float *)(v4 + v5 - 32) - *(float *)(v4 - 32);
    *(float *)(v3 - 32) = *(float *)(v3 + v6 - 32) - *(float *)(v4 - 28);
    *(float *)(v3 - 28) = *(float *)(v7 - 36) - *(float *)(v4 - 24);
    *(float *)(v3 - 24) = *(float *)(v7 - 32) - *(float *)(v4 - 20);
    *(float *)(v3 - 20) = *(float *)(v7 - 28) - *(float *)(v4 - 16);
    *(float *)(v3 - 16) = *(float *)(v7 - 24) - *(float *)(v4 - 12);
    *(float *)(v3 - 12) = *(float *)(v7 - 20) - *(float *)(v4 - 8);
  }
  while ( v8 );
  return a2;
}

//----- (1003DF20) --------------------------------------------------------
double __usercall sub_1003DF20@<st0>(float *a1@<eax>)
{
  double v1; // st7@1
  int v2; // eax@1
  signed int v3; // ecx@1
  double v4; // st7@2
  float v5; // ST00_4@2
  float v6; // ST00_4@2
  float v7; // ST00_4@2
  float v8; // ST00_4@2
  float v10; // [sp+0h] [bp-4h]@1

  v1 = *a1;
  v2 = (int)(a1 + 3);
  v3 = 3;
  v10 = v1 * v1;
  do
  {
    v4 = *(float *)(v2 - 8);
    v2 += 20;
    --v3;
    v5 = v4 * v4 + v10;
    v6 = *(float *)(v2 - 24) * *(float *)(v2 - 24) + v5;
    v7 = *(float *)(v2 - 20) * *(float *)(v2 - 20) + v6;
    v8 = *(float *)(v2 - 16) * *(float *)(v2 - 16) + v7;
    v10 = *(float *)(v2 - 12) * *(float *)(v2 - 12) + v8;
  }
  while ( v3 );
  return v10;
}

//----- (1003DF90) --------------------------------------------------------
double __usercall sub_1003DF90@<st0>(int a1@<eax>, int a2@<edx>)
{
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // eax@1
  int v5; // edx@1
  signed int v6; // esi@1
  double v7; // st7@2
  float v8; // ST08_4@2
  float v9; // ST04_4@2
  float v10; // ST08_4@2
  float v11; // ST04_4@2
  float v12; // ST08_4@2
  float v13; // ST04_4@2
  float v14; // ST08_4@2
  float v15; // ST04_4@2
  float v16; // ST08_4@2
  float v17; // ST04_4@2
  float v18; // ST08_4@2
  float v19; // ST04_4@2
  float v20; // ST08_4@2
  float v21; // ST04_4@2
  float v22; // ST08_4@2
  float v24; // [sp+4h] [bp-8h]@1

  v2 = a1;
  v24 = 0.0;
  v3 = a2 + 12;
  v4 = a1 + 4;
  v5 = a2 - v2;
  v6 = 2;
  do
  {
    v4 += 32;
    v7 = *(float *)(v3 - 12) - *(float *)(v4 - 36);
    v3 += 32;
    --v6;
    v8 = v7;
    v9 = v8 * v8 + v24;
    v10 = *(float *)(v5 + v4 - 32) - *(float *)(v4 - 32);
    v11 = v10 * v10 + v9;
    v12 = *(float *)(v3 - 36) - *(float *)(v4 - 28);
    v13 = v12 * v12 + v11;
    v14 = *(float *)(v3 - 32) - *(float *)(v4 - 24);
    v15 = v14 * v14 + v13;
    v16 = *(float *)(v3 - 28) - *(float *)(v4 - 20);
    v17 = v16 * v16 + v15;
    v18 = *(float *)(v3 - 24) - *(float *)(v4 - 16);
    v19 = v18 * v18 + v17;
    v20 = *(float *)(v3 - 20) - *(float *)(v4 - 12);
    v21 = v20 * v20 + v19;
    v22 = *(float *)(v3 - 16) - *(float *)(v4 - 8);
    v24 = v22 * v22 + v21;
  }
  while ( v6 );
  return v24;
}

//----- (1003E090) --------------------------------------------------------
double __usercall sub_1003E090@<st0>(float *a1@<esi>)
{
  double result; // st7@1
  int v2; // eax@1
  signed int v3; // ecx@1
  double v4; // st6@2
  float v5; // ST08_4@4

  result = *a1 * *a1;
  v2 = (int)(a1 + 3);
  v3 = 3;
  do
  {
    v4 = *(float *)(v2 - 8);
    v2 += 20;
    --v3;
    result = *(float *)(v2 - 16) * *(float *)(v2 - 16)
           + *(float *)(v2 - 24) * *(float *)(v2 - 24)
           + result
           + v4 * v4
           + *(float *)(v2 - 20) * *(float *)(v2 - 20)
           + *(float *)(v2 - 12) * *(float *)(v2 - 12);
  }
  while ( v3 );
  if ( 0.0 != result )
  {
    v5 = 1.0 / sqrt(result);
    sub_1003CD80((int)a1, v5);
  }
  return result;
}

//----- (1003E110) --------------------------------------------------------
int __usercall sub_1003E110@<eax>(int a1@<edi>, int a2@<esi>)
{
  int v2; // ebx@1
  int v3; // eax@1
  void *v4; // ecx@1

  *(float *)a1 = *(float *)a2;
  v2 = a1 + 36;
  *(float *)(a1 + 4) = *(float *)(a2 + 4);
  *(float *)(a1 + 8) = *(float *)(a2 + 8);
  *(float *)(a1 + 12) = *(float *)(a2 + 12);
  *(float *)(a1 + 16) = *(float *)(a2 + 16);
  *(float *)(a1 + 20) = *(float *)(a2 + 20);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(float *)(a1 + 32) = *(float *)(a2 + 32);
  *(_DWORD *)v2 = 0;
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  sub_100943C0(*(_DWORD *)(a2 + 40), 0, a1 + 36, 0, 4u, 0);
  v3 = *(_DWORD *)(a2 + 40);
  v4 = *(void **)(a1 + 36);
  *(_DWORD *)(a1 + 40) = v3;
  memcpy(v4, *(const void **)(a2 + 36), 4 * v3);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_BYTE *)(a1 + 60) = *(_BYTE *)(a2 + 60);
  return a1;
}

//----- (1003E2C0) --------------------------------------------------------
int __usercall sub_1003E2C0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // ebp@1
  int v7; // esi@1
  signed int v8; // eax@1
  double v9; // st7@2
  double v10; // st7@2

  v3 = a2 + 8;
  v4 = a3 + 4;
  v5 = a1 - a3;
  v6 = a1 - a2;
  v7 = a1 + 16;
  v8 = 2;
  do
  {
    v9 = *(float *)(v4 - 4);
    v4 += 32;
    v10 = v9 + *(float *)(v7 - 16);
    v3 += 32;
    v7 += 32;
    --v8;
    *(float *)(v3 - 40) = v10;
    *(float *)(v4 + a2 - a3 - 32) = *(float *)(v4 + v5 - 32) + *(float *)(v4 - 32);
    *(float *)(v3 - 32) = *(float *)(v3 + v6 - 32) + *(float *)(v4 - 28);
    *(float *)(v3 - 28) = *(float *)(v4 - 24) + *(float *)(v7 - 36);
    *(float *)(v3 - 24) = *(float *)(v4 - 20) + *(float *)(v7 - 32);
    *(float *)(v3 - 20) = *(float *)(v4 - 16) + *(float *)(v7 - 28);
    *(float *)(v3 - 16) = *(float *)(v4 - 12) + *(float *)(v7 - 24);
    *(float *)(v3 - 12) = *(float *)(v4 - 8) + *(float *)(v7 - 20);
  }
  while ( v8 );
  return a2;
}

//----- (1003E350) --------------------------------------------------------
int __usercall sub_1003E350@<eax>(int a1@<edi>, int a2@<esi>)
{
  int v2; // ebx@1
  int v3; // eax@1
  void *v4; // ecx@1

  sub_1003DDC0(a1, a2);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  *(float *)(a1 + 72) = *(float *)(a2 + 72);
  v2 = a1 + 76;
  *(_DWORD *)v2 = 0;
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  sub_100943C0(*(_DWORD *)(a2 + 80), 0, a1 + 76, 0, 4u, 0);
  v3 = *(_DWORD *)(a2 + 80);
  v4 = *(void **)(a1 + 76);
  *(_DWORD *)(a1 + 80) = v3;
  memcpy(v4, *(const void **)(a2 + 76), 4 * v3);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(a1 + 92) = *(_DWORD *)(a2 + 92);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a2 + 96);
  *(_BYTE *)(a1 + 100) = *(_BYTE *)(a2 + 100);
  return a1;
}

//----- (1003E3D0) --------------------------------------------------------
void __cdecl sub_1003E3D0(int a1, int a2, int a3)
{
  int v3; // ebp@1
  int v4; // edi@2
  int v5; // esi@2
  int v6; // ebx@2
  unsigned int v7; // eax@5
  int v8; // eax@8
  int v9; // [sp+20h] [bp+Ch]@1

  v3 = a2 + 24 * a3;
  v9 = v3;
  if ( a2 != v3 )
  {
    v4 = a1 + 12;
    v5 = a2 + 4;
    v6 = a1 - a2;
    do
    {
      if ( v4 != 12 )
      {
        if ( *(_BYTE *)(v5 + 16) )
        {
          *(_DWORD *)(v4 - 12) = 0;
          *(_DWORD *)(v6 + v5) = 0;
          *(_DWORD *)(v4 - 4) = 0;
          sub_100943C0(*(_DWORD *)v5, 0, v4 - 12, 0, 4u, 0);
          v7 = *(_DWORD *)v5;
          *(_DWORD *)(v6 + v5) = *(_DWORD *)v5;
          memcpy(*(void **)(v4 - 12), *(const void **)(v5 - 4), 4 * v7);
          v3 = v9;
          *(_DWORD *)v4 = *(_DWORD *)(v5 + 8);
          *(_DWORD *)(v4 + 4) = *(_DWORD *)(v5 + 12);
          *(_BYTE *)(v4 + 8) = 1;
        }
        else
        {
          *(_BYTE *)(v4 + 8) = 0;
        }
      }
      if ( *(_BYTE *)(v5 + 16) )
      {
        v8 = *(_DWORD *)(v5 - 4);
        if ( v8 )
        {
          if ( v8 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v8, 0, 0, 1, dword_100AE9F4);
        }
      }
      v5 += 24;
      v4 += 24;
    }
    while ( v5 - 4 != v3 );
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003E4E0) --------------------------------------------------------
void __usercall sub_1003E4E0(int a1@<eax>, int *a2@<ecx>)
{
  int *v2; // esi@1
  int v3; // edi@1
  int v4; // eax@2

  v2 = a2;
  v3 = (int)&a2[3 * a1];
  if ( a2 != (int *)v3 )
  {
    do
    {
      v4 = *v2;
      if ( *v2 )
      {
        if ( v4 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
      }
      v2 += 3;
    }
    while ( v2 != (int *)v3 );
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003E530) --------------------------------------------------------
void __usercall sub_1003E530(int a1@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  int v3; // edi@1
  int v4; // eax@3

  v2 = a2;
  v3 = a2 + 24 * a1;
  if ( a2 != v3 )
  {
    do
    {
      if ( *(_BYTE *)(v2 + 20) )
      {
        v4 = *(_DWORD *)v2;
        if ( *(_DWORD *)v2 )
        {
          if ( v4 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
        }
      }
      v2 += 24;
    }
    while ( v2 != v3 );
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003E580) --------------------------------------------------------
int __usercall sub_1003E580@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int result; // eax@1
  int v3; // esi@1

  result = a1 << 6;
  v3 = a2 + result;
  if ( a2 != a2 + result )
  {
    result = a2 + 44;
    do
    {
      if ( result != 44 )
      {
        *(_DWORD *)(result - 44) = 0;
        *(_DWORD *)(result - 40) = 0;
        *(_DWORD *)(result - 36) = 0;
        *(_DWORD *)(result - 32) = 0;
        *(_DWORD *)(result - 28) = 0;
        *(_DWORD *)(result - 24) = 0;
        *(_DWORD *)(result - 20) = 0;
        *(_DWORD *)(result - 16) = 0;
        *(_DWORD *)(result - 8) = 0;
        *(_DWORD *)(result - 4) = 0;
        *(_DWORD *)result = 0;
        *(_DWORD *)(result + 4) = -1;
        *(_DWORD *)(result + 8) = -1;
        *(_DWORD *)(result + 12) = -1;
        *(_BYTE *)(result + 16) = 0;
      }
      result += 64;
    }
    while ( result - 44 != v3 );
  }
  return result;
}

//----- (1003E5E0) --------------------------------------------------------
void __cdecl sub_1003E5E0(char *a1, unsigned int *a2, signed int a3)
{
  int v3; // ecx@0
  unsigned int *v4; // ebp@1
  char *v5; // esi@1
  int v6; // eax@1
  signed int v7; // edi@2
  int v8; // ebx@4
  unsigned int *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v4 = a2;
  v5 = a1;
  v6 = ((char *)a2 - a1) >> 2;
  if ( v6 <= 32 )
    goto LABEL_8;
  v7 = a3;
  while ( v7 > 0 )
  {
    sub_1003E6B0((int)&v9, v5, (unsigned int)v4);
    v8 = v10;
    v7 = v7 / 2 / 2 + v7 / 2;
    if ( (signed int)(((char *)v9 - v5) & 0xFFFFFFFC) >= (signed int)(((unsigned int)v4 - v10) & 0xFFFFFFFC) )
    {
      sub_1003E5E0(v10, v4, v7);
      v4 = v9;
    }
    else
    {
      sub_1003E5E0(v5, v9, v7);
      v5 = (char *)v8;
    }
    v6 = ((char *)v4 - v5) >> 2;
    if ( v6 <= 32 )
      goto LABEL_8;
  }
  if ( v6 <= 32 )
  {
LABEL_8:
    if ( v6 > 1 && (unsigned int *)v5 != v4 )
      sub_1003EA00((signed int)v5, v4);
  }
  else
  {
    if ( (signed int)(((char *)v4 - v5) & 0xFFFFFFFC) > 4 )
      sub_1003E910((int)v4, (int)v5);
    sub_1003E9B0((int)v4, v3, v5);
  }
}

//----- (1003E6B0) --------------------------------------------------------
int __cdecl sub_1003E6B0(int a1, char *a2, unsigned int a3)
{
  unsigned int *v3; // ebp@1
  int *v4; // esi@1
  char *v5; // eax@1
  unsigned int *v6; // edi@1
  unsigned int v7; // ecx@2
  unsigned int v8; // edx@6
  unsigned int *v9; // ecx@10
  char *v10; // edx@10
  unsigned int v11; // ebp@14
  bool v12; // zf@16
  unsigned int v13; // esi@17
  int v14; // esi@19
  unsigned int v15; // esi@25
  unsigned int *v16; // esi@26
  unsigned int v17; // ST14_4@26
  unsigned int v18; // esi@29
  int v19; // ebx@30
  unsigned int v20; // esi@30
  unsigned int v21; // esi@31

  v3 = (unsigned int *)a3;
  v4 = (int *)&a2[4 * (((signed int)(a3 - (_DWORD)a2) >> 2) / 2)];
  sub_1003E7F0(a2, v4, (char *)(a3 - 4));
  v5 = &a2[4 * (((signed int)(a3 - (_DWORD)a2) >> 2) / 2)];
  v6 = (unsigned int *)(v4 + 1);
  if ( a2 < (char *)v4 )
  {
    do
    {
      v7 = *((_DWORD *)v5 - 1);
      if ( *(_DWORD *)v5 > v7 )
        break;
      if ( *(_DWORD *)v5 < v7 )
        break;
      v5 -= 4;
    }
    while ( a2 < v5 );
  }
  if ( (unsigned int)v6 < a3 )
  {
    v8 = *(_DWORD *)v5;
    do
    {
      if ( v8 > *v6 )
        break;
      if ( v8 < *v6 )
        break;
      ++v6;
    }
    while ( (unsigned int)v6 < a3 );
  }
  v9 = v6;
  v10 = v5;
  while ( 1 )
  {
    while ( 1 )
    {
      for ( ; v9 < v3; ++v9 )
      {
        if ( *v9 <= *(_DWORD *)v5 )
        {
          if ( *v9 < *(_DWORD *)v5 )
            break;
          v11 = *v6;
          *v6 = *v9;
          *v9 = v11;
          v3 = (unsigned int *)a3;
          ++v6;
        }
      }
      v12 = v10 == a2;
      if ( v10 > a2 )
      {
        do
        {
          v13 = *((_DWORD *)v10 - 1);
          if ( *(_DWORD *)v5 <= v13 )
          {
            if ( *(_DWORD *)v5 < v13 )
              break;
            v14 = *((_DWORD *)v5 - 1);
            v5 -= 4;
            *(_DWORD *)v5 = *((_DWORD *)v10 - 1);
            *((_DWORD *)v10 - 1) = v14;
          }
          v10 -= 4;
        }
        while ( a2 < v10 );
        v12 = v10 == a2;
      }
      if ( v12 )
        break;
      v10 -= 4;
      if ( v9 == v3 )
      {
        v5 -= 4;
        if ( v10 != v5 )
        {
          v18 = *(_DWORD *)v10;
          *(_DWORD *)v10 = *(_DWORD *)v5;
          *(_DWORD *)v5 = v18;
        }
        v19 = *(v6 - 1);
        v20 = *(_DWORD *)v5;
        --v6;
        *(_DWORD *)v5 = v19;
        *v6 = v20;
      }
      else
      {
        v21 = *v9;
        *v9 = *(_DWORD *)v10;
        *(_DWORD *)v10 = v21;
        ++v9;
      }
    }
    if ( v9 == v3 )
      break;
    if ( v6 != v9 )
    {
      v15 = *(_DWORD *)v5;
      *(_DWORD *)v5 = *v6;
      *v6 = v15;
    }
    v16 = v9;
    v17 = *(_DWORD *)v5;
    *(_DWORD *)v5 = *v9;
    v3 = (unsigned int *)a3;
    ++v6;
    v5 += 4;
    ++v9;
    *v16 = v17;
  }
  *(_DWORD *)(a1 + 4) = v6;
  *(_DWORD *)a1 = v5;
  return a1;
}

//----- (1003E7F0) --------------------------------------------------------
int __usercall sub_1003E7F0@<eax>(char *a1@<ecx>, int *a2@<esi>, char *a3)
{
  int v3; // eax@1
  int v4; // eax@2
  int v5; // ebp@2
  int result; // eax@2
  unsigned int v7; // edx@2
  unsigned int v8; // edx@4
  unsigned int v9; // ebx@4
  unsigned int v10; // edx@6
  int v11; // ebx@8
  int *v12; // edx@8
  unsigned int v13; // edi@8
  unsigned int v14; // edi@10
  int v15; // edi@12
  int *v16; // edx@14
  unsigned int v17; // ebx@14
  char *v18; // edi@14
  unsigned int v19; // ebp@14
  int v20; // ebx@18
  int v21; // edi@20
  unsigned int v22; // ebx@20
  int v23; // edi@22
  int v24; // edx@24
  unsigned int v25; // edi@24
  int v26; // eax@26
  int v27; // eax@28
  int v28; // [sp+4h] [bp-4h]@16

  v3 = (a3 - a1) >> 2;
  if ( v3 <= 40 )
  {
    v26 = *a2;
    if ( (unsigned int)*a2 < *(_DWORD *)a1 )
    {
      *a2 = *(_DWORD *)a1;
      *(_DWORD *)a1 = v26;
    }
    v27 = *(_DWORD *)a3;
    if ( *(_DWORD *)a3 < (unsigned int)*a2 )
    {
      *(_DWORD *)a3 = *a2;
      *a2 = v27;
    }
    result = *a2;
    if ( (unsigned int)*a2 < *(_DWORD *)a1 )
    {
      *a2 = *(_DWORD *)a1;
      *(_DWORD *)a1 = result;
    }
  }
  else
  {
    v4 = (v3 + 1) / 8;
    v5 = 8 * v4;
    result = 4 * v4;
    v7 = *(_DWORD *)&a1[result];
    if ( v7 < *(_DWORD *)a1 )
    {
      *(_DWORD *)&a1[result] = *(_DWORD *)a1;
      *(_DWORD *)a1 = v7;
    }
    v8 = *(_DWORD *)&a1[v5];
    v9 = *(_DWORD *)&a1[result];
    if ( v8 < v9 )
    {
      *(_DWORD *)&a1[v5] = v9;
      *(_DWORD *)&a1[result] = v8;
    }
    v10 = *(_DWORD *)&a1[result];
    if ( v10 < *(_DWORD *)a1 )
    {
      *(_DWORD *)&a1[result] = *(_DWORD *)a1;
      *(_DWORD *)a1 = v10;
    }
    v11 = *a2;
    v12 = (int *)((char *)a2 - result);
    v13 = *(int *)((char *)a2 - result);
    if ( *a2 < v13 )
    {
      *a2 = v13;
      *v12 = v11;
    }
    v14 = *(int *)((char *)a2 + result);
    if ( v14 < *a2 )
    {
      *(int *)((char *)a2 + result) = *a2;
      *a2 = v14;
    }
    v15 = *a2;
    if ( *a2 < (unsigned int)*v12 )
    {
      *a2 = *v12;
      *v12 = v15;
    }
    v16 = (int *)&a3[-result];
    v17 = *(_DWORD *)&a3[-result];
    v18 = &a3[-v5];
    v19 = *(_DWORD *)&a3[-v5];
    if ( v17 < v19 )
    {
      *v16 = v19;
      *(_DWORD *)v18 = v17;
    }
    v28 = *(_DWORD *)a3;
    if ( *(_DWORD *)a3 < (unsigned int)*v16 )
    {
      *(_DWORD *)a3 = *v16;
      *v16 = v28;
    }
    v20 = *v16;
    if ( (unsigned int)*v16 < *(_DWORD *)v18 )
    {
      *v16 = *(_DWORD *)v18;
      *(_DWORD *)v18 = v20;
    }
    v21 = *a2;
    v22 = *(_DWORD *)&a1[result];
    if ( *a2 < v22 )
    {
      *a2 = v22;
      *(_DWORD *)&a1[result] = v21;
    }
    v23 = *v16;
    if ( *v16 < (unsigned int)*a2 )
    {
      *v16 = *a2;
      *a2 = v23;
    }
    v24 = *a2;
    v25 = *(_DWORD *)&a1[result];
    if ( *a2 < v25 )
    {
      *a2 = v25;
      *(_DWORD *)&a1[result] = v24;
    }
  }
  return result;
}

//----- (1003E910) --------------------------------------------------------
int __usercall sub_1003E910@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // ebx@1
  int result; // eax@1
  int v4; // kr00_4@1
  int v5; // esi@1
  int v6; // ebp@2
  unsigned int v7; // eax@3
  int v8; // edi@3
  int i; // eax@3
  unsigned int v10; // edx@10
  unsigned int v11; // [sp+8h] [bp-4h]@3

  v2 = (a1 - a2) >> 2;
  v4 = (a1 - a2) >> 2;
  result = v2 - ((unsigned __int64)v2 >> 32);
  v5 = v4 / 2;
  if ( v4 / 2 > 0 )
  {
    v6 = 2 * v5 + 2;
    do
    {
      v7 = *(_DWORD *)(a2 + 4 * v5-- - 4);
      v6 -= 2;
      v11 = v7;
      v8 = v5;
      for ( i = v6; i < v2; i = 2 * i + 2 )
      {
        if ( *(_DWORD *)(a2 + 4 * i) < *(_DWORD *)(a2 + 4 * i - 4) )
          --i;
        *(_DWORD *)(a2 + 4 * v8) = *(_DWORD *)(a2 + 4 * i);
        v8 = i;
      }
      if ( i == v2 )
      {
        *(_DWORD *)(a2 + 4 * v8) = *(_DWORD *)(a2 + 4 * v2 - 4);
        v8 = v2 - 1;
      }
      for ( result = (v8 - 1) / 2; v5 < v8; result = (result - 1) / 2 )
      {
        v10 = *(_DWORD *)(a2 + 4 * result);
        if ( v10 >= v11 )
          break;
        *(_DWORD *)(a2 + 4 * v8) = v10;
        v8 = result;
      }
      *(_DWORD *)(a2 + 4 * v8) = v11;
    }
    while ( v5 > 0 );
  }
  return result;
}

//----- (1003E9B0) --------------------------------------------------------
int __usercall sub_1003E9B0@<eax>(int a1@<eax>, int a2@<ecx>, char *a3@<esi>)
{
  int result; // eax@1
  int v4; // ecx@2
  int v5; // edi@2
  int v6; // [sp+0h] [bp-4h]@1

  v6 = a2;
  result = a1 - (_DWORD)a3;
  if ( (signed int)(result & 0xFFFFFFFC) > 4 )
  {
    do
    {
      v4 = *(_DWORD *)a3;
      v6 = *(_DWORD *)&a3[result - 4];
      v5 = result - 4;
      *(_DWORD *)&a3[result - 4] = v4;
      sub_1003EA70((result - 4) >> 2, (int)a3, &v6, 0);
      result = v5;
    }
    while ( (signed int)(v5 & 0xFFFFFFFC) > 4 );
  }
  return result;
}

//----- (1003EA00) --------------------------------------------------------
void __usercall sub_1003EA00(signed int a1@<ebx>, unsigned int *a2)
{
  unsigned int *i; // edi@1
  unsigned int v3; // esi@2
  unsigned int *v4; // edx@2
  unsigned int v5; // ecx@4
  int j; // eax@4

  for ( i = (unsigned int *)(a1 + 4); i != a2; ++i )
  {
    v3 = *i;
    v4 = i;
    if ( *i >= *(_DWORD *)a1 )
    {
      v5 = *(i - 1);
      for ( j = (int)(i - 1); v3 < v5; j -= 4 )
      {
        *v4 = v5;
        v5 = *(_DWORD *)(j - 4);
        v4 = (unsigned int *)j;
      }
      *v4 = v3;
    }
    else
    {
      memmove(&i[-(((signed int)i + 4 - a1 - 4) >> 2) + 1], (const void *)a1, 4 * (((signed int)i + 4 - a1 - 4) >> 2));
      *(_DWORD *)a1 = v3;
    }
  }
}

//----- (1003EA70) --------------------------------------------------------
int __usercall sub_1003EA70@<eax>(int a1@<edx>, int a2@<ecx>, int *a3@<ebx>, int a4)
{
  int v4; // esi@1
  int v5; // eax@1
  bool i; // zf@1
  int result; // eax@7
  unsigned int v8; // edx@8

  v4 = a4;
  v5 = 2 * a4 + 2;
  for ( i = v5 == a1; v5 < a1; i = v5 == a1 )
  {
    if ( *(_DWORD *)(a2 + 4 * v5) < *(_DWORD *)(a2 + 4 * v5 - 4) )
      --v5;
    *(_DWORD *)(a2 + 4 * v4) = *(_DWORD *)(a2 + 4 * v5);
    v4 = v5;
    v5 = 2 * v5 + 2;
  }
  if ( i )
  {
    *(_DWORD *)(a2 + 4 * v4) = *(_DWORD *)(a2 + 4 * a1 - 4);
    v4 = a1 - 1;
  }
  result = (v4 - 1) / 2;
  if ( a4 >= v4 )
  {
    result = *a3;
    *(_DWORD *)(a2 + 4 * v4) = *a3;
  }
  else
  {
    do
    {
      v8 = *(_DWORD *)(a2 + 4 * result);
      if ( v8 >= *a3 )
        break;
      *(_DWORD *)(a2 + 4 * v4) = v8;
      v4 = result;
      result = (result - 1) / 2;
    }
    while ( a4 < v4 );
    *(_DWORD *)(a2 + 4 * v4) = *a3;
  }
  return result;
}

//----- (1003EAE0) --------------------------------------------------------
void __stdcall sub_1003EAE0(int a1)
{
  int v1; // eax@1
  int v2; // eax@5
  int v3; // eax@9
  int v4; // eax@13
  int v5; // eax@17
  int v6; // eax@18
  int v7; // eax@22

  v1 = *(_DWORD *)(a1 + 76);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
  v2 = *(_DWORD *)(a1 + 64);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
  }
  v3 = *(_DWORD *)(a1 + 44);
  if ( v3 )
  {
    if ( v3 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
  }
  v4 = *(_DWORD *)(a1 + 24);
  if ( v4 )
  {
    if ( v4 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
  }
  v5 = *(_DWORD *)(a1 + 12);
  if ( v5 )
  {
    sub_10040FD0(v5, *(_DWORD *)(a1 + 16));
    v6 = *(_DWORD *)(a1 + 12);
    if ( v6 )
    {
      if ( v6 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v6, 0, 0, 1, dword_100AE9F4);
    }
  }
  v7 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
  {
    if ( v7 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v7, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003EC70) --------------------------------------------------------
void __usercall sub_1003EC70(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // eax@6
  int v3; // eax@11
  int v4; // eax@12

  v1 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
  }
  v2 = *(_DWORD *)(a1 + 24);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
  }
  v3 = *(_DWORD *)(a1 + 12);
  if ( v3 )
  {
    sub_10040FD0(v3, *(_DWORD *)(a1 + 16));
    v4 = *(_DWORD *)(a1 + 12);
    if ( v4 )
    {
      if ( v4 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
  }
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(float *)(a1 + 36) = 0.0;
  *(_BYTE *)(a1 + 60) = 0;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003ED30) --------------------------------------------------------
char __userpurge sub_1003ED30@<al>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // eax@1
  unsigned int v5; // edi@1
  unsigned int v6; // eax@3
  int v7; // ebx@3
  int v8; // esi@4
  unsigned int v9; // ecx@4
  unsigned int v10; // kr00_4@4
  double v11; // st7@4
  double v12; // st6@4
  float v13; // ST30_4@4
  float v14; // ST34_4@4
  int v15; // eax@7
  int *v16; // ebx@7
  float v17; // ST24_4@7
  int v18; // eax@8
  unsigned int v19; // eax@13
  int v20; // eax@15
  bool v21; // zf@15
  int v22; // edi@15
  unsigned int v23; // eax@17
  int v24; // esi@17
  char v25; // bl@23
  unsigned int v26; // ST10_4@23
  unsigned int v27; // edi@23
  int v28; // ecx@25
  int v29; // eax@26
  int v30; // edx@26
  int v31; // esi@26
  int v32; // eax@34
  unsigned int v34; // ebx@44
  int v35; // edi@46
  unsigned int v36; // eax@47
  int v37; // eax@49
  int v38; // eax@51
  int v39; // eax@56
  int v40; // eax@61
  int *v41; // [sp+0h] [bp-54h]@17
  double v42; // [sp+4h] [bp-50h]@2
  int *v43; // [sp+4h] [bp-50h]@23
  int *v44; // [sp+Ch] [bp-48h]@23
  float v45; // [sp+14h] [bp-40h]@2
  float v46; // [sp+18h] [bp-3Ch]@2
  unsigned __int64 v47; // [sp+1Ch] [bp-38h]@2
  float v48; // [sp+24h] [bp-30h]@7
  void *v49; // [sp+28h] [bp-2Ch]@2
  unsigned int v50; // [sp+2Ch] [bp-28h]@2
  unsigned int v51; // [sp+30h] [bp-24h]@2
  int v52; // [sp+34h] [bp-20h]@2
  int v53; // [sp+38h] [bp-1Ch]@2
  int v54; // [sp+3Ch] [bp-18h]@2
  char v55; // [sp+40h] [bp-14h]@2
  int v56; // [sp+48h] [bp-Ch]@1
  int (__thiscall *v57)(void *); // [sp+4Ch] [bp-8h]@1
  int v58; // [sp+50h] [bp-4h]@1
  float v59; // [sp+58h] [bp+4h]@4
  float v60; // [sp+58h] [bp+4h]@6
  float v61; // [sp+58h] [bp+4h]@6
  float v62; // [sp+58h] [bp+4h]@7
  float v63; // [sp+58h] [bp+4h]@7
  float v64; // [sp+58h] [bp+4h]@7
  unsigned int v65; // [sp+58h] [bp+4h]@23
  int v66; // [sp+58h] [bp+4h]@45

  v58 = -1;
  v57 = sub_10097D1D;
  v56 = a1;
  v3 = a2;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = 0;
  if ( v4 )
  {
    v42 = 0.0;
    *(_BYTE *)(a2 + 60) = 0;
    v47 = 0i64;
    v45 = 0.0;
    v46 = 0.0;
    v49 = 0;
    v50 = 0;
    v51 = 0;
    v52 = -1;
    v53 = -1;
    v54 = -1;
    v55 = 0;
    v58 = 0;
    sub_10036310((int)&v49, v4);
    if ( *(_DWORD *)(a2 + 4) > 0u )
    {
      v6 = v50;
      v7 = 0;
      do
      {
        v8 = v7 + *(_DWORD *)v3;
        v9 = *(_DWORD *)(v8 + 8);
        v59 = (double)*(unsigned int *)(v8 + 8);
        v10 = v47;
        LODWORD(v47) = v9 + v47;
        v11 = v59;
        v12 = v59 * *(float *)v8;
        v47 = __PAIR__(HIDWORD(v47), v9) + v10;
        v13 = v12;
        v14 = v59 * *(float *)(v8 + 4);
        v45 = v13 + v45;
        v46 = v14 + v46;
        if ( v6 >= v51 )
        {
          sub_100943C0(v6 + 1, 0, (int)&v49, 1, 4u, 0);
          v11 = v59;
          v6 = v50;
        }
        *((_DWORD *)v49 + v6++) = v5++;
        v7 += 12;
        v60 = *(float *)v8 * *(float *)v8;
        v50 = v6;
        v61 = *(float *)(v8 + 4) * *(float *)(v8 + 4) + v60;
        v42 = v11 * v61 + v42;
      }
      while ( v5 < *(_DWORD *)(v3 + 4) );
    }
    v62 = v45 * v45;
    v15 = *(_DWORD *)(v3 + 12);
    v16 = (int *)(v3 + 12);
    v63 = v46 * v46 + v62;
    v17 = (double)v47;
    v48 = v42 - v63 / v17;
    v64 = 1.0 / v17;
    v45 = v45 * v64;
    v46 = v64 * v46;
    if ( v15 )
    {
      sub_10040FD0(v15, *(_DWORD *)(v3 + 16));
      v18 = *v16;
      if ( *v16 )
      {
        if ( v18 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v18, 0, 0, 1, dword_100AE9F4);
      }
      *v16 = 0;
      *(_DWORD *)(v3 + 16) = 0;
      *(_DWORD *)(v3 + 20) = 0;
    }
    sub_1003FFD0(v3 + 12);
    v19 = *(_DWORD *)(v3 + 16);
    if ( v19 >= *(_DWORD *)(v3 + 20) )
      sub_100943C0(v19 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040D00, v3 + 12, 1, 0x30u, 0);
    v20 = *(_DWORD *)(v3 + 16);
    v21 = *v16 + 48 * v20 == 0;
    v22 = *v16 + 48 * v20;
    LOBYTE(v58) = 1;
    if ( !v21 )
      sub_10040EF0(v22, (int)&v45);
    LOBYTE(v58) = 0;
    ++*(_DWORD *)(v3 + 16);
    v23 = *(_DWORD *)(v3 + 48);
    v24 = v3 + 44;
    v41 = (int *)(v3 + 44);
    if ( v23 != 0x10000 )
    {
      if ( v23 <= 0x10000 )
      {
        if ( *(_DWORD *)(v3 + 52) < 0x10000u )
          sub_100943C0(0x10000u, 0, v3 + 44, v23 == 0xFFFF, 4u, 0);
        memset((void *)(*(_DWORD *)v24 + 4 * *(_DWORD *)(v3 + 48)), 0, 4 * (0x10000 - *(_DWORD *)(v3 + 48)));
      }
      *(_DWORD *)(v3 + 48) = 0x10000;
    }
    *(_DWORD *)(*(_DWORD *)v24 + 4) = 0;
    v25 = 1;
    v26 = *(_DWORD *)(v3 + 4) + 1;
    *(_DWORD *)(v3 + 56) = 1;
    *(_DWORD *)(v3 + 40) = 0;
    v43 = (int *)(v3 + 64);
    sub_10036310(v3 + 64, v26);
    v44 = (int *)(v3 + 76);
    sub_10036310(v3 + 76, *(_DWORD *)(v3 + 4) + 1);
    v65 = -1;
    v27 = 32867;
    while ( 1 )
    {
      v28 = *(_DWORD *)(v3 + 56);
      if ( !v28 )
      {
LABEL_34:
        v32 = *(_DWORD *)(v3 + 24);
        if ( v32 )
        {
          if ( v32 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v32, 0, 0, 1, dword_100AE9F4);
          *(_DWORD *)(v3 + 24) = 0;
          *(_DWORD *)(v3 + 28) = 0;
          *(_DWORD *)(v3 + 32) = 0;
        }
        v34 = 0;
        *(float *)(v3 + 36) = 0.0;
        if ( *(_DWORD *)(v3 + 16) )
        {
          v66 = 0;
          do
          {
            v35 = v66 + *(_DWORD *)(v3 + 12);
            if ( *(_DWORD *)(v35 + 32) == -1 )
            {
              *(_DWORD *)(v35 + 40) = *(_DWORD *)(v3 + 28);
              v36 = *(_DWORD *)(v3 + 28);
              if ( v36 >= *(_DWORD *)(v3 + 32) )
                sub_100943C0(v36 + 1, 0, v3 + 24, 1, 8u, 0);
              v37 = *(_DWORD *)(v3 + 24) + 8 * *(_DWORD *)(v3 + 28);
              *(_DWORD *)v37 = *(_DWORD *)v35;
              *(_DWORD *)(v37 + 4) = *(_DWORD *)(v35 + 4);
              ++*(_DWORD *)(v3 + 28);
              *(float *)(v3 + 36) = *(float *)(v35 + 16) + *(float *)(v3 + 36);
            }
            v66 += 48;
            ++v34;
          }
          while ( v34 < *(_DWORD *)(v3 + 16) );
        }
        v38 = *v41;
        if ( *v41 )
        {
          if ( v38 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v38, 0, 0, 1, dword_100AE9F4);
          *v41 = 0;
          *(_DWORD *)(v3 + 48) = 0;
          *(_DWORD *)(v3 + 52) = 0;
        }
        v39 = *v43;
        if ( *v43 )
        {
          if ( v39 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v39, 0, 0, 1, dword_100AE9F4);
          *v43 = 0;
          *(_DWORD *)(v3 + 68) = 0;
          *(_DWORD *)(v3 + 72) = 0;
        }
        v40 = *v44;
        if ( *v44 )
        {
          if ( v40 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v40, 0, 0, 1, dword_100AE9F4);
          *v44 = 0;
          *(_DWORD *)(v3 + 80) = 0;
          *(_DWORD *)(v3 + 84) = 0;
        }
        v58 = -1;
        if ( v49 )
        {
          if ( (unsigned __int8)v49 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v49, 0, 0, 1, dword_100AE9F4);
        }
        return 1;
      }
      v29 = *(_DWORD *)v24;
      v30 = *(_DWORD *)(*(_DWORD *)v24 + 4 * v28);
      v31 = *(_DWORD *)(*(_DWORD *)v24 + 4);
      *(_DWORD *)(v29 + 4) = v30;
      v21 = (*(_DWORD *)(v3 + 56))-- == 1;
      if ( !v21 )
        sub_1003F710(v3);
      sub_1003F7D0(v31, v3);
      ++v25;
      v27 += 100;
      if ( sub_1006B310 && !(v25 & 0x3F) && v27 / 0xFFFF != v65 )
      {
        if ( !sub_1006B310(v27 / 0xFFFF, a3) )
        {
          v58 = -1;
          if ( !v49 )
            return 0;
          if ( (unsigned __int8)v49 & 7 )
          {
            sub_100927E0((int)"crnlib_free: bad ptr");
            return 0;
          }
          off_100AD9F4(v49, 0, 0, 1, dword_100AE9F4);
          return 0;
        }
        v65 = v27 / 0xFFFF;
      }
      if ( v27 >= 0x647F9B )
        goto LABEL_34;
      v24 = v3 + 44;
    }
  }
  return 0;
}
// 10040D00: using guessed type int sub_10040D00();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003F290) --------------------------------------------------------
void __thiscall sub_1003F290(void *this, int a2, signed int a3)
{
  int v3; // edi@1
  unsigned int v4; // ebx@1
  int v5; // esi@1
  int v6; // ebp@2
  int v7; // ebp@4
  unsigned int v8; // eax@7
  unsigned int v9; // esi@7
  int v10; // eax@12
  int v11; // ecx@12
  int v12; // eax@12
  int i; // ecx@12
  int v14; // ebp@17
  int v15; // esi@17
  void *v16; // eax@21
  void *v17; // [sp+14h] [bp-18h]@1
  unsigned int v18; // [sp+18h] [bp-14h]@1
  unsigned int v19; // [sp+1Ch] [bp-10h]@1
  int v20; // [sp+28h] [bp-4h]@1

  v3 = (int)this;
  sub_10037280((int)this, 0, 0);
  sub_10038CE0(v3, a3);
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  sub_10036310((int)&v17, 0x200u);
  v4 = v18;
  v5 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(a2 + 12) + 48 * v5;
      v5 = *(_DWORD *)(v6 + 32);
      if ( v5 < 0 || *(_DWORD *)(v6 + 40) + 2 > a3 )
        break;
      v7 = *(_DWORD *)(v6 + 36);
      if ( v4 >= v19 )
      {
        sub_100943C0(v4 + 1, 0, (int)&v17, 1, 4u, 0);
        v4 = v18;
      }
      *((_DWORD *)v17 + v4++) = v7;
      v18 = v4;
    }
    v8 = *(_DWORD *)(v3 + 4);
    v9 = v8 + 1;
    if ( v8 + 1 != v8 )
    {
      if ( v8 + 1 >= v8 )
      {
        if ( v9 > *(_DWORD *)(v3 + 8) )
          sub_100943C0(v8 + 1, 0, v3, v9 == v8 + 1, 0xCu, 0);
        v10 = *(_DWORD *)(v3 + 4);
        v11 = v9 - v10;
        v12 = *(_DWORD *)v3 + 12 * v10;
        for ( i = v12 + 12 * v11; v12 != i; v12 += 12 )
        {
          if ( v12 )
          {
            *(_DWORD *)v12 = 0;
            *(_DWORD *)(v12 + 4) = 0;
            *(_DWORD *)(v12 + 8) = 0;
          }
        }
      }
      else
      {
        sub_1003E4E0(-1, (int *)(*(_DWORD *)v3 + 12 * v9));
      }
      *(_DWORD *)(v3 + 4) = v9;
    }
    v14 = v6 + 20;
    v15 = *(_DWORD *)v3 + 12 * *(_DWORD *)(v3 + 4) - 12;
    if ( v15 != v14 )
    {
      if ( *(_DWORD *)(v15 + 8) < *(_DWORD *)(v14 + 4) )
      {
        v16 = *(void **)v15;
        if ( *(_DWORD *)v15 )
        {
          if ( (unsigned __int8)v16 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v16, 0, 0, 1, dword_100AE9F4);
          *(_DWORD *)v15 = 0;
          *(_DWORD *)(v15 + 4) = 0;
          *(_DWORD *)(v15 + 8) = 0;
        }
        sub_100943C0(*(_DWORD *)(v14 + 4), 0, v15, 0, 4u, 0);
      }
      else if ( *(_DWORD *)(v15 + 4) )
      {
        *(_DWORD *)(v15 + 4) = 0;
      }
      memcpy(*(void **)v15, *(const void **)v14, 4 * *(_DWORD *)(v14 + 4));
      *(_DWORD *)(v15 + 4) = *(_DWORD *)(v14 + 4);
    }
    if ( !v4 )
      break;
    v5 = *((_DWORD *)v17 + v4-- - 1);
    v18 = v4;
  }
  v20 = -1;
  if ( v17 )
  {
    if ( (unsigned __int8)v17 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v17, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003F4C0) --------------------------------------------------------
unsigned int __usercall sub_1003F4C0@<eax>(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int result; // eax@1
  int v3; // edx@5
  int i; // ecx@5

  result = *(_DWORD *)(a1 + 4);
  if ( a2 != result )
  {
    if ( a2 >= result )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040A40, a1, a2 == result + 1, 0xCu, 0);
      v3 = *(_DWORD *)(a1 + 4);
      result = *(_DWORD *)a1 + 12 * v3;
      for ( i = result + 12 * (a2 - v3); result != i; result += 12 )
      {
        if ( result )
          *(_DWORD *)(result + 8) = 0;
      }
    }
    *(_DWORD *)(a1 + 4) = a2;
  }
  return result;
}
// 10040A40: using guessed type int sub_10040A40();

//----- (1003F520) --------------------------------------------------------
void __stdcall sub_1003F520(int a1)
{
  int v1; // eax@2
  int v2; // eax@8

  if ( *(_DWORD *)(a1 + 4) )
  {
    v1 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 )
    {
      if ( v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
      *(_DWORD *)a1 = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 8) = 0;
    }
    *(_DWORD *)(a1 + 12) = 32;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 24) = 0;
  }
  v2 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003F5E0) --------------------------------------------------------
int __userpurge sub_1003F5E0@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3@<ebx>, _BYTE *a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // edx@1
  unsigned int v7; // eax@2
  FILE *v8; // eax@5
  char DstBuf; // [sp+10h] [bp-200h]@5

  v4 = a1;
  v5 = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  if ( !sub_100400E0(a3, a1, a2, a4) )
  {
    v7 = 2 * *(_DWORD *)(v5 + 4);
    if ( v7 < 4 )
      v7 = 4;
    sub_10040BA0(v7, v6, v5);
    if ( !sub_100400E0(a3, v4, v5, a4) )
    {
      sprintf_s(
        &DstBuf,
        0x200u,
        "%s(%u): Failure: \"%s\"\n",
        "j:\\programme\\sdks\\crunch-104\\crnlib\\crn_hash_map.h",
        392,
        "\"insert() failed\"");
      OutputDebugStringA(&DstBuf);
      v8 = _iob_func();
      fputs(&DstBuf, v8 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
      if ( !byte_100AE9F8 )
        exit(1);
      RaiseException(0x100u, 0, 0, 0);
    }
  }
  return v4;
}
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (1003F710) --------------------------------------------------------
void __thiscall sub_1003F710(int this)
{
  int v1; // ebp@1
  unsigned int v2; // eax@1
  signed int v3; // ebx@1
  unsigned int v4; // edx@1
  double v5; // st7@2
  bool v6; // cf@2
  unsigned int v7; // eax@7

  v1 = *(_DWORD *)(*(_DWORD *)(this + 44) + 4);
  v2 = *(_DWORD *)(this + 56);
  v3 = 1;
  v4 = 2;
  if ( v2 < 2 )
  {
    *(_DWORD *)(*(_DWORD *)(this + 44) + 4) = v1;
  }
  else
  {
    v5 = *(float *)(*(_DWORD *)(this + 12) + 48 * v1 + 16);
    v6 = v2 > 2;
    while ( 1 )
    {
      if ( v6
        && *(float *)(*(_DWORD *)(this + 12) + 48 * *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v4 + 4) + 16) > (double)*(float *)(*(_DWORD *)(this + 12) + 48 * *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v4) + 16) )
      {
        ++v4;
      }
      if ( *(float *)(*(_DWORD *)(this + 12) + 48 * *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v4) + 16) < v5 )
        break;
      *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v3) = *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v4);
      v7 = *(_DWORD *)(this + 56);
      v3 = v4;
      v4 *= 2;
      v6 = v4 < v7;
      if ( v4 > v7 )
      {
        *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v3) = v1;
        return;
      }
    }
    *(_DWORD *)(*(_DWORD *)(this + 44) + 4 * v3) = v1;
  }
}

//----- (1003F7D0) --------------------------------------------------------
void __userpurge sub_1003F7D0(int a1@<eax>, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // ecx@5
  char v5; // al@5
  int v6; // ecx@5
  _DWORD *v7; // ebx@6
  _DWORD *v8; // ebp@6
  unsigned int v9; // ecx@7
  unsigned int v10; // ecx@11
  double v11; // st7@15
  _DWORD *v12; // ecx@18
  double v13; // st6@18
  int v14; // esi@18
  unsigned int v15; // edi@18
  float v16; // ST30_4@18
  float v17; // ST24_4@18
  float v18; // ST30_4@18
  float v19; // ST24_4@18
  double v20; // st6@18
  float v21; // ST24_4@18
  float v22; // ST30_4@18
  float v23; // ST24_4@18
  float v24; // ST30_4@18
  unsigned int v25; // eax@19
  float v26; // ST24_4@21
  double v27; // st7@21
  float v28; // ST24_4@21
  float v29; // ST24_4@21
  unsigned int v30; // eax@22
  float v31; // ST24_4@24
  double v32; // st7@24
  float v33; // ST24_4@24
  float v34; // ST24_4@24
  __int64 v35; // rdi@27
  float v36; // ST28_4@28
  float v37; // ST28_4@28
  float v38; // ST2C_4@28
  double v39; // st5@28
  float v40; // ST28_4@28
  float v41; // ST28_4@28
  float v42; // ST2C_4@28
  double v43; // st2@28
  float v44; // ST2C_4@28
  float v45; // ST44_4@28
  float v46; // ST48_4@28
  float v47; // ST2C_4@28
  float v48; // ST4C_4@28
  float v49; // ST50_4@28
  int v50; // ebp@35
  unsigned int v51; // ecx@35
  int *v52; // ebx@35
  unsigned int v53; // esi@35
  int v54; // edx@35
  int v55; // ebx@42
  int v56; // eax@42
  int v57; // esi@42
  int v58; // ecx@44
  int v59; // ecx@44
  int v60; // ecx@44
  int v61; // eax@49
  int v62; // eax@49
  int v63; // eax@49
  float v64; // [sp+14h] [bp-94h]@5
  float v65; // [sp+18h] [bp-90h]@5
  int v66; // [sp+18h] [bp-90h]@15
  _DWORD *v67; // [sp+1Ch] [bp-8Ch]@18
  float v68; // [sp+1Ch] [bp-8Ch]@28
  int v69; // [sp+24h] [bp-84h]@1
  unsigned __int64 v70; // [sp+28h] [bp-80h]@5
  float v71; // [sp+34h] [bp-74h]@15
  float v72; // [sp+38h] [bp-70h]@15
  float v73; // [sp+3Ch] [bp-6Ch]@15
  float v74; // [sp+40h] [bp-68h]@15
  int v75; // [sp+44h] [bp-64h]@5
  unsigned __int64 v76; // [sp+48h] [bp-60h]@5
  float v77; // [sp+50h] [bp-58h]@3
  float v78; // [sp+54h] [bp-54h]@18
  float v79; // [sp+58h] [bp-50h]@3
  float v80; // [sp+5Ch] [bp-4Ch]@18
  int v81; // [sp+60h] [bp-48h]@5
  float v82; // [sp+64h] [bp-44h]@5
  double v83; // [sp+68h] [bp-40h]@15
  float v84; // [sp+70h] [bp-38h]@21
  float v85; // [sp+74h] [bp-34h]@21
  float v86; // [sp+78h] [bp-30h]@24
  float v87; // [sp+7Ch] [bp-2Ch]@24
  double v88; // [sp+80h] [bp-28h]@15
  unsigned __int64 v89; // [sp+88h] [bp-20h]@28
  unsigned __int64 v90; // [sp+90h] [bp-18h]@28
  unsigned __int64 v91; // [sp+98h] [bp-10h]@28
  unsigned __int64 v92; // [sp+A0h] [bp-8h]@28

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 12) + 48 * a1;
  v69 = *(_DWORD *)(a2 + 12) + 48 * a1;
  if ( *(_DWORD *)(v3 + 24) != 1 )
  {
    if ( *(_BYTE *)(a2 + 60) )
      sub_10040260((int)&v79, v3, (int *)a2, (int)&v79, (int)&v77);
    else
      sub_10040410((int *)a2, (int)&v79, (int)&v77, v3);
    v4 = *(_BYTE *)(a2 + 60);
    v5 = 0;
    v82 = 1.0e10;
    v64 = 0.0;
    v6 = v4 != 0 ? 0xFFFFFFFA : 0;
    v65 = 0.0;
    v70 = 0i64;
    v76 = 0i64;
    v81 = v6 + 8;
    v75 = 0;
    if ( v6 != -8 )
    {
      v7 = (_DWORD *)(a2 + 64);
      v8 = (_DWORD *)(a2 + 76);
      while ( 1 )
      {
        v9 = *(_DWORD *)(a2 + 68);
        if ( v9 )
        {
          if ( v9 <= 0 )
            memset((void *)(*v7 + 4 * v9), 0, -4 * v9);
          *(_DWORD *)(a2 + 68) = 0;
        }
        v10 = *(_DWORD *)(a2 + 80);
        if ( v10 )
        {
          if ( v10 <= 0 )
            memset((void *)(*v8 + 4 * v10), 0, -4 * v10);
          *(_DWORD *)(a2 + 80) = 0;
        }
        v11 = 0.0;
        v71 = 0.0;
        v83 = 0.0;
        v72 = 0.0;
        v88 = 0.0;
        v73 = 0.0;
        v74 = 0.0;
        v70 = 0i64;
        v76 = 0i64;
        v66 = 0;
        if ( *(_DWORD *)(v3 + 24) <= 0u )
        {
          *(_BYTE *)(v3 + 44) = 1;
          return;
        }
        while ( 1 )
        {
          v12 = (_DWORD *)(*(_DWORD *)(v3 + 20) + 4 * v66);
          v13 = v79 - *(float *)(*(_DWORD *)v2 + 12 * *v12);
          v14 = *(_DWORD *)v2 + 12 * *v12;
          v15 = *(_DWORD *)(v14 + 8);
          v67 = v12;
          v16 = v13;
          v17 = v16 * v16 + v11;
          v18 = v80 - *(float *)(v14 + 4);
          v19 = v18 * v18 + v17;
          v20 = v19;
          v21 = v77 - *(float *)v14;
          v22 = v11 + v21 * v21;
          v23 = v78 - *(float *)(v14 + 4);
          v24 = v23 * v23 + v22;
          if ( v24 <= v20 )
          {
            v30 = *(_DWORD *)(a2 + 80);
            if ( v30 >= *(_DWORD *)(a2 + 84) )
            {
              sub_100943C0(v30 + 1, 0, (int)v8, 1, 4u, 0);
              v12 = v67;
            }
            *(_DWORD *)(*(_DWORD *)(a2 + 76) + 4 * (*(_DWORD *)(a2 + 80))++) = *v12;
            v31 = (double)v15;
            v32 = v31;
            v76 += v15;
            v86 = v31 * *(float *)v14;
            v87 = v31 * *(float *)(v14 + 4);
            v73 = v86 + v73;
            v74 = v74 + v87;
            v33 = *(float *)v14 * *(float *)v14;
            v34 = *(float *)(v14 + 4) * *(float *)(v14 + 4) + v33;
            v88 = v32 * v34 + v88;
          }
          else
          {
            v25 = *(_DWORD *)(a2 + 68);
            if ( v25 >= *(_DWORD *)(a2 + 72) )
            {
              sub_100943C0(v25 + 1, 0, (int)v7, 1, 4u, 0);
              v12 = v67;
            }
            *(_DWORD *)(*(_DWORD *)(a2 + 64) + 4 * (*(_DWORD *)(a2 + 68))++) = *v12;
            v26 = (double)v15;
            v27 = v26;
            v70 += v15;
            v84 = v26 * *(float *)v14;
            v85 = v26 * *(float *)(v14 + 4);
            v71 = v84 + v71;
            v72 = v72 + v85;
            v28 = *(float *)v14 * *(float *)v14;
            v29 = *(float *)(v14 + 4) * *(float *)(v14 + 4) + v28;
            v83 = v27 * v29 + v83;
          }
          if ( (unsigned int)++v66 >= *(_DWORD *)(v69 + 24) )
            break;
          v11 = 0.0;
          v2 = a2;
          v3 = v69;
        }
        if ( !v70 || (BYTE7(v35) = BYTE7(v76), !v76) )
        {
          *(_BYTE *)(v69 + 44) = 1;
          return;
        }
        v89 = v70 & 0x7FFFFFFFFFFFFFFFi64;
        v36 = v71 * v71;
        v91 = v70 & 0x8000000000000000ui64;
        v90 = v76 & 0x7FFFFFFFFFFFFFFFi64;
        v37 = v72 * v72 + v36;
        v92 = v35 & 0x8000000000000000ui64;
        v38 = (double)v70;
        v39 = v38;
        v64 = v83 - v37 / v38;
        v40 = v73 * v73;
        v41 = v74 * v74 + v40;
        v42 = (double)v76;
        v43 = v42;
        v65 = v88 - v41 / v42;
        v44 = 1.0 / v39;
        v45 = v71 * v44;
        v46 = v72 * v44;
        v47 = 1.0 / v43;
        v48 = v73 * v47;
        v79 = v45;
        v80 = v46;
        v77 = v48;
        v49 = v47 * v74;
        v78 = v49;
        v68 = v65 + v64;
        if ( v68 < 0.0000099999997 || (v82 - v68) / v68 < 0.001249999972060323 )
          break;
        v82 = v65 + v64;
        v2 = a2;
        v3 = v69;
        if ( ++v75 >= (unsigned int)v81 )
          goto LABEL_34;
      }
      v2 = a2;
      v3 = v69;
LABEL_34:
      v5 = 0;
    }
    v50 = *(_DWORD *)(v2 + 16);
    *(_DWORD *)(v3 + 32) = v50;
    *(_DWORD *)(v3 + 36) = *(_DWORD *)(v2 + 16) + 1;
    *(_DWORD *)(v3 + 40) = (*(_DWORD *)(v2 + 40))++;
    v51 = *(_DWORD *)(v2 + 16);
    v52 = (int *)(v2 + 12);
    v53 = *(_DWORD *)(v2 + 16) + 2;
    v54 = v50 + 1;
    if ( v53 != v51 )
    {
      if ( v53 >= v51 )
      {
        if ( v53 > *(_DWORD *)(v2 + 20) )
        {
          LOBYTE(v81) = v53 == v51 + 1;
          sub_100943C0(v53, (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040D00, v2 + 12, v53 == v51 + 1, 0x30u, v5);
        }
        sub_10041020(*v52 + 48 * *(_DWORD *)(v2 + 16), v53 - *(_DWORD *)(v2 + 16));
      }
      else
      {
        sub_10040FD0(*v52 + 48 * v53, v51 - v53);
      }
      v54 = v50 + 1;
      *(_DWORD *)(v2 + 16) = v53;
    }
    v55 = *v52;
    v56 = v55 + 48 * v50;
    v57 = v55 + 48 * v54;
    if ( (float *)v56 != &v79 )
    {
      *(float *)v56 = v79;
      *(float *)(v56 + 4) = v80;
    }
    *(_QWORD *)(v56 + 8) = v70;
    v58 = *(_DWORD *)(v56 + 20);
    *(_DWORD *)(v56 + 20) = *(_DWORD *)(v2 + 64);
    *(_DWORD *)(v2 + 64) = v58;
    v59 = *(_DWORD *)(v56 + 24);
    *(_DWORD *)(v56 + 24) = *(_DWORD *)(v2 + 68);
    *(_DWORD *)(v2 + 68) = v59;
    v60 = *(_DWORD *)(v56 + 28);
    *(_DWORD *)(v56 + 28) = *(_DWORD *)(v2 + 72);
    *(_DWORD *)(v2 + 72) = v60;
    *(float *)(v56 + 16) = v64;
    if ( *(_DWORD *)(v56 + 24) > 1u && v64 > 0.0 )
    {
      sub_100401C0(v2, v50);
      v54 = v50 + 1;
    }
    if ( (float *)v57 != &v77 )
    {
      *(float *)v57 = v77;
      *(float *)(v57 + 4) = v78;
    }
    *(_QWORD *)(v57 + 8) = v76;
    v61 = *(_DWORD *)(v57 + 20);
    *(_DWORD *)(v57 + 20) = *(_DWORD *)(v2 + 76);
    *(_DWORD *)(v2 + 76) = v61;
    v62 = *(_DWORD *)(v57 + 24);
    *(_DWORD *)(v57 + 24) = *(_DWORD *)(v2 + 80);
    *(_DWORD *)(v2 + 80) = v62;
    v63 = *(_DWORD *)(v57 + 28);
    *(_DWORD *)(v57 + 28) = *(_DWORD *)(v2 + 84);
    *(_DWORD *)(v2 + 84) = v63;
    *(float *)(v57 + 16) = v65;
    if ( *(_DWORD *)(v57 + 24) > 1u && v65 > 0.0 )
      sub_100401C0(v2, v54);
  }
}
// 10040D00: using guessed type int sub_10040D00();

//----- (1003FE70) --------------------------------------------------------
void __thiscall sub_1003FE70(int this, unsigned int a2)
{
  unsigned int v2; // eax@1
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // eax@6
  int v6; // ecx@6
  int v7; // edx@6
  int v8; // [sp+4h] [bp-18h]@4
  int v9; // [sp+8h] [bp-14h]@4
  int v10; // [sp+Ch] [bp-10h]@4
  int v11; // [sp+18h] [bp-4h]@4

  v2 = a2;
  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ( a2 <= v4 )
  {
    if ( a2 < v4 )
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      if ( *(_DWORD *)(v3 + 4) > a2 )
        v2 = *(_DWORD *)(v3 + 4);
      sub_100943C0(v2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040A40, (int)&v8, 0, 0xCu, 0);
      sub_100409D0((int)&v8, v3);
      v5 = *(_DWORD *)v3;
      v6 = v9;
      *(_DWORD *)v3 = v8;
      v7 = v10;
      *(_DWORD *)(v3 + 4) = v6;
      *(_DWORD *)(v3 + 8) = v7;
      v11 = -1;
      if ( v5 )
      {
        if ( v5 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040A40, v3, 0, 0xCu, 0);
  }
}
// 10040A40: using guessed type int sub_10040A40();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003FF80) --------------------------------------------------------
void __usercall sub_1003FF80(int a1@<esi>)
{
  int v1; // eax@2

  if ( *(_DWORD *)a1 )
  {
    sub_10040FD0(*(_DWORD *)a1, *(_DWORD *)(a1 + 4));
    v1 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 )
    {
      if ( v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1003FFD0) --------------------------------------------------------
void __usercall sub_1003FFD0(int a1@<esi>)
{
  unsigned int v1; // eax@1
  unsigned int v2; // eax@4
  int v3; // ebx@6
  int v4; // edx@6
  int v5; // ecx@6
  int v6; // eax@6
  int v7; // [sp+0h] [bp-18h]@4
  int v8; // [sp+4h] [bp-14h]@4
  int v9; // [sp+8h] [bp-10h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 >= 0x1FFFF )
  {
    if ( v1 > 0x1FFFF )
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v2 = *(_DWORD *)(a1 + 4);
      if ( v2 <= 0x1FFFF )
        v2 = 0x1FFFF;
      sub_100943C0(v2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040D00, (int)&v7, 0, 0x30u, 0);
      sub_10040A90((int)&v7, a1);
      v3 = *(_DWORD *)a1;
      v4 = v8;
      *(_DWORD *)a1 = v7;
      v5 = *(_DWORD *)(a1 + 4);
      v6 = v9;
      *(_DWORD *)(a1 + 4) = v4;
      *(_DWORD *)(a1 + 8) = v6;
      v10 = -1;
      if ( v3 )
      {
        sub_10040FD0(v3, v5);
        if ( v3 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(0x1FFFFu, (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040D00, a1, 0, 0x30u, 0);
  }
}
// 10040D00: using guessed type int sub_10040D00();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100400E0) --------------------------------------------------------
char __userpurge sub_100400E0@<al>(_DWORD *a1@<eax>, int a2@<edi>, int a3@<esi>, _BYTE *a4)
{
  _DWORD *v4; // ebx@1
  char result; // al@2
  unsigned int v6; // edx@3
  int v7; // ecx@3

  v4 = a1;
  if ( !*(_DWORD *)(a3 + 4) )
    return 0;
  v6 = (unsigned int)(-1640531527 * *a1) >> *(_DWORD *)(a3 + 12);
  v7 = *(_DWORD *)a3 + 24 * v6;
  result = 1;
  if ( *(_BYTE *)(v7 + 16) )
  {
    if ( *(_DWORD *)v7 != *v4 || *(_DWORD *)(v7 + 4) != v4[1] )
    {
      while ( 1 )
      {
        if ( v6 )
        {
          --v6;
          v7 -= 24;
        }
        else
        {
          v6 = *(_DWORD *)(a3 + 4) - 1;
          v7 = *(_DWORD *)a3 + 24 * v6;
        }
        if ( (unsigned int)(-1640531527 * *v4) >> *(_DWORD *)(a3 + 12) == v6 )
          return 0;
        if ( !*(_BYTE *)(v7 + 16) )
        {
          result = 1;
          goto LABEL_16;
        }
        if ( *(_DWORD *)v7 == *v4 && *(_DWORD *)(v7 + 4) == v4[1] )
        {
          *(_BYTE *)(a2 + 8) = 0;
          result = 1;
          *(_DWORD *)a2 = a3;
          *(_DWORD *)(a2 + 4) = v6;
          return result;
        }
      }
    }
    *(_BYTE *)(a2 + 8) = 0;
    result = 1;
    *(_DWORD *)a2 = a3;
    *(_DWORD *)(a2 + 4) = v6;
  }
  else
  {
LABEL_16:
    if ( *(_DWORD *)(a3 + 20) >= *(_DWORD *)(a3 + 24) )
      return 0;
    *(_DWORD *)v7 = *v4;
    *(_DWORD *)(v7 + 4) = v4[1];
    *(_BYTE *)(v7 + 8) = *a4;
    *(_BYTE *)(v7 + 16) = 1;
    ++*(_DWORD *)(a3 + 20);
    *(_BYTE *)(a2 + 8) = 1;
    *(_DWORD *)a2 = a3;
    *(_DWORD *)(a2 + 4) = v6;
  }
  return result;
}

//----- (100401C0) --------------------------------------------------------
void __userpurge sub_100401C0(int a1@<ebx>, int a2)
{
  int v2; // eax@1
  double v3; // st7@1
  float v4; // ST0C_4@4
  unsigned int v5; // ebp@1
  unsigned int v6; // edx@3
  int v7; // esi@4
  int v8; // ecx@4

  v2 = a2;
  v3 = *(float *)(*(_DWORD *)(a1 + 12) + 48 * a2 + 16);
  v5 = ++*(_DWORD *)(a1 + 56);
  if ( v5 >= *(_DWORD *)(a1 + 48) )
  {
    sub_100366C0(a1 + 44, v5 + 1);
    v2 = a2;
  }
  v6 = v5 >> 1;
  if ( v5 >> 1 )
  {
    while ( 1 )
    {
      v7 = *(_DWORD *)(a1 + 44);
      v8 = *(_DWORD *)(v7 + 4 * v6);
      v4 = v3;
      if ( *(float *)(*(_DWORD *)(a1 + 12) + 48 * v8 + 16) > (double)v4 )
        break;
      *(_DWORD *)(v7 + 4 * v5) = v8;
      v5 = v6;
      v6 >>= 1;
      if ( !v6 )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 44) + 4 * v5) = a2;
        return;
      }
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 44) + 4 * v5) = a2;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 44) + 4 * v5) = v2;
  }
}

//----- (10040260) --------------------------------------------------------
int __fastcall sub_10040260(int a1, int a2, int *a3, int a4, int a5)
{
  double v5; // st6@1
  int v6; // edi@1
  double v7; // st5@1
  int v8; // ebx@2
  _DWORD *v9; // esi@2
  int v10; // ebp@2
  int v11; // ecx@3
  float v12; // eax@5
  float v13; // ecx@5
  double v14; // st5@7
  double v15; // st4@7
  int v16; // ebx@8
  _DWORD *v17; // esi@8
  int v18; // ecx@9
  float v19; // eax@11
  float v20; // ecx@11
  int result; // eax@15
  float v22; // [sp+8h] [bp-18h]@3
  float v23; // [sp+Ch] [bp-14h]@7
  float v24; // [sp+10h] [bp-10h]@3
  float v25; // [sp+14h] [bp-Ch]@13
  float v26; // [sp+18h] [bp-8h]@1
  float v27; // [sp+1Ch] [bp-4h]@1
  float v28; // [sp+24h] [bp+4h]@9
  float v29; // [sp+24h] [bp+4h]@9

  v26 = 0.0;
  v27 = 0.0;
  v5 = -1.0;
  v6 = *(_DWORD *)(a2 + 24);
  v7 = -1.0;
  if ( v6 )
  {
    v8 = *a3;
    v9 = *(_DWORD **)(a2 + 20);
    v10 = *(_DWORD *)(a2 + 24);
    do
    {
      v11 = v8 + 12 * *v9;
      v22 = *(float *)(v8 + 12 * *v9) - *(float *)a2;
      v24 = v22 * v22 + 0.0;
      v22 = *(float *)(v11 + 4) - *(float *)(a2 + 4);
      v24 = v22 * v22 + v24;
      if ( v24 > v7 )
      {
        v7 = v24;
        if ( &v26 != (float *)v11 )
        {
          v12 = *(float *)v11;
          v13 = *(float *)(v11 + 4);
          v26 = v12;
          v27 = v13;
        }
      }
      ++v9;
      --v10;
    }
    while ( v10 );
  }
  v22 = 0.0;
  v23 = 0.0;
  v14 = v27;
  v15 = v26;
  if ( v6 )
  {
    v16 = *a3;
    v17 = *(_DWORD **)(a2 + 20);
    do
    {
      v18 = v16 + 12 * *v17;
      v28 = *(float *)(v16 + 12 * *v17) - v15;
      v24 = v28 * v28 + 0.0;
      v29 = *(float *)(v18 + 4) - v14;
      v24 = v29 * v29 + v24;
      if ( v24 > v5 )
      {
        v5 = v24;
        if ( &v22 != (float *)v18 )
        {
          v19 = *(float *)v18;
          v20 = *(float *)(v18 + 4);
          v22 = v19;
          v23 = v20;
        }
      }
      ++v17;
      --v6;
    }
    while ( v6 );
  }
  v24 = v15 + *(float *)a2;
  v25 = v14 + *(float *)(a2 + 4);
  v26 = v24 * 0.5;
  v27 = v25 * 0.5;
  if ( (float *)a4 != &v26 )
  {
    *(float *)a4 = v26;
    *(float *)(a4 + 4) = v27;
  }
  result = a5;
  v24 = *(float *)a2 + v22;
  v25 = *(float *)(a2 + 4) + v23;
  v26 = v24 * 0.5;
  v27 = 0.5 * v25;
  if ( (float *)a5 != &v26 )
  {
    *(float *)a5 = v26;
    *(float *)(a5 + 4) = v27;
  }
  return result;
}

//----- (10040410) --------------------------------------------------------
int __stdcall sub_10040410(int *a1, int a2, int a3, int a4)
{
  int v4; // edx@1
  float v5; // ecx@1
  int v6; // ecx@2
  int v7; // eax@2
  int result; // eax@4
  _DWORD *v9; // ebp@7
  int v10; // eax@8
  int v11; // ecx@8
  double v12; // st7@8
  unsigned int v13; // esi@10
  float *v14; // edx@10
  int *v15; // edi@10
  signed int v16; // ebx@10
  unsigned int v17; // eax@11
  int *v18; // ecx@13
  double v19; // st7@14
  int *v20; // ecx@16
  double v21; // st7@17
  unsigned int v22; // eax@20
  unsigned int v23; // kr00_4@20
  unsigned int v24; // edx@20
  int *v25; // ebx@20
  signed int v26; // edi@20
  double v27; // st7@20
  unsigned int v28; // esi@21
  unsigned int v29; // ecx@23
  int *v30; // eax@23
  double v31; // st6@24
  float *v32; // eax@26
  int v33; // ecx@26
  double v34; // st6@27
  float *v35; // eax@29
  float *v36; // ecx@29
  signed int v37; // edx@29
  double v38; // st7@30
  unsigned int v39; // esi@31
  int v40; // eax@31
  double v41; // st4@32
  float v42; // esi@33
  float v43; // edx@33
  int v44; // ecx@33
  double v45; // st7@33
  double v46; // st6@33
  double v47; // st5@33
  long double v48; // st4@33
  double v49; // st4@34
  long double v50; // st3@35
  long double v51; // st2@35
  long double v52; // st2@35
  long double v53; // rt0@37
  double v54; // st3@37
  long double v55; // st7@37
  long double v56; // rt1@37
  long double v57; // st4@37
  long double v58; // st6@37
  long double v59; // st4@37
  double v60; // rt2@40
  long double v61; // st5@40
  double v62; // st7@40
  double v63; // st5@42
  double v64; // st5@42
  long double v65; // st7@44
  long double v66; // st6@44
  double v67; // st6@45
  double v68; // st5@46
  int v69; // edi@46
  int v70; // ebx@46
  long double v71; // st4@46
  long double v72; // st3@46
  int v73; // esi@47
  _DWORD *v74; // edx@47
  double v75; // rt0@49
  double v76; // st2@50
  int v77; // ecx@50
  long double v78; // rt1@52
  double v79; // st3@52
  long double v80; // st5@52
  double v81; // st2@52
  double v82; // st1@52
  float v83; // [sp+14h] [bp-50h]@7
  float v84; // [sp+18h] [bp-4Ch]@7
  float v85; // [sp+1Ch] [bp-48h]@33
  int v86; // [sp+20h] [bp-44h]@10
  float v87; // [sp+24h] [bp-40h]@46
  float v88; // [sp+28h] [bp-3Ch]@35
  float v89; // [sp+2Ch] [bp-38h]@37
  float v90; // [sp+30h] [bp-34h]@8
  float v91; // [sp+34h] [bp-30h]@8
  float v92; // [sp+38h] [bp-2Ch]@14
  float v93; // [sp+3Ch] [bp-28h]@14
  unsigned __int64 v94; // [sp+40h] [bp-24h]@10
  float v95; // [sp+50h] [bp-14h]@6
  float v96; // [sp+54h] [bp-10h]@6
  float v97; // [sp+58h] [bp-Ch]@6
  float v98; // [sp+5Ch] [bp-8h]@6
  float v99; // [sp+74h] [bp+10h]@52
  float v100; // [sp+74h] [bp+10h]@52
  float v101; // [sp+74h] [bp+10h]@58
  float v102; // [sp+74h] [bp+10h]@60

  v4 = a4;
  v5 = *(float *)(a4 + 24);
  if ( LODWORD(v5) == 2 )
  {
    v6 = *a1;
    v7 = *a1 + 12 * **(_DWORD **)(a4 + 20);
    if ( a2 != v7 )
    {
      *(float *)a2 = *(float *)v7;
      *(float *)(a2 + 4) = *(float *)(v7 + 4);
    }
    result = v6 + 12 * *(_DWORD *)(*(_DWORD *)(a4 + 20) + 4);
    if ( a3 != result )
    {
      *(float *)a3 = *(float *)result;
      *(float *)(a3 + 4) = *(float *)(result + 4);
    }
  }
  else
  {
    v95 = 0.0;
    v96 = 0.0;
    v97 = 0.0;
    v98 = 0.0;
    if ( v5 != 0.0 )
    {
      v9 = *(_DWORD **)(a4 + 20);
      v84 = *(float *)a1;
      v83 = v5;
      do
      {
        v10 = LODWORD(v84) + 12 * *v9;
        v11 = *(_DWORD *)(v10 + 8);
        v90 = *(float *)(LODWORD(v84) + 12 * *v9) - *(float *)v4;
        v91 = *(float *)(v10 + 4) - *(float *)(v4 + 4);
        v12 = (double)*(signed int *)(v10 + 8);
        if ( v11 < 0 )
          v12 = v12 + 4294967300.0;
        *(float *)&v86 = v12;
        v13 = 0;
        v14 = &v90;
        v15 = (int *)&v96;
        v16 = 2;
        *(float *)&v94 = v90 * *(float *)&v86;
        *((float *)&v94 + 1) = *(float *)&v86 * v91;
        do
        {
          v17 = v13;
          if ( v13 < 2 )
          {
            if ( v16 >= 4 )
            {
              v18 = v15;
              do
              {
                v19 = *((float *)&v94 + v17);
                v17 += 4;
                v18 += 4;
                *((float *)v18 - 5) = v19 * *v14 + *((float *)v18 - 5);
                *((float *)v18 - 4) = *(&v91 + v17) * *v14 + *((float *)v18 - 4);
                *((float *)v18 - 3) = *(&v92 + v17) * *v14 + *((float *)v18 - 3);
                *((float *)v18 - 2) = *(&v93 + v17) * *v14 + *((float *)v18 - 2);
              }
              while ( v17 < 0xFFFFFFFF );
            }
            if ( v17 < 2 )
            {
              v20 = (int *)(&v95 + v17 + 2 * v13);
              do
              {
                v21 = *((float *)&v94 + v17++);
                ++v20;
                *((float *)v20 - 1) = v21 * *v14 + *((float *)v20 - 1);
              }
              while ( v17 < 2 );
            }
          }
          ++v13;
          --v16;
          v15 += 3;
          ++v14;
        }
        while ( v13 < 2 );
        v4 = a4;
        ++v9;
        --LODWORD(v83);
      }
      while ( v83 != 0.0 );
    }
    v22 = *(_DWORD *)(v4 + 12);
    LODWORD(v94) = *(_DWORD *)(v4 + 8);
    v23 = v94;
    v24 = 0;
    v94 = __PAIR__(v22 & 0x80000000, 0);
    v25 = (int *)&v96;
    v26 = 2;
    *(float *)&v86 = 1.0 / (double)__PAIR__(v22, v23);
    v27 = *(float *)&v86;
    do
    {
      v28 = v24;
      if ( v24 < 2 )
      {
        if ( v26 >= 4 )
        {
          v29 = ((-2 - v24) >> 2) + 1;
          v30 = v25;
          v28 = v24 + 4 * v29;
          do
          {
            v31 = *((float *)v30 - 1);
            v30 += 4;
            --v29;
            *((float *)v30 - 5) = v31 * v27;
            *((float *)v30 - 4) = *((float *)v30 - 4) * v27;
            *((float *)v30 - 3) = v27 * *((float *)v30 - 3);
            *((float *)v30 - 2) = *((float *)v30 - 2) * v27;
          }
          while ( v29 );
        }
        if ( v28 < 2 )
        {
          v32 = &v95 + v28 + 2 * v24;
          v33 = 2 - v28;
          do
          {
            v34 = *v32;
            ++v32;
            --v33;
            *(v32 - 1) = v34 * v27;
          }
          while ( v33 );
        }
      }
      ++v24;
      --v26;
      v25 += 3;
    }
    while ( v24 < 2 );
    v35 = &v96;
    v36 = &v97;
    v37 = 1;
    do
    {
      v38 = *v35;
      ++v35;
      *v36 = v38;
      v36 += 2;
      --v37;
    }
    while ( v37 );
    v39 = 0;
    *(float *)&v40 = COERCE_FLOAT(sub_100330F0(1, 1));
    v86 = v40;
    do
    {
      v41 = (double)v39++;
      *(float *)&v86 = v41 * (1.0 / (double)v40);
      *(&v83 + v39) = *(float *)&v86 * 0.5 + 0.75;
    }
    while ( v39 < 2 );
    v42 = v85;
    v43 = v84;
    v44 = 0;
    v45 = v84;
    v90 = v84;
    v46 = v85;
    v91 = v85;
    v47 = v98;
    v48 = 0.0;
    while ( 1 )
    {
      v50 = v48;
      v51 = v95 * v45 + v48 + v96 * v46;
      v88 = v51;
      v52 = fabs(v51);
      if ( v52 >= v48 )
        v50 = v52;
      v53 = v50;
      v54 = v45 * v97;
      v55 = v53;
      v56 = v48;
      v57 = v46 * v47 + v54 + v48;
      v58 = v56;
      v89 = v57;
      v59 = fabs(v57);
      if ( v59 >= v53 )
        v55 = v59;
      if ( v58 == v55 )
      {
        v62 = v47;
      }
      else
      {
        v60 = v47;
        v61 = 1.0 / v55;
        v62 = v60;
        *(float *)&v86 = v61;
        v88 = *(float *)&v86 * v88;
        v89 = *(float *)&v86 * v89;
      }
      v63 = v90;
      v90 = v43;
      v43 = v88;
      v84 = v88;
      v92 = v63 - v88;
      v64 = v91;
      v91 = v42;
      v42 = v89;
      v85 = v89;
      v93 = v64 - v89;
      v83 = v92 * v92;
      v83 = v93 * v93 + v83;
      if ( v83 < 0.0024999999 )
        break;
      if ( (unsigned int)++v44 >= 0xA )
        break;
      v49 = v62;
      v45 = v84;
      v47 = v49;
      v48 = v58;
      v46 = v85;
    }
    v65 = v58;
    v66 = v84 * v84 + v85 * v85;
    if ( v65 == v66 )
    {
      v67 = v85;
    }
    else
    {
      *(float *)&v86 = 1.0 / sqrt(v66);
      v84 = *(float *)&v86 * v84;
      v85 = *(float *)&v86 * v85;
      v67 = v85;
      v65 = 0.0;
    }
    v68 = 0.0;
    v69 = *(_DWORD *)(a4 + 24);
    v88 = 0.0;
    v89 = 0.0;
    v70 = a4;
    *(float *)&v86 = 0.0;
    v87 = 0.0;
    v71 = v65;
    v72 = v65;
    if ( !v69 )
      goto LABEL_65;
    v73 = *a1;
    v74 = *(_DWORD **)(a4 + 20);
    while ( 1 )
    {
      v76 = (double)*(signed int *)(v73 + 12 * *v74 + 8);
      v77 = v73 + 12 * *v74;
      if ( *(_DWORD *)(v77 + 8) < 0 )
        v76 = v76 + 4294967300.0;
      v83 = v76;
      v92 = *(float *)v77 - *(float *)v70;
      v93 = *(float *)(v77 + 4) - *(float *)(v70 + 4);
      v99 = v92 * v84;
      v100 = v93 * v67 + v99;
      v78 = v72;
      v79 = v68;
      v80 = v78;
      v81 = v83;
      v82 = v83 * *(float *)v77;
      if ( v79 <= v100 )
      {
        *(float *)&v94 = v82;
        *((float *)&v94 + 1) = *(float *)(v77 + 4) * v81;
        *(float *)&v86 = *(float *)&v94 + *(float *)&v86;
        v87 = *((float *)&v94 + 1) + v87;
        v80 = v80 + v81;
      }
      else
      {
        v90 = v82;
        v91 = *(float *)(v77 + 4) * v81;
        v88 = v90 + v88;
        v89 = v91 + v89;
        v71 = v71 + v81;
      }
      ++v74;
      if ( !--v69 )
        break;
      v75 = v79;
      v72 = v80;
      v68 = v75;
    }
    if ( v71 > v65 && v65 < v80 )
    {
      v101 = 1.0 / v71;
      v90 = v101 * v88;
      v91 = v101 * v89;
      if ( (float *)a2 != &v90 )
      {
        *(float *)a2 = v90;
        *(float *)(a2 + 4) = v91;
      }
      result = a3;
      v102 = 1.0 / v80;
      v90 = v102 * *(float *)&v86;
      v91 = v102 * v87;
      if ( (float *)a3 != &v90 )
      {
        *(float *)a3 = v90;
        *(float *)(a3 + 4) = v91;
      }
    }
    else
    {
LABEL_65:
      result = sub_10040260(a2, v70, a1, a2, a3);
    }
  }
  return result;
}

//----- (100409D0) --------------------------------------------------------
int __usercall sub_100409D0@<eax>(int result@<eax>, int a2@<ebx>)
{
  int v2; // edi@1
  int v3; // edx@5
  int v4; // eax@5
  int i; // ecx@5

  v2 = result;
  if ( result != a2 )
  {
    if ( *(_DWORD *)(result + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003C8F0(result);
      sub_100943C0(*(_DWORD *)(a2 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040A40, v2, 0, 0xCu, 0);
    }
    else
    {
      sub_1003F4C0(result, 0);
    }
    v3 = *(_DWORD *)(a2 + 4);
    v4 = *(_DWORD *)v2;
    for ( i = *(_DWORD *)a2; v3; --v3 )
    {
      if ( v4 )
      {
        *(float *)v4 = *(float *)i;
        *(float *)(v4 + 4) = *(float *)(i + 4);
        *(_DWORD *)(v4 + 8) = *(_DWORD *)(i + 8);
      }
      v4 += 12;
      i += 12;
    }
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
    result = v2;
  }
  return result;
}
// 10040A40: using guessed type int sub_10040A40();

//----- (10040A90) --------------------------------------------------------
int __stdcall sub_10040A90(int a1, int a2)
{
  int v2; // esi@5
  int v3; // ebx@5
  int i; // edi@5

  if ( a1 != a2 )
  {
    if ( *(_DWORD *)(a1 + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003FF80(a1);
      sub_100943C0(*(_DWORD *)(a2 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040D00, a1, 0, 0x30u, 0);
    }
    else
    {
      sub_10040B40(a1, 0);
    }
    v2 = *(_DWORD *)a2;
    v3 = *(_DWORD *)(a2 + 4);
    for ( i = *(_DWORD *)a1; v3; --v3 )
    {
      if ( i )
        sub_10040EF0(i, v2);
      i += 48;
      v2 += 48;
    }
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  }
  return a1;
}
// 10040D00: using guessed type int sub_10040D00();

//----- (10040B40) --------------------------------------------------------
void __usercall sub_10040B40(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int v2; // ecx@1

  v2 = *(_DWORD *)(a1 + 4);
  if ( a2 != v2 )
  {
    if ( a2 >= v2 )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040D00, a1, a2 == v2 + 1, 0x30u, 0);
      sub_10041020(*(_DWORD *)a1 + 48 * *(_DWORD *)(a1 + 4), a2 - *(_DWORD *)(a1 + 4));
      *(_DWORD *)(a1 + 4) = a2;
    }
    else
    {
      sub_10040FD0(*(_DWORD *)a1 + 48 * a2, v2 - a2);
      *(_DWORD *)(a1 + 4) = a2;
    }
  }
}
// 10040D00: using guessed type int sub_10040D00();

//----- (10040BA0) --------------------------------------------------------
void __fastcall sub_10040BA0(unsigned int a1, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // ebx@1
  int v5; // eax@3
  unsigned int i; // ecx@3
  int v7; // edi@5
  int v8; // ecx@5
  int v9; // eax@5
  int v10; // eax@10
  int v11; // edx@10
  int v12; // ecx@10
  int v13; // eax@10
  int v14; // edx@10
  int v15; // eax@10
  int v16; // ecx@10
  int v17; // eax@10
  unsigned int v18; // edx@10
  int v19; // eax@10
  int v20; // [sp+8h] [bp-28h]@3
  int v21; // [sp+Ch] [bp-24h]@3
  int v22; // [sp+10h] [bp-20h]@3
  int v23; // [sp+14h] [bp-1Ch]@3
  int v24; // [sp+1Ch] [bp-14h]@3
  unsigned int v25; // [sp+20h] [bp-10h]@3
  int v26; // [sp+2Ch] [bp-4h]@3
  int j; // [sp+34h] [bp+4h]@5

  v3 = a3;
  v4 = a1;
  if ( a1 >= *(_DWORD *)(a3 + 20) && a1 != *(_DWORD *)(a3 + 4) )
  {
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = 32;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    sub_10040E90((int)&v20, a1);
    v5 = 0;
    for ( i = v4; i > 1; ++v5 )
      i >>= 1;
    v7 = *(_DWORD *)a3;
    v8 = 32 - v5;
    v9 = *(_DWORD *)a3 + 24 * *(_DWORD *)(a3 + 4);
    v23 = v8;
    v25 = -1;
    for ( j = v9; v7 != v9; v7 += 24 )
    {
      if ( *(_BYTE *)(v7 + 16) )
      {
        sub_10040E20(v7, (int)&v20);
        if ( v24 == *(_DWORD *)(v3 + 20) )
          break;
        v9 = j;
      }
    }
    v25 = (v4 + 1) >> 1;
    sub_1003C8F0(v3);
    v10 = *(_DWORD *)v3;
    v11 = v21;
    *(_DWORD *)v3 = v20;
    v12 = v22;
    *(_DWORD *)(v3 + 12) = 32;
    v20 = v10;
    v13 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 4) = v11;
    v14 = v23;
    v21 = v13;
    v15 = *(_DWORD *)(v3 + 8);
    *(_DWORD *)(v3 + 8) = v12;
    v16 = v24;
    v22 = v15;
    v17 = *(_DWORD *)(v3 + 12);
    *(_DWORD *)(v3 + 12) = v14;
    v18 = v25;
    v23 = v17;
    v19 = *(_DWORD *)(v3 + 20);
    *(_DWORD *)(v3 + 20) = v16;
    v24 = v19;
    v25 = *(_DWORD *)(v3 + 24);
    *(_DWORD *)(v3 + 24) = v18;
    v26 = -1;
    sub_1003F520((int)&v20);
  }
}

//----- (10040E20) --------------------------------------------------------
unsigned int __usercall sub_10040E20@<eax>(int a1@<edx>, int a2@<esi>)
{
  unsigned int result; // eax@1
  int v3; // ecx@1

  result = (unsigned int)(-1640531527 * *(_DWORD *)a1) >> *(_DWORD *)(a2 + 12);
  v3 = *(_DWORD *)a2 + 24 * result;
  if ( *(_BYTE *)(v3 + 16) )
  {
    while ( 1 )
    {
      if ( result )
      {
        --result;
        v3 -= 24;
      }
      else
      {
        result = *(_DWORD *)(a2 + 4) - 1;
        v3 = *(_DWORD *)a2 + 24 * result;
      }
      if ( result == (unsigned int)(-1640531527 * *(_DWORD *)a1) >> *(_DWORD *)(a2 + 12) )
        break;
      if ( !*(_BYTE *)(v3 + 16) )
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    *(_DWORD *)v3 = *(_DWORD *)a1;
    *(_DWORD *)(v3 + 4) = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(v3 + 8) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(v3 + 12) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(v3 + 16) = *(_DWORD *)(a1 + 16);
    result = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(v3 + 20) = result;
    *(_BYTE *)(a1 + 16) = 0;
    ++*(_DWORD *)(a2 + 20);
  }
  return result;
}

//----- (10040E90) --------------------------------------------------------
unsigned int __usercall sub_10040E90@<eax>(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int result; // eax@1
  int v3; // edx@5
  int i; // ecx@5

  result = *(_DWORD *)(a1 + 4);
  if ( a2 != result )
  {
    if ( a2 >= result )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040F70, a1, a2 == result + 1, 0x18u, 0);
      v3 = *(_DWORD *)(a1 + 4);
      result = *(_DWORD *)a1 + 24 * v3;
      for ( i = result + 24 * (a2 - v3); result != i; result += 24 )
      {
        if ( result )
          *(_BYTE *)(result + 16) = 0;
      }
    }
    *(_DWORD *)(a1 + 4) = a2;
  }
  return result;
}
// 10040F70: using guessed type int sub_10040F70();

//----- (10040EF0) --------------------------------------------------------
int __usercall sub_10040EF0@<eax>(int a1@<edi>, int a2@<esi>)
{
  int v2; // ebx@1
  int v3; // eax@1
  void *v4; // ecx@1

  *(float *)a1 = *(float *)a2;
  v2 = a1 + 20;
  *(float *)(a1 + 4) = *(float *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(float *)(a1 + 16) = *(float *)(a2 + 16);
  *(_DWORD *)v2 = 0;
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  sub_100943C0(*(_DWORD *)(a2 + 24), 0, a1 + 20, 0, 4u, 0);
  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(void **)(a1 + 20);
  *(_DWORD *)(a1 + 24) = v3;
  memcpy(v4, *(const void **)(a2 + 20), 4 * v3);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_BYTE *)(a1 + 44) = *(_BYTE *)(a2 + 44);
  return a1;
}

//----- (10040FD0) --------------------------------------------------------
void __usercall sub_10040FD0(int a1@<eax>, int a2@<ecx>)
{
  int v2; // edi@1
  int *v3; // esi@2
  int v4; // eax@3

  v2 = a1 + 48 * a2;
  if ( a1 != v2 )
  {
    v3 = (int *)(a1 + 20);
    do
    {
      v4 = *v3;
      if ( *v3 )
      {
        if ( v4 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
      }
      v3 += 12;
    }
    while ( v3 - 5 != (int *)v2 );
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10041020) --------------------------------------------------------
int __usercall sub_10041020@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // edx@1

  v2 = result + 48 * a2;
  if ( result != v2 )
  {
    result += 28;
    do
    {
      if ( result != 28 )
      {
        *(_DWORD *)(result - 28) = 0;
        *(_DWORD *)(result - 24) = 0;
        *(_DWORD *)(result - 20) = 0;
        *(_DWORD *)(result - 16) = 0;
        *(_DWORD *)(result - 8) = 0;
        *(_DWORD *)(result - 4) = 0;
        *(_DWORD *)result = 0;
        *(_DWORD *)(result + 4) = -1;
        *(_DWORD *)(result + 8) = -1;
        *(_DWORD *)(result + 12) = -1;
        *(_BYTE *)(result + 16) = 0;
      }
      result += 48;
    }
    while ( result - 28 != v2 );
  }
  return result;
}

//----- (10041070) --------------------------------------------------------
void __thiscall sub_10041070(void *this, int a2, int a3, int a4)
{
  _BYTE *v4; // ebx@1

  v4 = this;
  (*((void (__thiscall **)(_DWORD, _DWORD, _DWORD, _DWORD))this + 2))(*((_DWORD *)this + 1), a2, a3, a4);
  if ( v4[12] & 1 )
  {
    if ( (unsigned __int8)v4 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100410C0) --------------------------------------------------------
int __thiscall sub_100410C0(int this)
{
  int v1; // esi@1
  int v2; // edi@1
  int v3; // edx@1
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // esi@1

  v1 = *(_DWORD *)(this + 64);
  v2 = *(_DWORD *)(this + 4 * (((_BYTE)v1 - 3) & 0xF));
  v3 = *(_DWORD *)(this + 4 * v1) ^ v2 ^ ((v2 ^ 2 * *(_DWORD *)(this + 4 * v1)) << 15);
  v4 = (*(_DWORD *)(this + 4 * (((_BYTE)v1 - 7) & 0xF)) >> 11) ^ *(_DWORD *)(this + 4 * (((_BYTE)v1 - 7) & 0xF));
  v5 = v4 ^ v3;
  *(_DWORD *)(this + 4 * v1) = v5;
  v6 = ((unsigned __int8)*(_DWORD *)(this + 64) - 1) & 0xF;
  *(_DWORD *)(this + 64) = v6;
  *(_DWORD *)(this + 4 * v6) ^= v3 ^ v5 ^ 32 * (v5 & 0xFED22169) ^ 4
                                                                 * (*(_DWORD *)(this + 4 * v6) ^ ((v3 ^ (v4 << 10)) << 16));
  return *(_DWORD *)(this + 4 * *(_DWORD *)(this + 64));
}

//----- (10041130) --------------------------------------------------------
void *__thiscall sub_10041130(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_100A505C;
  if ( a2 & 1 )
    operator delete(this);
  return v2;
}
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100A505C: using guessed type int (__stdcall *off_100A505C)(char);

//----- (10041150) --------------------------------------------------------
int __usercall sub_10041150@<eax>(_BYTE *a1@<edi>, int a2@<esi>)
{
  int v2; // ecx@1
  int v3; // ecx@3
  int v4; // eax@3
  int result; // eax@3
  _BYTE *v6; // edx@4

  v2 = *(_DWORD *)(a2 + 516);
  if ( v2 || (sub_10067B70(a2), (v2 = *(_DWORD *)(a2 + 516)) != 0) )
  {
    v6 = *(_BYTE **)(a2 + 512);
    result = *v6;
    *a1 = 0;
    *(_DWORD *)(a2 + 512) = v6 + 1;
    *(_DWORD *)(a2 + 516) = v2 - 1;
  }
  else
  {
    v3 = *(_DWORD *)(a2 + 520) ^ 1;
    v4 = *(_DWORD *)(a2 + 520) != 0 ? 0xFFFFFFDA : 0;
    *a1 = 1;
    *(_DWORD *)(a2 + 520) = v3;
    result = v4 + 255;
  }
  return result;
}

//----- (100411B0) --------------------------------------------------------
char __usercall sub_100411B0@<al>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // eax@3
  _BYTE *v4; // eax@6
  char v6; // [sp+Bh] [bp-1h]@1

  v1 = a1;
  v2 = sub_10041150(&v6, a1);
  if ( v2 == 255 )
  {
    if ( !v6 )
    {
      v3 = sub_10041150(&v6, v1);
      if ( v6 )
      {
        *(_BYTE *)--*(_DWORD *)(v1 + 512) = -1;
        ++*(_DWORD *)(v1 + 516);
        LOBYTE(v2) = -1;
        return v2;
      }
      if ( v3 )
      {
        *(_BYTE *)--*(_DWORD *)(v1 + 512) = v3;
        v4 = (_BYTE *)--*(_DWORD *)(v1 + 512);
        ++*(_DWORD *)(v1 + 516);
        *v4 = -1;
        ++*(_DWORD *)(v1 + 516);
      }
    }
    LOBYTE(v2) = -1;
  }
  return v2;
}

//----- (10041230) --------------------------------------------------------
int __usercall sub_10041230@<eax>(int result@<eax>, int a2@<esi>)
{
  int v2; // ebx@2
  int v3; // ecx@2
  signed int v4; // ecx@3
  int v5; // eax@4
  int v6; // edi@7
  int v7; // eax@8

  if ( result )
  {
    *(_DWORD *)(a2 + 9104) -= result;
    v2 = *(_DWORD *)(a2 + 9108) >> (32 - result);
    v3 = *(_DWORD *)(a2 + 9104);
    if ( v3 > 0 )
    {
      *(_DWORD *)(a2 + 9108) <<= result;
      result = v2;
    }
    else
    {
      *(_DWORD *)(a2 + 9108) <<= result + v3;
      v4 = *(_DWORD *)(a2 + 516);
      if ( v4 < 2 || (v5 = *(_DWORD *)(a2 + 512), *(_BYTE *)v5 == -1) || *(_BYTE *)(v5 + 1) == -1 )
      {
        v6 = (unsigned __int8)sub_100411B0(a2);
        *(_DWORD *)(a2 + 9108) |= (unsigned __int8)sub_100411B0(a2) | (v6 << 8);
      }
      else
      {
        *(_DWORD *)(a2 + 9108) |= *(_BYTE *)(v5 + 1) | (*(_BYTE *)v5 << 8);
        *(_DWORD *)(a2 + 516) = v4 - 2;
        *(_DWORD *)(a2 + 512) = v5 + 2;
      }
      v7 = *(_DWORD *)(a2 + 9104);
      *(_DWORD *)(a2 + 9108) <<= -*(_BYTE *)(a2 + 9104);
      *(_DWORD *)(a2 + 9104) = v7 + 16;
      result = v2;
    }
  }
  return result;
}

//----- (10041300) --------------------------------------------------------
int __usercall sub_10041300@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // esi@1
  unsigned int v3; // eax@1
  int v4; // edi@1
  signed int v5; // ecx@2
  unsigned int v6; // ebx@3
  int result; // eax@4

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 9108);
  v4 = *(_DWORD *)(a2 + 4 * (v3 >> 24) + 4);
  if ( v4 >= 0 )
  {
    sub_10041230(*(_BYTE *)(v4 + a2 + 2052), v2);
    result = v4;
  }
  else
  {
    v5 = 23;
    do
    {
      v6 = v3 >> v5--;
      v4 = *(_DWORD *)(a2 + 4 * (577 - (v6 & 1) - v4));
    }
    while ( v4 < 0 );
    sub_10041230(31 - v5, v2);
    result = v4;
  }
  return result;
}

//----- (10041360) --------------------------------------------------------
int __thiscall sub_10041360(int this, char a2)
{
  int v2; // esi@1
  FILE *v3; // eax@1

  v2 = this;
  v3 = *(FILE **)(this + 4);
  *(_DWORD *)this = &off_100A5064;
  if ( v3 )
  {
    fclose(v3);
    *(_DWORD *)(v2 + 4) = 0;
  }
  *(_WORD *)(v2 + 8) = 0;
  *(_DWORD *)v2 = &off_100A505C;
  if ( a2 & 1 )
    operator delete((void *)v2);
  return v2;
}
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100A505C: using guessed type int (__stdcall *off_100A505C)(char);
// 100A5064: using guessed type int (__stdcall *off_100A5064)(char);

//----- (100413B0) --------------------------------------------------------
char __usercall sub_100413B0@<al>(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int v2; // eax@1
  char result; // al@4

  v2 = *(_DWORD *)(a1 + 4);
  if ( a2 == v2 )
    goto LABEL_6;
  if ( a2 < v2 || a2 <= *(_DWORD *)(a1 + 8) || (result = sub_100943C0(a2, 0, a1, a2 == v2 + 1, 0x10u, 1)) != 0 )
  {
    *(_DWORD *)(a1 + 4) = a2;
LABEL_6:
    result = 1;
  }
  return result;
}

//----- (100413F0) --------------------------------------------------------
char __stdcall sub_100413F0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // eax@1
  char result; // al@2

  v5 = sub_10092A80(16);
  if ( v5 )
  {
    *(_DWORD *)(v5 + 4) = a2;
    *(_DWORD *)(v5 + 8) = a3;
    *(_DWORD *)v5 = &off_100A4F34;
    *(_DWORD *)(v5 + 12) = 1;
    result = sub_100916A0(v5, a1, a4, a5, 0);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);

//----- (10041440) --------------------------------------------------------
void __stdcall sub_10041440(int a1)
{
  int v1; // eax@1
  int v2; // ecx@5
  int v3; // eax@6
  char v4; // [sp+8h] [bp-10h]@10
  int v5; // [sp+14h] [bp-4h]@1

  v5 = 1;
  v1 = *(_DWORD *)(a1 + 28);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
  LOBYTE(v5) = 0;
  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 )
  {
    sub_1004CEA0(*(_DWORD *)(a1 + 20), v2);
    v3 = *(_DWORD *)(a1 + 16);
    if ( v3 )
    {
      if ( v3 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
    }
  }
  v5 = 2;
  sub_1004A4D0(a1, **(_DWORD **)(a1 + 4), (int *)&v4, **(_DWORD ***)(a1 + 4), *(_DWORD **)(a1 + 4));
  operator delete(*(void **)(a1 + 4));
}
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10041510) --------------------------------------------------------
void __stdcall sub_10041510(int a1)
{
  int v1; // eax@1
  int v2; // eax@5
  int v3; // eax@6
  char v4; // [sp+8h] [bp-10h]@10
  int v5; // [sp+14h] [bp-4h]@1

  v5 = 1;
  v1 = *(_DWORD *)(a1 + 28);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
  LOBYTE(v5) = 0;
  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 )
  {
    sub_1004CEF0(v2, *(_DWORD *)(a1 + 20));
    v3 = *(_DWORD *)(a1 + 16);
    if ( v3 )
    {
      if ( v3 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
    }
  }
  v5 = 2;
  sub_1004A690(a1, **(_DWORD **)(a1 + 4), (int *)&v4, **(_DWORD ***)(a1 + 4), *(_DWORD **)(a1 + 4));
  operator delete(*(void **)(a1 + 4));
}
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100415E0) --------------------------------------------------------
void __stdcall sub_100415E0(int a1)
{
  char v1; // [sp+8h] [bp-10h]@1
  int v2; // [sp+14h] [bp-4h]@1

  v2 = 0;
  sub_1004A4D0(a1, **(_DWORD **)(a1 + 4), (int *)&v1, **(_DWORD ***)(a1 + 4), *(_DWORD **)(a1 + 4));
  operator delete(*(void **)(a1 + 4));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10041640) --------------------------------------------------------
void __stdcall sub_10041640(int a1)
{
  char v1; // [sp+8h] [bp-10h]@1
  int v2; // [sp+14h] [bp-4h]@1

  v2 = 0;
  sub_1004A690(a1, **(_DWORD **)(a1 + 4), (int *)&v1, **(_DWORD ***)(a1 + 4), *(_DWORD **)(a1 + 4));
  operator delete(*(void **)(a1 + 4));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (100416A0) --------------------------------------------------------
void __stdcall sub_100416A0(int a1)
{
  `eh vector destructor iterator'((void *)(a1 + 144), 0xCu, 2, sub_100371F0);
  sub_100417D0(a1);
}

//----- (10041700) --------------------------------------------------------
void __stdcall sub_10041700(int a1)
{
  int v1; // eax@1
  int v2; // eax@5
  int v3; // eax@6
  char v4; // [sp+8h] [bp-10h]@10
  int v5; // [sp+14h] [bp-4h]@1

  v5 = 1;
  v1 = *(_DWORD *)(a1 + 28);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
  LOBYTE(v5) = 0;
  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 )
  {
    sub_10040FD0(v2, *(_DWORD *)(a1 + 20));
    v3 = *(_DWORD *)(a1 + 16);
    if ( v3 )
    {
      if ( v3 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
    }
  }
  v5 = 2;
  sub_1004A8B0(a1, **(_DWORD **)(a1 + 4), (int *)&v4, **(_DWORD ***)(a1 + 4), *(_DWORD **)(a1 + 4));
  operator delete(*(void **)(a1 + 4));
}
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100417D0) --------------------------------------------------------
void __stdcall sub_100417D0(int a1)
{
  int v1; // eax@1
  int v2; // eax@5
  int v3; // eax@6
  char v4; // [sp+8h] [bp-10h]@10
  int v5; // [sp+14h] [bp-4h]@1

  v5 = 1;
  v1 = *(_DWORD *)(a1 + 28);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
  LOBYTE(v5) = 0;
  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 )
  {
    sub_10040FD0(v2, *(_DWORD *)(a1 + 20));
    v3 = *(_DWORD *)(a1 + 16);
    if ( v3 )
    {
      if ( v3 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
    }
  }
  v5 = 2;
  sub_1004A2C0(a1, **(_DWORD **)(a1 + 4), (int *)&v4, **(_DWORD ***)(a1 + 4), *(_DWORD **)(a1 + 4));
  operator delete(*(void **)(a1 + 4));
}
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100418A0) --------------------------------------------------------
void __stdcall sub_100418A0(int a1)
{
  char v1; // [sp+8h] [bp-10h]@1
  int v2; // [sp+14h] [bp-4h]@1

  v2 = 0;
  sub_1004A8B0(a1, **(_DWORD **)(a1 + 4), (int *)&v1, **(_DWORD ***)(a1 + 4), *(_DWORD **)(a1 + 4));
  operator delete(*(void **)(a1 + 4));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10041900) --------------------------------------------------------
void __stdcall sub_10041900(int a1)
{
  char v1; // [sp+8h] [bp-10h]@1
  int v2; // [sp+14h] [bp-4h]@1

  v2 = 0;
  sub_1004A2C0(a1, **(_DWORD **)(a1 + 4), (int *)&v1, **(_DWORD ***)(a1 + 4), *(_DWORD **)(a1 + 4));
  operator delete(*(void **)(a1 + 4));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10041960) --------------------------------------------------------
void __stdcall sub_10041960(int a1)
{
  int v1; // eax@1
  int v2; // ecx@5
  int v3; // eax@6
  char v4; // [sp+8h] [bp-10h]@10
  int v5; // [sp+14h] [bp-4h]@1

  v5 = 1;
  v1 = *(_DWORD *)(a1 + 28);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
  LOBYTE(v5) = 0;
  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 )
  {
    sub_1004CF40(*(_DWORD *)(a1 + 20), v2);
    v3 = *(_DWORD *)(a1 + 16);
    if ( v3 )
    {
      if ( v3 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
    }
  }
  v5 = 2;
  sub_1004AAF0(a1, **(_DWORD **)(a1 + 4), (int *)&v4, **(_DWORD ***)(a1 + 4), *(_DWORD **)(a1 + 4));
  operator delete(*(void **)(a1 + 4));
}
// 10099194: using guessed type void __cdecl operator delete(void *);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10041A30) --------------------------------------------------------
void __stdcall sub_10041A30(int a1)
{
  char v1; // [sp+8h] [bp-10h]@1
  int v2; // [sp+14h] [bp-4h]@1

  v2 = 0;
  sub_1004AAF0(a1, **(_DWORD **)(a1 + 4), (int *)&v1, **(_DWORD ***)(a1 + 4), *(_DWORD **)(a1 + 4));
  operator delete(*(void **)(a1 + 4));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10041A90) --------------------------------------------------------
void *__userpurge sub_10041A90@<eax>(unsigned int a1@<ebx>, int a2)
{
  void *result; // eax@1
  void *v3; // esi@5
  int i; // edi@5

  result = *(void **)(a2 + 4);
  if ( (void *)a1 != result )
  {
    if ( a1 >= (unsigned int)result )
    {
      if ( a1 > *(_DWORD *)(a2 + 8) )
        sub_100943C0(a1, 0, a2, a1 == (_DWORD)result + 1, 0x32u, 0);
      result = *(void **)(a2 + 4);
      v3 = (void *)(*(_DWORD *)a2 + 50 * (_DWORD)result);
      for ( i = (int)v3 + 50 * (a1 - (_DWORD)result); v3 != (void *)i; v3 = (char *)v3 + 50 )
      {
        if ( v3 )
          result = memset(v3, 0, 0x32u);
      }
    }
    *(_DWORD *)(a2 + 4) = a1;
  }
  return result;
}

//----- (10041B10) --------------------------------------------------------
void *__userpurge sub_10041B10@<eax>(unsigned int a1@<ebx>, int a2)
{
  void *result; // eax@1
  void *v3; // esi@5
  int i; // edi@5

  result = *(void **)(a2 + 4);
  if ( (void *)a1 != result )
  {
    if ( a1 >= (unsigned int)result )
    {
      if ( a1 > *(_DWORD *)(a2 + 8) )
        sub_100943C0(a1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004A0C0, a2, a1 == (_DWORD)result + 1, 0x294u, 0);
      result = *(void **)(a2 + 4);
      v3 = (void *)(*(_DWORD *)a2 + 660 * (_DWORD)result);
      for ( i = (int)v3 + 660 * (a1 - (_DWORD)result); v3 != (void *)i; v3 = (char *)v3 + 660 )
      {
        if ( v3 )
          result = memset(v3, 0, 0x294u);
      }
    }
    *(_DWORD *)(a2 + 4) = a1;
  }
  return result;
}
// 1004A0C0: using guessed type int sub_1004A0C0();

//----- (10041BD0) --------------------------------------------------------
void __usercall sub_10041BD0(int a1@<esi>)
{
  int *v1; // eax@2

  if ( *(_DWORD *)a1 )
  {
    sub_1003E4E0(*(_DWORD *)(a1 + 4), *(int **)a1);
    v1 = *(int **)a1;
    if ( *(_DWORD *)a1 )
    {
      if ( (unsigned __int8)v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10041C10) --------------------------------------------------------
int __stdcall sub_10041C10(int a1)
{
  int v1; // ebp@1
  _DWORD *v2; // eax@1

  v1 = a1;
  *(_DWORD *)(a1 + 8) = 0;
  v2 = sub_1004D0A0(1u);
  *(_DWORD *)(a1 + 4) = v2;
  *v2 = v2;
  *(_DWORD *)(*(_DWORD *)(v1 + 4) + 4) = *(_DWORD *)(v1 + 4);
  *(_DWORD *)(*(_DWORD *)(v1 + 4) + 8) = *(_DWORD *)(v1 + 4);
  *(_BYTE *)(*(_DWORD *)(a1 + 4) + 24) = 1;
  *(_BYTE *)(*(_DWORD *)(a1 + 4) + 25) = 1;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(float *)(a1 + 40) = 0.0;
  sub_10068990(a1 + 44, -569075913);
  *(_DWORD *)(a1 + 60) = 123456789;
  *(_DWORD *)(a1 + 64) = 362436000;
  *(_DWORD *)(a1 + 68) = 521288629;
  *(_DWORD *)(a1 + 72) = 7654321;
  sub_10068790(a1 + 76);
  sub_10068A50(a1 + 44);
  return a1;
}

//----- (10041CA0) --------------------------------------------------------
char __stdcall sub_10041CA0(int a1, unsigned int a2)
{
  int v2; // ebp@1
  unsigned int v3; // eax@1
  char result; // al@2
  float **v5; // eax@3
  float *v6; // esi@3
  unsigned int v7; // edx@4
  int v8; // edi@5
  unsigned int v9; // kr00_4@5
  double v10; // st7@5
  int v11; // ebp@5
  double v12; // st6@5
  int v13; // ebx@5
  float v14; // ST34_4@5
  float v15; // ST38_4@5
  char *v16; // eax@7
  bool v17; // zf@9
  double v18; // st6@9
  float v19; // ST2C_4@9
  float v20; // ST2C_4@9
  int v21; // eax@10
  float j; // eax@11
  int i; // eax@14
  float v24; // ST2C_4@20
  int v25; // eax@20
  int *v26; // esi@20
  float v27; // ST2C_4@20
  float v28; // ST30_4@20
  float v29; // ST30_4@20
  int v30; // eax@21
  unsigned int k; // edi@26
  unsigned int v32; // edx@27
  int v33; // ebx@27
  int v34; // ecx@28
  int v35; // eax@36
  unsigned int v36; // ebx@36
  FILE *v37; // eax@38
  int v38; // esi@44
  unsigned int v39; // eax@45
  int v40; // eax@47
  FILE *v41; // eax@51
  float v42; // [sp+14h] [bp-268h]@5
  float v43; // [sp+14h] [bp-268h]@27
  int v44; // [sp+14h] [bp-268h]@43
  float v45; // [sp+24h] [bp-258h]@3
  float v46; // [sp+28h] [bp-254h]@3
  unsigned __int64 v47; // [sp+2Ch] [bp-250h]@3
  float v48; // [sp+34h] [bp-248h]@20
  void *v49; // [sp+38h] [bp-244h]@3
  unsigned int v50; // [sp+3Ch] [bp-240h]@3
  unsigned int v51; // [sp+40h] [bp-23Ch]@3
  int v52; // [sp+44h] [bp-238h]@3
  int v53; // [sp+48h] [bp-234h]@3
  int v54; // [sp+4Ch] [bp-230h]@3
  char v55; // [sp+50h] [bp-22Ch]@3
  double v56; // [sp+54h] [bp-228h]@3
  int v57; // [sp+68h] [bp-214h]@5
  char DstBuf; // [sp+6Ch] [bp-210h]@38
  int v59; // [sp+278h] [bp-4h]@3

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 8);
  if ( v3 )
  {
    v56 = 0.0;
    v47 = 0i64;
    v45 = 0.0;
    v49 = 0;
    v46 = 0.0;
    v50 = 0;
    v51 = 0;
    v52 = -1;
    v53 = -1;
    v54 = -1;
    v55 = 0;
    v59 = 0;
    sub_1003FE70((int)&v49, v3);
    v5 = *(float ***)(a1 + 4);
    v6 = *v5;
    if ( (float **)*v5 != v5 )
    {
      v7 = v50;
      do
      {
        v8 = *((_DWORD *)v6 + 5);
        v42 = (double)*((unsigned int *)v6 + 5);
        v9 = v47;
        LODWORD(v47) = v8 + v47;
        v10 = v42;
        v11 = *((_DWORD *)v6 + 4);
        v57 = v8;
        v12 = v42 * v6[3];
        v47 = __PAIR__(HIDWORD(v47), v8) + v9;
        v13 = *((_DWORD *)v6 + 3);
        v14 = v12;
        v15 = v42 * v6[4];
        v45 = v14 + v45;
        v46 = v15 + v46;
        if ( v7 >= v51 )
        {
          sub_100943C0(v7 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040A40, (int)&v49, 1, 0xCu, 0);
          v10 = v42;
          v7 = v50;
        }
        v16 = (char *)v49 + 12 * v7;
        if ( v16 )
        {
          *(_DWORD *)v16 = v13;
          *((_DWORD *)v16 + 1) = v11;
          *((_DWORD *)v16 + 2) = v8;
        }
        ++v7;
        v17 = *((_BYTE *)v6 + 25) == 0;
        v18 = v6[3] * v6[3];
        v50 = v7;
        v19 = v18;
        v20 = v6[4] * v6[4] + v19;
        v56 = v10 * v20 + v56;
        if ( v17 )
        {
          v21 = *((_DWORD *)v6 + 2);
          if ( *(_BYTE *)(v21 + 25) )
          {
            for ( i = *((_DWORD *)v6 + 1); !*(_BYTE *)(i + 25); i = *(_DWORD *)(i + 4) )
            {
              if ( v6 != *(float **)(i + 8) )
                break;
              v6 = (float *)i;
            }
            v6 = (float *)i;
          }
          else
          {
            v6 = (float *)*((_DWORD *)v6 + 2);
            for ( j = *(float *)v21; !*(_BYTE *)(LODWORD(j) + 25); j = *(float *)LODWORD(j) )
              v6 = (float *)LODWORD(j);
          }
        }
      }
      while ( v6 != *(float **)(a1 + 4) );
      v2 = a1;
    }
    v24 = v45 * v45;
    v25 = *(_DWORD *)(v2 + 16);
    v26 = (int *)(v2 + 16);
    v27 = v46 * v46 + v24;
    v28 = (double)v47;
    v48 = v56 - v27 / v28;
    v29 = 1.0 / v28;
    v45 = v45 * v29;
    v46 = v29 * v46;
    if ( v25 )
    {
      sub_10040FD0(v25, *(_DWORD *)(v2 + 20));
      v30 = *v26;
      if ( *v26 )
      {
        if ( v30 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v30, 0, 0, 1, dword_100AE9F4);
      }
      *v26 = 0;
      *(_DWORD *)(v2 + 20) = 0;
      *(_DWORD *)(v2 + 24) = 0;
    }
    sub_10044D10((int)v26, 2 * a2 + 1);
    sub_10044E20((int)&v45, v2 + 16);
    for ( k = 1; k < a2; ++k )
    {
      v32 = 0;
      v33 = -1;
      v43 = -1.0;
      if ( !*(_DWORD *)(v2 + 20) )
        break;
      v34 = *(_DWORD *)(v2 + 16) + 16;
      do
      {
        if ( *(_DWORD *)(v34 + 16) == -1 && !*(_BYTE *)(v34 + 28) && v43 < (double)*(float *)v34 )
        {
          v33 = v32;
          v43 = *(float *)v34;
        }
        ++v32;
        v34 += 48;
      }
      while ( v32 < *(_DWORD *)(v2 + 20) );
      if ( v43 <= 0.0 )
        break;
      sub_10043E90(v2, v33);
    }
    v35 = *(_DWORD *)(v2 + 28);
    v36 = 0;
    if ( v35 )
    {
      if ( v35 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v37 = _iob_func();
        fputs(&DstBuf, v37 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v35, 0, 0, 1, dword_100AE9F4);
      }
      *(_DWORD *)(v2 + 28) = 0;
      *(_DWORD *)(v2 + 32) = 0;
      *(_DWORD *)(v2 + 36) = 0;
    }
    *(float *)(v2 + 40) = 0.0;
    if ( *(_DWORD *)(v2 + 20) > 0u )
    {
      v44 = 0;
      do
      {
        v38 = v44 + *(_DWORD *)(v2 + 16);
        if ( *(_DWORD *)(v38 + 32) == -1 )
        {
          *(_DWORD *)(v38 + 40) = *(_DWORD *)(v2 + 32);
          v39 = *(_DWORD *)(v2 + 32);
          if ( v39 >= *(_DWORD *)(v2 + 36) )
            sub_100943C0(v39 + 1, 0, v2 + 28, 1, 8u, 0);
          v40 = *(_DWORD *)(v2 + 28) + 8 * *(_DWORD *)(v2 + 32);
          *(_DWORD *)v40 = *(_DWORD *)v38;
          *(_DWORD *)(v40 + 4) = *(_DWORD *)(v38 + 4);
          ++*(_DWORD *)(v2 + 32);
          *(float *)(v2 + 40) = *(float *)(v38 + 16) + *(float *)(v2 + 40);
        }
        v44 += 48;
        ++v36;
      }
      while ( v36 < *(_DWORD *)(v2 + 20) );
    }
    v59 = -1;
    if ( v49 )
    {
      if ( (unsigned __int8)v49 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v41 = _iob_func();
        fputs(&DstBuf, v41 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v49, 0, 0, 1, dword_100AE9F4);
      }
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10040A40: using guessed type int sub_10040A40();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10042140) --------------------------------------------------------
int __userpurge sub_10042140@<eax>(int a1@<esi>, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // edi@1
  int v4; // ebx@1
  unsigned int v5; // ecx@1
  int v6; // edx@2
  float v7; // ST0C_4@3
  float v8; // ST0C_4@5
  float v9; // ST0C_4@7
  float v10; // ST0C_4@9
  int v11; // edx@13
  float v12; // ST0C_4@14
  float v14; // [sp+8h] [bp-8h]@3
  float v15; // [sp+8h] [bp-8h]@5
  float v16; // [sp+8h] [bp-8h]@7
  float v17; // [sp+8h] [bp-8h]@9
  float v18; // [sp+8h] [bp-8h]@14
  float v19; // [sp+Ch] [bp-4h]@1
  float v20; // [sp+14h] [bp+4h]@3
  float v21; // [sp+14h] [bp+4h]@3
  float v22; // [sp+14h] [bp+4h]@5
  float v23; // [sp+14h] [bp+4h]@5
  float v24; // [sp+14h] [bp+4h]@7
  float v25; // [sp+14h] [bp+4h]@7
  float v26; // [sp+14h] [bp+4h]@9
  float v27; // [sp+14h] [bp+4h]@9
  float v28; // [sp+14h] [bp+4h]@14
  float v29; // [sp+14h] [bp+4h]@14

  v19 = 9.9999999e36;
  v2 = a2;
  v3 = *(_DWORD *)(a2 + 32);
  v4 = 0;
  v5 = 0;
  if ( (signed int)v3 < 4 )
  {
LABEL_12:
    if ( v5 < v3 )
    {
      v11 = *(_DWORD *)(v2 + 28) + 8 * v5;
      do
      {
        v28 = *(float *)v11 - *(float *)a1;
        v12 = v28 * v28 + 0.0;
        v29 = *(float *)(v11 + 4) - *(float *)(a1 + 4);
        v18 = v29 * v29 + v12;
        if ( v19 > (double)v18 )
        {
          v19 = v18;
          v4 = v5;
          if ( 0.0 == v18 )
            break;
        }
        ++v5;
        v11 += 8;
      }
      while ( v5 < v3 );
    }
  }
  else
  {
    v6 = *(_DWORD *)(a2 + 28) + 8;
    while ( 1 )
    {
      v20 = *(float *)(v6 - 8) - *(float *)a1;
      v7 = v20 * v20 + 0.0;
      v21 = *(float *)(v6 - 4) - *(float *)(a1 + 4);
      v14 = v21 * v21 + v7;
      if ( v19 > (double)v14 )
      {
        v19 = v14;
        v4 = v5;
        if ( 0.0 == v14 )
          break;
      }
      v22 = *(float *)v6 - *(float *)a1;
      v8 = v22 * v22 + 0.0;
      v23 = *(float *)(v6 + 4) - *(float *)(a1 + 4);
      v15 = v23 * v23 + v8;
      if ( v19 > (double)v15 )
      {
        v19 = v15;
        v4 = v5 + 1;
        if ( 0.0 == v15 )
          break;
      }
      v24 = *(float *)(v6 + 8) - *(float *)a1;
      v9 = v24 * v24 + 0.0;
      v25 = *(float *)(v6 + 12) - *(float *)(a1 + 4);
      v16 = v25 * v25 + v9;
      if ( v19 > (double)v16 )
      {
        v19 = v16;
        v4 = v5 + 2;
        if ( 0.0 == v16 )
          break;
      }
      v26 = *(float *)(v6 + 16) - *(float *)a1;
      v10 = v26 * v26 + 0.0;
      v27 = *(float *)(v6 + 20) - *(float *)(a1 + 4);
      v17 = v27 * v27 + v10;
      if ( v19 > (double)v17 )
      {
        v19 = v17;
        v4 = v5 + 3;
        if ( 0.0 == v17 )
          break;
      }
      v5 += 4;
      v6 += 32;
      if ( v5 >= v3 - 3 )
        goto LABEL_12;
    }
  }
  return v4;
}

//----- (10042350) --------------------------------------------------------
int __usercall sub_10042350@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // eax@1
  int (__stdcall **v3)(char); // [sp+Ch] [bp-10h]@3
  char v4; // [sp+10h] [bp-Ch]@3

  *(_DWORD *)(a1 + 8) = 0;
  v1 = operator new(0x2Cu);
  if ( !v1 )
  {
    v3 = 0;
    std::exception::exception((std::exception *)&v4, (const char *const *)&v3);
    v3 = &off_10099840;
    CxxThrowException(&v3, &unk_100A5EA0);
  }
  *(_DWORD *)(a1 + 4) = v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8) = *(_DWORD *)(a1 + 4);
  *(_BYTE *)(*(_DWORD *)(a1 + 4) + 40) = 1;
  *(_BYTE *)(*(_DWORD *)(a1 + 4) + 41) = 1;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(float *)(a1 + 40) = 0.0;
  sub_10068990(a1 + 44, -569075913);
  *(_DWORD *)(a1 + 60) = 123456789;
  *(_DWORD *)(a1 + 64) = 362436000;
  *(_DWORD *)(a1 + 68) = 521288629;
  *(_DWORD *)(a1 + 72) = 7654321;
  sub_10068790(a1 + 76);
  sub_10068A50(a1 + 44);
  return a1;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (10042410) --------------------------------------------------------
int __userpurge sub_10042410@<eax>(int a1@<eax>, int a2@<ecx>, unsigned int a3)
{
  int v3; // edi@1
  _DWORD *v4; // eax@1
  int result; // eax@1
  int v6; // [sp+8h] [bp-3Ch]@1
  float v7; // [sp+10h] [bp-34h]@1
  float v8; // [sp+14h] [bp-30h]@1
  float v9; // [sp+18h] [bp-2Ch]@1
  float v10; // [sp+1Ch] [bp-28h]@1
  float v11; // [sp+20h] [bp-24h]@1
  float v12; // [sp+24h] [bp-20h]@1
  float v13; // [sp+28h] [bp-1Ch]@1
  float v14; // [sp+2Ch] [bp-18h]@1
  float v15; // [sp+30h] [bp-14h]@1
  float v16; // [sp+34h] [bp-10h]@1
  float v17; // [sp+38h] [bp-Ch]@1
  float v18; // [sp+3Ch] [bp-8h]@1
  int v19; // [sp+40h] [bp-4h]@1

  v7 = *(float *)a1;
  v8 = *(float *)(a1 + 4);
  v9 = *(float *)(a1 + 8);
  v3 = a2;
  v10 = *(float *)(a1 + 12);
  v19 = 0;
  v11 = *(float *)(a1 + 16);
  v12 = *(float *)(a1 + 20);
  v13 = v7;
  v14 = v8;
  v15 = v9;
  v16 = v10;
  v17 = v11;
  v18 = v12;
  v4 = sub_1004E2D0(a2, (int)&v13);
  sub_1004D220((int)&v6, v3, (int)v4);
  result = -1 - a3;
  if ( a3 <= -1 - a3 )
  {
    result = v6;
    *(_DWORD *)(result + 36) += a3;
  }
  else
  {
    *(_DWORD *)(v6 + 36) = -1;
  }
  return result;
}

//----- (100424D0) --------------------------------------------------------
char __userpurge sub_100424D0@<al>(int a1@<eax>, int a2, unsigned int a3)
{
  int v3; // ebp@1
  unsigned int v4; // ecx@1
  char v5; // di@1
  char result; // al@2
  float **v7; // eax@3
  float *v8; // esi@3
  int v9; // edi@4
  int v10; // ecx@4
  double v11; // st7@4
  int v12; // eax@4
  int v13; // edx@4
  int v14; // ebp@4
  int v15; // ebx@4
  double v16; // st6@4
  unsigned int v17; // ecx@4
  double v18; // st6@4
  char *v19; // eax@6
  int v20; // edx@7
  bool v21; // zf@8
  double v22; // st6@8
  float v23; // ST28_4@8
  float v24; // ST28_4@8
  float v25; // ST28_4@8
  float v26; // ST28_4@8
  float v27; // ST28_4@8
  float v28; // ST28_4@8
  int v29; // eax@9
  float j; // eax@10
  int i; // eax@13
  float v32; // ST28_4@19
  int *v33; // ebx@19
  float v34; // ST28_4@19
  float v35; // ST28_4@19
  float v36; // ST28_4@19
  float v37; // ST28_4@19
  float v38; // ST28_4@19
  int v39; // ecx@19
  float v40; // ST2C_4@19
  float v41; // ST2C_4@19
  int v42; // eax@20
  unsigned int v43; // eax@25
  int v44; // edi@27
  int v45; // edi@27
  int v46; // ecx@28
  int v47; // edx@28
  char v48; // al@28
  unsigned int k; // ebx@29
  unsigned int v50; // edx@30
  int v51; // edi@30
  int v52; // ecx@31
  int v53; // eax@39
  int *v54; // edi@39
  unsigned int v55; // ebx@39
  FILE *v56; // eax@41
  int v57; // esi@47
  unsigned int v58; // eax@48
  int v59; // edx@50
  int v60; // eax@50
  int v61; // eax@50
  FILE *v62; // eax@54
  float v63; // [sp+0h] [bp-29Ch]@4
  float v64; // [sp+0h] [bp-29Ch]@30
  int v65; // [sp+0h] [bp-29Ch]@46
  float v66; // [sp+Ch] [bp-290h]@3
  float v67; // [sp+Ch] [bp-290h]@19
  float v68; // [sp+10h] [bp-28Ch]@3
  float v69; // [sp+10h] [bp-28Ch]@19
  float v70; // [sp+14h] [bp-288h]@3
  float v71; // [sp+14h] [bp-288h]@19
  float v72; // [sp+18h] [bp-284h]@3
  float v73; // [sp+18h] [bp-284h]@19
  float v74; // [sp+1Ch] [bp-280h]@3
  float v75; // [sp+1Ch] [bp-280h]@19
  float v76; // [sp+20h] [bp-27Ch]@3
  float v77; // [sp+20h] [bp-27Ch]@19
  unsigned __int64 v78; // [sp+24h] [bp-278h]@3
  float v79; // [sp+2Ch] [bp-270h]@19
  void *v80; // [sp+30h] [bp-26Ch]@3
  unsigned int v81; // [sp+34h] [bp-268h]@3
  unsigned int v82; // [sp+38h] [bp-264h]@3
  int v83; // [sp+3Ch] [bp-260h]@3
  int v84; // [sp+40h] [bp-25Ch]@3
  int v85; // [sp+44h] [bp-258h]@3
  char v86; // [sp+48h] [bp-254h]@3
  float v87; // [sp+4Ch] [bp-250h]@4
  float v88; // [sp+50h] [bp-24Ch]@4
  float v89; // [sp+54h] [bp-248h]@4
  float v90; // [sp+58h] [bp-244h]@4
  float v91; // [sp+5Ch] [bp-240h]@4
  float v92; // [sp+60h] [bp-23Ch]@4
  double v93; // [sp+64h] [bp-238h]@3
  int v94; // [sp+70h] [bp-22Ch]@4
  int v95; // [sp+74h] [bp-228h]@4
  int v96; // [sp+78h] [bp-224h]@4
  int v97; // [sp+80h] [bp-21Ch]@4
  int v98; // [sp+88h] [bp-214h]@4
  char DstBuf; // [sp+8Ch] [bp-210h]@41
  int v100; // [sp+290h] [bp-Ch]@1
  int (__thiscall *v101)(void *); // [sp+294h] [bp-8h]@1
  int v102; // [sp+298h] [bp-4h]@1

  v102 = -1;
  v101 = sub_100980D0;
  v100 = a1;
  v3 = a2;
  v4 = *(_DWORD *)(a2 + 8);
  v5 = 0;
  if ( v4 )
  {
    v66 = 0.0;
    v93 = 0.0;
    v68 = 0.0;
    v70 = 0.0;
    v72 = 0.0;
    v74 = 0.0;
    v76 = 0.0;
    v78 = 0i64;
    v80 = 0;
    v81 = 0;
    v82 = 0;
    v83 = -1;
    v84 = -1;
    v85 = -1;
    v86 = 0;
    v102 = 0;
    sub_10039830((int)&v80, v4);
    v7 = *(float ***)(a2 + 4);
    v8 = *v7;
    if ( (float **)*v7 != v7 )
    {
      do
      {
        v9 = *((_DWORD *)v8 + 9);
        v63 = (double)*((unsigned int *)v8 + 9);
        v10 = *((_DWORD *)v8 + 4);
        v11 = v63;
        v12 = *((_DWORD *)v8 + 3);
        v13 = *((_DWORD *)v8 + 5);
        v78 += (unsigned int)v9;
        v14 = *((_DWORD *)v8 + 6);
        v87 = v63 * v8[3];
        v15 = *((_DWORD *)v8 + 8);
        v95 = v10;
        v16 = v63 * v8[4];
        v97 = *((_DWORD *)v8 + 7);
        v17 = v81;
        v94 = v12;
        v88 = v16;
        v96 = v13;
        v18 = v8[5];
        v98 = v9;
        v89 = v18 * v63;
        v90 = v63 * v8[6];
        v91 = v63 * v8[7];
        v92 = v63 * v8[8];
        v66 = v87 + v66;
        v68 = v68 + v88;
        v70 = v70 + v89;
        v72 = v72 + v90;
        v74 = v74 + v91;
        v76 = v76 + v92;
        if ( v81 >= v82 )
        {
          sub_100943C0(v81 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003B7E0, (int)&v80, 1, 0x1Cu, 0);
          v11 = v63;
          v17 = v81;
        }
        v19 = (char *)v80 + 28 * v17;
        if ( v19 )
        {
          *(_DWORD *)v19 = v94;
          *((_DWORD *)v19 + 1) = v95;
          *((_DWORD *)v19 + 2) = v96;
          v20 = v97;
          *((_DWORD *)v19 + 3) = v14;
          *((_DWORD *)v19 + 4) = v20;
          *((_DWORD *)v19 + 5) = v15;
          *((_DWORD *)v19 + 6) = v9;
        }
        v21 = *((_BYTE *)v8 + 41) == 0;
        v22 = v8[3] * v8[3];
        v81 = v17 + 1;
        v23 = v22;
        v24 = v8[4] * v8[4] + v23;
        v25 = v8[5] * v8[5] + v24;
        v26 = v8[6] * v8[6] + v25;
        v27 = v8[7] * v8[7] + v26;
        v28 = v8[8] * v8[8] + v27;
        v93 = v11 * v28 + v93;
        if ( v21 )
        {
          v29 = *((_DWORD *)v8 + 2);
          if ( *(_BYTE *)(v29 + 41) )
          {
            for ( i = *((_DWORD *)v8 + 1); !*(_BYTE *)(i + 41); i = *(_DWORD *)(i + 4) )
            {
              if ( v8 != *(float **)(i + 8) )
                break;
              v8 = (float *)i;
            }
            v8 = (float *)i;
          }
          else
          {
            v8 = (float *)*((_DWORD *)v8 + 2);
            for ( j = *(float *)v29; !*(_BYTE *)(LODWORD(j) + 41); j = *(float *)LODWORD(j) )
              v8 = (float *)LODWORD(j);
          }
        }
        v3 = a2;
      }
      while ( v8 != *(float **)(a2 + 4) );
      v5 = 0;
    }
    v32 = v66 * v66;
    v33 = (int *)(v3 + 16);
    v34 = v68 * v68 + v32;
    v35 = v70 * v70 + v34;
    v36 = v72 * v72 + v35;
    v37 = v74 * v74 + v36;
    v38 = v76 * v76 + v37;
    v39 = *(_DWORD *)(v3 + 16);
    v40 = (double)v78;
    v79 = v93 - v38 / v40;
    v41 = 1.0 / v40;
    v67 = v66 * v41;
    v69 = v68 * v41;
    v71 = v70 * v41;
    v73 = v72 * v41;
    v75 = v74 * v41;
    v77 = v41 * v76;
    if ( v39 )
    {
      sub_1004CEA0(*(_DWORD *)(v3 + 20), v39);
      v42 = *v33;
      if ( *v33 )
      {
        if ( v42 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v42, 0, 0, 1, dword_100AE9F4);
      }
      *v33 = 0;
      *(_DWORD *)(v3 + 20) = 0;
      *(_DWORD *)(v3 + 24) = 0;
    }
    sub_10046720(v3 + 16, 2 * a3 + 1);
    v43 = *(_DWORD *)(v3 + 20);
    if ( v43 >= *(_DWORD *)(v3 + 24) )
      sub_100943C0(v43 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004B740, v3 + 16, 1, 0x40u, v5);
    v44 = *(_DWORD *)(v3 + 20) << 6;
    v21 = *v33 + v44 == 0;
    v45 = *v33 + v44;
    LOBYTE(v102) = 1;
    if ( !v21 )
    {
      *(float *)v45 = v67;
      *(float *)(v45 + 4) = v69;
      *(float *)(v45 + 8) = v71;
      *(float *)(v45 + 12) = v73;
      *(float *)(v45 + 16) = v75;
      *(float *)(v45 + 20) = v77;
      *(_QWORD *)(v45 + 24) = v78;
      *(float *)(v45 + 32) = v79;
      sub_1004CC60((int)&v80, v45 + 36);
      v46 = v84;
      v47 = v85;
      *(_DWORD *)(v45 + 48) = v83;
      v48 = v86;
      *(_DWORD *)(v45 + 52) = v46;
      *(_DWORD *)(v45 + 56) = v47;
      *(_BYTE *)(v45 + 60) = v48;
    }
    LOBYTE(v102) = 0;
    ++*(_DWORD *)(v3 + 20);
    for ( k = 1; k < a3; ++k )
    {
      v50 = 0;
      v51 = -1;
      v64 = -1.0;
      if ( !*(_DWORD *)(v3 + 20) )
        break;
      v52 = *(_DWORD *)(v3 + 16) + 32;
      do
      {
        if ( *(_DWORD *)(v52 + 16) == -1 && !*(_BYTE *)(v52 + 28) && v64 < (double)*(float *)v52 )
        {
          v51 = v50;
          v64 = *(float *)v52;
        }
        ++v50;
        v52 += 64;
      }
      while ( v50 < *(_DWORD *)(v3 + 20) );
      if ( v64 <= 0.0 )
        break;
      sub_10044ED0(v3, v51);
    }
    v53 = *(_DWORD *)(v3 + 28);
    v54 = (int *)(v3 + 28);
    v55 = 0;
    if ( v53 )
    {
      if ( v53 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v56 = _iob_func();
        fputs(&DstBuf, v56 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v53, 0, 0, 1, dword_100AE9F4);
      }
      *v54 = 0;
      *(_DWORD *)(v3 + 32) = 0;
      *(_DWORD *)(v3 + 36) = 0;
    }
    *(float *)(v3 + 40) = 0.0;
    if ( *(_DWORD *)(v3 + 20) > 0u )
    {
      v65 = 0;
      do
      {
        v57 = v65 + *(_DWORD *)(v3 + 16);
        if ( *(_DWORD *)(v57 + 48) == -1 )
        {
          *(_DWORD *)(v57 + 56) = *(_DWORD *)(v3 + 32);
          v58 = *(_DWORD *)(v3 + 32);
          if ( v58 >= *(_DWORD *)(v3 + 36) )
            sub_100943C0(v58 + 1, 0, v3 + 28, 1, 0x18u, 0);
          v59 = 3 * *(_DWORD *)(v3 + 32);
          v60 = *v54;
          *(_DWORD *)(v60 + 8 * v59) = *(_DWORD *)v57;
          v61 = v60 + 8 * v59;
          *(_DWORD *)(v61 + 4) = *(_DWORD *)(v57 + 4);
          *(_DWORD *)(v61 + 8) = *(_DWORD *)(v57 + 8);
          *(_DWORD *)(v61 + 12) = *(_DWORD *)(v57 + 12);
          *(_DWORD *)(v61 + 16) = *(_DWORD *)(v57 + 16);
          *(_DWORD *)(v61 + 20) = *(_DWORD *)(v57 + 20);
          ++*(_DWORD *)(v3 + 32);
          *(float *)(v3 + 40) = *(float *)(v57 + 32) + *(float *)(v3 + 40);
        }
        v65 += 64;
        ++v55;
      }
      while ( v55 < *(_DWORD *)(v3 + 20) );
    }
    v102 = -1;
    if ( v80 )
    {
      if ( (unsigned __int8)v80 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v62 = _iob_func();
        fputs(&DstBuf, v62 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v80, 0, 0, 1, dword_100AE9F4);
      }
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1004B740: using guessed type int sub_1004B740();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10042BA0) --------------------------------------------------------
unsigned int __userpurge sub_10042BA0@<eax>(int a1@<eax>, int a2)
{
  unsigned int v2; // edi@1
  unsigned int v3; // ebp@1
  unsigned int v4; // esi@1
  int v5; // ebx@2
  unsigned int result; // eax@6
  float v7; // [sp+8h] [bp-8h]@1
  float v8; // [sp+Ch] [bp-4h]@3

  v7 = 9.9999999e36;
  v2 = *(_DWORD *)(a1 + 32);
  v3 = 0;
  v4 = 0;
  if ( v2 )
  {
    v5 = *(_DWORD *)(a1 + 28);
    do
    {
      v8 = sub_1003CC80(a2, v5);
      if ( v7 > (double)v8 )
      {
        v7 = v8;
        v3 = v4;
        if ( 0.0 == v8 )
          break;
      }
      ++v4;
      v5 += 24;
    }
    while ( v4 < v2 );
    result = v3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10042C60) --------------------------------------------------------
int __usercall sub_10042C60@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // eax@1
  int (__stdcall **v3)(char); // [sp+Ch] [bp-10h]@3
  char v4; // [sp+10h] [bp-Ch]@3

  *(_DWORD *)(a1 + 8) = 0;
  v1 = operator new(0x20u);
  if ( !v1 )
  {
    v3 = 0;
    std::exception::exception((std::exception *)&v4, (const char *const *)&v3);
    v3 = &off_10099840;
    CxxThrowException(&v3, &unk_100A5EA0);
  }
  *(_DWORD *)(a1 + 4) = v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8) = *(_DWORD *)(a1 + 4);
  *(_BYTE *)(*(_DWORD *)(a1 + 4) + 28) = 1;
  *(_BYTE *)(*(_DWORD *)(a1 + 4) + 29) = 1;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(float *)(a1 + 40) = 0.0;
  sub_10068990(a1 + 44, -569075913);
  *(_DWORD *)(a1 + 60) = 123456789;
  *(_DWORD *)(a1 + 64) = 362436000;
  *(_DWORD *)(a1 + 68) = 521288629;
  *(_DWORD *)(a1 + 72) = 7654321;
  sub_10068790(a1 + 76);
  sub_10068A50(a1 + 44);
  return a1;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (10042D20) --------------------------------------------------------
char __stdcall sub_10042D20(int a1)
{
  int v1; // ebp@1
  unsigned int v2; // eax@1
  char result; // al@2
  float **v4; // eax@3
  float *v5; // esi@3
  int v6; // edi@4
  unsigned int v7; // kr00_4@4
  double v8; // st7@4
  unsigned int v9; // ecx@4
  int v10; // edx@4
  double v11; // st6@4
  int v12; // ebx@4
  int v13; // ebp@4
  char *v14; // eax@6
  int v15; // edx@7
  bool v16; // zf@8
  double v17; // st6@8
  float v18; // ST28_4@8
  float v19; // ST28_4@8
  float v20; // ST28_4@8
  int v21; // eax@9
  float j; // eax@10
  int i; // eax@13
  float v24; // ST28_4@19
  int v25; // eax@19
  int *v26; // esi@19
  float v27; // ST28_4@19
  float v28; // ST28_4@19
  float v29; // ST2C_4@19
  float v30; // ST2C_4@19
  int v31; // eax@20
  unsigned int v32; // edi@25
  unsigned int v33; // edx@26
  int v34; // ebx@26
  int v35; // ecx@27
  int v36; // eax@35
  int *v37; // edi@35
  unsigned int v38; // ebx@35
  FILE *v39; // eax@37
  int v40; // esi@43
  unsigned int v41; // eax@44
  int v42; // edx@46
  int v43; // eax@46
  int v44; // eax@46
  FILE *v45; // eax@50
  float v46; // [sp+10h] [bp-280h]@4
  float v47; // [sp+10h] [bp-280h]@26
  int v48; // [sp+10h] [bp-280h]@42
  float v49; // [sp+1Ch] [bp-274h]@3
  float v50; // [sp+20h] [bp-270h]@3
  float v51; // [sp+24h] [bp-26Ch]@3
  unsigned __int64 v52; // [sp+2Ch] [bp-264h]@3
  float v53; // [sp+34h] [bp-25Ch]@19
  void *v54; // [sp+38h] [bp-258h]@3
  unsigned int v55; // [sp+3Ch] [bp-254h]@3
  unsigned int v56; // [sp+40h] [bp-250h]@3
  int v57; // [sp+44h] [bp-24Ch]@3
  int v58; // [sp+48h] [bp-248h]@3
  int v59; // [sp+4Ch] [bp-244h]@3
  char v60; // [sp+50h] [bp-240h]@3
  float v61; // [sp+58h] [bp-238h]@4
  float v62; // [sp+5Ch] [bp-234h]@4
  float v63; // [sp+60h] [bp-230h]@4
  double v64; // [sp+64h] [bp-22Ch]@3
  int v65; // [sp+74h] [bp-21Ch]@4
  int v66; // [sp+78h] [bp-218h]@4
  char DstBuf; // [sp+7Ch] [bp-214h]@37
  int v68; // [sp+28Ch] [bp-4h]@3

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 )
  {
    v64 = 0.0;
    v52 = 0i64;
    v49 = 0.0;
    v54 = 0;
    v50 = 0.0;
    v55 = 0;
    v51 = 0.0;
    v56 = 0;
    v57 = -1;
    v58 = -1;
    v59 = -1;
    v60 = 0;
    v68 = 0;
    sub_10049EA0((int)&v54, v2);
    v4 = *(float ***)(a1 + 4);
    v5 = *v4;
    if ( (float **)*v4 != v4 )
    {
      do
      {
        v6 = *((_DWORD *)v5 + 6);
        v46 = (double)*((unsigned int *)v5 + 6);
        v7 = v52;
        LODWORD(v52) = v6 + v52;
        v8 = v46;
        v9 = v55;
        v10 = *((_DWORD *)v5 + 5);
        v11 = v46 * v5[3];
        v52 = __PAIR__(HIDWORD(v52), v6) + v7;
        v12 = *((_DWORD *)v5 + 3);
        v13 = *((_DWORD *)v5 + 4);
        v61 = v11;
        v65 = v10;
        v66 = v6;
        v62 = v46 * v5[4];
        v63 = v46 * v5[5];
        v49 = v61 + v49;
        v50 = v62 + v50;
        v51 = v63 + v51;
        if ( v55 >= v56 )
        {
          sub_100943C0(v55 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C600, (int)&v54, 1, 0x10u, 0);
          v8 = v46;
          v9 = v55;
        }
        v14 = (char *)v54 + 16 * v9;
        if ( v14 )
        {
          v15 = v65;
          *(_DWORD *)v14 = v12;
          *((_DWORD *)v14 + 1) = v13;
          *((_DWORD *)v14 + 2) = v15;
          *((_DWORD *)v14 + 3) = v6;
        }
        v16 = *((_BYTE *)v5 + 29) == 0;
        v17 = v5[3] * v5[3];
        v55 = v9 + 1;
        v18 = v17;
        v19 = v5[4] * v5[4] + v18;
        v20 = v5[5] * v5[5] + v19;
        v64 = v8 * v20 + v64;
        if ( v16 )
        {
          v21 = *((_DWORD *)v5 + 2);
          if ( *(_BYTE *)(v21 + 29) )
          {
            for ( i = *((_DWORD *)v5 + 1); !*(_BYTE *)(i + 29); i = *(_DWORD *)(i + 4) )
            {
              if ( v5 != *(float **)(i + 8) )
                break;
              v5 = (float *)i;
            }
            v5 = (float *)i;
          }
          else
          {
            v5 = (float *)*((_DWORD *)v5 + 2);
            for ( j = *(float *)v21; !*(_BYTE *)(LODWORD(j) + 29); j = *(float *)LODWORD(j) )
              v5 = (float *)LODWORD(j);
          }
        }
      }
      while ( v5 != *(float **)(a1 + 4) );
      v1 = a1;
    }
    v24 = v49 * v49;
    v25 = *(_DWORD *)(v1 + 16);
    v26 = (int *)(v1 + 16);
    v27 = v50 * v50 + v24;
    v28 = v51 * v51 + v27;
    v29 = (double)v52;
    v53 = v64 - v28 / v29;
    v30 = 1.0 / v29;
    v49 = v49 * v30;
    v50 = v50 * v30;
    v51 = v30 * v51;
    if ( v25 )
    {
      sub_1004CEF0(v25, *(_DWORD *)(v1 + 20));
      v31 = *v26;
      if ( *v26 )
      {
        if ( v31 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v31, 0, 0, 1, dword_100AE9F4);
      }
      *v26 = 0;
      *(_DWORD *)(v1 + 20) = 0;
      *(_DWORD *)(v1 + 24) = 0;
    }
    sub_10047C10((int)v26);
    sub_10047D20((int)&v49, v1 + 16);
    v32 = 1;
    do
    {
      v33 = 0;
      v34 = -1;
      v47 = -1.0;
      if ( !*(_DWORD *)(v1 + 20) )
        break;
      v35 = *(_DWORD *)(v1 + 16) + 24;
      do
      {
        if ( *(_DWORD *)(v35 + 16) == -1 && !*(_BYTE *)(v35 + 28) && v47 < (double)*(float *)v35 )
        {
          v34 = v33;
          v47 = *(float *)v35;
        }
        ++v33;
        v35 += 56;
      }
      while ( v33 < *(_DWORD *)(v1 + 20) );
      if ( v47 <= 0.0 )
        break;
      sub_10046830(v1, v34);
      ++v32;
    }
    while ( v32 < 2 );
    v36 = *(_DWORD *)(v1 + 28);
    v37 = (int *)(v1 + 28);
    v38 = 0;
    if ( v36 )
    {
      if ( v36 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v39 = _iob_func();
        fputs(&DstBuf, v39 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v36, 0, 0, 1, dword_100AE9F4);
      }
      *v37 = 0;
      *(_DWORD *)(v1 + 32) = 0;
      *(_DWORD *)(v1 + 36) = 0;
    }
    *(float *)(v1 + 40) = 0.0;
    if ( *(_DWORD *)(v1 + 20) > 0u )
    {
      v48 = 0;
      do
      {
        v40 = v48 + *(_DWORD *)(v1 + 16);
        if ( *(_DWORD *)(v40 + 40) == -1 )
        {
          *(_DWORD *)(v40 + 48) = *(_DWORD *)(v1 + 32);
          v41 = *(_DWORD *)(v1 + 32);
          if ( v41 >= *(_DWORD *)(v1 + 36) )
            sub_100943C0(v41 + 1, 0, v1 + 28, 1, 0xCu, 0);
          v42 = 3 * *(_DWORD *)(v1 + 32);
          v43 = *v37;
          *(_DWORD *)(v43 + 4 * v42) = *(_DWORD *)v40;
          v44 = v43 + 4 * v42;
          *(_DWORD *)(v44 + 4) = *(_DWORD *)(v40 + 4);
          *(_DWORD *)(v44 + 8) = *(_DWORD *)(v40 + 8);
          ++*(_DWORD *)(v1 + 32);
          *(float *)(v1 + 40) = *(float *)(v40 + 24) + *(float *)(v1 + 40);
        }
        v48 += 56;
        ++v38;
      }
      while ( v38 < *(_DWORD *)(v1 + 20) );
    }
    v68 = -1;
    if ( v54 )
    {
      if ( (unsigned __int8)v54 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v45 = _iob_func();
        fputs(&DstBuf, v45 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v54, 0, 0, 1, dword_100AE9F4);
      }
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1004C600: using guessed type int sub_1004C600();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10043260) --------------------------------------------------------
int __usercall sub_10043260@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // eax@1
  int (__stdcall **v3)(char); // [sp+Ch] [bp-10h]@3
  char v4; // [sp+10h] [bp-Ch]@3

  *(_DWORD *)(a1 + 8) = 0;
  v1 = operator new(0x18u);
  if ( !v1 )
  {
    v3 = 0;
    std::exception::exception((std::exception *)&v4, (const char *const *)&v3);
    v3 = &off_10099840;
    CxxThrowException(&v3, &unk_100A5EA0);
  }
  *(_DWORD *)(a1 + 4) = v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8) = *(_DWORD *)(a1 + 4);
  *(_BYTE *)(*(_DWORD *)(a1 + 4) + 20) = 1;
  *(_BYTE *)(*(_DWORD *)(a1 + 4) + 21) = 1;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(float *)(a1 + 40) = 0.0;
  sub_10068990(a1 + 44, -569075913);
  *(_DWORD *)(a1 + 60) = 123456789;
  *(_DWORD *)(a1 + 64) = 362436000;
  *(_DWORD *)(a1 + 68) = 521288629;
  *(_DWORD *)(a1 + 72) = 7654321;
  sub_10068790(a1 + 76);
  sub_10068A50(a1 + 44);
  return a1;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (10043320) --------------------------------------------------------
char __stdcall sub_10043320(int a1)
{
  unsigned int v1; // eax@1
  char v2; // di@1
  char result; // al@2
  _DWORD *v4; // eax@3
  _DWORD *v5; // esi@3
  unsigned int v6; // ecx@4
  unsigned int v7; // edi@5
  char *v8; // eax@7
  bool v9; // zf@9
  double v10; // st7@9
  float v11; // ST2C_4@9
  int v12; // eax@10
  int j; // eax@11
  int i; // eax@14
  float v15; // ST2C_4@20
  int v16; // eax@20
  int *v17; // ebp@20
  float v18; // ST34_4@20
  float v19; // ST2C_4@20
  int v20; // eax@21
  unsigned int v21; // eax@26
  int v22; // eax@28
  int v23; // edi@28
  int v24; // edx@29
  int v25; // eax@29
  char v26; // cl@29
  unsigned int v27; // ebp@30
  unsigned int v28; // edx@31
  int v29; // edi@31
  int v30; // ecx@32
  int v31; // eax@40
  _DWORD *v32; // esi@40
  unsigned int v33; // ebp@40
  FILE *v34; // eax@42
  int v35; // ebx@47
  int v36; // edi@48
  int v37; // ecx@48
  unsigned int v38; // eax@49
  FILE *v39; // eax@55
  float v40; // [sp+18h] [bp-260h]@5
  float v41; // [sp+18h] [bp-260h]@31
  float v42; // [sp+1Ch] [bp-25Ch]@5
  float v43; // [sp+24h] [bp-254h]@3
  float v44; // [sp+24h] [bp-254h]@20
  unsigned __int64 v45; // [sp+2Ch] [bp-24Ch]@3
  float v46; // [sp+34h] [bp-244h]@20
  void *v47; // [sp+38h] [bp-240h]@3
  unsigned int v48; // [sp+3Ch] [bp-23Ch]@3
  unsigned int v49; // [sp+40h] [bp-238h]@3
  int v50; // [sp+44h] [bp-234h]@3
  int v51; // [sp+48h] [bp-230h]@3
  int v52; // [sp+4Ch] [bp-22Ch]@3
  char v53; // [sp+50h] [bp-228h]@3
  double v54; // [sp+54h] [bp-224h]@3
  float v55; // [sp+60h] [bp-218h]@5
  char DstBuf; // [sp+64h] [bp-214h]@42
  int v57; // [sp+274h] [bp-4h]@3

  v1 = *(_DWORD *)(a1 + 8);
  v2 = 0;
  if ( v1 )
  {
    v54 = 0.0;
    v45 = 0i64;
    v43 = 0.0;
    v47 = 0;
    v48 = 0;
    v49 = 0;
    v50 = -1;
    v51 = -1;
    v52 = -1;
    v53 = 0;
    v57 = 0;
    sub_10049FB0((int)&v47, v1);
    v4 = *(_DWORD **)(a1 + 4);
    v5 = (_DWORD *)*v4;
    if ( (_DWORD *)*v4 != v4 )
    {
      v6 = v48;
      do
      {
        v7 = v5[4];
        v40 = (double)(unsigned int)v5[4];
        v45 += v7;
        v55 = v40 * *((float *)v5 + 3);
        v43 = v55 + v43;
        v42 = *((float *)v5 + 3);
        if ( v6 >= v49 )
        {
          sub_100943C0(v6 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C650, (int)&v47, 1, 8u, 0);
          v6 = v48;
        }
        v8 = (char *)v47 + 8 * v6;
        if ( v8 )
        {
          *(float *)v8 = v42;
          *((_DWORD *)v8 + 1) = v7;
        }
        ++v6;
        v9 = *((_BYTE *)v5 + 21) == 0;
        v10 = *((float *)v5 + 3) * *((float *)v5 + 3);
        v48 = v6;
        v11 = v10;
        v54 = v40 * v11 + v54;
        if ( v9 )
        {
          v12 = v5[2];
          if ( *(_BYTE *)(v12 + 21) )
          {
            for ( i = v5[1]; !*(_BYTE *)(i + 21); i = *(_DWORD *)(i + 4) )
            {
              if ( v5 != *(_DWORD **)(i + 8) )
                break;
              v5 = (_DWORD *)i;
            }
            v5 = (_DWORD *)i;
          }
          else
          {
            v5 = (_DWORD *)v5[2];
            for ( j = *(_DWORD *)v12; !*(_BYTE *)(j + 21); j = *(_DWORD *)j )
              v5 = (_DWORD *)j;
          }
        }
      }
      while ( v5 != *(_DWORD **)(a1 + 4) );
      v2 = 0;
    }
    v15 = v43 * v43;
    v16 = *(_DWORD *)(a1 + 16);
    v17 = (int *)(a1 + 16);
    v18 = (double)v45;
    v46 = v54 - v15 / v18;
    v19 = 1.0 / v18;
    v44 = v43 * v19;
    if ( v16 )
    {
      sub_10040FD0(v16, *(_DWORD *)(a1 + 20));
      v20 = *v17;
      if ( *v17 )
      {
        if ( v20 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v20, 0, 0, 1, dword_100AE9F4);
      }
      *v17 = 0;
      *(_DWORD *)(a1 + 20) = 0;
      *(_DWORD *)(a1 + 24) = 0;
    }
    sub_10048910(a1 + 16);
    v21 = *(_DWORD *)(a1 + 20);
    if ( v21 >= *(_DWORD *)(a1 + 24) )
      sub_100943C0(v21 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004BFD0, a1 + 16, 1, 0x30u, v2);
    v22 = *(_DWORD *)(a1 + 20);
    v9 = *v17 + 48 * v22 == 0;
    v23 = *v17 + 48 * v22;
    LOBYTE(v57) = 1;
    if ( !v9 )
    {
      *(float *)v23 = v44;
      *(_DWORD *)(v23 + 12) = HIDWORD(v45);
      *(float *)(v23 + 16) = v46;
      *(_DWORD *)(v23 + 8) = v45;
      sub_1004CD50((int)&v47, v23 + 20);
      v24 = v51;
      v25 = v52;
      *(_DWORD *)(v23 + 32) = v50;
      v26 = v53;
      *(_DWORD *)(v23 + 36) = v24;
      *(_DWORD *)(v23 + 40) = v25;
      *(_BYTE *)(v23 + 44) = v26;
    }
    LOBYTE(v57) = 0;
    ++*(_DWORD *)(a1 + 20);
    v27 = 1;
    do
    {
      v28 = 0;
      v29 = -1;
      v41 = -1.0;
      if ( !*(_DWORD *)(a1 + 20) )
        break;
      v30 = *(_DWORD *)(a1 + 16) + 16;
      do
      {
        if ( *(_DWORD *)(v30 + 16) == -1 && !*(_BYTE *)(v30 + 28) && v41 < (double)*(float *)v30 )
        {
          v29 = v28;
          v41 = *(float *)v30;
        }
        ++v28;
        v30 += 48;
      }
      while ( v28 < *(_DWORD *)(a1 + 20) );
      if ( v41 <= 0.0 )
        break;
      sub_10047DD0(a1, v29);
      ++v27;
    }
    while ( v27 < 2 );
    v31 = *(_DWORD *)(a1 + 28);
    v32 = (_DWORD *)(a1 + 28);
    v33 = 0;
    if ( v31 )
    {
      if ( v31 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v34 = _iob_func();
        fputs(&DstBuf, v34 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v31, 0, 0, 1, dword_100AE9F4);
      }
      *v32 = 0;
      *(_DWORD *)(a1 + 32) = 0;
      *(_DWORD *)(a1 + 36) = 0;
    }
    *(float *)(a1 + 40) = 0.0;
    if ( *(_DWORD *)(a1 + 20) > 0u )
    {
      v35 = 0;
      do
      {
        v36 = v35 + *(_DWORD *)(a1 + 16);
        v37 = a1;
        if ( *(_DWORD *)(v36 + 32) == -1 )
        {
          *(_DWORD *)(v36 + 40) = *(_DWORD *)(a1 + 32);
          v38 = *(_DWORD *)(a1 + 32);
          if ( v38 >= *(_DWORD *)(a1 + 36) )
          {
            sub_100943C0(v38 + 1, 0, (int)v32, 1, 4u, 0);
            v37 = a1;
          }
          *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * (*(_DWORD *)(a1 + 32))++) = *(_DWORD *)v36;
          *(float *)(v37 + 40) = *(float *)(v36 + 16) + *(float *)(v37 + 40);
        }
        ++v33;
        v35 += 48;
      }
      while ( v33 < *(_DWORD *)(v37 + 20) );
    }
    v57 = -1;
    if ( v47 )
    {
      if ( (unsigned __int8)v47 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v39 = _iob_func();
        fputs(&DstBuf, v39 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v47, 0, 0, 1, dword_100AE9F4);
      }
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1004BFD0: using guessed type int sub_1004BFD0();
// 1004C650: using guessed type int sub_1004C650();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10043810) --------------------------------------------------------
int __usercall sub_10043810@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // eax@1
  int (__stdcall **v3)(char); // [sp+Ch] [bp-10h]@3
  char v4; // [sp+10h] [bp-Ch]@3

  *(_DWORD *)(a1 + 8) = 0;
  v1 = operator new(0x54u);
  if ( !v1 )
  {
    v3 = 0;
    std::exception::exception((std::exception *)&v4, (const char *const *)&v3);
    v3 = &off_10099840;
    CxxThrowException(&v3, &unk_100A5EA0);
  }
  *(_DWORD *)(a1 + 4) = v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8) = *(_DWORD *)(a1 + 4);
  *(_BYTE *)(*(_DWORD *)(a1 + 4) + 80) = 1;
  *(_BYTE *)(*(_DWORD *)(a1 + 4) + 81) = 1;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(float *)(a1 + 40) = 0.0;
  sub_10068990(a1 + 44, -569075913);
  *(_DWORD *)(a1 + 60) = 123456789;
  *(_DWORD *)(a1 + 64) = 362436000;
  *(_DWORD *)(a1 + 68) = 521288629;
  *(_DWORD *)(a1 + 72) = 7654321;
  sub_10068790(a1 + 76);
  sub_10068A50(a1 + 44);
  return a1;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (100438D0) --------------------------------------------------------
char __stdcall sub_100438D0(int a1, unsigned int a2)
{
  int v2; // edi@1
  unsigned int v3; // esi@1
  char result; // al@2
  _DWORD *v5; // eax@3
  _DWORD *v6; // esi@3
  int v7; // ebx@4
  int v8; // eax@4
  int v9; // eax@4
  unsigned int v10; // ebp@4
  char *v11; // eax@6
  float v12; // ST28_4@8
  int v13; // eax@9
  int j; // eax@10
  int i; // eax@13
  float v16; // ST28_4@19
  float v17; // ST2C_4@19
  float v18; // ST28_4@19
  int v19; // ecx@19
  int *v20; // esi@19
  int v21; // eax@20
  unsigned int k; // ebp@25
  unsigned int v23; // edx@26
  int v24; // ebx@26
  int v25; // ecx@27
  int v26; // eax@35
  int v27; // ebx@35
  FILE *v28; // eax@37
  int v29; // ebp@43
  unsigned int v30; // eax@44
  FILE *v31; // eax@50
  char *v32; // [sp+14h] [bp-314h]@6
  unsigned int v33; // [sp+14h] [bp-314h]@41
  float v34; // [sp+18h] [bp-310h]@4
  float v35; // [sp+18h] [bp-310h]@26
  int v36; // [sp+18h] [bp-310h]@42
  double v37; // [sp+20h] [bp-308h]@3
  char v38; // [sp+28h] [bp-300h]@3
  unsigned __int64 v39; // [sp+68h] [bp-2C0h]@3
  float v40; // [sp+70h] [bp-2B8h]@19
  void *v41; // [sp+74h] [bp-2B4h]@3
  unsigned int v42; // [sp+78h] [bp-2B0h]@3
  unsigned int v43; // [sp+7Ch] [bp-2ACh]@3
  int v44; // [sp+80h] [bp-2A8h]@3
  int v45; // [sp+84h] [bp-2A4h]@3
  int v46; // [sp+88h] [bp-2A0h]@3
  char v47; // [sp+8Ch] [bp-29Ch]@3
  char v48; // [sp+94h] [bp-294h]@4
  int v49; // [sp+D4h] [bp-254h]@4
  char v50; // [sp+D8h] [bp-250h]@4
  char DstBuf; // [sp+118h] [bp-210h]@37
  int v52; // [sp+324h] [bp-4h]@3

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 8);
  if ( v3 )
  {
    v37 = 0.0;
    memset(&v38, 0, 0x40u);
    v39 = 0i64;
    v41 = 0;
    v42 = 0;
    v43 = 0;
    v44 = -1;
    v45 = -1;
    v46 = -1;
    v47 = 0;
    v52 = 0;
    sub_1003A580((int)&v41, v3);
    v5 = *(_DWORD **)(a1 + 4);
    v6 = (_DWORD *)*v5;
    if ( (_DWORD *)*v5 != v5 )
    {
      do
      {
        v7 = v6[19];
        v34 = (double)(unsigned int)v6[19];
        v8 = sub_1003CDE0((int)&v50, (int)(v6 + 3), v34);
        sub_1003CD10((int)&v38, v8);
        v39 += (unsigned int)v7;
        v9 = sub_1003DDC0((int)&v50, (int)(v6 + 3));
        sub_1003DDC0((int)&v48, v9);
        v10 = v42;
        v49 = v7;
        if ( v42 >= v43 )
        {
          sub_100943C0(v42 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003DD80, (int)&v41, 1, 0x44u, 0);
          v10 = v42;
        }
        v11 = (char *)v41 + 68 * v10;
        v32 = v11;
        if ( v11 )
        {
          sub_1003DDC0((int)v11, (int)&v48);
          *((_DWORD *)v32 + 16) = v7;
        }
        v42 = v10 + 1;
        v12 = sub_1003DE10((float *)v6 + 3, (float *)v6 + 3);
        v37 = v34 * v12 + v37;
        if ( !*((_BYTE *)v6 + 81) )
        {
          v13 = v6[2];
          if ( *(_BYTE *)(v13 + 81) )
          {
            for ( i = v6[1]; !*(_BYTE *)(i + 81); i = *(_DWORD *)(i + 4) )
            {
              if ( v6 != *(_DWORD **)(i + 8) )
                break;
              v6 = (_DWORD *)i;
            }
            v6 = (_DWORD *)i;
          }
          else
          {
            v6 = (_DWORD *)v6[2];
            for ( j = *(_DWORD *)v13; !*(_BYTE *)(j + 81); j = *(_DWORD *)j )
              v6 = (_DWORD *)j;
          }
        }
      }
      while ( v6 != *(_DWORD **)(a1 + 4) );
      v2 = a1;
    }
    v16 = sub_1003DE10((float *)&v38, (float *)&v38);
    v17 = (double)v39;
    v40 = v37 - v16 / v17;
    v18 = 1.0 / v17;
    sub_1003CD80((int)&v38, v18);
    v19 = *(_DWORD *)(v2 + 16);
    v20 = (int *)(v2 + 16);
    if ( v19 )
    {
      sub_1004CF40(*(_DWORD *)(v2 + 20), v19);
      v21 = *v20;
      if ( *v20 )
      {
        if ( v21 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v21, 0, 0, 1, dword_100AE9F4);
      }
      *v20 = 0;
      *(_DWORD *)(v2 + 20) = 0;
      *(_DWORD *)(v2 + 24) = 0;
    }
    sub_10049CF0((int)v20, 2 * a2 + 1);
    sub_10049E00(v2 + 16, (int)&v38);
    for ( k = 1; k < a2; ++k )
    {
      v23 = 0;
      v24 = -1;
      v35 = -1.0;
      if ( !*(_DWORD *)(v2 + 20) )
        break;
      v25 = *(_DWORD *)(v2 + 16) + 72;
      do
      {
        if ( *(_DWORD *)(v25 + 16) == -1 && !*(_BYTE *)(v25 + 28) && v35 < (double)*(float *)v25 )
        {
          v24 = v23;
          v35 = *(float *)v25;
        }
        ++v23;
        v25 += 104;
      }
      while ( v23 < *(_DWORD *)(v2 + 20) );
      if ( v35 <= 0.0 )
        break;
      sub_10048A60(v2, v24);
    }
    v26 = *(_DWORD *)(v2 + 28);
    v27 = v2 + 28;
    if ( v26 )
    {
      if ( v26 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v28 = _iob_func();
        fputs(&DstBuf, v28 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v26, 0, 0, 1, dword_100AE9F4);
      }
      *(_DWORD *)v27 = 0;
      *(_DWORD *)(v2 + 32) = 0;
      *(_DWORD *)(v2 + 36) = 0;
    }
    v33 = 0;
    *(float *)(v2 + 40) = 0.0;
    if ( *(_DWORD *)(v2 + 20) > 0u )
    {
      v36 = 0;
      do
      {
        v29 = v36 + *(_DWORD *)(v2 + 16);
        if ( *(_DWORD *)(v29 + 88) == -1 )
        {
          *(_DWORD *)(v29 + 96) = *(_DWORD *)(v2 + 32);
          v30 = *(_DWORD *)(v27 + 4);
          if ( v30 >= *(_DWORD *)(v27 + 8) )
            sub_100943C0(v30 + 1, 0, v27, 1, 0x40u, 0);
          qmemcpy((void *)(*(_DWORD *)v27 + ((*(_DWORD *)(v27 + 4))++ << 6)), (const void *)v29, 0x40u);
          v2 = a1;
          *(float *)(v2 + 40) = *(float *)(v29 + 72) + *(float *)(v2 + 40);
        }
        v36 += 104;
        ++v33;
      }
      while ( v33 < *(_DWORD *)(v2 + 20) );
    }
    v52 = -1;
    if ( v41 )
    {
      if ( (unsigned __int8)v41 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v31 = _iob_func();
        fputs(&DstBuf, v31 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v41, 0, 0, 1, dword_100AE9F4);
      }
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10043E90) --------------------------------------------------------
void __stdcall sub_10043E90(int a1, int a2)
{
  int v2; // esi@1
  unsigned int v3; // ebx@1
  unsigned int v4; // edx@2
  double v5; // st7@2
  double v6; // st6@2
  int v7; // ecx@3
  float v8; // ST30_4@4
  unsigned int v9; // edx@8
  double v10; // st5@8
  double v11; // st4@8
  int v12; // ecx@9
  float v13; // ST30_4@10
  float v14; // ST30_4@10
  int v15; // ebp@16
  int v16; // edx@17
  double v17; // st6@17
  unsigned int v18; // esi@19
  float *v19; // edx@19
  int *v20; // edi@19
  signed int v21; // ebx@19
  unsigned int v22; // ecx@20
  int *v23; // eax@22
  double v24; // st6@22
  double v25; // st5@23
  void **v26; // eax@25
  double v27; // st6@25
  double v28; // st5@26
  float v29; // ST30_4@26
  float *v30; // eax@29
  float *v31; // ecx@29
  signed int v32; // edx@29
  double v33; // st6@30
  unsigned int v34; // eax@31
  signed int v35; // ecx@31
  double v36; // st2@32
  double v37; // st4@32
  double v38; // st3@32
  double v39; // st6@37
  long double v40; // st5@37
  double v41; // st7@38
  double v42; // st5@38
  double v43; // st4@38
  unsigned int v44; // edx@40
  double v45; // st4@40
  double v46; // st3@40
  unsigned int v47; // esi@41
  int v48; // ecx@41
  float v49; // ST30_4@42
  float v50; // ST30_4@42
  double v51; // st1@42
  double v52; // st2@42
  unsigned int v53; // ebx@49
  float v54; // ebp@49
  double v55; // st7@50
  char *v56; // eax@52
  int i; // ecx@52
  char *v58; // eax@59
  int j; // ecx@59
  int v60; // esi@65
  int v61; // ecx@65
  int v62; // ecx@66
  double v63; // st6@66
  int v64; // esi@66
  unsigned int v65; // edi@66
  float v66; // ST2C_4@66
  float v67; // ST30_4@66
  float v68; // ST2C_4@66
  float v69; // ST30_4@66
  double v70; // st6@66
  float v71; // ST2C_4@66
  float v72; // ST30_4@66
  float v73; // ST2C_4@66
  float v74; // ST30_4@66
  char *v75; // eax@69
  float v76; // ST2C_4@71
  unsigned int v77; // kr00_4@71
  double v78; // st6@71
  double v79; // st5@71
  float v80; // ST2C_4@71
  float v81; // ST2C_4@71
  char *v82; // eax@74
  float v83; // ST2C_4@76
  unsigned int v84; // kr04_4@76
  double v85; // st6@76
  double v86; // st5@76
  float v87; // ST2C_4@76
  float v88; // ST2C_4@76
  float v89; // ST2C_4@80
  float v90; // ST2C_4@80
  double v91; // st5@80
  float v92; // ST2C_4@80
  float v93; // ST2C_4@80
  float v94; // ST30_4@80
  double v95; // st2@80
  float v96; // ST30_4@80
  float v97; // ST30_4@80
  void *v98; // eax@84
  FILE *v99; // eax@86
  FILE *v100; // ST14_4@91
  int v101; // edi@93
  int v102; // edx@93
  unsigned int v103; // eax@93
  unsigned int v104; // esi@93
  int v105; // ecx@100
  int v106; // eax@100
  double v107; // st7@102
  void *v108; // esi@102
  float v109; // edx@102
  float v110; // edx@102
  int v111; // ecx@104
  void *v112; // edx@104
  int v113; // ecx@104
  unsigned int v114; // edx@104
  FILE *v115; // eax@106
  FILE *v116; // ST14_4@111
  unsigned int v117; // [sp+14h] [bp-2C0h]@1
  float v118; // [sp+14h] [bp-2C0h]@80
  float v119; // [sp+18h] [bp-2BCh]@4
  float v120; // [sp+18h] [bp-2BCh]@80
  unsigned __int64 v121; // [sp+1Ch] [bp-2B8h]@2
  float v122; // [sp+24h] [bp-2B0h]@19
  float v123; // [sp+28h] [bp-2ACh]@4
  unsigned __int64 v124; // [sp+2Ch] [bp-2A8h]@14
  unsigned __int64 v125; // [sp+34h] [bp-2A0h]@16
  int v126; // [sp+3Ch] [bp-298h]@1
  float v127; // [sp+40h] [bp-294h]@42
  float v128; // [sp+44h] [bp-290h]@42
  void *v129; // [sp+48h] [bp-28Ch]@15
  float v130; // [sp+4Ch] [bp-288h]@15
  float v131; // [sp+50h] [bp-284h]@15
  float v132; // [sp+54h] [bp-280h]@15
  float v133; // [sp+58h] [bp-27Ch]@43
  float v134; // [sp+5Ch] [bp-278h]@43
  float v135; // [sp+60h] [bp-274h]@23
  float v136; // [sp+64h] [bp-270h]@14
  float v137; // [sp+68h] [bp-26Ch]@14
  void *v138; // [sp+6Ch] [bp-268h]@19
  float v139; // [sp+70h] [bp-264h]@19
  unsigned int v140; // [sp+74h] [bp-260h]@49
  int v141; // [sp+78h] [bp-25Ch]@1
  float v142; // [sp+7Ch] [bp-258h]@14
  float v143; // [sp+80h] [bp-254h]@14
  double v144; // [sp+84h] [bp-250h]@31
  double v145; // [sp+8Ch] [bp-248h]@64
  float v146; // [sp+94h] [bp-240h]@71
  float v147; // [sp+98h] [bp-23Ch]@71
  float v148; // [sp+9Ch] [bp-238h]@76
  float v149; // [sp+A0h] [bp-234h]@76
  unsigned __int64 v150; // [sp+A4h] [bp-230h]@80
  unsigned __int64 v151; // [sp+ACh] [bp-228h]@80
  unsigned __int64 v152; // [sp+B4h] [bp-220h]@80
  unsigned __int64 v153; // [sp+BCh] [bp-218h]@80
  char DstBuf; // [sp+C4h] [bp-210h]@86
  int v155; // [sp+2D0h] [bp-4h]@49

  v2 = *(_DWORD *)(a1 + 16) + 48 * a2;
  v3 = *(_DWORD *)(v2 + 24);
  v141 = a1 + 16;
  v126 = v2;
  v117 = v3;
  if ( v3 != 1 )
  {
    v4 = 0;
    *(float *)&v121 = 0.0;
    *((float *)&v121 + 1) = 0.0;
    v5 = -1.0;
    v6 = -1.0;
    if ( v3 )
    {
      v7 = *(_DWORD *)(v2 + 20);
      do
      {
        v123 = *(float *)v7 - *(float *)v2;
        v8 = v123 * v123 + 0.0;
        v123 = *(float *)(v7 + 4) - *(float *)(v2 + 4);
        v119 = v123 * v123 + v8;
        if ( v119 > v6 )
        {
          v6 = v119;
          if ( &v121 != (unsigned __int64 *)v7 )
            v121 = *(_QWORD *)v7;
        }
        ++v4;
        v7 += 12;
      }
      while ( v4 < v3 );
    }
    v9 = 0;
    v10 = *((float *)&v121 + 1);
    v11 = *(float *)&v121;
    if ( v3 )
    {
      v12 = *(_DWORD *)(v2 + 20);
      do
      {
        v13 = *(float *)v12 - v11;
        v123 = v13 * v13 + 0.0;
        v14 = *(float *)(v12 + 4) - v10;
        v123 = v14 * v14 + v123;
        if ( v123 > v5 )
        {
          v5 = v123;
          if ( &v121 != (unsigned __int64 *)v12 )
            v121 = *(_QWORD *)v12;
        }
        ++v9;
        v12 += 12;
      }
      while ( v9 < v3 );
    }
    v136 = v11 + *(float *)v2;
    v137 = v10 + *(float *)(v2 + 4);
    v142 = v136 * 0.5;
    v143 = v137 * 0.5;
    *(float *)&v124 = *(float *)&v121 + *(float *)v2;
    *((float *)&v124 + 1) = *((float *)&v121 + 1) + *(float *)(v2 + 4);
    v136 = *(float *)&v124 * 0.5;
    v137 = 0.5 * *((float *)&v124 + 1);
    if ( v3 > 2 )
    {
      *(float *)&v129 = 0.0;
      v130 = 0.0;
      v131 = 0.0;
      v132 = 0.0;
      v123 = 0.0;
      if ( v3 )
      {
        v15 = *(_DWORD *)(v2 + 20);
        LODWORD(v125) = *(_DWORD *)(v2 + 24);
        do
        {
          v16 = *(_DWORD *)(v15 + 8);
          *(float *)&v121 = *(float *)v15 - *(float *)v126;
          *((float *)&v121 + 1) = *(float *)(v15 + 4) - *(float *)(v126 + 4);
          v17 = (double)*(signed int *)(v15 + 8);
          if ( v16 < 0 )
            v17 = v17 + 4294967300.0;
          v122 = v17;
          v18 = 0;
          v19 = (float *)&v121;
          v20 = (int *)&v130;
          v21 = 2;
          *(float *)&v138 = *(float *)&v121 * v122;
          v139 = v122 * *((float *)&v121 + 1);
          do
          {
            v22 = v18;
            if ( v18 < 2 )
            {
              if ( v21 >= 4 )
              {
                v23 = v20;
                v24 = *v19;
                do
                {
                  v25 = *((float *)&v138 + v22);
                  v22 += 4;
                  v23 += 4;
                  *((float *)v23 - 5) = v25 * *v19 + *((float *)v23 - 5);
                  *((float *)v23 - 4) = *(&v135 + v22) * *v19 + *((float *)v23 - 4);
                  *((float *)v23 - 3) = *(&v136 + v22) * *v19 + *((float *)v23 - 3);
                  *((float *)v23 - 2) = *(&v137 + v22) * v24 + *((float *)v23 - 2);
                }
                while ( v22 < 0xFFFFFFFF );
              }
              if ( v22 < 2 )
              {
                v26 = &v129 + v22 + 2 * v18;
                v27 = *v19;
                do
                {
                  v28 = *((float *)&v138 + v22++);
                  v29 = v28;
                  ++v26;
                  *((float *)v26 - 1) = v29 * v27 + *((float *)v26 - 1);
                }
                while ( v22 < 2 );
              }
            }
            ++v18;
            --v21;
            v20 += 3;
            ++v19;
          }
          while ( v18 < 2 );
          v15 += 12;
          ++LODWORD(v123);
        }
        while ( LODWORD(v123) < (unsigned int)v125 );
      }
      v30 = &v130;
      v31 = &v131;
      v32 = 1;
      do
      {
        v33 = *v30;
        ++v30;
        *v31 = v33;
        v31 += 2;
        --v32;
      }
      while ( v32 );
      v34 = *(_DWORD *)(v126 + 12);
      v144 = COERCE_DOUBLE(__PAIR__(v34 & 0x80000000, 0));
      v35 = 10;
      v122 = (double)__PAIR__(v34, *(_DWORD *)(v126 + 8));
      *(float *)&v129 = *(float *)&v129 / v122;
      v130 = v130 / v122;
      v131 = v131 / v122;
      v132 = v132 / v122;
      *(float *)&v125 = 1.0;
      *((float *)&v125 + 1) = 1.0;
      do
      {
        v36 = *(float *)&v129 * *(float *)&v125 + 0.0 + *((float *)&v125 + 1) * v130;
        *(float *)&v121 = v36;
        v37 = v36;
        v38 = *((float *)&v125 + 1) * v132 + *(float *)&v125 * v131 + 0.0;
        *((float *)&v121 + 1) = v38;
        if ( v38 >= v36 )
          v37 = v38;
        if ( 0.0 != v37 )
        {
          v122 = 1.0 / v37;
          *(float *)&v121 = *(float *)&v121 * v122;
          *((float *)&v121 + 1) = v122 * *((float *)&v121 + 1);
        }
        --v35;
        v125 = v121;
      }
      while ( v35 );
      v39 = *(float *)&v125;
      v40 = *(float *)&v125 * *(float *)&v125 + *((float *)&v125 + 1) * *((float *)&v125 + 1);
      if ( 0.0 == v40 )
      {
        v41 = *((float *)&v125 + 1);
        v43 = 0.0;
        v42 = 0.0;
      }
      else
      {
        v122 = 1.0 / sqrt(v40);
        *(float *)&v125 = v122 * *(float *)&v125;
        *((float *)&v125 + 1) = v122 * *((float *)&v125 + 1);
        v41 = *((float *)&v125 + 1);
        v39 = *(float *)&v125;
        v42 = 0.0;
        v43 = 0.0;
      }
      *(float *)&v121 = v43;
      v44 = 0;
      *((float *)&v121 + 1) = v43;
      *(float *)&v124 = v43;
      *((float *)&v124 + 1) = v43;
      v45 = v42;
      v46 = v42;
      if ( v117 )
      {
        v47 = *(_DWORD *)(v126 + 24);
        v48 = *(_DWORD *)(v126 + 20);
        do
        {
          v123 = (double)*(unsigned int *)(v48 + 8);
          v127 = *(float *)v48 - *(float *)v126;
          v128 = *(float *)(v48 + 4) - *(float *)(v126 + 4);
          v49 = v127 * v39;
          v50 = v128 * v41 + v49;
          v51 = *(float *)v48 * v123;
          v52 = v123;
          if ( v50 >= v42 )
          {
            *(float *)&v125 = v51;
            *((float *)&v125 + 1) = *(float *)(v48 + 4) * v52;
            *(float *)&v124 = *(float *)&v125 + *(float *)&v124;
            *((float *)&v124 + 1) = *((float *)&v125 + 1) + *((float *)&v124 + 1);
            v46 = v46 + v52;
          }
          else
          {
            v133 = v51;
            v134 = *(float *)(v48 + 4) * v52;
            *(float *)&v121 = v133 + *(float *)&v121;
            *((float *)&v121 + 1) = v134 + *((float *)&v121 + 1);
            v45 = v45 + v52;
          }
          ++v44;
          v48 += 12;
        }
        while ( v44 < v47 );
        if ( v42 < v45 && v42 < v46 )
        {
          v122 = 1.0 / v45;
          v127 = *(float *)&v121 * v122;
          v128 = v122 * *((float *)&v121 + 1);
          v142 = v127;
          v143 = v128;
          v122 = 1.0 / v46;
          *(float *)&v121 = *(float *)&v124 * v122;
          *((float *)&v121 + 1) = v122 * *((float *)&v124 + 1);
          v136 = *(float *)&v121;
          v137 = *((float *)&v121 + 1);
        }
      }
    }
    *(float *)&v129 = 0.0;
    v130 = 0.0;
    v131 = 0.0;
    v155 = 0;
    *(float *)&v138 = 0.0;
    v139 = 0.0;
    v140 = 0;
    LOBYTE(v155) = 1;
    sub_1003FE70((int)&v129, v117 >> 1);
    sub_1003FE70((int)&v138, *(_DWORD *)(v126 + 24) >> 1);
    *(float *)&v53 = v130;
    *(float *)&v125 = 1.0e10;
    v54 = v139;
    v122 = 0.0;
    while ( 1 )
    {
      v55 = 0.0;
      if ( *(float *)&v53 != 0.0 )
      {
        if ( v53 <= 0 )
        {
          v56 = (char *)v129 + 12 * v53;
          for ( i = (int)&v56[-12 * v53]; v56 != (char *)i; v56 += 12 )
          {
            if ( v56 )
              *((_DWORD *)v56 + 2) = 0;
          }
        }
        *(float *)&v53 = 0.0;
        v130 = 0.0;
      }
      if ( v54 != 0.0 )
      {
        if ( LODWORD(v54) <= 0 )
        {
          v58 = (char *)v138 + 12 * LODWORD(v54);
          for ( j = (int)&v58[-12 * LODWORD(v54)]; v58 != (char *)j; v58 += 12 )
          {
            if ( v58 )
              *((_DWORD *)v58 + 2) = 0;
          }
        }
        v54 = 0.0;
        v139 = 0.0;
      }
      v145 = 0.0;
      v133 = 0.0;
      v144 = 0.0;
      v134 = 0.0;
      v127 = 0.0;
      v128 = 0.0;
      v121 = 0i64;
      v124 = 0i64;
      v123 = 0.0;
      if ( *(_DWORD *)(v126 + 24) <= 0u )
        break;
      v60 = 0;
      v135 = 0.0;
      v61 = v126;
      do
      {
        v62 = *(_DWORD *)(v61 + 20);
        v63 = v142 - *(float *)(v60 + v62);
        v64 = v62 + v60;
        v65 = *(_DWORD *)(v64 + 8);
        v66 = v63;
        v67 = v66 * v66 + v55;
        v68 = v143 - *(float *)(v64 + 4);
        v69 = v68 * v68 + v67;
        v70 = v69;
        v71 = v136 - *(float *)v64;
        v72 = v71 * v71 + v55;
        v73 = v137 - *(float *)(v64 + 4);
        v74 = v73 * v73 + v72;
        if ( v74 <= v70 )
        {
          if ( LODWORD(v54) >= v140 )
          {
            sub_100943C0(LODWORD(v54) + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040A40, (int)&v138, 1, 0xCu, 0);
            v55 = 0.0;
            v54 = v139;
          }
          v82 = (char *)v138 + 12 * LODWORD(v54);
          if ( v82 )
          {
            *(float *)v82 = *(float *)v64;
            *((float *)v82 + 1) = *(float *)(v64 + 4);
            *((_DWORD *)v82 + 2) = *(_DWORD *)(v64 + 8);
          }
          ++LODWORD(v54);
          v139 = v54;
          v83 = (double)v65;
          v84 = v124;
          LODWORD(v124) = v65 + v124;
          v85 = v83;
          v86 = v83 * *(float *)v64;
          v124 = __PAIR__(HIDWORD(v124), v65) + v84;
          v148 = v86;
          v149 = v83 * *(float *)(v64 + 4);
          v127 = v148 + v127;
          v128 = v128 + v149;
          v87 = *(float *)v64 * *(float *)v64;
          v88 = *(float *)(v64 + 4) * *(float *)(v64 + 4) + v87;
          v144 = v85 * v88 + v144;
        }
        else
        {
          if ( v53 >= LODWORD(v131) )
          {
            sub_100943C0(v53 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040A40, (int)&v129, 1, 0xCu, 0);
            v55 = 0.0;
            *(float *)&v53 = v130;
          }
          v75 = (char *)v129 + 12 * v53;
          if ( v75 )
          {
            *(float *)v75 = *(float *)v64;
            *((float *)v75 + 1) = *(float *)(v64 + 4);
            *((_DWORD *)v75 + 2) = *(_DWORD *)(v64 + 8);
          }
          ++v53;
          v130 = *(float *)&v53;
          v76 = (double)v65;
          v77 = v121;
          LODWORD(v121) = v65 + v121;
          v78 = v76;
          v79 = v76 * *(float *)v64;
          v121 = __PAIR__(HIDWORD(v121), v65) + v77;
          v146 = v79;
          v147 = v76 * *(float *)(v64 + 4);
          v133 = v146 + v133;
          v134 = v134 + v147;
          v80 = *(float *)v64 * *(float *)v64;
          v81 = *(float *)(v64 + 4) * *(float *)(v64 + 4) + v80;
          v145 = v78 * v81 + v145;
        }
        v61 = v126;
        v60 = LODWORD(v135) + 12;
        ++LODWORD(v123);
        LODWORD(v135) += 12;
      }
      while ( LODWORD(v123) < *(_DWORD *)(v126 + 24) );
      if ( !v121 || !v124 )
        break;
      v150 = v121 & 0x7FFFFFFFFFFFFFFFi64;
      v89 = v133 * v133;
      v151 = __PAIR__(HIDWORD(v121), 0) & 0x8000000000000000ui64;
      v152 = v124 & 0x7FFFFFFFFFFFFFFFi64;
      v90 = v134 * v134 + v89;
      v153 = __PAIR__(HIDWORD(v124), 0) & 0x8000000000000000ui64;
      v135 = (double)v121;
      v91 = v135;
      v135 = v145 - v90 / v135;
      v92 = v127 * v127;
      v93 = v128 * v128 + v92;
      v94 = (double)v124;
      v95 = v94;
      v118 = v144 - v93 / v94;
      v96 = 1.0 / v91;
      v133 = v133 * v96;
      v134 = v96 * v134;
      v97 = 1.0 / v95;
      v127 = v127 * v97;
      v142 = v133;
      v136 = v127;
      v143 = v134;
      v128 = v128 * v97;
      v137 = v128;
      v120 = v118 + v135;
      if ( v120 >= 0.0000099999997 && (*(float *)&v125 - v120) / v120 >= 0.000009999999747378752 )
      {
        *(float *)&v125 = v118 + v135;
        if ( ++LODWORD(v122) < 0x400u )
          continue;
      }
      v101 = *(_DWORD *)(a1 + 20);
      v102 = v126;
      *(_DWORD *)(v126 + 32) = v101;
      *(_DWORD *)(v102 + 36) = *(_DWORD *)(a1 + 20) + 1;
      v103 = *(_DWORD *)(v141 + 4);
      v104 = *(_DWORD *)(a1 + 20) + 2;
      if ( v104 != v103 )
      {
        if ( v104 >= v103 )
        {
          if ( v104 > *(_DWORD *)(v141 + 8) )
          {
            LOBYTE(v122) = v104 == v103 + 1;
            sub_100943C0(v104, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004B300, v141, v104 == v103 + 1, 0x30u, 0);
          }
          sub_10041020(*(_DWORD *)v141 + 48 * *(_DWORD *)(v141 + 4), v104 - *(_DWORD *)(v141 + 4));
        }
        else
        {
          sub_10040FD0(*(_DWORD *)v141 + 48 * v104, v103 - v104);
        }
        *(_DWORD *)(v141 + 4) = v104;
      }
      v105 = *(_DWORD *)v141 + 48 * v101;
      v106 = *(_DWORD *)v141 + 16 * (3 * v101 + 3);
      if ( (float *)v105 != &v142 )
      {
        *(float *)v105 = v142;
        *(float *)(v105 + 4) = v143;
      }
      v107 = v135;
      *(_QWORD *)(v105 + 8) = v121;
      v108 = *(void **)(v105 + 20);
      *(float *)(v105 + 20) = *(float *)&v129;
      v109 = *(float *)(v105 + 24);
      *(float *)(v105 + 24) = *(float *)&v53;
      v122 = *(float *)&v108;
      v129 = v108;
      v130 = v109;
      v110 = *(float *)(v105 + 28);
      *(float *)(v105 + 28) = v131;
      *(float *)(v105 + 16) = v107;
      v131 = v110;
      if ( (float *)v106 != &v136 )
      {
        *(float *)v106 = v136;
        *(float *)(v106 + 4) = v137;
      }
      v111 = HIDWORD(v124);
      *(_DWORD *)(v106 + 8) = v124;
      v112 = v138;
      *(_DWORD *)(v106 + 12) = v111;
      v113 = *(_DWORD *)(v106 + 20);
      *(_DWORD *)(v106 + 20) = v112;
      v114 = v140;
      *(float *)(v106 + 24) = v54;
      LOBYTE(v155) = 0;
      *(_DWORD *)(v106 + 28) = v114;
      *(float *)(v106 + 16) = v118;
      if ( v113 )
      {
        if ( v113 & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v115 = _iob_func();
          fputs(&DstBuf, v115 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v113, 0, 0, 1, dword_100AE9F4);
        }
      }
      v155 = -1;
      if ( v122 != 0.0 )
      {
        if ( !(LOBYTE(v122) & 7) )
        {
          off_100AD9F4(LODWORD(v122), 0, 0, 1, dword_100AE9F4);
          return;
        }
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v116 = _iob_func() + 2;
        fputs(&DstBuf, v116);
        goto LABEL_112;
      }
      return;
    }
    LOBYTE(v155) = 0;
    v98 = v138;
    *(_BYTE *)(v126 + 44) = 1;
    if ( v98 )
    {
      if ( (unsigned __int8)v98 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v99 = _iob_func();
        fputs(&DstBuf, v99 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v98, 0, 0, 1, dword_100AE9F4);
      }
    }
    v155 = -1;
    if ( *(float *)&v129 != 0.0 )
    {
      if ( !((unsigned __int8)v129 & 7) )
      {
        off_100AD9F4(v129, 0, 0, 1, dword_100AE9F4);
        return;
      }
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v100 = _iob_func() + 2;
      fputs(&DstBuf, v100);
LABEL_112:
      if ( IsDebuggerPresent() )
        DebugBreak();
      return;
    }
  }
}
// 10040A40: using guessed type int sub_10040A40();
// 1004B300: using guessed type int sub_1004B300();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10044D10) --------------------------------------------------------
void __userpurge sub_10044D10(int a1@<esi>, unsigned int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // ecx@1
  int v4; // ebx@6
  int v5; // edx@6
  int v6; // ecx@6
  int v7; // eax@6
  int v8; // [sp+0h] [bp-18h]@4
  int v9; // [sp+4h] [bp-14h]@4
  int v10; // [sp+8h] [bp-10h]@4
  int v11; // [sp+14h] [bp-4h]@4

  v2 = a2;
  v3 = *(_DWORD *)(a1 + 8);
  if ( a2 <= v3 )
  {
    if ( a2 < v3 )
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      if ( *(_DWORD *)(a1 + 4) > a2 )
        v2 = *(_DWORD *)(a1 + 4);
      sub_100943C0(v2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004B300, (int)&v8, 0, 0x30u, 0);
      sub_1004A370((int)&v8, a1);
      v4 = *(_DWORD *)a1;
      v5 = v9;
      *(_DWORD *)a1 = v8;
      v6 = *(_DWORD *)(a1 + 4);
      v7 = v10;
      *(_DWORD *)(a1 + 4) = v5;
      *(_DWORD *)(a1 + 8) = v7;
      v11 = -1;
      if ( v4 )
      {
        sub_10040FD0(v4, v6);
        if ( v4 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004B300, a1, 0, 0x30u, 0);
  }
}
// 1004B300: using guessed type int sub_1004B300();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10044E20) --------------------------------------------------------
char __userpurge sub_10044E20@<al>(int a1@<ebx>, int a2)
{
  unsigned int v2; // eax@1
  int v3; // edi@3

  v2 = *(_DWORD *)(a2 + 4);
  if ( v2 >= *(_DWORD *)(a2 + 8) )
    LOBYTE(v2) = sub_100943C0(v2 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004B300, a2, 1, 0x30u, 0);
  v3 = *(_DWORD *)a2 + 48 * *(_DWORD *)(a2 + 4);
  if ( v3 )
  {
    *(float *)v3 = *(float *)a1;
    *(float *)(v3 + 4) = *(float *)(a1 + 4);
    *(_DWORD *)(v3 + 8) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(v3 + 12) = *(_DWORD *)(a1 + 12);
    *(float *)(v3 + 16) = *(float *)(a1 + 16);
    sub_1004CBF0(a1 + 20, v3 + 20);
    *(_DWORD *)(v3 + 32) = *(_DWORD *)(a1 + 32);
    v2 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(v3 + 36) = v2;
    *(_DWORD *)(v3 + 40) = *(_DWORD *)(a1 + 40);
    *(_BYTE *)(v3 + 44) = *(_BYTE *)(a1 + 44);
  }
  ++*(_DWORD *)(a2 + 4);
  return v2;
}
// 1004B300: using guessed type int sub_1004B300();

//----- (10044ED0) --------------------------------------------------------
void __stdcall sub_10044ED0(int a1, int a2)
{
  int v2; // ebp@1
  float v3; // eax@1
  unsigned int v4; // edi@2
  int v5; // esi@3
  float v6; // ebx@3
  double v7; // st7@4
  float v8; // edx@6
  float v9; // eax@6
  float v10; // ecx@6
  float v11; // edx@6
  float v12; // eax@6
  unsigned int v13; // edi@8
  unsigned int v14; // ebx@9
  int v15; // esi@9
  double v16; // st7@10
  float v17; // eax@12
  float v18; // ecx@12
  float v19; // edx@12
  float v20; // eax@12
  float v21; // ecx@12
  int v22; // edi@16
  int v23; // edx@17
  double v24; // st7@17
  unsigned int v25; // ebp@19
  unsigned int v26; // esi@19
  float *v27; // edx@19
  float *v28; // ebx@19
  unsigned int v29; // ecx@20
  float *v30; // eax@22
  double v31; // st7@22
  double v32; // st6@23
  float *v33; // eax@25
  double v34; // st7@25
  double v35; // st6@26
  signed int v36; // ebx@29
  int v37; // ebp@29
  unsigned int v38; // esi@29
  unsigned int v39; // edi@30
  unsigned int v40; // edx@32
  float *v41; // eax@32
  char *v42; // ecx@32
  double v43; // st7@33
  float *v44; // ecx@35
  float *v45; // edx@35
  int v46; // eax@35
  double v47; // st7@36
  unsigned int v48; // eax@38
  unsigned int v49; // kr00_4@38
  float *v50; // eax@38
  signed int v51; // ecx@38
  float v52; // ST2C_4@38
  double v53; // st7@38
  double v54; // st6@39
  signed int v55; // edx@40
  double v56; // st7@40
  int v57; // ecx@41
  double v58; // st6@41
  double v59; // st5@41
  double v60; // st4@41
  double v61; // st3@41
  double v62; // st2@41
  double v63; // rtt@43
  double v64; // st2@43
  double v65; // st7@43
  float v66; // ST2C_4@49
  unsigned int v67; // edx@52
  unsigned int v68; // edi@53
  int v69; // ecx@53
  float v70; // ST34_4@54
  float v71; // ST2C_4@54
  float v72; // ST2C_4@54
  float v73; // ST2C_4@54
  float v74; // ST2C_4@54
  float v75; // ST34_4@54
  double v76; // st1@54
  double v77; // st2@54
  float v78; // ST2C_4@60
  float v79; // ST2C_4@60
  float v80; // ebp@61
  float v81; // ebx@61
  float v82; // eax@64
  float i; // ecx@64
  char *v84; // eax@71
  int j; // ecx@71
  int v86; // esi@78
  unsigned int v87; // edi@78
  double v88; // ST2C_8@78
  int v89; // eax@81
  float v90; // ST34_4@83
  unsigned int v91; // kr04_4@83
  double v92; // st7@83
  double v93; // st6@83
  float v94; // ST34_4@83
  float v95; // ST2C_4@83
  float v96; // ST2C_4@83
  float v97; // ST2C_4@83
  float v98; // ST2C_4@83
  float v99; // ST34_4@83
  char *v100; // eax@86
  float v101; // ST34_4@88
  unsigned int v102; // kr08_4@88
  double v103; // st7@88
  double v104; // st6@88
  float v105; // ST34_4@88
  float v106; // ST2C_4@88
  float v107; // ST2C_4@88
  float v108; // ST2C_4@88
  float v109; // ST2C_4@88
  float v110; // ST34_4@88
  __int64 v111; // rdi@91
  float v112; // ST34_4@92
  float v113; // ST2C_4@92
  float v114; // ST2C_4@92
  float v115; // ST2C_4@92
  float v116; // ST2C_4@92
  float v117; // ST34_4@92
  float v118; // ST34_4@92
  float v119; // ST2C_4@92
  float v120; // ST2C_4@92
  float v121; // ST2C_4@92
  float v122; // ST2C_4@92
  float v123; // ST34_4@92
  float v124; // ST2C_4@92
  double v125; // st5@92
  float v126; // ST2C_4@92
  float v127; // ST2C_4@92
  FILE *v128; // eax@98
  FILE *v129; // eax@103
  int v130; // esi@105
  int v131; // edx@105
  int v132; // ebp@105
  unsigned int v133; // eax@105
  unsigned int v134; // edi@105
  int v135; // ebp@107
  int v136; // eax@108
  FILE *v137; // eax@110
  int v138; // edx@118
  int v139; // eax@119
  int v140; // ecx@119
  double v141; // st7@121
  float v142; // esi@121
  float v143; // ebx@121
  float v144; // edx@121
  float v145; // edx@121
  int v146; // eax@123
  void *v147; // edx@123
  int v148; // eax@123
  FILE *v149; // eax@125
  FILE *v150; // eax@130
  float v151; // [sp-14h] [bp-3F0h]@104
  int v152; // [sp-4h] [bp-3E0h]@104
  unsigned int v153; // [sp+14h] [bp-3C8h]@16
  float v154; // [sp+14h] [bp-3C8h]@92
  int k; // [sp+14h] [bp-3C8h]@107
  signed int v156; // [sp+1Ch] [bp-3C0h]@19
  float v157; // [sp+1Ch] [bp-3C0h]@92
  float v158; // [sp+20h] [bp-3BCh]@14
  float v159; // [sp+24h] [bp-3B8h]@14
  float v160; // [sp+28h] [bp-3B4h]@14
  float v161; // [sp+2Ch] [bp-3B0h]@14
  float v162; // [sp+30h] [bp-3ACh]@14
  float v163; // [sp+34h] [bp-3A8h]@14
  float v164; // [sp+38h] [bp-3A4h]@11
  float v165; // [sp+3Ch] [bp-3A0h]@12
  float v166; // [sp+40h] [bp-39Ch]@12
  float v167; // [sp+44h] [bp-398h]@12
  float v168; // [sp+48h] [bp-394h]@12
  float v169; // [sp+4Ch] [bp-390h]@12
  float v170; // [sp+50h] [bp-38Ch]@15
  float v171; // [sp+54h] [bp-388h]@22
  int v172; // [sp+58h] [bp-384h]@1
  float v173; // [sp+5Ch] [bp-380h]@19
  float v174; // [sp+60h] [bp-37Ch]@19
  float v175; // [sp+64h] [bp-378h]@19
  float v176; // [sp+68h] [bp-374h]@19
  float v177; // [sp+6Ch] [bp-370h]@19
  float v178; // [sp+70h] [bp-36Ch]@19
  double v179; // [sp+74h] [bp-368h]@41
  float v180; // [sp+80h] [bp-35Ch]@1
  double v181; // [sp+84h] [bp-358h]@2
  float v182; // [sp+8Ch] [bp-350h]@2
  float v183; // [sp+90h] [bp-34Ch]@2
  float v184; // [sp+94h] [bp-348h]@2
  float v185; // [sp+98h] [bp-344h]@2
  float v186; // [sp+9Ch] [bp-340h]@2
  float v187; // [sp+A0h] [bp-33Ch]@2
  signed __int64 v188; // [sp+A4h] [bp-338h]@52
  void *v189; // [sp+ACh] [bp-330h]@52
  float v190; // [sp+B0h] [bp-32Ch]@52
  float v191; // [sp+B4h] [bp-328h]@52
  float v192; // [sp+B8h] [bp-324h]@52
  float v193; // [sp+BCh] [bp-320h]@52
  float v194; // [sp+C0h] [bp-31Ch]@52
  float v195; // [sp+C4h] [bp-318h]@19
  float v196; // [sp+C8h] [bp-314h]@54
  float v197; // [sp+CCh] [bp-310h]@54
  float v198; // [sp+D0h] [bp-30Ch]@54
  float v199; // [sp+D4h] [bp-308h]@54
  float v200; // [sp+D8h] [bp-304h]@54
  float v201; // [sp+DCh] [bp-300h]@54
  int v202; // [sp+E0h] [bp-2FCh]@1
  float v203; // [sp+E4h] [bp-2F8h]@14
  float v204; // [sp+E8h] [bp-2F4h]@14
  float v205; // [sp+ECh] [bp-2F0h]@14
  float v206; // [sp+F0h] [bp-2ECh]@14
  float v207; // [sp+F4h] [bp-2E8h]@14
  float v208; // [sp+F8h] [bp-2E4h]@14
  float v209; // [sp+FCh] [bp-2E0h]@55
  float v210; // [sp+100h] [bp-2DCh]@55
  float v211; // [sp+104h] [bp-2D8h]@55
  float v212; // [sp+108h] [bp-2D4h]@55
  float v213; // [sp+10Ch] [bp-2D0h]@55
  float v214; // [sp+110h] [bp-2CCh]@55
  double v215; // [sp+114h] [bp-2C8h]@76
  __int64 v216; // [sp+11Ch] [bp-2C0h]@92
  __int64 v217; // [sp+124h] [bp-2B8h]@92
  unsigned __int64 v218; // [sp+12Ch] [bp-2B0h]@92
  unsigned __int64 v219; // [sp+134h] [bp-2A8h]@35
  float v220; // [sp+13Ch] [bp-2A0h]@15
  float v221; // [sp+140h] [bp-29Ch]@19
  float v222; // [sp+144h] [bp-298h]@38
  float v223; // [sp+148h] [bp-294h]@43
  float v224; // [sp+14Ch] [bp-290h]@43
  float v225[6]; // [sp+150h] [bp-28Ch]@43
  char v226[100]; // [sp+168h] [bp-274h]@32
  char DstBuf; // [sp+1CCh] [bp-210h]@98
  int v228; // [sp+3D8h] [bp-4h]@61

  v2 = *(_DWORD *)(a1 + 16) + (a2 << 6);
  v3 = *(float *)(v2 + 40);
  v202 = a1 + 16;
  v172 = v2;
  v180 = v3;
  if ( LODWORD(v3) != 1 )
  {
    v4 = 0;
    v182 = 0.0;
    v183 = 0.0;
    v184 = 0.0;
    v185 = 0.0;
    v186 = 0.0;
    v187 = 0.0;
    v181 = -1.0;
    if ( v3 != 0.0 )
    {
      v5 = *(_DWORD *)(v2 + 36);
      v6 = v3;
      do
      {
        v7 = sub_1003CC80(v2, v5);
        if ( v181 < v7 )
        {
          v181 = v7;
          if ( &v182 != (float *)v5 )
          {
            v8 = *(float *)(v5 + 4);
            v9 = *(float *)(v5 + 8);
            v182 = *(float *)v5;
            v10 = *(float *)(v5 + 12);
            v183 = v8;
            v11 = *(float *)(v5 + 16);
            v184 = v9;
            v12 = *(float *)(v5 + 20);
            v185 = v10;
            v186 = v11;
            v187 = v12;
          }
        }
        ++v4;
        v5 += 28;
      }
      while ( v4 < LODWORD(v6) );
    }
    v13 = 0;
    v181 = -1.0;
    if ( v180 != 0.0 )
    {
      v14 = *(_DWORD *)(v2 + 40);
      v15 = *(_DWORD *)(v2 + 36);
      do
      {
        v16 = sub_1003CC80((int)&v182, v15);
        if ( v181 < v16 )
        {
          v181 = v16;
          if ( &v164 != (float *)v15 )
          {
            v17 = *(float *)(v15 + 4);
            v18 = *(float *)(v15 + 8);
            v164 = *(float *)v15;
            v19 = *(float *)(v15 + 12);
            v165 = v17;
            v20 = *(float *)(v15 + 16);
            v166 = v18;
            v21 = *(float *)(v15 + 20);
            v167 = v19;
            v168 = v20;
            v169 = v21;
          }
        }
        ++v13;
        v15 += 28;
      }
      while ( v13 < v14 );
    }
    v158 = v182 + *(float *)v2;
    v159 = v183 + *(float *)(v2 + 4);
    v160 = v184 + *(float *)(v2 + 8);
    v161 = v185 + *(float *)(v2 + 12);
    v162 = v186 + *(float *)(v2 + 16);
    v163 = v187 + *(float *)(v2 + 20);
    v203 = v158 * 0.5;
    v204 = v159 * 0.5;
    v205 = v160 * 0.5;
    v206 = v161 * 0.5;
    v207 = v162 * 0.5;
    v208 = v163 * 0.5;
    v158 = v164 + *(float *)v2;
    v159 = *(float *)(v2 + 4) + v165;
    v160 = v166 + *(float *)(v2 + 8);
    v161 = v167 + *(float *)(v2 + 12);
    v162 = v168 + *(float *)(v2 + 16);
    v163 = *(float *)(v2 + 20) + v169;
    v182 = v158 * 0.5;
    v183 = v159 * 0.5;
    v184 = v160 * 0.5;
    v185 = v161 * 0.5;
    v186 = v162 * 0.5;
    v187 = 0.5 * v163;
    if ( LODWORD(v180) > 2 )
    {
      memset(&v220, 0, 0x90u);
      v170 = 0.0;
      if ( v180 != 0.0 )
      {
        v22 = *(_DWORD *)(v2 + 36);
        v153 = *(_DWORD *)(v2 + 40);
        do
        {
          v23 = *(_DWORD *)(v22 + 24);
          v164 = *(float *)v22 - *(float *)v172;
          v165 = *(float *)(v22 + 4) - *(float *)(v172 + 4);
          v166 = *(float *)(v22 + 8) - *(float *)(v172 + 8);
          v167 = *(float *)(v22 + 12) - *(float *)(v172 + 12);
          v168 = *(float *)(v22 + 16) - *(float *)(v172 + 16);
          v169 = *(float *)(v22 + 20) - *(float *)(v172 + 20);
          v24 = (double)*(signed int *)(v22 + 24);
          if ( v23 < 0 )
            v24 = v24 + 4294967300.0;
          v195 = v24;
          v25 = 0;
          v26 = 0;
          v27 = &v164;
          v28 = &v221;
          v156 = 6;
          v173 = v164 * v195;
          v174 = v165 * v195;
          v175 = v166 * v195;
          v176 = v167 * v195;
          v177 = v168 * v195;
          v178 = v195 * v169;
          do
          {
            v29 = v25;
            if ( v25 < 6 )
            {
              if ( v156 >= 4 )
              {
                v30 = v28;
                v171 = *v27;
                v31 = v171;
                do
                {
                  v32 = *(&v173 + v29);
                  v29 += 4;
                  v30 += 4;
                  *(v30 - 5) = v32 * *v27 + *(v30 - 5);
                  *(v30 - 4) = *(&v170 + v29) * *v27 + *(v30 - 4);
                  *(v30 - 3) = *(&v171 + v29) * *v27 + *(v30 - 3);
                  v171 = *((float *)&v172 + v29);
                  *(v30 - 2) = v171 * v31 + *(v30 - 2);
                }
                while ( v29 < 3 );
              }
              if ( v29 < 6 )
              {
                v171 = *v27;
                v33 = &v220 + v26 + v29;
                v34 = v171;
                do
                {
                  v35 = *(&v173 + v29++);
                  v171 = v35;
                  ++v33;
                  *(v33 - 1) = v171 * v34 + *(v33 - 1);
                }
                while ( v29 < 6 );
              }
            }
            --v156;
            v26 += 6;
            ++v25;
            v28 += 7;
            ++v27;
          }
          while ( v26 < 0x24 );
          v22 += 28;
          ++LODWORD(v170);
        }
        while ( LODWORD(v170) < v153 );
      }
      v36 = 5;
      v37 = 0;
      v38 = 1;
      LODWORD(v170) = 5;
      do
      {
        v39 = v38;
        if ( v38 < 6 )
        {
          if ( v36 >= 4 )
          {
            v40 = ((2 - v38) >> 2) + 1;
            v41 = &v221 + v38 + v37;
            v42 = &v226[4 * (v38 + v37)];
            v39 = v38 + 4 * v40;
            do
            {
              v43 = *(v41 - 1);
              v41 += 4;
              *((float *)v42 - 6) = v43;
              v42 += 96;
              --v40;
              *((float *)v42 - 24) = *(v41 - 4);
              *((float *)v42 - 18) = *(v41 - 3);
              *((float *)v42 - 12) = *(v41 - 2);
            }
            while ( v40 );
          }
          if ( v39 < 6 )
          {
            v44 = &v220 + v39 + v37;
            v45 = (float *)((char *)&v219 + 4 * (v38 + 6 * v39) + 4);
            v46 = 6 - v39;
            do
            {
              v47 = *v44;
              ++v44;
              *v45 = v47;
              v45 += 6;
              --v46;
            }
            while ( v46 );
          }
        }
        --v36;
        ++v38;
        v37 += 6;
        --LODWORD(v170);
      }
      while ( v170 != 0.0 );
      v48 = *(_DWORD *)(v172 + 28);
      v49 = v48;
      HIDWORD(v181) = v48 & 0x80000000;
      LODWORD(v181) = 0;
      v50 = &v222;
      v51 = 6;
      v52 = (double)__PAIR__(v49, *(_DWORD *)(v172 + 24));
      v53 = v52;
      do
      {
        v54 = *(v50 - 2);
        v50 += 6;
        --v51;
        *(v50 - 8) = v54 / v53;
        *(v50 - 7) = *(v50 - 7) / v53;
        *(v50 - 6) = *(v50 - 6) / v53;
        *(v50 - 5) = *(v50 - 5) / v53;
        *(v50 - 4) = *(v50 - 4) / v53;
        *(v50 - 3) = *(v50 - 3) / v53;
      }
      while ( v51 );
      v55 = 10;
      v164 = 1.0;
      v165 = 1.0;
      v166 = 1.0;
      v167 = 1.0;
      v168 = 1.0;
      v169 = 1.0;
      v56 = 0.0;
      do
      {
        v179 = v56;
        v57 = 0;
        v58 = v169;
        v59 = v168;
        v60 = v167;
        v61 = v166;
        v62 = v165;
        while ( 1 )
        {
          v63 = v62;
          v64 = v56
              + *(&v220 + 6 * v57) * v164
              + *(&v221 + 6 * v57) * v62
              + *(&v222 + 6 * v57) * v61
              + *(&v223 + 6 * v57) * v60
              + *(&v224 + 6 * v57) * v59
              + v225[6 * v57] * v58;
          v65 = v63;
          *(&v158 + v57) = v64;
          if ( v57 && v179 > v64 )
            v64 = v179;
          else
            v179 = v64;
          if ( (unsigned int)++v57 >= 6 )
            break;
          v62 = v65;
          v56 = 0.0;
        }
        if ( 0.0 == v64 )
        {
          v56 = 0.0;
        }
        else
        {
          v56 = 0.0;
          v66 = 1.0 / v64;
          v158 = v66 * v158;
          v159 = v66 * v159;
          v160 = v66 * v160;
          v161 = v66 * v161;
          v162 = v66 * v162;
          v163 = v66 * v163;
        }
        --v55;
        v164 = v158;
        v165 = v159;
        v166 = v160;
        v167 = v161;
        v168 = v162;
        v169 = v163;
      }
      while ( v55 );
      sub_1003DCF0((int)&v164);
      v67 = 0;
      v158 = 0.0;
      v159 = 0.0;
      v160 = 0.0;
      v161 = 0.0;
      v162 = 0.0;
      v163 = 0.0;
      *(float *)&v189 = 0.0;
      v190 = 0.0;
      v191 = 0.0;
      v192 = 0.0;
      v193 = 0.0;
      v194 = 0.0;
      v179 = 0.0;
      *(double *)&v188 = 0.0;
      if ( v180 != 0.0 )
      {
        v68 = *(_DWORD *)(v172 + 40);
        v69 = *(_DWORD *)(v172 + 36);
        do
        {
          v170 = (double)*(unsigned int *)(v69 + 24);
          v196 = *(float *)v69 - *(float *)v172;
          v197 = *(float *)(v69 + 4) - *(float *)(v172 + 4);
          v198 = *(float *)(v69 + 8) - *(float *)(v172 + 8);
          v199 = *(float *)(v69 + 12) - *(float *)(v172 + 12);
          v200 = *(float *)(v69 + 16) - *(float *)(v172 + 16);
          v201 = *(float *)(v69 + 20) - *(float *)(v172 + 20);
          v70 = v164 * v196;
          v71 = v197 * v165 + v70;
          v72 = v71 + v198 * v166;
          v73 = v72 + v199 * v167;
          v74 = v73 + v200 * v168;
          v75 = v74 + v201 * v169;
          v76 = *(float *)v69 * v170;
          v77 = v170;
          if ( v75 >= 0.0 )
          {
            v173 = v76;
            v174 = *(float *)(v69 + 4) * v77;
            v175 = *(float *)(v69 + 8) * v77;
            v176 = *(float *)(v69 + 12) * v77;
            v177 = *(float *)(v69 + 16) * v77;
            v178 = *(float *)(v69 + 20) * v77;
            *(float *)&v189 = v173 + *(float *)&v189;
            v190 = v174 + v190;
            v191 = v175 + v191;
            v192 = v176 + v192;
            v193 = v177 + v193;
            v194 = v178 + v194;
            *(double *)&v188 = v77 + *(double *)&v188;
          }
          else
          {
            v209 = v76;
            v210 = *(float *)(v69 + 4) * v77;
            v211 = *(float *)(v69 + 8) * v77;
            v212 = *(float *)(v69 + 12) * v77;
            v213 = *(float *)(v69 + 16) * v77;
            v214 = *(float *)(v69 + 20) * v77;
            v158 = v209 + v158;
            v159 = v210 + v159;
            v160 = v211 + v160;
            v161 = v212 + v161;
            v162 = v213 + v162;
            v163 = v214 + v163;
            v179 = v77 + v179;
          }
          ++v67;
          v69 += 28;
        }
        while ( v67 < v68 );
        if ( v179 > 0.0 && *(double *)&v188 > 0.0 )
        {
          v78 = 1.0 / v179;
          v173 = v158 * v78;
          v174 = v159 * v78;
          v175 = v160 * v78;
          v176 = v161 * v78;
          v177 = v162 * v78;
          v178 = v78 * v163;
          v203 = v173;
          v204 = v174;
          v205 = v175;
          v206 = v176;
          v207 = v177;
          v208 = v178;
          v79 = 1.0 / *(double *)&v188;
          v173 = *(float *)&v189 * v79;
          v174 = v190 * v79;
          v175 = v191 * v79;
          v176 = v192 * v79;
          v177 = v193 * v79;
          v178 = v79 * v194;
          v182 = v173;
          v183 = v174;
          v184 = v175;
          v185 = v176;
          v186 = v177;
          v187 = v178;
        }
      }
    }
    v196 = 0.0;
    v197 = 0.0;
    v198 = 0.0;
    v228 = 0;
    *(float *)&v189 = 0.0;
    v190 = 0.0;
    v191 = 0.0;
    LOBYTE(v228) = 1;
    sub_10039830((int)&v196, LODWORD(v180) >> 1);
    sub_10039830((int)&v189, *(_DWORD *)(v172 + 40) >> 1);
    v80 = v197;
    v180 = 1.0e10;
    v81 = v190;
    v195 = 0.0;
    while ( 1 )
    {
      if ( v80 != 0.0 )
      {
        if ( v80 == 0.0 )
        {
          v82 = v196;
          for ( i = v196; LODWORD(v82) != LODWORD(i); LODWORD(v82) += 28 )
          {
            if ( v82 != 0.0 )
              *(_DWORD *)(LODWORD(v82) + 24) = 0;
          }
        }
        v80 = 0.0;
        v197 = 0.0;
      }
      if ( v81 != 0.0 )
      {
        if ( LODWORD(v81) <= 0 )
        {
          v84 = (char *)v189 + 28 * LODWORD(v81);
          for ( j = (int)&v84[-28 * LODWORD(v81)]; v84 != (char *)j; v84 += 28 )
          {
            if ( v84 )
              *((_DWORD *)v84 + 6) = 0;
          }
        }
        v81 = 0.0;
        v190 = 0.0;
      }
      v164 = 0.0;
      v215 = 0.0;
      v165 = 0.0;
      v181 = 0.0;
      v166 = 0.0;
      v167 = 0.0;
      v168 = 0.0;
      v169 = 0.0;
      v158 = 0.0;
      v159 = 0.0;
      v160 = 0.0;
      v161 = 0.0;
      v162 = 0.0;
      v163 = 0.0;
      v188 = 0i64;
      *(_QWORD *)&v179 = 0i64;
      v170 = 0.0;
      if ( *(_DWORD *)(v172 + 40) <= 0u )
        break;
      v171 = 0.0;
      do
      {
        v86 = *(_DWORD *)(v172 + 36) + LODWORD(v171);
        v87 = *(_DWORD *)(v86 + 24);
        v88 = sub_1003CC80(v86, (int)&v203);
        if ( sub_1003CC80(v86, (int)&v182) <= v88 )
        {
          if ( LODWORD(v81) >= LODWORD(v191) )
          {
            sub_100943C0(LODWORD(v81) + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003B7E0, (int)&v189, 1, 0x1Cu, 0);
            v81 = v190;
          }
          v100 = (char *)v189 + 28 * LODWORD(v81);
          if ( v100 )
          {
            *(float *)v100 = *(float *)v86;
            *((float *)v100 + 1) = *(float *)(v86 + 4);
            *((float *)v100 + 2) = *(float *)(v86 + 8);
            *((float *)v100 + 3) = *(float *)(v86 + 12);
            *((float *)v100 + 4) = *(float *)(v86 + 16);
            *((float *)v100 + 5) = *(float *)(v86 + 20);
            *((_DWORD *)v100 + 6) = *(_DWORD *)(v86 + 24);
          }
          ++LODWORD(v81);
          v190 = v81;
          v101 = (double)v87;
          v102 = LODWORD(v179);
          LODWORD(v179) += v87;
          v103 = v101;
          v104 = v101 * *(float *)v86;
          *(_QWORD *)&v179 = __PAIR__(HIDWORD(v179), v87) + v102;
          v209 = v104;
          v210 = *(float *)(v86 + 4) * v101;
          v211 = *(float *)(v86 + 8) * v101;
          v212 = v101 * *(float *)(v86 + 12);
          v213 = v101 * *(float *)(v86 + 16);
          v214 = *(float *)(v86 + 20) * v101;
          v158 = v158 + v209;
          v159 = v159 + v210;
          v160 = v160 + v211;
          v161 = v161 + v212;
          v162 = v162 + v213;
          v163 = v163 + v214;
          v105 = *(float *)v86 * *(float *)v86;
          v106 = *(float *)(v86 + 4) * *(float *)(v86 + 4) + v105;
          v107 = *(float *)(v86 + 8) * *(float *)(v86 + 8) + v106;
          v108 = *(float *)(v86 + 12) * *(float *)(v86 + 12) + v107;
          v109 = *(float *)(v86 + 16) * *(float *)(v86 + 16) + v108;
          v110 = *(float *)(v86 + 20) * *(float *)(v86 + 20) + v109;
          v181 = v103 * v110 + v181;
        }
        else
        {
          if ( LODWORD(v80) >= LODWORD(v198) )
          {
            sub_100943C0(LODWORD(v80) + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003B7E0, (int)&v196, 1, 0x1Cu, 0);
            v80 = v197;
          }
          v89 = LODWORD(v196) + 28 * LODWORD(v80);
          if ( v89 )
          {
            *(float *)v89 = *(float *)v86;
            *(float *)(v89 + 4) = *(float *)(v86 + 4);
            *(float *)(v89 + 8) = *(float *)(v86 + 8);
            *(float *)(v89 + 12) = *(float *)(v86 + 12);
            *(float *)(v89 + 16) = *(float *)(v86 + 16);
            *(float *)(v89 + 20) = *(float *)(v86 + 20);
            *(_DWORD *)(v89 + 24) = *(_DWORD *)(v86 + 24);
          }
          ++LODWORD(v80);
          v197 = v80;
          v90 = (double)v87;
          v91 = v188;
          LODWORD(v188) = v87 + v188;
          v92 = v90;
          v93 = v90 * *(float *)v86;
          v188 = __PAIR__(HIDWORD(v188), v87) + v91;
          v173 = v93;
          v174 = *(float *)(v86 + 4) * v90;
          v175 = *(float *)(v86 + 8) * v90;
          v176 = v90 * *(float *)(v86 + 12);
          v177 = v90 * *(float *)(v86 + 16);
          v178 = *(float *)(v86 + 20) * v90;
          v164 = v173 + v164;
          v165 = v174 + v165;
          v166 = v175 + v166;
          v167 = v176 + v167;
          v168 = v177 + v168;
          v169 = v169 + v178;
          v94 = *(float *)v86 * *(float *)v86;
          v95 = *(float *)(v86 + 4) * *(float *)(v86 + 4) + v94;
          v96 = *(float *)(v86 + 8) * *(float *)(v86 + 8) + v95;
          v97 = *(float *)(v86 + 12) * *(float *)(v86 + 12) + v96;
          v98 = *(float *)(v86 + 16) * *(float *)(v86 + 16) + v97;
          v99 = *(float *)(v86 + 20) * *(float *)(v86 + 20) + v98;
          v215 = v92 * v99 + v215;
        }
        LODWORD(v171) += 28;
        ++LODWORD(v170);
      }
      while ( LODWORD(v170) < *(_DWORD *)(v172 + 40) );
      if ( !v188 )
        break;
      BYTE7(v111) = BYTE7(v179);
      if ( !*(_QWORD *)&v179 )
        break;
      v216 = v188 & 0x7FFFFFFFFFFFFFFFi64;
      v112 = v164 * v164;
      v219 = v188 & 0x8000000000000000ui64;
      v113 = v165 * v165 + v112;
      v114 = v166 * v166 + v113;
      v115 = v167 * v167 + v114;
      v116 = v168 * v168 + v115;
      v117 = v169 * v169 + v116;
      v170 = (double)(unsigned __int64)v188;
      v171 = v215 - v117 / v170;
      v118 = v158 * v158;
      v119 = v159 * v159 + v118;
      v120 = v160 * v160 + v119;
      v121 = v161 * v161 + v120;
      v122 = v162 * v162 + v121;
      v123 = v163 * v163 + v122;
      v217 = *(_QWORD *)&v179 & 0x7FFFFFFFFFFFFFFFi64;
      v218 = v111 & 0x8000000000000000ui64;
      v124 = (double)*(unsigned __int64 *)&v179;
      v125 = v124;
      v157 = v181 - v123 / v124;
      v126 = 1.0 / v170;
      v164 = v164 * v126;
      v203 = v164;
      v165 = v165 * v126;
      v204 = v165;
      v166 = v166 * v126;
      v205 = v166;
      v167 = v167 * v126;
      v206 = v167;
      v168 = v168 * v126;
      v169 = v126 * v169;
      v127 = 1.0 / v125;
      v158 = v158 * v127;
      v159 = v159 * v127;
      v160 = v160 * v127;
      v161 = v161 * v127;
      v162 = v162 * v127;
      v163 = v127 * v163;
      v182 = v158;
      v154 = v157 + v171;
      v207 = v168;
      v208 = v169;
      v185 = v161;
      v183 = v159;
      v184 = v160;
      v186 = v162;
      v187 = v163;
      if ( v154 >= 0.0000099999997 && (v180 - v154) / v154 >= 0.000009999999747378752 )
      {
        v180 = v157 + v171;
        if ( ++LODWORD(v195) < 0x400u )
          continue;
      }
      v130 = *(_DWORD *)(a1 + 20);
      v131 = v172;
      v132 = v202;
      *(_DWORD *)(v172 + 48) = v130;
      *(_DWORD *)(v131 + 52) = *(_DWORD *)(a1 + 20) + 1;
      v133 = *(_DWORD *)(v132 + 4);
      v134 = *(_DWORD *)(a1 + 20) + 2;
      if ( v134 != v133 )
      {
        if ( v134 >= v133 )
        {
          if ( v134 > *(_DWORD *)(v132 + 8) )
            sub_100943C0(v134, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004B740, v132, v134 == v133 + 1, 0x40u, 0);
          sub_1003E580(v134 - *(_DWORD *)(v132 + 4), *(_DWORD *)v132 + (*(_DWORD *)(v132 + 4) << 6));
        }
        else
        {
          v135 = *(_DWORD *)v202 + (v134 << 6);
          for ( k = v135 + ((v133 - v134) << 6); v135 != k; v135 += 64 )
          {
            v136 = *(_DWORD *)(v135 + 36);
            if ( v136 )
            {
              if ( v136 & 7 )
              {
                sprintf_s(
                  &DstBuf,
                  0x200u,
                  "%s(%u): Assertion failed: \"%s\"\n",
                  "crn_mem.cpp",
                  216,
                  "crnlib_free: bad ptr");
                OutputDebugStringA(&DstBuf);
                v137 = _iob_func();
                fputs(&DstBuf, v137 + 2);
                if ( IsDebuggerPresent() )
                  DebugBreak();
              }
              else
              {
                off_100AD9F4(v136, 0, 0, 1, dword_100AE9F4);
              }
            }
          }
        }
        v138 = v202;
        *(_DWORD *)(v202 + 4) = v134;
        v132 = v138;
      }
      v139 = *(_DWORD *)v132 + (v130 << 6);
      v140 = ((v130 + 1) << 6) + *(_DWORD *)v132;
      if ( (float *)v139 != &v203 )
      {
        *(float *)v139 = v203;
        *(float *)(v139 + 4) = v204;
        *(float *)(v139 + 8) = v205;
        *(float *)(v139 + 12) = v206;
        *(float *)(v139 + 16) = v207;
        *(float *)(v139 + 20) = v208;
      }
      v141 = v171;
      v142 = v197;
      *(_QWORD *)(v139 + 24) = v188;
      v143 = *(float *)(v139 + 36);
      *(float *)(v139 + 36) = v196;
      v144 = *(float *)(v139 + 40);
      *(float *)(v139 + 40) = v142;
      v197 = v144;
      v145 = *(float *)(v139 + 44);
      *(float *)(v139 + 44) = v198;
      *(float *)(v139 + 32) = v141;
      v196 = v143;
      v198 = v145;
      if ( (float *)v140 != &v182 )
      {
        *(float *)v140 = v182;
        *(float *)(v140 + 4) = v183;
        *(float *)(v140 + 8) = v184;
        *(float *)(v140 + 12) = v185;
        *(float *)(v140 + 16) = v186;
        *(float *)(v140 + 20) = v187;
      }
      v146 = HIDWORD(v179);
      *(_DWORD *)(v140 + 24) = LODWORD(v179);
      v147 = v189;
      *(_DWORD *)(v140 + 28) = v146;
      v148 = *(_DWORD *)(v140 + 36);
      *(_DWORD *)(v140 + 36) = v147;
      *(float *)(v140 + 40) = v190;
      *(float *)(v140 + 44) = v191;
      *(float *)(v140 + 32) = v157;
      LOBYTE(v228) = 0;
      if ( v148 )
      {
        if ( v148 & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v149 = _iob_func();
          fputs(&DstBuf, v149 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v148, 0, 0, 1, dword_100AE9F4);
        }
      }
      v228 = -1;
      if ( v143 != 0.0 )
      {
        if ( LOBYTE(v143) & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v150 = _iob_func();
          fputs(&DstBuf, v150 + 2);
          goto LABEL_131;
        }
        v152 = dword_100AE9F4;
        v151 = v143;
LABEL_134:
        off_100AD9F4(LODWORD(v151), 0, 0, 1, v152);
        return;
      }
      return;
    }
    LOBYTE(v228) = 0;
    *(_BYTE *)(v172 + 60) = 1;
    if ( *(float *)&v189 != 0.0 )
    {
      if ( (unsigned __int8)v189 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v128 = _iob_func();
        fputs(&DstBuf, v128 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v189, 0, 0, 1, dword_100AE9F4);
      }
    }
    v228 = -1;
    if ( v196 != 0.0 )
    {
      if ( !(LOBYTE(v196) & 7) )
      {
        v152 = dword_100AE9F4;
        v151 = v196;
        goto LABEL_134;
      }
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v129 = _iob_func();
      fputs(&DstBuf, v129 + 2);
LABEL_131:
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
  }
}
// 1004B740: using guessed type int sub_1004B740();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 10044ED0: using guessed type char var_274[100];
// 10044ED0: using guessed type float var_28C[6];

//----- (10046720) --------------------------------------------------------
void __userpurge sub_10046720(int a1@<esi>, unsigned int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // ecx@1
  int v4; // ebx@6
  int v5; // ecx@6
  int v6; // edx@6
  int v7; // eax@6
  int v8; // [sp+0h] [bp-18h]@4
  int v9; // [sp+4h] [bp-14h]@4
  int v10; // [sp+8h] [bp-10h]@4
  int v11; // [sp+14h] [bp-4h]@4

  v2 = a2;
  v3 = *(_DWORD *)(a1 + 8);
  if ( a2 <= v3 )
  {
    if ( a2 < v3 )
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      if ( *(_DWORD *)(a1 + 4) > a2 )
        v2 = *(_DWORD *)(a1 + 4);
      sub_100943C0(v2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004B740, (int)&v8, 0, 0x40u, 0);
      sub_1004A580((int)&v8, a1);
      v4 = *(_DWORD *)a1;
      v5 = v9;
      v6 = v10;
      *(_DWORD *)a1 = v8;
      v7 = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a1 + 4) = v5;
      *(_DWORD *)(a1 + 8) = v6;
      v11 = -1;
      if ( v4 )
      {
        sub_1004CEA0(v7, v4);
        if ( v4 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004B740, a1, 0, 0x40u, 0);
  }
}
// 1004B740: using guessed type int sub_1004B740();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10046830) --------------------------------------------------------
void __stdcall sub_10046830(int a1, int a2)
{
  int v2; // eax@1
  unsigned int v3; // ebx@1
  int v4; // esi@1
  unsigned int v5; // edx@2
  double v6; // st7@2
  double v7; // st6@2
  int v8; // ecx@3
  float v9; // ST30_4@4
  float v10; // ST2C_4@4
  float v11; // ST30_4@4
  float v12; // ST2C_4@4
  float v13; // ST30_4@4
  unsigned int v14; // edx@8
  double v15; // st5@8
  double v16; // st4@8
  double v17; // st3@8
  int v18; // ecx@9
  float v19; // ST2C_4@10
  float v20; // ST30_4@10
  float v21; // ST2C_4@10
  float v22; // ST30_4@10
  float v23; // ST2C_4@10
  int v24; // ebp@16
  int v25; // edi@16
  int v26; // ecx@17
  double v27; // st6@17
  unsigned int v28; // ecx@19
  int v29; // esi@19
  signed int v30; // ebx@19
  unsigned int v31; // eax@20
  int v32; // eax@22
  int *v33; // edx@24
  double v34; // st6@24
  double v35; // st5@25
  float v36; // ST30_4@25
  signed int v37; // ebx@28
  int v38; // ebp@28
  unsigned int v39; // edi@28
  unsigned int v40; // eax@29
  int v41; // ecx@31
  float *v42; // edx@33
  float *v43; // esi@33
  int v44; // ecx@33
  double v45; // st6@34
  unsigned int v46; // eax@36
  signed int v47; // ecx@36
  double v48; // st3@37
  double v49; // st2@37
  double v50; // st6@39
  double v51; // st5@39
  long double v52; // st3@44
  double v53; // st7@45
  double v54; // st6@45
  double v55; // st5@45
  double v56; // st4@45
  double v57; // st3@45
  unsigned int v58; // edx@47
  double v59; // st3@47
  unsigned int v60; // edi@48
  int v61; // ecx@48
  float v62; // ST2C_4@49
  float v63; // ST2C_4@49
  double v64; // st2@49
  double v65; // st1@49
  unsigned int v66; // ebp@56
  float v67; // ebx@56
  int v68; // edx@56
  double v69; // st7@57
  int j; // esi@57
  float v71; // eax@59
  float i; // ecx@59
  int v73; // eax@66
  int v74; // ecx@66
  int v75; // esi@73
  unsigned int v76; // edi@73
  float v77; // ST2C_4@73
  float v78; // ST30_4@73
  float v79; // ST2C_4@73
  float v80; // ST30_4@73
  float v81; // ST2C_4@73
  float v82; // ST30_4@73
  double v83; // st6@73
  float v84; // ST2C_4@73
  float v85; // ST30_4@73
  float v86; // ST2C_4@73
  float v87; // ST30_4@73
  float v88; // ST2C_4@73
  float v89; // ST30_4@73
  int v90; // eax@76
  float v91; // ST28_4@78
  unsigned int v92; // kr04_4@78
  double v93; // st6@78
  double v94; // st5@78
  float v95; // ST28_4@78
  float v96; // ST28_4@78
  float v97; // ST28_4@78
  int v98; // eax@81
  float v99; // ST28_4@83
  unsigned int v100; // kr08_4@83
  double v101; // st6@83
  double v102; // st5@83
  float v103; // ST28_4@83
  float v104; // ST28_4@83
  float v105; // ST28_4@83
  float v106; // ST28_4@87
  float v107; // ST28_4@87
  double v108; // st4@87
  float v109; // ST28_4@87
  float v110; // ST28_4@87
  double v111; // st2@87
  float v112; // ST28_4@87
  float v113; // ST28_4@87
  int v114; // eax@91
  FILE *v115; // eax@93
  FILE *v116; // eax@98
  int v117; // edi@100
  int *v118; // ecx@100
  unsigned int v119; // eax@100
  unsigned int v120; // esi@100
  int v121; // ebp@100
  int v122; // ebp@102
  int v123; // eax@103
  FILE *v124; // eax@105
  int v125; // ebp@110
  int v126; // ecx@114
  int v127; // eax@114
  int v128; // ecx@114
  double v129; // st7@116
  float v130; // esi@116
  float v131; // ebx@116
  float v132; // edx@116
  float v133; // edx@116
  double v134; // st7@118
  int v135; // eax@118
  int v136; // edx@118
  int v137; // eax@118
  FILE *v138; // eax@120
  FILE *v139; // eax@125
  float v140; // [sp-14h] [bp-328h]@99
  int v141; // [sp-4h] [bp-318h]@99
  unsigned int v142; // [sp+10h] [bp-304h]@1
  float v143; // [sp+10h] [bp-304h]@87
  float v144; // [sp+14h] [bp-300h]@4
  float v145; // [sp+18h] [bp-2FCh]@10
  unsigned __int64 v146; // [sp+1Ch] [bp-2F8h]@2
  float v147; // [sp+24h] [bp-2F0h]@2
  int k; // [sp+28h] [bp-2ECh]@19
  float v149; // [sp+2Ch] [bp-2E8h]@15
  float v150; // [sp+30h] [bp-2E4h]@14
  float v151; // [sp+34h] [bp-2E0h]@14
  float v152; // [sp+38h] [bp-2DCh]@14
  float v153; // [sp+3Ch] [bp-2D8h]@22
  float v154; // [sp+40h] [bp-2D4h]@49
  float v155; // [sp+44h] [bp-2D0h]@49
  float v156; // [sp+48h] [bp-2CCh]@72
  unsigned __int64 v157; // [sp+4Ch] [bp-2C8h]@36
  float v158; // [sp+54h] [bp-2C0h]@36
  float v159; // [sp+60h] [bp-2B4h]@50
  float v160; // [sp+64h] [bp-2B0h]@50
  float v161; // [sp+68h] [bp-2ACh]@50
  int v162; // [sp+6Ch] [bp-2A8h]@1
  float v163; // [sp+70h] [bp-2A4h]@14
  float v164; // [sp+74h] [bp-2A0h]@14
  float v165; // [sp+78h] [bp-29Ch]@14
  signed __int64 v166; // [sp+7Ch] [bp-298h]@47
  unsigned __int64 v167; // [sp+84h] [bp-290h]@33
  float v168; // [sp+8Ch] [bp-288h]@15
  float v169; // [sp+90h] [bp-284h]@15
  float v170; // [sp+94h] [bp-280h]@15
  float v171; // [sp+98h] [bp-27Ch]@15
  float v172; // [sp+9Ch] [bp-278h]@15
  float v173; // [sp+A0h] [bp-274h]@15
  float v174; // [sp+A4h] [bp-270h]@15
  float v175; // [sp+A8h] [bp-26Ch]@15
  float v176; // [sp+ACh] [bp-268h]@15
  int v177; // [sp+B0h] [bp-264h]@1
  float v178; // [sp+B4h] [bp-260h]@14
  float v179; // [sp+B8h] [bp-25Ch]@14
  float v180; // [sp+BCh] [bp-258h]@14
  int v181; // [sp+C0h] [bp-254h]@56
  double v182; // [sp+C4h] [bp-250h]@36
  double v183; // [sp+CCh] [bp-248h]@71
  float v184; // [sp+D4h] [bp-240h]@78
  float v185; // [sp+D8h] [bp-23Ch]@78
  float v186; // [sp+DCh] [bp-238h]@78
  float v187; // [sp+E0h] [bp-234h]@83
  float v188; // [sp+E4h] [bp-230h]@83
  float v189; // [sp+E8h] [bp-22Ch]@83
  __int64 v190; // [sp+ECh] [bp-228h]@87
  unsigned __int64 v191; // [sp+F4h] [bp-220h]@87
  unsigned __int64 v192; // [sp+FCh] [bp-218h]@87
  char DstBuf; // [sp+104h] [bp-210h]@93
  int v194; // [sp+310h] [bp-4h]@56

  v2 = *(_DWORD *)(a1 + 16);
  v3 = *(_DWORD *)(v2 + 56 * a2 + 32);
  v4 = v2 + 56 * a2;
  v177 = a1 + 16;
  v162 = v2 + 56 * a2;
  v142 = v3;
  if ( v3 != 1 )
  {
    v5 = 0;
    *(float *)&v146 = 0.0;
    *((float *)&v146 + 1) = 0.0;
    v147 = 0.0;
    v6 = -1.0;
    v7 = -1.0;
    if ( v3 )
    {
      v8 = *(_DWORD *)(v4 + 28);
      do
      {
        v9 = *(float *)v8 - *(float *)v4;
        v10 = v9 * v9 + 0.0;
        v11 = *(float *)(v8 + 4) - *(float *)(v4 + 4);
        v12 = v11 * v11 + v10;
        v13 = *(float *)(v8 + 8) - *(float *)(v4 + 8);
        v144 = v13 * v13 + v12;
        if ( v144 > v7 )
        {
          v7 = v144;
          if ( &v146 != (unsigned __int64 *)v8 )
          {
            v146 = *(_QWORD *)v8;
            v147 = *(float *)(v8 + 8);
          }
        }
        ++v5;
        v8 += 16;
      }
      while ( v5 < v3 );
    }
    v14 = 0;
    v15 = v147;
    v16 = *((float *)&v146 + 1);
    v17 = *(float *)&v146;
    if ( v3 )
    {
      v18 = *(_DWORD *)(v4 + 28);
      do
      {
        v19 = *(float *)v18 - v17;
        v20 = v19 * v19 + 0.0;
        v21 = *(float *)(v18 + 4) - v16;
        v22 = v21 * v21 + v20;
        v23 = *(float *)(v18 + 8) - v15;
        v145 = v23 * v23 + v22;
        if ( v145 > v6 )
        {
          v6 = v145;
          if ( &v146 != (unsigned __int64 *)v18 )
          {
            v146 = *(_QWORD *)v18;
            v147 = *(float *)(v18 + 8);
          }
        }
        ++v14;
        v18 += 16;
      }
      while ( v14 < v3 );
    }
    v163 = v17 + *(float *)v4;
    v164 = v16 + *(float *)(v4 + 4);
    v165 = v15 + *(float *)(v4 + 8);
    v178 = v163 * 0.5;
    v179 = v164 * 0.5;
    v180 = v165 * 0.5;
    v150 = *(float *)&v146 + *(float *)v4;
    v151 = *((float *)&v146 + 1) + *(float *)(v4 + 4);
    v152 = v147 + *(float *)(v4 + 8);
    v163 = v150 * 0.5;
    v164 = v151 * 0.5;
    v165 = 0.5 * v152;
    if ( v3 > 2 )
    {
      v168 = 0.0;
      v169 = 0.0;
      v170 = 0.0;
      v171 = 0.0;
      v172 = 0.0;
      v173 = 0.0;
      v174 = 0.0;
      v175 = 0.0;
      v176 = 0.0;
      v149 = 0.0;
      if ( v3 )
      {
        v24 = v2 + 56 * a2;
        v25 = *(_DWORD *)(v4 + 28);
        do
        {
          v26 = *(_DWORD *)(v25 + 12);
          *(float *)&v146 = *(float *)v25 - *(float *)v24;
          *((float *)&v146 + 1) = *(float *)(v25 + 4) - *(float *)(v24 + 4);
          v147 = *(float *)(v25 + 8) - *(float *)(v24 + 8);
          v27 = (double)*(signed int *)(v25 + 12);
          if ( v26 < 0 )
            v27 = v27 + 4294967300.0;
          *(float *)&k = v27;
          v28 = 0;
          v29 = 0;
          v30 = 3;
          v150 = *(float *)&v146 * *(float *)&k;
          v151 = *((float *)&v146 + 1) * *(float *)&k;
          v152 = *(float *)&k * v147;
          do
          {
            v31 = v28;
            if ( v28 < 3 )
            {
              if ( v30 >= 4 )
              {
                v32 = 4 * (v29 + v28);
                *(float *)((char *)&v168 + v32) = *(&v150 + v28) * *((float *)&v146 + v28) + *(&v168 + v29 + v28);
                *(float *)((char *)&v169 + v32) = *(&v151 + v28) * *((float *)&v146 + v28) + *(&v169 + v29 + v28);
                *(float *)((char *)&v170 + v32) = *(&v152 + v28) * *((float *)&v146 + v28) + *(&v170 + v29 + v28);
                *(float *)((char *)&v171 + v32) = *(&v153 + v28) * *((float *)&v146 + v28)
                                                + *(float *)((char *)&v171 + v32);
                v31 = v28 + 4;
              }
              if ( v31 < 3 )
              {
                v33 = (int *)(&v168 + v29 + v31);
                v34 = *((float *)&v146 + v28);
                do
                {
                  v35 = *(&v150 + v31++);
                  v36 = v35;
                  ++v33;
                  *((float *)v33 - 1) = v36 * v34 + *((float *)v33 - 1);
                }
                while ( v31 < 3 );
              }
            }
            ++v28;
            --v30;
            v29 += 3;
          }
          while ( v28 < 3 );
          v25 += 16;
          ++LODWORD(v149);
        }
        while ( LODWORD(v149) < *(_DWORD *)(v24 + 32) );
      }
      v37 = 2;
      v38 = 0;
      v39 = 1;
      LODWORD(v149) = 2;
      do
      {
        v40 = v39;
        if ( v39 < 3 )
        {
          if ( v37 >= 4 )
          {
            v41 = 4 * (v39 + v38) + 8;
            *(float *)((char *)&v168 + v41) = *(&v168 + v39 + v38);
            *(float *)((char *)&v171 + v41) = *(&v169 + v39 + v38);
            *(float *)((char *)&v174 + v41) = *(&v170 + v39 + v38);
            v40 = v39 + 4;
            *(int *)((char *)&v177 + v41) = *((int *)&v171 + v39 + v38);
          }
          if ( v40 < 3 )
          {
            v42 = &v168 + v40 + v38;
            v43 = (float *)((char *)&v167 + 4 * (v40 + v39 + 2 * v40) + 4);
            v44 = 3 - v40;
            do
            {
              v45 = *v42;
              ++v42;
              *v43 = v45;
              v43 += 3;
              --v44;
            }
            while ( v44 );
          }
        }
        --v37;
        ++v39;
        v38 += 3;
        --LODWORD(v149);
      }
      while ( v149 != 0.0 );
      v46 = *(_DWORD *)(v162 + 20);
      HIDWORD(v182) = v46 & 0x80000000;
      LODWORD(v182) = 0;
      v47 = 10;
      *(float *)&k = (double)__PAIR__(v46, *(_DWORD *)(v162 + 16));
      v168 = v168 / *(float *)&k;
      v169 = v169 / *(float *)&k;
      v170 = v170 / *(float *)&k;
      v171 = v171 / *(float *)&k;
      v172 = v172 / *(float *)&k;
      v173 = v173 / *(float *)&k;
      v174 = v174 / *(float *)&k;
      v175 = v175 / *(float *)&k;
      v176 = v176 / *(float *)&k;
      *(float *)&v157 = 1.0;
      *((float *)&v157 + 1) = 1.0;
      v158 = 1.0;
      do
      {
        v48 = *(float *)&v157 * v168 + 0.0 + *((float *)&v157 + 1) * v169 + v158 * v170;
        *(float *)&v146 = v48;
        v49 = *(float *)&v157 * v171 + 0.0 + *((float *)&v157 + 1) * v172 + v158 * v173;
        *((float *)&v146 + 1) = v49;
        if ( v49 >= v48 )
          v48 = v49;
        v50 = v48;
        v51 = v158 * v176 + *((float *)&v157 + 1) * v175 + *(float *)&v157 * v174 + 0.0;
        v147 = v51;
        if ( v51 >= v48 )
          v50 = v51;
        if ( 0.0 != v50 )
        {
          *(float *)&k = 1.0 / v50;
          *(float *)&v146 = *(float *)&k * *(float *)&v146;
          *((float *)&v146 + 1) = *(float *)&k * *((float *)&v146 + 1);
          v147 = *(float *)&k * v147;
        }
        --v47;
        v157 = v146;
        v158 = v147;
      }
      while ( v47 );
      v52 = v158 * v158 + *(float *)&v157 * *(float *)&v157 + *((float *)&v157 + 1) * *((float *)&v157 + 1);
      if ( 0.0 == v52 )
      {
        v53 = v158;
        v56 = 0.0;
        v54 = *((float *)&v157 + 1);
        v57 = 0.0;
        v55 = *(float *)&v157;
      }
      else
      {
        *(float *)&k = 1.0 / sqrt(v52);
        *(float *)&v157 = *(float *)&k * *(float *)&v157;
        *((float *)&v157 + 1) = *(float *)&k * *((float *)&v157 + 1);
        v158 = *(float *)&k * v158;
        v53 = v158;
        v54 = *((float *)&v157 + 1);
        v55 = *(float *)&v157;
        v56 = 0.0;
        v57 = 0.0;
      }
      *(float *)&v146 = v57;
      v58 = 0;
      *((float *)&v146 + 1) = v57;
      v147 = v57;
      v150 = v57;
      v151 = v57;
      v152 = v57;
      *(double *)&v166 = v56;
      v59 = v56;
      if ( v142 )
      {
        v60 = *(_DWORD *)(v162 + 32);
        v61 = *(_DWORD *)(v162 + 28);
        do
        {
          v149 = (double)*(unsigned int *)(v61 + 12);
          v153 = *(float *)v61 - *(float *)v162;
          v154 = *(float *)(v61 + 4) - *(float *)(v162 + 4);
          v155 = *(float *)(v61 + 8) - *(float *)(v162 + 8);
          v62 = v153 * v55;
          *(float *)&k = v154 * v54 + v62;
          v63 = *(float *)&k + v155 * v53;
          v64 = v149;
          v65 = v149 * *(float *)v61;
          if ( v63 >= v56 )
          {
            *(float *)&v157 = v65;
            *((float *)&v157 + 1) = *(float *)(v61 + 4) * v64;
            v158 = *(float *)(v61 + 8) * v64;
            v150 = *(float *)&v157 + v150;
            v151 = *((float *)&v157 + 1) + v151;
            v152 = v158 + v152;
            v59 = v59 + v64;
          }
          else
          {
            v159 = v65;
            v160 = *(float *)(v61 + 4) * v64;
            v161 = *(float *)(v61 + 8) * v64;
            *(float *)&v146 = v159 + *(float *)&v146;
            *((float *)&v146 + 1) = v160 + *((float *)&v146 + 1);
            v147 = v161 + v147;
            *(double *)&v166 = v64 + *(double *)&v166;
          }
          ++v58;
          v61 += 16;
        }
        while ( v58 < v60 );
        if ( *(double *)&v166 > v56 && v56 < v59 )
        {
          *(float *)&k = 1.0 / *(double *)&v166;
          v153 = *(float *)&k * *(float *)&v146;
          v154 = *(float *)&k * *((float *)&v146 + 1);
          v155 = *(float *)&k * v147;
          v178 = v153;
          v179 = v154;
          v180 = v155;
          *(float *)&k = 1.0 / v59;
          *(float *)&v146 = *(float *)&k * v150;
          *((float *)&v146 + 1) = *(float *)&k * v151;
          v147 = *(float *)&k * v152;
          v163 = *(float *)&v146;
          v164 = *((float *)&v146 + 1);
          v165 = v147;
        }
      }
    }
    v153 = 0.0;
    v154 = 0.0;
    v155 = 0.0;
    v194 = 0;
    v146 = 0i64;
    v147 = 0.0;
    LOBYTE(v194) = 1;
    sub_10049EA0((int)&v153, v142 >> 1);
    sub_10049EA0((int)&v146, *(_DWORD *)(v162 + 32) >> 1);
    v66 = HIDWORD(v146);
    *(float *)&v181 = 1.0e10;
    v67 = v154;
    v68 = v162;
    *(float *)&k = 0.0;
    while ( 1 )
    {
      v69 = 0.0;
      j = 0;
      if ( v67 != 0.0 )
      {
        if ( v67 == 0.0 )
        {
          v71 = v153;
          for ( i = v153; LODWORD(v71) != LODWORD(i); LODWORD(v71) += 16 )
          {
            if ( v71 != 0.0 )
              *(_DWORD *)(LODWORD(v71) + 12) = 0;
          }
        }
        v67 = 0.0;
        v154 = 0.0;
      }
      if ( v66 )
      {
        if ( v66 <= 0 )
        {
          v73 = v146 + 16 * v66;
          v74 = v73 + -16 * v66;
          for ( j = 0; v73 != v74; v73 += 16 )
          {
            if ( v73 )
              *(_DWORD *)(v73 + 12) = 0;
          }
        }
        v66 = 0;
        HIDWORD(v146) = 0;
      }
      v183 = 0.0;
      v182 = 0.0;
      v150 = 0.0;
      v151 = 0.0;
      v152 = 0.0;
      v159 = 0.0;
      v160 = 0.0;
      v161 = 0.0;
      v166 = 0i64;
      v167 = 0i64;
      v149 = 0.0;
      if ( *(_DWORD *)(v68 + 32) <= 0u )
        break;
      v156 = 0.0;
      do
      {
        v75 = *(_DWORD *)(v68 + 28) + j;
        v76 = *(_DWORD *)(v75 + 12);
        v77 = v178 - *(float *)v75;
        v78 = v77 * v77 + v69;
        v79 = v179 - *(float *)(v75 + 4);
        v80 = v79 * v79 + v78;
        v81 = v180 - *(float *)(v75 + 8);
        v82 = v81 * v81 + v80;
        v83 = v82;
        v84 = v163 - *(float *)v75;
        v85 = v84 * v84 + v69;
        v86 = v164 - *(float *)(v75 + 4);
        v87 = v86 * v86 + v85;
        v88 = v165 - *(float *)(v75 + 8);
        v89 = v88 * v88 + v87;
        if ( v89 <= v83 )
        {
          if ( v66 >= LODWORD(v147) )
          {
            sub_100943C0(v66 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C600, (int)&v146, 1, 0x10u, 0);
            v69 = 0.0;
            v66 = HIDWORD(v146);
            v68 = v162;
          }
          v98 = v146 + 16 * v66;
          if ( v98 )
          {
            *(float *)v98 = *(float *)v75;
            *(float *)(v98 + 4) = *(float *)(v75 + 4);
            *(float *)(v98 + 8) = *(float *)(v75 + 8);
            *(_DWORD *)(v98 + 12) = *(_DWORD *)(v75 + 12);
          }
          HIDWORD(v146) = ++v66;
          v99 = (double)v76;
          v100 = v167;
          LODWORD(v167) = v76 + v167;
          v101 = v99;
          v102 = v99 * *(float *)v75;
          v167 = __PAIR__(HIDWORD(v167), v76) + v100;
          v187 = v102;
          v188 = v99 * *(float *)(v75 + 4);
          v189 = v99 * *(float *)(v75 + 8);
          v159 = v159 + v187;
          v160 = v160 + v188;
          v161 = v161 + v189;
          v103 = *(float *)v75 * *(float *)v75;
          v104 = *(float *)(v75 + 4) * *(float *)(v75 + 4) + v103;
          v105 = *(float *)(v75 + 8) * *(float *)(v75 + 8) + v104;
          v182 = v101 * v105 + v182;
        }
        else
        {
          if ( LODWORD(v67) >= LODWORD(v155) )
          {
            sub_100943C0(LODWORD(v67) + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C600, (int)&v153, 1, 0x10u, 0);
            v69 = 0.0;
            v67 = v154;
            v68 = v162;
          }
          v90 = LODWORD(v153) + 16 * LODWORD(v67);
          if ( v90 )
          {
            *(float *)v90 = *(float *)v75;
            *(float *)(v90 + 4) = *(float *)(v75 + 4);
            *(float *)(v90 + 8) = *(float *)(v75 + 8);
            *(_DWORD *)(v90 + 12) = *(_DWORD *)(v75 + 12);
          }
          ++LODWORD(v67);
          v154 = v67;
          v91 = (double)v76;
          v92 = v166;
          LODWORD(v166) = v76 + v166;
          v93 = v91;
          v94 = v91 * *(float *)v75;
          v166 = __PAIR__(HIDWORD(v166), v76) + v92;
          v184 = v94;
          v185 = v91 * *(float *)(v75 + 4);
          v186 = v91 * *(float *)(v75 + 8);
          v150 = v150 + v184;
          v151 = v151 + v185;
          v152 = v152 + v186;
          v95 = *(float *)v75 * *(float *)v75;
          v96 = *(float *)(v75 + 4) * *(float *)(v75 + 4) + v95;
          v97 = *(float *)(v75 + 8) * *(float *)(v75 + 8) + v96;
          v183 = v93 * v97 + v183;
        }
        j = LODWORD(v156) + 16;
        ++LODWORD(v149);
        LODWORD(v156) += 16;
      }
      while ( LODWORD(v149) < *(_DWORD *)(v68 + 32) );
      if ( !v166 || !v167 )
        break;
      v190 = v166 & 0x7FFFFFFFFFFFFFFFi64;
      v106 = v150 * v150;
      v192 = v166 & 0x8000000000000000ui64;
      v191 = v167 & 0x7FFFFFFFFFFFFFFFi64;
      v157 = v167 & 0x8000000000000000ui64;
      v156 = v151 * v151 + v106;
      v107 = v152 * v152 + v156;
      v156 = (double)(unsigned __int64)v166;
      v108 = v156;
      v156 = v183 - v107 / v156;
      v109 = v159 * v159;
      v149 = v160 * v160 + v109;
      v110 = v161 * v161 + v149;
      v149 = (double)v167;
      v111 = v149;
      v149 = v182 - v110 / v149;
      v112 = 1.0 / v108;
      v150 = v150 * v112;
      v178 = v150;
      v151 = v151 * v112;
      v179 = v151;
      v152 = v112 * v152;
      v180 = v152;
      v113 = 1.0 / v111;
      v159 = v159 * v113;
      v163 = v159;
      v160 = v160 * v113;
      v164 = v160;
      v161 = v113 * v161;
      v165 = v161;
      v143 = v149 + v156;
      if ( v143 >= 0.0000099999997 && (*(float *)&v181 - v143) / v143 >= 0.000009999999747378752 )
      {
        *(float *)&v181 = v149 + v156;
        if ( (unsigned int)++k < 0x400 )
          continue;
      }
      v117 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v68 + 40) = v117;
      *(_DWORD *)(v68 + 44) = *(_DWORD *)(a1 + 20) + 1;
      v118 = (int *)v177;
      v119 = *(_DWORD *)(v177 + 4);
      v120 = *(_DWORD *)(a1 + 20) + 2;
      v121 = v117 + 1;
      v181 = v117 + 1;
      if ( v119 != v120 )
      {
        if ( v120 >= v119 )
        {
          v125 = v177;
          if ( v120 > *(_DWORD *)(v177 + 8) )
          {
            LOBYTE(k) = v120 == v119 + 1;
            sub_100943C0(v120, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004BB90, v177, v120 == v119 + 1, 0x38u, 0);
          }
          sub_1004CF90(*(_DWORD *)v125 + 56 * *(_DWORD *)(v125 + 4), v120 - *(_DWORD *)(v125 + 4));
        }
        else
        {
          v122 = *(_DWORD *)v177 + 56 * v120;
          for ( k = v122 + 56 * (v119 - v120); v122 != k; v122 += 56 )
          {
            v123 = *(_DWORD *)(v122 + 28);
            if ( v123 )
            {
              if ( v123 & 7 )
              {
                sprintf_s(
                  &DstBuf,
                  0x200u,
                  "%s(%u): Assertion failed: \"%s\"\n",
                  "crn_mem.cpp",
                  216,
                  "crnlib_free: bad ptr");
                OutputDebugStringA(&DstBuf);
                v124 = _iob_func();
                fputs(&DstBuf, v124 + 2);
                if ( IsDebuggerPresent() )
                  DebugBreak();
              }
              else
              {
                off_100AD9F4(v123, 0, 0, 1, dword_100AE9F4);
              }
            }
          }
        }
        v118 = (int *)v177;
        v121 = v181;
        *(_DWORD *)(v177 + 4) = v120;
      }
      v126 = *v118;
      v127 = v126 + 56 * v117;
      v128 = v126 + 56 * v121;
      if ( (float *)v127 != &v178 )
      {
        *(float *)v127 = v178;
        *(float *)(v127 + 4) = v179;
        *(float *)(v127 + 8) = v180;
      }
      v129 = v156;
      v130 = v154;
      *(_QWORD *)(v127 + 16) = v166;
      v131 = *(float *)(v127 + 28);
      *(float *)(v127 + 28) = v153;
      v132 = *(float *)(v127 + 32);
      *(float *)(v127 + 32) = v130;
      v154 = v132;
      v133 = *(float *)(v127 + 36);
      *(float *)(v127 + 36) = v155;
      *(float *)(v127 + 24) = v129;
      v153 = v131;
      v155 = v133;
      if ( (float *)v128 != &v163 )
      {
        *(float *)v128 = v163;
        *(float *)(v128 + 4) = v164;
        *(float *)(v128 + 8) = v165;
      }
      v134 = v149;
      v135 = HIDWORD(v167);
      *(_DWORD *)(v128 + 16) = v167;
      v136 = v146;
      *(_DWORD *)(v128 + 20) = v135;
      v137 = *(_DWORD *)(v128 + 28);
      *(_DWORD *)(v128 + 28) = v136;
      *(_DWORD *)(v128 + 32) = HIDWORD(v146);
      *(float *)(v128 + 36) = v147;
      *(float *)(v128 + 24) = v134;
      LOBYTE(v194) = 0;
      if ( v137 )
      {
        if ( v137 & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v138 = _iob_func();
          fputs(&DstBuf, v138 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v137, 0, 0, 1, dword_100AE9F4);
        }
      }
      v194 = -1;
      if ( v131 != 0.0 )
      {
        if ( LOBYTE(v131) & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v139 = _iob_func();
          fputs(&DstBuf, v139 + 2);
          goto LABEL_126;
        }
        v141 = dword_100AE9F4;
        v140 = v131;
LABEL_129:
        off_100AD9F4(LODWORD(v140), 0, 0, 1, v141);
        return;
      }
      return;
    }
    LOBYTE(v194) = 0;
    v114 = v146;
    *(_BYTE *)(v68 + 52) = 1;
    if ( v114 )
    {
      if ( v114 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v115 = _iob_func();
        fputs(&DstBuf, v115 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v114, 0, 0, 1, dword_100AE9F4);
      }
    }
    v194 = -1;
    if ( v153 != 0.0 )
    {
      if ( !(LOBYTE(v153) & 7) )
      {
        v141 = dword_100AE9F4;
        v140 = v153;
        goto LABEL_129;
      }
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v116 = _iob_func();
      fputs(&DstBuf, v116 + 2);
LABEL_126:
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
  }
}
// 1004BB90: using guessed type int sub_1004BB90();
// 1004C600: using guessed type int sub_1004C600();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10047BC0) --------------------------------------------------------
void __usercall sub_10047BC0(int a1@<esi>)
{
  int v1; // eax@2

  if ( *(_DWORD *)a1 )
  {
    sub_1004CEF0(*(_DWORD *)a1, *(_DWORD *)(a1 + 4));
    v1 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 )
    {
      if ( v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10047C10) --------------------------------------------------------
void __usercall sub_10047C10(int a1@<esi>)
{
  unsigned int v1; // eax@1
  unsigned int v2; // eax@4
  int v3; // ebx@6
  int v4; // edx@6
  int v5; // ecx@6
  int v6; // eax@6
  int v7; // [sp+0h] [bp-18h]@4
  int v8; // [sp+4h] [bp-14h]@4
  int v9; // [sp+8h] [bp-10h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 >= 5 )
  {
    if ( v1 > 5 )
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v2 = *(_DWORD *)(a1 + 4);
      if ( v2 <= 5 )
        v2 = 5;
      sub_100943C0(v2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004BB90, (int)&v7, 0, 0x38u, 0);
      sub_1004A740((int)&v7, a1);
      v3 = *(_DWORD *)a1;
      v4 = v8;
      *(_DWORD *)a1 = v7;
      v5 = *(_DWORD *)(a1 + 4);
      v6 = v9;
      *(_DWORD *)(a1 + 4) = v4;
      *(_DWORD *)(a1 + 8) = v6;
      v10 = -1;
      if ( v3 )
      {
        sub_1004CEF0(v3, v5);
        if ( v3 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(5u, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004BB90, a1, 0, 0x38u, 0);
  }
}
// 1004BB90: using guessed type int sub_1004BB90();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10047D20) --------------------------------------------------------
int __userpurge sub_10047D20@<eax>(int a1@<ebx>, int a2)
{
  unsigned int v2; // eax@1
  int result; // eax@3
  int v4; // edi@3

  v2 = *(_DWORD *)(a2 + 4);
  if ( v2 >= *(_DWORD *)(a2 + 8) )
    sub_100943C0(v2 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004BB90, a2, 1, 0x38u, 0);
  result = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)a2 + 56 * result;
  if ( v4 )
  {
    *(float *)v4 = *(float *)a1;
    *(float *)(v4 + 4) = *(float *)(a1 + 4);
    *(float *)(v4 + 8) = *(float *)(a1 + 8);
    *(_DWORD *)(v4 + 16) = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(v4 + 20) = *(_DWORD *)(a1 + 20);
    *(float *)(v4 + 24) = *(float *)(a1 + 24);
    sub_1004CCE0(a1 + 28, v4 + 28);
    *(_DWORD *)(v4 + 40) = *(_DWORD *)(a1 + 40);
    result = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(v4 + 44) = result;
    *(_DWORD *)(v4 + 48) = *(_DWORD *)(a1 + 48);
    *(_BYTE *)(v4 + 52) = *(_BYTE *)(a1 + 52);
  }
  ++*(_DWORD *)(a2 + 4);
  return result;
}
// 1004BB90: using guessed type int sub_1004BB90();

//----- (10047DD0) --------------------------------------------------------
void __stdcall sub_10047DD0(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // ebp@1
  unsigned int v4; // edx@2
  double v5; // st6@2
  double v6; // st5@2
  float *v7; // ecx@3
  float v8; // ST2C_4@4
  unsigned int v9; // edx@8
  double v10; // st4@8
  float *v11; // ecx@9
  float v12; // ST2C_4@10
  double v13; // st6@14
  float v14; // ST2C_4@14
  float v15; // ST2C_4@14
  double v16; // st5@15
  double v17; // st7@15
  unsigned int v18; // esi@15
  int v19; // edx@16
  int v20; // ecx@17
  double v21; // st4@17
  float v22; // ST2C_4@19
  unsigned int v23; // eax@19
  float *v24; // ecx@19
  double v25; // st4@19
  double v26; // st3@20
  float v27; // ST2C_4@20
  unsigned int v28; // eax@22
  signed int v29; // edx@22
  float v30; // ST2C_4@22
  double v31; // st4@23
  unsigned int v32; // ecx@23
  double v33; // st3@23
  double v34; // st2@24
  float v35; // ST2C_4@29
  long double v36; // st4@31
  float v37; // ST2C_4@32
  unsigned int v38; // edx@33
  double v39; // st5@33
  double v40; // st4@33
  int v41; // ecx@34
  float v42; // ST2C_4@35
  double v43; // st1@35
  double v44; // st2@35
  float v45; // ST28_4@37
  double v46; // rt2@39
  double v47; // st4@39
  double v48; // st5@39
  double v49; // rtt@40
  double v50; // st4@40
  double v51; // st6@40
  float v52; // ST28_4@41
  float v53; // ST28_4@41
  unsigned int v54; // ebx@42
  unsigned int v55; // ebp@42
  double v56; // st7@42
  char *v57; // eax@45
  int i; // ecx@45
  char *v59; // eax@52
  int j; // ecx@52
  float v61; // eax@57
  int v62; // esi@58
  unsigned int v63; // edi@58
  float v64; // ST28_4@58
  float v65; // ST28_4@58
  double v66; // st6@58
  float v67; // ST28_4@58
  float v68; // ST28_4@58
  char *v69; // eax@61
  unsigned int v70; // kr08_4@63
  double v71; // st5@63
  float v72; // ST28_4@63
  char *v73; // eax@66
  unsigned int v74; // kr0C_4@68
  double v75; // st5@68
  float v76; // ST28_4@68
  float v77; // ST28_4@72
  double v78; // st5@72
  float v79; // ST28_4@72
  double v80; // st3@72
  float v81; // ST28_4@72
  float v82; // ST28_4@72
  void *v83; // eax@76
  FILE *v84; // eax@78
  void *v85; // eax@81
  FILE *v86; // ST14_4@83
  int v87; // edx@84
  int v88; // edi@84
  unsigned int v89; // eax@84
  unsigned int v90; // esi@84
  int v91; // ecx@89
  int v92; // eax@89
  float *v93; // ecx@89
  int v94; // edx@89
  int v95; // eax@90
  int v96; // ecx@95
  int v97; // eax@95
  double v98; // st7@97
  void *v99; // esi@97
  int v100; // edx@97
  unsigned int v101; // edx@97
  double v102; // st7@99
  int v103; // ecx@99
  void *v104; // edx@99
  int v105; // ecx@99
  unsigned int v106; // edx@99
  FILE *v107; // eax@101
  FILE *v108; // ST14_4@106
  float v109; // [sp+10h] [bp-2ACh]@72
  float v110; // [sp+14h] [bp-2A8h]@4
  float v111; // [sp+14h] [bp-2A8h]@10
  int v112; // [sp+14h] [bp-2A8h]@42
  float v113; // [sp+18h] [bp-2A4h]@11
  float v114; // [sp+1Ch] [bp-2A0h]@17
  float v115; // [sp+20h] [bp-29Ch]@24
  float v116; // [sp+24h] [bp-298h]@2
  int v117; // [sp+28h] [bp-294h]@1
  void *v118; // [sp+2Ch] [bp-290h]@68
  void *v119; // [sp+30h] [bp-28Ch]@42
  int v120; // [sp+34h] [bp-288h]@42
  unsigned int v121; // [sp+38h] [bp-284h]@42
  unsigned __int64 v122; // [sp+3Ch] [bp-280h]@57
  float v123; // [sp+48h] [bp-274h]@22
  int v124; // [sp+50h] [bp-26Ch]@1
  float v125[2]; // [sp+54h] [bp-268h]@15
  double v126; // [sp+5Ch] [bp-260h]@22
  float v127; // [sp+68h] [bp-254h]@14
  unsigned __int64 v128; // [sp+6Ch] [bp-250h]@57
  void *v129; // [sp+74h] [bp-248h]@42
  unsigned int v130; // [sp+78h] [bp-244h]@42
  unsigned int v131; // [sp+7Ch] [bp-240h]@42
  float v132; // [sp+80h] [bp-23Ch]@36
  unsigned __int64 v133; // [sp+84h] [bp-238h]@19
  double v134; // [sp+8Ch] [bp-230h]@57
  unsigned __int64 v135; // [sp+94h] [bp-228h]@72
  unsigned __int64 v136; // [sp+9Ch] [bp-220h]@72
  unsigned __int64 v137; // [sp+A4h] [bp-218h]@72
  char DstBuf; // [sp+ACh] [bp-210h]@78
  int v139; // [sp+2B8h] [bp-4h]@42

  v2 = *(_DWORD *)(a1 + 16) + 48 * a2;
  v3 = *(_DWORD *)(v2 + 24);
  v117 = a1 + 16;
  v124 = v2;
  if ( v3 != 1 )
  {
    v116 = 0.0;
    v4 = 0;
    v5 = -1.0;
    v6 = -1.0;
    if ( v3 )
    {
      v7 = *(float **)(v2 + 20);
      do
      {
        v8 = *v7 - *(float *)v2;
        v110 = v8 * v8 + 0.0;
        if ( v110 > v6 )
        {
          v6 = v110;
          if ( &v116 != v7 )
            v116 = *v7;
        }
        ++v4;
        v7 += 2;
      }
      while ( v4 < v3 );
    }
    v9 = 0;
    v10 = v116;
    if ( v3 > 0 )
    {
      v11 = *(float **)(v2 + 20);
      do
      {
        v12 = *v11 - v10;
        v111 = v12 * v12 + 0.0;
        if ( v111 > v5 )
        {
          v5 = v111;
          if ( &v113 != v11 )
            v113 = *v11;
        }
        ++v9;
        v11 += 2;
      }
      while ( v9 < v3 );
    }
    v13 = 0.0;
    v14 = v10 + *(float *)v2;
    v127 = v14 * 0.5;
    v15 = *(float *)v2 + v113;
    v116 = 0.5 * v15;
    if ( v3 > 2 )
    {
      v16 = 0.0;
      v17 = 1.0;
      v18 = 0;
      v125[0] = 0.0;
      if ( v3 > 0 )
      {
        v19 = *(_DWORD *)(v2 + 20);
        do
        {
          v20 = *(_DWORD *)(v19 + 4);
          v114 = *(float *)v19 - *(float *)v2;
          v21 = (double)*(signed int *)(v19 + 4);
          if ( v20 < 0 )
            v21 = v21 + 4294967300.0;
          v22 = v21;
          v23 = 0;
          v24 = v125;
          v25 = v114;
          *(float *)&v133 = v22 * v114;
          do
          {
            v26 = *((float *)&v133 + v23++);
            v27 = v26;
            ++v24;
            *(v24 - 1) = v27 * v25 + *(v24 - 1);
          }
          while ( v23 < 1 );
          ++v18;
          v19 += 8;
        }
        while ( v18 < v3 );
      }
      v28 = *(_DWORD *)(v2 + 12);
      v126 = COERCE_DOUBLE(__PAIR__(v28 & 0x80000000, 0));
      v29 = 10;
      v30 = (double)__PAIR__(v28, *(_DWORD *)(v2 + 8));
      v125[0] = v125[0] / v30;
      v123 = 1.0;
      do
      {
        v31 = 0.0;
        v32 = 0;
        v33 = v123;
        do
        {
          v34 = v125[v32] * v33 + 0.0;
          *(&v115 + v32) = v34;
          if ( !v32 || v34 >= v31 )
            v31 = v34;
          ++v32;
        }
        while ( v32 < 1 );
        if ( 0.0 != v31 )
        {
          v35 = 1.0 / v31;
          v115 = v35 * v115;
        }
        --v29;
        v123 = v115;
      }
      while ( v29 );
      v36 = v115 * v115;
      if ( 0.0 != v36 )
      {
        v17 = 1.0;
        v37 = 1.0 / sqrt(v36);
        v123 = v37 * v115;
        v13 = 0.0;
        v16 = 0.0;
      }
      v115 = v16;
      v38 = 0;
      v113 = v16;
      v39 = v13;
      v40 = v13;
      if ( v3 > 0 )
      {
        v41 = *(_DWORD *)(v2 + 20);
        do
        {
          v114 = (double)*(unsigned int *)(v41 + 4);
          *(float *)&v133 = *(float *)v41 - *(float *)v2;
          v42 = *(float *)&v133 * v123;
          v43 = *(float *)v41 * v114;
          v44 = v114;
          if ( v42 >= v13 )
          {
            v45 = v43;
            v113 = v45 + v113;
            v40 = v40 + v44;
          }
          else
          {
            v132 = v43;
            v115 = v132 + v115;
            v39 = v39 + v44;
          }
          ++v38;
          v41 += 8;
        }
        while ( v38 < v3 );
        v46 = v40;
        v47 = v39;
        v48 = v46;
        if ( v47 > v13 )
        {
          v49 = v47;
          v50 = v13;
          v51 = v49;
          if ( v50 < v48 )
          {
            v52 = v17 / v51;
            v127 = v52 * v115;
            v53 = v17 / v48;
            v116 = v53 * v113;
          }
        }
      }
    }
    v119 = 0;
    v120 = 0;
    v121 = 0;
    v139 = 0;
    v129 = 0;
    v130 = 0;
    v131 = 0;
    LOBYTE(v139) = 1;
    sub_10049FB0((int)&v119, v3 >> 1);
    sub_10049FB0((int)&v129, *(_DWORD *)(v2 + 24) >> 1);
    v54 = v120;
    v115 = 1.0e10;
    v55 = v130;
    v56 = 0.0;
    v112 = 0;
    while ( 1 )
    {
      if ( v54 )
      {
        if ( v54 <= 0 )
        {
          v57 = (char *)v119 + 8 * v54;
          for ( i = (int)&v57[-8 * v54]; v57 != (char *)i; v57 += 8 )
          {
            if ( v57 )
              *((_DWORD *)v57 + 1) = 0;
          }
        }
        v54 = 0;
        v120 = 0;
      }
      if ( v55 )
      {
        if ( v55 <= 0 )
        {
          v59 = (char *)v129 + 8 * v55;
          for ( j = (int)&v59[-8 * v55]; v59 != (char *)j; v59 += 8 )
          {
            if ( v59 )
              *((_DWORD *)v59 + 1) = 0;
          }
        }
        v55 = 0;
        v130 = 0;
      }
      v123 = 0.0;
      v61 = 0.0;
      v125[0] = 0.0;
      v128 = 0i64;
      v122 = 0i64;
      v134 = v56;
      v126 = v56;
      v114 = 0.0;
      if ( *(_DWORD *)(v124 + 24) <= 0u )
        break;
      do
      {
        v62 = *(_DWORD *)(v124 + 20) + 8 * LODWORD(v61);
        v63 = *(_DWORD *)(v62 + 4);
        v64 = v127 - *(float *)v62;
        v65 = v64 * v64 + v56;
        v66 = v65;
        v67 = v116 - *(float *)v62;
        v68 = v67 * v67 + v56;
        if ( v68 <= v66 )
        {
          if ( v55 >= v131 )
          {
            sub_100943C0(v55 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C650, (int)&v129, 1, 8u, 0);
            v56 = 0.0;
            v55 = v130;
          }
          v73 = (char *)v129 + 8 * v55;
          if ( v73 )
          {
            *(float *)v73 = *(float *)v62;
            *((_DWORD *)v73 + 1) = *(_DWORD *)(v62 + 4);
          }
          v130 = ++v55;
          v113 = (double)v63;
          v74 = v122;
          LODWORD(v122) = v63 + v122;
          v75 = v113 * *(float *)v62;
          v122 = __PAIR__(HIDWORD(v122), v63) + v74;
          *(float *)&v118 = v75;
          v125[0] = v125[0] + *(float *)&v118;
          v76 = *(float *)v62 * *(float *)v62;
          v126 = v113 * v76 + v126;
        }
        else
        {
          if ( v54 >= v121 )
          {
            sub_100943C0(v54 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C650, (int)&v119, 1, 8u, 0);
            v56 = 0.0;
            v54 = v120;
          }
          v69 = (char *)v119 + 8 * v54;
          if ( v69 )
          {
            *(float *)v69 = *(float *)v62;
            *((_DWORD *)v69 + 1) = *(_DWORD *)(v62 + 4);
          }
          v120 = ++v54;
          v113 = (double)v63;
          v70 = v128;
          LODWORD(v128) = v63 + v128;
          v71 = v113 * *(float *)v62;
          v128 = __PAIR__(HIDWORD(v128), v63) + v70;
          v132 = v71;
          v123 = v123 + v132;
          v72 = *(float *)v62 * *(float *)v62;
          v134 = v113 * v72 + v134;
        }
        LODWORD(v61) = LODWORD(v114) + 1;
        v114 = v61;
      }
      while ( LODWORD(v61) < *(_DWORD *)(v124 + 24) );
      if ( !v128 || !v122 )
        break;
      v136 = v128 & 0x7FFFFFFFFFFFFFFFi64;
      v77 = v123 * v123;
      v135 = __PAIR__(HIDWORD(v128), 0) & 0x8000000000000000ui64;
      v137 = v122 & 0x7FFFFFFFFFFFFFFFi64;
      v114 = (double)v128;
      v133 = __PAIR__(HIDWORD(v122), 0) & 0x8000000000000000ui64;
      v78 = v114;
      v114 = v134 - v77 / v114;
      v79 = v125[0] * v125[0];
      v113 = (double)v122;
      v80 = v113;
      v113 = v126 - v79 / v113;
      v81 = 1.0 / v78;
      v123 = v123 * v81;
      v82 = 1.0 / v80;
      v125[0] = v125[0] * v82;
      v127 = v123;
      v116 = v125[0];
      v109 = v113 + v114;
      if ( v109 >= 0.0000099999997 && (v115 - v109) / v109 >= 0.000009999999747378752 )
      {
        v115 = v113 + v114;
        if ( (unsigned int)++v112 < 0x400 )
          continue;
      }
      v87 = v124;
      v88 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v124 + 32) = v88;
      *(_DWORD *)(v87 + 36) = *(_DWORD *)(a1 + 20) + 1;
      v89 = *(_DWORD *)(v117 + 4);
      v90 = *(_DWORD *)(a1 + 20) + 2;
      if ( v90 != v89 )
      {
        if ( v90 >= v89 )
        {
          if ( v90 > *(_DWORD *)(v117 + 8) )
          {
            LOBYTE(v118) = v90 == v89 + 1;
            sub_100943C0(v90, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004BFD0, v117, v90 == v89 + 1, 0x30u, 0);
          }
          v91 = *(_DWORD *)(v117 + 4);
          v92 = v90 - v91;
          v93 = (float *)(*(_DWORD *)v117 + 48 * v91);
          v94 = (int)&v93[12 * v92];
          if ( v93 != (float *)v94 )
          {
            v95 = (int)(v93 + 7);
            do
            {
              if ( v93 )
              {
                *v93 = 0.0;
                *(_DWORD *)(v95 - 20) = 0;
                *(_DWORD *)(v95 - 16) = 0;
                *(_DWORD *)(v95 - 8) = 0;
                *(_DWORD *)(v95 - 4) = 0;
                *(_DWORD *)v95 = 0;
                *(_DWORD *)(v95 + 4) = -1;
                *(_DWORD *)(v95 + 8) = -1;
                *(_DWORD *)(v95 + 12) = -1;
                *(_BYTE *)(v95 + 16) = 0;
              }
              v93 += 12;
              v95 += 48;
            }
            while ( v93 != (float *)v94 );
          }
        }
        else
        {
          sub_10040FD0(*(_DWORD *)v117 + 48 * v90, v89 - v90);
        }
        *(_DWORD *)(v117 + 4) = v90;
      }
      v96 = *(_DWORD *)v117 + 48 * v88;
      v97 = *(_DWORD *)v117 + 16 * (3 * v88 + 3);
      if ( (float *)v96 != &v127 )
        *(float *)v96 = v123;
      v98 = v114;
      *(_QWORD *)(v96 + 8) = v128;
      v99 = *(void **)(v96 + 20);
      *(_DWORD *)(v96 + 20) = v119;
      v100 = *(_DWORD *)(v96 + 24);
      v118 = v99;
      v119 = v99;
      *(_DWORD *)(v96 + 24) = v120;
      v120 = v100;
      v101 = *(_DWORD *)(v96 + 28);
      *(_DWORD *)(v96 + 28) = v121;
      *(float *)(v96 + 16) = v98;
      v121 = v101;
      if ( (float *)v97 != &v116 )
        *(float *)v97 = v125[0];
      v102 = v113;
      v103 = HIDWORD(v122);
      *(_DWORD *)(v97 + 8) = v122;
      v104 = v129;
      *(_DWORD *)(v97 + 12) = v103;
      v105 = *(_DWORD *)(v97 + 20);
      *(_DWORD *)(v97 + 20) = v104;
      v106 = v131;
      *(_DWORD *)(v97 + 24) = v55;
      LOBYTE(v139) = 0;
      *(_DWORD *)(v97 + 28) = v106;
      *(float *)(v97 + 16) = v102;
      if ( v105 )
      {
        if ( v105 & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v107 = _iob_func();
          fputs(&DstBuf, v107 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v105, 0, 0, 1, dword_100AE9F4);
        }
      }
      v139 = -1;
      v85 = v118;
      if ( *(float *)&v118 != 0.0 )
      {
        if ( (unsigned __int8)v118 & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v108 = _iob_func() + 2;
          fputs(&DstBuf, v108);
          goto LABEL_107;
        }
LABEL_109:
        off_100AD9F4(v85, 0, 0, 1, dword_100AE9F4);
        return;
      }
      return;
    }
    LOBYTE(v139) = 0;
    v83 = v129;
    *(_BYTE *)(v124 + 44) = 1;
    if ( v83 )
    {
      if ( (unsigned __int8)v83 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v84 = _iob_func();
        fputs(&DstBuf, v84 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v83, 0, 0, 1, dword_100AE9F4);
      }
    }
    v139 = -1;
    v85 = v119;
    if ( v119 )
    {
      if ( !((unsigned __int8)v119 & 7) )
        goto LABEL_109;
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v86 = _iob_func() + 2;
      fputs(&DstBuf, v86);
LABEL_107:
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
  }
}
// 1004BFD0: using guessed type int sub_1004BFD0();
// 1004C650: using guessed type int sub_1004C650();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 10047DD0: using guessed type float var_268[2];

//----- (10048910) --------------------------------------------------------
void __usercall sub_10048910(int a1@<esi>)
{
  unsigned int v1; // eax@1
  unsigned int v2; // eax@4
  int v3; // ebx@6
  int v4; // edx@6
  int v5; // ecx@6
  int v6; // eax@6
  int v7; // [sp+0h] [bp-18h]@4
  int v8; // [sp+4h] [bp-14h]@4
  int v9; // [sp+8h] [bp-10h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 >= 5 )
  {
    if ( v1 > 5 )
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v2 = *(_DWORD *)(a1 + 4);
      if ( v2 <= 5 )
        v2 = 5;
      sub_100943C0(v2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004BFD0, (int)&v7, 0, 0x30u, 0);
      sub_1004A960((int)&v7, a1);
      v3 = *(_DWORD *)a1;
      v4 = v8;
      *(_DWORD *)a1 = v7;
      v5 = *(_DWORD *)(a1 + 4);
      v6 = v9;
      *(_DWORD *)(a1 + 4) = v4;
      *(_DWORD *)(a1 + 8) = v6;
      v10 = -1;
      if ( v3 )
      {
        sub_10040FD0(v3, v5);
        if ( v3 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(5u, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004BFD0, a1, 0, 0x30u, 0);
  }
}
// 1004BFD0: using guessed type int sub_1004BFD0();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10048A20) --------------------------------------------------------
char __usercall sub_10048A20@<al>(int a1@<eax>, float *a2@<ecx>)
{
  unsigned int v2; // edx@1
  int v3; // esi@1

  v2 = 0;
  v3 = a1 - (_DWORD)a2;
  while ( *a2 <= (double)*(float *)((char *)a2 + v3) )
  {
    if ( *a2 == *(float *)((char *)a2 + v3) )
    {
      ++v2;
      ++a2;
      if ( v2 < 1 )
        continue;
    }
    return 0;
  }
  return 1;
}

//----- (10048A60) --------------------------------------------------------
void __stdcall sub_10048A60(int a1, int a2)
{
  int v2; // eax@1
  unsigned int v3; // esi@1
  unsigned int v4; // edi@2
  unsigned int v5; // ebx@3
  int v6; // ebp@3
  double v7; // st7@4
  unsigned int v8; // edi@7
  unsigned int v9; // ebx@8
  int v10; // ebp@8
  double v11; // st7@9
  int v12; // eax@12
  int v13; // eax@12
  float v14; // ST14_4@15
  unsigned int v15; // edi@15
  unsigned int v16; // esi@15
  float *v17; // edx@15
  char *v18; // ebp@15
  signed int v19; // ebx@15
  unsigned int v20; // ecx@16
  char *v21; // eax@18
  double v22; // st7@18
  double v23; // st6@19
  char *v24; // eax@21
  double v25; // st7@21
  double v26; // st6@22
  float v27; // ST28_4@22
  signed int v28; // ebx@25
  int v29; // ebp@25
  unsigned int v30; // esi@25
  unsigned int v31; // edi@26
  unsigned int v32; // edx@28
  char *v33; // eax@28
  char *v34; // ecx@28
  double v35; // st7@29
  float *v36; // edx@31
  float *v37; // ecx@31
  int v38; // eax@31
  double v39; // st7@32
  unsigned int v40; // ebp@34
  float v41; // ST14_4@34
  double v42; // st7@34
  signed int v43; // esi@34
  double v44; // st6@35
  unsigned int v45; // edx@35
  double v46; // st5@36
  unsigned int v47; // eax@36
  char *v48; // ecx@36
  double v49; // st4@37
  double v50; // st4@37
  float v51; // ST44_4@43
  unsigned int v52; // ebx@46
  int v53; // edi@46
  float *v54; // eax@47
  int v55; // eax@48
  int v56; // eax@49
  float v57; // ST44_4@53
  int v58; // eax@53
  float v59; // ST44_4@53
  int v60; // eax@53
  float v61; // ebx@54
  float v62; // eax@57
  float i; // ecx@57
  char *v64; // eax@64
  int j; // ecx@64
  int v66; // ecx@71
  unsigned int v67; // edi@71
  int v68; // esi@71
  double v69; // ST44_8@71
  int v70; // ebp@74
  float v71; // ST28_4@76
  int v72; // eax@76
  double v73; // st7@76
  char *v74; // ebp@79
  float v75; // ST28_4@81
  int v76; // eax@81
  float v77; // ST2C_4@85
  double v78; // st7@85
  float v79; // ST34_4@85
  float v80; // ST2C_4@85
  float v81; // ST2C_4@85
  void *v82; // eax@89
  FILE *v83; // eax@91
  FILE *v84; // eax@96
  int v85; // esi@98
  int v86; // ebx@98
  unsigned int v87; // eax@98
  unsigned int v88; // ebp@98
  int v89; // edi@98
  int v90; // ebx@100
  int v91; // eax@101
  FILE *v92; // eax@103
  int v93; // esi@112
  int v94; // edi@112
  float v95; // eax@112
  float v96; // ecx@112
  float v97; // ebx@112
  float v98; // edx@112
  float v99; // eax@112
  void *v100; // edx@112
  float v101; // ecx@112
  int v102; // eax@112
  float v103; // edx@112
  FILE *v104; // eax@114
  FILE *v105; // eax@119
  float v106; // [sp-10h] [bp-638h]@97
  float v107; // [sp+0h] [bp-628h]@97
  float v108; // [sp+14h] [bp-614h]@47
  float v109; // [sp+14h] [bp-614h]@85
  unsigned int v110; // [sp+18h] [bp-610h]@13
  signed int v111; // [sp+18h] [bp-610h]@25
  unsigned int v112; // [sp+18h] [bp-610h]@69
  float v113; // [sp+18h] [bp-610h]@85
  int v114; // [sp+1Ch] [bp-60Ch]@1
  int v115; // [sp+20h] [bp-608h]@14
  int v116; // [sp+20h] [bp-608h]@70
  int v117; // [sp+24h] [bp-604h]@54
  int k; // [sp+24h] [bp-604h]@100
  double v119; // [sp+28h] [bp-600h]@2
  double v120; // [sp+28h] [bp-600h]@7
  double v121; // [sp+28h] [bp-600h]@69
  unsigned int v122; // [sp+30h] [bp-5F8h]@14
  float v123; // [sp+30h] [bp-5F8h]@85
  double v124; // [sp+38h] [bp-5F0h]@45
  unsigned __int64 v125; // [sp+38h] [bp-5F0h]@69
  double v126; // [sp+40h] [bp-5E8h]@45
  unsigned __int64 v127; // [sp+40h] [bp-5E8h]@69
  float v128; // [sp+4Ch] [bp-5DCh]@37
  float v129; // [sp+50h] [bp-5D8h]@37
  float v130; // [sp+54h] [bp-5D4h]@37
  void *v131; // [sp+58h] [bp-5D0h]@37
  float v132; // [sp+5Ch] [bp-5CCh]@37
  float v133; // [sp+60h] [bp-5C8h]@37
  int v134; // [sp+64h] [bp-5C4h]@1
  int v135; // [sp+68h] [bp-5C0h]@34
  int v136; // [sp+6Ch] [bp-5BCh]@34
  int v137; // [sp+70h] [bp-5B8h]@34
  int v138; // [sp+74h] [bp-5B4h]@34
  int v139; // [sp+78h] [bp-5B0h]@34
  int v140; // [sp+7Ch] [bp-5ACh]@34
  int v141; // [sp+80h] [bp-5A8h]@34
  int v142; // [sp+84h] [bp-5A4h]@34
  int v143; // [sp+88h] [bp-5A0h]@34
  int v144; // [sp+8Ch] [bp-59Ch]@34
  int v145; // [sp+90h] [bp-598h]@34
  int v146; // [sp+94h] [bp-594h]@34
  int v147; // [sp+98h] [bp-590h]@34
  int v148; // [sp+9Ch] [bp-58Ch]@34
  int v149; // [sp+A0h] [bp-588h]@34
  int v150; // [sp+A4h] [bp-584h]@34
  int v151; // [sp+A8h] [bp-580h]@12
  int v152; // [sp+ACh] [bp-57Ch]@44
  int v153; // [sp+B0h] [bp-578h]@44
  int v154; // [sp+B4h] [bp-574h]@44
  int v155; // [sp+B8h] [bp-570h]@44
  int v156; // [sp+BCh] [bp-56Ch]@44
  int v157; // [sp+C0h] [bp-568h]@44
  int v158; // [sp+C4h] [bp-564h]@44
  int v159; // [sp+C8h] [bp-560h]@44
  int v160; // [sp+CCh] [bp-55Ch]@44
  int v161; // [sp+D0h] [bp-558h]@44
  int v162; // [sp+D4h] [bp-554h]@44
  int v163; // [sp+D8h] [bp-550h]@44
  int v164; // [sp+DCh] [bp-54Ch]@44
  int v165; // [sp+E0h] [bp-548h]@44
  int v166; // [sp+E4h] [bp-544h]@44
  float v167; // [sp+ECh] [bp-53Ch]@54
  int v168; // [sp+F0h] [bp-538h]@2
  int v169; // [sp+F4h] [bp-534h]@2
  int v170; // [sp+F8h] [bp-530h]@2
  int v171; // [sp+FCh] [bp-52Ch]@2
  int v172; // [sp+100h] [bp-528h]@2
  int v173; // [sp+104h] [bp-524h]@2
  int v174; // [sp+108h] [bp-520h]@2
  int v175; // [sp+10Ch] [bp-51Ch]@2
  int v176; // [sp+110h] [bp-518h]@2
  int v177; // [sp+114h] [bp-514h]@2
  int v178; // [sp+118h] [bp-510h]@2
  int v179; // [sp+11Ch] [bp-50Ch]@2
  int v180; // [sp+120h] [bp-508h]@2
  int v181; // [sp+124h] [bp-504h]@2
  int v182; // [sp+128h] [bp-500h]@2
  int v183; // [sp+12Ch] [bp-4FCh]@2
  double v184; // [sp+130h] [bp-4F8h]@19
  float v185; // [sp+138h] [bp-4F0h]@10
  int v186; // [sp+13Ch] [bp-4ECh]@45
  int v187; // [sp+140h] [bp-4E8h]@45
  int v188; // [sp+144h] [bp-4E4h]@45
  int v189; // [sp+148h] [bp-4E0h]@45
  int v190; // [sp+14Ch] [bp-4DCh]@45
  int v191; // [sp+150h] [bp-4D8h]@45
  int v192; // [sp+154h] [bp-4D4h]@45
  int v193; // [sp+158h] [bp-4D0h]@45
  int v194; // [sp+15Ch] [bp-4CCh]@45
  int v195; // [sp+160h] [bp-4C8h]@45
  int v196; // [sp+164h] [bp-4C4h]@45
  int v197; // [sp+168h] [bp-4C0h]@45
  int v198; // [sp+16Ch] [bp-4BCh]@45
  int v199; // [sp+170h] [bp-4B8h]@45
  int v200; // [sp+174h] [bp-4B4h]@45
  unsigned __int64 v201; // [sp+178h] [bp-4B0h]@85
  unsigned __int64 v202; // [sp+180h] [bp-4A8h]@85
  unsigned __int64 v203; // [sp+188h] [bp-4A0h]@85
  unsigned __int64 v204; // [sp+190h] [bp-498h]@85
  int v205; // [sp+198h] [bp-490h]@12
  int v206; // [sp+19Ch] [bp-48Ch]@85
  int v207; // [sp+1A0h] [bp-488h]@85
  int v208; // [sp+1A4h] [bp-484h]@85
  int v209; // [sp+1A8h] [bp-480h]@85
  int v210; // [sp+1ACh] [bp-47Ch]@85
  int v211; // [sp+1B0h] [bp-478h]@85
  int v212; // [sp+1B4h] [bp-474h]@85
  int v213; // [sp+1B8h] [bp-470h]@85
  int v214; // [sp+1BCh] [bp-46Ch]@85
  int v215; // [sp+1C0h] [bp-468h]@85
  int v216; // [sp+1C4h] [bp-464h]@85
  int v217; // [sp+1C8h] [bp-460h]@85
  int v218; // [sp+1CCh] [bp-45Ch]@85
  int v219; // [sp+1D0h] [bp-458h]@85
  int v220; // [sp+1D4h] [bp-454h]@85
  char v221; // [sp+1D8h] [bp-450h]@47
  char v222[4]; // [sp+214h] [bp-414h]@31
  char DstBuf[4]; // [sp+218h] [bp-410h]@13
  char v224[120]; // [sp+21Ch] [bp-40Ch]@15
  char v225[904]; // [sp+294h] [bp-394h]@28
  int v226; // [sp+624h] [bp-4h]@54

  v2 = *(_DWORD *)(a1 + 16) + 104 * a2;
  v3 = *(_DWORD *)(v2 + 80);
  v134 = a1 + 16;
  v114 = v2;
  if ( v3 != 1 )
  {
    v4 = 0;
    v119 = -1.0;
    v168 = 0;
    v169 = 0;
    v170 = 0;
    v171 = 0;
    v172 = 0;
    v173 = 0;
    v174 = 0;
    v175 = 0;
    v176 = 0;
    v177 = 0;
    v178 = 0;
    v179 = 0;
    v180 = 0;
    v181 = 0;
    v182 = 0;
    v183 = 0;
    if ( v3 )
    {
      v5 = *(_DWORD *)(v2 + 80);
      v6 = *(_DWORD *)(v2 + 76);
      do
      {
        v7 = sub_1003DF90(v114, v6);
        if ( v119 < v7 )
        {
          v119 = v7;
          sub_10038C30((int)&v168, v6);
        }
        ++v4;
        v6 += 68;
      }
      while ( v4 < v5 );
    }
    v8 = 0;
    v120 = -1.0;
    if ( v3 )
    {
      v9 = *(_DWORD *)(v114 + 80);
      v10 = *(_DWORD *)(v114 + 76);
      do
      {
        v11 = sub_1003DF90((int)&v168, v10);
        if ( v120 < v11 )
        {
          v120 = v11;
          sub_10038C30((int)&v185, v10);
        }
        ++v8;
        v10 += 68;
      }
      while ( v8 < v9 );
    }
    v12 = sub_1003E2C0((int)&v168, (int)&v151, v114);
    sub_1003CDE0((int)&v205, v12, 0.5);
    v13 = sub_1003E2C0((int)&v185, (int)&v151, v114);
    sub_1003CDE0((int)&v168, v13, 0.5);
    if ( v3 > 2 )
    {
      memset(DstBuf, 0, 0x400u);
      v110 = 0;
      if ( v3 )
      {
        v122 = *(_DWORD *)(v114 + 80);
        v115 = *(_DWORD *)(v114 + 76);
        do
        {
          sub_1003DE90(v115, (int)&v151, v114);
          v14 = (double)*(unsigned int *)(v115 + 64);
          sub_1003CDE0((int)&v185, (int)&v151, v14);
          v15 = 0;
          v16 = 0;
          v17 = (float *)&v151;
          v18 = v224;
          v19 = 16;
          do
          {
            v20 = v15;
            if ( v15 < 0x10 )
            {
              if ( v19 >= 4 )
              {
                v21 = v18;
                v22 = *v17;
                do
                {
                  v23 = *(&v185 + v20);
                  v20 += 4;
                  v21 += 16;
                  *((float *)v21 - 5) = v23 * *v17 + *((float *)v21 - 5);
                  *((float *)v21 - 4) = *((float *)&v183 + v20) * *v17 + *((float *)v21 - 4);
                  *((float *)v21 - 3) = *((float *)&v184 + v20) * *v17 + *((float *)v21 - 3);
                  *((float *)v21 - 2) = *((float *)&v184 + v20 + 1) * v22 + *((float *)v21 - 2);
                }
                while ( v20 < 0xD );
              }
              if ( v20 < 0x10 )
              {
                v24 = &DstBuf[4 * (v16 + v20)];
                v25 = *v17;
                do
                {
                  v26 = *(&v185 + v20++);
                  v27 = v26;
                  v24 += 4;
                  *((float *)v24 - 1) = v27 * v25 + *((float *)v24 - 1);
                }
                while ( v20 < 0x10 );
              }
            }
            v16 += 16;
            ++v15;
            --v19;
            v18 += 68;
            ++v17;
          }
          while ( v16 < 0x100 );
          v115 += 68;
          ++v110;
        }
        while ( v110 < v122 );
      }
      v28 = 15;
      v29 = 0;
      v30 = 1;
      v111 = 15;
      do
      {
        v31 = v30;
        if ( v30 < 0x10 )
        {
          if ( v28 >= 4 )
          {
            v32 = ((12 - v30) >> 2) + 1;
            v33 = &v224[4 * (v30 + v29)];
            v34 = &v225[4 * (v30 + v29)];
            v31 = v30 + 4 * v32;
            do
            {
              v35 = *((float *)v33 - 1);
              v33 += 16;
              *((float *)v34 - 16) = v35;
              v34 += 256;
              --v32;
              *((float *)v34 - 64) = *((float *)v33 - 4);
              *((float *)v34 - 48) = *((float *)v33 - 3);
              *((float *)v34 - 32) = *((float *)v33 - 2);
            }
            while ( v32 );
          }
          if ( v31 < 0x10 )
          {
            v36 = (float *)&v222[4 * (v30 + 16 * v31)];
            v37 = (float *)&DstBuf[4 * (v31 + v29)];
            v38 = 16 - v31;
            do
            {
              v39 = *v37;
              ++v37;
              *v36 = v39;
              v36 += 16;
              --v38;
            }
            while ( v38 );
          }
        }
        --v28;
        ++v30;
        v29 += 16;
        --v111;
      }
      while ( v111 );
      v40 = 0;
      v41 = (double)*(unsigned __int64 *)(v114 + 64);
      sub_1004AFC0((int)DstBuf, v41);
      v42 = 0.0;
      v135 = 1065353216;
      v136 = 1065353216;
      v137 = 1065353216;
      v138 = 1065353216;
      v139 = 1065353216;
      v140 = 1065353216;
      v141 = 1065353216;
      v142 = 1065353216;
      v143 = 1065353216;
      v144 = 1065353216;
      v145 = 1065353216;
      v146 = 1065353216;
      v147 = 1065353216;
      v148 = 1065353216;
      v149 = 1065353216;
      v150 = 1065353216;
      v43 = 10;
      do
      {
        v44 = v42;
        v45 = 0;
        do
        {
          v46 = v42;
          v47 = 0;
          v48 = &v224[64 * v45];
          do
          {
            v49 = *((float *)&v135 + v47);
            v47 += 8;
            v50 = v49 * *((float *)v48 - 1);
            v48 += 32;
            v46 = v46
                + v50
                + *(&v128 + v47) * *((float *)v48 - 8)
                + *(&v129 + v47) * *((float *)v48 - 7)
                + *(&v130 + v47) * *((float *)v48 - 6)
                + *((float *)&v131 + v47) * *((float *)v48 - 5)
                + *(&v132 + v47) * *((float *)v48 - 4)
                + *(&v133 + v47) * *((float *)v48 - 3)
                + *((float *)&v134 + v47) * *((float *)v48 - 2);
          }
          while ( v47 < 0x10 );
          *((float *)&v151 + v45) = v46;
          if ( !v45 || v46 >= v44 )
            v44 = v46;
          ++v45;
        }
        while ( v45 < 0x10 );
        if ( v42 != v44 )
        {
          v51 = 1.0 / v44;
          sub_1003CD80((int)&v151, v51);
          v42 = 0.0;
        }
        --v43;
        v135 = v151;
        v136 = v152;
        v137 = v153;
        v138 = v154;
        v139 = v155;
        v140 = v156;
        v141 = v157;
        v142 = v158;
        v143 = v159;
        v144 = v160;
        v145 = v161;
        v146 = v162;
        v147 = v163;
        v148 = v164;
        v149 = v165;
        v150 = v166;
      }
      while ( v43 );
      sub_1003E090((float *)&v135);
      v3 = *(_DWORD *)(v114 + 80);
      v126 = 0.0;
      v124 = 0.0;
      *(float *)&v151 = 0.0;
      v152 = 0;
      v153 = 0;
      v154 = 0;
      v155 = 0;
      v156 = 0;
      v157 = 0;
      v158 = 0;
      v159 = 0;
      v160 = 0;
      v161 = 0;
      v162 = 0;
      v163 = 0;
      v164 = 0;
      v165 = 0;
      v166 = 0;
      v185 = 0.0;
      v186 = 0;
      v187 = 0;
      v188 = 0;
      v189 = 0;
      v190 = 0;
      v191 = 0;
      v192 = 0;
      v193 = 0;
      v194 = 0;
      v195 = 0;
      v196 = 0;
      v197 = 0;
      v198 = 0;
      v199 = 0;
      v200 = 0;
      if ( v3 > 0 )
      {
        v52 = *(_DWORD *)(v114 + 80);
        v53 = *(_DWORD *)(v114 + 76);
        do
        {
          v108 = (double)*(unsigned int *)(v53 + 64);
          v54 = (float *)sub_1003DE90(v53, (int)&v221, v114);
          if ( sub_1003DE10((float *)&v135, v54) >= 0.0 )
          {
            v56 = sub_1003CDE0((int)&v221, v53, v108);
            sub_1003CD10((int)&v185, v56);
            v124 = v108 + v124;
          }
          else
          {
            v55 = sub_1003CDE0((int)&v221, v53, v108);
            sub_1003CD10((int)&v151, v55);
            v126 = v108 + v126;
          }
          ++v40;
          v53 += 68;
        }
        while ( v40 < v52 );
        if ( v126 > 0.0 && v124 > 0.0 )
        {
          v57 = 1.0 / v126;
          v58 = sub_1003CDE0((int)&v221, (int)&v151, v57);
          sub_10038C30((int)&v205, v58);
          v59 = 1.0 / v124;
          v60 = sub_1003CDE0((int)&v221, (int)&v185, v59);
          sub_10038C30((int)&v168, v60);
        }
      }
    }
    v128 = 0.0;
    v129 = 0.0;
    v130 = 0.0;
    v226 = 0;
    v131 = 0;
    v132 = 0.0;
    v133 = 0.0;
    LOBYTE(v226) = 1;
    sub_1003A580((int)&v128, v3 >> 1);
    sub_1003A580((int)&v131, *(_DWORD *)(v114 + 80) >> 1);
    v61 = v132;
    v167 = 1.0e10;
    v117 = 0;
    while ( 1 )
    {
      if ( v129 != 0.0 )
      {
        if ( v129 == 0.0 )
        {
          v62 = v128;
          for ( i = v128; LODWORD(v62) != LODWORD(i); LODWORD(v62) += 68 )
          {
            if ( v62 != 0.0 )
              *(_DWORD *)(LODWORD(v62) + 64) = 0;
          }
        }
        v129 = 0.0;
      }
      if ( v61 != 0.0 )
      {
        if ( LODWORD(v61) <= 0 )
        {
          v64 = (char *)v131 + 68 * LODWORD(v61);
          for ( j = (int)&v64[-68 * LODWORD(v61)]; v64 != (char *)j; v64 += 68 )
          {
            if ( v64 )
              *((_DWORD *)v64 + 16) = 0;
          }
        }
        v61 = 0.0;
        v132 = 0.0;
      }
      memset(&v135, 0, 0x40u);
      memset(&v151, 0, 0x40u);
      v184 = 0.0;
      v121 = 0.0;
      v127 = 0i64;
      v125 = 0i64;
      v112 = 0;
      if ( *(_DWORD *)(v114 + 80) <= 0u )
        break;
      v116 = 0;
      do
      {
        v66 = *(_DWORD *)(v114 + 76);
        v67 = *(_DWORD *)(v116 + v66 + 64);
        v68 = v66 + v116;
        v69 = sub_1003DF90(v66 + v116, (int)&v205);
        if ( sub_1003DF90(v68, (int)&v168) <= v69 )
        {
          if ( LODWORD(v61) >= LODWORD(v133) )
          {
            sub_100943C0(LODWORD(v61) + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003DD80, (int)&v131, 1, 0x44u, 0);
            v61 = v132;
          }
          v74 = (char *)v131 + 68 * LODWORD(v61);
          if ( v74 )
          {
            sub_1003DDC0((int)v131 + 68 * LODWORD(v61), v68);
            *((_DWORD *)v74 + 16) = *(_DWORD *)(v68 + 64);
          }
          ++LODWORD(v61);
          v132 = v61;
          v75 = (double)v67;
          v76 = sub_1003CDE0((int)&v221, v68, v75);
          sub_1003CD10((int)&v151, v76);
          v125 += v67;
          v121 = sub_1003DE10((float *)v68, (float *)v68) * v75 + v121;
        }
        else
        {
          if ( LODWORD(v129) >= LODWORD(v130) )
            sub_100943C0(
              LODWORD(v129) + 1,
              (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003DD80,
              (int)&v128,
              1,
              0x44u,
              0);
          v70 = LODWORD(v128) + 68 * LODWORD(v129);
          if ( v70 )
          {
            sub_1003DDC0(LODWORD(v128) + 68 * LODWORD(v129), v68);
            *(_DWORD *)(v70 + 64) = *(_DWORD *)(v68 + 64);
          }
          ++LODWORD(v129);
          v71 = (double)v67;
          v72 = sub_1003CDE0((int)&v221, v68, v71);
          sub_1003CD10((int)&v135, v72);
          v127 += v67;
          v73 = sub_1003DE10((float *)v68, (float *)v68);
          v184 = v73 * v71 + v184;
        }
        v116 += 68;
        ++v112;
      }
      while ( v112 < *(_DWORD *)(v114 + 80) );
      if ( !v127 || !v125 )
        break;
      v201 = v127 & 0x7FFFFFFFFFFFFFFFi64;
      v204 = v127 & 0x8000000000000000ui64;
      v77 = (double)v127;
      v78 = sub_1003DE10((float *)&v135, (float *)&v135);
      v202 = v125 & 0x7FFFFFFFFFFFFFFFi64;
      v203 = __PAIR__(HIDWORD(v125), 0) & 0x8000000000000000ui64;
      v109 = v184 - v78 / v77;
      v79 = (double)v125;
      v123 = v121 - sub_1003DE10((float *)&v151, (float *)&v151) / v79;
      v80 = 1.0 / v77;
      sub_1003CD80((int)&v135, v80);
      v81 = 1.0 / v79;
      sub_1003CD80((int)&v151, v81);
      v205 = v135;
      v206 = v136;
      v207 = v137;
      v208 = v138;
      v209 = v139;
      v210 = v140;
      v211 = v141;
      v212 = v142;
      v213 = v143;
      v214 = v144;
      v215 = v145;
      v216 = v146;
      v217 = v147;
      v220 = v150;
      v113 = v123 + v109;
      v218 = v148;
      v170 = v153;
      v219 = v149;
      v168 = v151;
      v173 = v156;
      v169 = v152;
      v171 = v154;
      v176 = v159;
      v172 = v155;
      v174 = v157;
      v179 = v162;
      v175 = v158;
      v177 = v160;
      v182 = v165;
      v178 = v161;
      v180 = v163;
      v181 = v164;
      v183 = v166;
      if ( v113 >= 0.0000099999997 && (v167 - v113) / v113 >= 0.000009999999747378752 )
      {
        v167 = v123 + v109;
        if ( (unsigned int)++v117 < 0x400 )
          continue;
      }
      v85 = *(_DWORD *)(a1 + 20);
      v86 = v134;
      *(_DWORD *)(v114 + 88) = v85;
      *(_DWORD *)(v114 + 92) = *(_DWORD *)(a1 + 20) + 1;
      v87 = *(_DWORD *)(v86 + 4);
      v88 = *(_DWORD *)(a1 + 20) + 2;
      v89 = v85 + 1;
      if ( v88 != v87 )
      {
        if ( v88 >= v87 )
        {
          if ( v88 > *(_DWORD *)(v86 + 8) )
            sub_100943C0(v88, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C430, v86, v88 == v87 + 1, 0x68u, 0);
          sub_1004D040(v88 - *(_DWORD *)(v86 + 4), (char *)(*(_DWORD *)v86 + 104 * *(_DWORD *)(v86 + 4)));
        }
        else
        {
          v90 = *(_DWORD *)v134 + 104 * v88;
          for ( k = v90 + 104 * (v87 - v88); v90 != k; v90 += 104 )
          {
            v91 = *(_DWORD *)(v90 + 76);
            if ( v91 )
            {
              if ( v91 & 7 )
              {
                sprintf_s(
                  DstBuf,
                  0x200u,
                  "%s(%u): Assertion failed: \"%s\"\n",
                  "crn_mem.cpp",
                  216,
                  "crnlib_free: bad ptr");
                OutputDebugStringA(DstBuf);
                v92 = _iob_func();
                fputs(DstBuf, v92 + 2);
                if ( IsDebuggerPresent() )
                  DebugBreak();
              }
              else
              {
                off_100AD9F4(v91, 0, 0, 1, dword_100AE9F4);
              }
            }
          }
        }
        *(_DWORD *)(v134 + 4) = v88;
      }
      v93 = *(_DWORD *)v134 + 104 * v85;
      v94 = *(_DWORD *)v134 + 104 * v89;
      sub_10038C30(v93, (int)&v205);
      v95 = v128;
      *(_DWORD *)(v93 + 64) = v127;
      v96 = v129;
      *(_DWORD *)(v93 + 68) = HIDWORD(v127);
      v97 = *(float *)(v93 + 76);
      v98 = v130;
      *(float *)(v93 + 76) = v95;
      v99 = *(float *)(v93 + 80);
      *(float *)(v93 + 80) = v96;
      v129 = v99;
      v130 = *(float *)(v93 + 84);
      *(float *)(v93 + 84) = v98;
      *(float *)(v93 + 72) = v109;
      v128 = v97;
      sub_10038C30(v94, (int)&v168);
      v100 = v131;
      *(_DWORD *)(v94 + 68) = HIDWORD(v125);
      v101 = v132;
      *(_DWORD *)(v94 + 64) = v125;
      v102 = *(_DWORD *)(v94 + 76);
      *(_DWORD *)(v94 + 76) = v100;
      v103 = v133;
      *(float *)(v94 + 80) = v101;
      *(float *)(v94 + 84) = v103;
      *(float *)(v94 + 72) = v123;
      LOBYTE(v226) = 0;
      if ( v102 )
      {
        if ( v102 & 7 )
        {
          sprintf_s(DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(DstBuf);
          v104 = _iob_func();
          fputs(DstBuf, v104 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v102, 0, 0, 1, dword_100AE9F4);
        }
      }
      v226 = -1;
      if ( v97 != 0.0 )
      {
        if ( LOBYTE(v97) & 7 )
        {
          sprintf_s(DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(DstBuf);
          v105 = _iob_func();
          fputs(DstBuf, v105 + 2);
          goto LABEL_120;
        }
        v107 = *(float *)&dword_100AE9F4;
        v106 = v97;
LABEL_123:
        off_100AD9F4(LODWORD(v106), 0, 0, 1, LODWORD(v107));
        return;
      }
      return;
    }
    LOBYTE(v226) = 0;
    v82 = v131;
    *(_BYTE *)(v114 + 100) = 1;
    if ( v82 )
    {
      if ( (unsigned __int8)v82 & 7 )
      {
        sprintf_s(DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(DstBuf);
        v83 = _iob_func();
        fputs(DstBuf, v83 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v82, 0, 0, 1, dword_100AE9F4);
      }
    }
    v226 = -1;
    if ( v128 != 0.0 )
    {
      if ( !(LOBYTE(v128) & 7) )
      {
        v107 = *(float *)&dword_100AE9F4;
        v106 = v128;
        goto LABEL_123;
      }
      sprintf_s(DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(DstBuf);
      v84 = _iob_func();
      fputs(DstBuf, v84 + 2);
LABEL_120:
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
  }
}
// 1004C430: using guessed type int sub_1004C430();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 10048A60: using guessed type char DstBuf[4];
// 10048A60: using guessed type char var_40C[120];
// 10048A60: using guessed type char var_394[904];
// 10048A60: using guessed type char var_414[4];

//----- (10049CF0) --------------------------------------------------------
void __userpurge sub_10049CF0(int a1@<esi>, unsigned int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // ecx@1
  int v4; // ebx@6
  int v5; // ecx@6
  int v6; // edx@6
  int v7; // eax@6
  int v8; // [sp+0h] [bp-18h]@4
  int v9; // [sp+4h] [bp-14h]@4
  int v10; // [sp+8h] [bp-10h]@4
  int v11; // [sp+14h] [bp-4h]@4

  v2 = a2;
  v3 = *(_DWORD *)(a1 + 8);
  if ( a2 <= v3 )
  {
    if ( a2 < v3 )
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      if ( *(_DWORD *)(a1 + 4) > a2 )
        v2 = *(_DWORD *)(a1 + 4);
      sub_100943C0(v2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C430, (int)&v8, 0, 0x68u, 0);
      sub_1004ABA0((int)&v8, a1);
      v4 = *(_DWORD *)a1;
      v5 = v9;
      v6 = v10;
      *(_DWORD *)a1 = v8;
      v7 = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a1 + 4) = v5;
      *(_DWORD *)(a1 + 8) = v6;
      v11 = -1;
      if ( v4 )
      {
        sub_1004CF40(v7, v4);
        if ( v4 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C430, a1, 0, 0x68u, 0);
  }
}
// 1004C430: using guessed type int sub_1004C430();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10049E00) --------------------------------------------------------
char __userpurge sub_10049E00@<al>(int a1@<ebx>, int a2)
{
  unsigned int v2; // eax@1
  int v3; // edi@3

  v2 = *(_DWORD *)(a1 + 4);
  if ( v2 >= *(_DWORD *)(a1 + 8) )
    LOBYTE(v2) = sub_100943C0(v2 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C430, a1, 1, 0x68u, 0);
  v3 = *(_DWORD *)a1 + 104 * *(_DWORD *)(a1 + 4);
  if ( v3 )
  {
    sub_1003DDC0(v3, a2);
    *(_DWORD *)(v3 + 64) = *(_DWORD *)(a2 + 64);
    *(_DWORD *)(v3 + 68) = *(_DWORD *)(a2 + 68);
    *(float *)(v3 + 72) = *(float *)(a2 + 72);
    sub_1004CDB0(a2 + 76, v3 + 76);
    *(_DWORD *)(v3 + 88) = *(_DWORD *)(a2 + 88);
    v2 = *(_DWORD *)(a2 + 92);
    *(_DWORD *)(v3 + 92) = v2;
    *(_DWORD *)(v3 + 96) = *(_DWORD *)(a2 + 96);
    *(_BYTE *)(v3 + 100) = *(_BYTE *)(a2 + 100);
  }
  ++*(_DWORD *)(a1 + 4);
  return v2;
}
// 1004C430: using guessed type int sub_1004C430();

//----- (10049EA0) --------------------------------------------------------
void __thiscall sub_10049EA0(int this, unsigned int a2)
{
  unsigned int v2; // eax@1
  int v3; // edi@1
  unsigned int v4; // ecx@1
  int v5; // eax@6
  int v6; // ecx@6
  int v7; // edx@6
  int v8; // [sp+4h] [bp-18h]@4
  int v9; // [sp+8h] [bp-14h]@4
  int v10; // [sp+Ch] [bp-10h]@4
  int v11; // [sp+18h] [bp-4h]@4

  v2 = a2;
  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ( a2 <= v4 )
  {
    if ( a2 < v4 )
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      if ( *(_DWORD *)(v3 + 4) > a2 )
        v2 = *(_DWORD *)(v3 + 4);
      sub_100943C0(v2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C600, (int)&v8, 0, 0x10u, 0);
      sub_1004ADF0((int)&v8, v3);
      v5 = *(_DWORD *)v3;
      v6 = v9;
      *(_DWORD *)v3 = v8;
      v7 = v10;
      *(_DWORD *)(v3 + 4) = v6;
      *(_DWORD *)(v3 + 8) = v7;
      v11 = -1;
      if ( v5 )
      {
        if ( v5 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C600, v3, 0, 0x10u, 0);
  }
}
// 1004C600: using guessed type int sub_1004C600();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10049FB0) --------------------------------------------------------
void __thiscall sub_10049FB0(int this, unsigned int a2)
{
  unsigned int v2; // eax@1
  int v3; // edi@1
  unsigned int v4; // ecx@1
  int v5; // eax@6
  int v6; // ecx@6
  int v7; // edx@6
  int v8; // [sp+4h] [bp-18h]@4
  int v9; // [sp+8h] [bp-14h]@4
  int v10; // [sp+Ch] [bp-10h]@4
  int v11; // [sp+18h] [bp-4h]@4

  v2 = a2;
  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ( a2 <= v4 )
  {
    if ( a2 < v4 )
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      if ( *(_DWORD *)(v3 + 4) > a2 )
        v2 = *(_DWORD *)(v3 + 4);
      sub_100943C0(v2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C650, (int)&v8, 0, 8u, 0);
      sub_1004AEE0((int)&v8, v3);
      v5 = *(_DWORD *)v3;
      v6 = v9;
      *(_DWORD *)v3 = v8;
      v7 = v10;
      *(_DWORD *)(v3 + 4) = v6;
      *(_DWORD *)(v3 + 8) = v7;
      v11 = -1;
      if ( v5 )
      {
        if ( v5 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      }
    }
  }
  else
  {
    sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C650, v3, 0, 8u, 0);
  }
}
// 1004C650: using guessed type int sub_1004C650();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1004A2C0) --------------------------------------------------------
int *__userpurge sub_1004A2C0@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<esi>, _DWORD *a4, _DWORD *a5)
{
  int v5; // ecx@1
  int v6; // edi@1
  _DWORD *v7; // eax@1
  int *result; // eax@3
  int v9; // edx@5
  int v10; // eax@6
  _DWORD *v11; // ecx@7
  int j; // eax@7
  int i; // eax@10
  int v14; // [sp+0h] [bp-4h]@1

  v14 = a2;
  v5 = (int)a4;
  v6 = a1;
  v7 = *(_DWORD **)(a1 + 4);
  if ( a4 != (_DWORD *)*v7 || a5 != v7 )
  {
    for ( ; a4 != a5; v5 = (int)a4 )
    {
      v9 = v5;
      if ( !*(_BYTE *)(v5 + 25) )
      {
        v10 = *(_DWORD *)(v5 + 8);
        if ( *(_BYTE *)(v10 + 25) )
        {
          for ( i = *(_DWORD *)(v5 + 4); !*(_BYTE *)(i + 25); i = *(_DWORD *)(i + 4) )
          {
            if ( v5 != *(_DWORD *)(i + 8) )
              break;
            v5 = i;
          }
          a4 = (_DWORD *)i;
        }
        else
        {
          v11 = *(_DWORD **)(v5 + 8);
          for ( j = *(_DWORD *)v10; !*(_BYTE *)(j + 25); j = *(_DWORD *)j )
            v11 = (_DWORD *)j;
          a4 = v11;
        }
      }
      sub_1004B030(v6, &v14, v9);
    }
    result = a3;
    *a3 = v5;
  }
  else
  {
    sub_1004B2B0(v6);
    result = a3;
    *a3 = **(_DWORD **)(v6 + 4);
  }
  return result;
}

//----- (1004A370) --------------------------------------------------------
int __stdcall sub_1004A370(int a1, int a2)
{
  int result; // eax@2
  int v3; // ebx@6
  int v4; // edi@6
  int i; // ebp@6

  if ( a1 == a2 )
  {
    result = a1;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003FF80(a1);
      sub_100943C0(*(_DWORD *)(a2 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004B300, a1, 0, 0x30u, 0);
    }
    else
    {
      sub_1004A470(a1, 0);
    }
    v3 = *(_DWORD *)a1;
    v4 = *(_DWORD *)a2;
    for ( i = *(_DWORD *)(a2 + 4); i; --i )
    {
      if ( v3 )
      {
        *(float *)v3 = *(float *)v4;
        *(float *)(v3 + 4) = *(float *)(v4 + 4);
        *(_DWORD *)(v3 + 8) = *(_DWORD *)(v4 + 8);
        *(_DWORD *)(v3 + 12) = *(_DWORD *)(v4 + 12);
        *(float *)(v3 + 16) = *(float *)(v4 + 16);
        sub_1004CBF0(v4 + 20, v3 + 20);
        *(_DWORD *)(v3 + 32) = *(_DWORD *)(v4 + 32);
        *(_DWORD *)(v3 + 36) = *(_DWORD *)(v4 + 36);
        *(_DWORD *)(v3 + 40) = *(_DWORD *)(v4 + 40);
        *(_BYTE *)(v3 + 44) = *(_BYTE *)(v4 + 44);
      }
      v3 += 48;
      v4 += 48;
    }
    result = a1;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  }
  return result;
}
// 1004B300: using guessed type int sub_1004B300();

//----- (1004A470) --------------------------------------------------------
void __usercall sub_1004A470(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int v2; // ecx@1

  v2 = *(_DWORD *)(a1 + 4);
  if ( a2 != v2 )
  {
    if ( a2 >= v2 )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004B300, a1, a2 == v2 + 1, 0x30u, 0);
      sub_10041020(*(_DWORD *)a1 + 48 * *(_DWORD *)(a1 + 4), a2 - *(_DWORD *)(a1 + 4));
      *(_DWORD *)(a1 + 4) = a2;
    }
    else
    {
      sub_10040FD0(*(_DWORD *)a1 + 48 * a2, v2 - a2);
      *(_DWORD *)(a1 + 4) = a2;
    }
  }
}
// 1004B300: using guessed type int sub_1004B300();

//----- (1004A4D0) --------------------------------------------------------
int *__userpurge sub_1004A4D0@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<esi>, _DWORD *a4, _DWORD *a5)
{
  int v5; // ecx@1
  int v6; // edi@1
  _DWORD *v7; // eax@1
  int *result; // eax@3
  int v9; // edx@5
  int v10; // eax@6
  _DWORD *v11; // ecx@7
  int j; // eax@7
  int i; // eax@10
  int v14; // [sp+0h] [bp-4h]@1

  v14 = a2;
  v5 = (int)a4;
  v6 = a1;
  v7 = *(_DWORD **)(a1 + 4);
  if ( a4 != (_DWORD *)*v7 || a5 != v7 )
  {
    for ( ; a4 != a5; v5 = (int)a4 )
    {
      v9 = v5;
      if ( !*(_BYTE *)(v5 + 41) )
      {
        v10 = *(_DWORD *)(v5 + 8);
        if ( *(_BYTE *)(v10 + 41) )
        {
          for ( i = *(_DWORD *)(v5 + 4); !*(_BYTE *)(i + 41); i = *(_DWORD *)(i + 4) )
          {
            if ( v5 != *(_DWORD *)(i + 8) )
              break;
            v5 = i;
          }
          a4 = (_DWORD *)i;
        }
        else
        {
          v11 = *(_DWORD **)(v5 + 8);
          for ( j = *(_DWORD *)v10; !*(_BYTE *)(j + 41); j = *(_DWORD *)j )
            v11 = (_DWORD *)j;
          a4 = v11;
        }
      }
      sub_1004B470(v6, &v14, v9);
    }
    result = a3;
    *a3 = v5;
  }
  else
  {
    sub_1004B6F0(v6);
    result = a3;
    *a3 = **(_DWORD **)(v6 + 4);
  }
  return result;
}

//----- (1004A580) --------------------------------------------------------
int __stdcall sub_1004A580(int a1, int a2)
{
  int v2; // esi@5
  int v3; // edi@5
  int i; // ebx@5

  if ( a1 != a2 )
  {
    if ( *(_DWORD *)(a1 + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_10039940(a1);
      sub_100943C0(*(_DWORD *)(a2 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004B740, a1, 0, 0x40u, 0);
    }
    else
    {
      sub_1004A630(a1, 0);
    }
    v2 = *(_DWORD *)(a2 + 4);
    v3 = *(_DWORD *)a1;
    for ( i = *(_DWORD *)a2; v2; --v2 )
    {
      if ( v3 )
        sub_1004C690(i, v3);
      v3 += 64;
      i += 64;
    }
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  }
  return a1;
}
// 1004B740: using guessed type int sub_1004B740();

//----- (1004A630) --------------------------------------------------------
void __usercall sub_1004A630(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int v2; // eax@1

  v2 = *(_DWORD *)(a1 + 4);
  if ( a2 != v2 )
  {
    if ( a2 >= v2 )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004B740, a1, a2 == v2 + 1, 0x40u, 0);
      sub_1003E580(a2 - *(_DWORD *)(a1 + 4), *(_DWORD *)a1 + (*(_DWORD *)(a1 + 4) << 6));
      *(_DWORD *)(a1 + 4) = a2;
    }
    else
    {
      sub_1004CEA0(v2 - a2, *(_DWORD *)a1 + (a2 << 6));
      *(_DWORD *)(a1 + 4) = a2;
    }
  }
}
// 1004B740: using guessed type int sub_1004B740();

//----- (1004A690) --------------------------------------------------------
int *__userpurge sub_1004A690@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<esi>, _DWORD *a4, _DWORD *a5)
{
  int v5; // ecx@1
  int v6; // edi@1
  _DWORD *v7; // eax@1
  int *result; // eax@3
  int v9; // edx@5
  int v10; // eax@6
  _DWORD *v11; // ecx@7
  int j; // eax@7
  int i; // eax@10
  int v14; // [sp+0h] [bp-4h]@1

  v14 = a2;
  v5 = (int)a4;
  v6 = a1;
  v7 = *(_DWORD **)(a1 + 4);
  if ( a4 != (_DWORD *)*v7 || a5 != v7 )
  {
    for ( ; a4 != a5; v5 = (int)a4 )
    {
      v9 = v5;
      if ( !*(_BYTE *)(v5 + 29) )
      {
        v10 = *(_DWORD *)(v5 + 8);
        if ( *(_BYTE *)(v10 + 29) )
        {
          for ( i = *(_DWORD *)(v5 + 4); !*(_BYTE *)(i + 29); i = *(_DWORD *)(i + 4) )
          {
            if ( v5 != *(_DWORD *)(i + 8) )
              break;
            v5 = i;
          }
          a4 = (_DWORD *)i;
        }
        else
        {
          v11 = *(_DWORD **)(v5 + 8);
          for ( j = *(_DWORD *)v10; !*(_BYTE *)(j + 29); j = *(_DWORD *)j )
            v11 = (_DWORD *)j;
          a4 = v11;
        }
      }
      sub_1004B8C0(v6, &v14, v9);
    }
    result = a3;
    *a3 = v5;
  }
  else
  {
    sub_1004BB40(v6);
    result = a3;
    *a3 = **(_DWORD **)(v6 + 4);
  }
  return result;
}

//----- (1004A740) --------------------------------------------------------
int __stdcall sub_1004A740(int a1, int a2)
{
  int result; // eax@2
  int v3; // ebx@6
  int v4; // edi@6
  int i; // ebp@6

  if ( a1 == a2 )
  {
    result = a1;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_10047BC0(a1);
      sub_100943C0(*(_DWORD *)(a2 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004BB90, a1, 0, 0x38u, 0);
    }
    else
    {
      sub_1004A840(a1, 0);
    }
    v3 = *(_DWORD *)a1;
    v4 = *(_DWORD *)a2;
    for ( i = *(_DWORD *)(a2 + 4); i; --i )
    {
      if ( v3 )
      {
        *(float *)v3 = *(float *)v4;
        *(float *)(v3 + 4) = *(float *)(v4 + 4);
        *(float *)(v3 + 8) = *(float *)(v4 + 8);
        *(_DWORD *)(v3 + 16) = *(_DWORD *)(v4 + 16);
        *(_DWORD *)(v3 + 20) = *(_DWORD *)(v4 + 20);
        *(float *)(v3 + 24) = *(float *)(v4 + 24);
        sub_1004CCE0(v4 + 28, v3 + 28);
        *(_DWORD *)(v3 + 40) = *(_DWORD *)(v4 + 40);
        *(_DWORD *)(v3 + 44) = *(_DWORD *)(v4 + 44);
        *(_DWORD *)(v3 + 48) = *(_DWORD *)(v4 + 48);
        *(_BYTE *)(v3 + 52) = *(_BYTE *)(v4 + 52);
      }
      v3 += 56;
      v4 += 56;
    }
    result = a1;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  }
  return result;
}
// 1004BB90: using guessed type int sub_1004BB90();

//----- (1004A840) --------------------------------------------------------
int __usercall sub_1004A840@<eax>(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int v2; // ecx@1
  int result; // eax@3

  v2 = *(_DWORD *)(a1 + 4);
  if ( a2 != v2 )
  {
    if ( a2 >= v2 )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004BB90, a1, a2 == v2 + 1, 0x38u, 0);
      result = sub_1004CF90(*(_DWORD *)a1 + 56 * *(_DWORD *)(a1 + 4), a2 - *(_DWORD *)(a1 + 4));
      *(_DWORD *)(a1 + 4) = a2;
    }
    else
    {
      result = sub_1004CEF0(*(_DWORD *)a1 + 56 * a2, v2 - a2);
      *(_DWORD *)(a1 + 4) = a2;
    }
  }
  return result;
}
// 1004BB90: using guessed type int sub_1004BB90();

//----- (1004A8B0) --------------------------------------------------------
int *__userpurge sub_1004A8B0@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<esi>, _DWORD *a4, _DWORD *a5)
{
  int v5; // ecx@1
  int v6; // edi@1
  _DWORD *v7; // eax@1
  int *result; // eax@3
  int v9; // edx@5
  int v10; // eax@6
  _DWORD *v11; // ecx@7
  int j; // eax@7
  int i; // eax@10
  int v14; // [sp+0h] [bp-4h]@1

  v14 = a2;
  v5 = (int)a4;
  v6 = a1;
  v7 = *(_DWORD **)(a1 + 4);
  if ( a4 != (_DWORD *)*v7 || a5 != v7 )
  {
    for ( ; a4 != a5; v5 = (int)a4 )
    {
      v9 = v5;
      if ( !*(_BYTE *)(v5 + 21) )
      {
        v10 = *(_DWORD *)(v5 + 8);
        if ( *(_BYTE *)(v10 + 21) )
        {
          for ( i = *(_DWORD *)(v5 + 4); !*(_BYTE *)(i + 21); i = *(_DWORD *)(i + 4) )
          {
            if ( v5 != *(_DWORD *)(i + 8) )
              break;
            v5 = i;
          }
          a4 = (_DWORD *)i;
        }
        else
        {
          v11 = *(_DWORD **)(v5 + 8);
          for ( j = *(_DWORD *)v10; !*(_BYTE *)(j + 21); j = *(_DWORD *)j )
            v11 = (_DWORD *)j;
          a4 = v11;
        }
      }
      sub_1004BD00(v6, &v14, v9);
    }
    result = a3;
    *a3 = v5;
  }
  else
  {
    sub_1004BF80(v6);
    result = a3;
    *a3 = **(_DWORD **)(v6 + 4);
  }
  return result;
}

//----- (1004A960) --------------------------------------------------------
int __stdcall sub_1004A960(int a1, int a2)
{
  int result; // eax@2
  int v3; // ebx@6
  int v4; // edi@6
  int i; // ebp@6

  if ( a1 == a2 )
  {
    result = a1;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003FF80(a1);
      sub_100943C0(*(_DWORD *)(a2 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004BFD0, a1, 0, 0x30u, 0);
    }
    else
    {
      sub_1004AA50(a1, 0);
    }
    v3 = *(_DWORD *)a1;
    v4 = *(_DWORD *)a2;
    for ( i = *(_DWORD *)(a2 + 4); i; --i )
    {
      if ( v3 )
      {
        *(float *)v3 = *(float *)v4;
        *(_DWORD *)(v3 + 8) = *(_DWORD *)(v4 + 8);
        *(_DWORD *)(v3 + 12) = *(_DWORD *)(v4 + 12);
        *(float *)(v3 + 16) = *(float *)(v4 + 16);
        sub_1004CD50(v4 + 20, v3 + 20);
        *(_DWORD *)(v3 + 32) = *(_DWORD *)(v4 + 32);
        *(_DWORD *)(v3 + 36) = *(_DWORD *)(v4 + 36);
        *(_DWORD *)(v3 + 40) = *(_DWORD *)(v4 + 40);
        *(_BYTE *)(v3 + 44) = *(_BYTE *)(v4 + 44);
      }
      v3 += 48;
      v4 += 48;
    }
    result = a1;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  }
  return result;
}
// 1004BFD0: using guessed type int sub_1004BFD0();

//----- (1004AA50) --------------------------------------------------------
void __usercall sub_1004AA50(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int v2; // ecx@1

  v2 = *(_DWORD *)(a1 + 4);
  if ( a2 != v2 )
  {
    if ( a2 >= v2 )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004BFD0, a1, a2 == v2 + 1, 0x30u, 0);
      sub_1004CFF0(*(_DWORD *)a1 + 48 * *(_DWORD *)(a1 + 4), a2 - *(_DWORD *)(a1 + 4));
      *(_DWORD *)(a1 + 4) = a2;
    }
    else
    {
      sub_10040FD0(*(_DWORD *)a1 + 48 * a2, v2 - a2);
      *(_DWORD *)(a1 + 4) = a2;
    }
  }
}
// 1004BFD0: using guessed type int sub_1004BFD0();

//----- (1004AAB0) --------------------------------------------------------
int __cdecl sub_1004AAB0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // edx@2
  int v6; // ecx@3

  result = a2;
  v4 = a2 + 8 * a3;
  if ( a2 != v4 )
  {
    v5 = a1 - a2;
    do
    {
      v6 = v5 + result;
      if ( v5 + result )
      {
        *(_DWORD *)v6 = *(_DWORD *)result;
        *(_DWORD *)(v6 + 4) = *(_DWORD *)(result + 4);
      }
      result += 8;
    }
    while ( result != v4 );
  }
  return result;
}

//----- (1004AAF0) --------------------------------------------------------
int *__userpurge sub_1004AAF0@<eax>(int a1@<eax>, int a2@<ecx>, int *a3@<esi>, _DWORD *a4, _DWORD *a5)
{
  int v5; // ecx@1
  int v6; // edi@1
  _DWORD *v7; // eax@1
  int *result; // eax@3
  int v9; // edx@5
  int v10; // eax@6
  _DWORD *v11; // ecx@7
  int j; // eax@7
  int i; // eax@10
  int v14; // [sp+0h] [bp-4h]@1

  v14 = a2;
  v5 = (int)a4;
  v6 = a1;
  v7 = *(_DWORD **)(a1 + 4);
  if ( a4 != (_DWORD *)*v7 || a5 != v7 )
  {
    for ( ; a4 != a5; v5 = (int)a4 )
    {
      v9 = v5;
      if ( !*(_BYTE *)(v5 + 81) )
      {
        v10 = *(_DWORD *)(v5 + 8);
        if ( *(_BYTE *)(v10 + 81) )
        {
          for ( i = *(_DWORD *)(v5 + 4); !*(_BYTE *)(i + 81); i = *(_DWORD *)(i + 4) )
          {
            if ( v5 != *(_DWORD *)(i + 8) )
              break;
            v5 = i;
          }
          a4 = (_DWORD *)i;
        }
        else
        {
          v11 = *(_DWORD **)(v5 + 8);
          for ( j = *(_DWORD *)v10; !*(_BYTE *)(j + 81); j = *(_DWORD *)j )
            v11 = (_DWORD *)j;
          a4 = v11;
        }
      }
      sub_1004C160(v6, &v14, v9);
    }
    result = a3;
    *a3 = v5;
  }
  else
  {
    sub_1004C3E0(v6);
    result = a3;
    *a3 = **(_DWORD **)(v6 + 4);
  }
  return result;
}

//----- (1004ABA0) --------------------------------------------------------
int __stdcall sub_1004ABA0(int a1, int a2)
{
  int result; // eax@2
  int v3; // ebx@6
  int v4; // edi@6
  int i; // ebp@6

  if ( a1 == a2 )
  {
    result = a1;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003C940(a1);
      sub_100943C0(*(_DWORD *)(a2 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C430, a1, 0, 0x68u, 0);
    }
    else
    {
      sub_1004ACA0(a1, 0);
    }
    v3 = *(_DWORD *)a1;
    v4 = *(_DWORD *)a2;
    for ( i = *(_DWORD *)(a2 + 4); i; --i )
    {
      if ( v3 )
      {
        sub_1003DDC0(v3, v4);
        *(_DWORD *)(v3 + 64) = *(_DWORD *)(v4 + 64);
        *(_DWORD *)(v3 + 68) = *(_DWORD *)(v4 + 68);
        *(float *)(v3 + 72) = *(float *)(v4 + 72);
        sub_1004CDB0(v4 + 76, v3 + 76);
        *(_DWORD *)(v3 + 88) = *(_DWORD *)(v4 + 88);
        *(_DWORD *)(v3 + 92) = *(_DWORD *)(v4 + 92);
        *(_DWORD *)(v3 + 96) = *(_DWORD *)(v4 + 96);
        *(_BYTE *)(v3 + 100) = *(_BYTE *)(v4 + 100);
      }
      v3 += 104;
      v4 += 104;
    }
    result = a1;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  }
  return result;
}
// 1004C430: using guessed type int sub_1004C430();

//----- (1004ACA0) --------------------------------------------------------
void __usercall sub_1004ACA0(int a1@<edi>, unsigned int a2@<esi>)
{
  unsigned int v2; // eax@1

  v2 = *(_DWORD *)(a1 + 4);
  if ( a2 != v2 )
  {
    if ( a2 >= v2 )
    {
      if ( a2 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(a2, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C430, a1, a2 == v2 + 1, 0x68u, 0);
      sub_1004D040(a2 - *(_DWORD *)(a1 + 4), (char *)(*(_DWORD *)a1 + 104 * *(_DWORD *)(a1 + 4)));
      *(_DWORD *)(a1 + 4) = a2;
    }
    else
    {
      sub_1004CF40(v2 - a2, *(_DWORD *)a1 + 104 * a2);
      *(_DWORD *)(a1 + 4) = a2;
    }
  }
}
// 1004C430: using guessed type int sub_1004C430();

//----- (1004AD00) --------------------------------------------------------
int __usercall sub_1004AD00@<eax>(int result@<eax>)
{
  int v1; // ecx@1
  int v2; // edx@2
  int j; // ecx@3
  int i; // ecx@6

  v1 = *(_DWORD *)result;
  if ( !*(_BYTE *)(*(_DWORD *)result + 25) )
  {
    v2 = *(_DWORD *)(v1 + 8);
    if ( *(_BYTE *)(v2 + 25) )
    {
      for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 25); i = *(_DWORD *)(i + 4) )
      {
        if ( *(_DWORD *)result != *(_DWORD *)(i + 8) )
          break;
        *(_DWORD *)result = i;
      }
      *(_DWORD *)result = i;
    }
    else
    {
      for ( j = *(_DWORD *)v2; !*(_BYTE *)(j + 25); j = *(_DWORD *)j )
        v2 = j;
      *(_DWORD *)result = v2;
    }
  }
  return result;
}

//----- (1004AD50) --------------------------------------------------------
int __usercall sub_1004AD50@<eax>(int result@<eax>)
{
  int v1; // ecx@1
  int v2; // edx@2
  int j; // ecx@3
  int i; // ecx@6

  v1 = *(_DWORD *)result;
  if ( !*(_BYTE *)(*(_DWORD *)result + 41) )
  {
    v2 = *(_DWORD *)(v1 + 8);
    if ( *(_BYTE *)(v2 + 41) )
    {
      for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 41); i = *(_DWORD *)(i + 4) )
      {
        if ( *(_DWORD *)result != *(_DWORD *)(i + 8) )
          break;
        *(_DWORD *)result = i;
      }
      *(_DWORD *)result = i;
    }
    else
    {
      for ( j = *(_DWORD *)v2; !*(_BYTE *)(j + 41); j = *(_DWORD *)j )
        v2 = j;
      *(_DWORD *)result = v2;
    }
  }
  return result;
}

//----- (1004ADA0) --------------------------------------------------------
int __usercall sub_1004ADA0@<eax>(int result@<eax>)
{
  int v1; // ecx@1
  int v2; // edx@2
  int j; // ecx@3
  int i; // ecx@6

  v1 = *(_DWORD *)result;
  if ( !*(_BYTE *)(*(_DWORD *)result + 29) )
  {
    v2 = *(_DWORD *)(v1 + 8);
    if ( *(_BYTE *)(v2 + 29) )
    {
      for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 29); i = *(_DWORD *)(i + 4) )
      {
        if ( *(_DWORD *)result != *(_DWORD *)(i + 8) )
          break;
        *(_DWORD *)result = i;
      }
      *(_DWORD *)result = i;
    }
    else
    {
      for ( j = *(_DWORD *)v2; !*(_BYTE *)(j + 29); j = *(_DWORD *)j )
        v2 = j;
      *(_DWORD *)result = v2;
    }
  }
  return result;
}

//----- (1004ADF0) --------------------------------------------------------
int __usercall sub_1004ADF0@<eax>(int result@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  int v3; // edx@6
  int v4; // eax@6
  int i; // ecx@6

  v2 = result;
  if ( result != a2 )
  {
    if ( *(_DWORD *)(result + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003C8F0(result);
      sub_100943C0(*(_DWORD *)(a2 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C600, v2, 0, 0x10u, 0);
    }
    else if ( *(_DWORD *)(result + 4) )
    {
      *(_DWORD *)(result + 4) = 0;
    }
    v3 = *(_DWORD *)(a2 + 4);
    v4 = *(_DWORD *)v2;
    for ( i = *(_DWORD *)a2; v3; --v3 )
    {
      if ( v4 )
      {
        *(float *)v4 = *(float *)i;
        *(float *)(v4 + 4) = *(float *)(i + 4);
        *(float *)(v4 + 8) = *(float *)(i + 8);
        *(_DWORD *)(v4 + 12) = *(_DWORD *)(i + 12);
      }
      v4 += 16;
      i += 16;
    }
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
    result = v2;
  }
  return result;
}
// 1004C600: using guessed type int sub_1004C600();

//----- (1004AE90) --------------------------------------------------------
int __usercall sub_1004AE90@<eax>(int result@<eax>)
{
  int v1; // ecx@1
  int v2; // edx@2
  int j; // ecx@3
  int i; // ecx@6

  v1 = *(_DWORD *)result;
  if ( !*(_BYTE *)(*(_DWORD *)result + 21) )
  {
    v2 = *(_DWORD *)(v1 + 8);
    if ( *(_BYTE *)(v2 + 21) )
    {
      for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 21); i = *(_DWORD *)(i + 4) )
      {
        if ( *(_DWORD *)result != *(_DWORD *)(i + 8) )
          break;
        *(_DWORD *)result = i;
      }
      *(_DWORD *)result = i;
    }
    else
    {
      for ( j = *(_DWORD *)v2; !*(_BYTE *)(j + 21); j = *(_DWORD *)j )
        v2 = j;
      *(_DWORD *)result = v2;
    }
  }
  return result;
}

//----- (1004AEE0) --------------------------------------------------------
int __usercall sub_1004AEE0@<eax>(int result@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  int v3; // edx@6
  int v4; // eax@6
  int i; // ecx@6

  v2 = result;
  if ( result != a2 )
  {
    if ( *(_DWORD *)(result + 8) < *(_DWORD *)(a2 + 4) )
    {
      sub_1003C8F0(result);
      sub_100943C0(*(_DWORD *)(a2 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C650, v2, 0, 8u, 0);
    }
    else if ( *(_DWORD *)(result + 4) )
    {
      *(_DWORD *)(result + 4) = 0;
    }
    v3 = *(_DWORD *)(a2 + 4);
    v4 = *(_DWORD *)v2;
    for ( i = *(_DWORD *)a2; v3; --v3 )
    {
      if ( v4 )
      {
        *(float *)v4 = *(float *)i;
        *(_DWORD *)(v4 + 4) = *(_DWORD *)(i + 4);
      }
      v4 += 8;
      i += 8;
    }
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
    result = v2;
  }
  return result;
}
// 1004C650: using guessed type int sub_1004C650();

//----- (1004AF70) --------------------------------------------------------
int __usercall sub_1004AF70@<eax>(int result@<eax>)
{
  int v1; // ecx@1
  int v2; // edx@2
  int j; // ecx@3
  int i; // ecx@6

  v1 = *(_DWORD *)result;
  if ( !*(_BYTE *)(*(_DWORD *)result + 81) )
  {
    v2 = *(_DWORD *)(v1 + 8);
    if ( *(_BYTE *)(v2 + 81) )
    {
      for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 81); i = *(_DWORD *)(i + 4) )
      {
        if ( *(_DWORD *)result != *(_DWORD *)(i + 8) )
          break;
        *(_DWORD *)result = i;
      }
      *(_DWORD *)result = i;
    }
    else
    {
      for ( j = *(_DWORD *)v2; !*(_BYTE *)(j + 81); j = *(_DWORD *)j )
        v2 = j;
      *(_DWORD *)result = v2;
    }
  }
  return result;
}

//----- (1004AFC0) --------------------------------------------------------
int __userpurge sub_1004AFC0@<eax>(int result@<eax>, float a2)
{
  double v2; // st7@1
  int v3; // ecx@1
  signed int v4; // esi@1
  signed int v5; // edx@2
  double v6; // st6@3

  v2 = a2;
  v3 = result + 8;
  v4 = 16;
  do
  {
    v5 = 2;
    do
    {
      v6 = *(float *)(v3 - 8);
      v3 += 32;
      --v5;
      *(float *)(v3 - 40) = v6 / v2;
      *(float *)(v3 - 36) = *(float *)(v3 - 36) / v2;
      *(float *)(v3 - 32) = *(float *)(v3 - 32) / v2;
      *(float *)(v3 - 28) = *(float *)(v3 - 28) / v2;
      *(float *)(v3 - 24) = *(float *)(v3 - 24) / v2;
      *(float *)(v3 - 20) = *(float *)(v3 - 20) / v2;
      *(float *)(v3 - 16) = *(float *)(v3 - 16) / v2;
      *(float *)(v3 - 12) = *(float *)(v3 - 12) / v2;
    }
    while ( v5 );
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (1004B030) --------------------------------------------------------
int *__stdcall sub_1004B030(int a1, int *a2, int a3)
{
  void *v3; // eax@1
  void *v4; // ebp@3
  int v5; // edi@4
  int v6; // eax@7
  int v7; // esi@8
  int v8; // eax@10
  void **v9; // edx@15
  int i; // ecx@17
  int v11; // eax@18
  int v12; // ebx@21
  int v13; // ecx@30
  int v14; // ecx@32
  char v15; // cl@35
  int v16; // ecx@39
  int v17; // eax@60
  int *result; // eax@62

  v3 = (void *)a3;
  if ( *(_BYTE *)(a3 + 25) )
    std::_Xout_of_range("invalid map/set<T> iterator");
  v4 = v3;
  sub_1004AD00((int)&a3);
  if ( *(_BYTE *)(*(_DWORD *)v4 + 25) )
  {
    v5 = *((_DWORD *)v4 + 2);
LABEL_8:
    v7 = *((_DWORD *)v4 + 1);
    if ( !*(_BYTE *)(v5 + 25) )
      *(_DWORD *)(v5 + 4) = v7;
    v8 = *(_DWORD *)(a1 + 4);
    if ( *(void **)(v8 + 4) == v4 )
    {
      *(_DWORD *)(v8 + 4) = v5;
    }
    else if ( *(void **)v7 == v4 )
    {
      *(_DWORD *)v7 = v5;
    }
    else
    {
      *(_DWORD *)(v7 + 8) = v5;
    }
    v9 = *(void ***)(a1 + 4);
    if ( *v9 == v4 )
    {
      if ( *(_BYTE *)(v5 + 25) )
      {
        i = v7;
      }
      else
      {
        v11 = *(_DWORD *)v5;
        for ( i = v5; !*(_BYTE *)(v11 + 25); v11 = *(_DWORD *)v11 )
          i = v11;
      }
      *v9 = (void *)i;
    }
    v12 = *(_DWORD *)(a1 + 4);
    if ( *(void **)(v12 + 8) == v4 )
    {
      if ( *(_BYTE *)(v5 + 25) )
        *(_DWORD *)(v12 + 8) = v7;
      else
        *(_DWORD *)(v12 + 8) = sub_1004C7D0(v5);
    }
    goto LABEL_36;
  }
  if ( *(_BYTE *)(*((_DWORD *)v4 + 2) + 25) )
  {
    v5 = *(_DWORD *)v4;
    goto LABEL_8;
  }
  v6 = a3;
  v5 = *(_DWORD *)(a3 + 8);
  if ( (void *)a3 == v4 )
    goto LABEL_8;
  *(_DWORD *)(*(_DWORD *)v4 + 4) = a3;
  *(_DWORD *)v6 = *(_DWORD *)v4;
  if ( v6 == *((_DWORD *)v4 + 2) )
  {
    v7 = v6;
  }
  else
  {
    v7 = *(_DWORD *)(v6 + 4);
    if ( !*(_BYTE *)(v5 + 25) )
      *(_DWORD *)(v5 + 4) = v7;
    *(_DWORD *)v7 = v5;
    *(_DWORD *)(v6 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(*((_DWORD *)v4 + 2) + 4) = v6;
  }
  v13 = *(_DWORD *)(a1 + 4);
  if ( *(void **)(v13 + 4) == v4 )
  {
    *(_DWORD *)(v13 + 4) = v6;
  }
  else
  {
    v14 = *((_DWORD *)v4 + 1);
    if ( *(void **)v14 == v4 )
      *(_DWORD *)v14 = v6;
    else
      *(_DWORD *)(v14 + 8) = v6;
  }
  *(_DWORD *)(v6 + 4) = *((_DWORD *)v4 + 1);
  v15 = *(_BYTE *)(v6 + 24);
  *(_BYTE *)(v6 + 24) = *((_BYTE *)v4 + 24);
  *((_BYTE *)v4 + 24) = v15;
LABEL_36:
  if ( *((_BYTE *)v4 + 24) == 1 )
  {
    for ( ; v5 != *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4); v7 = *(_DWORD *)(v7 + 4) )
    {
      if ( *(_BYTE *)(v5 + 24) != 1 )
        break;
      v16 = *(_DWORD *)v7;
      if ( v5 == *(_DWORD *)v7 )
      {
        v16 = *(_DWORD *)(v7 + 8);
        if ( !*(_BYTE *)(v16 + 24) )
        {
          *(_BYTE *)(v16 + 24) = 1;
          *(_BYTE *)(v7 + 24) = 0;
          sub_1004C730(v7, a1);
          v16 = *(_DWORD *)(v7 + 8);
        }
        if ( *(_BYTE *)(v16 + 25) )
          goto LABEL_54;
        if ( *(_BYTE *)(*(_DWORD *)v16 + 24) != 1 || *(_BYTE *)(*(_DWORD *)(v16 + 8) + 24) != 1 )
        {
          if ( *(_BYTE *)(*(_DWORD *)(v16 + 8) + 24) == 1 )
          {
            *(_BYTE *)(*(_DWORD *)v16 + 24) = 1;
            *(_BYTE *)(v16 + 24) = 0;
            sub_1004C780((_DWORD *)v16, a1);
            v16 = *(_DWORD *)(v7 + 8);
          }
          *(_BYTE *)(v16 + 24) = *(_BYTE *)(v7 + 24);
          *(_BYTE *)(v7 + 24) = 1;
          *(_BYTE *)(*(_DWORD *)(v16 + 8) + 24) = 1;
          sub_1004C730(v7, a1);
          break;
        }
      }
      else
      {
        if ( !*(_BYTE *)(v16 + 24) )
        {
          *(_BYTE *)(v16 + 24) = 1;
          *(_BYTE *)(v7 + 24) = 0;
          sub_1004C780((_DWORD *)v7, a1);
          v16 = *(_DWORD *)v7;
        }
        if ( *(_BYTE *)(v16 + 25) )
          goto LABEL_54;
        if ( *(_BYTE *)(*(_DWORD *)(v16 + 8) + 24) != 1 || *(_BYTE *)(*(_DWORD *)v16 + 24) != 1 )
        {
          if ( *(_BYTE *)(*(_DWORD *)v16 + 24) == 1 )
          {
            *(_BYTE *)(*(_DWORD *)(v16 + 8) + 24) = 1;
            *(_BYTE *)(v16 + 24) = 0;
            sub_1004C730(v16, a1);
            v16 = *(_DWORD *)v7;
          }
          *(_BYTE *)(v16 + 24) = *(_BYTE *)(v7 + 24);
          *(_BYTE *)(v7 + 24) = 1;
          *(_BYTE *)(*(_DWORD *)v16 + 24) = 1;
          sub_1004C780((_DWORD *)v7, a1);
          break;
        }
      }
      *(_BYTE *)(v16 + 24) = 0;
LABEL_54:
      v5 = v7;
    }
    *(_BYTE *)(v5 + 24) = 1;
  }
  operator delete(v4);
  v17 = *(_DWORD *)(a1 + 8);
  if ( v17 )
    *(_DWORD *)(a1 + 8) = v17 - 1;
  result = a2;
  *a2 = a3;
  return result;
}
// 100990E0: using guessed type void __cdecl std::_Xout_of_range(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004B2B0) --------------------------------------------------------
int __usercall sub_1004B2B0@<eax>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // ebx@1
  int v3; // esi@1
  int result; // eax@3

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(v1 + 4);
  v3 = *(_DWORD *)(v1 + 4);
  if ( !*(_BYTE *)(v2 + 25) )
  {
    do
    {
      sub_1004C6F0(*(void **)(v3 + 8));
      v3 = *(_DWORD *)v3;
      operator delete((void *)v2);
      v2 = v3;
    }
    while ( !*(_BYTE *)(v3 + 25) );
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = *(_DWORD *)(a1 + 4);
  **(_DWORD **)(a1 + 4) = *(_DWORD *)(a1 + 4);
  result = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(result + 8) = result;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004B470) --------------------------------------------------------
int *__stdcall sub_1004B470(int a1, int *a2, int a3)
{
  void *v3; // eax@1
  void *v4; // ebp@3
  int v5; // edi@4
  int v6; // eax@7
  int v7; // esi@8
  int v8; // eax@10
  void **v9; // edx@15
  int i; // ecx@17
  int v11; // eax@18
  int v12; // ebx@21
  int v13; // ecx@30
  int v14; // ecx@32
  char v15; // cl@35
  int v16; // ecx@39
  int v17; // eax@60
  int *result; // eax@62

  v3 = (void *)a3;
  if ( *(_BYTE *)(a3 + 41) )
    std::_Xout_of_range("invalid map/set<T> iterator");
  v4 = v3;
  sub_1004AD50((int)&a3);
  if ( *(_BYTE *)(*(_DWORD *)v4 + 41) )
  {
    v5 = *((_DWORD *)v4 + 2);
LABEL_8:
    v7 = *((_DWORD *)v4 + 1);
    if ( !*(_BYTE *)(v5 + 41) )
      *(_DWORD *)(v5 + 4) = v7;
    v8 = *(_DWORD *)(a1 + 4);
    if ( *(void **)(v8 + 4) == v4 )
    {
      *(_DWORD *)(v8 + 4) = v5;
    }
    else if ( *(void **)v7 == v4 )
    {
      *(_DWORD *)v7 = v5;
    }
    else
    {
      *(_DWORD *)(v7 + 8) = v5;
    }
    v9 = *(void ***)(a1 + 4);
    if ( *v9 == v4 )
    {
      if ( *(_BYTE *)(v5 + 41) )
      {
        i = v7;
      }
      else
      {
        v11 = *(_DWORD *)v5;
        for ( i = v5; !*(_BYTE *)(v11 + 41); v11 = *(_DWORD *)v11 )
          i = v11;
      }
      *v9 = (void *)i;
    }
    v12 = *(_DWORD *)(a1 + 4);
    if ( *(void **)(v12 + 8) == v4 )
    {
      if ( *(_BYTE *)(v5 + 41) )
        *(_DWORD *)(v12 + 8) = v7;
      else
        *(_DWORD *)(v12 + 8) = sub_1004C8D0(v5);
    }
    goto LABEL_36;
  }
  if ( *(_BYTE *)(*((_DWORD *)v4 + 2) + 41) )
  {
    v5 = *(_DWORD *)v4;
    goto LABEL_8;
  }
  v6 = a3;
  v5 = *(_DWORD *)(a3 + 8);
  if ( (void *)a3 == v4 )
    goto LABEL_8;
  *(_DWORD *)(*(_DWORD *)v4 + 4) = a3;
  *(_DWORD *)v6 = *(_DWORD *)v4;
  if ( v6 == *((_DWORD *)v4 + 2) )
  {
    v7 = v6;
  }
  else
  {
    v7 = *(_DWORD *)(v6 + 4);
    if ( !*(_BYTE *)(v5 + 41) )
      *(_DWORD *)(v5 + 4) = v7;
    *(_DWORD *)v7 = v5;
    *(_DWORD *)(v6 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(*((_DWORD *)v4 + 2) + 4) = v6;
  }
  v13 = *(_DWORD *)(a1 + 4);
  if ( *(void **)(v13 + 4) == v4 )
  {
    *(_DWORD *)(v13 + 4) = v6;
  }
  else
  {
    v14 = *((_DWORD *)v4 + 1);
    if ( *(void **)v14 == v4 )
      *(_DWORD *)v14 = v6;
    else
      *(_DWORD *)(v14 + 8) = v6;
  }
  *(_DWORD *)(v6 + 4) = *((_DWORD *)v4 + 1);
  v15 = *(_BYTE *)(v6 + 40);
  *(_BYTE *)(v6 + 40) = *((_BYTE *)v4 + 40);
  *((_BYTE *)v4 + 40) = v15;
LABEL_36:
  if ( *((_BYTE *)v4 + 40) == 1 )
  {
    for ( ; v5 != *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4); v7 = *(_DWORD *)(v7 + 4) )
    {
      if ( *(_BYTE *)(v5 + 40) != 1 )
        break;
      v16 = *(_DWORD *)v7;
      if ( v5 == *(_DWORD *)v7 )
      {
        v16 = *(_DWORD *)(v7 + 8);
        if ( !*(_BYTE *)(v16 + 40) )
        {
          *(_BYTE *)(v16 + 40) = 1;
          *(_BYTE *)(v7 + 40) = 0;
          sub_1004C830(v7, a1);
          v16 = *(_DWORD *)(v7 + 8);
        }
        if ( *(_BYTE *)(v16 + 41) )
          goto LABEL_54;
        if ( *(_BYTE *)(*(_DWORD *)v16 + 40) != 1 || *(_BYTE *)(*(_DWORD *)(v16 + 8) + 40) != 1 )
        {
          if ( *(_BYTE *)(*(_DWORD *)(v16 + 8) + 40) == 1 )
          {
            *(_BYTE *)(*(_DWORD *)v16 + 40) = 1;
            *(_BYTE *)(v16 + 40) = 0;
            sub_1004C880((_DWORD *)v16, a1);
            v16 = *(_DWORD *)(v7 + 8);
          }
          *(_BYTE *)(v16 + 40) = *(_BYTE *)(v7 + 40);
          *(_BYTE *)(v7 + 40) = 1;
          *(_BYTE *)(*(_DWORD *)(v16 + 8) + 40) = 1;
          sub_1004C830(v7, a1);
          break;
        }
      }
      else
      {
        if ( !*(_BYTE *)(v16 + 40) )
        {
          *(_BYTE *)(v16 + 40) = 1;
          *(_BYTE *)(v7 + 40) = 0;
          sub_1004C880((_DWORD *)v7, a1);
          v16 = *(_DWORD *)v7;
        }
        if ( *(_BYTE *)(v16 + 41) )
          goto LABEL_54;
        if ( *(_BYTE *)(*(_DWORD *)(v16 + 8) + 40) != 1 || *(_BYTE *)(*(_DWORD *)v16 + 40) != 1 )
        {
          if ( *(_BYTE *)(*(_DWORD *)v16 + 40) == 1 )
          {
            *(_BYTE *)(*(_DWORD *)(v16 + 8) + 40) = 1;
            *(_BYTE *)(v16 + 40) = 0;
            sub_1004C830(v16, a1);
            v16 = *(_DWORD *)v7;
          }
          *(_BYTE *)(v16 + 40) = *(_BYTE *)(v7 + 40);
          *(_BYTE *)(v7 + 40) = 1;
          *(_BYTE *)(*(_DWORD *)v16 + 40) = 1;
          sub_1004C880((_DWORD *)v7, a1);
          break;
        }
      }
      *(_BYTE *)(v16 + 40) = 0;
LABEL_54:
      v5 = v7;
    }
    *(_BYTE *)(v5 + 40) = 1;
  }
  operator delete(v4);
  v17 = *(_DWORD *)(a1 + 8);
  if ( v17 )
    *(_DWORD *)(a1 + 8) = v17 - 1;
  result = a2;
  *a2 = a3;
  return result;
}
// 100990E0: using guessed type void __cdecl std::_Xout_of_range(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004B6F0) --------------------------------------------------------
int __usercall sub_1004B6F0@<eax>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // ebx@1
  int v3; // esi@1
  int result; // eax@3

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(v1 + 4);
  v3 = *(_DWORD *)(v1 + 4);
  if ( !*(_BYTE *)(v2 + 41) )
  {
    do
    {
      sub_1004C7F0(*(void **)(v3 + 8));
      v3 = *(_DWORD *)v3;
      operator delete((void *)v2);
      v2 = v3;
    }
    while ( !*(_BYTE *)(v3 + 41) );
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = *(_DWORD *)(a1 + 4);
  **(_DWORD **)(a1 + 4) = *(_DWORD *)(a1 + 4);
  result = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(result + 8) = result;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004B8C0) --------------------------------------------------------
int *__stdcall sub_1004B8C0(int a1, int *a2, int a3)
{
  void *v3; // eax@1
  void *v4; // ebp@3
  int v5; // edi@4
  int v6; // eax@7
  int v7; // esi@8
  int v8; // eax@10
  void **v9; // edx@15
  int i; // ecx@17
  int v11; // eax@18
  int v12; // ebx@21
  int v13; // ecx@30
  int v14; // ecx@32
  char v15; // cl@35
  int v16; // ecx@39
  int v17; // eax@60
  int *result; // eax@62

  v3 = (void *)a3;
  if ( *(_BYTE *)(a3 + 29) )
    std::_Xout_of_range("invalid map/set<T> iterator");
  v4 = v3;
  sub_1004ADA0((int)&a3);
  if ( *(_BYTE *)(*(_DWORD *)v4 + 29) )
  {
    v5 = *((_DWORD *)v4 + 2);
LABEL_8:
    v7 = *((_DWORD *)v4 + 1);
    if ( !*(_BYTE *)(v5 + 29) )
      *(_DWORD *)(v5 + 4) = v7;
    v8 = *(_DWORD *)(a1 + 4);
    if ( *(void **)(v8 + 4) == v4 )
    {
      *(_DWORD *)(v8 + 4) = v5;
    }
    else if ( *(void **)v7 == v4 )
    {
      *(_DWORD *)v7 = v5;
    }
    else
    {
      *(_DWORD *)(v7 + 8) = v5;
    }
    v9 = *(void ***)(a1 + 4);
    if ( *v9 == v4 )
    {
      if ( *(_BYTE *)(v5 + 29) )
      {
        i = v7;
      }
      else
      {
        v11 = *(_DWORD *)v5;
        for ( i = v5; !*(_BYTE *)(v11 + 29); v11 = *(_DWORD *)v11 )
          i = v11;
      }
      *v9 = (void *)i;
    }
    v12 = *(_DWORD *)(a1 + 4);
    if ( *(void **)(v12 + 8) == v4 )
    {
      if ( *(_BYTE *)(v5 + 29) )
        *(_DWORD *)(v12 + 8) = v7;
      else
        *(_DWORD *)(v12 + 8) = sub_1004C9D0(v5);
    }
    goto LABEL_36;
  }
  if ( *(_BYTE *)(*((_DWORD *)v4 + 2) + 29) )
  {
    v5 = *(_DWORD *)v4;
    goto LABEL_8;
  }
  v6 = a3;
  v5 = *(_DWORD *)(a3 + 8);
  if ( (void *)a3 == v4 )
    goto LABEL_8;
  *(_DWORD *)(*(_DWORD *)v4 + 4) = a3;
  *(_DWORD *)v6 = *(_DWORD *)v4;
  if ( v6 == *((_DWORD *)v4 + 2) )
  {
    v7 = v6;
  }
  else
  {
    v7 = *(_DWORD *)(v6 + 4);
    if ( !*(_BYTE *)(v5 + 29) )
      *(_DWORD *)(v5 + 4) = v7;
    *(_DWORD *)v7 = v5;
    *(_DWORD *)(v6 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(*((_DWORD *)v4 + 2) + 4) = v6;
  }
  v13 = *(_DWORD *)(a1 + 4);
  if ( *(void **)(v13 + 4) == v4 )
  {
    *(_DWORD *)(v13 + 4) = v6;
  }
  else
  {
    v14 = *((_DWORD *)v4 + 1);
    if ( *(void **)v14 == v4 )
      *(_DWORD *)v14 = v6;
    else
      *(_DWORD *)(v14 + 8) = v6;
  }
  *(_DWORD *)(v6 + 4) = *((_DWORD *)v4 + 1);
  v15 = *(_BYTE *)(v6 + 28);
  *(_BYTE *)(v6 + 28) = *((_BYTE *)v4 + 28);
  *((_BYTE *)v4 + 28) = v15;
LABEL_36:
  if ( *((_BYTE *)v4 + 28) == 1 )
  {
    for ( ; v5 != *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4); v7 = *(_DWORD *)(v7 + 4) )
    {
      if ( *(_BYTE *)(v5 + 28) != 1 )
        break;
      v16 = *(_DWORD *)v7;
      if ( v5 == *(_DWORD *)v7 )
      {
        v16 = *(_DWORD *)(v7 + 8);
        if ( !*(_BYTE *)(v16 + 28) )
        {
          *(_BYTE *)(v16 + 28) = 1;
          *(_BYTE *)(v7 + 28) = 0;
          sub_1004C930(v7, a1);
          v16 = *(_DWORD *)(v7 + 8);
        }
        if ( *(_BYTE *)(v16 + 29) )
          goto LABEL_54;
        if ( *(_BYTE *)(*(_DWORD *)v16 + 28) != 1 || *(_BYTE *)(*(_DWORD *)(v16 + 8) + 28) != 1 )
        {
          if ( *(_BYTE *)(*(_DWORD *)(v16 + 8) + 28) == 1 )
          {
            *(_BYTE *)(*(_DWORD *)v16 + 28) = 1;
            *(_BYTE *)(v16 + 28) = 0;
            sub_1004C980((_DWORD *)v16, a1);
            v16 = *(_DWORD *)(v7 + 8);
          }
          *(_BYTE *)(v16 + 28) = *(_BYTE *)(v7 + 28);
          *(_BYTE *)(v7 + 28) = 1;
          *(_BYTE *)(*(_DWORD *)(v16 + 8) + 28) = 1;
          sub_1004C930(v7, a1);
          break;
        }
      }
      else
      {
        if ( !*(_BYTE *)(v16 + 28) )
        {
          *(_BYTE *)(v16 + 28) = 1;
          *(_BYTE *)(v7 + 28) = 0;
          sub_1004C980((_DWORD *)v7, a1);
          v16 = *(_DWORD *)v7;
        }
        if ( *(_BYTE *)(v16 + 29) )
          goto LABEL_54;
        if ( *(_BYTE *)(*(_DWORD *)(v16 + 8) + 28) != 1 || *(_BYTE *)(*(_DWORD *)v16 + 28) != 1 )
        {
          if ( *(_BYTE *)(*(_DWORD *)v16 + 28) == 1 )
          {
            *(_BYTE *)(*(_DWORD *)(v16 + 8) + 28) = 1;
            *(_BYTE *)(v16 + 28) = 0;
            sub_1004C930(v16, a1);
            v16 = *(_DWORD *)v7;
          }
          *(_BYTE *)(v16 + 28) = *(_BYTE *)(v7 + 28);
          *(_BYTE *)(v7 + 28) = 1;
          *(_BYTE *)(*(_DWORD *)v16 + 28) = 1;
          sub_1004C980((_DWORD *)v7, a1);
          break;
        }
      }
      *(_BYTE *)(v16 + 28) = 0;
LABEL_54:
      v5 = v7;
    }
    *(_BYTE *)(v5 + 28) = 1;
  }
  operator delete(v4);
  v17 = *(_DWORD *)(a1 + 8);
  if ( v17 )
    *(_DWORD *)(a1 + 8) = v17 - 1;
  result = a2;
  *a2 = a3;
  return result;
}
// 100990E0: using guessed type void __cdecl std::_Xout_of_range(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004BB40) --------------------------------------------------------
int __usercall sub_1004BB40@<eax>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // ebx@1
  int v3; // esi@1
  int result; // eax@3

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(v1 + 4);
  v3 = *(_DWORD *)(v1 + 4);
  if ( !*(_BYTE *)(v2 + 29) )
  {
    do
    {
      sub_1004C8F0(*(void **)(v3 + 8));
      v3 = *(_DWORD *)v3;
      operator delete((void *)v2);
      v2 = v3;
    }
    while ( !*(_BYTE *)(v3 + 29) );
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = *(_DWORD *)(a1 + 4);
  **(_DWORD **)(a1 + 4) = *(_DWORD *)(a1 + 4);
  result = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(result + 8) = result;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004BD00) --------------------------------------------------------
int *__stdcall sub_1004BD00(int a1, int *a2, int a3)
{
  void *v3; // eax@1
  void *v4; // ebp@3
  int v5; // edi@4
  int v6; // eax@7
  int v7; // esi@8
  int v8; // eax@10
  void **v9; // edx@15
  int i; // ecx@17
  int v11; // eax@18
  int v12; // ebx@21
  int v13; // ecx@30
  int v14; // ecx@32
  char v15; // cl@35
  int v16; // ecx@39
  int v17; // eax@60
  int *result; // eax@62

  v3 = (void *)a3;
  if ( *(_BYTE *)(a3 + 21) )
    std::_Xout_of_range("invalid map/set<T> iterator");
  v4 = v3;
  sub_1004AE90((int)&a3);
  if ( *(_BYTE *)(*(_DWORD *)v4 + 21) )
  {
    v5 = *((_DWORD *)v4 + 2);
LABEL_8:
    v7 = *((_DWORD *)v4 + 1);
    if ( !*(_BYTE *)(v5 + 21) )
      *(_DWORD *)(v5 + 4) = v7;
    v8 = *(_DWORD *)(a1 + 4);
    if ( *(void **)(v8 + 4) == v4 )
    {
      *(_DWORD *)(v8 + 4) = v5;
    }
    else if ( *(void **)v7 == v4 )
    {
      *(_DWORD *)v7 = v5;
    }
    else
    {
      *(_DWORD *)(v7 + 8) = v5;
    }
    v9 = *(void ***)(a1 + 4);
    if ( *v9 == v4 )
    {
      if ( *(_BYTE *)(v5 + 21) )
      {
        i = v7;
      }
      else
      {
        v11 = *(_DWORD *)v5;
        for ( i = v5; !*(_BYTE *)(v11 + 21); v11 = *(_DWORD *)v11 )
          i = v11;
      }
      *v9 = (void *)i;
    }
    v12 = *(_DWORD *)(a1 + 4);
    if ( *(void **)(v12 + 8) == v4 )
    {
      if ( *(_BYTE *)(v5 + 21) )
        *(_DWORD *)(v12 + 8) = v7;
      else
        *(_DWORD *)(v12 + 8) = sub_1004CAD0(v5);
    }
    goto LABEL_36;
  }
  if ( *(_BYTE *)(*((_DWORD *)v4 + 2) + 21) )
  {
    v5 = *(_DWORD *)v4;
    goto LABEL_8;
  }
  v6 = a3;
  v5 = *(_DWORD *)(a3 + 8);
  if ( (void *)a3 == v4 )
    goto LABEL_8;
  *(_DWORD *)(*(_DWORD *)v4 + 4) = a3;
  *(_DWORD *)v6 = *(_DWORD *)v4;
  if ( v6 == *((_DWORD *)v4 + 2) )
  {
    v7 = v6;
  }
  else
  {
    v7 = *(_DWORD *)(v6 + 4);
    if ( !*(_BYTE *)(v5 + 21) )
      *(_DWORD *)(v5 + 4) = v7;
    *(_DWORD *)v7 = v5;
    *(_DWORD *)(v6 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(*((_DWORD *)v4 + 2) + 4) = v6;
  }
  v13 = *(_DWORD *)(a1 + 4);
  if ( *(void **)(v13 + 4) == v4 )
  {
    *(_DWORD *)(v13 + 4) = v6;
  }
  else
  {
    v14 = *((_DWORD *)v4 + 1);
    if ( *(void **)v14 == v4 )
      *(_DWORD *)v14 = v6;
    else
      *(_DWORD *)(v14 + 8) = v6;
  }
  *(_DWORD *)(v6 + 4) = *((_DWORD *)v4 + 1);
  v15 = *(_BYTE *)(v6 + 20);
  *(_BYTE *)(v6 + 20) = *((_BYTE *)v4 + 20);
  *((_BYTE *)v4 + 20) = v15;
LABEL_36:
  if ( *((_BYTE *)v4 + 20) == 1 )
  {
    for ( ; v5 != *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4); v7 = *(_DWORD *)(v7 + 4) )
    {
      if ( *(_BYTE *)(v5 + 20) != 1 )
        break;
      v16 = *(_DWORD *)v7;
      if ( v5 == *(_DWORD *)v7 )
      {
        v16 = *(_DWORD *)(v7 + 8);
        if ( !*(_BYTE *)(v16 + 20) )
        {
          *(_BYTE *)(v16 + 20) = 1;
          *(_BYTE *)(v7 + 20) = 0;
          sub_1004CA30(v7, a1);
          v16 = *(_DWORD *)(v7 + 8);
        }
        if ( *(_BYTE *)(v16 + 21) )
          goto LABEL_54;
        if ( *(_BYTE *)(*(_DWORD *)v16 + 20) != 1 || *(_BYTE *)(*(_DWORD *)(v16 + 8) + 20) != 1 )
        {
          if ( *(_BYTE *)(*(_DWORD *)(v16 + 8) + 20) == 1 )
          {
            *(_BYTE *)(*(_DWORD *)v16 + 20) = 1;
            *(_BYTE *)(v16 + 20) = 0;
            sub_1004CA80((_DWORD *)v16, a1);
            v16 = *(_DWORD *)(v7 + 8);
          }
          *(_BYTE *)(v16 + 20) = *(_BYTE *)(v7 + 20);
          *(_BYTE *)(v7 + 20) = 1;
          *(_BYTE *)(*(_DWORD *)(v16 + 8) + 20) = 1;
          sub_1004CA30(v7, a1);
          break;
        }
      }
      else
      {
        if ( !*(_BYTE *)(v16 + 20) )
        {
          *(_BYTE *)(v16 + 20) = 1;
          *(_BYTE *)(v7 + 20) = 0;
          sub_1004CA80((_DWORD *)v7, a1);
          v16 = *(_DWORD *)v7;
        }
        if ( *(_BYTE *)(v16 + 21) )
          goto LABEL_54;
        if ( *(_BYTE *)(*(_DWORD *)(v16 + 8) + 20) != 1 || *(_BYTE *)(*(_DWORD *)v16 + 20) != 1 )
        {
          if ( *(_BYTE *)(*(_DWORD *)v16 + 20) == 1 )
          {
            *(_BYTE *)(*(_DWORD *)(v16 + 8) + 20) = 1;
            *(_BYTE *)(v16 + 20) = 0;
            sub_1004CA30(v16, a1);
            v16 = *(_DWORD *)v7;
          }
          *(_BYTE *)(v16 + 20) = *(_BYTE *)(v7 + 20);
          *(_BYTE *)(v7 + 20) = 1;
          *(_BYTE *)(*(_DWORD *)v16 + 20) = 1;
          sub_1004CA80((_DWORD *)v7, a1);
          break;
        }
      }
      *(_BYTE *)(v16 + 20) = 0;
LABEL_54:
      v5 = v7;
    }
    *(_BYTE *)(v5 + 20) = 1;
  }
  operator delete(v4);
  v17 = *(_DWORD *)(a1 + 8);
  if ( v17 )
    *(_DWORD *)(a1 + 8) = v17 - 1;
  result = a2;
  *a2 = a3;
  return result;
}
// 100990E0: using guessed type void __cdecl std::_Xout_of_range(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004BF80) --------------------------------------------------------
int __usercall sub_1004BF80@<eax>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // ebx@1
  int v3; // esi@1
  int result; // eax@3

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(v1 + 4);
  v3 = *(_DWORD *)(v1 + 4);
  if ( !*(_BYTE *)(v2 + 21) )
  {
    do
    {
      sub_1004C9F0(*(void **)(v3 + 8));
      v3 = *(_DWORD *)v3;
      operator delete((void *)v2);
      v2 = v3;
    }
    while ( !*(_BYTE *)(v3 + 21) );
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = *(_DWORD *)(a1 + 4);
  **(_DWORD **)(a1 + 4) = *(_DWORD *)(a1 + 4);
  result = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(result + 8) = result;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004C160) --------------------------------------------------------
int *__stdcall sub_1004C160(int a1, int *a2, int a3)
{
  void *v3; // eax@1
  void *v4; // ebp@3
  int v5; // edi@4
  int v6; // eax@7
  int v7; // esi@8
  int v8; // eax@10
  void **v9; // edx@15
  int i; // ecx@17
  int v11; // eax@18
  int v12; // ebx@21
  int v13; // ecx@30
  int v14; // ecx@32
  char v15; // cl@35
  int v16; // ecx@39
  int v17; // eax@60
  int *result; // eax@62

  v3 = (void *)a3;
  if ( *(_BYTE *)(a3 + 81) )
    std::_Xout_of_range("invalid map/set<T> iterator");
  v4 = v3;
  sub_1004AF70((int)&a3);
  if ( *(_BYTE *)(*(_DWORD *)v4 + 81) )
  {
    v5 = *((_DWORD *)v4 + 2);
LABEL_8:
    v7 = *((_DWORD *)v4 + 1);
    if ( !*(_BYTE *)(v5 + 81) )
      *(_DWORD *)(v5 + 4) = v7;
    v8 = *(_DWORD *)(a1 + 4);
    if ( *(void **)(v8 + 4) == v4 )
    {
      *(_DWORD *)(v8 + 4) = v5;
    }
    else if ( *(void **)v7 == v4 )
    {
      *(_DWORD *)v7 = v5;
    }
    else
    {
      *(_DWORD *)(v7 + 8) = v5;
    }
    v9 = *(void ***)(a1 + 4);
    if ( *v9 == v4 )
    {
      if ( *(_BYTE *)(v5 + 81) )
      {
        i = v7;
      }
      else
      {
        v11 = *(_DWORD *)v5;
        for ( i = v5; !*(_BYTE *)(v11 + 81); v11 = *(_DWORD *)v11 )
          i = v11;
      }
      *v9 = (void *)i;
    }
    v12 = *(_DWORD *)(a1 + 4);
    if ( *(void **)(v12 + 8) == v4 )
    {
      if ( *(_BYTE *)(v5 + 81) )
        *(_DWORD *)(v12 + 8) = v7;
      else
        *(_DWORD *)(v12 + 8) = sub_1004CBD0(v5);
    }
    goto LABEL_36;
  }
  if ( *(_BYTE *)(*((_DWORD *)v4 + 2) + 81) )
  {
    v5 = *(_DWORD *)v4;
    goto LABEL_8;
  }
  v6 = a3;
  v5 = *(_DWORD *)(a3 + 8);
  if ( (void *)a3 == v4 )
    goto LABEL_8;
  *(_DWORD *)(*(_DWORD *)v4 + 4) = a3;
  *(_DWORD *)v6 = *(_DWORD *)v4;
  if ( v6 == *((_DWORD *)v4 + 2) )
  {
    v7 = v6;
  }
  else
  {
    v7 = *(_DWORD *)(v6 + 4);
    if ( !*(_BYTE *)(v5 + 81) )
      *(_DWORD *)(v5 + 4) = v7;
    *(_DWORD *)v7 = v5;
    *(_DWORD *)(v6 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(*((_DWORD *)v4 + 2) + 4) = v6;
  }
  v13 = *(_DWORD *)(a1 + 4);
  if ( *(void **)(v13 + 4) == v4 )
  {
    *(_DWORD *)(v13 + 4) = v6;
  }
  else
  {
    v14 = *((_DWORD *)v4 + 1);
    if ( *(void **)v14 == v4 )
      *(_DWORD *)v14 = v6;
    else
      *(_DWORD *)(v14 + 8) = v6;
  }
  *(_DWORD *)(v6 + 4) = *((_DWORD *)v4 + 1);
  v15 = *(_BYTE *)(v6 + 80);
  *(_BYTE *)(v6 + 80) = *((_BYTE *)v4 + 80);
  *((_BYTE *)v4 + 80) = v15;
LABEL_36:
  if ( *((_BYTE *)v4 + 80) == 1 )
  {
    for ( ; v5 != *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4); v7 = *(_DWORD *)(v7 + 4) )
    {
      if ( *(_BYTE *)(v5 + 80) != 1 )
        break;
      v16 = *(_DWORD *)v7;
      if ( v5 == *(_DWORD *)v7 )
      {
        v16 = *(_DWORD *)(v7 + 8);
        if ( !*(_BYTE *)(v16 + 80) )
        {
          *(_BYTE *)(v16 + 80) = 1;
          *(_BYTE *)(v7 + 80) = 0;
          sub_1004CB30(v7, a1);
          v16 = *(_DWORD *)(v7 + 8);
        }
        if ( *(_BYTE *)(v16 + 81) )
          goto LABEL_54;
        if ( *(_BYTE *)(*(_DWORD *)v16 + 80) != 1 || *(_BYTE *)(*(_DWORD *)(v16 + 8) + 80) != 1 )
        {
          if ( *(_BYTE *)(*(_DWORD *)(v16 + 8) + 80) == 1 )
          {
            *(_BYTE *)(*(_DWORD *)v16 + 80) = 1;
            *(_BYTE *)(v16 + 80) = 0;
            sub_1004CB80((_DWORD *)v16, a1);
            v16 = *(_DWORD *)(v7 + 8);
          }
          *(_BYTE *)(v16 + 80) = *(_BYTE *)(v7 + 80);
          *(_BYTE *)(v7 + 80) = 1;
          *(_BYTE *)(*(_DWORD *)(v16 + 8) + 80) = 1;
          sub_1004CB30(v7, a1);
          break;
        }
      }
      else
      {
        if ( !*(_BYTE *)(v16 + 80) )
        {
          *(_BYTE *)(v16 + 80) = 1;
          *(_BYTE *)(v7 + 80) = 0;
          sub_1004CB80((_DWORD *)v7, a1);
          v16 = *(_DWORD *)v7;
        }
        if ( *(_BYTE *)(v16 + 81) )
          goto LABEL_54;
        if ( *(_BYTE *)(*(_DWORD *)(v16 + 8) + 80) != 1 || *(_BYTE *)(*(_DWORD *)v16 + 80) != 1 )
        {
          if ( *(_BYTE *)(*(_DWORD *)v16 + 80) == 1 )
          {
            *(_BYTE *)(*(_DWORD *)(v16 + 8) + 80) = 1;
            *(_BYTE *)(v16 + 80) = 0;
            sub_1004CB30(v16, a1);
            v16 = *(_DWORD *)v7;
          }
          *(_BYTE *)(v16 + 80) = *(_BYTE *)(v7 + 80);
          *(_BYTE *)(v7 + 80) = 1;
          *(_BYTE *)(*(_DWORD *)v16 + 80) = 1;
          sub_1004CB80((_DWORD *)v7, a1);
          break;
        }
      }
      *(_BYTE *)(v16 + 80) = 0;
LABEL_54:
      v5 = v7;
    }
    *(_BYTE *)(v5 + 80) = 1;
  }
  operator delete(v4);
  v17 = *(_DWORD *)(a1 + 8);
  if ( v17 )
    *(_DWORD *)(a1 + 8) = v17 - 1;
  result = a2;
  *a2 = a3;
  return result;
}
// 100990E0: using guessed type void __cdecl std::_Xout_of_range(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004C3E0) --------------------------------------------------------
int __usercall sub_1004C3E0@<eax>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // ebx@1
  int v3; // esi@1
  int result; // eax@3

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(v1 + 4);
  v3 = *(_DWORD *)(v1 + 4);
  if ( !*(_BYTE *)(v2 + 81) )
  {
    do
    {
      sub_1004CAF0(*(void **)(v3 + 8));
      v3 = *(_DWORD *)v3;
      operator delete((void *)v2);
      v2 = v3;
    }
    while ( !*(_BYTE *)(v3 + 81) );
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = *(_DWORD *)(a1 + 4);
  **(_DWORD **)(a1 + 4) = *(_DWORD *)(a1 + 4);
  result = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(result + 8) = result;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004C690) --------------------------------------------------------
int __usercall sub_1004C690@<eax>(int a1@<ebx>, int a2@<edi>)
{
  *(float *)a2 = *(float *)a1;
  *(float *)(a2 + 4) = *(float *)(a1 + 4);
  *(float *)(a2 + 8) = *(float *)(a1 + 8);
  *(float *)(a2 + 12) = *(float *)(a1 + 12);
  *(float *)(a2 + 16) = *(float *)(a1 + 16);
  *(float *)(a2 + 20) = *(float *)(a1 + 20);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 28);
  *(float *)(a2 + 32) = *(float *)(a1 + 32);
  sub_1004CC60(a1 + 36, a2 + 36);
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a2 + 52) = *(_DWORD *)(a1 + 52);
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a2 + 60) = *(_BYTE *)(a1 + 60);
  return a2;
}

//----- (1004C6F0) --------------------------------------------------------
void __stdcall sub_1004C6F0(void *a1)
{
  void *v1; // edi@1
  void *i; // esi@1

  v1 = a1;
  for ( i = a1; !*((_BYTE *)i + 25); v1 = i )
  {
    sub_1004C6F0(*((_DWORD *)i + 2));
    i = *(void **)i;
    operator delete(v1);
  }
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004C730) --------------------------------------------------------
int __thiscall sub_1004C730(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@3
  int v4; // edx@5

  result = *(_DWORD *)(this + 8);
  *(_DWORD *)(this + 8) = *(_DWORD *)result;
  if ( !*(_BYTE *)(*(_DWORD *)result + 25) )
    *(_DWORD *)(*(_DWORD *)result + 4) = this;
  *(_DWORD *)(result + 4) = *(_DWORD *)(this + 4);
  v3 = *(_DWORD *)(a2 + 4);
  if ( this == *(_DWORD *)(v3 + 4) )
  {
    *(_DWORD *)(v3 + 4) = result;
    *(_DWORD *)result = this;
    *(_DWORD *)(this + 4) = result;
  }
  else
  {
    v4 = *(_DWORD *)(this + 4);
    if ( this == *(_DWORD *)v4 )
    {
      *(_DWORD *)v4 = result;
      *(_DWORD *)result = this;
      *(_DWORD *)(this + 4) = result;
    }
    else
    {
      *(_DWORD *)(v4 + 8) = result;
      *(_DWORD *)result = this;
      *(_DWORD *)(this + 4) = result;
    }
  }
  return result;
}

//----- (1004C780) --------------------------------------------------------
int __thiscall sub_1004C780(_DWORD *this, int a2)
{
  int result; // eax@1
  int v3; // edx@1
  int v4; // edx@3
  int v5; // edx@5

  result = *this;
  *this = *(_DWORD *)(*this + 8);
  v3 = *(_DWORD *)(result + 8);
  if ( !*(_BYTE *)(v3 + 25) )
    *(_DWORD *)(v3 + 4) = this;
  *(_DWORD *)(result + 4) = this[1];
  v4 = *(_DWORD *)(a2 + 4);
  if ( this == *(_DWORD **)(v4 + 4) )
  {
    *(_DWORD *)(v4 + 4) = result;
    *(_DWORD *)(result + 8) = this;
    this[1] = result;
  }
  else
  {
    v5 = this[1];
    if ( this == *(_DWORD **)(v5 + 8) )
    {
      *(_DWORD *)(v5 + 8) = result;
      *(_DWORD *)(result + 8) = this;
      this[1] = result;
    }
    else
    {
      *(_DWORD *)v5 = result;
      *(_DWORD *)(result + 8) = this;
      this[1] = result;
    }
  }
  return result;
}

//----- (1004C7D0) --------------------------------------------------------
int __usercall sub_1004C7D0@<eax>(int result@<eax>)
{
  int i; // ecx@1

  for ( i = *(_DWORD *)(result + 8); !*(_BYTE *)(i + 25); i = *(_DWORD *)(i + 8) )
    result = i;
  return result;
}

//----- (1004C7F0) --------------------------------------------------------
void __stdcall sub_1004C7F0(void *a1)
{
  void *v1; // edi@1
  void *i; // esi@1

  v1 = a1;
  for ( i = a1; !*((_BYTE *)i + 41); v1 = i )
  {
    sub_1004C7F0(*((_DWORD *)i + 2));
    i = *(void **)i;
    operator delete(v1);
  }
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004C830) --------------------------------------------------------
int __thiscall sub_1004C830(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@3
  int v4; // edx@5

  result = *(_DWORD *)(this + 8);
  *(_DWORD *)(this + 8) = *(_DWORD *)result;
  if ( !*(_BYTE *)(*(_DWORD *)result + 41) )
    *(_DWORD *)(*(_DWORD *)result + 4) = this;
  *(_DWORD *)(result + 4) = *(_DWORD *)(this + 4);
  v3 = *(_DWORD *)(a2 + 4);
  if ( this == *(_DWORD *)(v3 + 4) )
  {
    *(_DWORD *)(v3 + 4) = result;
    *(_DWORD *)result = this;
    *(_DWORD *)(this + 4) = result;
  }
  else
  {
    v4 = *(_DWORD *)(this + 4);
    if ( this == *(_DWORD *)v4 )
    {
      *(_DWORD *)v4 = result;
      *(_DWORD *)result = this;
      *(_DWORD *)(this + 4) = result;
    }
    else
    {
      *(_DWORD *)(v4 + 8) = result;
      *(_DWORD *)result = this;
      *(_DWORD *)(this + 4) = result;
    }
  }
  return result;
}

//----- (1004C880) --------------------------------------------------------
int __thiscall sub_1004C880(_DWORD *this, int a2)
{
  int result; // eax@1
  int v3; // edx@1
  int v4; // edx@3
  int v5; // edx@5

  result = *this;
  *this = *(_DWORD *)(*this + 8);
  v3 = *(_DWORD *)(result + 8);
  if ( !*(_BYTE *)(v3 + 41) )
    *(_DWORD *)(v3 + 4) = this;
  *(_DWORD *)(result + 4) = this[1];
  v4 = *(_DWORD *)(a2 + 4);
  if ( this == *(_DWORD **)(v4 + 4) )
  {
    *(_DWORD *)(v4 + 4) = result;
    *(_DWORD *)(result + 8) = this;
    this[1] = result;
  }
  else
  {
    v5 = this[1];
    if ( this == *(_DWORD **)(v5 + 8) )
    {
      *(_DWORD *)(v5 + 8) = result;
      *(_DWORD *)(result + 8) = this;
      this[1] = result;
    }
    else
    {
      *(_DWORD *)v5 = result;
      *(_DWORD *)(result + 8) = this;
      this[1] = result;
    }
  }
  return result;
}

//----- (1004C8D0) --------------------------------------------------------
int __usercall sub_1004C8D0@<eax>(int result@<eax>)
{
  int i; // ecx@1

  for ( i = *(_DWORD *)(result + 8); !*(_BYTE *)(i + 41); i = *(_DWORD *)(i + 8) )
    result = i;
  return result;
}

//----- (1004C8F0) --------------------------------------------------------
void __stdcall sub_1004C8F0(void *a1)
{
  void *v1; // edi@1
  void *i; // esi@1

  v1 = a1;
  for ( i = a1; !*((_BYTE *)i + 29); v1 = i )
  {
    sub_1004C8F0(*((_DWORD *)i + 2));
    i = *(void **)i;
    operator delete(v1);
  }
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004C930) --------------------------------------------------------
int __thiscall sub_1004C930(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@3
  int v4; // edx@5

  result = *(_DWORD *)(this + 8);
  *(_DWORD *)(this + 8) = *(_DWORD *)result;
  if ( !*(_BYTE *)(*(_DWORD *)result + 29) )
    *(_DWORD *)(*(_DWORD *)result + 4) = this;
  *(_DWORD *)(result + 4) = *(_DWORD *)(this + 4);
  v3 = *(_DWORD *)(a2 + 4);
  if ( this == *(_DWORD *)(v3 + 4) )
  {
    *(_DWORD *)(v3 + 4) = result;
    *(_DWORD *)result = this;
    *(_DWORD *)(this + 4) = result;
  }
  else
  {
    v4 = *(_DWORD *)(this + 4);
    if ( this == *(_DWORD *)v4 )
    {
      *(_DWORD *)v4 = result;
      *(_DWORD *)result = this;
      *(_DWORD *)(this + 4) = result;
    }
    else
    {
      *(_DWORD *)(v4 + 8) = result;
      *(_DWORD *)result = this;
      *(_DWORD *)(this + 4) = result;
    }
  }
  return result;
}

//----- (1004C980) --------------------------------------------------------
int __thiscall sub_1004C980(_DWORD *this, int a2)
{
  int result; // eax@1
  int v3; // edx@1
  int v4; // edx@3
  int v5; // edx@5

  result = *this;
  *this = *(_DWORD *)(*this + 8);
  v3 = *(_DWORD *)(result + 8);
  if ( !*(_BYTE *)(v3 + 29) )
    *(_DWORD *)(v3 + 4) = this;
  *(_DWORD *)(result + 4) = this[1];
  v4 = *(_DWORD *)(a2 + 4);
  if ( this == *(_DWORD **)(v4 + 4) )
  {
    *(_DWORD *)(v4 + 4) = result;
    *(_DWORD *)(result + 8) = this;
    this[1] = result;
  }
  else
  {
    v5 = this[1];
    if ( this == *(_DWORD **)(v5 + 8) )
    {
      *(_DWORD *)(v5 + 8) = result;
      *(_DWORD *)(result + 8) = this;
      this[1] = result;
    }
    else
    {
      *(_DWORD *)v5 = result;
      *(_DWORD *)(result + 8) = this;
      this[1] = result;
    }
  }
  return result;
}

//----- (1004C9D0) --------------------------------------------------------
int __usercall sub_1004C9D0@<eax>(int result@<eax>)
{
  int i; // ecx@1

  for ( i = *(_DWORD *)(result + 8); !*(_BYTE *)(i + 29); i = *(_DWORD *)(i + 8) )
    result = i;
  return result;
}

//----- (1004C9F0) --------------------------------------------------------
void __stdcall sub_1004C9F0(void *a1)
{
  void *v1; // edi@1
  void *i; // esi@1

  v1 = a1;
  for ( i = a1; !*((_BYTE *)i + 21); v1 = i )
  {
    sub_1004C9F0(*((_DWORD *)i + 2));
    i = *(void **)i;
    operator delete(v1);
  }
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004CA30) --------------------------------------------------------
int __thiscall sub_1004CA30(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@3
  int v4; // edx@5

  result = *(_DWORD *)(this + 8);
  *(_DWORD *)(this + 8) = *(_DWORD *)result;
  if ( !*(_BYTE *)(*(_DWORD *)result + 21) )
    *(_DWORD *)(*(_DWORD *)result + 4) = this;
  *(_DWORD *)(result + 4) = *(_DWORD *)(this + 4);
  v3 = *(_DWORD *)(a2 + 4);
  if ( this == *(_DWORD *)(v3 + 4) )
  {
    *(_DWORD *)(v3 + 4) = result;
    *(_DWORD *)result = this;
    *(_DWORD *)(this + 4) = result;
  }
  else
  {
    v4 = *(_DWORD *)(this + 4);
    if ( this == *(_DWORD *)v4 )
    {
      *(_DWORD *)v4 = result;
      *(_DWORD *)result = this;
      *(_DWORD *)(this + 4) = result;
    }
    else
    {
      *(_DWORD *)(v4 + 8) = result;
      *(_DWORD *)result = this;
      *(_DWORD *)(this + 4) = result;
    }
  }
  return result;
}

//----- (1004CA80) --------------------------------------------------------
int __thiscall sub_1004CA80(_DWORD *this, int a2)
{
  int result; // eax@1
  int v3; // edx@1
  int v4; // edx@3
  int v5; // edx@5

  result = *this;
  *this = *(_DWORD *)(*this + 8);
  v3 = *(_DWORD *)(result + 8);
  if ( !*(_BYTE *)(v3 + 21) )
    *(_DWORD *)(v3 + 4) = this;
  *(_DWORD *)(result + 4) = this[1];
  v4 = *(_DWORD *)(a2 + 4);
  if ( this == *(_DWORD **)(v4 + 4) )
  {
    *(_DWORD *)(v4 + 4) = result;
    *(_DWORD *)(result + 8) = this;
    this[1] = result;
  }
  else
  {
    v5 = this[1];
    if ( this == *(_DWORD **)(v5 + 8) )
    {
      *(_DWORD *)(v5 + 8) = result;
      *(_DWORD *)(result + 8) = this;
      this[1] = result;
    }
    else
    {
      *(_DWORD *)v5 = result;
      *(_DWORD *)(result + 8) = this;
      this[1] = result;
    }
  }
  return result;
}

//----- (1004CAD0) --------------------------------------------------------
int __usercall sub_1004CAD0@<eax>(int result@<eax>)
{
  int i; // ecx@1

  for ( i = *(_DWORD *)(result + 8); !*(_BYTE *)(i + 21); i = *(_DWORD *)(i + 8) )
    result = i;
  return result;
}

//----- (1004CAF0) --------------------------------------------------------
void __stdcall sub_1004CAF0(void *a1)
{
  void *v1; // edi@1
  void *i; // esi@1

  v1 = a1;
  for ( i = a1; !*((_BYTE *)i + 81); v1 = i )
  {
    sub_1004CAF0(*((_DWORD *)i + 2));
    i = *(void **)i;
    operator delete(v1);
  }
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004CB30) --------------------------------------------------------
int __thiscall sub_1004CB30(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@3
  int v4; // edx@5

  result = *(_DWORD *)(this + 8);
  *(_DWORD *)(this + 8) = *(_DWORD *)result;
  if ( !*(_BYTE *)(*(_DWORD *)result + 81) )
    *(_DWORD *)(*(_DWORD *)result + 4) = this;
  *(_DWORD *)(result + 4) = *(_DWORD *)(this + 4);
  v3 = *(_DWORD *)(a2 + 4);
  if ( this == *(_DWORD *)(v3 + 4) )
  {
    *(_DWORD *)(v3 + 4) = result;
    *(_DWORD *)result = this;
    *(_DWORD *)(this + 4) = result;
  }
  else
  {
    v4 = *(_DWORD *)(this + 4);
    if ( this == *(_DWORD *)v4 )
    {
      *(_DWORD *)v4 = result;
      *(_DWORD *)result = this;
      *(_DWORD *)(this + 4) = result;
    }
    else
    {
      *(_DWORD *)(v4 + 8) = result;
      *(_DWORD *)result = this;
      *(_DWORD *)(this + 4) = result;
    }
  }
  return result;
}

//----- (1004CB80) --------------------------------------------------------
int __thiscall sub_1004CB80(_DWORD *this, int a2)
{
  int result; // eax@1
  int v3; // edx@1
  int v4; // edx@3
  int v5; // edx@5

  result = *this;
  *this = *(_DWORD *)(*this + 8);
  v3 = *(_DWORD *)(result + 8);
  if ( !*(_BYTE *)(v3 + 81) )
    *(_DWORD *)(v3 + 4) = this;
  *(_DWORD *)(result + 4) = this[1];
  v4 = *(_DWORD *)(a2 + 4);
  if ( this == *(_DWORD **)(v4 + 4) )
  {
    *(_DWORD *)(v4 + 4) = result;
    *(_DWORD *)(result + 8) = this;
    this[1] = result;
  }
  else
  {
    v5 = this[1];
    if ( this == *(_DWORD **)(v5 + 8) )
    {
      *(_DWORD *)(v5 + 8) = result;
      *(_DWORD *)(result + 8) = this;
      this[1] = result;
    }
    else
    {
      *(_DWORD *)v5 = result;
      *(_DWORD *)(result + 8) = this;
      this[1] = result;
    }
  }
  return result;
}

//----- (1004CBD0) --------------------------------------------------------
int __usercall sub_1004CBD0@<eax>(int result@<eax>)
{
  int i; // ecx@1

  for ( i = *(_DWORD *)(result + 8); !*(_BYTE *)(i + 81); i = *(_DWORD *)(i + 8) )
    result = i;
  return result;
}

//----- (1004CBF0) --------------------------------------------------------
int __usercall sub_1004CBF0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  int v3; // edx@1
  int v4; // eax@1
  int i; // ecx@1

  v2 = a1;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  sub_100943C0(*(_DWORD *)(a1 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040A40, a2, 0, 0xCu, 0);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_DWORD *)a2;
  *(_DWORD *)(a2 + 4) = v3;
  for ( i = *(_DWORD *)v2; v3; --v3 )
  {
    if ( v4 )
    {
      *(float *)v4 = *(float *)i;
      *(float *)(v4 + 4) = *(float *)(i + 4);
      *(_DWORD *)(v4 + 8) = *(_DWORD *)(i + 8);
    }
    v4 += 12;
    i += 12;
  }
  return a2;
}
// 10040A40: using guessed type int sub_10040A40();

//----- (1004CC60) --------------------------------------------------------
int __usercall sub_1004CC60@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  int v3; // edx@1
  int v4; // eax@1
  int i; // ecx@1

  v2 = a1;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  sub_100943C0(*(_DWORD *)(a1 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003B7E0, a2, 0, 0x1Cu, 0);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_DWORD *)a2;
  *(_DWORD *)(a2 + 4) = v3;
  for ( i = *(_DWORD *)v2; v3; --v3 )
  {
    if ( v4 )
    {
      *(float *)v4 = *(float *)i;
      *(float *)(v4 + 4) = *(float *)(i + 4);
      *(float *)(v4 + 8) = *(float *)(i + 8);
      *(float *)(v4 + 12) = *(float *)(i + 12);
      *(float *)(v4 + 16) = *(float *)(i + 16);
      *(float *)(v4 + 20) = *(float *)(i + 20);
      *(_DWORD *)(v4 + 24) = *(_DWORD *)(i + 24);
    }
    v4 += 28;
    i += 28;
  }
  return a2;
}

//----- (1004CCE0) --------------------------------------------------------
int __usercall sub_1004CCE0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  int v3; // edx@1
  int v4; // eax@1
  int i; // ecx@1

  v2 = a1;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  sub_100943C0(*(_DWORD *)(a1 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C600, a2, 0, 0x10u, 0);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_DWORD *)a2;
  *(_DWORD *)(a2 + 4) = v3;
  for ( i = *(_DWORD *)v2; v3; --v3 )
  {
    if ( v4 )
    {
      *(float *)v4 = *(float *)i;
      *(float *)(v4 + 4) = *(float *)(i + 4);
      *(float *)(v4 + 8) = *(float *)(i + 8);
      *(_DWORD *)(v4 + 12) = *(_DWORD *)(i + 12);
    }
    v4 += 16;
    i += 16;
  }
  return a2;
}
// 1004C600: using guessed type int sub_1004C600();

//----- (1004CD50) --------------------------------------------------------
int __usercall sub_1004CD50@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  int v3; // ecx@1
  int v4; // eax@1
  int i; // edi@1

  v2 = a1;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  sub_100943C0(*(_DWORD *)(a1 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004C650, a2, 0, 8u, 0);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_DWORD *)a2;
  *(_DWORD *)(a2 + 4) = v3;
  for ( i = *(_DWORD *)v2; v3; --v3 )
  {
    if ( v4 )
    {
      *(float *)v4 = *(float *)i;
      *(_DWORD *)(v4 + 4) = *(_DWORD *)(i + 4);
    }
    v4 += 8;
    i += 8;
  }
  return a2;
}
// 1004C650: using guessed type int sub_1004C650();

//----- (1004CDB0) --------------------------------------------------------
int __usercall sub_1004CDB0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // ebx@1
  int v3; // edi@1
  int v4; // ebp@1
  int i; // ebx@1

  v2 = a1;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  sub_100943C0(*(_DWORD *)(a1 + 4), (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003DD80, a2, 0, 0x44u, 0);
  v3 = *(_DWORD *)a2;
  v4 = *(_DWORD *)(v2 + 4);
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)v2; v4; --v4 )
  {
    if ( v3 )
    {
      sub_1003DDC0(v3, i);
      *(_DWORD *)(v3 + 64) = *(_DWORD *)(i + 64);
    }
    v3 += 68;
    i += 68;
  }
  return a2;
}

//----- (1004CE10) --------------------------------------------------------
int __usercall sub_1004CE10@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // edx@1

  v2 = result + 40 * a2;
  if ( result != v2 )
  {
    result += 8;
    do
    {
      if ( result != 8 )
      {
        *(_DWORD *)(result - 8) = 0;
        *(_DWORD *)(result - 4) = 0;
        *(_DWORD *)result = 0;
        *(_DWORD *)(result + 4) = 0;
        *(_DWORD *)(result + 8) = 0;
        *(_DWORD *)(result + 16) = 0;
        *(_DWORD *)(result + 20) = 0;
        *(_BYTE *)(result + 24) = 0;
      }
      result += 40;
    }
    while ( result - 8 != v2 );
  }
  return result;
}

//----- (1004CE50) --------------------------------------------------------
void __usercall sub_1004CE50(int a1@<eax>, int *a2@<ecx>)
{
  int *v2; // esi@1
  int v3; // edi@1
  int v4; // eax@2

  v2 = a2;
  v3 = (int)&a2[10 * a1];
  if ( a2 != (int *)v3 )
  {
    do
    {
      v4 = *v2;
      if ( *v2 )
      {
        if ( v4 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
      }
      v2 += 10;
    }
    while ( v2 != (int *)v3 );
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1004CEA0) --------------------------------------------------------
void __usercall sub_1004CEA0(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@1
  int v3; // edi@1
  int *v4; // esi@2
  int v5; // eax@3

  v2 = a1 << 6;
  v3 = a2 + v2;
  if ( a2 != a2 + v2 )
  {
    v4 = (int *)(a2 + 36);
    do
    {
      v5 = *v4;
      if ( *v4 )
      {
        if ( v5 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      }
      v4 += 16;
    }
    while ( v4 - 9 != (int *)v3 );
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1004CEF0) --------------------------------------------------------
int __usercall sub_1004CEF0@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // edi@1
  int *v3; // esi@2

  v2 = result + 56 * a2;
  if ( result != v2 )
  {
    v3 = (int *)(result + 28);
    do
    {
      result = *v3;
      if ( *v3 )
      {
        if ( result & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          result = off_100AD9F4(result, 0, 0, 1, dword_100AE9F4);
      }
      v3 += 14;
    }
    while ( v3 - 7 != (int *)v2 );
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1004CF40) --------------------------------------------------------
void __usercall sub_1004CF40(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@1
  int v3; // edi@1
  int *v4; // esi@2
  int v5; // eax@3

  v2 = 104 * a1;
  v3 = a2 + v2;
  if ( a2 != a2 + v2 )
  {
    v4 = (int *)(a2 + 76);
    do
    {
      v5 = *v4;
      if ( *v4 )
      {
        if ( v5 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      }
      v4 += 26;
    }
    while ( v4 - 19 != (int *)v3 );
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1004CF90) --------------------------------------------------------
int __usercall sub_1004CF90@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // esi@1

  v2 = result + 56 * a2;
  if ( result != v2 )
  {
    result += 36;
    do
    {
      if ( result != 36 )
      {
        *(_DWORD *)(result - 36) = 0;
        *(_DWORD *)(result - 32) = 0;
        *(_DWORD *)(result - 28) = 0;
        *(_DWORD *)(result - 20) = 0;
        *(_DWORD *)(result - 16) = 0;
        *(_DWORD *)(result - 8) = 0;
        *(_DWORD *)(result - 4) = 0;
        *(_DWORD *)result = 0;
        *(_DWORD *)(result + 4) = -1;
        *(_DWORD *)(result + 8) = -1;
        *(_DWORD *)(result + 12) = -1;
        *(_BYTE *)(result + 16) = 0;
      }
      result += 56;
    }
    while ( result - 36 != v2 );
  }
  return result;
}

//----- (1004CFF0) --------------------------------------------------------
int __usercall sub_1004CFF0@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // ecx@1

  v2 = result + 48 * a2;
  if ( result != v2 )
  {
    result += 28;
    do
    {
      if ( result != 28 )
      {
        *(float *)(result - 28) = 0.0;
        *(_DWORD *)(result - 20) = 0;
        *(_DWORD *)(result - 16) = 0;
        *(_DWORD *)(result - 8) = 0;
        *(_DWORD *)(result - 4) = 0;
        *(_DWORD *)result = 0;
        *(_DWORD *)(result + 4) = -1;
        *(_DWORD *)(result + 8) = -1;
        *(_DWORD *)(result + 12) = -1;
        *(_BYTE *)(result + 16) = 0;
      }
      result += 48;
    }
    while ( result - 28 != v2 );
  }
  return result;
}

//----- (1004D040) --------------------------------------------------------
char *__usercall sub_1004D040@<eax>(int a1@<eax>, char *a2@<ecx>)
{
  char *result; // eax@1
  int v3; // ebp@1
  int v4; // esi@2

  result = (char *)(104 * a1);
  v3 = (int)&result[(_DWORD)a2];
  if ( a2 != &result[(_DWORD)a2] )
  {
    v4 = (int)(a2 + 84);
    do
    {
      result = (char *)(v4 - 84);
      if ( v4 != 84 )
      {
        result = (char *)memset((void *)(v4 - 84), 0, 0x40u);
        *(_DWORD *)(v4 - 20) = 0;
        *(_DWORD *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        *(_DWORD *)(v4 - 4) = 0;
        *(_DWORD *)v4 = 0;
        *(_DWORD *)(v4 + 4) = -1;
        *(_DWORD *)(v4 + 8) = -1;
        *(_DWORD *)(v4 + 12) = -1;
        *(_BYTE *)(v4 + 16) = 0;
      }
      v4 += 104;
    }
    while ( v4 - 84 != v3 );
  }
  return result;
}

//----- (1004D0A0) --------------------------------------------------------
void *__usercall sub_1004D0A0@<eax>(unsigned int a1@<eax>)
{
  void *result; // eax@2
  int (__stdcall **v2)(char); // [sp+0h] [bp-10h]@3
  char v3; // [sp+4h] [bp-Ch]@3

  if ( a1 > 0x9249249 || (result = operator new(28 * a1)) == 0 )
  {
    v2 = 0;
    std::exception::exception((std::exception *)&v3, (const char *const *)&v2);
    v2 = &off_10099840;
    CxxThrowException(&v2, &unk_100A5EA0);
  }
  return result;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (1004D100) --------------------------------------------------------
int __userpurge sub_1004D100@<eax>(int a1@<ebx>, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebp@1
  bool v5; // zf@1
  int v6; // edi@1
  char v7; // al@1
  float *v8; // ecx@2
  unsigned int v9; // edx@2
  int v10; // esi@2
  int v11; // esi@13
  int result; // eax@15
  int v13; // [sp+Ch] [bp-8h]@13
  int v14; // [sp+10h] [bp-4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4);
  v5 = *(_BYTE *)(v4 + 25) == 0;
  v6 = *(_DWORD *)(a2 + 4);
  v7 = 1;
  LOBYTE(v14) = 1;
  if ( v5 )
  {
    do
    {
      v8 = (float *)(v4 + 12);
      v9 = 0;
      v6 = v4;
      v10 = a3 + 12 - (v4 + 12);
      while ( *v8 <= (double)*(float *)((char *)v8 + v10) )
      {
        if ( *v8 == *(float *)((char *)v8 + v10) )
        {
          ++v9;
          ++v8;
          if ( v9 < 2 )
            continue;
        }
        v7 = 0;
        goto LABEL_7;
      }
      v7 = 1;
LABEL_7:
      LOBYTE(v14) = v7;
      if ( v7 )
        v4 = *(_DWORD *)v4;
      else
        v4 = *(_DWORD *)(v4 + 8);
    }
    while ( !*(_BYTE *)(v4 + 25) );
    v3 = a2;
  }
  v11 = v6;
  v13 = v6;
  if ( v7 )
  {
    if ( v6 == **(_DWORD **)(v3 + 4) )
    {
      *(_DWORD *)a1 = *sub_1004D6A0(v6, v3, &a3, 1, a3);
      *(_BYTE *)(a1 + 4) = 1;
      return a1;
    }
    sub_1004E0B0((int)&v13);
    v11 = v13;
  }
  if ( sub_1004E030(v11 + 12, (float *)(a3 + 12)) )
  {
    *(_DWORD *)a1 = *sub_1004D6A0(v6, a2, &a3, v14, a3);
    *(_BYTE *)(a1 + 4) = 1;
    result = a1;
  }
  else
  {
    operator delete((void *)a3);
    *(_DWORD *)a1 = v11;
    *(_BYTE *)(a1 + 4) = 0;
    result = a1;
  }
  return result;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004D220) --------------------------------------------------------
int __userpurge sub_1004D220@<eax>(int a1@<ebx>, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebp@1
  bool v5; // zf@1
  int v6; // edi@1
  char v7; // al@1
  float *v8; // ecx@2
  unsigned int v9; // edx@2
  int v10; // esi@2
  int v11; // esi@13
  int result; // eax@15
  int v13; // [sp+Ch] [bp-8h]@13
  int v14; // [sp+10h] [bp-4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4);
  v5 = *(_BYTE *)(v4 + 41) == 0;
  v6 = *(_DWORD *)(a2 + 4);
  v7 = 1;
  LOBYTE(v14) = 1;
  if ( v5 )
  {
    do
    {
      v8 = (float *)(v4 + 12);
      v9 = 0;
      v6 = v4;
      v10 = a3 + 12 - (v4 + 12);
      while ( *v8 <= (double)*(float *)((char *)v8 + v10) )
      {
        if ( *v8 == *(float *)((char *)v8 + v10) )
        {
          ++v9;
          ++v8;
          if ( v9 < 6 )
            continue;
        }
        v7 = 0;
        goto LABEL_7;
      }
      v7 = 1;
LABEL_7:
      LOBYTE(v14) = v7;
      if ( v7 )
        v4 = *(_DWORD *)v4;
      else
        v4 = *(_DWORD *)(v4 + 8);
    }
    while ( !*(_BYTE *)(v4 + 41) );
    v3 = a2;
  }
  v11 = v6;
  v13 = v6;
  if ( v7 )
  {
    if ( v6 == **(_DWORD **)(v3 + 4) )
    {
      *(_DWORD *)a1 = *sub_1004D870(v6, v3, &a3, 1, a3);
      *(_BYTE *)(a1 + 4) = 1;
      return a1;
    }
    sub_1004E110((int)&v13);
    v11 = v13;
  }
  if ( sub_1004DFF0(v11 + 12, (float *)(a3 + 12)) )
  {
    *(_DWORD *)a1 = *sub_1004D870(v6, a2, &a3, v14, a3);
    *(_BYTE *)(a1 + 4) = 1;
    result = a1;
  }
  else
  {
    operator delete((void *)a3);
    *(_DWORD *)a1 = v11;
    *(_BYTE *)(a1 + 4) = 0;
    result = a1;
  }
  return result;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004D340) --------------------------------------------------------
int __userpurge sub_1004D340@<eax>(int a1@<ebx>, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebp@1
  bool v5; // zf@1
  int v6; // edi@1
  char v7; // al@1
  float *v8; // ecx@2
  unsigned int v9; // edx@2
  int v10; // esi@2
  int v11; // esi@13
  int result; // eax@15
  int v13; // [sp+Ch] [bp-8h]@13
  int v14; // [sp+10h] [bp-4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4);
  v5 = *(_BYTE *)(v4 + 29) == 0;
  v6 = *(_DWORD *)(a2 + 4);
  v7 = 1;
  LOBYTE(v14) = 1;
  if ( v5 )
  {
    do
    {
      v8 = (float *)(v4 + 12);
      v9 = 0;
      v6 = v4;
      v10 = a3 + 12 - (v4 + 12);
      while ( *v8 <= (double)*(float *)((char *)v8 + v10) )
      {
        if ( *v8 == *(float *)((char *)v8 + v10) )
        {
          ++v9;
          ++v8;
          if ( v9 < 3 )
            continue;
        }
        v7 = 0;
        goto LABEL_7;
      }
      v7 = 1;
LABEL_7:
      LOBYTE(v14) = v7;
      if ( v7 )
        v4 = *(_DWORD *)v4;
      else
        v4 = *(_DWORD *)(v4 + 8);
    }
    while ( !*(_BYTE *)(v4 + 29) );
    v3 = a2;
  }
  v11 = v6;
  v13 = v6;
  if ( v7 )
  {
    if ( v6 == **(_DWORD **)(v3 + 4) )
    {
      *(_DWORD *)a1 = *sub_1004DA40(v6, v3, &a3, 1, a3);
      *(_BYTE *)(a1 + 4) = 1;
      return a1;
    }
    sub_1004E170((int)&v13);
    v11 = v13;
  }
  if ( sub_1004DFB0(v11 + 12, (float *)(a3 + 12)) )
  {
    *(_DWORD *)a1 = *sub_1004DA40(v6, a2, &a3, v14, a3);
    *(_BYTE *)(a1 + 4) = 1;
    result = a1;
  }
  else
  {
    operator delete((void *)a3);
    *(_DWORD *)a1 = v11;
    *(_BYTE *)(a1 + 4) = 0;
    result = a1;
  }
  return result;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004D460) --------------------------------------------------------
int __userpurge sub_1004D460@<eax>(int a1@<ebx>, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebp@1
  bool v5; // zf@1
  int v6; // edi@1
  char v7; // al@1
  float *v8; // ecx@2
  unsigned int v9; // edx@2
  int v10; // esi@2
  int v11; // esi@13
  int result; // eax@15
  int v13; // [sp+Ch] [bp-8h]@13
  int v14; // [sp+10h] [bp-4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4);
  v5 = *(_BYTE *)(v4 + 21) == 0;
  v6 = *(_DWORD *)(a2 + 4);
  v7 = 1;
  LOBYTE(v14) = 1;
  if ( v5 )
  {
    do
    {
      v8 = (float *)(v4 + 12);
      v9 = 0;
      v6 = v4;
      v10 = a3 + 12 - (v4 + 12);
      while ( *v8 <= (double)*(float *)((char *)v8 + v10) )
      {
        if ( *v8 == *(float *)((char *)v8 + v10) )
        {
          ++v9;
          ++v8;
          if ( v9 < 1 )
            continue;
        }
        v7 = 0;
        goto LABEL_7;
      }
      v7 = 1;
LABEL_7:
      LOBYTE(v14) = v7;
      if ( v7 )
        v4 = *(_DWORD *)v4;
      else
        v4 = *(_DWORD *)(v4 + 8);
    }
    while ( !*(_BYTE *)(v4 + 21) );
    v3 = a2;
  }
  v11 = v6;
  v13 = v6;
  if ( v7 )
  {
    if ( v6 == **(_DWORD **)(v3 + 4) )
    {
      *(_DWORD *)a1 = *sub_1004DC10(v6, v3, &a3, 1, a3);
      *(_BYTE *)(a1 + 4) = 1;
      return a1;
    }
    sub_1004E1D0((int)&v13);
    v11 = v13;
  }
  if ( sub_10048A20(v11 + 12, (float *)(a3 + 12)) )
  {
    *(_DWORD *)a1 = *sub_1004DC10(v6, a2, &a3, v14, a3);
    *(_BYTE *)(a1 + 4) = 1;
    result = a1;
  }
  else
  {
    operator delete((void *)a3);
    *(_DWORD *)a1 = v11;
    *(_BYTE *)(a1 + 4) = 0;
    result = a1;
  }
  return result;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004D580) --------------------------------------------------------
int __userpurge sub_1004D580@<eax>(int a1@<ebx>, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebp@1
  bool v5; // zf@1
  int v6; // edi@1
  char v7; // al@1
  float *v8; // ecx@2
  unsigned int v9; // edx@2
  int v10; // esi@2
  int v11; // esi@13
  int result; // eax@15
  int v13; // [sp+Ch] [bp-8h]@13
  int v14; // [sp+10h] [bp-4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4);
  v5 = *(_BYTE *)(v4 + 81) == 0;
  v6 = *(_DWORD *)(a2 + 4);
  v7 = 1;
  LOBYTE(v14) = 1;
  if ( v5 )
  {
    do
    {
      v8 = (float *)(v4 + 12);
      v9 = 0;
      v6 = v4;
      v10 = a3 + 12 - (v4 + 12);
      while ( *v8 <= (double)*(float *)((char *)v8 + v10) )
      {
        if ( *v8 == *(float *)((char *)v8 + v10) )
        {
          ++v9;
          ++v8;
          if ( v9 < 0x10 )
            continue;
        }
        v7 = 0;
        goto LABEL_7;
      }
      v7 = 1;
LABEL_7:
      LOBYTE(v14) = v7;
      if ( v7 )
        v4 = *(_DWORD *)v4;
      else
        v4 = *(_DWORD *)(v4 + 8);
    }
    while ( !*(_BYTE *)(v4 + 81) );
    v3 = a2;
  }
  v11 = v6;
  v13 = v6;
  if ( v7 )
  {
    if ( v6 == **(_DWORD **)(v3 + 4) )
    {
      *(_DWORD *)a1 = *sub_1004DDE0(v6, v3, &a3, 1, a3);
      *(_BYTE *)(a1 + 4) = 1;
      return a1;
    }
    sub_1004E230((int)&v13);
    v11 = v13;
  }
  if ( sub_1004E070(v11 + 12, (float *)(a3 + 12)) )
  {
    *(_DWORD *)a1 = *sub_1004DDE0(v6, a2, &a3, v14, a3);
    *(_BYTE *)(a1 + 4) = 1;
    result = a1;
  }
  else
  {
    operator delete((void *)a3);
    *(_DWORD *)a1 = v11;
    *(_BYTE *)(a1 + 4) = 0;
    result = a1;
  }
  return result;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004D6A0) --------------------------------------------------------
_DWORD *__userpurge sub_1004D6A0@<eax>(int a1@<eax>, int a2@<edi>, _DWORD *a3, char a4, int a5)
{
  unsigned int v5; // ecx@1
  int v6; // ecx@3
  int v7; // ecx@4
  _DWORD *v8; // ecx@6
  int v9; // esi@10
  int v10; // eax@11
  int v11; // ecx@11
  int v12; // ecx@12
  int v13; // eax@14
  int v14; // ecx@16
  int v15; // ecx@18
  int v16; // eax@22
  int v17; // ecx@22
  int v18; // edx@22
  int v19; // edx@24
  int v20; // edx@26
  int v21; // edx@35
  int v22; // edx@37
  _DWORD *result; // eax@43

  v5 = *(_DWORD *)(a2 + 8);
  if ( v5 >= 0x15555554 )
  {
    operator delete((void *)a5);
    std::_Xlength_error("map/set<T> too long");
  }
  *(_DWORD *)(a2 + 8) = v5 + 1;
  *(_DWORD *)(a5 + 4) = a1;
  v6 = *(_DWORD *)(a2 + 4);
  if ( a1 == v6 )
  {
    *(_DWORD *)(v6 + 4) = a5;
    **(_DWORD **)(a2 + 4) = a5;
    v7 = *(_DWORD *)(a2 + 4);
LABEL_9:
    *(_DWORD *)(v7 + 8) = a5;
    goto LABEL_10;
  }
  if ( !a4 )
  {
    *(_DWORD *)(a1 + 8) = a5;
    v7 = *(_DWORD *)(a2 + 4);
    if ( a1 != *(_DWORD *)(v7 + 8) )
      goto LABEL_10;
    goto LABEL_9;
  }
  *(_DWORD *)a1 = a5;
  v8 = *(_DWORD **)(a2 + 4);
  if ( a1 == *v8 )
    *v8 = a5;
LABEL_10:
  v9 = a5;
  while ( !*(_BYTE *)(*(_DWORD *)(v9 + 4) + 24) )
  {
    v10 = *(_DWORD *)(v9 + 4);
    v11 = *(_DWORD *)(v10 + 4);
    if ( v10 == *(_DWORD *)v11 )
    {
      v12 = *(_DWORD *)(v11 + 8);
      if ( *(_BYTE *)(v12 + 24) )
      {
        if ( v9 == *(_DWORD *)(v10 + 8) )
        {
          v9 = *(_DWORD *)(v9 + 4);
          v13 = *(_DWORD *)(v10 + 8);
          *(_DWORD *)(v9 + 8) = *(_DWORD *)v13;
          if ( !*(_BYTE *)(*(_DWORD *)v13 + 25) )
            *(_DWORD *)(*(_DWORD *)v13 + 4) = v9;
          *(_DWORD *)(v13 + 4) = *(_DWORD *)(v9 + 4);
          v14 = *(_DWORD *)(a2 + 4);
          if ( v9 == *(_DWORD *)(v14 + 4) )
          {
            *(_DWORD *)(v14 + 4) = v13;
          }
          else
          {
            v15 = *(_DWORD *)(v9 + 4);
            if ( v9 == *(_DWORD *)v15 )
              *(_DWORD *)v15 = v13;
            else
              *(_DWORD *)(v15 + 8) = v13;
          }
          *(_DWORD *)v13 = v9;
          *(_DWORD *)(v9 + 4) = v13;
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 24) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 24) = 0;
        v16 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)v16;
        *(_DWORD *)v16 = *(_DWORD *)(*(_DWORD *)v16 + 8);
        v18 = *(_DWORD *)(v17 + 8);
        if ( !*(_BYTE *)(v18 + 25) )
          *(_DWORD *)(v18 + 4) = v16;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v16 + 4);
        v19 = *(_DWORD *)(a2 + 4);
        if ( v16 == *(_DWORD *)(v19 + 4) )
        {
          *(_DWORD *)(v19 + 4) = v17;
          *(_DWORD *)(v17 + 8) = v16;
        }
        else
        {
          v20 = *(_DWORD *)(v16 + 4);
          if ( v16 == *(_DWORD *)(v20 + 8) )
          {
            *(_DWORD *)(v20 + 8) = v17;
            *(_DWORD *)(v17 + 8) = v16;
          }
          else
          {
            *(_DWORD *)v20 = v17;
            *(_DWORD *)(v17 + 8) = v16;
          }
        }
LABEL_41:
        *(_DWORD *)(v16 + 4) = v17;
        continue;
      }
    }
    else
    {
      v12 = *(_DWORD *)v11;
      if ( *(_BYTE *)(v12 + 24) )
      {
        if ( v9 == *(_DWORD *)v10 )
        {
          v9 = *(_DWORD *)(v9 + 4);
          sub_1004C780((_DWORD *)v10, a2);
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 24) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 24) = 0;
        v16 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)(v16 + 8);
        *(_DWORD *)(v16 + 8) = *(_DWORD *)v17;
        if ( !*(_BYTE *)(*(_DWORD *)v17 + 25) )
          *(_DWORD *)(*(_DWORD *)v17 + 4) = v16;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v16 + 4);
        v21 = *(_DWORD *)(a2 + 4);
        if ( v16 == *(_DWORD *)(v21 + 4) )
        {
          *(_DWORD *)(v21 + 4) = v17;
        }
        else
        {
          v22 = *(_DWORD *)(v16 + 4);
          if ( v16 == *(_DWORD *)v22 )
            *(_DWORD *)v22 = v17;
          else
            *(_DWORD *)(v22 + 8) = v17;
        }
        *(_DWORD *)v17 = v16;
        goto LABEL_41;
      }
    }
    *(_BYTE *)(v10 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 1;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 24) = 0;
    v9 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
  }
  result = a3;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) + 24) = 1;
  *a3 = a5;
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004D870) --------------------------------------------------------
_DWORD *__userpurge sub_1004D870@<eax>(int a1@<eax>, int a2@<edi>, _DWORD *a3, char a4, int a5)
{
  unsigned int v5; // ecx@1
  int v6; // ecx@3
  int v7; // ecx@4
  _DWORD *v8; // ecx@6
  int v9; // esi@10
  int v10; // eax@11
  int v11; // ecx@11
  int v12; // ecx@12
  int v13; // eax@14
  int v14; // ecx@16
  int v15; // ecx@18
  int v16; // eax@22
  int v17; // ecx@22
  int v18; // edx@22
  int v19; // edx@24
  int v20; // edx@26
  int v21; // edx@35
  int v22; // edx@37
  _DWORD *result; // eax@43

  v5 = *(_DWORD *)(a2 + 8);
  if ( v5 >= 0x9249248 )
  {
    operator delete((void *)a5);
    std::_Xlength_error("map/set<T> too long");
  }
  *(_DWORD *)(a2 + 8) = v5 + 1;
  *(_DWORD *)(a5 + 4) = a1;
  v6 = *(_DWORD *)(a2 + 4);
  if ( a1 == v6 )
  {
    *(_DWORD *)(v6 + 4) = a5;
    **(_DWORD **)(a2 + 4) = a5;
    v7 = *(_DWORD *)(a2 + 4);
LABEL_9:
    *(_DWORD *)(v7 + 8) = a5;
    goto LABEL_10;
  }
  if ( !a4 )
  {
    *(_DWORD *)(a1 + 8) = a5;
    v7 = *(_DWORD *)(a2 + 4);
    if ( a1 != *(_DWORD *)(v7 + 8) )
      goto LABEL_10;
    goto LABEL_9;
  }
  *(_DWORD *)a1 = a5;
  v8 = *(_DWORD **)(a2 + 4);
  if ( a1 == *v8 )
    *v8 = a5;
LABEL_10:
  v9 = a5;
  while ( !*(_BYTE *)(*(_DWORD *)(v9 + 4) + 40) )
  {
    v10 = *(_DWORD *)(v9 + 4);
    v11 = *(_DWORD *)(v10 + 4);
    if ( v10 == *(_DWORD *)v11 )
    {
      v12 = *(_DWORD *)(v11 + 8);
      if ( *(_BYTE *)(v12 + 40) )
      {
        if ( v9 == *(_DWORD *)(v10 + 8) )
        {
          v9 = *(_DWORD *)(v9 + 4);
          v13 = *(_DWORD *)(v10 + 8);
          *(_DWORD *)(v9 + 8) = *(_DWORD *)v13;
          if ( !*(_BYTE *)(*(_DWORD *)v13 + 41) )
            *(_DWORD *)(*(_DWORD *)v13 + 4) = v9;
          *(_DWORD *)(v13 + 4) = *(_DWORD *)(v9 + 4);
          v14 = *(_DWORD *)(a2 + 4);
          if ( v9 == *(_DWORD *)(v14 + 4) )
          {
            *(_DWORD *)(v14 + 4) = v13;
          }
          else
          {
            v15 = *(_DWORD *)(v9 + 4);
            if ( v9 == *(_DWORD *)v15 )
              *(_DWORD *)v15 = v13;
            else
              *(_DWORD *)(v15 + 8) = v13;
          }
          *(_DWORD *)v13 = v9;
          *(_DWORD *)(v9 + 4) = v13;
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 40) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 40) = 0;
        v16 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)v16;
        *(_DWORD *)v16 = *(_DWORD *)(*(_DWORD *)v16 + 8);
        v18 = *(_DWORD *)(v17 + 8);
        if ( !*(_BYTE *)(v18 + 41) )
          *(_DWORD *)(v18 + 4) = v16;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v16 + 4);
        v19 = *(_DWORD *)(a2 + 4);
        if ( v16 == *(_DWORD *)(v19 + 4) )
        {
          *(_DWORD *)(v19 + 4) = v17;
          *(_DWORD *)(v17 + 8) = v16;
        }
        else
        {
          v20 = *(_DWORD *)(v16 + 4);
          if ( v16 == *(_DWORD *)(v20 + 8) )
          {
            *(_DWORD *)(v20 + 8) = v17;
            *(_DWORD *)(v17 + 8) = v16;
          }
          else
          {
            *(_DWORD *)v20 = v17;
            *(_DWORD *)(v17 + 8) = v16;
          }
        }
LABEL_41:
        *(_DWORD *)(v16 + 4) = v17;
        continue;
      }
    }
    else
    {
      v12 = *(_DWORD *)v11;
      if ( *(_BYTE *)(v12 + 40) )
      {
        if ( v9 == *(_DWORD *)v10 )
        {
          v9 = *(_DWORD *)(v9 + 4);
          sub_1004C880((_DWORD *)v10, a2);
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 40) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 40) = 0;
        v16 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)(v16 + 8);
        *(_DWORD *)(v16 + 8) = *(_DWORD *)v17;
        if ( !*(_BYTE *)(*(_DWORD *)v17 + 41) )
          *(_DWORD *)(*(_DWORD *)v17 + 4) = v16;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v16 + 4);
        v21 = *(_DWORD *)(a2 + 4);
        if ( v16 == *(_DWORD *)(v21 + 4) )
        {
          *(_DWORD *)(v21 + 4) = v17;
        }
        else
        {
          v22 = *(_DWORD *)(v16 + 4);
          if ( v16 == *(_DWORD *)v22 )
            *(_DWORD *)v22 = v17;
          else
            *(_DWORD *)(v22 + 8) = v17;
        }
        *(_DWORD *)v17 = v16;
        goto LABEL_41;
      }
    }
    *(_BYTE *)(v10 + 40) = 1;
    *(_BYTE *)(v12 + 40) = 1;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 40) = 0;
    v9 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
  }
  result = a3;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) + 40) = 1;
  *a3 = a5;
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004DA40) --------------------------------------------------------
_DWORD *__userpurge sub_1004DA40@<eax>(int a1@<eax>, int a2@<edi>, _DWORD *a3, char a4, int a5)
{
  unsigned int v5; // ecx@1
  int v6; // ecx@3
  int v7; // ecx@4
  _DWORD *v8; // ecx@6
  int v9; // esi@10
  int v10; // eax@11
  int v11; // ecx@11
  int v12; // ecx@12
  int v13; // eax@14
  int v14; // ecx@16
  int v15; // ecx@18
  int v16; // eax@22
  int v17; // ecx@22
  int v18; // edx@22
  int v19; // edx@24
  int v20; // edx@26
  int v21; // edx@35
  int v22; // edx@37
  _DWORD *result; // eax@43

  v5 = *(_DWORD *)(a2 + 8);
  if ( v5 >= 0xFFFFFFE )
  {
    operator delete((void *)a5);
    std::_Xlength_error("map/set<T> too long");
  }
  *(_DWORD *)(a2 + 8) = v5 + 1;
  *(_DWORD *)(a5 + 4) = a1;
  v6 = *(_DWORD *)(a2 + 4);
  if ( a1 == v6 )
  {
    *(_DWORD *)(v6 + 4) = a5;
    **(_DWORD **)(a2 + 4) = a5;
    v7 = *(_DWORD *)(a2 + 4);
LABEL_9:
    *(_DWORD *)(v7 + 8) = a5;
    goto LABEL_10;
  }
  if ( !a4 )
  {
    *(_DWORD *)(a1 + 8) = a5;
    v7 = *(_DWORD *)(a2 + 4);
    if ( a1 != *(_DWORD *)(v7 + 8) )
      goto LABEL_10;
    goto LABEL_9;
  }
  *(_DWORD *)a1 = a5;
  v8 = *(_DWORD **)(a2 + 4);
  if ( a1 == *v8 )
    *v8 = a5;
LABEL_10:
  v9 = a5;
  while ( !*(_BYTE *)(*(_DWORD *)(v9 + 4) + 28) )
  {
    v10 = *(_DWORD *)(v9 + 4);
    v11 = *(_DWORD *)(v10 + 4);
    if ( v10 == *(_DWORD *)v11 )
    {
      v12 = *(_DWORD *)(v11 + 8);
      if ( *(_BYTE *)(v12 + 28) )
      {
        if ( v9 == *(_DWORD *)(v10 + 8) )
        {
          v9 = *(_DWORD *)(v9 + 4);
          v13 = *(_DWORD *)(v10 + 8);
          *(_DWORD *)(v9 + 8) = *(_DWORD *)v13;
          if ( !*(_BYTE *)(*(_DWORD *)v13 + 29) )
            *(_DWORD *)(*(_DWORD *)v13 + 4) = v9;
          *(_DWORD *)(v13 + 4) = *(_DWORD *)(v9 + 4);
          v14 = *(_DWORD *)(a2 + 4);
          if ( v9 == *(_DWORD *)(v14 + 4) )
          {
            *(_DWORD *)(v14 + 4) = v13;
          }
          else
          {
            v15 = *(_DWORD *)(v9 + 4);
            if ( v9 == *(_DWORD *)v15 )
              *(_DWORD *)v15 = v13;
            else
              *(_DWORD *)(v15 + 8) = v13;
          }
          *(_DWORD *)v13 = v9;
          *(_DWORD *)(v9 + 4) = v13;
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 28) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 28) = 0;
        v16 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)v16;
        *(_DWORD *)v16 = *(_DWORD *)(*(_DWORD *)v16 + 8);
        v18 = *(_DWORD *)(v17 + 8);
        if ( !*(_BYTE *)(v18 + 29) )
          *(_DWORD *)(v18 + 4) = v16;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v16 + 4);
        v19 = *(_DWORD *)(a2 + 4);
        if ( v16 == *(_DWORD *)(v19 + 4) )
        {
          *(_DWORD *)(v19 + 4) = v17;
          *(_DWORD *)(v17 + 8) = v16;
        }
        else
        {
          v20 = *(_DWORD *)(v16 + 4);
          if ( v16 == *(_DWORD *)(v20 + 8) )
          {
            *(_DWORD *)(v20 + 8) = v17;
            *(_DWORD *)(v17 + 8) = v16;
          }
          else
          {
            *(_DWORD *)v20 = v17;
            *(_DWORD *)(v17 + 8) = v16;
          }
        }
LABEL_41:
        *(_DWORD *)(v16 + 4) = v17;
        continue;
      }
    }
    else
    {
      v12 = *(_DWORD *)v11;
      if ( *(_BYTE *)(v12 + 28) )
      {
        if ( v9 == *(_DWORD *)v10 )
        {
          v9 = *(_DWORD *)(v9 + 4);
          sub_1004C980((_DWORD *)v10, a2);
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 28) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 28) = 0;
        v16 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)(v16 + 8);
        *(_DWORD *)(v16 + 8) = *(_DWORD *)v17;
        if ( !*(_BYTE *)(*(_DWORD *)v17 + 29) )
          *(_DWORD *)(*(_DWORD *)v17 + 4) = v16;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v16 + 4);
        v21 = *(_DWORD *)(a2 + 4);
        if ( v16 == *(_DWORD *)(v21 + 4) )
        {
          *(_DWORD *)(v21 + 4) = v17;
        }
        else
        {
          v22 = *(_DWORD *)(v16 + 4);
          if ( v16 == *(_DWORD *)v22 )
            *(_DWORD *)v22 = v17;
          else
            *(_DWORD *)(v22 + 8) = v17;
        }
        *(_DWORD *)v17 = v16;
        goto LABEL_41;
      }
    }
    *(_BYTE *)(v10 + 28) = 1;
    *(_BYTE *)(v12 + 28) = 1;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 28) = 0;
    v9 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
  }
  result = a3;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) + 28) = 1;
  *a3 = a5;
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004DC10) --------------------------------------------------------
_DWORD *__userpurge sub_1004DC10@<eax>(int a1@<eax>, int a2@<edi>, _DWORD *a3, char a4, int a5)
{
  unsigned int v5; // ecx@1
  int v6; // ecx@3
  int v7; // ecx@4
  _DWORD *v8; // ecx@6
  int v9; // esi@10
  int v10; // eax@11
  int v11; // ecx@11
  int v12; // ecx@12
  int v13; // eax@14
  int v14; // ecx@16
  int v15; // ecx@18
  int v16; // eax@22
  int v17; // ecx@22
  int v18; // edx@22
  int v19; // edx@24
  int v20; // edx@26
  int v21; // edx@35
  int v22; // edx@37
  _DWORD *result; // eax@43

  v5 = *(_DWORD *)(a2 + 8);
  if ( v5 >= 0x1FFFFFFE )
  {
    operator delete((void *)a5);
    std::_Xlength_error("map/set<T> too long");
  }
  *(_DWORD *)(a2 + 8) = v5 + 1;
  *(_DWORD *)(a5 + 4) = a1;
  v6 = *(_DWORD *)(a2 + 4);
  if ( a1 == v6 )
  {
    *(_DWORD *)(v6 + 4) = a5;
    **(_DWORD **)(a2 + 4) = a5;
    v7 = *(_DWORD *)(a2 + 4);
LABEL_9:
    *(_DWORD *)(v7 + 8) = a5;
    goto LABEL_10;
  }
  if ( !a4 )
  {
    *(_DWORD *)(a1 + 8) = a5;
    v7 = *(_DWORD *)(a2 + 4);
    if ( a1 != *(_DWORD *)(v7 + 8) )
      goto LABEL_10;
    goto LABEL_9;
  }
  *(_DWORD *)a1 = a5;
  v8 = *(_DWORD **)(a2 + 4);
  if ( a1 == *v8 )
    *v8 = a5;
LABEL_10:
  v9 = a5;
  while ( !*(_BYTE *)(*(_DWORD *)(v9 + 4) + 20) )
  {
    v10 = *(_DWORD *)(v9 + 4);
    v11 = *(_DWORD *)(v10 + 4);
    if ( v10 == *(_DWORD *)v11 )
    {
      v12 = *(_DWORD *)(v11 + 8);
      if ( *(_BYTE *)(v12 + 20) )
      {
        if ( v9 == *(_DWORD *)(v10 + 8) )
        {
          v9 = *(_DWORD *)(v9 + 4);
          v13 = *(_DWORD *)(v10 + 8);
          *(_DWORD *)(v9 + 8) = *(_DWORD *)v13;
          if ( !*(_BYTE *)(*(_DWORD *)v13 + 21) )
            *(_DWORD *)(*(_DWORD *)v13 + 4) = v9;
          *(_DWORD *)(v13 + 4) = *(_DWORD *)(v9 + 4);
          v14 = *(_DWORD *)(a2 + 4);
          if ( v9 == *(_DWORD *)(v14 + 4) )
          {
            *(_DWORD *)(v14 + 4) = v13;
          }
          else
          {
            v15 = *(_DWORD *)(v9 + 4);
            if ( v9 == *(_DWORD *)v15 )
              *(_DWORD *)v15 = v13;
            else
              *(_DWORD *)(v15 + 8) = v13;
          }
          *(_DWORD *)v13 = v9;
          *(_DWORD *)(v9 + 4) = v13;
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 20) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 20) = 0;
        v16 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)v16;
        *(_DWORD *)v16 = *(_DWORD *)(*(_DWORD *)v16 + 8);
        v18 = *(_DWORD *)(v17 + 8);
        if ( !*(_BYTE *)(v18 + 21) )
          *(_DWORD *)(v18 + 4) = v16;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v16 + 4);
        v19 = *(_DWORD *)(a2 + 4);
        if ( v16 == *(_DWORD *)(v19 + 4) )
        {
          *(_DWORD *)(v19 + 4) = v17;
          *(_DWORD *)(v17 + 8) = v16;
        }
        else
        {
          v20 = *(_DWORD *)(v16 + 4);
          if ( v16 == *(_DWORD *)(v20 + 8) )
          {
            *(_DWORD *)(v20 + 8) = v17;
            *(_DWORD *)(v17 + 8) = v16;
          }
          else
          {
            *(_DWORD *)v20 = v17;
            *(_DWORD *)(v17 + 8) = v16;
          }
        }
LABEL_41:
        *(_DWORD *)(v16 + 4) = v17;
        continue;
      }
    }
    else
    {
      v12 = *(_DWORD *)v11;
      if ( *(_BYTE *)(v12 + 20) )
      {
        if ( v9 == *(_DWORD *)v10 )
        {
          v9 = *(_DWORD *)(v9 + 4);
          sub_1004CA80((_DWORD *)v10, a2);
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 20) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 20) = 0;
        v16 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)(v16 + 8);
        *(_DWORD *)(v16 + 8) = *(_DWORD *)v17;
        if ( !*(_BYTE *)(*(_DWORD *)v17 + 21) )
          *(_DWORD *)(*(_DWORD *)v17 + 4) = v16;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v16 + 4);
        v21 = *(_DWORD *)(a2 + 4);
        if ( v16 == *(_DWORD *)(v21 + 4) )
        {
          *(_DWORD *)(v21 + 4) = v17;
        }
        else
        {
          v22 = *(_DWORD *)(v16 + 4);
          if ( v16 == *(_DWORD *)v22 )
            *(_DWORD *)v22 = v17;
          else
            *(_DWORD *)(v22 + 8) = v17;
        }
        *(_DWORD *)v17 = v16;
        goto LABEL_41;
      }
    }
    *(_BYTE *)(v10 + 20) = 1;
    *(_BYTE *)(v12 + 20) = 1;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 20) = 0;
    v9 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
  }
  result = a3;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) + 20) = 1;
  *a3 = a5;
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004DDE0) --------------------------------------------------------
_DWORD *__userpurge sub_1004DDE0@<eax>(int a1@<eax>, int a2@<edi>, _DWORD *a3, char a4, int a5)
{
  unsigned int v5; // ecx@1
  int v6; // ecx@3
  int v7; // ecx@4
  _DWORD *v8; // ecx@6
  int v9; // esi@10
  int v10; // eax@11
  int v11; // ecx@11
  int v12; // ecx@12
  int v13; // eax@14
  int v14; // ecx@16
  int v15; // ecx@18
  int v16; // eax@22
  int v17; // ecx@22
  int v18; // edx@22
  int v19; // edx@24
  int v20; // edx@26
  int v21; // edx@35
  int v22; // edx@37
  _DWORD *result; // eax@43

  v5 = *(_DWORD *)(a2 + 8);
  if ( v5 >= 0x3C3C3C2 )
  {
    operator delete((void *)a5);
    std::_Xlength_error("map/set<T> too long");
  }
  *(_DWORD *)(a2 + 8) = v5 + 1;
  *(_DWORD *)(a5 + 4) = a1;
  v6 = *(_DWORD *)(a2 + 4);
  if ( a1 == v6 )
  {
    *(_DWORD *)(v6 + 4) = a5;
    **(_DWORD **)(a2 + 4) = a5;
    v7 = *(_DWORD *)(a2 + 4);
LABEL_9:
    *(_DWORD *)(v7 + 8) = a5;
    goto LABEL_10;
  }
  if ( !a4 )
  {
    *(_DWORD *)(a1 + 8) = a5;
    v7 = *(_DWORD *)(a2 + 4);
    if ( a1 != *(_DWORD *)(v7 + 8) )
      goto LABEL_10;
    goto LABEL_9;
  }
  *(_DWORD *)a1 = a5;
  v8 = *(_DWORD **)(a2 + 4);
  if ( a1 == *v8 )
    *v8 = a5;
LABEL_10:
  v9 = a5;
  while ( !*(_BYTE *)(*(_DWORD *)(v9 + 4) + 80) )
  {
    v10 = *(_DWORD *)(v9 + 4);
    v11 = *(_DWORD *)(v10 + 4);
    if ( v10 == *(_DWORD *)v11 )
    {
      v12 = *(_DWORD *)(v11 + 8);
      if ( *(_BYTE *)(v12 + 80) )
      {
        if ( v9 == *(_DWORD *)(v10 + 8) )
        {
          v9 = *(_DWORD *)(v9 + 4);
          v13 = *(_DWORD *)(v10 + 8);
          *(_DWORD *)(v9 + 8) = *(_DWORD *)v13;
          if ( !*(_BYTE *)(*(_DWORD *)v13 + 81) )
            *(_DWORD *)(*(_DWORD *)v13 + 4) = v9;
          *(_DWORD *)(v13 + 4) = *(_DWORD *)(v9 + 4);
          v14 = *(_DWORD *)(a2 + 4);
          if ( v9 == *(_DWORD *)(v14 + 4) )
          {
            *(_DWORD *)(v14 + 4) = v13;
          }
          else
          {
            v15 = *(_DWORD *)(v9 + 4);
            if ( v9 == *(_DWORD *)v15 )
              *(_DWORD *)v15 = v13;
            else
              *(_DWORD *)(v15 + 8) = v13;
          }
          *(_DWORD *)v13 = v9;
          *(_DWORD *)(v9 + 4) = v13;
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 80) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 80) = 0;
        v16 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)v16;
        *(_DWORD *)v16 = *(_DWORD *)(*(_DWORD *)v16 + 8);
        v18 = *(_DWORD *)(v17 + 8);
        if ( !*(_BYTE *)(v18 + 81) )
          *(_DWORD *)(v18 + 4) = v16;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v16 + 4);
        v19 = *(_DWORD *)(a2 + 4);
        if ( v16 == *(_DWORD *)(v19 + 4) )
        {
          *(_DWORD *)(v19 + 4) = v17;
          *(_DWORD *)(v17 + 8) = v16;
        }
        else
        {
          v20 = *(_DWORD *)(v16 + 4);
          if ( v16 == *(_DWORD *)(v20 + 8) )
          {
            *(_DWORD *)(v20 + 8) = v17;
            *(_DWORD *)(v17 + 8) = v16;
          }
          else
          {
            *(_DWORD *)v20 = v17;
            *(_DWORD *)(v17 + 8) = v16;
          }
        }
LABEL_41:
        *(_DWORD *)(v16 + 4) = v17;
        continue;
      }
    }
    else
    {
      v12 = *(_DWORD *)v11;
      if ( *(_BYTE *)(v12 + 80) )
      {
        if ( v9 == *(_DWORD *)v10 )
        {
          v9 = *(_DWORD *)(v9 + 4);
          sub_1004CB80((_DWORD *)v10, a2);
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 80) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 80) = 0;
        v16 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)(v16 + 8);
        *(_DWORD *)(v16 + 8) = *(_DWORD *)v17;
        if ( !*(_BYTE *)(*(_DWORD *)v17 + 81) )
          *(_DWORD *)(*(_DWORD *)v17 + 4) = v16;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v16 + 4);
        v21 = *(_DWORD *)(a2 + 4);
        if ( v16 == *(_DWORD *)(v21 + 4) )
        {
          *(_DWORD *)(v21 + 4) = v17;
        }
        else
        {
          v22 = *(_DWORD *)(v16 + 4);
          if ( v16 == *(_DWORD *)v22 )
            *(_DWORD *)v22 = v17;
          else
            *(_DWORD *)(v22 + 8) = v17;
        }
        *(_DWORD *)v17 = v16;
        goto LABEL_41;
      }
    }
    *(_BYTE *)(v10 + 80) = 1;
    *(_BYTE *)(v12 + 80) = 1;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 80) = 0;
    v9 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
  }
  result = a3;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) + 80) = 1;
  *a3 = a5;
  return result;
}
// 100990E4: using guessed type void __cdecl std::_Xlength_error(const char *);
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1004DFB0) --------------------------------------------------------
char __usercall sub_1004DFB0@<al>(int a1@<eax>, float *a2@<ecx>)
{
  unsigned int v2; // edx@1
  int v3; // esi@1

  v2 = 0;
  v3 = a1 - (_DWORD)a2;
  while ( *a2 <= (double)*(float *)((char *)a2 + v3) )
  {
    if ( *a2 == *(float *)((char *)a2 + v3) )
    {
      ++v2;
      ++a2;
      if ( v2 < 3 )
        continue;
    }
    return 0;
  }
  return 1;
}

//----- (1004DFF0) --------------------------------------------------------
char __usercall sub_1004DFF0@<al>(int a1@<eax>, float *a2@<ecx>)
{
  unsigned int v2; // edx@1
  int v3; // esi@1

  v2 = 0;
  v3 = a1 - (_DWORD)a2;
  while ( *a2 <= (double)*(float *)((char *)a2 + v3) )
  {
    if ( *a2 == *(float *)((char *)a2 + v3) )
    {
      ++v2;
      ++a2;
      if ( v2 < 6 )
        continue;
    }
    return 0;
  }
  return 1;
}

//----- (1004E030) --------------------------------------------------------
char __usercall sub_1004E030@<al>(int a1@<eax>, float *a2@<ecx>)
{
  unsigned int v2; // edx@1
  int v3; // esi@1

  v2 = 0;
  v3 = a1 - (_DWORD)a2;
  while ( *a2 <= (double)*(float *)((char *)a2 + v3) )
  {
    if ( *a2 == *(float *)((char *)a2 + v3) )
    {
      ++v2;
      ++a2;
      if ( v2 < 2 )
        continue;
    }
    return 0;
  }
  return 1;
}

//----- (1004E070) --------------------------------------------------------
char __usercall sub_1004E070@<al>(int a1@<eax>, float *a2@<ecx>)
{
  unsigned int v2; // edx@1
  int v3; // esi@1

  v2 = 0;
  v3 = a1 - (_DWORD)a2;
  while ( *a2 <= (double)*(float *)((char *)a2 + v3) )
  {
    if ( *a2 == *(float *)((char *)a2 + v3) )
    {
      ++v2;
      ++a2;
      if ( v2 < 0x10 )
        continue;
    }
    return 0;
  }
  return 1;
}

//----- (1004E0B0) --------------------------------------------------------
int __usercall sub_1004E0B0@<eax>(int result@<eax>)
{
  int v1; // ecx@1
  int v2; // edx@3
  int j; // ecx@4
  int i; // ecx@7

  v1 = *(_DWORD *)result;
  if ( *(_BYTE *)(*(_DWORD *)result + 25) )
  {
    *(_DWORD *)result = *(_DWORD *)(v1 + 8);
  }
  else
  {
    v2 = *(_DWORD *)v1;
    if ( *(_BYTE *)(*(_DWORD *)v1 + 25) )
    {
      for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 25); i = *(_DWORD *)(i + 4) )
      {
        if ( *(_DWORD *)result != *(_DWORD *)i )
          break;
        *(_DWORD *)result = i;
      }
      if ( !*(_BYTE *)(*(_DWORD *)result + 25) )
        *(_DWORD *)result = i;
    }
    else
    {
      for ( j = *(_DWORD *)(v2 + 8); !*(_BYTE *)(j + 25); j = *(_DWORD *)(j + 8) )
        v2 = j;
      *(_DWORD *)result = v2;
    }
  }
  return result;
}

//----- (1004E110) --------------------------------------------------------
int __usercall sub_1004E110@<eax>(int result@<eax>)
{
  int v1; // ecx@1
  int v2; // edx@3
  int j; // ecx@4
  int i; // ecx@7

  v1 = *(_DWORD *)result;
  if ( *(_BYTE *)(*(_DWORD *)result + 41) )
  {
    *(_DWORD *)result = *(_DWORD *)(v1 + 8);
  }
  else
  {
    v2 = *(_DWORD *)v1;
    if ( *(_BYTE *)(*(_DWORD *)v1 + 41) )
    {
      for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 41); i = *(_DWORD *)(i + 4) )
      {
        if ( *(_DWORD *)result != *(_DWORD *)i )
          break;
        *(_DWORD *)result = i;
      }
      if ( !*(_BYTE *)(*(_DWORD *)result + 41) )
        *(_DWORD *)result = i;
    }
    else
    {
      for ( j = *(_DWORD *)(v2 + 8); !*(_BYTE *)(j + 41); j = *(_DWORD *)(j + 8) )
        v2 = j;
      *(_DWORD *)result = v2;
    }
  }
  return result;
}

//----- (1004E170) --------------------------------------------------------
int __usercall sub_1004E170@<eax>(int result@<eax>)
{
  int v1; // ecx@1
  int v2; // edx@3
  int j; // ecx@4
  int i; // ecx@7

  v1 = *(_DWORD *)result;
  if ( *(_BYTE *)(*(_DWORD *)result + 29) )
  {
    *(_DWORD *)result = *(_DWORD *)(v1 + 8);
  }
  else
  {
    v2 = *(_DWORD *)v1;
    if ( *(_BYTE *)(*(_DWORD *)v1 + 29) )
    {
      for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 29); i = *(_DWORD *)(i + 4) )
      {
        if ( *(_DWORD *)result != *(_DWORD *)i )
          break;
        *(_DWORD *)result = i;
      }
      if ( !*(_BYTE *)(*(_DWORD *)result + 29) )
        *(_DWORD *)result = i;
    }
    else
    {
      for ( j = *(_DWORD *)(v2 + 8); !*(_BYTE *)(j + 29); j = *(_DWORD *)(j + 8) )
        v2 = j;
      *(_DWORD *)result = v2;
    }
  }
  return result;
}

//----- (1004E1D0) --------------------------------------------------------
int __usercall sub_1004E1D0@<eax>(int result@<eax>)
{
  int v1; // ecx@1
  int v2; // edx@3
  int j; // ecx@4
  int i; // ecx@7

  v1 = *(_DWORD *)result;
  if ( *(_BYTE *)(*(_DWORD *)result + 21) )
  {
    *(_DWORD *)result = *(_DWORD *)(v1 + 8);
  }
  else
  {
    v2 = *(_DWORD *)v1;
    if ( *(_BYTE *)(*(_DWORD *)v1 + 21) )
    {
      for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 21); i = *(_DWORD *)(i + 4) )
      {
        if ( *(_DWORD *)result != *(_DWORD *)i )
          break;
        *(_DWORD *)result = i;
      }
      if ( !*(_BYTE *)(*(_DWORD *)result + 21) )
        *(_DWORD *)result = i;
    }
    else
    {
      for ( j = *(_DWORD *)(v2 + 8); !*(_BYTE *)(j + 21); j = *(_DWORD *)(j + 8) )
        v2 = j;
      *(_DWORD *)result = v2;
    }
  }
  return result;
}

//----- (1004E230) --------------------------------------------------------
int __usercall sub_1004E230@<eax>(int result@<eax>)
{
  int v1; // ecx@1
  int v2; // edx@3
  int j; // ecx@4
  int i; // ecx@7

  v1 = *(_DWORD *)result;
  if ( *(_BYTE *)(*(_DWORD *)result + 81) )
  {
    *(_DWORD *)result = *(_DWORD *)(v1 + 8);
  }
  else
  {
    v2 = *(_DWORD *)v1;
    if ( *(_BYTE *)(*(_DWORD *)v1 + 81) )
    {
      for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 81); i = *(_DWORD *)(i + 4) )
      {
        if ( *(_DWORD *)result != *(_DWORD *)i )
          break;
        *(_DWORD *)result = i;
      }
      if ( !*(_BYTE *)(*(_DWORD *)result + 81) )
        *(_DWORD *)result = i;
    }
    else
    {
      for ( j = *(_DWORD *)(v2 + 8); !*(_BYTE *)(j + 81); j = *(_DWORD *)(j + 8) )
        v2 = j;
      *(_DWORD *)result = v2;
    }
  }
  return result;
}

//----- (1004E290) --------------------------------------------------------
_DWORD *__usercall sub_1004E290@<eax>(int a1@<edi>, int a2@<esi>)
{
  _DWORD *result; // eax@1

  result = sub_1004D0A0(1u);
  *result = *(_DWORD *)(a2 + 4);
  result[1] = *(_DWORD *)(a2 + 4);
  result[2] = *(_DWORD *)(a2 + 4);
  *((_WORD *)result + 12) = 0;
  if ( result != (_DWORD *)-12 )
  {
    *((float *)result + 3) = *(float *)a1;
    *((float *)result + 4) = *(float *)(a1 + 4);
    result[5] = *(_DWORD *)(a1 + 8);
  }
  return result;
}

//----- (1004E2D0) --------------------------------------------------------
_DWORD *__usercall sub_1004E2D0@<eax>(int a1@<edi>, int a2@<esi>)
{
  _DWORD *result; // eax@1
  int (__stdcall **v3)(char); // [sp+0h] [bp-10h]@5
  char v4; // [sp+4h] [bp-Ch]@5

  result = operator new(0x2Cu);
  if ( !result )
  {
    v3 = 0;
    std::exception::exception((std::exception *)&v4, (const char *const *)&v3);
    v3 = &off_10099840;
    CxxThrowException(&v3, &unk_100A5EA0);
  }
  *result = *(_DWORD *)(a1 + 4);
  result[1] = *(_DWORD *)(a1 + 4);
  result[2] = *(_DWORD *)(a1 + 4);
  *((_WORD *)result + 20) = 0;
  if ( result != (_DWORD *)-12 )
  {
    *((float *)result + 3) = *(float *)a2;
    *((float *)result + 4) = *(float *)(a2 + 4);
    *((float *)result + 5) = *(float *)(a2 + 8);
    *((float *)result + 6) = *(float *)(a2 + 12);
    *((float *)result + 7) = *(float *)(a2 + 16);
    *((float *)result + 8) = *(float *)(a2 + 20);
    result[9] = *(_DWORD *)(a2 + 24);
  }
  return result;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (1004E360) --------------------------------------------------------
_DWORD *__usercall sub_1004E360@<eax>(int a1@<edi>, int a2@<esi>)
{
  _DWORD *result; // eax@1
  int (__stdcall **v3)(char); // [sp+0h] [bp-10h]@5
  char v4; // [sp+4h] [bp-Ch]@5

  result = operator new(0x20u);
  if ( !result )
  {
    v3 = 0;
    std::exception::exception((std::exception *)&v4, (const char *const *)&v3);
    v3 = &off_10099840;
    CxxThrowException(&v3, &unk_100A5EA0);
  }
  *result = *(_DWORD *)(a2 + 4);
  result[1] = *(_DWORD *)(a2 + 4);
  result[2] = *(_DWORD *)(a2 + 4);
  *((_WORD *)result + 14) = 0;
  if ( result != (_DWORD *)-12 )
  {
    *((float *)result + 3) = *(float *)a1;
    *((float *)result + 4) = *(float *)(a1 + 4);
    *((float *)result + 5) = *(float *)(a1 + 8);
    result[6] = *(_DWORD *)(a1 + 12);
  }
  return result;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (1004E3E0) --------------------------------------------------------
_DWORD *__usercall sub_1004E3E0@<eax>(int a1@<edi>, int a2@<esi>)
{
  _DWORD *result; // eax@1
  int (__stdcall **v3)(char); // [sp+0h] [bp-10h]@5
  char v4; // [sp+4h] [bp-Ch]@5

  result = operator new(0x18u);
  if ( !result )
  {
    v3 = 0;
    std::exception::exception((std::exception *)&v4, (const char *const *)&v3);
    v3 = &off_10099840;
    CxxThrowException(&v3, &unk_100A5EA0);
  }
  *result = *(_DWORD *)(a2 + 4);
  result[1] = *(_DWORD *)(a2 + 4);
  result[2] = *(_DWORD *)(a2 + 4);
  *((_WORD *)result + 10) = 0;
  if ( result != (_DWORD *)-12 )
  {
    *((float *)result + 3) = *(float *)a1;
    result[4] = *(_DWORD *)(a1 + 4);
  }
  return result;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (1004E450) --------------------------------------------------------
_DWORD *__usercall sub_1004E450@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // edi@1
  _DWORD *v3; // esi@1
  int (__stdcall **v5)(char); // [sp+8h] [bp-10h]@5
  char v6; // [sp+Ch] [bp-Ch]@5

  v2 = a1;
  v3 = operator new(0x54u);
  if ( !v3 )
  {
    v5 = 0;
    std::exception::exception((std::exception *)&v6, (const char *const *)&v5);
    v5 = &off_10099840;
    CxxThrowException(&v5, &unk_100A5EA0);
  }
  *v3 = *(_DWORD *)(v2 + 4);
  v3[1] = *(_DWORD *)(v2 + 4);
  v3[2] = *(_DWORD *)(v2 + 4);
  *((_WORD *)v3 + 40) = 0;
  if ( v3 != (_DWORD *)-12 )
  {
    sub_1003DDC0((int)(v3 + 3), a2);
    v3[19] = *(_DWORD *)(a2 + 64);
  }
  return v3;
}
// 10095EE4: using guessed type int __cdecl CxxThrowException(_DWORD, _DWORD);
// 10099184: using guessed type _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *);
// 1009918C: using guessed type void *__cdecl operator new(unsigned int);
// 10099840: using guessed type int (__stdcall *off_10099840)(char);

//----- (1004E4D0) --------------------------------------------------------
void __usercall sub_1004E4D0(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // ecx@2
  int v3; // ecx@7
  int v4; // eax@8

  v1 = *(_DWORD *)(a1 + 168);
  if ( v1 )
  {
    v2 = v1 - 8;
    if ( *(_DWORD *)(v1 - 4) == ~*(_DWORD *)(v1 - 8) && v1 != 8 )
    {
      if ( v2 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    }
  }
  v3 = *(_DWORD *)(a1 + 176);
  if ( v3 )
  {
    v4 = v3 - 8;
    if ( *(_DWORD *)(v3 - 4) == ~*(_DWORD *)(v3 - 8) && v3 != 8 )
    {
      if ( v4 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1004E560) --------------------------------------------------------
void *sub_1004E560()
{
  unsigned int v0; // esi@1
  float v1; // ST04_4@2
  float v2; // ST04_4@2

  v0 = 0;
  do
  {
    v1 = (double)v0 * 0.00048828125;
    v2 = log(v1);
    flt_100BF794[++v0] = -v2 * 1.442695021629333;
  }
  while ( v0 < 0x800 );
  return &unk_100C17B0;
}
// 100BF794: using guessed type float flt_100BF794[];

//----- (1004E5C0) --------------------------------------------------------
void __usercall sub_1004E5C0(int a1@<ebx>)
{
  if ( a1 )
  {
    sub_1004E4D0(a1);
    if ( a1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(a1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1004E600) --------------------------------------------------------
int sub_1004E600()
{
  int result; // eax@1

  result = sub_10092A80(180);
  if ( result )
  {
    *(_DWORD *)(result + 12) = 0;
    *(_DWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 20) = 0;
    *(_DWORD *)(result + 164) = 0;
    *(_DWORD *)(result + 168) = 0;
    *(_DWORD *)(result + 172) = 0;
    *(_DWORD *)(result + 176) = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004E640) --------------------------------------------------------
void __stdcall sub_1004E640(int a1)
{
  unsigned int v1; // edi@1
  int v2; // ecx@2
  int v3; // eax@3
  int v4; // eax@8

  v1 = 0;
  if ( *(_DWORD *)(a1 + 12) )
  {
    do
    {
      v2 = *(_DWORD *)(a1 + 4);
      if ( !v2 )
        break;
      v3 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v1);
      if ( v3 )
      {
        *(_DWORD *)(a1 + 4) = v2 - 1;
        if ( v3 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
      }
      ++v1;
    }
    while ( v1 < *(_DWORD *)(a1 + 12) );
  }
  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 )
  {
    if ( v4 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1004E710) --------------------------------------------------------
void __usercall sub_1004E710(int a1@<eax>, int a2@<edi>)
{
  FILE *v2; // eax@2
  char DstBuf; // [sp+0h] [bp-200h]@2

  if ( !sub_1004E8B0(a2, a1) )
  {
    sprintf_s(
      &DstBuf,
      0x200u,
      "%s(%u): Failure: \"%s\"\n",
      "j:\\programme\\sdks\\crunch-104\\crnlib\\crn_sparse_array.h",
      193,
      "\"Out of memory\"");
    OutputDebugStringA(&DstBuf);
    v2 = _iob_func();
    fputs(&DstBuf, v2 + 2);
    if ( IsDebuggerPresent() )
      DebugBreak();
    if ( !byte_100AE9F8 )
      exit(1);
    RaiseException(0x100u, 0, 0, 0);
  }
}
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (1004E7B0) --------------------------------------------------------
int __userpurge sub_1004E7B0@<eax>(int a1@<esi>, unsigned int a2)
{
  unsigned int v2; // ecx@1
  unsigned int v3; // ebx@1
  void *v4; // eax@2
  int v5; // ebp@2
  unsigned int v6; // eax@3
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // edi@7
  int v10; // ecx@8
  int v11; // edx@9

  v2 = a2;
  v3 = a2 >> 4;
  if ( a2 >> 4 >= *(_DWORD *)(a1 + 12) )
  {
    v4 = (void *)sub_10092A80(64);
    v5 = (int)v4;
    if ( !v4 )
      return 0;
    memset(v4, 0, 0x40u);
    ++*(_DWORD *)(a1 + 4);
    v6 = *(_DWORD *)(a1 + 12);
    if ( v6 >= *(_DWORD *)(a1 + 16) && !sub_100943C0(v6 + 1, 0, a1 + 8, 1, 4u, 1) )
    {
      sub_1004E880(v5, a1);
      return 0;
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * (*(_DWORD *)(a1 + 12))++) = v5;
    v2 = a2;
  }
  v7 = *(char **)(*(_DWORD *)(a1 + 8) + 4 * v3);
  if ( !v7 )
  {
    v8 = (char *)sub_10092A80(64);
    v9 = v8;
    if ( v8 )
    {
      memset(v8, 0, 0x40u);
      v10 = *(_DWORD *)(a1 + 8);
      ++*(_DWORD *)(a1 + 4);
      *(_DWORD *)(v10 + 4 * v3) = v9;
      v2 = a2;
      v7 = v9;
      goto LABEL_9;
    }
    return 0;
  }
LABEL_9:
  v11 = *(_DWORD *)a1;
  if ( v2 + 1 > *(_DWORD *)a1 )
    v11 = v2 + 1;
  *(_DWORD *)a1 = v11;
  return (int)&v7[4 * (v2 & 0xF)];
}

//----- (1004E880) --------------------------------------------------------
void __usercall sub_1004E880(int a1@<eax>, int a2@<ecx>)
{
  if ( a1 )
  {
    --*(_DWORD *)(a2 + 4);
    if ( a1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(a1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1004E8B0) --------------------------------------------------------
char __userpurge sub_1004E8B0@<al>(int a1@<edi>, int a2)
{
  unsigned int v3; // eax@3
  unsigned int v4; // esi@3
  unsigned int v5; // ebx@4
  int v6; // eax@5
  unsigned int v7; // eax@10

  if ( *(_DWORD *)a1 == a2 )
    return 1;
  v3 = *(_DWORD *)(a1 + 12);
  v4 = (unsigned int)(a2 + 15) >> 4;
  if ( v4 == v3 )
    goto LABEL_16;
  v5 = (unsigned int)(a2 + 15) >> 4;
  if ( v4 < v3 )
  {
    do
    {
      v6 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v5);
      if ( v6 )
      {
        --*(_DWORD *)(a1 + 4);
        if ( v6 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v6, 0, 0, 1, dword_100AE9F4);
      }
      ++v5;
    }
    while ( v5 < *(_DWORD *)(a1 + 12) );
  }
  v7 = *(_DWORD *)(a1 + 12);
  if ( v4 == v7 )
    goto LABEL_16;
  if ( v4 < v7 )
  {
LABEL_15:
    *(_DWORD *)(a1 + 12) = v4;
LABEL_16:
    *(_DWORD *)a1 = a2;
    return 1;
  }
  if ( v4 <= *(_DWORD *)(a1 + 16) || sub_100943C0(v4, 0, a1 + 8, v4 == v7 + 1, 4u, 1) )
  {
    memset((void *)(*(_DWORD *)(a1 + 8) + 4 * *(_DWORD *)(a1 + 12)), 0, 4 * (v4 - *(_DWORD *)(a1 + 12)));
    goto LABEL_15;
  }
  return 0;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1004E980) --------------------------------------------------------
int __userpurge sub_1004E980@<eax>(int a1@<edx>, int a2@<edi>, float a3, float a4, float a5, float a6, float a7, float a8)
{
  int v8; // edx@1
  float v9; // ST18_4@1
  float v10; // ST18_4@1
  float v11; // ST18_4@1
  signed int v12; // eax@3
  signed int v13; // eax@5
  signed int v14; // ebx@5
  float v15; // ST1C_4@7
  float v16; // ST1C_4@7
  float v17; // ST1C_4@7
  signed int v18; // eax@9
  signed int v19; // eax@11
  signed __int16 v20; // cx@13
  signed __int16 v21; // si@13
  signed __int16 v22; // dx@13
  __int16 v23; // cx@19
  signed __int16 v24; // dx@19
  signed __int16 v25; // cx@19
  signed int v27; // [sp+14h] [bp-10h]@3
  float v28; // [sp+18h] [bp-Ch]@1
  signed int v29; // [sp+18h] [bp-Ch]@9
  float v30; // [sp+1Ch] [bp-8h]@1
  float v31; // [sp+1Ch] [bp-8h]@7
  float v32; // [sp+20h] [bp-4h]@7

  sub_100365F0((int)&a3, a1, 0.0, 0.99900001);
  sub_100365F0((int)&a6, v8, 0.0, 0.99900001);
  v9 = a5 * 32.0;
  v10 = floor(v9);
  v30 = v10;
  v11 = a4 * 64.0;
  v28 = floor(v11);
  a3 = a3 * 32.0;
  a3 = floor(a3);
  LODWORD(a3) = (signed int)a3;
  if ( LODWORD(a3) & 0xFFFFFF00 )
    LODWORD(a3) = (unsigned __int8)~(SLODWORD(a3) >> 31);
  v12 = (signed int)v28;
  v27 = (signed int)v28;
  if ( v12 & 0xFFFFFF00 )
    LOBYTE(v27) = ~(v12 >> 31);
  v13 = (signed int)v30;
  v14 = (signed int)v30;
  if ( v13 & 0xFFFFFF00 )
    LOBYTE(v14) = ~(v13 >> 31);
  v15 = a8 * 32.0;
  v16 = floor(v15);
  v32 = v16;
  v17 = a7 * 64.0;
  v31 = floor(v17);
  a6 = a6 * 32.0;
  a6 = floor(a6);
  LODWORD(a6) = (signed int)a6;
  if ( LODWORD(a6) & 0xFFFFFF00 )
    LODWORD(a6) = (unsigned __int8)~(SLODWORD(a6) >> 31);
  v18 = (signed int)v31;
  v29 = (signed int)v31;
  if ( v18 & 0xFFFFFF00 )
    LOBYTE(v29) = ~(v18 >> 31);
  v19 = (signed int)v32;
  if ( v19 & 0xFFFFFF00 )
    LOBYTE(v19) = ~(v19 >> 31);
  v20 = LOBYTE(a3);
  v21 = (unsigned __int8)v27;
  v22 = (unsigned __int8)v14;
  if ( LOBYTE(a3) >= 0x1Fu )
    v20 = 31;
  if ( (unsigned __int8)v27 >= 0x3Fu )
    v21 = 63;
  if ( (unsigned __int8)v14 >= 0x1Fu )
    v22 = 31;
  v23 = v22 | 32 * (v21 | (v20 << 6));
  v24 = (unsigned __int8)v29;
  *(_WORD *)a2 = v23;
  v25 = LOBYTE(a6);
  v19 = (unsigned __int8)v19;
  if ( LOBYTE(a6) >= 0x1Fu )
    v25 = 31;
  if ( (unsigned __int8)v29 >= 0x3Fu )
    v24 = 63;
  if ( (unsigned int)v19 >= 0x1F )
    LOWORD(v19) = 31;
  *(_WORD *)(a2 + 2) = v19 | 32 * (v24 | (v25 << 6));
  return a2;
}

//----- (1004EBE0) --------------------------------------------------------
int __cdecl sub_1004EBE0(unsigned int *a1, int *a2, signed int a3)
{
  int v3; // ecx@0
  int *v4; // ebx@1
  unsigned int *v5; // esi@1
  int result; // eax@1
  signed int v7; // edi@2
  int v8; // ebp@4
  int *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v4 = a2;
  v5 = a1;
  result = ((char *)a2 - (char *)a1) >> 2;
  if ( result <= 32 )
    goto LABEL_8;
  v7 = a3;
  while ( v7 > 0 )
  {
    sub_1004EDA0((int)&v9, (unsigned int)v5, v4);
    v8 = v10;
    v7 = v7 / 2 / 2 + v7 / 2;
    if ( (signed int)(((char *)v9 - (char *)v5) & 0xFFFFFFFC) >= (signed int)(((unsigned int)v4 - v10) & 0xFFFFFFFC) )
    {
      sub_1004EBE0(v10, v4, v7);
      v4 = v9;
    }
    else
    {
      sub_1004EBE0(v5, v9, v7);
      v5 = (unsigned int *)v8;
    }
    result = ((char *)v4 - (char *)v5) >> 2;
    if ( result <= 32 )
      goto LABEL_8;
  }
  if ( result <= 32 )
  {
LABEL_8:
    if ( result > 1 && (int *)v5 != v4 )
      result = sub_1004F400(v5, (unsigned int *)v4);
  }
  else
  {
    if ( (signed int)(((char *)v4 - (char *)v5) & 0xFFFFFFFC) > 4 )
      sub_1004F2B0((int)v4, (int)v5);
    result = sub_1004F3B0((int)v4, v3, (char *)v5);
  }
  return result;
}

//----- (1004ECB0) --------------------------------------------------------
int __cdecl sub_1004ECB0(int a1)
{
  int v1; // ecx@0
  int result; // eax@1
  int v3; // ebp@2
  int v4; // ecx@2
  __int16 v5; // ax@3
  __int16 v6; // ax@5
  unsigned __int16 v7; // dx@7
  unsigned __int16 v8; // bx@7
  int i; // ecx@16
  __int16 v10; // ax@17
  __int16 v11; // ax@19
  unsigned __int16 v12; // dx@21
  unsigned __int16 v13; // bx@21
  __int16 v14; // [sp+10h] [bp-4h]@5
  __int16 v15; // [sp+10h] [bp-4h]@19

  result = a1;
  if ( v1 != a1 )
  {
    v3 = v1;
    v4 = v1 + 4;
    if ( v4 != a1 )
    {
      while ( 1 )
      {
        v5 = *(_WORD *)v3;
        if ( *(_WORD *)v3 >= *(_WORD *)(v3 + 2) )
          v5 = *(_WORD *)(v3 + 2);
        v14 = v5;
        v6 = *(_WORD *)v3;
        if ( *(_WORD *)v3 <= *(_WORD *)(v3 + 2) )
          v6 = *(_WORD *)(v3 + 2);
        v7 = *(_WORD *)(v4 + 2);
        v8 = *(_WORD *)v4;
        if ( *(_WORD *)v4 >= *(_WORD *)(v4 + 2) )
          v8 = *(_WORD *)(v4 + 2);
        if ( *(_WORD *)v4 > v7 )
          v7 = *(_WORD *)v4;
        if ( v14 == v8 && v6 == v7 )
          break;
        v3 = v4;
        v4 += 4;
        if ( v4 == a1 )
          return a1;
      }
      for ( i = v4 + 4; i != a1; i += 4 )
      {
        v10 = *(_WORD *)v3;
        if ( *(_WORD *)v3 >= *(_WORD *)(v3 + 2) )
          v10 = *(_WORD *)(v3 + 2);
        v15 = v10;
        v11 = *(_WORD *)v3;
        if ( *(_WORD *)v3 <= *(_WORD *)(v3 + 2) )
          v11 = *(_WORD *)(v3 + 2);
        v12 = *(_WORD *)(i + 2);
        v13 = *(_WORD *)i;
        if ( *(_WORD *)i >= *(_WORD *)(i + 2) )
          v13 = *(_WORD *)(i + 2);
        if ( *(_WORD *)i > v12 )
          v12 = *(_WORD *)i;
        if ( v15 != v13 || v11 != v12 )
        {
          v3 += 4;
          *(_DWORD *)v3 = *(_DWORD *)i;
        }
      }
      result = v3 + 4;
    }
  }
  return result;
}

//----- (1004EDA0) --------------------------------------------------------
int __cdecl sub_1004EDA0(int a1, unsigned int a2, int *a3)
{
  unsigned __int16 v3; // bx@2
  unsigned __int16 v4; // bp@2
  unsigned __int16 v5; // ax@8
  unsigned __int16 v6; // cx@8
  unsigned __int16 v7; // di@8
  unsigned __int16 v8; // dx@10
  unsigned __int16 v9; // di@15
  unsigned __int16 v10; // si@17
  unsigned __int16 v11; // dx@19
  unsigned __int16 v12; // ax@21
  unsigned __int16 v13; // si@29
  unsigned __int16 v14; // di@29
  unsigned __int16 v15; // dx@35
  unsigned __int16 v16; // ax@37
  unsigned __int16 v17; // bp@42
  unsigned __int16 v18; // bx@44
  unsigned __int16 v19; // dx@46
  unsigned __int16 v20; // ax@48
  unsigned int v21; // ebx@54
  unsigned __int16 v22; // bp@57
  unsigned __int16 v23; // ax@63
  unsigned __int16 v24; // cx@63
  unsigned __int16 v25; // di@63
  unsigned __int16 v26; // dx@65
  unsigned __int16 v27; // dx@70
  unsigned __int16 v28; // di@72
  unsigned __int16 v29; // dx@74
  unsigned __int16 v30; // ax@76
  int *v31; // eax@81
  int v32; // ecx@81
  unsigned __int16 v33; // bx@85
  unsigned __int16 v34; // bp@85
  unsigned __int16 v35; // ax@91
  unsigned __int16 v36; // cx@91
  unsigned __int16 v37; // di@91
  unsigned __int16 v38; // dx@93
  unsigned __int16 v39; // di@98
  unsigned __int16 v40; // si@100
  unsigned __int16 v41; // dx@102
  unsigned __int16 v42; // ax@104
  int v43; // eax@109
  int *v44; // edx@113
  int v45; // eax@114
  _DWORD *v46; // ecx@115
  int v47; // edx@115
  int *v48; // ecx@116
  int *v49; // edx@117
  int v50; // eax@118
  int v51; // eax@119
  int v52; // eax@120
  int result; // eax@121
  unsigned int v54; // [sp+10h] [bp-18h]@1
  unsigned int i; // [sp+14h] [bp-14h]@1
  unsigned __int16 v56; // [sp+18h] [bp-10h]@6
  unsigned __int16 v57; // [sp+18h] [bp-10h]@33
  unsigned int v58; // [sp+18h] [bp-10h]@54
  unsigned __int16 v59; // [sp+1Ch] [bp-Ch]@3
  unsigned __int16 v60; // [sp+1Ch] [bp-Ch]@30
  int *v61; // [sp+1Ch] [bp-Ch]@55
  unsigned __int16 v62; // [sp+20h] [bp-8h]@28
  unsigned __int16 v63; // [sp+20h] [bp-8h]@61
  unsigned __int16 v64; // [sp+20h] [bp-8h]@89
  unsigned __int16 v65; // [sp+24h] [bp-4h]@28
  unsigned __int16 v66; // [sp+24h] [bp-4h]@58
  unsigned __int16 v67; // [sp+24h] [bp-4h]@72
  unsigned __int16 v68; // [sp+24h] [bp-4h]@86

  sub_1004F220((int)(a3 - 1), a2, a2 + 4 * (((signed int)((signed int)a3 - a2) >> 2) / 2));
  v54 = a2 + 4 * (((signed int)((signed int)a3 - a2) >> 2) / 2);
  for ( i = v54 + 4; a2 < v54; v54 -= 4 )
  {
    v3 = *(_WORD *)(v54 - 2);
    v4 = *(_WORD *)(v54 - 4);
    if ( *(_WORD *)(v54 - 4) >= *(_WORD *)(v54 - 2) )
      v59 = *(_WORD *)(v54 - 2);
    else
      v59 = *(_WORD *)(v54 - 4);
    if ( v4 <= v3 )
      v56 = *(_WORD *)(v54 - 2);
    else
      v56 = *(_WORD *)(v54 - 4);
    v5 = *(_WORD *)(v54 + 2);
    v6 = *(_WORD *)v54;
    v7 = *(_WORD *)v54;
    if ( *(_WORD *)v54 >= v5 )
      v7 = *(_WORD *)(v54 + 2);
    v8 = *(_WORD *)(v54 + 2);
    if ( v6 > v5 )
      v8 = *(_WORD *)v54;
    if ( v59 < v7 || v59 == v7 && v56 < v8 )
      break;
    v9 = *(_WORD *)v54;
    if ( v6 >= v5 )
      v9 = *(_WORD *)(v54 + 2);
    v10 = *(_WORD *)v54;
    if ( v6 <= v5 )
      v10 = *(_WORD *)(v54 + 2);
    v11 = *(_WORD *)(v54 - 4);
    if ( v4 >= v3 )
      v11 = *(_WORD *)(v54 - 2);
    v12 = *(_WORD *)(v54 - 2);
    if ( v4 > v3 )
      v12 = *(_WORD *)(v54 - 4);
    if ( v9 < v11 || v9 == v11 && v10 < v12 )
      break;
  }
  if ( i < (unsigned int)a3 )
  {
    v62 = *(_WORD *)(v54 + 2);
    v65 = *(_WORD *)v54;
    do
    {
      v13 = *(_WORD *)(i + 2);
      v14 = *(_WORD *)i;
      if ( *(_WORD *)i >= *(_WORD *)(i + 2) )
        v60 = *(_WORD *)(i + 2);
      else
        v60 = *(_WORD *)i;
      if ( v14 <= v13 )
        v57 = *(_WORD *)(i + 2);
      else
        v57 = *(_WORD *)i;
      v15 = *(_WORD *)v54;
      if ( v65 >= v62 )
        v15 = *(_WORD *)(v54 + 2);
      v16 = *(_WORD *)(v54 + 2);
      if ( v65 > v62 )
        v16 = *(_WORD *)v54;
      if ( v60 < v15 || v60 == v15 && v57 < v16 )
        break;
      v17 = *(_WORD *)v54;
      if ( v65 >= v62 )
        v17 = *(_WORD *)(v54 + 2);
      v18 = *(_WORD *)v54;
      if ( v65 <= v62 )
        v18 = *(_WORD *)(v54 + 2);
      v19 = *(_WORD *)i;
      if ( v14 >= v13 )
        v19 = *(_WORD *)(i + 2);
      v20 = *(_WORD *)(i + 2);
      if ( v14 > v13 )
        v20 = *(_WORD *)i;
      if ( v17 < v19 || v17 == v19 && v18 < v20 )
        break;
      i += 4;
    }
    while ( i < (unsigned int)a3 );
  }
  v21 = i;
  v58 = v54;
  while ( 2 )
  {
    while ( 2 )
    {
      v61 = (int *)v21;
LABEL_56:
      if ( v21 >= (unsigned int)a3 )
        goto LABEL_84;
      do
      {
        v22 = *(_WORD *)(v54 + 2);
        if ( *(_WORD *)v54 >= *(_WORD *)(v54 + 2) )
          v66 = *(_WORD *)(v54 + 2);
        else
          v66 = *(_WORD *)v54;
        if ( *(_WORD *)v54 <= v22 )
          v63 = *(_WORD *)(v54 + 2);
        else
          v63 = *(_WORD *)v54;
        v23 = *(_WORD *)(v21 + 2);
        v24 = *(_WORD *)v21;
        v25 = *(_WORD *)v21;
        if ( *(_WORD *)v21 >= *(_WORD *)(v21 + 2) )
          v25 = *(_WORD *)(v21 + 2);
        v26 = *(_WORD *)(v21 + 2);
        if ( v24 > v23 )
          v26 = *(_WORD *)v21;
        if ( v66 < v25 || v66 == v25 && v63 < v26 )
          goto LABEL_82;
        v27 = *(_WORD *)(v21 + 2);
        if ( v24 < v23 )
          v27 = *(_WORD *)v21;
        v67 = v27;
        v28 = *(_WORD *)v21;
        if ( v24 <= v23 )
          v28 = *(_WORD *)(v21 + 2);
        v29 = *(_WORD *)v54;
        if ( *(_WORD *)v54 >= v22 )
          v29 = *(_WORD *)(v54 + 2);
        v30 = *(_WORD *)(v54 + 2);
        if ( *(_WORD *)v54 > v22 )
          v30 = *(_WORD *)v54;
        if ( v67 < v29 || v67 == v29 && v28 < v30 )
          break;
        v31 = (int *)i;
        i += 4;
        v32 = *v31;
        *v31 = *(_DWORD *)v21;
        *(_DWORD *)v21 = v32;
LABEL_82:
        v21 += 4;
      }
      while ( v21 < (unsigned int)a3 );
      v61 = (int *)v21;
LABEL_84:
      while ( a2 < v58 )
      {
        v33 = *(_WORD *)(v58 - 2);
        v34 = *(_WORD *)(v58 - 4);
        if ( *(_WORD *)(v58 - 4) >= *(_WORD *)(v58 - 2) )
          v68 = *(_WORD *)(v58 - 2);
        else
          v68 = *(_WORD *)(v58 - 4);
        if ( v34 <= v33 )
          v64 = *(_WORD *)(v58 - 2);
        else
          v64 = *(_WORD *)(v58 - 4);
        v35 = *(_WORD *)(v54 + 2);
        v36 = *(_WORD *)v54;
        v37 = *(_WORD *)v54;
        if ( *(_WORD *)v54 >= *(_WORD *)(v54 + 2) )
          v37 = *(_WORD *)(v54 + 2);
        v38 = *(_WORD *)(v54 + 2);
        if ( v36 > v35 )
          v38 = *(_WORD *)v54;
        if ( v68 >= v37 && (v68 != v37 || v64 >= v38) )
        {
          v39 = *(_WORD *)v54;
          if ( v36 >= v35 )
            v39 = *(_WORD *)(v54 + 2);
          v40 = *(_WORD *)v54;
          if ( v36 <= v35 )
            v40 = *(_WORD *)(v54 + 2);
          v41 = *(_WORD *)(v58 - 4);
          if ( v34 >= v33 )
            v41 = *(_WORD *)(v58 - 2);
          v42 = *(_WORD *)(v58 - 2);
          if ( v34 > v33 )
            v42 = *(_WORD *)(v58 - 4);
          if ( v39 < v41 || v39 == v41 && v40 < v42 )
            break;
          v43 = *(_DWORD *)(v54 - 4);
          *(_DWORD *)(v54 - 4) = *(_DWORD *)(v58 - 4);
          v54 -= 4;
          *(_DWORD *)(v58 - 4) = v43;
        }
        v58 -= 4;
      }
      v21 = (unsigned int)v61;
      if ( v58 != a2 )
      {
        v48 = (int *)(v58 - 4);
        v58 -= 4;
        if ( v61 != a3 )
        {
          v52 = *v61;
          *v61 = *v48;
          *v48 = v52;
          v21 = (unsigned int)(v61 + 1);
          continue;
        }
        v49 = (int *)(v54 - 4);
        v54 = (unsigned int)v49;
        if ( v48 != v49 )
        {
          v50 = *v48;
          *v48 = *v49;
          *v49 = v50;
        }
        v51 = *v49;
        *v49 = *(_DWORD *)(i - 4);
        i -= 4;
        *(_DWORD *)i = v51;
        goto LABEL_56;
      }
      break;
    }
    if ( v61 != a3 )
    {
      v44 = (int *)v54;
      if ( (int *)i != v61 )
      {
        v45 = *(_DWORD *)v54;
        *(_DWORD *)v54 = *(_DWORD *)i;
        *(_DWORD *)i = v45;
      }
      i += 4;
      v46 = (_DWORD *)v54;
      v54 += 4;
      v47 = *v44;
      *v46 = *v61;
      v21 = (unsigned int)(v61 + 1);
      *v61 = v47;
      continue;
    }
    break;
  }
  result = a1;
  *(_DWORD *)a1 = v54;
  *(_DWORD *)(a1 + 4) = i;
  return result;
}

//----- (1004F220) --------------------------------------------------------
int __usercall sub_1004F220@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // esi@1
  int v4; // eax@1
  int v5; // eax@2
  int v6; // ST30_4@2
  int v7; // ebx@2
  int v8; // ST34_4@2
  int result; // eax@2

  v3 = a1;
  v4 = (a1 - a2) >> 2;
  if ( v4 <= 40 )
  {
    result = sub_1004F520(a3, a2, v3);
  }
  else
  {
    v5 = (v4 + 1) / 8;
    v6 = 8 * v5;
    v7 = 4 * v5;
    v8 = 4 * v5 + a2;
    sub_1004F520(v8, a2, a2 + 8 * v5);
    sub_1004F520(a3, a3 - v7, v7 + a3);
    sub_1004F520(v3 - v7, v3 - v6, v3);
    result = sub_1004F520(a3, v8, v3 - v7);
  }
  return result;
}

//----- (1004F2B0) --------------------------------------------------------
int __usercall sub_1004F2B0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // ebx@1
  int v3; // esi@1
  int result; // eax@1
  int v5; // ebp@1
  int v6; // edi@2
  int v7; // eax@3
  int v8; // eax@3
  unsigned __int16 v9; // dx@4
  unsigned __int16 v10; // cx@9
  unsigned __int16 v11; // di@9
  int v12; // edx@17
  int v13; // ecx@17
  int v14; // [sp+Ch] [bp-18h]@3
  unsigned __int16 v15; // [sp+14h] [bp-10h]@7
  int v16; // [sp+18h] [bp-Ch]@1
  int v17; // [sp+1Ch] [bp-8h]@3
  int v18; // [sp+20h] [bp-4h]@3

  v2 = a2;
  v3 = (a1 - a2) >> 2;
  result = v3 - ((unsigned __int64)v3 >> 32);
  v5 = v3 / 2;
  v16 = v3;
  if ( v3 / 2 > 0 )
  {
    v6 = 2 * v5 + 2;
    do
    {
      v7 = *(_DWORD *)(v2 + 4 * v5-- - 4);
      v6 -= 2;
      v18 = v7;
      v17 = v6;
      v14 = v5;
      v8 = v6;
      if ( v6 < v3 )
      {
        do
        {
          v9 = *(_WORD *)(v2 + 4 * v8 + 2);
          if ( *(_WORD *)(v2 + 4 * v8) < v9 )
            v9 = *(_WORD *)(v2 + 4 * v8);
          if ( *(_WORD *)(v2 + 4 * v8) <= *(_WORD *)(v2 + 4 * v8 + 2) )
            v15 = *(_WORD *)(v2 + 4 * v8 + 2);
          else
            v15 = *(_WORD *)(v2 + 4 * v8);
          v10 = *(_WORD *)(v2 + 4 * v8 - 2);
          v11 = *(_WORD *)(v2 + 4 * v8 - 4);
          if ( v11 >= *(_WORD *)(v2 + 4 * v8 - 2) )
            v11 = *(_WORD *)(v2 + 4 * v8 - 2);
          if ( *(_WORD *)(v2 + 4 * v8 - 4) > v10 )
            v10 = *(_WORD *)(v2 + 4 * v8 - 4);
          if ( v9 < v11 || v9 == v11 && v15 < v10 )
            --v8;
          v12 = v14;
          v13 = *(_DWORD *)(v2 + 4 * v8);
          v14 = v8;
          v8 = 2 * v8 + 2;
          *(_DWORD *)(v2 + 4 * v12) = v13;
        }
        while ( v8 < v16 );
        v3 = v16;
        v6 = v17;
      }
      if ( v8 == v3 )
      {
        *(_DWORD *)(v2 + 4 * v14) = *(_DWORD *)(v2 + 4 * v3 - 4);
        v14 = v3 - 1;
      }
      result = sub_1004F6F0(v2, v14, v5, (int)&v18);
    }
    while ( v5 > 0 );
  }
  return result;
}

//----- (1004F3B0) --------------------------------------------------------
int __usercall sub_1004F3B0@<eax>(int a1@<eax>, int a2@<ecx>, char *a3@<esi>)
{
  int result; // eax@1
  int v4; // edx@2
  int v5; // edi@2
  int v6; // [sp+0h] [bp-4h]@1

  v6 = a2;
  result = a1 - (_DWORD)a3;
  if ( (signed int)(result & 0xFFFFFFFC) > 4 )
  {
    do
    {
      v4 = *(_DWORD *)&a3[result - 4];
      v5 = result - 4;
      *(_DWORD *)&a3[result - 4] = *(_DWORD *)a3;
      v6 = v4;
      sub_1004F630((int)a3, 0, (result - 4) >> 2, (int)&v6);
      result = v5;
    }
    while ( (signed int)(v5 & 0xFFFFFFFC) > 4 );
  }
  return result;
}

//----- (1004F400) --------------------------------------------------------
int __cdecl sub_1004F400(unsigned int *a1, unsigned int *a2)
{
  unsigned int *v2; // edx@1
  int result; // eax@1
  unsigned int v4; // ebx@4
  int v5; // eax@4
  unsigned int v6; // edi@4
  unsigned int v7; // ebp@6
  unsigned __int16 v8; // ax@8
  unsigned __int16 v9; // dx@8
  unsigned __int16 v10; // si@8
  int v11; // edx@15
  unsigned int *v12; // ecx@15
  int v13; // esi@16
  int i; // edi@18
  unsigned __int16 v15; // bp@19
  unsigned __int16 v16; // si@23
  int v17; // [sp+0h] [bp-10h]@1
  unsigned int *v18; // [sp+4h] [bp-Ch]@4
  unsigned __int16 v19; // [sp+8h] [bp-8h]@21

  v2 = a1;
  result = (int)(a1 + 1);
  v17 = (int)(a1 + 1);
  if ( a1 + 1 != a2 )
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)result;
      v18 = (unsigned int *)result;
      v5 = *(_DWORD *)result >> 16;
      LOWORD(v6) = v4;
      if ( (unsigned __int16)v4 >= HIWORD(v4) )
        v6 = v4 >> 16;
      LOWORD(v7) = v4;
      if ( (unsigned __int16)v4 <= (unsigned __int16)v5 )
        v7 = v4 >> 16;
      v8 = *((_WORD *)v2 + 1);
      v9 = *(_WORD *)v2;
      v10 = v9;
      if ( v9 >= v8 )
        v10 = v8;
      if ( v9 > v8 )
        v8 = v9;
      if ( (unsigned __int16)v6 >= v10 && ((_WORD)v6 != v10 || (unsigned __int16)v7 >= v8) )
      {
        for ( i = v17; ; v18 = (unsigned int *)i )
        {
          i -= 4;
          v15 = v4;
          if ( (unsigned __int16)v4 < HIWORD(v4) || (v15 = HIWORD(v4), (unsigned __int16)v4 <= HIWORD(v4)) )
            v19 = HIWORD(v4);
          else
            v19 = v4;
          result = *(_WORD *)(i + 2);
          v16 = *(_WORD *)i;
          if ( *(_WORD *)i >= *(_WORD *)(i + 2) )
            v16 = *(_WORD *)(i + 2);
          if ( *(_WORD *)i > (unsigned __int16)result )
            result = *(_WORD *)i;
          if ( v15 >= v16 && (v15 != v16 || v19 >= (unsigned __int16)result) )
            break;
          *v18 = *(_DWORD *)i;
        }
        v12 = v18;
        v11 = v17;
      }
      else
      {
        v11 = v17;
        v12 = a1;
        for ( result = v17; (unsigned int *)result != a1; *(_DWORD *)(result + 4) = v13 )
        {
          v13 = *(_DWORD *)(result - 4);
          result -= 4;
        }
      }
      *v12 = v4;
      v17 = v11 + 4;
      if ( (unsigned int *)(v11 + 4) == a2 )
        break;
      v2 = a1;
      result = v17;
    }
  }
  return result;
}

//----- (1004F520) --------------------------------------------------------
int __usercall sub_1004F520@<eax>(int a1@<edi>, int a2, int a3)
{
  unsigned __int16 v3; // cx@1
  unsigned __int16 v4; // bp@3
  unsigned __int16 v5; // ax@5
  unsigned __int16 v6; // si@5
  int v7; // eax@12
  unsigned __int16 v8; // bp@13
  unsigned __int16 v9; // bx@15
  unsigned __int16 v10; // ax@17
  unsigned __int16 v11; // si@17
  int v12; // eax@24
  unsigned __int16 v13; // bp@25
  unsigned __int16 v14; // bx@27
  int result; // eax@29
  unsigned __int16 v16; // si@29

  v3 = *(_WORD *)(a1 + 2);
  if ( *(_WORD *)a1 < v3 )
    v3 = *(_WORD *)a1;
  v4 = *(_WORD *)a1;
  if ( *(_WORD *)a1 <= *(_WORD *)(a1 + 2) )
    v4 = *(_WORD *)(a1 + 2);
  v5 = *(_WORD *)(a2 + 2);
  v6 = *(_WORD *)a2;
  if ( *(_WORD *)a2 >= *(_WORD *)(a2 + 2) )
    v6 = *(_WORD *)(a2 + 2);
  if ( *(_WORD *)a2 > v5 )
    v5 = *(_WORD *)a2;
  if ( v3 < v6 || v3 == v6 && v4 < v5 )
  {
    v7 = *(_DWORD *)a1;
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(_DWORD *)a2 = v7;
  }
  v8 = *(_WORD *)a3;
  if ( *(_WORD *)a3 >= *(_WORD *)(a3 + 2) )
    v8 = *(_WORD *)(a3 + 2);
  v9 = *(_WORD *)a3;
  if ( *(_WORD *)a3 <= *(_WORD *)(a3 + 2) )
    v9 = *(_WORD *)(a3 + 2);
  v10 = *(_WORD *)(a1 + 2);
  v11 = *(_WORD *)a1;
  if ( *(_WORD *)a1 >= *(_WORD *)(a1 + 2) )
    v11 = *(_WORD *)(a1 + 2);
  if ( *(_WORD *)a1 > v10 )
    v10 = *(_WORD *)a1;
  if ( v8 < v11 || v8 == v11 && v9 < v10 )
  {
    v12 = *(_DWORD *)a3;
    *(_DWORD *)a3 = *(_DWORD *)a1;
    *(_DWORD *)a1 = v12;
  }
  v13 = *(_WORD *)a1;
  if ( *(_WORD *)a1 >= *(_WORD *)(a1 + 2) )
    v13 = *(_WORD *)(a1 + 2);
  v14 = *(_WORD *)a1;
  if ( *(_WORD *)a1 <= *(_WORD *)(a1 + 2) )
    v14 = *(_WORD *)(a1 + 2);
  result = *(_WORD *)(a2 + 2);
  v16 = *(_WORD *)a2;
  if ( *(_WORD *)a2 >= *(_WORD *)(a2 + 2) )
    v16 = *(_WORD *)(a2 + 2);
  if ( *(_WORD *)a2 > (unsigned __int16)result )
    result = *(_WORD *)a2;
  if ( v13 < v16 || v13 == v16 && v14 < (unsigned __int16)result )
  {
    result = *(_DWORD *)a1;
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(_DWORD *)a2 = result;
  }
  return result;
}

//----- (1004F630) --------------------------------------------------------
int __usercall sub_1004F630@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  int v4; // ecx@1
  int v5; // ebp@1
  int v6; // ebx@1
  int v7; // eax@1
  bool v8; // zf@1
  unsigned __int16 v9; // dx@2
  unsigned __int16 v10; // cx@7
  unsigned __int16 v11; // di@7
  unsigned __int16 v13; // [sp+8h] [bp-8h]@5

  v4 = a3;
  v5 = a2;
  v6 = a1;
  v7 = 2 * a2 + 2;
  v8 = v7 == a3;
  if ( v7 < a3 )
  {
    do
    {
      v9 = *(_WORD *)(v6 + 4 * v7 + 2);
      if ( *(_WORD *)(v6 + 4 * v7) < v9 )
        v9 = *(_WORD *)(v6 + 4 * v7);
      if ( *(_WORD *)(v6 + 4 * v7) <= *(_WORD *)(v6 + 4 * v7 + 2) )
        v13 = *(_WORD *)(v6 + 4 * v7 + 2);
      else
        v13 = *(_WORD *)(v6 + 4 * v7);
      v10 = *(_WORD *)(v6 + 4 * v7 - 2);
      v11 = *(_WORD *)(v6 + 4 * v7 - 4);
      if ( v11 >= *(_WORD *)(v6 + 4 * v7 - 2) )
        v11 = *(_WORD *)(v6 + 4 * v7 - 2);
      if ( *(_WORD *)(v6 + 4 * v7 - 4) > v10 )
        v10 = *(_WORD *)(v6 + 4 * v7 - 4);
      if ( v9 < v11 || v9 == v11 && v13 < v10 )
        --v7;
      *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v6 + 4 * v7);
      v5 = v7;
      v7 = 2 * v7 + 2;
    }
    while ( v7 < a3 );
    v4 = a3;
    v8 = v7 == a3;
  }
  if ( v8 )
  {
    *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v6 + 4 * v4 - 4);
    v5 = v4 - 1;
  }
  return sub_1004F6F0(v6, v5, a2, a4);
}

//----- (1004F6F0) --------------------------------------------------------
int __usercall sub_1004F6F0@<eax>(int a1@<ebx>, int a2, int a3, int a4)
{
  int v4; // ebp@1
  int result; // eax@1
  unsigned __int16 v6; // dx@2
  unsigned __int16 v7; // cx@7
  unsigned __int16 v8; // di@7
  unsigned __int16 v9; // [sp+4h] [bp-4h]@5

  v4 = a2;
  result = (a2 - 1) / 2;
  if ( a3 < a2 )
  {
    while ( 1 )
    {
      v6 = *(_WORD *)(a1 + 4 * result + 2);
      if ( *(_WORD *)(a1 + 4 * result) < v6 )
        v6 = *(_WORD *)(a1 + 4 * result);
      if ( *(_WORD *)(a1 + 4 * result) <= *(_WORD *)(a1 + 4 * result + 2) )
        v9 = *(_WORD *)(a1 + 4 * result + 2);
      else
        v9 = *(_WORD *)(a1 + 4 * result);
      v7 = *(_WORD *)(a4 + 2);
      v8 = *(_WORD *)a4;
      if ( *(_WORD *)a4 >= *(_WORD *)(a4 + 2) )
        v8 = *(_WORD *)(a4 + 2);
      if ( *(_WORD *)a4 > v7 )
        v7 = *(_WORD *)a4;
      if ( v6 >= v8 )
      {
        if ( v6 != v8 )
        {
          result = a4;
          *(_DWORD *)(a1 + 4 * v4) = *(_DWORD *)a4;
          return result;
        }
        if ( v9 >= v7 )
        {
          *(_DWORD *)(a1 + 4 * v4) = *(_DWORD *)a4;
          return result;
        }
      }
      *(_DWORD *)(a1 + 4 * v4) = *(_DWORD *)(a1 + 4 * result);
      v4 = result;
      result = (result - 1) / 2;
      if ( a3 >= v4 )
      {
        result = *(_DWORD *)a4;
        *(_DWORD *)(a1 + 4 * v4) = *(_DWORD *)a4;
        return result;
      }
    }
  }
  result = *(_DWORD *)a4;
  *(_DWORD *)(a1 + 4 * a2) = *(_DWORD *)a4;
  return result;
}

//----- (1004FE84) --------------------------------------------------------
int sub_1004FE84()
{
  return _clean_type_info_names_internal(&unk_100AE9CC);
}
// 100501B2: using guessed type int __cdecl _clean_type_info_names_internal(_DWORD);

//----- (1004FF48) --------------------------------------------------------
int (*sub_1004FF48())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // edi@1

  result = (int (*)(void))&unk_100A5D88;
  v1 = (int (**)(void))&unk_100A5D88;
  if ( &unk_100A5D88 < &unk_100A5D88 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_100A5D88 );
  }
  return result;
}

//----- (100502BE) --------------------------------------------------------
FARPROC __stdcall sub_100502BE(DWORD a1, DWORD Arguments)
{
  DWORD v2; // esi@1
  int v3; // ebx@1
  char *v4; // edi@1
  const CHAR *v5; // ecx@1
  char *v6; // ebx@1
  char *v7; // edx@1
  bool v8; // zf@1
  HMODULE v10; // edi@3
  unsigned int v11; // edx@3
  const CHAR *v12; // eax@3
  FARPROC v13; // ebx@5
  _DWORD *v14; // eax@16
  int v15; // eax@24
  int v16; // [sp+Ch] [bp-44h]@1
  DWORD v17; // [sp+10h] [bp-40h]@1
  DWORD v18; // [sp+14h] [bp-3Ch]@1
  LPCSTR lpLibFileName; // [sp+18h] [bp-38h]@1
  unsigned int v20; // [sp+1Ch] [bp-34h]@1
  LPCSTR lpProcName; // [sp+20h] [bp-30h]@1
  HMODULE v22; // [sp+24h] [bp-2Ch]@1
  int (__stdcall *v23)(); // [sp+28h] [bp-28h]@1
  DWORD v24; // [sp+2Ch] [bp-24h]@1
  LPLONG Target; // [sp+38h] [bp-18h]@1
  char *v26; // [sp+44h] [bp-Ch]@1
  int v27; // [sp+4Ch] [bp-4h]@1

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 12);
  v4 = (char *)&_ImageBase + *(_DWORD *)(a1 + 20);
  v5 = (char *)&_ImageBase + *(_DWORD *)(a1 + 4);
  Target = (LPLONG)((char *)&_ImageBase + *(_DWORD *)(a1 + 8));
  v6 = (char *)&_ImageBase + v3;
  v7 = (char *)&_ImageBase + *(_DWORD *)(a1 + 16);
  v27 = *(_DWORD *)(a1 + 28);
  lpLibFileName = v5;
  v26 = v4;
  v18 = Arguments;
  v8 = (*(_DWORD *)a1 & 1) == 0;
  v16 = 36;
  v17 = a1;
  v20 = 0;
  lpProcName = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  if ( v8 )
  {
    Arguments = (DWORD)&v16;
    RaiseException(0xC06D0057, 0, 1u, &Arguments);
    return 0;
  }
  v10 = (HMODULE)*Target;
  v11 = *(_DWORD *)&v7[(Arguments - (_DWORD)v6) & 0xFFFFFFFC];
  a1 = (Arguments - (_DWORD)v6) & 0xFFFFFFFC;
  v20 = ~(v11 >> 31) & 1;
  v12 = (char *)&word_10000002 + v11;
  if ( !(~(v11 >> 31) & 1) )
    v12 = (const CHAR *)(unsigned __int16)v11;
  lpProcName = v12;
  v13 = 0;
  if ( !dword_100AE9E4 || (v13 = (FARPROC)dword_100AE9E4(0, &v16)) == 0 )
  {
    if ( !v10 )
    {
      if ( !dword_100AE9E4 || (v10 = (HMODULE)dword_100AE9E4(1, &v16)) == 0 )
      {
        v10 = LoadLibraryA(lpLibFileName);
        if ( !v10 )
        {
          v24 = GetLastError();
          if ( !dword_100AE9E0 || (v10 = (HMODULE)dword_100AE9E0(3, &v16)) == 0 )
          {
            Arguments = (DWORD)&v16;
            RaiseException(0xC06D007E, 0, 1u, &Arguments);
            return v23;
          }
        }
      }
      if ( (HMODULE)InterlockedExchange(Target, (LONG)v10) == v10 )
      {
        FreeLibrary(v10);
      }
      else if ( *(_DWORD *)(v2 + 24) )
      {
        v14 = LocalAlloc(0x40u, 8u);
        if ( v14 )
        {
          v14[1] = v2;
          *v14 = dword_100AE9DC;
          dword_100AE9DC = (int)v14;
        }
      }
    }
    v22 = v10;
    if ( dword_100AE9E4 )
      v13 = (FARPROC)dword_100AE9E4(2, &v16);
    if ( !v13 )
    {
      if ( !*(_DWORD *)(v2 + 20)
        || !*(_DWORD *)(v2 + 28)
        || (v15 = *((_DWORD *)v10 + 15), *(_DWORD *)((char *)v10 + v15) != 17744)
        || *(_DWORD *)((char *)v10 + v15 + 8) != v27
        || v10 != *(HMODULE *)((char *)v10 + v15 + 52)
        || (v13 = *(FARPROC *)&v26[a1]) == 0 )
      {
        v13 = GetProcAddress(v10, lpProcName);
        if ( !v13 )
        {
          v24 = GetLastError();
          if ( !dword_100AE9E0 || (v13 = (FARPROC)dword_100AE9E0(4, &v16)) == 0 )
          {
            a1 = (DWORD)&v16;
            RaiseException(0xC06D007F, 0, 1u, &a1);
            v13 = v23;
          }
        }
      }
    }
    *(_DWORD *)Arguments = v13;
  }
  if ( dword_100AE9E4 )
  {
    v24 = 0;
    v22 = v10;
    v23 = v13;
    dword_100AE9E4(5, &v16);
  }
  return v13;
}
// 10000000: using guessed type __int16 _ImageBase;
// 10000002: using guessed type __int16 word_10000002;
// 100AE9DC: using guessed type int dword_100AE9DC;
// 100AE9E0: using guessed type int (__stdcall *dword_100AE9E0)(_DWORD, _DWORD);
// 100AE9E4: using guessed type int (__stdcall *dword_100AE9E4)(_DWORD, _DWORD);

//----- (10050500) --------------------------------------------------------
int __cdecl sub_10050500(LPCRITICAL_SECTION lpCriticalSection)
{
  InitializeCriticalSection(lpCriticalSection);
  return 0;
}

//----- (10050690) --------------------------------------------------------
DWORD __usercall sub_10050690@<eax>(LONG lInitialCount@<ecx>, LONG a2@<eax>, int a3)
{
  HANDLE v3; // eax@1
  DWORD result; // eax@2

  v3 = CreateSemaphoreW(0, lInitialCount, a2, 0);
  *(_DWORD *)a3 = v3;
  if ( v3 )
  {
    result = 0;
  }
  else
  {
    result = GetLastError();
    if ( !result )
      result = 1;
  }
  return result;
}

//----- (10050790) --------------------------------------------------------
DWORD __usercall sub_10050790@<eax>(int a1@<edx>, int a2@<ecx>, int *a3)
{
  int v3; // eax@1
  DWORD result; // eax@2
  int v5; // [sp+0h] [bp-4h]@1

  v5 = a2;
  v3 = beginthreadex(0, 0, a1, a2, 0, &v5);
  *a3 = v3;
  if ( v3 )
  {
    result = 0;
  }
  else
  {
    result = GetLastError();
    if ( !result )
      result = 1;
  }
  return result;
}
// 10099118: using guessed type int __cdecl beginthreadex(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10050860) --------------------------------------------------------
DWORD __cdecl sub_10050860(_DWORD *a1)
{
  HANDLE v1; // eax@1
  DWORD result; // eax@2

  v1 = CreateEventW(0, 0, 0, 0);
  *a1 = v1;
  if ( v1 )
  {
    result = 0;
  }
  else
  {
    result = GetLastError();
    if ( !result )
      result = 1;
  }
  return result;
}

//----- (10050890) --------------------------------------------------------
int __cdecl sub_10050890(int a1, int a2)
{
  int v2; // eax@1
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // esi@1
  unsigned int v6; // eax@2
  int v7; // eax@3
  int v9; // ecx@4
  int v10; // eax@4

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a1 + 4);
  v4 = *(_DWORD *)(v3 + 4 * v2);
  v5 = v3 + 4 * v2 + 4;
  *(_DWORD *)(a1 + 8) = v2 + v4 + 1;
  if ( v4 )
  {
    v9 = *(_DWORD *)(a1 + 16);
    --*(_DWORD *)(a1 + 20);
    v10 = (*(int (__cdecl **)(int, int, int))(a1 + 40))(a1, v9 - *(_DWORD *)(v5 + 4), a2);
    do
    {
      *(_DWORD *)v10 = *(_DWORD *)v5;
      *(_DWORD *)(v10 + 4) = *(_DWORD *)(v5 + 4);
      v10 += 8;
      v5 += 8;
      v4 -= 2;
    }
    while ( v4 );
    v4 = (v10 - a2) >> 2;
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 20) = v6 - 1;
    if ( v6 >= 4 )
    {
      v7 = (*(int (__cdecl **)(int, int, int))(a1 + 40))(a1, *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 32), a2);
      ++*(_DWORD *)(a1 + 16);
      ++*(_DWORD *)a1;
      return (v7 - a2) >> 2;
    }
  }
  ++*(_DWORD *)(a1 + 16);
  ++*(_DWORD *)a1;
  return v4;
}

//----- (10050C00) --------------------------------------------------------
int __cdecl sub_10050C00(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ebx@1
  int v7; // ecx@2
  int v8; // esi@2
  int result; // eax@3

  v6 = a6;
  if ( a6 )
  {
    v7 = a2;
    v8 = a5;
    do
    {
      result = *(_BYTE *)(a1 - a2 + v7) | (*(_BYTE *)(a1 - a2 + v7 + 1) << 8);
      v8 += 4;
      *(_DWORD *)(v8 - 4) = v7 - *(_DWORD *)(a3 + 4 * result);
      *(_DWORD *)(a3 + 4 * result) = v7++;
      --v6;
    }
    while ( v6 );
  }
  return result;
}

//----- (10050D10) --------------------------------------------------------
int __cdecl sub_10050D10(int a1)
{
  int v1; // edi@1
  int v2; // ST00_4@1
  int v3; // eax@1
  int v4; // ecx@1
  int result; // eax@1

  v1 = *(_DWORD *)(a1 + 376);
  v2 = *(_DWORD *)(a1 + 376);
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 252) = 0;
  sub_100521C0(v2);
  v3 = *(_DWORD *)v1;
  v4 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)a1 = v3;
  *(_DWORD *)(a1 + 16) = v4 + 1;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(v1 + 32);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(v1 + 92);
  *(_DWORD *)(a1 + 36) = v1 + 108;
  *(_DWORD *)(a1 + 264) = *(_DWORD *)(v1 + 36);
  *(_DWORD *)(a1 + 268) = *(_DWORD *)(v1 + 28);
  *(_DWORD *)(a1 + 272) = *(_DWORD *)(v1 + 72);
  *(_DWORD *)(a1 + 276) = *(_DWORD *)(v1 + 4);
  *(_DWORD *)(a1 + 280) = *(_DWORD *)v1;
  *(_DWORD *)(a1 + 284) = *(_DWORD *)(v1 + 20);
  *(_DWORD *)(a1 + 288) = *(_DWORD *)(v1 + 24);
  result = *(_DWORD *)(v1 + 44);
  *(_DWORD *)(a1 + 292) = result;
  return result;
}

//----- (10050DB0) --------------------------------------------------------
void __usercall sub_10050DB0(int a1@<ebx>)
{
  BOOL v1; // eax@1
  int v2; // esi@6
  int v3; // edi@7
  int v4; // eax@7
  int v5; // ecx@8
  unsigned int v6; // ecx@11
  int v7; // edi@12
  int v8; // edx@12
  unsigned int v9; // eax@12
  unsigned int v10; // edi@12
  int v11; // ebp@12
  unsigned int v12; // ecx@12
  int v13; // edx@13
  int v14; // edx@14
  char v15; // bp@17
  unsigned int v16; // edi@17
  int v17; // ebp@17
  unsigned int v18; // eax@17
  void *v19; // ST18_4@22
  int v20; // [sp+Ch] [bp-4h]@1

LABEL_1:
  v20 = 0;
  WaitForSingleObject(*(HANDLE *)(a1 + 316), 0xFFFFFFFF);
  v1 = SetEvent(*(HANDLE *)(a1 + 320));
LABEL_2:
  if ( !v1 )
    GetLastError();
  while ( !*(_DWORD *)(a1 + 304) )
  {
    if ( *(_DWORD *)(a1 + 308) )
    {
      v19 = *(void **)(a1 + 324);
      *(_DWORD *)(a1 + 368) = v20;
      if ( !SetEvent(v19) )
        GetLastError();
      goto LABEL_1;
    }
    v2 = *(_DWORD *)(a1 + 376);
    if ( (unsigned int)(*(_DWORD *)(v2 + 48) + *(_DWORD *)(v2 + 60) - *(_DWORD *)v2) > *(_DWORD *)(v2 + 68) )
    {
      WaitForSingleObject(*(HANDLE *)(a1 + 328), 0xFFFFFFFF);
      if ( !*(_DWORD *)(v2 + 56) && *(_DWORD *)(v2 + 68) >= (unsigned int)(*(_DWORD *)(v2 + 12) - *(_DWORD *)(v2 + 4)) )
        sub_100520A0(v5, v2);
      v6 = *(_DWORD *)(v2 + 4);
      if ( v6 > 0xFFFFDFFF )
      {
        v7 = *(_DWORD *)(v2 + 40);
        v8 = *(_DWORD *)(v2 + 32);
        v9 = v6 - *(_DWORD *)(v2 + 88) - 1;
        *(_DWORD *)(v2 + 8) -= v9;
        *(_DWORD *)(v2 + 12) -= v9;
        v10 = v7 + 1;
        *(_DWORD *)(v2 + 4) = v6 - v9;
        v11 = v8 + 4 * *(_DWORD *)(v2 + 92);
        v12 = 0;
        if ( v10 )
        {
          do
          {
            v13 = *(_DWORD *)(v11 + 4 * v12);
            if ( v13 > v9 )
              v14 = v13 - v9;
            else
              v14 = 0;
            *(_DWORD *)(v11 + 4 * v12++) = v14;
          }
          while ( v12 < v10 );
        }
      }
      v15 = v20;
      v16 = *(_DWORD *)(v2 + 12) - *(_DWORD *)(v2 + 4);
      ++v20;
      v17 = *(_DWORD *)(a1 + 248) + ((v15 & 7) << 15);
      *(_DWORD *)v17 = 2;
      *(_DWORD *)(v17 + 4) = v16;
      v18 = *(_DWORD *)(v2 + 72);
      if ( v16 >= v18 )
      {
        v16 += 1 - v18;
        if ( v16 > 0x1FFE )
          v16 = 8190;
        (*(void (__cdecl **)(int, _DWORD, int, _DWORD, int, unsigned int, int))(a1 + 372))(
          *(_DWORD *)v2,
          *(_DWORD *)(v2 + 4),
          *(_DWORD *)(v2 + 32) + 4 * *(_DWORD *)(v2 + 92),
          *(_DWORD *)(v2 + 40),
          v17 + 8,
          v16,
          v2 + 108);
        *(_DWORD *)v17 += v16;
      }
      *(_DWORD *)(v2 + 4) += v16;
      *(_DWORD *)v2 += v16;
      v1 = ReleaseSemaphore(*(HANDLE *)(a1 + 332), 1, 0);
      goto LABEL_2;
    }
    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 92));
    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 344));
    v3 = *(_DWORD *)v2;
    memmove(
      *(void **)(v2 + 48),
      (const void *)(*(_DWORD *)v2 - *(_DWORD *)(v2 + 64)),
      *(_DWORD *)(v2 + 64) + *(_DWORD *)(v2 + 12) - *(_DWORD *)(v2 + 4));
    v4 = *(_DWORD *)(v2 + 48) + *(_DWORD *)(v2 + 64);
    *(_DWORD *)v2 = v4;
    *(_DWORD *)a1 += v4 - v3;
    *(_DWORD *)(a1 + 280) += v4 - v3;
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 92));
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 344));
  }
}

//----- (10050FA0) --------------------------------------------------------
signed int __usercall sub_10050FA0@<eax>(LONG a1@<edi>, int a2@<esi>, int a3, int a4)
{
  HANDLE v4; // eax@3

  if ( !*(_DWORD *)a2 )
  {
    if ( sub_10050500((LPCRITICAL_SECTION)(a2 + 48)) )
      return 12;
    *(_DWORD *)(a2 + 40) = 1;
    v4 = CreateEventW(0, 0, 0, 0);
    *(_DWORD *)(a2 + 20) = v4;
    if ( !v4 )
    {
      GetLastError();
      return 12;
    }
    if ( sub_10050860((_DWORD *)(a2 + 24)) )
      return 12;
    if ( sub_10050860((_DWORD *)(a2 + 28)) )
      return 12;
    if ( sub_10050690(a1, a1, a2 + 32) )
      return 12;
    if ( sub_10050690(0, a1, a2 + 36) )
      return 12;
    *(_DWORD *)(a2 + 4) = 1;
    if ( sub_10050790(a3, a4, (int *)(a2 + 16)) )
      return 12;
    *(_DWORD *)a2 = 1;
  }
  return 0;
}

//----- (10051050) --------------------------------------------------------
void __usercall sub_10051050(int a1@<esi>)
{
  int v1; // edi@1
  bool v2; // zf@3

  v1 = *(_DWORD *)(a1 + 72);
  if ( *(_DWORD *)(a1 + 16) && !*(_DWORD *)(a1 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 44) == 0;
    *(_DWORD *)(a1 + 12) = 1;
    if ( !v2 )
    {
      LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
      *(_DWORD *)(a1 + 44) = 0;
    }
    if ( !ReleaseSemaphore(*(HANDLE *)(a1 + 32), 1, 0) )
      GetLastError();
    WaitForSingleObject(*(HANDLE *)(a1 + 28), 0xFFFFFFFF);
    while ( v1 != *(_DWORD *)(a1 + 72) )
    {
      ++v1;
      WaitForSingleObject(*(HANDLE *)(a1 + 36), 0xFFFFFFFF);
      if ( !ReleaseSemaphore(*(HANDLE *)(a1 + 32), 1, 0) )
        GetLastError();
    }
    *(_DWORD *)(a1 + 4) = 1;
  }
}

//----- (100510E0) --------------------------------------------------------
void __usercall sub_100510E0(int a1@<esi>)
{
  void *v1; // eax@2
  void *v2; // edx@9

  if ( *(_DWORD *)(a1 + 4) )
  {
    v1 = *(void **)(a1 + 24);
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 72) = 1;
    if ( !ResetEvent(v1) )
      GetLastError();
    if ( !ResetEvent(*(HANDLE *)(a1 + 28)) )
      GetLastError();
    if ( !SetEvent(*(HANDLE *)(a1 + 20)) )
      GetLastError();
    WaitForSingleObject(*(HANDLE *)(a1 + 24), 0xFFFFFFFF);
  }
  else
  {
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
    v2 = *(void **)(a1 + 32);
    ++*(_DWORD *)(a1 + 72);
    *(_DWORD *)(a1 + 44) = 0;
    if ( !ReleaseSemaphore(v2, 1, 0) )
      GetLastError();
  }
  WaitForSingleObject(*(HANDLE *)(a1 + 36), 0xFFFFFFFF);
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
  *(_DWORD *)(a1 + 44) = 1;
}

//----- (10051190) --------------------------------------------------------
unsigned int __usercall sub_10051190@<eax>(int a1@<edi>)
{
  int v1; // ecx@1
  int v2; // eax@1
  int v3; // edx@1
  int v4; // ecx@1
  unsigned int result; // eax@1
  int v6; // esi@2
  unsigned int v7; // ebx@2
  unsigned int v8; // ecx@2
  int v9; // edx@3
  int v10; // edx@4

  sub_100510E0(a1 + 44);
  v1 = *(_DWORD *)(a1 + 4);
  v2 = (((unsigned __int8)*(_DWORD *)(a1 + 116) - 1) & 0x3F) << 14;
  *(_DWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 12) = v2;
  v3 = v2 + *(_DWORD *)(v1 + 4 * v2);
  *(_DWORD *)(a1 + 8) = ++v2;
  *(_DWORD *)(a1 + 12) = v3;
  v4 = *(_DWORD *)(v1 + 4 * v2);
  *(_DWORD *)(a1 + 8) = v2 + 1;
  result = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 20) = v4;
  if ( result >= 0xFFFFBFFF )
  {
    v6 = *(_DWORD *)(a1 + 24);
    v7 = *(_DWORD *)(a1 + 28);
    result = result - *(_DWORD *)(a1 + 32) - 1;
    v8 = 0;
    if ( v7 )
    {
      do
      {
        v9 = *(_DWORD *)(v6 + 4 * v8);
        if ( v9 > result )
          v10 = v9 - result;
        else
          v10 = 0;
        *(_DWORD *)(v6 + 4 * v8++) = v10;
      }
      while ( v8 < v7 );
    }
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 32) + 1;
  }
  return result;
}

//----- (10051210) --------------------------------------------------------
int __stdcall sub_10051210(int a1)
{
  sub_10050DB0(a1);
  return 0;
}

//----- (10051270) --------------------------------------------------------
DWORD __usercall sub_10051270@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  void *v2; // eax@5
  DWORD result; // eax@29

  v1 = a1;
  if ( *(_DWORD *)(a1 + 16) )
  {
    sub_10051050(a1);
    *(_DWORD *)(v1 + 8) = 1;
    if ( *(_DWORD *)(v1 + 4) && !SetEvent(*(HANDLE *)(v1 + 20)) )
      GetLastError();
    v2 = *(void **)(v1 + 16);
    if ( v2 )
      WaitForSingleObject(v2, 0xFFFFFFFF);
    if ( !*(_DWORD *)(v1 + 16) || CloseHandle(*(HANDLE *)(v1 + 16)) )
      *(_DWORD *)(v1 + 16) = 0;
    else
      GetLastError();
  }
  if ( *(_DWORD *)(v1 + 40) )
  {
    DeleteCriticalSection((LPCRITICAL_SECTION)(v1 + 48));
    *(_DWORD *)(v1 + 40) = 0;
  }
  if ( !*(_DWORD *)(v1 + 20) || CloseHandle(*(HANDLE *)(v1 + 20)) )
    *(_DWORD *)(v1 + 20) = 0;
  else
    GetLastError();
  if ( !*(_DWORD *)(v1 + 24) || CloseHandle(*(HANDLE *)(v1 + 24)) )
    *(_DWORD *)(v1 + 24) = 0;
  else
    GetLastError();
  if ( !*(_DWORD *)(v1 + 28) || CloseHandle(*(HANDLE *)(v1 + 28)) )
    *(_DWORD *)(v1 + 28) = 0;
  else
    GetLastError();
  if ( !*(_DWORD *)(v1 + 32) || CloseHandle(*(HANDLE *)(v1 + 32)) )
    *(_DWORD *)(v1 + 32) = 0;
  else
    GetLastError();
  result = *(_DWORD *)(v1 + 36);
  if ( !result || (result = CloseHandle(*(HANDLE *)(v1 + 36))) != 0 )
  {
    *(_DWORD *)(v1 + 36) = 0;
    *(_DWORD *)v1 = 0;
  }
  else
  {
    result = GetLastError();
    *(_DWORD *)v1 = 0;
  }
  return result;
}

//----- (10051360) --------------------------------------------------------
int __cdecl sub_10051360(int a1, int a2)
{
  int v2; // ecx@2
  int v3; // eax@2
  int v4; // edx@2
  int v5; // ecx@2
  unsigned int v6; // eax@2
  unsigned int v7; // ebx@3
  int v8; // esi@3
  unsigned int v9; // eax@3
  unsigned int v10; // ecx@3
  int v11; // edx@4
  int v12; // edx@5
  unsigned int v13; // eax@9
  int v14; // esi@10
  __int16 v15; // dx@10
  int v16; // ecx@10
  int v17; // eax@10
  int v18; // eax@11
  bool v19; // zf@11
  int result; // eax@11

  do
  {
    if ( *(_DWORD *)(a1 + 8) == *(_DWORD *)(a1 + 12) )
    {
      sub_100510E0(a1 + 44);
      v2 = *(_DWORD *)(a1 + 4);
      v3 = (((unsigned __int8)*(_DWORD *)(a1 + 116) - 1) & 0x3F) << 14;
      *(_DWORD *)(a1 + 8) = v3;
      *(_DWORD *)(a1 + 12) = v3;
      v4 = v3 + *(_DWORD *)(v2 + 4 * v3);
      *(_DWORD *)(a1 + 8) = ++v3;
      *(_DWORD *)(a1 + 12) = v4;
      v5 = *(_DWORD *)(v2 + 4 * v3);
      *(_DWORD *)(a1 + 8) = v3 + 1;
      v6 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 20) = v5;
      if ( v6 >= 0xFFFFBFFF )
      {
        v7 = *(_DWORD *)(a1 + 28);
        v8 = *(_DWORD *)(a1 + 24);
        v9 = v6 - *(_DWORD *)(a1 + 32) - 1;
        v10 = 0;
        if ( v7 )
        {
          do
          {
            v11 = *(_DWORD *)(v8 + 4 * v10);
            if ( v11 > v9 )
              v12 = v11 - v9;
            else
              v12 = 0;
            *(_DWORD *)(v8 + 4 * v10++) = v12;
          }
          while ( v10 < v7 );
        }
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 32) + 1;
      }
    }
    v13 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 20) = v13 - 1;
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 24);
      v15 = *(_WORD *)(*(_DWORD *)(a1 + 36) + 4 * **(_BYTE **)a1) ^ *(_BYTE *)(*(_DWORD *)a1 + 1);
      v16 = *(_DWORD *)(a1 + 16);
      v17 = (unsigned __int16)(v15 ^ (*(_BYTE *)(*(_DWORD *)a1 + 2) << 8));
      *(_DWORD *)(v14 + 4 * (v15 & 0x3FF)) = v16;
      *(_DWORD *)(v14 + 4 * v17 + 4096) = v16;
    }
    v18 = *(_DWORD *)(a1 + 8);
    ++*(_DWORD *)(a1 + 16);
    ++*(_DWORD *)a1;
    v19 = a2-- == 1;
    result = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v18) + v18 + 1;
    *(_DWORD *)(a1 + 8) = result;
  }
  while ( !v19 );
  return result;
}

//----- (10051450) --------------------------------------------------------
int __cdecl sub_10051450(int a1, int a2)
{
  int v2; // ecx@2
  int v3; // eax@2
  int v4; // edx@2
  int v5; // ecx@2
  unsigned int v6; // eax@2
  unsigned int v7; // ebx@3
  int v8; // esi@3
  unsigned int v9; // eax@3
  unsigned int v10; // ecx@3
  int v11; // edx@4
  int v12; // edx@5
  unsigned int v13; // eax@9
  int v14; // eax@11
  bool v15; // zf@11
  int result; // eax@11

  do
  {
    if ( *(_DWORD *)(a1 + 8) == *(_DWORD *)(a1 + 12) )
    {
      sub_100510E0(a1 + 44);
      v2 = *(_DWORD *)(a1 + 4);
      v3 = (((unsigned __int8)*(_DWORD *)(a1 + 116) - 1) & 0x3F) << 14;
      *(_DWORD *)(a1 + 8) = v3;
      *(_DWORD *)(a1 + 12) = v3;
      v4 = v3 + *(_DWORD *)(v2 + 4 * v3);
      *(_DWORD *)(a1 + 8) = ++v3;
      *(_DWORD *)(a1 + 12) = v4;
      v5 = *(_DWORD *)(v2 + 4 * v3);
      *(_DWORD *)(a1 + 8) = v3 + 1;
      v6 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 20) = v5;
      if ( v6 >= 0xFFFFBFFF )
      {
        v7 = *(_DWORD *)(a1 + 28);
        v8 = *(_DWORD *)(a1 + 24);
        v9 = v6 - *(_DWORD *)(a1 + 32) - 1;
        v10 = 0;
        if ( v7 )
        {
          do
          {
            v11 = *(_DWORD *)(v8 + 4 * v10);
            if ( v11 > v9 )
              v12 = v11 - v9;
            else
              v12 = 0;
            *(_DWORD *)(v8 + 4 * v10++) = v12;
          }
          while ( v10 < v7 );
        }
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 32) + 1;
      }
    }
    v13 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 20) = v13 - 1;
    if ( v13 >= 2 )
      *(_DWORD *)(*(_DWORD *)(a1 + 24)
                + 4 * ((*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4 * **(_BYTE **)a1) ^ *(_BYTE *)(*(_DWORD *)a1 + 1)) & 0x3FF)) = *(_DWORD *)(a1 + 16);
    v14 = *(_DWORD *)(a1 + 8);
    ++*(_DWORD *)(a1 + 16);
    ++*(_DWORD *)a1;
    v15 = a2-- == 1;
    result = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v14) + v14 + 1;
    *(_DWORD *)(a1 + 8) = result;
  }
  while ( !v15 );
  return result;
}

//----- (10051530) --------------------------------------------------------
int __cdecl sub_10051530(int a1, int a2)
{
  int v2; // ecx@2
  int v3; // eax@2
  int v4; // edx@2
  int v5; // ecx@2
  unsigned int v6; // eax@2
  unsigned int v7; // ebx@3
  int v8; // esi@3
  unsigned int v9; // eax@3
  unsigned int v10; // ecx@3
  int v11; // edx@4
  int v12; // edx@5
  int v13; // eax@9
  bool v14; // zf@9
  int result; // eax@9

  do
  {
    if ( *(_DWORD *)(a1 + 8) == *(_DWORD *)(a1 + 12) )
    {
      sub_100510E0(a1 + 44);
      v2 = *(_DWORD *)(a1 + 4);
      v3 = (((unsigned __int8)*(_DWORD *)(a1 + 116) - 1) & 0x3F) << 14;
      *(_DWORD *)(a1 + 8) = v3;
      *(_DWORD *)(a1 + 12) = v3;
      v4 = v3 + *(_DWORD *)(v2 + 4 * v3);
      *(_DWORD *)(a1 + 8) = ++v3;
      *(_DWORD *)(a1 + 12) = v4;
      v5 = *(_DWORD *)(v2 + 4 * v3);
      *(_DWORD *)(a1 + 8) = v3 + 1;
      v6 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 20) = v5;
      if ( v6 >= 0xFFFFBFFF )
      {
        v7 = *(_DWORD *)(a1 + 28);
        v8 = *(_DWORD *)(a1 + 24);
        v9 = v6 - *(_DWORD *)(a1 + 32) - 1;
        v10 = 0;
        if ( v7 )
        {
          do
          {
            v11 = *(_DWORD *)(v8 + 4 * v10);
            if ( v11 > v9 )
              v12 = v11 - v9;
            else
              v12 = 0;
            *(_DWORD *)(v8 + 4 * v10++) = v12;
          }
          while ( v10 < v7 );
        }
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 32) + 1;
      }
    }
    v13 = *(_DWORD *)(a1 + 8);
    --*(_DWORD *)(a1 + 20);
    ++*(_DWORD *)(a1 + 16);
    ++*(_DWORD *)a1;
    v14 = a2-- == 1;
    result = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v13) + v13 + 1;
    *(_DWORD *)(a1 + 8) = result;
  }
  while ( !v14 );
  return result;
}

//----- (10051640) --------------------------------------------------------
unsigned int __usercall sub_10051640@<eax>(int a1@<edi>, unsigned int a2)
{
  unsigned int result; // eax@1
  unsigned int v3; // ebx@1
  unsigned int v4; // ebp@1
  int v5; // eax@2
  int v6; // ecx@2
  int v7; // ecx@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // ecx@3
  unsigned int v11; // ecx@3
  unsigned int v12; // edx@7
  int v13; // esi@7
  int v14; // ebx@7
  unsigned int v15; // ecx@7
  unsigned int v16; // eax@7
  unsigned int v17; // eax@9
  _DWORD *v18; // esi@17
  int v19; // ecx@17
  int v20; // eax@17
  int v21; // eax@17
  int v22; // eax@18
  unsigned int v23; // [sp+8h] [bp-14h]@7
  int v24; // [sp+Ch] [bp-10h]@16
  int v25; // [sp+10h] [bp-Ch]@7
  int v26; // [sp+14h] [bp-8h]@1
  unsigned int v27; // [sp+18h] [bp-4h]@1

  result = a2;
  v3 = 2 * (0x2000 - *(_DWORD *)(a1 + 268));
  v4 = 2;
  v26 = 0;
  v27 = v3;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 260);
  if ( v3 <= 2 )
  {
    *(_DWORD *)a2 = 2;
    return result;
  }
  while ( 1 )
  {
    v5 = *(_DWORD *)(a1 + 256);
    v6 = *(_DWORD *)(a1 + 252);
    if ( v6 != v5 )
    {
      v12 = *(_DWORD *)(a1 + 268);
      v13 = *(_DWORD *)(a1 + 284);
      v14 = *(_DWORD *)(a1 + 276);
      v15 = v5 - v6;
      v16 = *(_DWORD *)(a1 + 260);
      v25 = v12;
      v23 = *(_DWORD *)(a1 + 284);
      if ( v12 >= v16 )
      {
        v25 = *(_DWORD *)(a1 + 260);
        v12 = *(_DWORD *)(a1 + 260);
      }
      v17 = v16 - v12 + 1;
      if ( v17 < v15 )
        v15 = v17;
      if ( *(_DWORD *)(a1 + 288) - v13 < v15 )
        v15 = *(_DWORD *)(a1 + 288) - v13;
      if ( v4 < v27 )
      {
        while ( 1 )
        {
          v24 = v15 - 1;
          if ( !v15 )
            break;
          v18 = (_DWORD *)(a2 + 4 * v4);
          v19 = *(_DWORD *)(a1 + 252) + 1;
          v20 = v14 - *(_DWORD *)(*(_DWORD *)(a1 + 248) + 4 * v19 - 4);
          *(_DWORD *)(a1 + 252) = v19;
          v21 = (sub_10051D20(
                   v25,
                   v20,
                   v14,
                   *(_DWORD *)(a1 + 280),
                   *(_DWORD *)(a1 + 264),
                   v23,
                   *(_DWORD *)(a1 + 288),
                   *(_DWORD *)(a1 + 292),
                   (int)(v18 + 1),
                   *(_DWORD *)(a1 + 272) - 1)
               - (signed int)v18) >> 2;
          v4 += v21;
          ++v23;
          *v18 = v21 - 1;
          ++*(_DWORD *)(a1 + 280);
          ++v14;
          if ( v4 >= v27 )
            break;
          v15 = v24;
        }
      }
      v22 = *(_DWORD *)(a1 + 276);
      v26 += v14 - v22;
      *(_DWORD *)(a1 + 260) += v22 - v14;
      result = v23;
      *(_DWORD *)(a1 + 276) = v14;
      if ( v23 == *(_DWORD *)(a1 + 288) )
        v23 = 0;
      v3 = v27;
      *(_DWORD *)(a1 + 284) = v23;
      goto LABEL_21;
    }
    sub_100510E0(a1 + 296);
    v7 = *(_DWORD *)(a1 + 248);
    v8 = (((unsigned __int8)*(_DWORD *)(a1 + 368) - 1) & 7) << 13;
    *(_DWORD *)(a1 + 252) = v8;
    *(_DWORD *)(a1 + 256) = v8;
    v9 = v8 + *(_DWORD *)(v7 + 4 * v8);
    *(_DWORD *)(a1 + 252) = ++v8;
    *(_DWORD *)(a1 + 256) = v9;
    v10 = *(_DWORD *)(v7 + 4 * v8);
    *(_DWORD *)(a1 + 260) = v10;
    *(_DWORD *)(a1 + 252) = v8 + 1;
    result = a2;
    *(_DWORD *)(a2 + 4) = v26 + v10;
    v11 = *(_DWORD *)(a1 + 260);
    if ( v11 < *(_DWORD *)(a1 + 272) )
      break;
LABEL_21:
    if ( v4 >= v3 )
    {
      *(_DWORD *)a2 = v4;
      return result;
    }
  }
  if ( v11 )
  {
    do
    {
      *(_DWORD *)(a2 + 4 * v4) = 0;
      --*(_DWORD *)(a1 + 260);
      ++v4;
    }
    while ( *(_DWORD *)(a1 + 260) );
  }
  *(_DWORD *)a2 = v4;
  return result;
}

//----- (100518B0) --------------------------------------------------------
int __usercall sub_100518B0@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  int (*v3)(); // edx@3

  *(_DWORD *)result = sub_10050D10;
  *(_DWORD *)(result + 4) = sub_10050AA0;
  *(_DWORD *)(result + 8) = sub_100515E0;
  *(_DWORD *)(result + 12) = sub_10050AB0;
  *(_DWORD *)(result + 16) = sub_10050890;
  v2 = *(_DWORD *)(a2 + 376);
  if ( *(_DWORD *)(v2 + 72) == 2 )
  {
    *(_DWORD *)(a2 + 372) = sub_10050C00;
    *(_DWORD *)(a2 + 40) = 0;
    *(_DWORD *)(result + 20) = sub_10051530;
    *(_DWORD *)(result + 16) = sub_10050930;
  }
  else if ( *(_DWORD *)(v2 + 72) == 3 )
  {
    *(_DWORD *)(a2 + 372) = sub_10050BA0;
    *(_DWORD *)(a2 + 40) = sub_10050A40;
    *(_DWORD *)(result + 20) = sub_10051450;
  }
  else
  {
    v3 = sub_10050AE0;
    if ( !*(_DWORD *)(v2 + 84) )
      v3 = sub_10050B40;
    *(_DWORD *)(a2 + 372) = v3;
    *(_DWORD *)(a2 + 40) = sub_10050980;
    *(_DWORD *)(result + 20) = sub_10051360;
  }
  return result;
}
// 10050930: using guessed type int sub_10050930();
// 10050980: using guessed type int sub_10050980();
// 10050A40: using guessed type int sub_10050A40();
// 10050AA0: using guessed type int sub_10050AA0();
// 10050AB0: using guessed type int sub_10050AB0();
// 10050AE0: using guessed type int sub_10050AE0();
// 10050B40: using guessed type int sub_10050B40();
// 10050BA0: using guessed type int sub_10050BA0();
// 100515E0: using guessed type int sub_100515E0();

//----- (10051950) --------------------------------------------------------
void __usercall sub_10051950(char a1@<al>, int a2@<ecx>)
{
  int v2; // edi@1
  char v3; // si@1
  unsigned int v4; // eax@3
  int v5; // ecx@4
  int v6; // edx@4
  unsigned int v7; // ebx@4
  unsigned int v8; // esi@4
  unsigned int v9; // eax@4
  int v10; // ecx@5
  int v11; // ecx@6

  v2 = a2;
  v3 = a1;
  if ( !*(_DWORD *)(a2 + 300) )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(a2 + 344));
    *(_DWORD *)(v2 + 340) = 1;
  }
  sub_10051640(v2, *(_DWORD *)(v2 + 4) + ((v3 & 0x3F) << 16));
  v4 = *(_DWORD *)(v2 + 276);
  if ( v4 > 0xFFFFBFFF )
  {
    v5 = *(_DWORD *)(v2 + 288);
    v6 = *(_DWORD *)(v2 + 264);
    v7 = v4 - v5;
    v8 = 2 * v5;
    v9 = 0;
    if ( 2 * v5 )
    {
      do
      {
        v10 = *(_DWORD *)(v6 + 4 * v9);
        if ( v10 > v7 )
          v11 = v10 - v7;
        else
          v11 = 0;
        *(_DWORD *)(v6 + 4 * v9++) = v11;
      }
      while ( v9 < v8 );
    }
    *(_DWORD *)(v2 + 276) -= v7;
  }
  if ( !*(_DWORD *)(v2 + 300) )
  {
    LeaveCriticalSection((LPCRITICAL_SECTION)(v2 + 344));
    *(_DWORD *)(v2 + 340) = 0;
  }
}

//----- (10051A80) --------------------------------------------------------
int __stdcall sub_10051A80(int a1)
{
  signed int v1; // eax@1
  int v2; // esi@3
  BOOL i; // eax@3

  v1 = 0;
  do
    ++v1;
  while ( v1 < 16 );
LABEL_3:
  v2 = 0;
  WaitForSingleObject(*(HANDLE *)(a1 + 64), 0xFFFFFFFF);
  for ( i = SetEvent(*(HANDLE *)(a1 + 68)); ; i = ReleaseSemaphore(*(HANDLE *)(a1 + 80), 1, 0) )
  {
    if ( !i )
      GetLastError();
    if ( *(_DWORD *)(a1 + 52) )
      break;
    if ( *(_DWORD *)(a1 + 56) )
    {
      *(_DWORD *)(a1 + 116) = v2;
      sub_10051050(a1 + 296);
      if ( !SetEvent(*(HANDLE *)(a1 + 72)) )
        GetLastError();
      goto LABEL_3;
    }
    WaitForSingleObject(*(HANDLE *)(a1 + 76), 0xFFFFFFFF);
    sub_10051950(v2++, a1);
  }
  return 0;
}

//----- (10051B20) --------------------------------------------------------
signed int __usercall sub_10051B20@<eax>(int a1@<eax>, unsigned int a2@<ecx>, int a3@<ebx>, int a4)
{
  int v4; // ebp@1
  int v5; // esi@1
  unsigned int v6; // edi@1
  signed int result; // eax@2
  int v8; // eax@4
  int v9; // esi@8
  signed int v10; // edi@8

  v4 = *(_DWORD *)(a3 + 376);
  v5 = a1;
  v6 = a2;
  *(_DWORD *)(a3 + 32) = a2;
  if ( (unsigned int)(4 * a1) >= 0x4000 )
    return 5;
  if ( !*(_DWORD *)(a3 + 248) )
  {
    v8 = off_100AD048(&off_100AD048, 4456448);
    *(_DWORD *)(a3 + 248) = v8;
    if ( !v8 )
      return 2;
    *(_DWORD *)(a3 + 4) = v8 + 0x40000;
  }
  if ( !sub_100524B0(v5, a4 + 1114112, 8465, v4, v6) )
    return 2;
  v9 = a3 + 296;
  v10 = sub_10050FA0(8, a3 + 296, (int)sub_10051210, a3);
  if ( v10 || (v9 = a3 + 44, result = sub_10050FA0(64, a3 + 44, (int)sub_10051A80, a3), (v10 = result) != 0) )
  {
    sub_10051270(v9);
    result = v10;
  }
  return result;
}
// 100AD048: using guessed type int (__cdecl *off_100AD048)(_DWORD, _DWORD);

//----- (10051BF0) --------------------------------------------------------
_DWORD *__usercall sub_10051BF0@<eax>(int a1@<edx>, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, int a8)
{
  unsigned int v8; // esi@1
  _DWORD *v9; // edi@1
  unsigned int v10; // ebx@1
  unsigned int v11; // ebp@1
  unsigned int v12; // eax@1
  int v13; // edi@3
  int v14; // ecx@3
  unsigned int v15; // eax@3
  _BYTE *v16; // esi@7
  _DWORD *result; // eax@10
  _DWORD *v18; // [sp+10h] [bp-10h]@1
  _DWORD *v19; // [sp+14h] [bp-Ch]@1
  unsigned int v20; // [sp+18h] [bp-8h]@1
  unsigned int v21; // [sp+1Ch] [bp-4h]@1

  v8 = a6;
  v9 = (_DWORD *)(a5 + 8 * a6);
  v10 = 0;
  v11 = 0;
  v12 = a3 - a1;
  v19 = (_DWORD *)(a5 + 8 * a6 + 4);
  v18 = (_DWORD *)(a5 + 8 * a6);
  v20 = 0;
  v21 = 0;
  if ( a8 )
  {
    while ( 1 )
    {
      --a8;
      if ( v12 >= a7 )
        break;
      v13 = a5 + 8 * (v8 + (v8 < v12 ? a7 : 0) - v12);
      v14 = a4 - v12;
      v15 = v10;
      if ( v10 >= v11 )
        v15 = v11;
      if ( *(_BYTE *)(v15 + v14) == *(_BYTE *)(v15 + a4) )
      {
        if ( ++v15 == a2 )
          goto LABEL_10;
        v16 = (_BYTE *)(v15 + a4);
        while ( v16[v14 - a4] == *v16 )
        {
          ++v15;
          ++v16;
          if ( v15 == a2 )
            goto LABEL_10;
        }
        if ( v15 == a2 )
        {
LABEL_10:
          result = v18;
          *v18 = *(_DWORD *)v13;
          *v19 = *(_DWORD *)(v13 + 4);
          return result;
        }
      }
      if ( *(_BYTE *)(v15 + v14) >= *(_BYTE *)(v15 + a4) )
      {
        v11 = v21;
        *v19 = a1;
        a1 = *(_DWORD *)v13;
        v10 = v15;
        v19 = (_DWORD *)v13;
        v9 = v18;
        v20 = v15;
      }
      else
      {
        v10 = v20;
        v9 = (_DWORD *)(v13 + 4);
        v11 = v15;
        *v18 = a1;
        a1 = *v9;
        v18 = v9;
        v21 = v15;
      }
      v12 = a3 - a1;
      if ( !a8 )
        break;
      v8 = a6;
    }
  }
  result = v19;
  *v9 = 0;
  *v19 = 0;
  return result;
}

//----- (10051D20) --------------------------------------------------------
int __cdecl sub_10051D20(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, int a8, int a9, unsigned int a10)
{
  unsigned int v10; // ebx@1
  unsigned int v11; // edi@1
  unsigned int v12; // edx@1
  _DWORD *v13; // esi@1
  unsigned int v14; // ecx@1
  unsigned int v15; // ebp@1
  int result; // eax@2
  int v17; // ebx@5
  int v18; // esi@5
  _BYTE *v19; // edi@11
  int v20; // ebx@17
  _DWORD *v21; // [sp+10h] [bp-10h]@1
  _DWORD *v22; // [sp+14h] [bp-Ch]@1
  unsigned int v23; // [sp+18h] [bp-8h]@1
  unsigned int v24; // [sp+1Ch] [bp-4h]@1

  v10 = a7;
  v11 = a6;
  v22 = (_DWORD *)(a5 + 8 * a6 + 4);
  v12 = a3 - a2;
  v13 = (_DWORD *)(a5 + 8 * a6);
  v14 = 0;
  v15 = 0;
  v21 = (_DWORD *)(a5 + 8 * a6);
  v23 = 0;
  v24 = 0;
  if ( a8 )
  {
    while ( 1 )
    {
      --a8;
      if ( v12 >= v10 )
        break;
      v17 = a5 + 8 * (v11 + (v11 < v12 ? v10 : 0) - v12);
      v18 = a4 - v12;
      if ( v14 >= v15 )
        v14 = v15;
      if ( *(_BYTE *)(v14 + v18) == *(_BYTE *)(v14 + a4) )
      {
        if ( ++v14 != a1 && *(_BYTE *)(v14 + v18) == *(_BYTE *)(v14 + a4) && ++v14 != a1 )
        {
          v19 = (_BYTE *)(v14 + a4);
          do
          {
            if ( v19[v18 - a4] != *v19 )
              break;
            ++v14;
            ++v19;
          }
          while ( v14 != a1 );
        }
        if ( a10 < v14 )
        {
          *(_DWORD *)a9 = v14;
          *(_DWORD *)(a9 + 4) = v12 - 1;
          result = a9 + 8;
          a10 = v14;
          a9 += 8;
          if ( v14 == a1 )
          {
            *v21 = *(_DWORD *)v17;
            *v22 = *(_DWORD *)(v17 + 4);
            return result;
          }
        }
      }
      if ( *(_BYTE *)(v14 + v18) >= *(_BYTE *)(v14 + a4) )
      {
        v13 = v21;
        v15 = v24;
        *v22 = a2;
        v22 = (_DWORD *)v17;
        v20 = *(_DWORD *)v17;
        v23 = v14;
      }
      else
      {
        v13 = (_DWORD *)(v17 + 4);
        v15 = v14;
        v14 = v23;
        *v21 = a2;
        v20 = *(_DWORD *)(v17 + 4);
        v21 = v13;
        v24 = v15;
      }
      v12 = a3 - v20;
      a2 = v20;
      if ( !a8 )
        break;
      v10 = a7;
      v11 = a6;
    }
  }
  *v13 = 0;
  *v22 = 0;
  return a9;
}

//----- (10051E80) --------------------------------------------------------
int __usercall sub_10051E80@<eax>(unsigned int a1@<eax>, int a2, int a3, int a4, _BYTE *a5, int a6, unsigned int a7, unsigned int a8, int a9, int a10)
{
  unsigned int v10; // ebx@1
  unsigned int v11; // eax@1
  unsigned int v12; // esi@1
  unsigned int v13; // ecx@1
  int v14; // edi@1
  _BYTE *v15; // edx@5
  unsigned int v16; // esi@7
  int v17; // edx@8
  _BYTE *v18; // edi@8
  int i; // [sp+10h] [bp-4h]@8
  int v21; // [sp+1Ch] [bp+8h]@5

  v10 = a1;
  v11 = a7;
  *(_DWORD *)(a6 + 4 * a7) = a3;
  v12 = a8;
  v13 = a4 - a3;
  v14 = a10;
  if ( a9 )
  {
    while ( 1 )
    {
      --a9;
      if ( v13 >= v12 )
        break;
      v15 = &a5[-v13];
      v21 = *(_DWORD *)(a6 + 4 * (v11 + (v11 < v13 ? v12 : 0) - v13));
      if ( *(&a5[v10] - v13) != a5[v10] || *v15 != *a5 )
      {
        v14 = a10;
      }
      else
      {
        v16 = 1;
        if ( a2 != 1 )
        {
          v17 = v15 - a5;
          v18 = a5 + 1;
          for ( i = v17; v18[v17] == *v18; v17 = i )
          {
            ++v16;
            ++v18;
            if ( v16 == a2 )
              break;
          }
        }
        v14 = a10;
        if ( v10 < v16 )
        {
          *(_DWORD *)a10 = v16;
          *(_DWORD *)(a10 + 4) = v13 - 1;
          v14 = a10 + 8;
          v10 = v16;
          a10 += 8;
          if ( v16 == a2 )
            return v14;
        }
      }
      v13 = a4 - v21;
      if ( !a9 )
        return v14;
      v12 = a8;
      v11 = a7;
    }
  }
  return v14;
}

//----- (100520A0) --------------------------------------------------------
void __usercall sub_100520A0(int a1@<ecx>, int a2@<esi>)
{
  int v2; // eax@3
  int v3; // eax@4
  int v4; // [sp+0h] [bp-4h]@1

  v4 = a1;
  if ( !*(_DWORD *)(a2 + 56) && !*(_DWORD *)(a2 + 104) )
  {
    v2 = *(_DWORD *)(a2 + 12) + *(_DWORD *)a2 - *(_DWORD *)(a2 + 4);
    v4 = *(_DWORD *)(a2 + 60) + *(_DWORD *)(a2 + 48) - v2;
    if ( v4 )
    {
      while ( 1 )
      {
        v3 = (**(int (__cdecl ***)(_DWORD, int, int *))(a2 + 52))(*(_DWORD *)(a2 + 52), v2, &v4);
        *(_DWORD *)(a2 + 104) = v3;
        if ( v3 )
          break;
        if ( !v4 )
        {
          *(_DWORD *)(a2 + 56) = 1;
          return;
        }
        *(_DWORD *)(a2 + 12) += v4;
        if ( (unsigned int)(*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4)) <= *(_DWORD *)(a2 + 68) )
        {
          v2 = *(_DWORD *)(a2 + 12) + *(_DWORD *)a2 - *(_DWORD *)(a2 + 4);
          v4 = *(_DWORD *)(a2 + 60) + *(_DWORD *)(a2 + 48) - v2;
          if ( v4 )
            continue;
        }
        return;
      }
    }
  }
}

//----- (10052170) --------------------------------------------------------
unsigned int __usercall sub_10052170@<eax>(int a1@<esi>)
{
  int v1; // ebx@1
  int v2; // edi@1
  unsigned int result; // eax@1
  bool v4; // zf@1
  unsigned int v5; // edi@1
  unsigned int v6; // ecx@1
  int v7; // edx@2
  int v8; // edx@3

  v1 = *(_DWORD *)(a1 + 32);
  v2 = *(_DWORD *)(a1 + 100);
  result = (*(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 88) - 1) & 0xFFFFFC00;
  v4 = *(_DWORD *)(a1 + 96) + v2 == 0;
  v5 = *(_DWORD *)(a1 + 96) + v2;
  v6 = 0;
  if ( !v4 )
  {
    do
    {
      v7 = *(_DWORD *)(v1 + 4 * v6);
      if ( v7 > result )
        v8 = v7 - result;
      else
        v8 = 0;
      *(_DWORD *)(v1 + 4 * v6++) = v8;
    }
    while ( v6 < v5 );
  }
  *(_DWORD *)(a1 + 8) -= result;
  *(_DWORD *)(a1 + 4) -= result;
  *(_DWORD *)(a1 + 12) -= result;
  return result;
}

//----- (100521C0) --------------------------------------------------------
int __cdecl sub_100521C0(int a1)
{
  int v1; // ecx@0
  unsigned int v2; // eax@1
  int v3; // eax@3
  int v4; // edx@3
  int v5; // ebx@3
  unsigned int v6; // ecx@3
  unsigned int v7; // edx@5
  int v8; // edi@5
  unsigned int v9; // eax@6
  int result; // eax@10

  v2 = 0;
  if ( *(_DWORD *)(a1 + 96) )
  {
    do
    {
      v1 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(v1 + 4 * v2++) = 0;
    }
    while ( v2 < *(_DWORD *)(a1 + 96) );
  }
  v3 = *(_DWORD *)(a1 + 24);
  v4 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)a1 = v4;
  *(_DWORD *)(a1 + 12) = v3;
  *(_DWORD *)(a1 + 4) = v3;
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  sub_100520A0(v1, a1);
  v5 = *(_DWORD *)(a1 + 4);
  v6 = -1 - v5;
  if ( *(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 20) < (unsigned int)(-1 - v5) )
    v6 = *(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 20);
  v7 = *(_DWORD *)(a1 + 12) - v5;
  v8 = *(_DWORD *)(a1 + 68);
  if ( v7 > v8 )
    v9 = v7 - v8;
  else
    v9 = *(_DWORD *)(a1 + 12) != v5;
  if ( v9 < v6 )
    v6 = v9;
  result = *(_DWORD *)(a1 + 12) - v5;
  if ( v7 > *(_DWORD *)(a1 + 28) )
    result = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 8) = v6 + v5;
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

//----- (100522A0) --------------------------------------------------------
unsigned int __usercall sub_100522A0@<eax>(int a1@<eax>)
{
  unsigned int v1; // edx@1
  unsigned int *v2; // esi@1
  unsigned int v3; // ecx@2
  unsigned int v4; // eax@2
  unsigned int v5; // ecx@2
  unsigned int result; // eax@2

  v1 = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 44) = 32;
  *(_DWORD *)(a1 + 80) = 1;
  *(_DWORD *)(a1 + 72) = 4;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  v2 = (unsigned int *)(a1 + 108);
  do
  {
    v3 = ((((((((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1)
                                                                  - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1)
                                                                                             - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320) >> 1;
    v4 = v3 ^ ~((((unsigned __int8)(((((((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1)
                                                                                           - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1)
              - 1) & 0xEDB88320;
    v5 = (v4 >> 1) ^ ~((((unsigned __int8)v3 ^ ~((((unsigned __int8)(((((((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(((v1 >> 1) ^ ~((v1 & 1) - 1) & 0xEDB88320) >> 1) ^ ~((((unsigned __int8)(v1 >> 1) ^ ~((v1 & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1) - 1) & 0x20) & 1)
                                               - 1) & 0x20) & 1)
                     - 1) & 0xEDB88320;
    result = ((v5 >> 1) ^ ~((v5 & 1) - 1) & 0xEDB88320) >> 1;
    *v2 = result ^ ~((((unsigned __int8)(v5 >> 1) ^ ~((v5 & 1) - 1) & 0x20) & 1) - 1) & 0xEDB88320;
    ++v1;
    ++v2;
  }
  while ( v1 < 0x100 );
  return result;
}

//----- (10052370) --------------------------------------------------------
void __usercall sub_10052370(int *a1@<eax>)
{
  int v1; // esi@1
  int v2; // eax@1
  char *v3; // edx@1
  unsigned int v4; // ecx@1

  v1 = (int)a1;
  v2 = *a1;
  v3 = *(char **)(v1 + 48);
  v4 = (unsigned int)&v3[*(_DWORD *)(v1 + 60) - v2];
  if ( v4 <= *(_DWORD *)(v1 + 68) )
  {
    memmove(
      v3,
      (const void *)(v2 - *(_DWORD *)(v1 + 64)),
      *(_DWORD *)(v1 + 64) + *(_DWORD *)(v1 + 12) - *(_DWORD *)(v1 + 4));
    *(_DWORD *)v1 = *(_DWORD *)(v1 + 48) + *(_DWORD *)(v1 + 64);
  }
  sub_100520A0(v4, v1);
}

//----- (100523D0) --------------------------------------------------------
signed int __usercall sub_100523D0@<eax>(int a1@<esi>, int a2)
{
  int v2; // edi@1
  signed int result; // eax@2

  v2 = a2 + *(_DWORD *)(a1 + 64) + *(_DWORD *)(a1 + 68);
  if ( *(_DWORD *)(a1 + 76) )
  {
    *(_DWORD *)(a1 + 60) = v2;
    result = 1;
  }
  else
  {
    if ( !*(_DWORD *)(a1 + 48) || *(_DWORD *)(a1 + 60) != v2 )
    {
      off_100AD04C(&off_100AD048, *(_DWORD *)(a1 + 48));
      *(_DWORD *)(a1 + 48) = 0;
      *(_DWORD *)(a1 + 60) = v2;
      *(_DWORD *)(a1 + 48) = off_100AD048(&off_100AD048, v2);
    }
    result = *(_DWORD *)(a1 + 48) != 0;
  }
  return result;
}
// 100AD048: using guessed type int (__cdecl *off_100AD048)(_DWORD, _DWORD);
// 100AD04C: using guessed type int (__cdecl *off_100AD04C)(_DWORD, _DWORD);

//----- (10052430) --------------------------------------------------------
unsigned int __usercall sub_10052430@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ecx@6
  int v3; // edi@8
  unsigned int v4; // ecx@8
  unsigned int result; // eax@8
  unsigned int v6; // edx@10
  int v7; // ebx@10
  unsigned int v8; // ecx@11

  v1 = a1;
  if ( *(_DWORD *)(a1 + 4) == -1 )
    sub_10052170(a1);
  if ( !*(_DWORD *)(v1 + 56) && *(_DWORD *)(v1 + 68) == *(_DWORD *)(v1 + 12) - *(_DWORD *)(v1 + 4) )
    sub_10052370((int *)v1);
  v2 = *(_DWORD *)(v1 + 24);
  if ( *(_DWORD *)(v1 + 20) == v2 )
    *(_DWORD *)(v1 + 20) = 0;
  v3 = *(_DWORD *)(v1 + 4);
  v4 = v2 - *(_DWORD *)(v1 + 20);
  result = -1 - v3;
  if ( v4 < -1 - v3 )
    result = v4;
  v6 = *(_DWORD *)(v1 + 12) - v3;
  v7 = *(_DWORD *)(v1 + 68);
  if ( v6 > v7 )
    v8 = v6 - v7;
  else
    v8 = *(_DWORD *)(v1 + 12) != v3;
  if ( v8 < result )
    result = v8;
  if ( v6 > *(_DWORD *)(v1 + 28) )
    v6 = *(_DWORD *)(v1 + 28);
  *(_DWORD *)(v1 + 8) = result + v3;
  *(_DWORD *)(v1 + 16) = v6;
  return result;
}

//----- (100524B0) --------------------------------------------------------
signed int __usercall sub_100524B0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, unsigned int a5)
{
  int v5; // ebx@1
  unsigned int v7; // eax@5
  unsigned int v8; // edx@8
  int v9; // ebp@8
  unsigned int v10; // eax@9
  unsigned int v11; // ecx@10
  int v12; // eax@14
  int v13; // eax@20
  int v14; // ecx@20
  int v15; // edx@20
  int v16; // edi@22
  int v17; // eax@22
  int v18; // eax@25

  v5 = a1;
  if ( a5 > 0xC0000000 )
  {
    off_100AD04C(&off_100AD048, *(_DWORD *)(a4 + 32));
    *(_DWORD *)(a4 + 32) = 0;
    if ( !*(_DWORD *)(a4 + 76) )
    {
      off_100AD04C(&off_100AD048, *(_DWORD *)(a4 + 48));
      *(_DWORD *)(a4 + 48) = 0;
    }
    return 0;
  }
  v7 = a5 >> 1;
  if ( a5 > 0x80000000 )
    v7 = a5 >> 2;
  *(_DWORD *)(a4 + 64) = a5 + a2 + 1;
  *(_DWORD *)(a4 + 68) = v5 + a3;
  if ( sub_100523D0(a4, ((unsigned int)(a3 + v5 + a2) >> 1) + v7 + 0x80000) )
  {
    v8 = *(_DWORD *)(a4 + 72);
    *(_DWORD *)(a4 + 28) = v5;
    v9 = a5 + 1;
    *(_DWORD *)(a4 + 92) = 0;
    if ( v8 == 2 )
    {
      v10 = 0xFFFF;
    }
    else
    {
      v11 = ((((((a5 - 1) >> 1) | (a5 - 1)) >> 2) | ((a5 - 1) >> 1) | (a5 - 1)) >> 4) | ((((a5 - 1) >> 1) | (a5 - 1)) >> 2) | ((a5 - 1) >> 1) | (a5 - 1);
      v10 = (v11 | ((v11 | 0x1FFFE00) >> 8)) >> 1;
      if ( v10 > 0x1000000 )
      {
        if ( v8 == 3 )
          v10 = 0xFFFFFF;
        else
          v10 = (v11 | ((((((((a5 - 1) >> 1) | (a5 - 1)) >> 2) | ((a5 - 1) >> 1) | (a5 - 1)) >> 4) | ((((a5 - 1) >> 1) | (a5 - 1)) >> 2) | ((a5 - 1) >> 1) | (a5 - 1) | 0x1FFFE00) >> 8)) >> 2;
      }
    }
    *(_DWORD *)(a4 + 40) = v10;
    v12 = v10 + 1;
    if ( v8 > 2 )
      *(_DWORD *)(a4 + 92) = 1024;
    if ( v8 > 3 )
      *(_DWORD *)(a4 + 92) += 0x10000;
    if ( v8 > 4 )
      *(_DWORD *)(a4 + 92) += 0x100000;
    v13 = *(_DWORD *)(a4 + 92) + v12;
    v14 = *(_DWORD *)(a4 + 100) + *(_DWORD *)(a4 + 96);
    *(_DWORD *)(a4 + 88) = a5;
    *(_DWORD *)(a4 + 96) = v13;
    *(_DWORD *)(a4 + 24) = v9;
    v15 = 2 * v9;
    if ( !*(_DWORD *)(a4 + 80) )
      v15 = a5 + 1;
    v16 = v13 + v15;
    v17 = *(_DWORD *)(a4 + 32);
    *(_DWORD *)(a4 + 100) = v15;
    if ( v17 && v14 == v16 )
      return 1;
    off_100AD04C(&off_100AD048, v17);
    *(_DWORD *)(a4 + 32) = 0;
    if ( (unsigned int)(4 * v16) >> 2 == v16 )
      v18 = off_100AD048(&off_100AD048, 4 * v16);
    else
      v18 = 0;
    *(_DWORD *)(a4 + 32) = v18;
    if ( v18 )
    {
      *(_DWORD *)(a4 + 36) = v18 + 4 * *(_DWORD *)(a4 + 96);
      return 1;
    }
  }
  off_100AD04C(&off_100AD048, *(_DWORD *)(a4 + 32));
  *(_DWORD *)(a4 + 32) = 0;
  if ( !*(_DWORD *)(a4 + 76) )
  {
    off_100AD04C(&off_100AD048, *(_DWORD *)(a4 + 48));
    *(_DWORD *)(a4 + 48) = 0;
  }
  return 0;
}
// 100AD048: using guessed type int (__cdecl *off_100AD048)(_DWORD, _DWORD);
// 100AD04C: using guessed type int (__cdecl *off_100AD04C)(_DWORD, _DWORD);

//----- (10052690) --------------------------------------------------------
unsigned int __cdecl sub_10052690(int a1, int a2)
{
  int v2; // ecx@2
  __int16 v3; // dx@2
  int v4; // edi@2
  int v5; // eax@2
  int v6; // ebx@2
  int v7; // edx@2
  unsigned int result; // eax@3

  do
  {
    if ( *(_DWORD *)(a1 + 16) >= 4u )
    {
      v2 = *(_DWORD *)(a1 + 4 * **(_BYTE **)a1 + 108) ^ *(_BYTE *)(*(_DWORD *)a1 + 1);
      v3 = *(_BYTE *)(*(_DWORD *)a1 + 2);
      v4 = *(_DWORD *)(a1 + 32);
      v5 = *(_DWORD *)(a1 + 40) & (v2 ^ 32
                                      * (*(_DWORD *)(a1 + 4 * *(_BYTE *)(*(_DWORD *)a1 + 3) + 108) ^ 8 * *(_BYTE *)(*(_DWORD *)a1 + 2)));
      v6 = *(_DWORD *)(v4 + 4 * v5 + 266240);
      *(_DWORD *)(v4 + 4 * v5 + 266240) = *(_DWORD *)(a1 + 4);
      v7 = (unsigned __int16)(v2 ^ (v3 << 8));
      *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4 * v7 + 4096) = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4 * v5 + 266240);
      *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4 * (v2 & 0x3FF)) = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4 * v7 + 4096);
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 4 * *(_DWORD *)(a1 + 20)) = v6;
    }
    result = ++*(_DWORD *)(a1 + 4);
    ++*(_DWORD *)(a1 + 20);
    ++*(_DWORD *)a1;
    if ( result == *(_DWORD *)(a1 + 8) )
      result = sub_10052430(a1);
    --a2;
  }
  while ( a2 );
  return result;
}

//----- (10052750) --------------------------------------------------------
unsigned int __cdecl sub_10052750(int a1, int a2)
{
  int v2; // esi@1
  int v3; // ecx@3
  int v4; // ebx@3
  int v5; // eax@3
  int v6; // edx@3
  int v7; // edi@3
  unsigned int result; // eax@4
  unsigned int v9; // [sp+14h] [bp+4h]@2

  v2 = a1;
  do
  {
    v9 = *(_DWORD *)(v2 + 16);
    if ( v9 >= 4 )
    {
      v3 = *(_DWORD *)(v2 + 4 * **(_BYTE **)v2 + 108) ^ *(_BYTE *)(*(_DWORD *)v2 + 1);
      v4 = *(_DWORD *)(v2 + 32);
      v5 = *(_DWORD *)(v2 + 40) & (v3 ^ 32
                                      * (*(_DWORD *)(v2 + 4 * *(_BYTE *)(*(_DWORD *)v2 + 3) + 108) ^ 8 * *(_BYTE *)(*(_DWORD *)v2 + 2)));
      v6 = *(_DWORD *)(v4 + 4 * v5 + 266240);
      v7 = (unsigned __int16)(v3 ^ (*(_BYTE *)(*(_DWORD *)v2 + 2) << 8));
      *(_DWORD *)(v4 + 4 * v7 + 4096) = *(_DWORD *)(v2 + 4);
      *(_DWORD *)(*(_DWORD *)(v2 + 32) + 4 * (v3 & 0x3FF)) = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 4 * v7 + 4096);
      *(_DWORD *)(*(_DWORD *)(v2 + 32) + 4 * v5 + 266240) = *(_DWORD *)(v2 + 4);
      sub_10051BF0(
        v6,
        v9,
        *(_DWORD *)(v2 + 4),
        *(_DWORD *)v2,
        *(_DWORD *)(v2 + 36),
        *(_DWORD *)(v2 + 20),
        *(_DWORD *)(v2 + 24),
        *(_DWORD *)(v2 + 44));
    }
    result = ++*(_DWORD *)(v2 + 4);
    ++*(_DWORD *)(v2 + 20);
    ++*(_DWORD *)v2;
    if ( result == *(_DWORD *)(v2 + 8) )
      result = sub_10052430(v2);
    --a2;
  }
  while ( a2 );
  return result;
}

//----- (10052830) --------------------------------------------------------
unsigned int __cdecl sub_10052830(int a1, int a2)
{
  unsigned int v2; // ebx@1
  int v3; // eax@2
  int v4; // ecx@2
  int *v5; // edi@2
  int v6; // edx@2
  unsigned int result; // eax@3

  do
  {
    v2 = *(_DWORD *)(a1 + 16);
    if ( v2 >= 3 )
    {
      v3 = *(_DWORD *)(a1 + 4 * **(_BYTE **)a1 + 108) ^ *(_BYTE *)(*(_DWORD *)a1 + 1);
      v4 = *(_DWORD *)(a1 + 40) & (v3 ^ (*(_BYTE *)(*(_DWORD *)a1 + 2) << 8));
      v5 = (int *)(*(_DWORD *)(a1 + 32) + 4 * v4 + 4096);
      v6 = *v5;
      *v5 = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4 * (v3 & 0x3FF)) = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4 * v4 + 4096);
      sub_10051BF0(
        v6,
        v2,
        *(_DWORD *)(a1 + 4),
        *(_DWORD *)a1,
        *(_DWORD *)(a1 + 36),
        *(_DWORD *)(a1 + 20),
        *(_DWORD *)(a1 + 24),
        *(_DWORD *)(a1 + 44));
    }
    result = ++*(_DWORD *)(a1 + 4);
    ++*(_DWORD *)(a1 + 20);
    ++*(_DWORD *)a1;
    if ( result == *(_DWORD *)(a1 + 8) )
      result = sub_10052430(a1);
    --a2;
  }
  while ( a2 );
  return result;
}

//----- (100528D0) --------------------------------------------------------
unsigned int __cdecl sub_100528D0(int a1, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // edi@2
  int *v4; // eax@3
  int v5; // edx@3
  unsigned int result; // eax@4

  v2 = a2;
  do
  {
    v3 = *(_DWORD *)(a1 + 16);
    if ( v3 >= 2 )
    {
      v4 = (int *)(*(_DWORD *)(a1 + 32) + 4 * (**(_BYTE **)a1 | (*(_BYTE *)(*(_DWORD *)a1 + 1) << 8)));
      v5 = *v4;
      *v4 = *(_DWORD *)(a1 + 4);
      sub_10051BF0(
        v5,
        v3,
        *(_DWORD *)(a1 + 4),
        *(_DWORD *)a1,
        *(_DWORD *)(a1 + 36),
        *(_DWORD *)(a1 + 20),
        *(_DWORD *)(a1 + 24),
        *(_DWORD *)(a1 + 44));
    }
    result = ++*(_DWORD *)(a1 + 4);
    ++*(_DWORD *)(a1 + 20);
    ++*(_DWORD *)a1;
    if ( result == *(_DWORD *)(a1 + 8) )
      result = sub_10052430(a1);
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (10052950) --------------------------------------------------------
signed int __cdecl sub_10052950(int a1, int a2)
{
  _BYTE **v2; // esi@1
  signed int result; // eax@4
  _BYTE *v4; // edi@5
  int v5; // edx@5
  int v6; // eax@5
  int v7; // ecx@5
  _BYTE *v8; // edx@5
  int v9; // ebx@5
  unsigned int v10; // ecx@5
  signed int v11; // ebp@5
  unsigned int v12; // eax@5
  _BYTE *v13; // edx@14
  int v14; // eax@23
  int v15; // edi@23
  unsigned int v16; // [sp+4h] [bp-10h]@5
  int v17; // [sp+Ch] [bp-8h]@5
  unsigned int v18; // [sp+10h] [bp-4h]@5
  unsigned int v19; // [sp+18h] [bp+4h]@1

  v2 = (_BYTE **)a1;
  v19 = *(_DWORD *)(a1 + 16);
  if ( v19 >= 4 )
  {
    v4 = *v2;
    v5 = (unsigned int)v2[**v2 + 27] ^ (*v2)[1];
    v6 = (unsigned int)v2[10] & (v5 ^ 32 * ((unsigned int)v2[(*v2)[3] + 27] ^ 8 * (*v2)[2]));
    LOWORD(v7) = v5 ^ ((*v2)[2] << 8);
    v8 = v2[8];
    v9 = (LOWORD(v2[**v2 + 27]) ^ (*v2)[1]) & 0x3FF;
    v7 = (unsigned __int16)v7;
    v18 = (unsigned int)&v2[1][-*(_DWORD *)&v8[4 * v9]];
    v16 = (unsigned int)&v2[1][-*(_DWORD *)&v8[4 * (unsigned __int16)v7 + 4096]];
    v17 = *(_DWORD *)&v8[4 * v6 + 266240];
    *(_DWORD *)&v8[4 * v6 + 266240] = v2[1];
    *(_DWORD *)&v2[8][4 * v7 + 4096] = *(_DWORD *)&v2[8][4 * v6 + 266240];
    *(_DWORD *)&v2[8][4 * v9] = *(_DWORD *)&v2[8][4 * (unsigned __int16)v7 + 4096];
    v10 = v18;
    v11 = 0;
    v12 = 1;
    if ( v18 < (unsigned int)v2[6] && v4[-v18] == *v4 )
    {
      v12 = 2;
      *(_DWORD *)a2 = 2;
      *(_DWORD *)(a2 + 4) = v18 - 1;
      v11 = 2;
    }
    if ( v18 != v16 && v16 < (unsigned int)v2[6] && v4[-v16] == *v4 )
    {
      v10 = v16;
      *(_DWORD *)(a2 + 4 * v11 + 4) = v16 - 1;
      v12 = 3;
      v11 += 2;
    }
    if ( !v11 )
      goto LABEL_28;
    if ( v12 != v19 )
    {
      v13 = &v4[v12 - v10];
      do
      {
        if ( *v13 != v4[v12] )
          break;
        ++v12;
        ++v13;
      }
      while ( v12 != v19 );
    }
    *(_DWORD *)(a2 + 4 * v11 - 8) = v12;
    if ( v12 == v19 )
    {
      *(_DWORD *)&v2[9][4 * (_DWORD)v2[5]++] = v17;
      ++*v2;
      if ( ++v2[1] == v2[2] )
        sub_10052430((int)v2);
      result = v11;
    }
    else
    {
LABEL_28:
      if ( v12 < 3 )
        v12 = 3;
      v14 = sub_10051E80(
              v12,
              v19,
              v17,
              (int)v2[1],
              *v2,
              (int)v2[9],
              (unsigned int)v2[5],
              (unsigned int)v2[6],
              (int)v2[11],
              a2 + 4 * v11);
      ++v2[5];
      ++*v2;
      ++v2[1];
      v15 = (v14 - a2) >> 2;
      if ( v2[1] == v2[2] )
        sub_10052430((int)v2);
      result = v15;
    }
  }
  else
  {
    ++v2[5];
    ++*v2;
    if ( ++v2[1] == v2[2] )
      sub_10052430((int)v2);
    result = 0;
  }
  return result;
}

//----- (10052B30) --------------------------------------------------------
signed int __cdecl sub_10052B30(int a1, int a2)
{
  int v2; // esi@1
  signed int result; // eax@4
  _BYTE *v4; // edi@5
  int v5; // edx@5
  int v6; // eax@5
  int v7; // ecx@5
  int v8; // edx@5
  int v9; // ebx@5
  unsigned int v10; // ecx@5
  signed int v11; // ebp@5
  unsigned int v12; // eax@5
  int v13; // edx@12
  _BYTE *v14; // edx@14
  int v15; // eax@24
  int v16; // edi@24
  unsigned int v17; // [sp+4h] [bp-10h]@5
  int v18; // [sp+Ch] [bp-8h]@5
  unsigned int v19; // [sp+10h] [bp-4h]@5
  unsigned int v20; // [sp+18h] [bp+4h]@1

  v2 = a1;
  v20 = *(_DWORD *)(a1 + 16);
  if ( v20 >= 4 )
  {
    v4 = *(_BYTE **)v2;
    v5 = *(_DWORD *)(v2 + 4 * **(_BYTE **)v2 + 108) ^ *(_BYTE *)(*(_DWORD *)v2 + 1);
    v6 = *(_DWORD *)(v2 + 40) & (v5 ^ 32
                                    * (*(_DWORD *)(v2 + 4 * *(_BYTE *)(*(_DWORD *)v2 + 3) + 108) ^ 8
                                                                                                 * *(_BYTE *)(*(_DWORD *)v2 + 2)));
    LOWORD(v7) = v5 ^ (*(_BYTE *)(*(_DWORD *)v2 + 2) << 8);
    v8 = *(_DWORD *)(v2 + 32);
    v9 = (*(_WORD *)(v2 + 4 * **(_BYTE **)v2 + 108) ^ *(_BYTE *)(*(_DWORD *)v2 + 1)) & 0x3FF;
    v7 = (unsigned __int16)v7;
    v19 = *(_DWORD *)(v2 + 4) - *(_DWORD *)(v8 + 4 * v9);
    v17 = *(_DWORD *)(v2 + 4) - *(_DWORD *)(v8 + 4 * (unsigned __int16)v7 + 4096);
    v18 = *(_DWORD *)(v8 + 4 * v6 + 266240);
    *(_DWORD *)(v8 + 4 * v6 + 266240) = *(_DWORD *)(v2 + 4);
    *(_DWORD *)(*(_DWORD *)(v2 + 32) + 4 * v7 + 4096) = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 4 * v6 + 266240);
    *(_DWORD *)(*(_DWORD *)(v2 + 32) + 4 * v9) = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 4 * (unsigned __int16)v7 + 4096);
    v10 = v19;
    v11 = 0;
    v12 = 1;
    if ( v19 < *(_DWORD *)(v2 + 24) && v4[-v19] == *v4 )
    {
      v12 = 2;
      *(_DWORD *)a2 = 2;
      *(_DWORD *)(a2 + 4) = v19 - 1;
      v11 = 2;
    }
    if ( v19 != v17 && v17 < *(_DWORD *)(v2 + 24) && v4[-v17] == *v4 )
    {
      v10 = v17;
      *(_DWORD *)(a2 + 4 * v11 + 4) = v17 - 1;
      v12 = 3;
      v11 += 2;
    }
    v13 = v20;
    if ( !v11 )
      goto LABEL_29;
    if ( v12 != v20 )
    {
      v14 = &v4[v12 - v10];
      do
      {
        if ( *v14 != v4[v12] )
          break;
        ++v12;
        ++v14;
      }
      while ( v12 != v20 );
      v13 = v20;
    }
    *(_DWORD *)(a2 + 4 * v11 - 8) = v12;
    if ( v12 == v13 )
    {
      sub_10051BF0(
        v18,
        v13,
        *(_DWORD *)(v2 + 4),
        *(_DWORD *)v2,
        *(_DWORD *)(v2 + 36),
        *(_DWORD *)(v2 + 20),
        *(_DWORD *)(v2 + 24),
        *(_DWORD *)(v2 + 44));
      ++*(_DWORD *)(v2 + 20);
      ++*(_DWORD *)v2;
      if ( ++*(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
        sub_10052430(v2);
      result = v11;
    }
    else
    {
LABEL_29:
      if ( v12 < 3 )
        v12 = 3;
      v15 = sub_10051D20(
              v13,
              v18,
              *(_DWORD *)(v2 + 4),
              *(_DWORD *)v2,
              *(_DWORD *)(v2 + 36),
              *(_DWORD *)(v2 + 20),
              *(_DWORD *)(v2 + 24),
              *(_DWORD *)(v2 + 44),
              a2 + 4 * v11,
              v12);
      ++*(_DWORD *)(v2 + 20);
      ++*(_DWORD *)v2;
      ++*(_DWORD *)(v2 + 4);
      v16 = (v15 - a2) >> 2;
      if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
        sub_10052430(v2);
      result = v16;
    }
  }
  else
  {
    ++*(_DWORD *)(v2 + 20);
    ++*(_DWORD *)v2;
    if ( ++*(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
      sub_10052430(v2);
    result = 0;
  }
  return result;
}

//----- (10052D30) --------------------------------------------------------
signed int __cdecl sub_10052D30(int a1, int a2)
{
  int v2; // esi@1
  int v4; // edx@5
  _BYTE *v5; // ebx@5
  int v6; // ecx@5
  int v7; // eax@5
  int v8; // edi@5
  unsigned int v9; // ecx@5
  signed int v10; // ebp@5
  unsigned int v11; // edi@5
  int v12; // edx@6
  int v13; // eax@7
  int v14; // ebx@12
  int v15; // eax@17
  int v16; // edi@17
  int v17; // [sp+4h] [bp-8h]@5
  unsigned int v18; // [sp+10h] [bp+4h]@1

  v2 = a1;
  v18 = *(_DWORD *)(a1 + 16);
  if ( v18 < 3 )
  {
    ++*(_DWORD *)(v2 + 20);
    ++*(_DWORD *)v2;
    if ( ++*(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
      sub_10052430(v2);
    return 0;
  }
  v4 = *(_DWORD *)(v2 + 32);
  v5 = *(_BYTE **)v2;
  v6 = *(_DWORD *)(v2 + 4 * **(_BYTE **)v2 + 108) ^ *(_BYTE *)(*(_DWORD *)v2 + 1);
  v7 = *(_DWORD *)(v2 + 40) & (v6 ^ (*(_BYTE *)(*(_DWORD *)v2 + 2) << 8));
  v8 = v6 & 0x3FF;
  v9 = *(_DWORD *)(v2 + 4) - *(_DWORD *)(v4 + 4 * v8);
  v17 = *(_DWORD *)(v4 + 4 * v7 + 4096);
  *(_DWORD *)(v4 + 4 * v7 + 4096) = *(_DWORD *)(v2 + 4);
  *(_DWORD *)(*(_DWORD *)(v2 + 32) + 4 * v8) = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 4 * v7 + 4096);
  v10 = 0;
  v11 = 2;
  if ( v9 >= *(_DWORD *)(v2 + 24) || (v12 = (int)&v5[-v9], v5[-v9] != *v5) )
  {
    v13 = v18;
    v14 = a2;
  }
  else
  {
    v13 = v18;
    if ( v18 != 2 )
    {
      while ( *(_BYTE *)(v12 + v11) == v5[v11] )
      {
        if ( ++v11 == v18 )
          break;
        v12 = (int)&v5[-v9];
      }
    }
    v14 = a2;
    *(_DWORD *)a2 = v11;
    *(_DWORD *)(a2 + 4) = v9 - 1;
    v10 = 2;
    if ( v11 == v18 )
    {
      sub_10051BF0(
        v17,
        v18,
        *(_DWORD *)(v2 + 4),
        *(_DWORD *)v2,
        *(_DWORD *)(v2 + 36),
        *(_DWORD *)(v2 + 20),
        *(_DWORD *)(v2 + 24),
        *(_DWORD *)(v2 + 44));
      ++*(_DWORD *)(v2 + 20);
      ++*(_DWORD *)v2;
      if ( ++*(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
        sub_10052430(v2);
      return 2;
    }
  }
  v15 = sub_10051D20(
          v13,
          v17,
          *(_DWORD *)(v2 + 4),
          *(_DWORD *)v2,
          *(_DWORD *)(v2 + 36),
          *(_DWORD *)(v2 + 20),
          *(_DWORD *)(v2 + 24),
          *(_DWORD *)(v2 + 44),
          v14 + 4 * v10,
          v11);
  ++*(_DWORD *)(v2 + 20);
  ++*(_DWORD *)v2;
  ++*(_DWORD *)(v2 + 4);
  v16 = (v15 - v14) >> 2;
  if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
    sub_10052430(v2);
  return v16;
}

//----- (10052F50) --------------------------------------------------------
int __usercall sub_10052F50@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // ecx@3

  *(_DWORD *)result = sub_100521C0;
  *(_DWORD *)(result + 4) = sub_10052130;
  *(_DWORD *)(result + 8) = sub_10052120;
  *(_DWORD *)(result + 12) = sub_10052140;
  if ( *(_DWORD *)(a2 + 80) )
  {
    v2 = *(_DWORD *)(a2 + 72);
    if ( v2 == 2 )
    {
      *(_DWORD *)(result + 16) = sub_10052EB0;
      *(_DWORD *)(result + 20) = sub_100528D0;
    }
    else if ( v2 == 3 )
    {
      *(_DWORD *)(result + 16) = sub_10052D30;
      *(_DWORD *)(result + 20) = sub_10052830;
    }
    else
    {
      *(_DWORD *)(result + 16) = sub_10052B30;
      *(_DWORD *)(result + 20) = sub_10052750;
    }
  }
  else
  {
    *(_DWORD *)(result + 16) = sub_10052950;
    *(_DWORD *)(result + 20) = sub_10052690;
  }
  return result;
}
// 10052120: using guessed type int sub_10052120();
// 10052130: using guessed type int sub_10052130();
// 10052140: using guessed type int sub_10052140();
// 10052EB0: using guessed type int sub_10052EB0();

//----- (10052FC0) --------------------------------------------------------
signed int __fastcall sub_10052FC0(int a1, int a2)
{
  unsigned int v2; // eax@1
  unsigned __int8 v3; // dl@3
  signed int result; // eax@4
  signed __int64 v5; // rax@5
  signed __int64 v6; // rax@5

  v2 = *(_BYTE *)(a2 + 1) | ((*(_BYTE *)(a2 + 2) | ((*(_BYTE *)(a2 + 3) | (*(_BYTE *)(a2 + 4) << 8)) << 8)) << 8);
  if ( v2 < 0x1000 )
    v2 = 4096;
  v3 = *(_BYTE *)a2;
  *(_DWORD *)(a1 + 12) = v2;
  if ( v3 < 0xE1u )
  {
    v5 = v3;
    *(_DWORD *)a1 = v5 % 9;
    v6 = (unsigned __int8)(v5 / 9);
    *(_DWORD *)(a1 + 8) = v6 / 5;
    *(_DWORD *)(a1 + 4) = v6 % 5;
    result = 0;
  }
  else
  {
    result = 4;
  }
  return result;
}

//----- (100530F0) --------------------------------------------------------
signed int __usercall sub_100530F0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3)
{
  int v3; // edi@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edx@1
  unsigned int v6; // esi@1
  int v7; // ebx@1
  unsigned int v9; // eax@5
  unsigned int v10; // edx@6
  int v11; // ecx@8
  unsigned int v12; // ecx@12
  int v13; // edi@13
  unsigned int v14; // eax@16
  _BYTE *v15; // ebp@21
  unsigned int v16; // ecx@25
  unsigned int v17; // ebx@25
  int v18; // eax@26
  int v19; // ecx@28
  signed int v20; // ebx@28
  unsigned int v21; // edi@28
  int v22; // ecx@29
  int v23; // eax@29
  unsigned int v24; // ecx@32
  _BYTE *v25; // ecx@37
  unsigned int v26; // edx@37
  unsigned int v27; // esi@37
  unsigned int v28; // eax@40
  unsigned int v29; // edx@41
  int v30; // edi@41
  unsigned int v31; // edx@42
  unsigned int v32; // ecx@45
  unsigned int v33; // eax@46
  unsigned int v34; // edx@46
  unsigned int v35; // ecx@49
  _BYTE *v36; // edi@53
  unsigned int v37; // edx@53
  unsigned int v38; // ecx@56
  int v39; // eax@58
  unsigned int v40; // ecx@68
  _BYTE *v41; // eax@68
  int v42; // ebx@69
  signed int v43; // ebp@69
  unsigned int v44; // edx@70
  unsigned int v45; // ecx@73
  unsigned int v46; // edi@76
  int v47; // eax@80
  unsigned int v48; // ecx@80
  unsigned int v49; // edi@85
  int v50; // ebx@88
  unsigned int v51; // edi@88
  int v52; // eax@92
  unsigned int v53; // ecx@92
  unsigned int v54; // edi@96
  int v55; // ecx@97
  int v56; // ecx@99
  int v57; // ebx@105
  int v58; // eax@109
  unsigned int v59; // edi@109
  unsigned int v60; // [sp+10h] [bp-14h]@1
  int v61; // [sp+14h] [bp-10h]@1
  int v62; // [sp+14h] [bp-10h]@6
  int v63; // [sp+14h] [bp-10h]@98
  int v64; // [sp+18h] [bp-Ch]@1
  int v65; // [sp+18h] [bp-Ch]@29
  int v66; // [sp+18h] [bp-Ch]@37
  int v67; // [sp+18h] [bp-Ch]@53
  unsigned int v68; // [sp+18h] [bp-Ch]@69
  signed int v69; // [sp+1Ch] [bp-8h]@20
  int v70; // [sp+20h] [bp-4h]@29
  unsigned int v71; // [sp+20h] [bp-4h]@41

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 52);
  v5 = *(_DWORD *)(a2 + 28);
  v6 = *(_DWORD *)(a2 + 32);
  v60 = (unsigned int)&a3[a1];
  v61 = *(_DWORD *)(a2 + 16);
  v7 = *(_DWORD *)(v3 + 44) & ((1 << *(_DWORD *)(v3 + 8)) - 1);
  v64 = *(_WORD *)(v61 + 2 * (v7 + 16 * v4));
  if ( v5 < 0x1000000 )
  {
    if ( (unsigned int)a3 >= v60 )
      return 0;
    v5 <<= 8;
    v6 = *a3++ | (v6 << 8);
  }
  v9 = v64 * (v5 >> 11);
  if ( v6 < v9 )
  {
    v10 = v64 * (v5 >> 11);
    v62 = v61 + 3692;
    if ( *(_DWORD *)(a2 + 48) || *(_DWORD *)(a2 + 44) )
    {
      v11 = *(_DWORD *)(a2 + 36);
      if ( !v11 )
        v11 = *(_DWORD *)(v3 + 40);
      v62 += 1536
           * (((*(_DWORD *)(v3 + 44) & ((1 << *(_DWORD *)(v3 + 4)) - 1)) << *(_DWORD *)v3)
            + ((unsigned int)*(_BYTE *)(*(_DWORD *)(v3 + 20) + v11 - 1) >> (8 - *(_DWORD *)v3)));
    }
    if ( v4 >= 7 )
    {
      v16 = *(_DWORD *)(v3 + 36);
      v17 = *(_DWORD *)(v3 + 56);
      if ( v16 >= v17 )
        v18 = 0;
      else
        v18 = *(_DWORD *)(v3 + 40);
      v19 = *(_BYTE *)(v16 + *(_DWORD *)(v3 + 20) - v17 + v18);
      v20 = 256;
      v21 = 1;
      while ( 1 )
      {
        v22 = 2 * v19;
        v23 = v22 & v20;
        v70 = v22;
        v65 = *(_WORD *)(v62 + 2 * (v20 + (v22 & v20) + v21));
        if ( v10 < 0x1000000 )
        {
          if ( (unsigned int)a3 >= v60 )
            return 0;
          v10 <<= 8;
          v6 = *a3++ | (v6 << 8);
        }
        v24 = v65 * (v10 >> 11);
        if ( v6 >= v24 )
        {
          v10 -= v24;
          v6 -= v24;
          v21 = 2 * v21 + 1;
        }
        else
        {
          v10 = v65 * (v10 >> 11);
          v21 *= 2;
          v23 = ~v23;
        }
        v20 &= v23;
        if ( v21 >= 0x100 )
          break;
        v19 = v70;
      }
    }
    else
    {
      v12 = 1;
      do
      {
        v13 = *(_WORD *)(v62 + 2 * v12);
        if ( v10 < 0x1000000 )
        {
          if ( (unsigned int)a3 >= v60 )
            return 0;
          v10 <<= 8;
          v6 = *a3++ | (v6 << 8);
        }
        v14 = v13 * (v10 >> 11);
        if ( v6 >= v14 )
        {
          v10 -= v14;
          v6 -= v14;
          v12 = 2 * v12 + 1;
        }
        else
        {
          v10 = v13 * (v10 >> 11);
          v12 *= 2;
        }
      }
      while ( v12 < 0x100 );
    }
    v69 = 1;
    goto LABEL_21;
  }
  v25 = a3;
  v26 = v5 - v9;
  v27 = v6 - v9;
  v66 = *(_WORD *)(v61 + 2 * v4 + 384);
  if ( v26 < 0x1000000 )
  {
    if ( (unsigned int)a3 >= v60 )
      return 0;
    v26 <<= 8;
    v27 = *a3 | (v27 << 8);
    v25 = a3++ + 1;
  }
  v28 = v66 * (v26 >> 11);
  if ( v27 < v28 )
  {
    v29 = v66 * (v26 >> 11);
    v71 = 0;
    v30 = v61 + 1636;
    v69 = 2;
    goto LABEL_65;
  }
  v31 = v26 - v28;
  v27 -= v28;
  v69 = 3;
  if ( v31 < 0x1000000 )
  {
    if ( (unsigned int)v25 >= v60 )
      return 0;
    v31 <<= 8;
    v27 = *v25 | (v27 << 8);
    a3 = v25 + 1;
  }
  v32 = *(_WORD *)(v61 + 2 * v4 + 408) * (v31 >> 11);
  if ( v27 < v32 )
  {
    v33 = (unsigned int)a3;
    v34 = *(_WORD *)(v61 + 2 * v4 + 408) * (v31 >> 11);
    if ( v32 < 0x1000000 )
    {
      if ( (unsigned int)a3 >= v60 )
        return 0;
      v34 = v32 << 8;
      v27 = *a3 | (v27 << 8);
      v33 = (unsigned int)(a3++ + 1);
    }
    v35 = *(_WORD *)(v61 + 2 * (v7 + 16 * (v4 + 15))) * (v34 >> 11);
    if ( v27 < v35 )
    {
      if ( v35 < 0x1000000 && v33 >= v60 )
        return 0;
      return 3;
    }
    goto LABEL_63;
  }
  v36 = a3;
  v37 = v31 - v32;
  v27 -= v32;
  v67 = *(_WORD *)(v61 + 2 * v4 + 432);
  if ( v37 < 0x1000000 )
  {
    if ( (unsigned int)a3 >= v60 )
      return 0;
    v37 <<= 8;
    v27 = *a3 | (v27 << 8);
    v36 = a3++ + 1;
  }
  v38 = v67 * (v37 >> 11);
  if ( v27 >= v38 )
  {
    v39 = *(_WORD *)(v61 + 2 * v4 + 456);
    v34 = v37 - v38;
    v27 -= v38;
    if ( v34 < 0x1000000 )
    {
      if ( (unsigned int)v36 >= v60 )
        return 0;
      v34 <<= 8;
      v27 = *v36 | (v27 << 8);
      a3 = v36 + 1;
    }
    v35 = v39 * (v34 >> 11);
    if ( v27 >= v35 )
    {
LABEL_63:
      v29 = v34 - v35;
      v27 -= v35;
      goto LABEL_64;
    }
    v29 = v39 * (v34 >> 11);
  }
  else
  {
    v29 = v67 * (v37 >> 11);
  }
LABEL_64:
  v25 = a3;
  v71 = 12;
  v30 = v61 + 2664;
LABEL_65:
  if ( v29 < 0x1000000 )
  {
    if ( (unsigned int)v25 >= v60 )
      return 0;
    v29 <<= 8;
    v27 = *v25 | (v27 << 8);
    a3 = v25 + 1;
  }
  v40 = *(_WORD *)v30 * (v29 >> 11);
  v41 = a3;
  if ( v27 >= v40 )
  {
    v44 = v29 - v40;
    v27 -= v40;
    if ( v44 < 0x1000000 )
    {
      if ( (unsigned int)a3 >= v60 )
        return 0;
      v44 <<= 8;
      v27 = *a3 | (v27 << 8);
      v41 = a3++ + 1;
    }
    v45 = *(_WORD *)(v30 + 2) * (v44 >> 11);
    if ( v27 >= v45 )
    {
      v10 = v44 - v45;
      v27 -= v45;
      v42 = v30 + 516;
      v43 = 16;
      v68 = 256;
    }
    else
    {
      v43 = 8;
      v10 = *(_WORD *)(v30 + 2) * (v44 >> 11);
      v42 = v30 + 16 * v7 + 260;
      v68 = 8;
    }
  }
  else
  {
    v10 = *(_WORD *)v30 * (v29 >> 11);
    v42 = v30 + 16 * v7 + 4;
    v43 = 0;
    v68 = 8;
  }
  v46 = 1;
  while ( 1 )
  {
    if ( v10 < 0x1000000 )
    {
      if ( (unsigned int)v41 >= v60 )
        return 0;
      v10 <<= 8;
      v27 = *v41 | (v27 << 8);
      a3 = v41 + 1;
    }
    v47 = *(_WORD *)(v42 + 2 * v46);
    v48 = v47 * (v10 >> 11);
    if ( v27 >= v48 )
    {
      v10 -= v48;
      v27 -= v48;
      v46 = 2 * v46 + 1;
    }
    else
    {
      v10 = v47 * (v10 >> 11);
      v46 *= 2;
    }
    if ( v46 >= v68 )
      break;
    v41 = a3;
  }
  v49 = v43 - v68 + v46;
  if ( v71 < 4 )
  {
    if ( v49 >= 4 )
      v49 = 3;
    v15 = a3;
    v50 = (v49 << 7) + v61 + 864;
    v51 = 1;
    do
    {
      if ( v10 < 0x1000000 )
      {
        if ( (unsigned int)v15 >= v60 )
          return 0;
        v10 <<= 8;
        v27 = *v15++ | (v27 << 8);
      }
      v52 = *(_WORD *)(v50 + 2 * v51);
      v53 = v52 * (v10 >> 11);
      if ( v27 >= v53 )
      {
        v10 -= v53;
        v27 -= v53;
        v51 = 2 * v51 + 1;
      }
      else
      {
        v10 = v52 * (v10 >> 11);
        v51 *= 2;
      }
    }
    while ( v51 < 0x40 );
    v54 = v51 - 64;
    if ( v54 >= 4 )
    {
      v55 = (v54 >> 1) - 1;
      if ( v54 >= 0xE )
      {
        v56 = (v54 >> 1) - 5;
        do
        {
          if ( v10 < 0x1000000 )
          {
            if ( (unsigned int)v15 >= v60 )
              return 0;
            v10 <<= 8;
            v27 = *v15++ | (v27 << 8);
          }
          v10 >>= 1;
          v27 -= v10 & (((v27 - v10) >> 31) - 1);
          --v56;
        }
        while ( v56 );
        v63 = v61 + 1604;
        v55 = 4;
      }
      else
      {
        v63 = v61 + 2 * (((v54 & 1 | 2) << v55) - v54) + 1374;
      }
      v57 = 1;
      do
      {
        if ( v10 < 0x1000000 )
        {
          if ( (unsigned int)v15 >= v60 )
            return 0;
          v10 <<= 8;
          v27 = *v15++ | (v27 << 8);
        }
        v58 = *(_WORD *)(v63 + 2 * v57);
        v59 = v58 * (v10 >> 11);
        if ( v27 >= v59 )
        {
          v10 -= v59;
          v27 -= v59;
          v57 = 2 * v57 + 1;
        }
        else
        {
          v10 = v58 * (v10 >> 11);
          v57 *= 2;
        }
        --v55;
      }
      while ( v55 );
    }
    goto LABEL_22;
  }
LABEL_21:
  v15 = a3;
LABEL_22:
  if ( v10 < 0x1000000 && (unsigned int)v15 >= v60 )
    return 0;
  return v69;
}

//----- (100536F0) --------------------------------------------------------
void __usercall sub_100536F0(int a1@<edx>, int a2@<esi>)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@3
  unsigned int v4; // ebp@3
  unsigned int v5; // ecx@3
  unsigned int v6; // edx@3
  int v7; // edi@3
  int v8; // [sp+4h] [bp-4h]@3

  v2 = *(_DWORD *)(a2 + 72);
  if ( v2 && v2 < 0x112 )
  {
    v3 = *(_DWORD *)(a2 + 36);
    v4 = *(_DWORD *)(a2 + 56);
    v8 = *(_DWORD *)(a2 + 40);
    v5 = *(_DWORD *)(a2 + 72);
    v6 = a1 - v3;
    v7 = *(_DWORD *)(a2 + 20);
    if ( v6 < v2 )
      v5 = v6;
    if ( !*(_DWORD *)(a2 + 48) && *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44) <= v5 )
      *(_DWORD *)(a2 + 48) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 44) += v5;
    for ( *(_DWORD *)(a2 + 72) = v2 - v5; v5; --v5 )
    {
      *(_BYTE *)(v3 + v7) = *(_BYTE *)(v3 + (v3 < v4 ? v8 : 0) - v4 + v7);
      ++v3;
    }
    *(_DWORD *)(a2 + 36) = v3;
  }
}

//----- (10053760) --------------------------------------------------------
signed int __stdcall sub_10053760(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // ebx@1
  int v4; // ebp@1
  unsigned int v5; // esi@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@1
  int v8; // ecx@2
  unsigned __int16 *v9; // ebx@2
  int v10; // ecx@2
  unsigned int v11; // edx@4
  int v12; // ebp@5
  unsigned int v13; // ecx@7
  _BYTE *v14; // ebx@10
  unsigned int v15; // ecx@11
  int v16; // edx@12
  unsigned int v17; // edi@14
  signed int v18; // ebx@19
  int v19; // edi@19
  int v20; // edi@21
  int v21; // edx@21
  int v22; // edi@21
  unsigned int v23; // ebp@23
  unsigned int v24; // eax@28
  int v25; // ecx@28
  _BYTE *v26; // ebx@28
  unsigned int v27; // edx@30
  unsigned int v28; // eax@31
  int v29; // ecx@31
  unsigned int v30; // eax@32
  int v31; // edx@34
  unsigned int v32; // ecx@36
  unsigned __int16 *v33; // ebx@37
  int v34; // edx@37
  unsigned int v35; // eax@37
  unsigned int v36; // ecx@39
  unsigned int v37; // eax@42
  int v38; // ecx@42
  unsigned int v39; // edx@44
  __int16 v40; // dx@45
  unsigned int v41; // ecx@45
  unsigned int v42; // eax@46
  int v43; // ecx@46
  unsigned int v44; // edx@48
  __int16 v45; // dx@49
  int v46; // edx@54
  unsigned int v47; // edi@56
  int v48; // ebx@57
  signed int v49; // ebp@57
  unsigned int v50; // eax@58
  int v51; // edx@58
  unsigned int v52; // edi@60
  unsigned int v53; // edi@63
  int v54; // ecx@64
  unsigned int v55; // edx@66
  unsigned int v56; // edi@70
  signed int v57; // ecx@71
  _BYTE *v58; // ebp@73
  int v59; // ecx@73
  int v60; // edx@73
  unsigned int v61; // edi@75
  unsigned int v62; // eax@76
  signed int v63; // edx@76
  int v64; // ebx@78
  unsigned int v65; // edx@78
  unsigned int v66; // edi@80
  unsigned int v67; // eax@81
  int v68; // ebx@83
  int v69; // edx@83
  unsigned int v70; // edi@85
  unsigned int v71; // eax@86
  int v72; // ebx@88
  int v73; // edx@88
  unsigned int v74; // edi@90
  unsigned int v75; // eax@91
  int v76; // ebx@93
  int v77; // edx@93
  unsigned int v78; // edi@95
  unsigned int v79; // eax@96
  int v80; // ebx@98
  int v81; // edx@98
  unsigned int v82; // edi@100
  int v83; // ebp@101
  unsigned int v84; // ebp@103
  unsigned int v85; // edx@104
  int v86; // edi@104
  int v87; // ecx@104
  int v88; // ebp@104
  int v89; // ebx@105
  int v90; // edx@106
  unsigned int v91; // ecx@108
  _BYTE *v92; // edi@113
  unsigned int v93; // esi@116
  int v94; // edx@117
  unsigned int v95; // edi@119
  unsigned int v96; // eax@120
  signed int v97; // edx@120
  int v98; // ebx@122
  unsigned int v99; // edx@122
  unsigned int v100; // edi@124
  unsigned int v101; // eax@125
  int v102; // ebx@127
  int v103; // edx@127
  unsigned int v104; // edi@129
  unsigned int v105; // eax@130
  int v106; // edx@132
  unsigned int v107; // edi@134
  unsigned int v108; // edx@138
  bool v109; // cf@139
  unsigned int v110; // ebp@143
  unsigned int v111; // edi@143
  int v112; // ebx@146
  int v113; // ecx@146
  _BYTE *v114; // edx@147
  int v115; // edi@147
  int v116; // ecx@147
  int v118; // edx@159
  _BYTE *v119; // [sp+10h] [bp-4Ch]@1
  unsigned int v120; // [sp+14h] [bp-48h]@1
  unsigned int v121; // [sp+18h] [bp-44h]@1
  unsigned int v122; // [sp+1Ch] [bp-40h]@1
  unsigned int v123; // [sp+20h] [bp-3Ch]@1
  int v124; // [sp+24h] [bp-38h]@1
  unsigned int v125; // [sp+24h] [bp-38h]@70
  unsigned int v126; // [sp+28h] [bp-34h]@1
  unsigned int v127; // [sp+2Ch] [bp-30h]@1
  int v128; // [sp+30h] [bp-2Ch]@2
  int v129; // [sp+30h] [bp-2Ch]@5
  unsigned int v130; // [sp+30h] [bp-2Ch]@57
  int v131; // [sp+30h] [bp-2Ch]@104
  int v132; // [sp+30h] [bp-2Ch]@113
  int v133; // [sp+30h] [bp-2Ch]@144
  int v134; // [sp+34h] [bp-28h]@1
  unsigned int v135; // [sp+38h] [bp-24h]@1
  int v136; // [sp+3Ch] [bp-20h]@1
  unsigned int v137; // [sp+40h] [bp-1Ch]@1
  signed int v138; // [sp+40h] [bp-1Ch]@105
  unsigned int v139; // [sp+44h] [bp-18h]@1
  int v140; // [sp+48h] [bp-14h]@1
  unsigned __int16 *v141; // [sp+4Ch] [bp-10h]@21
  int v142; // [sp+50h] [bp-Ch]@1
  int v143; // [sp+54h] [bp-8h]@21
  int v144; // [sp+58h] [bp-4h]@1

  v123 = *(_DWORD *)(a1 + 56);
  v126 = *(_DWORD *)(a1 + 60);
  v127 = *(_DWORD *)(a1 + 64);
  v137 = *(_DWORD *)(a1 + 68);
  v3 = (1 << *(_DWORD *)(a1 + 8)) - 1;
  v4 = *(_DWORD *)(a1 + 16);
  v142 = (1 << *(_DWORD *)(a1 + 4)) - 1;
  v140 = *(_DWORD *)a1;
  v135 = *(_DWORD *)(a1 + 40);
  v134 = *(_DWORD *)(a1 + 20);
  v5 = *(_DWORD *)(a1 + 32);
  v120 = *(_DWORD *)(a1 + 44);
  v6 = *(_DWORD *)(a1 + 52);
  v122 = *(_DWORD *)(a1 + 36);
  v119 = *(_BYTE **)(a1 + 24);
  v7 = *(_DWORD *)(a1 + 28);
  v136 = *(_DWORD *)(a1 + 16);
  v121 = *(_DWORD *)(a1 + 52);
  v144 = (1 << *(_DWORD *)(a1 + 8)) - 1;
  v139 = *(_DWORD *)(a1 + 48);
  v124 = 0;
  while ( 1 )
  {
    v8 = v3 & v120;
    v9 = (unsigned __int16 *)(v4 + 2 * ((v3 & v120) + 16 * v6));
    v128 = v8;
    v10 = *v9;
    if ( v7 < 0x1000000 )
    {
      v7 <<= 8;
      v5 = *v119++ | (v5 << 8);
    }
    v11 = v10 * (v7 >> 11);
    if ( v5 < v11 )
    {
      v7 = v10 * (v7 >> 11);
      v12 = v4 + 3692;
      *v9 = v10 + ((unsigned int)(2048 - v10) >> 5);
      v129 = v12;
      if ( v139 || v120 )
      {
        v13 = v122;
        if ( !v122 )
          v13 = v135;
        v12 += 1536 * (((v142 & v120) << v140) + ((unsigned int)*(_BYTE *)(v13 + v134 - 1) >> (8 - v140)));
        v129 = v12;
      }
      v14 = v119;
      if ( v6 >= 7 )
      {
        v18 = 256;
        v19 = *(_BYTE *)(*(_DWORD *)(a1 + 20) + (v122 < v123 ? v135 : 0) - v123 + v122);
        v15 = 1;
        while ( 1 )
        {
          v20 = 2 * v19;
          v143 = v20;
          v21 = v20 & v18;
          v141 = (unsigned __int16 *)(v12 + 2 * (v15 + (v20 & v18) + v18));
          v22 = *v141;
          if ( v7 < 0x1000000 )
          {
            v7 <<= 8;
            v5 = *v119++ | (v5 << 8);
          }
          v23 = v22 * (v7 >> 11);
          if ( v5 >= v23 )
          {
            v7 -= v23;
            v5 -= v23;
            *v141 -= *v141 >> 5;
            v15 = 2 * v15 + 1;
          }
          else
          {
            v7 = v22 * (v7 >> 11);
            *v141 = v22 + ((unsigned int)(2048 - v22) >> 5);
            v15 *= 2;
            v21 = ~v21;
          }
          v18 &= v21;
          if ( v15 >= 0x100 )
            break;
          v12 = v129;
          v19 = v143;
        }
      }
      else
      {
        v15 = 1;
        do
        {
          v16 = *(_WORD *)(v12 + 2 * v15);
          if ( v7 < 0x1000000 )
          {
            v7 <<= 8;
            v5 = *v14++ | (v5 << 8);
          }
          v17 = v16 * (v7 >> 11);
          if ( v5 >= v17 )
          {
            v7 -= v17;
            v5 -= v17;
            *(_WORD *)(v12 + 2 * v15) -= *(_WORD *)(v12 + 2 * v15) >> 5;
            v15 = 2 * v15 + 1;
          }
          else
          {
            v7 = v16 * (v7 >> 11);
            *(_WORD *)(v12 + 2 * v15) = v16 + ((unsigned int)(2048 - v16) >> 5);
            v15 *= 2;
          }
        }
        while ( v15 < 0x100 );
        v119 = v14;
      }
      *(_BYTE *)(v122 + v134) = v15;
      ++v120;
      ++v122;
      v121 = (unsigned __int8)byte_10099848[v121];
      goto LABEL_154;
    }
    v24 = v7 - v11;
    v5 -= v11;
    *v9 -= *v9 >> 5;
    v25 = *(_WORD *)(v4 + 2 * v6 + 384);
    v26 = v119;
    if ( v24 < 0x1000000 )
    {
      v24 <<= 8;
      v5 = *v119 | (v5 << 8);
      v26 = v119++ + 1;
    }
    v27 = v25 * (v24 >> 11);
    if ( v5 >= v27 )
    {
      v30 = v24 - v27;
      v5 -= v27;
      *(_WORD *)(v4 + 2 * v6 + 384) -= *(_WORD *)(v4 + 2 * v6 + 384) >> 5;
      if ( !v139 && !v120 )
        return 1;
      v31 = *(_WORD *)(v4 + 2 * v6 + 408);
      if ( v30 < 0x1000000 )
      {
        v30 <<= 8;
        v5 = *v26++ | (v5 << 8);
        v119 = v26;
      }
      v32 = v31 * (v30 >> 11);
      if ( v5 >= v32 )
      {
        v37 = v30 - v32;
        v5 -= v32;
        *(_WORD *)(v4 + 2 * v6 + 408) -= *(_WORD *)(v4 + 2 * v6 + 408) >> 5;
        v38 = *(_WORD *)(v4 + 2 * v6 + 432);
        if ( v37 < 0x1000000 )
        {
          v37 <<= 8;
          v5 = *v26++ | (v5 << 8);
          v119 = v26;
        }
        v39 = v38 * (v37 >> 11);
        if ( v5 >= v39 )
        {
          v42 = v37 - v39;
          v5 -= v39;
          *(_WORD *)(v4 + 2 * v6 + 432) -= *(_WORD *)(v4 + 2 * v6 + 432) >> 5;
          v43 = *(_WORD *)(v4 + 2 * v6 + 456);
          if ( v42 < 0x1000000 )
          {
            v42 <<= 8;
            v5 = *v26++ | (v5 << 8);
            v119 = v26;
          }
          v44 = v43 * (v42 >> 11);
          if ( v5 >= v44 )
          {
            v28 = v42 - v44;
            v5 -= v44;
            *(_WORD *)(v4 + 2 * v6 + 456) -= *(_WORD *)(v4 + 2 * v6 + 456) >> 5;
            v41 = v137;
            v137 = v127;
          }
          else
          {
            v28 = v43 * (v42 >> 11);
            v45 = v43 + ((unsigned int)(2048 - v43) >> 5);
            v41 = v127;
            *(_WORD *)(v4 + 2 * v6 + 456) = v45;
          }
          v127 = v126;
        }
        else
        {
          v28 = v38 * (v37 >> 11);
          v40 = v38 + ((unsigned int)(2048 - v38) >> 5);
          v41 = v126;
          *(_WORD *)(v4 + 2 * v6 + 432) = v40;
        }
        v126 = v123;
        v123 = v41;
      }
      else
      {
        *(_WORD *)(v4 + 2 * v6 + 408) = v31 + ((unsigned int)(2048 - v31) >> 5);
        v33 = (unsigned __int16 *)(v4 + 2 * (v128 + 16 * (v6 + 15)));
        v34 = *v33;
        v35 = v32;
        if ( v32 < 0x1000000 )
        {
          v35 = v32 << 8;
          v5 = *v119++ | (v5 << 8);
        }
        v36 = v34 * (v35 >> 11);
        if ( v5 < v36 )
        {
          v7 = v34 * (v35 >> 11);
          *v33 = v34 + ((unsigned int)(2048 - v34) >> 5);
          ++v120;
          *(_BYTE *)(v122 + v134) = *(_BYTE *)(v122 + (v122 < v123 ? v135 : 0) - v123 + v134);
          ++v122;
          v121 = v6 < 7 ? 9 : 11;
          goto LABEL_154;
        }
        v28 = v35 - v36;
        v5 -= v36;
        *v33 -= *v33 >> 5;
        v26 = v119;
      }
      v121 = v6 < 7 ? 8 : 11;
      v29 = v4 + 2664;
    }
    else
    {
      v28 = v25 * (v24 >> 11);
      *(_WORD *)(v4 + 2 * v6 + 384) = v25 + ((unsigned int)(2048 - v25) >> 5);
      v121 = v6 + 12;
      v29 = v4 + 1636;
    }
    v46 = *(_WORD *)v29;
    if ( v28 < 0x1000000 )
    {
      v28 <<= 8;
      v5 = *v26++ | (v5 << 8);
      v119 = v26;
    }
    v47 = v46 * (v28 >> 11);
    if ( v5 >= v47 )
    {
      v50 = v28 - v47;
      v5 -= v47;
      *(_WORD *)v29 -= *(_WORD *)v29 >> 5;
      v51 = *(_WORD *)(v29 + 2);
      if ( v50 < 0x1000000 )
      {
        v50 <<= 8;
        v5 = *v26 | (v5 << 8);
        v119 = v26 + 1;
      }
      v52 = v51 * (v50 >> 11);
      if ( v5 >= v52 )
      {
        v7 = v50 - v52;
        v5 -= v52;
        *(_WORD *)(v29 + 2) -= *(_WORD *)(v29 + 2) >> 5;
        v48 = v29 + 516;
        v49 = 16;
        v130 = 256;
      }
      else
      {
        v7 = v51 * (v50 >> 11);
        v49 = 8;
        *(_WORD *)(v29 + 2) = v51 + ((unsigned int)(2048 - v51) >> 5);
        v48 = v29 + 16 * v128 + 260;
        v130 = 8;
      }
    }
    else
    {
      v7 = v46 * (v28 >> 11);
      *(_WORD *)v29 = v46 + ((unsigned int)(2048 - v46) >> 5);
      v48 = v29 + 16 * v128 + 4;
      v49 = 0;
      v130 = 8;
    }
    v53 = 1;
    do
    {
      v54 = *(_WORD *)(v48 + 2 * v53);
      if ( v7 < 0x1000000 )
      {
        v7 <<= 8;
        v5 = *v119++ | (v5 << 8);
      }
      v55 = v54 * (v7 >> 11);
      if ( v5 >= v55 )
      {
        v7 -= v55;
        v5 -= v55;
        *(_WORD *)(v48 + 2 * v53) -= *(_WORD *)(v48 + 2 * v53) >> 5;
        v53 = 2 * v53 + 1;
      }
      else
      {
        v7 = v54 * (v7 >> 11);
        *(_WORD *)(v48 + 2 * v53) = v54 + ((unsigned int)(2048 - v54) >> 5);
        v53 *= 2;
      }
    }
    while ( v53 < v130 );
    v56 = v49 - v130 + v53;
    v125 = v56;
    if ( v121 >= 0xC )
      break;
LABEL_143:
    v110 = v122;
    v111 = v56 + 2;
    if ( a2 == v122 )
      return 1;
    v133 = a2 - v122;
    if ( a2 - v122 >= v111 )
      v133 = v111;
    v112 = v133;
    v120 += v133;
    v113 = v122 + (v122 < v123 ? v135 : 0) - v123;
    v124 = v111 - v133;
    if ( v113 + v133 > v135 )
    {
      do
      {
        *(_BYTE *)(v134 + v110++) = *(_BYTE *)(v113++ + v134);
        if ( v113 == v135 )
          v113 = 0;
        --v112;
      }
      while ( v112 );
      v122 = v110;
    }
    else
    {
      v114 = (_BYTE *)(v122 + v134);
      v115 = (v122 < v123 ? v135 : 0) - v123;
      v116 = v122 + v134 + v133;
      v122 += v133;
      do
      {
        *v114 = v114[v115];
        ++v114;
      }
      while ( v114 != (_BYTE *)v116 );
    }
LABEL_154:
    if ( v122 >= a2 || (unsigned int)v119 >= a3 )
      goto LABEL_159;
    v4 = v136;
    v6 = v121;
    v3 = v144;
  }
  v57 = v56;
  if ( v56 >= 4 )
    v57 = 3;
  v58 = v119;
  v59 = (v57 << 7) + v136 + 864;
  v60 = *(_WORD *)(v59 + 2);
  if ( v7 < 0x1000000 )
  {
    v7 <<= 8;
    v5 = *v119 | (v5 << 8);
    v58 = v119++ + 1;
  }
  v61 = v60 * (v7 >> 11);
  if ( v5 >= v61 )
  {
    v62 = v7 - v61;
    v5 -= v61;
    *(_WORD *)(v59 + 2) -= *(_WORD *)(v59 + 2) >> 5;
    v63 = 3;
  }
  else
  {
    v62 = v60 * (v7 >> 11);
    *(_WORD *)(v59 + 2) = v60 + ((unsigned int)(2048 - v60) >> 5);
    v63 = 2;
  }
  v64 = 2 * v63;
  v65 = *(_WORD *)(2 * v63 + v59);
  if ( v62 < 0x1000000 )
  {
    v62 <<= 8;
    v5 = *v58++ | (v5 << 8);
    v119 = v58;
  }
  v66 = v65 * (v62 >> 11);
  if ( v5 >= v66 )
  {
    v67 = v62 - v66;
    v5 -= v66;
    *(_WORD *)(v64++ + v59) = v65 - (v65 >> 5);
  }
  else
  {
    v67 = v65 * (v62 >> 11);
    *(_WORD *)(v64 + v59) = v65 + ((2048 - v65) >> 5);
  }
  v68 = 2 * v64;
  v69 = *(_WORD *)(v68 + v59);
  if ( v67 < 0x1000000 )
  {
    v67 <<= 8;
    v5 = *v58++ | (v5 << 8);
    v119 = v58;
  }
  v70 = v69 * (v67 >> 11);
  if ( v5 >= v70 )
  {
    v71 = v67 - v70;
    v5 -= v70;
    *(_WORD *)(v68 + v59) -= *(_WORD *)(v68 + v59) >> 5;
    ++v68;
  }
  else
  {
    v71 = v69 * (v67 >> 11);
    *(_WORD *)(v68 + v59) = v69 + ((unsigned int)(2048 - v69) >> 5);
  }
  v72 = 2 * v68;
  v73 = *(_WORD *)(v72 + v59);
  if ( v71 < 0x1000000 )
  {
    v71 <<= 8;
    v5 = *v58++ | (v5 << 8);
    v119 = v58;
  }
  v74 = v73 * (v71 >> 11);
  if ( v5 >= v74 )
  {
    v75 = v71 - v74;
    v5 -= v74;
    *(_WORD *)(v72 + v59) -= *(_WORD *)(v72 + v59) >> 5;
    ++v72;
  }
  else
  {
    v75 = v73 * (v71 >> 11);
    *(_WORD *)(v72 + v59) = v73 + ((unsigned int)(2048 - v73) >> 5);
  }
  v76 = 2 * v72;
  v77 = *(_WORD *)(v76 + v59);
  if ( v75 < 0x1000000 )
  {
    v75 <<= 8;
    v5 = *v58++ | (v5 << 8);
    v119 = v58;
  }
  v78 = v77 * (v75 >> 11);
  if ( v5 >= v78 )
  {
    v79 = v75 - v78;
    v5 -= v78;
    *(_WORD *)(v76 + v59) -= *(_WORD *)(v76 + v59) >> 5;
    ++v76;
  }
  else
  {
    v79 = v77 * (v75 >> 11);
    *(_WORD *)(v76 + v59) = v77 + ((unsigned int)(2048 - v77) >> 5);
  }
  v80 = 2 * v76;
  v81 = *(_WORD *)(v80 + v59);
  if ( v79 < 0x1000000 )
  {
    v79 <<= 8;
    v5 = *v58 | (v5 << 8);
    v119 = v58 + 1;
  }
  v82 = v81 * (v79 >> 11);
  if ( v5 >= v82 )
  {
    v7 = v79 - v82;
    v5 -= v82;
    *(_WORD *)(v80 + v59) -= *(_WORD *)(v80 + v59) >> 5;
    v83 = v80 + 1;
  }
  else
  {
    v7 = v81 * (v79 >> 11);
    *(_WORD *)(v80 + v59) = v81 + ((unsigned int)(2048 - v81) >> 5);
    v83 = v80;
  }
  v84 = v83 - 64;
  if ( v84 < 4 )
  {
LABEL_138:
    v108 = v126;
    v137 = v127;
    v126 = v123;
    v127 = v108;
    v123 = v84 + 1;
    if ( v139 )
      v109 = v84 < v139;
    else
      v109 = v84 < v120;
    if ( !v109 )
      return 1;
    v56 = v125;
    v121 = v121 < 0x13 ? 7 : 10;
    goto LABEL_143;
  }
  v85 = v84;
  v86 = 1;
  v87 = (v84 >> 1) - 1;
  v88 = v84 & 1 | 2;
  v131 = v87;
  if ( v85 < 0xE )
  {
    v84 = v88 << v87;
    v138 = 1;
    v89 = v136 + 2 * (v84 - v85) + 1374;
    do
    {
      v90 = *(_WORD *)(v89 + 2 * v86);
      if ( v7 < 0x1000000 )
      {
        v7 <<= 8;
        v5 = *v119++ | (v5 << 8);
      }
      v91 = v90 * (v7 >> 11);
      if ( v5 >= v91 )
      {
        v7 -= v91;
        v5 -= v91;
        v84 |= v138;
        *(_WORD *)(v89 + 2 * v86) -= *(_WORD *)(v89 + 2 * v86) >> 5;
        v86 = 2 * v86 + 1;
      }
      else
      {
        v7 = v90 * (v7 >> 11);
        *(_WORD *)(v89 + 2 * v86) = v90 + ((unsigned int)(2048 - v90) >> 5);
        v86 *= 2;
      }
      v138 *= 2;
      --v131;
    }
    while ( v131 );
    goto LABEL_138;
  }
  v92 = v119;
  v132 = v87 - 4;
  do
  {
    if ( v7 < 0x1000000 )
    {
      v7 <<= 8;
      v5 = *v92++ | (v5 << 8);
    }
    v7 >>= 1;
    v93 = v5 - v7;
    v88 = 2 * v88 - (v93 >> 31) + 1;
    v5 = (v7 & -(v93 >> 31)) + v93;
    --v132;
  }
  while ( v132 );
  v94 = *(_WORD *)(v136 + 1606);
  v84 = 16 * v88;
  v119 = v92;
  if ( v7 < 0x1000000 )
  {
    v7 <<= 8;
    v5 = *v92 | (v5 << 8);
    v119 = v92 + 1;
  }
  v95 = v94 * (v7 >> 11);
  if ( v5 >= v95 )
  {
    v96 = v7 - v95;
    v5 -= v95;
    *(_WORD *)(v136 + 1606) -= *(_WORD *)(v136 + 1606) >> 5;
    v97 = 3;
    v84 |= 1u;
  }
  else
  {
    v96 = v94 * (v7 >> 11);
    *(_WORD *)(v136 + 1606) = v94 + ((unsigned int)(2048 - v94) >> 5);
    v97 = 2;
  }
  v98 = 2 * v97;
  v99 = *(_WORD *)(2 * v97 + v136 + 1604);
  if ( v96 < 0x1000000 )
  {
    v96 <<= 8;
    v5 = *v119++ | (v5 << 8);
  }
  v100 = v99 * (v96 >> 11);
  if ( v5 >= v100 )
  {
    v101 = v96 - v100;
    v5 -= v100;
    *(_WORD *)(v98++ + v136 + 1604) = v99 - (v99 >> 5);
    v84 |= 2u;
  }
  else
  {
    v101 = v99 * (v96 >> 11);
    *(_WORD *)(v98 + v136 + 1604) = v99 + ((2048 - v99) >> 5);
  }
  v102 = 2 * v98;
  v103 = *(_WORD *)(v102 + v136 + 1604);
  if ( v101 < 0x1000000 )
  {
    v101 <<= 8;
    v5 = *v119++ | (v5 << 8);
  }
  v104 = v103 * (v101 >> 11);
  if ( v5 >= v104 )
  {
    v105 = v101 - v104;
    v5 -= v104;
    *(_WORD *)(v102 + v136 + 1604) -= *(_WORD *)(v102 + v136 + 1604) >> 5;
    ++v102;
    v84 |= 4u;
  }
  else
  {
    v105 = v103 * (v101 >> 11);
    *(_WORD *)(v102 + v136 + 1604) = v103 + ((unsigned int)(2048 - v103) >> 5);
  }
  v106 = *(_WORD *)(v136 + 2 * v102 + 1604);
  if ( v105 < 0x1000000 )
  {
    v105 <<= 8;
    v5 = *v119++ | (v5 << 8);
  }
  v107 = v106 * (v105 >> 11);
  if ( v5 >= v107 )
  {
    v7 = v105 - v107;
    v5 -= v107;
    *(_WORD *)(v136 + 2 * v102 + 1604) -= *(_WORD *)(v136 + 2 * v102 + 1604) >> 5;
    v84 |= 8u;
  }
  else
  {
    v7 = v106 * (v105 >> 11);
    *(_WORD *)(v136 + 2 * v102 + 1604) = v106 + ((unsigned int)(2048 - v106) >> 5);
  }
  if ( v84 != -1 )
    goto LABEL_138;
  v124 = v125 + 274;
  v121 -= 12;
LABEL_159:
  v118 = (int)v119;
  if ( v7 < 0x1000000 )
  {
    v7 <<= 8;
    v5 = *v119 | (v5 << 8);
    v118 = (int)(v119 + 1);
  }
  *(_DWORD *)(a1 + 28) = v7;
  *(_DWORD *)(a1 + 24) = v118;
  *(_DWORD *)(a1 + 36) = v122;
  *(_DWORD *)(a1 + 72) = v124;
  *(_DWORD *)(a1 + 56) = v123;
  *(_DWORD *)(a1 + 44) = v120;
  *(_DWORD *)(a1 + 32) = v5;
  *(_DWORD *)(a1 + 64) = v127;
  *(_DWORD *)(a1 + 60) = v126;
  *(_DWORD *)(a1 + 52) = v121;
  *(_DWORD *)(a1 + 68) = v137;
  return 0;
}

//----- (10054390) --------------------------------------------------------
signed int __usercall sub_10054390@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  int v3; // eax@3
  signed int result; // eax@4

  v2 = (768 << (*(_BYTE *)a1 + *(_BYTE *)(a1 + 4))) + 1846;
  if ( *(_DWORD *)(a2 + 16) && v2 == *(_DWORD *)(a2 + 84)
    || (off_100AD04C(&off_100AD048, *(_DWORD *)(a2 + 16)),
        *(_DWORD *)(a2 + 16) = 0,
        v3 = off_100AD048(&off_100AD048, 2 * v2),
        *(_DWORD *)(a2 + 16) = v3,
        *(_DWORD *)(a2 + 84) = v2,
        v3) )
  {
    result = 0;
  }
  else
  {
    result = 2;
  }
  return result;
}
// 100AD048: using guessed type int (__cdecl *off_100AD048)(_DWORD, _DWORD);
// 100AD04C: using guessed type int (__cdecl *off_100AD04C)(_DWORD, _DWORD);

//----- (10054410) --------------------------------------------------------
signed int __usercall sub_10054410@<eax>(int a1@<eax>, unsigned int a2@<ebx>, unsigned int a3@<edi>)
{
  int v3; // esi@1
  unsigned int v4; // edx@2
  int v5; // ecx@3
  unsigned int v6; // eax@3
  signed int result; // eax@5
  unsigned int v8; // eax@6

  v3 = a1;
  while ( 1 )
  {
    v4 = a3;
    if ( !*(_DWORD *)(v3 + 48) )
    {
      v5 = *(_DWORD *)(v3 + 36);
      v6 = *(_DWORD *)(v3 + 12) - *(_DWORD *)(v3 + 44);
      if ( a3 - v5 > v6 )
        v4 = v5 + v6;
    }
    result = sub_10053760(v3, v4, a2);
    if ( result )
      break;
    v8 = *(_DWORD *)(v3 + 12);
    if ( *(_DWORD *)(v3 + 44) >= v8 )
      *(_DWORD *)(v3 + 48) = v8;
    sub_100536F0(a3, v3);
    if ( *(_DWORD *)(v3 + 36) >= a3 || *(_DWORD *)(v3 + 24) >= a2 || *(_DWORD *)(v3 + 72) >= 0x112u )
    {
      if ( *(_DWORD *)(v3 + 72) > 0x112u )
        *(_DWORD *)(v3 + 72) = 274;
      return 0;
    }
  }
  return result;
}

//----- (100544E0) --------------------------------------------------------
int __usercall sub_100544E0@<eax>(int a1@<eax>, int a2, void *a3, int a4, int a5)
{
  int v5; // esi@1
  unsigned int v6; // ebx@1
  bool v7; // zf@1
  unsigned int v8; // ecx@4
  int v9; // ecx@12
  void *v10; // edi@12
  unsigned int v11; // ecx@13
  unsigned __int8 v12; // cf@13
  char *v13; // edi@13
  int i; // ecx@13
  unsigned int v15; // ebp@17
  char *v16; // ebp@19
  char *v17; // edi@19
  int v18; // eax@23
  unsigned int v19; // edi@24
  int result; // eax@36
  int v21; // esi@42
  unsigned int v22; // [sp+10h] [bp-8h]@1
  unsigned int v23; // [sp+14h] [bp-4h]@24

  v5 = a1;
  v6 = *(_DWORD *)a4;
  v22 = *(_DWORD *)a4;
  *(_DWORD *)a4 = 0;
  sub_100536F0(a2, a1);
  v7 = *(_DWORD *)(v5 + 72) == 274;
  *(_DWORD *)a5 = 0;
  if ( v7 )
  {
LABEL_42:
    v21 = *(_DWORD *)(v5 + 32);
    if ( !v21 )
      *(_DWORD *)a5 = 1;
    result = v21 != 0;
  }
  else
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(v5 + 76) )
      {
        if ( v6 )
        {
          do
          {
            v8 = *(_DWORD *)(v5 + 88);
            if ( v8 >= 5 )
              break;
            *(_BYTE *)(v8 + v5 + 92) = *(_BYTE *)a3;
            ++*(_DWORD *)(v5 + 88);
            a3 = (char *)a3 + 1;
            ++*(_DWORD *)a4;
            --v6;
          }
          while ( v6 );
          v22 = v6;
        }
        if ( *(_DWORD *)(v5 + 88) < 5u )
          goto LABEL_40;
        if ( *(_BYTE *)(v5 + 92) )
          return 1;
        *(_DWORD *)(v5 + 32) = *(_BYTE *)(v5 + 96) | ((*(_BYTE *)(v5 + 95) | ((*(_BYTE *)(v5 + 94) | (*(_BYTE *)(v5 + 93) << 8)) << 8)) << 8);
        *(_DWORD *)(v5 + 28) = -1;
        *(_DWORD *)(v5 + 76) = 0;
        *(_DWORD *)(v5 + 88) = 0;
      }
      if ( *(_DWORD *)(v5 + 36) >= (unsigned int)a2 )
        break;
      if ( *(_DWORD *)(v5 + 80) )
      {
        v9 = *(_DWORD *)v5 + *(_DWORD *)(v5 + 4);
        v10 = *(void **)(v5 + 16);
        if ( 768 << v9 != -1846 )
        {
          v11 = (768 << v9) + 1846;
          v12 = v11 & 1;
          v11 >>= 1;
          memset32(v10, 67109888, v11);
          v13 = (char *)v10 + 4 * v11;
          for ( i = v12; i; --i )
          {
            *(_WORD *)v13 = 1024;
            v13 += 2;
          }
        }
        *(_DWORD *)(v5 + 68) = 1;
        *(_DWORD *)(v5 + 64) = 1;
        *(_DWORD *)(v5 + 60) = 1;
        *(_DWORD *)(v5 + 56) = 1;
        *(_DWORD *)(v5 + 52) = 0;
        *(_DWORD *)(v5 + 80) = 0;
      }
      v15 = *(_DWORD *)(v5 + 88);
      if ( v15 )
      {
        v19 = 0;
        v23 = 0;
        if ( v15 < 0x14 )
        {
          do
          {
            if ( v19 >= v6 )
              break;
            *(_BYTE *)(v5 + v15++ + 92) = *((_BYTE *)a3 + v19++);
          }
          while ( v15 < 0x14 );
          v23 = v19;
        }
        *(_DWORD *)(v5 + 88) = v15;
        if ( v15 < 0x14 && !sub_100530F0(v15, v5, (_BYTE *)(v5 + 92)) )
        {
          *(_DWORD *)a4 += v19;
          *(_DWORD *)a5 = 3;
          return 0;
        }
        *(_DWORD *)(v5 + 24) = v5 + 92;
        if ( sub_10054410(v5, v5 + 92, a2) )
          return 1;
        v18 = v23 + *(_DWORD *)(v5 + 24) - v15 - v5 - 92;
        *(_DWORD *)a4 += v18;
        a3 = (char *)a3 + v18;
        *(_DWORD *)(v5 + 88) = 0;
      }
      else
      {
        if ( v6 < 0x14 )
        {
          v17 = (char *)a3;
          if ( !sub_100530F0(v6, v5, a3) )
          {
            memcpy((void *)(v5 + 92), a3, v6);
            *(_DWORD *)(v5 + 88) = v6;
            *(_DWORD *)a4 += v6;
LABEL_40:
            *(_DWORD *)a5 = 3;
            return 0;
          }
          v16 = (char *)a3;
        }
        else
        {
          v16 = (char *)a3;
          v17 = (char *)a3 + v6 - 20;
        }
        *(_DWORD *)(v5 + 24) = v16;
        if ( sub_10054410(v5, (unsigned int)v17, a2) )
          return 1;
        v18 = *(_DWORD *)(v5 + 24) - (_DWORD)v16;
        *(_DWORD *)a4 += v18;
        a3 = &v16[v18];
      }
      v22 -= v18;
      if ( *(_DWORD *)(v5 + 72) == 274 )
        goto LABEL_42;
      v6 = v22;
    }
    if ( *(_DWORD *)(v5 + 72) || *(_DWORD *)(v5 + 32) )
    {
      *(_DWORD *)a5 = 2;
      result = 0;
    }
    else
    {
      *(_DWORD *)a5 = 4;
      result = 0;
    }
  }
  return result;
}

//----- (100547B0) --------------------------------------------------------
signed int __usercall sub_100547B0@<eax>(unsigned int *a1@<eax>, int a2@<edx>, int a3, int *a4, void *a5, unsigned int a6, _DWORD *a7)
{
  unsigned int *v7; // esi@1
  unsigned int v8; // ebx@1
  int v9; // ecx@1
  signed int result; // eax@2
  int v11; // esi@6
  void *v12; // ST0C_4@9
  int v13; // ecx@11
  int v14; // [sp+Ch] [bp-84h]@1
  int v15; // [sp+10h] [bp-80h]@11
  int v16; // [sp+14h] [bp-7Ch]@13
  int v17; // [sp+18h] [bp-78h]@13
  int v18; // [sp+1Ch] [bp-74h]@13
  int v19; // [sp+20h] [bp-70h]@6
  int v20; // [sp+24h] [bp-6Ch]@13
  int v21; // [sp+28h] [bp-68h]@13
  int v22; // [sp+2Ch] [bp-64h]@13
  void *v23; // [sp+30h] [bp-60h]@3
  int v24; // [sp+34h] [bp-5Ch]@3
  int v25; // [sp+44h] [bp-4Ch]@6
  int v26; // [sp+48h] [bp-48h]@6
  int v27; // [sp+4Ch] [bp-44h]@6
  int v28; // [sp+50h] [bp-40h]@6
  int v29; // [sp+68h] [bp-28h]@6
  int v30; // [sp+6Ch] [bp-24h]@6
  int v31; // [sp+70h] [bp-20h]@6
  int v32; // [sp+78h] [bp-18h]@6

  v7 = a1;
  v8 = *a1;
  v9 = *a4;
  *a4 = 0;
  v14 = v9;
  *a1 = 0;
  if ( v8 < 5 )
    return 6;
  v24 = 0;
  v23 = 0;
  if ( a6 < 5 )
  {
    result = 4;
LABEL_5:
    if ( result )
      return result;
    goto LABEL_6;
  }
  result = sub_10052FC0((int)&v15, a2);
  if ( result )
    return result;
  result = sub_10054390(v13, (int)&v19);
  if ( result )
    goto LABEL_5;
  v19 = v15;
  v20 = v16;
  v21 = v17;
  v22 = v18;
LABEL_6:
  *v7 = v8;
  v24 = a3;
  v30 = 1;
  v31 = 1;
  v26 = v14;
  v25 = 0;
  v29 = 0;
  v32 = 0;
  v27 = 0;
  v28 = 0;
  v11 = sub_100544E0((int)&v19, v14, a5, (int)v7, (int)a7);
  if ( !v11 && *a7 == 3 )
    v11 = 6;
  v12 = v23;
  *a4 = v25;
  off_100AD04C(&off_100AD048, v12);
  return v11;
}
// 100AD048: using guessed type int (__cdecl *off_100AD048)(_DWORD, _DWORD);
// 100AD04C: using guessed type int (__cdecl *off_100AD04C)(_DWORD, _DWORD);

//----- (100548D0) --------------------------------------------------------
signed int __usercall sub_100548D0@<eax>(_DWORD *a1@<eax>, int a2@<edi>, int a3@<esi>)
{
  unsigned int v3; // edx@1
  signed int result; // eax@2
  signed int v5; // ecx@3
  signed int v6; // edx@8

  v3 = *(_DWORD *)(a3 + 244992);
  if ( *a1 >= 5u )
  {
    *a1 = 5;
    v5 = 11;
    *(_BYTE *)a2 = *(_BYTE *)(a3 + 206228) + 9 * (*(_BYTE *)(a3 + 206232) + 5 * *(_BYTE *)(a3 + 206236));
    while ( 1 )
    {
      if ( v3 <= 2 << v5 )
      {
        v6 = 2;
        goto LABEL_10;
      }
      if ( v3 <= 3 << v5 )
        break;
      if ( ++v5 > 30 )
        goto LABEL_11;
    }
    v6 = 3;
LABEL_10:
    v3 = v6 << v5;
LABEL_11:
    *(_BYTE *)(a2 + 1) = v3;
    *(_BYTE *)(a2 + 3) = v3 >> 16;
    *(_BYTE *)(a2 + 2) = BYTE1(v3);
    *(_BYTE *)(a2 + 4) = BYTE3(v3);
    result = 0;
  }
  else
  {
    result = 5;
  }
  return result;
}

//----- (10054A30) --------------------------------------------------------
int __usercall sub_10054A30@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3)
{
  int v3; // esi@1
  int v4; // eax@1
  int v5; // edx@1
  int v6; // ebp@1
  int v7; // edi@2
  int v8; // eax@3
  int v9; // eax@5
  int v10; // edi@5
  int v11; // ebx@5
  int result; // eax@6

  v3 = a1;
  v4 = 6 * a1;
  v5 = *(_DWORD *)(a2 + 8 * v4 + 1716);
  v6 = *(_DWORD *)(a2 + 8 * v4 + 1720);
  *(_DWORD *)(a2 + 1672) = v3;
  do
  {
    v7 = a2 + 48 * v3;
    if ( *(_DWORD *)(v7 + 1700) )
    {
      v8 = a2 + 48 * v5;
      *(_DWORD *)(v8 + 1720) = -1;
      *(_DWORD *)(v8 + 1700) = 0;
      *(_DWORD *)(v8 + 1716) = v5 - 1;
      if ( *(_DWORD *)(v7 + 1704) )
      {
        *(_DWORD *)(v8 + 1652) = 0;
        *(_DWORD *)(v8 + 1668) = *(_DWORD *)(v7 + 1708);
        *(_DWORD *)(v8 + 1672) = *(_DWORD *)(v7 + 1712);
      }
    }
    v9 = 6 * v5;
    v10 = v5;
    v5 = *(_DWORD *)(a2 + 48 * v5 + 1716);
    v11 = v6;
    v6 = *(_DWORD *)(a2 + 8 * v9 + 1720);
    *(_DWORD *)(a2 + 8 * v9 + 1716) = v3;
    *(_DWORD *)(a2 + 8 * v9 + 1720) = v11;
    v3 = v10;
  }
  while ( v10 );
  *a3 = *(_DWORD *)(a2 + 1720);
  result = *(_DWORD *)(a2 + 1716);
  *(_DWORD *)(a2 + 1676) = result;
  return result;
}

//----- (10054B00) --------------------------------------------------------
int __usercall sub_10054B00@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  int v4; // esi@1
  int result; // eax@2
  int v6; // eax@3

  v4 = a1;
  if ( a1 )
  {
    v6 = *(_DWORD *)(a3 + 4 * ((*(_WORD *)(a3 + 2 * a2 + 206660) ^ 0x7F0u) >> 4) + 200348);
    if ( v4 == 1 )
      result = *(_DWORD *)(a3 + 4 * ((unsigned int)*(_WORD *)(a3 + 2 * a2 + 206684) >> 4) + 200348) + v6;
    else
      result = *(_DWORD *)(a3 + 4 * ((*(_WORD *)(a3 + 2 * a2 + 206684) ^ 0x7F0u) >> 4) + 200348)
             + *(_DWORD *)(a3
                         + 4 * (((2 - v4) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(a3 + 2 * a2 + 206708) >> 4))
                         + 200348)
             + v6;
  }
  else
  {
    result = *(_DWORD *)(a3 + 4 * ((unsigned int)*(_WORD *)(a3 + 2 * a2 + 206660) >> 4) + 200348)
           + *(_DWORD *)(a3 + 4 * ((*(_WORD *)(a3 + 2 * (a4 + 16 * a2) + 206732) ^ 0x7F0u) >> 4) + 200348);
  }
  return result;
}

//----- (10054BE0) --------------------------------------------------------
unsigned int __usercall sub_10054BE0@<eax>(int a1@<esi>, int *a2)
{
  unsigned int v2; // edi@1
  int v3; // eax@1
  int (__cdecl *v4)(_DWORD, int); // ecx@1
  int v5; // eax@1
  int v6; // ebp@1
  int v7; // eax@3
  unsigned int v8; // edx@3
  int v9; // eax@3
  _BYTE *v10; // ecx@6
  unsigned int result; // eax@9

  v2 = 0;
  v3 = (*(int (__cdecl **)(_DWORD))(a1 + 8))(*(_DWORD *)(a1 + 24));
  v4 = *(int (__cdecl **)(_DWORD, int))(a1 + 16);
  *(_DWORD *)(a1 + 1688) = v3;
  v5 = v4(*(_DWORD *)(a1 + 24), a1 + 200860);
  v6 = v5;
  if ( v5 )
  {
    v2 = *(_DWORD *)(a1 + 4 * v5 + 200852);
    if ( v2 == *(_DWORD *)(a1 + 203056) )
    {
      v7 = (*(int (__cdecl **)(_DWORD))(a1 + 12))(*(_DWORD *)(a1 + 24));
      v8 = *(_DWORD *)(a1 + 1688);
      v9 = v7 - 1;
      if ( v8 > 0x111 )
        v8 = 273;
      if ( v2 < v8 )
      {
        v10 = (_BYTE *)(v9 + v2);
        do
        {
          if ( *v10 != v10[v9 - (*(_DWORD *)(a1 + 4 * v6 + 200856) + 1) - v9] )
            break;
          ++v2;
          ++v10;
        }
        while ( v2 < v8 );
      }
    }
  }
  ++*(_DWORD *)(a1 + 203060);
  result = v2;
  *a2 = v6;
  return result;
}

//----- (10054D80) --------------------------------------------------------
int __usercall sub_10054D80@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>, int a4)
{
  int v4; // esi@1
  signed int v5; // edx@1
  int result; // eax@1
  unsigned int v7; // ecx@1

  v4 = a1;
  v5 = 256;
  result = 0;
  v7 = a2 | 0x100;
  do
  {
    v4 *= 2;
    result += *(_DWORD *)(a3
                        + 4
                        * (((signed int)-((v7 >> 7) & 1) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(a4
                                                                                                + 2
                                                                                                * (v5
                                                                                                 + (v4 & v5)
                                                                                                 + (v7 >> 8))) >> 4)));
    v7 *= 2;
    v5 &= ~(v4 ^ v7);
  }
  while ( v7 < 0x10000 );
  return result;
}

//----- (10054DE0) --------------------------------------------------------
int __usercall sub_10054DE0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>)
{
  int result; // eax@1
  unsigned int v4; // ecx@1

  result = 0;
  v4 = a2 | 0x100;
  do
  {
    result += *(_DWORD *)(a1
                        + 4
                        * (((signed int)-((v4 >> 7) & 1) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(a3 + 2 * (v4 >> 8)) >> 4)));
    v4 *= 2;
  }
  while ( v4 < 0x10000 );
  return result;
}

//----- (10054E20) --------------------------------------------------------
int __usercall sub_10054E20@<eax>(int a1@<edi>)
{
  unsigned int v1; // edx@1
  int v2; // ecx@2
  unsigned int v3; // eax@2
  signed int v4; // esi@2
  int result; // eax@6
  unsigned int v6; // ecx@6

  v1 = 8;
  do
  {
    v2 = 0;
    v3 = v1;
    v4 = 4;
    do
    {
      v3 *= v3;
      for ( v2 *= 2; v3 >= 0x10000; ++v2 )
        v3 >>= 1;
      --v4;
    }
    while ( v4 );
    result = 161 - v2;
    v6 = v1 >> 4;
    v1 += 16;
    *(_DWORD *)(a1 + 4 * v6) = result;
  }
  while ( v1 < 0x800 );
  return result;
}

//----- (10054F40) --------------------------------------------------------
int __cdecl sub_10054F40(int a1, void *a2, int a3)
{
  size_t v3; // esi@1

  v3 = *(_DWORD *)a3;
  if ( *(_DWORD *)(a1 + 8) < *(_DWORD *)a3 )
    v3 = *(_DWORD *)(a1 + 8);
  memcpy(a2, *(const void **)(a1 + 4), v3);
  *(_DWORD *)(a1 + 8) -= v3;
  *(_DWORD *)(a1 + 4) += v3;
  *(_DWORD *)a3 = v3;
  return 0;
}

//----- (10054F80) --------------------------------------------------------
void *__cdecl sub_10054F80(char *a1)
{
  signed int v1; // ebx@1
  int v2; // edi@1
  int v3; // ecx@2
  signed int v4; // esi@2
  void *result; // eax@3

  v1 = 2;
  *(_WORD *)a1 = 256;
  v2 = 2;
  do
  {
    v3 = (v2 >> 1) - 1;
    v4 = 1 << v3;
    if ( 1 << v3 )
    {
      result = memset(&a1[v1], v2, 1 << v3);
      v1 += v4;
    }
    ++v2;
  }
  while ( v2 < 22 );
  return result;
}

//----- (10054FC0) --------------------------------------------------------
int __usercall sub_10054FC0@<eax>(int result@<eax>)
{
  signed int v1; // esi@1
  bool v2; // zf@3
  signed int v3; // edx@5
  signed int v4; // ecx@26

  v1 = *(_DWORD *)result;
  if ( *(_DWORD *)result < 0 )
    v1 = 5;
  v2 = *(_DWORD *)(result + 4) == 0;
  *(_DWORD *)result = v1;
  if ( v2 )
  {
    if ( v1 > 5 )
      v3 = v1 != 6 ? 0x4000000 : 0x2000000;
    else
      v3 = 1 << (2 * v1 + 14);
    *(_DWORD *)(result + 4) = v3;
  }
  if ( *(_DWORD *)(result + 8) < 0 )
    *(_DWORD *)(result + 8) = 3;
  if ( *(_DWORD *)(result + 12) < 0 )
    *(_DWORD *)(result + 12) = 0;
  if ( *(_DWORD *)(result + 16) < 0 )
    *(_DWORD *)(result + 16) = 2;
  if ( *(_DWORD *)(result + 20) < 0 )
    *(_DWORD *)(result + 20) = v1 >= 5;
  if ( *(_DWORD *)(result + 24) < 0 )
    *(_DWORD *)(result + 24) = v1 >= 7 ? 64 : 32;
  if ( *(_DWORD *)(result + 28) < 0 )
    *(_DWORD *)(result + 28) = *(_DWORD *)(result + 20) != 0;
  if ( *(_DWORD *)(result + 32) < 0 )
    *(_DWORD *)(result + 32) = 4;
  if ( !*(_DWORD *)(result + 36) )
    *(_DWORD *)(result + 36) = ((*(_DWORD *)(result + 24) >> 1) + 16) >> (*(_DWORD *)(result + 28) == 0);
  if ( *(_DWORD *)(result + 44) < 0 )
  {
    if ( !*(_DWORD *)(result + 28) || (v4 = 2, !*(_DWORD *)(result + 20)) )
      v4 = 1;
    *(_DWORD *)(result + 44) = v4;
  }
  return result;
}

//----- (10055100) --------------------------------------------------------
int __fastcall sub_10055100(int a1, int a2)
{
  int v2; // ecx@1
  _WORD *v3; // eax@1
  signed int v4; // edi@1
  signed int v5; // esi@2
  unsigned int v6; // esi@5
  unsigned int i; // eax@5
  int v8; // ecx@7
  int result; // eax@7

  *(_DWORD *)(a2 + 203080) = 0;
  *(_DWORD *)(a2 + 203064) = 0;
  *(_DWORD *)(a2 + 203068) = 0;
  *(_DWORD *)(a2 + 203072) = 0;
  *(_DWORD *)(a2 + 203076) = 0;
  *(_DWORD *)(a2 + 244928) = *(_DWORD *)(a2 + 244936);
  *(_DWORD *)(a2 + 244912) = 0;
  *(_DWORD *)(a2 + 244916) = 0;
  *(_DWORD *)(a2 + 244904) = -1;
  *(_DWORD *)(a2 + 244920) = 1;
  *(_DWORD *)(a2 + 244924) = 0;
  *(_BYTE *)(a2 + 244908) = 0;
  *(_DWORD *)(a2 + 244944) = 0;
  *(_DWORD *)(a2 + 244948) = 0;
  *(_DWORD *)(a2 + 244952) = 0;
  v2 = a2 + 206660;
  v3 = (_WORD *)(a2 + 206732);
  v4 = 12;
  do
  {
    v5 = 16;
    do
    {
      *(v3 - 240) = 1024;
      *v3 = 1024;
      ++v3;
      --v5;
    }
    while ( v5 );
    *(_WORD *)(v2 - 24) = 1024;
    *(_WORD *)v2 = 1024;
    *(_WORD *)(v2 + 24) = 1024;
    *(_WORD *)(v2 + 48) = 1024;
    v2 += 2;
    --v4;
  }
  while ( v4 );
  v6 = 768 << (*(_BYTE *)(a2 + 206232) + *(_BYTE *)(a2 + 206228));
  for ( i = 0; i < v6; ++i )
    *(_WORD *)(*(_DWORD *)(a2 + 206248) + 2 * i) = 1024;
  memset32((void *)(a2 + 207116), 67109888, 0x80u);
  memset32((void *)(a2 + 207628), 67109888, 0x39u);
  *(_DWORD *)(a2 + 207888) = 67109888;
  memset32((void *)(a2 + 207892), 67109888, 0x40u);
  memset32((void *)(a2 + 208148), 67109888, 0x40u);
  memset32((void *)(a2 + 208404), 67109888, 0x80u);
  *(_DWORD *)(a2 + 226392) = 67109888;
  memset32((void *)(a2 + 226396), 67109888, 0x40u);
  memset32((void *)(a2 + 226652), 67109888, 0x40u);
  memset32((void *)(a2 + 226908), 67109888, 0x80u);
  *(_DWORD *)(a2 + 207856) = 67109888;
  *(_DWORD *)(a2 + 207860) = 67109888;
  *(_DWORD *)(a2 + 207864) = 67109888;
  *(_DWORD *)(a2 + 207868) = 67109888;
  *(_DWORD *)(a2 + 207872) = 67109888;
  *(_DWORD *)(a2 + 207876) = 67109888;
  *(_DWORD *)(a2 + 207880) = 67109888;
  *(_DWORD *)(a2 + 207884) = 67109888;
  *(_DWORD *)(a2 + 1672) = 0;
  *(_DWORD *)(a2 + 1676) = 0;
  v8 = *(_DWORD *)(a2 + 206232);
  *(_DWORD *)(a2 + 206244) = (1 << *(_DWORD *)(a2 + 206236)) - 1;
  *(_DWORD *)(a2 + 203060) = 0;
  result = (1 << v8) - 1;
  *(_DWORD *)(a2 + 206240) = result;
  return result;
}

//----- (10055370) --------------------------------------------------------
unsigned int __fastcall sub_10055370(int a1, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // ebp@2
  int v4; // esi@2
  unsigned int v5; // edi@2
  int v6; // ebx@2
  int v7; // eax@5
  int v8; // ebp@8
  int v9; // edi@8
  unsigned int v10; // ebx@9
  unsigned int v11; // eax@10
  int v12; // esi@10
  unsigned int i; // eax@14
  unsigned int result; // eax@16
  int *v15; // ecx@16
  int v16; // esi@17
  bool v17; // zf@18
  int v18; // [sp+10h] [bp-210h]@2
  int v19; // [sp+10h] [bp-210h]@8
  int v20; // [sp+14h] [bp-20Ch]@2
  char *v21; // [sp+14h] [bp-20Ch]@8
  signed int v22; // [sp+18h] [bp-208h]@1
  int v23; // [sp+18h] [bp-208h]@8
  unsigned int v24; // [sp+1Ch] [bp-204h]@2
  signed int v25; // [sp+1Ch] [bp-204h]@8
  int v26[128]; // [sp+20h] [bp-200h]@7

  v2 = 4;
  v22 = 4;
  do
  {
    v3 = *(_BYTE *)(a2 + v2 + 198300);
    v4 = (*(_BYTE *)(a2 + v2 + 198300) & 1 | 2) << ((*(_BYTE *)(a2 + v2 + 198300) >> 1) - 1);
    v24 = *(_BYTE *)(a2 + v2 + 198300);
    v18 = 0;
    v5 = v2 - v4;
    v6 = 1;
    v20 = (v3 >> 1) - 1;
    if ( v3 >> 1 != 1 )
    {
      while ( 1 )
      {
        v7 = v5 & 1;
        v18 += *(_DWORD *)(a2
                         + 4 * ((-v7 >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(a2 + 2 * (v4 + v6 - v3) + 207626) >> 4))
                         + 200348);
        v5 >>= 1;
        v6 = v7 | 2 * v6;
        if ( !--v20 )
          break;
        v3 = v24;
      }
      v2 = v22;
    }
    v26[v2++] = v18;
    v22 = v2;
  }
  while ( v2 < 0x80 );
  v19 = a2 + 207116;
  v8 = a2 + 204116;
  v9 = a2 + 203084;
  v23 = a2 + 204116;
  v21 = (char *)&v26[-51027] - a2;
  v25 = 4;
  do
  {
    v10 = 0;
    if ( *(_DWORD *)(a2 + 206224) )
    {
      do
      {
        v11 = v10 | 0x40;
        v12 = 0;
        if ( (v10 | 0x40) != 1 )
        {
          do
          {
            v12 += *(_DWORD *)(a2
                             + 4
                             * (((signed int)-(v11 & 1) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(v19 + 2 * (v11 >> 1)) >> 4))
                             + 200348);
            v11 >>= 1;
          }
          while ( v11 != 1 );
          v8 = v23;
        }
        *(_DWORD *)(v9 + 4 * v10++) = v12;
      }
      while ( v10 < *(_DWORD *)(a2 + 206224) );
    }
    for ( i = 14; i < *(_DWORD *)(a2 + 206224); ++i )
      *(_DWORD *)(v9 + 4 * i) += 16 * ((i >> 1) - 5);
    *(_DWORD *)(v8 - 8) = *(_DWORD *)v9;
    *(_DWORD *)(v8 - 4) = *(_DWORD *)(v9 + 4);
    *(_DWORD *)v8 = *(_DWORD *)(v9 + 8);
    *(_DWORD *)(v8 + 4) = *(_DWORD *)(v9 + 12);
    result = 4;
    v15 = (int *)(v8 + 8);
    do
    {
      v16 = *(int *)((char *)v15 + (_DWORD)v21) + *(_DWORD *)(v9 + 4 * *(_BYTE *)(a2 + result++ + 198300));
      *v15 = v16;
      ++v15;
    }
    while ( result < 0x80 );
    v19 += 128;
    v21 -= 512;
    v8 += 512;
    v9 += 256;
    v17 = v25-- == 1;
    v23 = v8;
  }
  while ( !v17 );
  *(_DWORD *)(a2 + 244976) = 0;
  return result;
}
// 10055370: using guessed type int var_200[128];

//----- (10055550) --------------------------------------------------------
int __usercall sub_10055550@<eax>(int a1@<edi>)
{
  unsigned int v1; // esi@1
  int v2; // edx@2
  int v3; // ecx@2
  int v4; // eax@3
  int result; // eax@4
  signed int v6; // [sp+Ch] [bp-Ch]@2
  unsigned int v7; // [sp+10h] [bp-8h]@1
  _DWORD *v8; // [sp+14h] [bp-4h]@1

  v1 = 0;
  v7 = 0;
  v8 = (_DWORD *)(a1 + 206156);
  do
  {
    v2 = 0;
    v3 = 1;
    v6 = 4;
    do
    {
      v4 = v1 & 1;
      v2 += *(_DWORD *)(a1 + 4 * ((-v4 >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(a1 + 2 * v3 + 207856) >> 4)) + 200348);
      v1 >>= 1;
      v3 = v4 | 2 * v3;
      --v6;
    }
    while ( v6 );
    v1 = v7 + 1;
    *v8 = v2;
    result = (int)(v8 + 1);
    v7 = v1;
    ++v8;
  }
  while ( v1 < 0x10 );
  *(_DWORD *)(a1 + 206220) = 0;
  return result;
}

//----- (100555E0) --------------------------------------------------------
signed int __usercall sub_100555E0@<eax>(int a1@<eax>, unsigned int *a2)
{
  int v2; // esi@1
  unsigned int v3; // ebx@1
  unsigned int v4; // eax@4
  int v6; // eax@8
  _BYTE *v7; // ecx@9
  unsigned int v8; // edi@11
  _BYTE *v9; // edx@12
  unsigned int v10; // ebp@19
  int v11; // edx@21
  unsigned int v12; // ebx@24
  unsigned int v13; // ecx@25
  unsigned int *v14; // eax@26
  unsigned int v15; // edx@29
  int v16; // edx@41
  unsigned int v17; // eax@45
  unsigned int v18; // edx@46
  unsigned int v19; // ecx@48
  bool v20; // cf@48
  bool v21; // zf@48
  int v22; // eax@55
  _BYTE *v23; // ecx@56
  unsigned int v24; // ebp@58
  unsigned int v25; // edi@58
  _BYTE *v26; // edx@59
  int v27; // ecx@59
  int v28; // ecx@67
  void (__cdecl *v29)(int, unsigned int); // edx@67
  unsigned int v30; // [sp+8h] [bp-18h]@2
  _DWORD *v31; // [sp+Ch] [bp-14h]@8
  unsigned int v32; // [sp+Ch] [bp-14h]@24
  unsigned int v33; // [sp+10h] [bp-10h]@4
  unsigned int v34; // [sp+14h] [bp-Ch]@2
  _DWORD *v35; // [sp+18h] [bp-8h]@8
  unsigned int v36; // [sp+1Ch] [bp-4h]@8

  v2 = a1;
  v3 = 0;
  if ( *(_DWORD *)(a1 + 203060) )
  {
    v30 = *(_DWORD *)(a1 + 1680);
    v34 = *(_DWORD *)(a1 + 1684);
  }
  else
  {
    v30 = sub_10054BE0(a1, (int *)&v34);
  }
  v33 = *(_DWORD *)(v2 + 1688);
  v4 = *(_DWORD *)(v2 + 1688);
  *a2 = -1;
  if ( v4 < 2 )
    return 1;
  if ( v4 > 0x111 )
    v33 = 273;
  v6 = (*(int (__cdecl **)(_DWORD))(v2 + 12))(*(_DWORD *)(v2 + 24)) - 1;
  v36 = 0;
  v35 = 0;
  v31 = (_DWORD *)(v2 + 203064);
  do
  {
    v7 = (_BYTE *)(v6 - *v31);
    if ( *(_BYTE *)v6 == *(v7 - 1) && *(_BYTE *)(v6 + 1) == *v7 )
    {
      v8 = 2;
      if ( v33 > 2 )
      {
        v9 = (_BYTE *)(v6 + 2);
        do
        {
          if ( *v9 != v9[(_DWORD)&v7[-v6 - 1]] )
            break;
          ++v8;
          ++v9;
        }
        while ( v8 < v33 );
      }
      if ( v8 >= *(_DWORD *)(v2 + 203056) )
      {
        *a2 = v3;
        if ( v8 != 1 )
        {
          *(_DWORD *)(v2 + 203060) += v8 - 1;
          (*(void (__cdecl **)(_DWORD, unsigned int))(v2 + 20))(*(_DWORD *)(v2 + 24), v8 - 1);
          return v8;
        }
        return v8;
      }
      if ( v8 > (unsigned int)v35 )
      {
        v36 = v3;
        v35 = (_DWORD *)v8;
      }
    }
    ++v31;
    ++v3;
  }
  while ( v3 < 4 );
  v10 = v30;
  if ( v30 >= *(_DWORD *)(v2 + 203056) )
  {
    *a2 = *(_DWORD *)(v2 + 4 * v34 + 200856) + 4;
    if ( v30 != 1 )
    {
      v11 = *(_DWORD *)(v2 + 24);
      *(_DWORD *)(v2 + 203060) += v30 - 1;
      (*(void (__cdecl **)(int, unsigned int))(v2 + 20))(v11, v30 - 1);
      return v30;
    }
    return v10;
  }
  v12 = 0;
  v32 = 0;
  if ( v30 >= 2 )
  {
    v13 = v34;
    v12 = *(_DWORD *)(v2 + 4 * v34 + 200856);
    v32 = *(_DWORD *)(v2 + 4 * v34 + 200856);
    if ( v34 > 2 )
    {
      v14 = (unsigned int *)(v2 + 4 * v34 + 200848);
      do
      {
        if ( v10 != *(v14 - 1) + 1 )
          break;
        if ( v12 >> 7 <= *v14 )
          break;
        v15 = *(v14 - 1);
        v12 = *v14;
        v14 -= 2;
        v13 -= 2;
        v30 = v15;
        v10 = v15;
      }
      while ( v13 > 2 );
      v32 = v12;
    }
    if ( v10 == 2 && v12 >= 0x80 )
    {
      v30 = 1;
      v10 = 1;
    }
  }
  v8 = (unsigned int)v35;
  if ( (unsigned int)v35 >= 2
    && ((unsigned int)v35 + 1 >= v10
     || (unsigned int)v35 + 2 >= v10 && v12 >= 0x200
     || (unsigned int)v35 + 3 >= v10 && v12 >= 0x8000) )
  {
    *a2 = v36;
    if ( v8 != 1 )
    {
      v16 = *(_DWORD *)(v2 + 24);
      *(_DWORD *)(v2 + 203060) += v8 - 1;
      (*(void (__cdecl **)(int, unsigned int))(v2 + 20))(v16, v8 - 1);
    }
    return v8;
  }
  if ( v10 < 2 || v33 <= 2 )
    return 1;
  v17 = sub_10054BE0(v2, (int *)(v2 + 1684));
  *(_DWORD *)(v2 + 1680) = v17;
  if ( v17 < 2 )
    goto LABEL_55;
  v18 = *(_DWORD *)(v2 + 4 * *(_DWORD *)(v2 + 1684) + 200856);
  if ( v17 >= v10 && v18 < v12 )
    return 1;
  v19 = v10 + 1;
  v20 = v17 < v10 + 1;
  v21 = v17 == v10 + 1;
  if ( v17 == v10 + 1 )
  {
    if ( v18 >> 7 > v12 )
    {
      v20 = v17 < v19;
      v21 = v17 == v19;
      goto LABEL_51;
    }
    return 1;
  }
LABEL_51:
  if ( !v20 && !v21 || v17 + 1 >= v10 && v10 >= 3 && v12 >> 7 > v18 )
    return 1;
LABEL_55:
  v22 = (*(int (__cdecl **)(_DWORD))(v2 + 12))(*(_DWORD *)(v2 + 24)) - 1;
  v36 = 0;
  v35 = (_DWORD *)(v2 + 203064);
  do
  {
    v23 = (_BYTE *)(v22 - *v35 - 1);
    if ( *(_BYTE *)v22 == *v23 && *(_BYTE *)(v22 + 1) == *(_BYTE *)(v22 - *v35) )
    {
      v24 = v10 - 1;
      v25 = 2;
      if ( v24 <= 2 )
        return 1;
      v26 = (_BYTE *)(v22 + 2);
      v27 = (int)&v23[-v22];
      while ( *v26 == v26[v27] )
      {
        ++v25;
        ++v26;
        if ( v25 >= v24 )
          return 1;
      }
      if ( v25 >= v24 )
        return 1;
      v12 = v32;
      v10 = v30;
    }
    ++v35;
    ++v36;
  }
  while ( v36 < 4 );
  *a2 = v12 + 4;
  if ( v10 != 2 )
  {
    v28 = *(_DWORD *)(v2 + 24);
    v29 = *(void (__cdecl **)(int, unsigned int))(v2 + 20);
    *(_DWORD *)(v2 + 203060) += v10 - 2;
    v29(v28, v10 - 2);
  }
  return v10;
}

//----- (10055960) --------------------------------------------------------
unsigned int __usercall sub_10055960@<eax>(int a1@<ebx>, int a2@<esi>, int a3, unsigned int a4, int a5)
{
  unsigned int v5; // edx@1
  unsigned int result; // eax@1
  unsigned int v7; // edx@1
  int i; // edi@3
  unsigned int v9; // eax@9
  int k; // edi@9
  unsigned int v11; // eax@14
  int j; // edi@14
  int v13; // [sp+8h] [bp-Ch]@1
  int v14; // [sp+8h] [bp-Ch]@7
  int v15; // [sp+8h] [bp-Ch]@13
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v13 = *(_DWORD *)(a2 + 4 * ((unsigned int)*(_WORD *)a1 >> 4));
  v5 = *(_WORD *)(a1 + 2);
  result = *(_DWORD *)(a2 + 4 * ((*(_WORD *)a1 ^ 0x7F0u) >> 4));
  v16 = result + *(_DWORD *)(a2 + 4 * (v5 >> 4));
  v17 = result + *(_DWORD *)(a2 + 4 * ((v5 ^ 0x7F0) >> 4));
  v7 = 0;
  while ( v7 < a4 )
  {
    result = v7 | 8;
    for ( i = 0; result != 1; result >>= 1 )
      i += *(_DWORD *)(a2
                     + 4
                     * (((signed int)-(result & 1) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(a1
                                                                                          + 2 * ((result >> 1) + 8 * a3)
                                                                                          + 4) >> 4)));
    *(_DWORD *)(a5 + 4 * v7++) = v13 + i;
    if ( v7 >= 8 )
    {
      if ( v7 >= 0x10 )
      {
LABEL_12:
        if ( v7 < a4 )
        {
          result = v7 - 16;
          v15 = v7 - 16;
          do
          {
            v11 = result | 0x100;
            for ( j = 0; v11 != 1; v11 >>= 1 )
              j += *(_DWORD *)(a2
                             + 4
                             * (((signed int)-(v11 & 1) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(a1
                                                                                               + 2 * (v11 >> 1)
                                                                                               + 516) >> 4)));
            *(_DWORD *)(a5 + 4 * v7++) = v17 + j;
            result = v15++ + 1;
          }
          while ( v7 < a4 );
        }
      }
      else
      {
        result = v7 - 8;
        v14 = v7 - 8;
        while ( v7 < a4 )
        {
          v9 = result | 8;
          for ( k = 0; v9 != 1; v9 >>= 1 )
            k += *(_DWORD *)(a2
                           + 4
                           * (((signed int)-(v9 & 1) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(a1
                                                                                            + 2 * ((v9 >> 1) + 8 * a3)
                                                                                            + 260) >> 4)));
          *(_DWORD *)(a5 + 4 * v7++) = v16 + k;
          result = v14++ + 1;
          if ( v7 >= 0x10 )
            goto LABEL_12;
        }
      }
      return result;
    }
  }
  return result;
}

//----- (10055AE0) --------------------------------------------------------
int __usercall sub_10055AE0@<eax>(int a1@<esi>)
{
  unsigned int v1; // edi@1
  char v2; // bl@3
  _BYTE *v3; // edi@4
  int v4; // edi@4
  int v5; // edi@6
  unsigned __int8 v6; // cf@8
  int v7; // eax@9
  int result; // eax@11

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 < 0xFF000000 || *(_QWORD *)(a1 + 8) >> 32 )
  {
    v2 = *(_BYTE *)(a1 + 4);
    do
    {
      v3 = *(_BYTE **)(a1 + 24);
      *v3 = v2 + (*(_QWORD *)(a1 + 8) >> 32);
      v4 = (int)(v3 + 1);
      *(_DWORD *)(a1 + 24) = v4;
      if ( v4 == *(_DWORD *)(a1 + 28) && !*(_DWORD *)(a1 + 48) )
      {
        v5 = v4 - *(_DWORD *)(a1 + 32);
        if ( v5 != (**(int (__cdecl ***)(_DWORD, _DWORD, _DWORD))(a1 + 36))(
                     *(_DWORD *)(a1 + 36),
                     *(_DWORD *)(a1 + 32),
                     v5) )
          *(_DWORD *)(a1 + 48) = 9;
        v6 = __CFADD__(v5, *(_DWORD *)(a1 + 40));
        *(_DWORD *)(a1 + 40) += v5;
        *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 32);
        *(_DWORD *)(a1 + 44) += v6;
      }
      v2 = -1;
      v6 = __CFADD__((*(_DWORD *)(a1 + 16))--, -1);
      v7 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 20) = v6 + *(_DWORD *)(a1 + 20) - 1;
    }
    while ( *(_DWORD *)(a1 + 20) | v7 );
    v1 = *(_DWORD *)(a1 + 8);
    *(_BYTE *)(a1 + 4) = *(_DWORD *)(a1 + 8) >> 24;
  }
  v6 = __CFADD__((*(_DWORD *)(a1 + 16))++, 1);
  result = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 8) = v1 << 8;
  return result;
}

//----- (10055B90) --------------------------------------------------------
signed int __usercall sub_10055B90@<eax>(const void *a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  int v3; // edx@2
  int v4; // ecx@3
  int v5; // edi@6
  unsigned int v6; // eax@6
  bool v7; // zf@10
  signed int v8; // ecx@10
  int v9; // eax@10
  bool v10; // sf@15
  unsigned __int8 v11; // of@15
  int v12; // ecx@15
  signed int result; // eax@15
  char v14; // [sp+8h] [bp-34h]@1
  unsigned int v15; // [sp+Ch] [bp-30h]@4
  int v16; // [sp+10h] [bp-2Ch]@1
  int v17; // [sp+14h] [bp-28h]@2
  int v18; // [sp+18h] [bp-24h]@3
  int v19; // [sp+1Ch] [bp-20h]@10
  unsigned int v20; // [sp+20h] [bp-1Ch]@6
  int v21; // [sp+24h] [bp-18h]@10
  int v22; // [sp+28h] [bp-14h]@11
  int v23; // [sp+2Ch] [bp-10h]@6
  int v24; // [sp+30h] [bp-Ch]@15
  int v25; // [sp+34h] [bp-8h]@15

  qmemcpy(&v14, a1, 0x30u);
  sub_10054FC0((int)&v14);
  v2 = v16;
  if ( v16 > 8 || (v3 = v17, v17 > 4) || (v4 = v18, v18 > 4) || v15 > 0x8000000 || v15 > 0x40000000 )
  {
    result = 5;
  }
  else
  {
    v5 = v23;
    *(_DWORD *)(a2 + 244992) = v15;
    v6 = v20;
    *(_DWORD *)(a2 + 244996) = v5;
    if ( v6 >= 5 )
    {
      if ( v6 > 0x111 )
        v6 = 273;
    }
    else
    {
      v6 = 5;
    }
    *(_DWORD *)(a2 + 203056) = v6;
    v7 = v19 == 0;
    *(_DWORD *)(a2 + 206236) = v4;
    *(_DWORD *)(a2 + 206228) = v2;
    *(_DWORD *)(a2 + 206232) = v3;
    v8 = 4;
    *(_DWORD *)(a2 + 244900) = v7;
    v9 = v21;
    *(_DWORD *)(a2 + 492) = v21;
    if ( v9 )
    {
      if ( v22 >= 2 )
      {
        if ( v22 < 4 )
          v8 = v22;
      }
      else
      {
        v8 = 2;
      }
    }
    v11 = __OFSUB__(v25, 1);
    v7 = v25 == 1;
    v10 = v25 - 1 < 0;
    *(_DWORD *)(a2 + 484) = v8;
    v12 = v24;
    *(_DWORD *)(a2 + 456) = v5;
    *(_DWORD *)(a2 + 244960) = v12;
    result = 0;
    *(_DWORD *)(a2 + 244984) = !((unsigned __int8)(v10 ^ v11) | v7);
  }
  return result;
}

//----- (10055CB0) --------------------------------------------------------
int __usercall sub_10055CB0@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // edi@1
  int result; // eax@1
  int v4; // [sp+10h] [bp-34h]@1
  int v5; // [sp+14h] [bp-30h]@1
  int v6; // [sp+18h] [bp-2Ch]@1
  int v7; // [sp+1Ch] [bp-28h]@1
  int v8; // [sp+20h] [bp-24h]@1
  int v9; // [sp+24h] [bp-20h]@1
  int v10; // [sp+28h] [bp-1Ch]@1
  int v11; // [sp+2Ch] [bp-18h]@1
  int v12; // [sp+30h] [bp-14h]@1
  int v13; // [sp+34h] [bp-10h]@1
  int v14; // [sp+38h] [bp-Ch]@1
  int v15; // [sp+3Ch] [bp-8h]@1

  v1 = a1;
  v2 = a1 + 412;
  *(_DWORD *)(a1 + 244940) = 0;
  *(_DWORD *)(a1 + 244936) = 0;
  sub_100522A0(a1 + 412);
  *(_DWORD *)(v1 + 280) = 0;
  *(_DWORD *)(v1 + 328) = 0;
  *(_DWORD *)(v1 + 368) = 0;
  *(_DWORD *)(v1 + 372) = 0;
  *(_DWORD *)(v1 + 344) = 0;
  *(_DWORD *)(v1 + 348) = 0;
  *(_DWORD *)(v1 + 352) = 0;
  *(_DWORD *)(v1 + 356) = 0;
  *(_DWORD *)(v1 + 360) = 0;
  *(_DWORD *)(v1 + 364) = 0;
  v15 = -1;
  v12 = -1;
  v11 = -1;
  v10 = -1;
  v9 = -1;
  v8 = -1;
  v7 = -1;
  v6 = -1;
  *(_DWORD *)(v1 + 76) = 0;
  *(_DWORD *)(v1 + 116) = 0;
  *(_DWORD *)(v1 + 120) = 0;
  *(_DWORD *)(v1 + 92) = 0;
  *(_DWORD *)(v1 + 96) = 0;
  *(_DWORD *)(v1 + 100) = 0;
  *(_DWORD *)(v1 + 104) = 0;
  *(_DWORD *)(v1 + 108) = 0;
  *(_DWORD *)(v1 + 112) = 0;
  *(_DWORD *)(v1 + 408) = v2;
  v4 = 5;
  v13 = 0;
  v5 = 0;
  v14 = 0;
  sub_10055B90(&v4, v1);
  sub_10054F80((char *)(v1 + 198300));
  result = sub_10054E20(v1 + 200348);
  *(_DWORD *)(v1 + 206248) = 0;
  *(_DWORD *)(v1 + 245016) = 0;
  return result;
}

//----- (10055DA0) --------------------------------------------------------
int __cdecl sub_10055DA0(int a1, int a2, unsigned int *a3)
{
  int v3; // ebp@1
  int v4; // ecx@1
  int v5; // esi@2
  int result; // eax@2
  unsigned int v7; // ecx@2
  unsigned int v8; // edi@3
  unsigned int v9; // eax@4
  unsigned int v10; // eax@6
  int v11; // eax@10
  unsigned __int8 v12; // dl@10
  int v13; // esi@10
  unsigned int v14; // ebx@11
  int v15; // eax@11
  _BYTE *v16; // ecx@11
  unsigned int v17; // eax@13
  _BYTE *v18; // edi@14
  int v19; // ecx@14
  int v20; // ecx@18
  unsigned int v21; // edi@22
  unsigned int v22; // eax@22
  int v23; // ecx@26
  int v24; // eax@27
  unsigned int v25; // ebx@34
  int v26; // eax@34
  int v27; // edi@34
  unsigned int v28; // esi@34
  int v29; // ecx@34
  int v30; // esi@34
  int v31; // eax@35
  _WORD *v32; // ecx@37
  int v33; // eax@37
  int v34; // ecx@37
  unsigned int v35; // eax@38
  unsigned int v36; // eax@40
  int v37; // edx@45
  int v38; // ecx@45
  _DWORD *v39; // ecx@45
  unsigned int v40; // edi@47
  unsigned int v41; // esi@48
  int v42; // ebx@49
  int v43; // eax@49
  int v44; // eax@49
  _DWORD *v45; // ebx@49
  unsigned int *v46; // ecx@49
  unsigned int v47; // edx@50
  int v48; // edx@54
  int v49; // eax@54
  unsigned int v50; // ebx@55
  int v51; // edi@58
  _DWORD *i; // ecx@61
  unsigned int v53; // esi@62
  int v54; // edx@62
  int v55; // eax@62
  unsigned int v56; // edx@65
  unsigned int v57; // ecx@66
  int v58; // eax@66
  unsigned int v59; // eax@73
  int v60; // edi@74
  int v61; // eax@74
  int v62; // ebx@74
  int v63; // ecx@76
  int v64; // edx@77
  unsigned int v65; // ecx@87
  int v66; // edx@87
  int v67; // eax@92
  int v68; // edx@92
  int v69; // eax@93
  int v70; // eax@96
  int v71; // ecx@96
  int v72; // eax@97
  int v73; // ecx@97
  unsigned int v74; // esi@97
  int v75; // edx@97
  unsigned int v76; // eax@97
  int (__cdecl *v77)(int); // edx@97
  int v78; // ST04_4@97
  char *v79; // edi@97
  unsigned __int8 v80; // dl@97
  int v81; // eax@97
  int v82; // eax@97
  int v83; // eax@97
  unsigned int v84; // edi@97
  int v85; // eax@97
  int v86; // edi@97
  int v87; // eax@98
  unsigned int v88; // eax@99
  unsigned int v89; // edx@100
  int v90; // ecx@100
  unsigned int v91; // edx@102
  int v92; // edi@104
  unsigned int v93; // eax@107
  unsigned int v94; // ecx@109
  unsigned int v95; // esi@112
  unsigned int v96; // esi@116
  unsigned int v97; // ecx@118
  _BYTE *v98; // eax@119
  int v99; // eax@123
  int v100; // ecx@123
  int v101; // ebx@123
  int v102; // edx@123
  unsigned int v103; // esi@123
  unsigned int v104; // edi@123
  int v105; // ebx@124
  _DWORD *v106; // edi@124
  unsigned int v107; // eax@127
  char v108; // cl@130
  unsigned int v109; // edi@132
  _BYTE *v110; // eax@133
  int v111; // ebx@136
  int v112; // eax@137
  _DWORD *v113; // ecx@137
  unsigned int v114; // esi@139
  int v115; // eax@139
  int v116; // eax@139
  unsigned int *v117; // ecx@139
  _DWORD *v118; // ebx@139
  unsigned int v119; // edx@140
  unsigned int v120; // eax@145
  unsigned int v121; // ecx@145
  _BYTE *v122; // edi@148
  int v123; // ebx@152
  int v124; // edx@152
  unsigned int v125; // edi@152
  int v126; // eax@152
  int v127; // eax@152
  int v128; // ebx@152
  int v129; // edi@152
  int v130; // eax@152
  int v131; // ecx@152
  int v132; // ebx@152
  int v133; // edx@152
  unsigned int v134; // ebx@152
  unsigned int v135; // eax@152
  int v136; // ebx@153
  _DWORD *v137; // eax@153
  unsigned int v138; // eax@156
  unsigned int v139; // esi@159
  int v140; // ecx@160
  unsigned int v141; // edx@163
  int v142; // eax@165
  _DWORD *v143; // esi@165
  int v144; // eax@167
  unsigned int v145; // eax@170
  unsigned int v146; // ecx@170
  int v147; // esi@170
  unsigned int v148; // edi@170
  _DWORD *v149; // ebx@170
  int v150; // edx@171
  int v151; // ecx@171
  unsigned int v152; // edx@174
  int v153; // ecx@179
  unsigned int v154; // eax@179
  int v155; // ecx@179
  unsigned int v156; // esi@179
  int v157; // ebx@182
  _BYTE *v158; // edx@182
  int v159; // esi@188
  int v160; // edx@188
  int v161; // eax@188
  int v162; // esi@188
  int v163; // eax@188
  int v164; // ebx@188
  int v165; // eax@188
  int v166; // ecx@188
  int v167; // esi@188
  int v168; // edx@188
  unsigned int v169; // esi@188
  unsigned int v170; // eax@188
  int v171; // esi@189
  _DWORD *v172; // eax@189
  int v173; // eax@192
  unsigned int v174; // eax@192
  int v175; // edx@193
  int v176; // eax@194
  unsigned int v177; // ecx@196
  unsigned __int8 v178; // [sp+Fh] [bp-69h]@30
  unsigned __int8 v179; // [sp+Fh] [bp-69h]@97
  unsigned int v180; // [sp+10h] [bp-68h]@72
  unsigned int v181; // [sp+14h] [bp-64h]@41
  int v182; // [sp+18h] [bp-60h]@4
  unsigned int v183; // [sp+1Ch] [bp-5Ch]@6
  unsigned int v184; // [sp+20h] [bp-58h]@6
  int v185; // [sp+24h] [bp-54h]@10
  unsigned int v186; // [sp+28h] [bp-50h]@97
  unsigned int v187; // [sp+2Ch] [bp-4Ch]@97
  unsigned int v188; // [sp+30h] [bp-48h]@10
  _DWORD *v189; // [sp+34h] [bp-44h]@10
  char *v190; // [sp+38h] [bp-40h]@37
  unsigned int v191; // [sp+3Ch] [bp-3Ch]@22
  int v192; // [sp+40h] [bp-38h]@34
  int v193; // [sp+44h] [bp-34h]@104
  unsigned int v194; // [sp+48h] [bp-30h]@139
  unsigned int v195; // [sp+4Ch] [bp-2Ch]@139
  unsigned int j; // [sp+50h] [bp-28h]@73
  unsigned int v197; // [sp+54h] [bp-24h]@104
  unsigned int v198; // [sp+58h] [bp-20h]@11
  int v199; // [sp+5Ch] [bp-1Ch]@45
  int v200; // [sp+60h] [bp-18h]@45
  int v201; // [sp+64h] [bp-14h]@45
  int v202[4]; // [sp+68h] [bp-10h]@18
  unsigned __int8 v203; // [sp+7Ch] [bp+4h]@10
  int v204; // [sp+7Ch] [bp+4h]@58
  unsigned int v205; // [sp+7Ch] [bp+4h]@87
  unsigned __int8 v206; // [sp+7Ch] [bp+4h]@97
  int v207; // [sp+7Ch] [bp+4h]@122
  unsigned int v208; // [sp+7Ch] [bp+4h]@129
  int v209; // [sp+7Ch] [bp+4h]@167

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 1676);
  if ( *(_DWORD *)(a1 + 1672) != v4 )
  {
    v5 = *(_DWORD *)(a1 + 48 * v4 + 1716);
    result = *(_DWORD *)(a1 + 48 * v4 + 1716) - v4;
    v7 = *(_DWORD *)(a1 + 48 * v4 + 1720);
    *(_DWORD *)(a1 + 1676) = v5;
    *a3 = v7;
    return result;
  }
  v8 = 0;
  *(_DWORD *)(a1 + 1672) = 0;
  *(_DWORD *)(a1 + 1676) = 0;
  if ( *(_DWORD *)(a1 + 203060) )
  {
    v9 = *(_DWORD *)(a1 + 1680);
    v182 = *(_DWORD *)(a1 + 1684);
  }
  else
  {
    v9 = sub_10054BE0(a1, &v182);
  }
  v183 = v9;
  v10 = *(_DWORD *)(a1 + 1688);
  v184 = v10;
  if ( v10 < 2 )
  {
    *a3 = -1;
    return 1;
  }
  if ( v10 > 0x111 )
    v184 = 273;
  v11 = (*(int (__cdecl **)(_DWORD))(a1 + 12))(*(_DWORD *)(a1 + 24));
  v12 = *(_BYTE *)(v11 - 1);
  v13 = v11 - 1;
  v188 = 0;
  v185 = 0;
  v203 = v12;
  v189 = 0;
  do
  {
    v14 = v8;
    v15 = *(_DWORD *)(4 * v8 + v3 + 203064);
    v16 = (_BYTE *)(v13 - v15 - 1);
    *(&v198 + v8) = v15;
    if ( v12 != *v16 || *(_BYTE *)(v13 + 1) != *(_BYTE *)(v13 - v15) )
    {
      v202[v14] = 0;
    }
    else
    {
      v17 = 2;
      if ( v184 > 2 )
      {
        v18 = (_BYTE *)(v13 + 2);
        v19 = (int)&v16[-v13];
        do
        {
          if ( *v18 != v18[v19] )
            break;
          ++v17;
          ++v18;
        }
        while ( v17 < v184 );
        v12 = v203;
        v8 = v185;
      }
      v20 = (int)v189;
      v202[v14] = v17;
      if ( v17 > *(int *)((char *)v202 + v20) )
      {
        v188 = v8;
        v189 = (_DWORD *)(v14 * 4);
      }
    }
    v185 = ++v8;
  }
  while ( v8 < 4 );
  v21 = v202[v188];
  v22 = *(_DWORD *)(v3 + 203056);
  v191 = v21;
  if ( v21 >= v22 )
  {
    *a3 = v188;
    if ( v21 != 1 )
    {
      *(_DWORD *)(v3 + 203060) += v21 - 1;
      (*(void (__cdecl **)(_DWORD, unsigned int))(v3 + 20))(*(_DWORD *)(v3 + 24), v21 - 1);
    }
    return v21;
  }
  v23 = v183;
  if ( v183 < v22 )
  {
    v178 = *(_BYTE *)(v13 - v198 - 1);
    if ( v183 < 2 && v12 != *(_BYTE *)(v13 - v198 - 1) && v21 < 2 )
    {
      *a3 = -1;
      return 1;
    }
    v25 = *(_DWORD *)(v3 + 203080);
    v26 = *(_DWORD *)(v3 + 206228);
    v27 = *(_DWORD *)(v3 + 206244) & a2;
    *(_DWORD *)(v3 + 1696) = v25;
    v28 = (unsigned int)*(_BYTE *)(v13 - 1) >> (8 - v26);
    v29 = a2 & *(_DWORD *)(v3 + 206240);
    v185 = v27;
    v192 = v29;
    v30 = *(_DWORD *)(v3 + 206248) + 1536 * ((v29 << v26) + v28);
    if ( v25 < 7 )
    {
      v31 = sub_10054DE0(v3 + 200348, v12, v30);
    }
    else
    {
      v31 = sub_10054D80(v178, v12, v3 + 200348, v30);
      v27 = v185;
    }
    v32 = (_WORD *)(v3 + 2 * (v27 + 16 * v25) + 206252);
    *(_DWORD *)(v3 + 1740) = v31 + *(_DWORD *)(v3 + 4 * ((unsigned int)*v32 >> 4) + 200348);
    *(_DWORD *)(v3 + 1768) = -1;
    *(_DWORD *)(v3 + 1748) = 0;
    v33 = *(_DWORD *)(v3 + 4 * ((*v32 ^ 0x7F0u) >> 4) + 200348);
    v34 = v33 + *(_DWORD *)(v3 + 4 * ((*(_WORD *)(v3 + 2 * v25 + 206636) ^ 0x7F0u) >> 4) + 200348);
    v190 = (char *)v33;
    v192 = v34;
    if ( v178 == v203 )
    {
      v35 = v34
          + *(_DWORD *)(v3 + 4 * ((unsigned int)*(_WORD *)(v3 + 2 * v25 + 206660) >> 4) + 200348)
          + *(_DWORD *)(v3 + 4 * ((unsigned int)*(_WORD *)(v3 + 2 * (v27 + 16 * v25) + 206732) >> 4) + 200348);
      if ( v35 < *(_DWORD *)(v3 + 1740) )
      {
        *(_DWORD *)(v3 + 1740) = v35;
        *(_DWORD *)(v3 + 1768) = 0;
        *(_DWORD *)(v3 + 1748) = 0;
      }
    }
    v36 = v191;
    if ( v183 < v191 )
    {
      v181 = v191;
    }
    else
    {
      v36 = v183;
      v181 = v183;
    }
    if ( v36 < 2 )
    {
      *a3 = *(_DWORD *)(v3 + 1768);
      return 1;
    }
    v37 = v198;
    v38 = v199;
    *(_DWORD *)(v3 + 1764) = 0;
    *(_DWORD *)(v3 + 1724) = v37;
    *(_DWORD *)(v3 + 1732) = v200;
    *(_DWORD *)(v3 + 1728) = v38;
    *(_DWORD *)(v3 + 1736) = v201;
    v39 = (_DWORD *)(v3 + 48 * v36 + 1692);
    do
    {
      *v39 = 0x40000000;
      --v36;
      v39 -= 12;
    }
    while ( v36 >= 2 );
    v40 = 0;
    do
    {
      v41 = v202[v40];
      if ( v41 >= 2 )
      {
        v42 = v185;
        v43 = sub_10054B00(v40, *(_DWORD *)(v3 + 203080), v3, v185);
        v44 = v192 + v43;
        v45 = (_DWORD *)(v3 + 4 * (v41 + 272 * v42) + 227412);
        v46 = (unsigned int *)(v3 + 48 * v41 + 1720);
        do
        {
          v47 = v44 + *v45;
          if ( v47 < *(v46 - 7) )
          {
            *(v46 - 7) = v47;
            *(v46 - 1) = 0;
            *v46 = v40;
            *(v46 - 5) = 0;
          }
          --v41;
          --v45;
          v46 -= 12;
        }
        while ( v41 >= 2 );
      }
      ++v40;
    }
    while ( v40 < 4 );
    v48 = *(_DWORD *)(v3 + 203080);
    v49 = (int)&v190[*(_DWORD *)(v3 + 4 * ((unsigned int)*(_WORD *)(v3 + 2 * v48 + 206636) >> 4) + 200348)];
    v192 = (int)&v190[*(_DWORD *)(v3 + 4 * ((unsigned int)*(_WORD *)(v3 + 2 * v48 + 206636) >> 4) + 200348)];
    if ( v202[0] < 2u )
      v50 = 2;
    else
      v50 = v202[0] + 1;
    if ( v50 <= v183 )
    {
      v51 = 0;
      v204 = 0;
      if ( v50 > *(_DWORD *)(v3 + 200860) )
      {
        do
          v51 += 2;
        while ( v50 > *(_DWORD *)(v3 + 4 * v51 + 200860) );
        v204 = v51;
      }
      v185 = v3 + 4 * (v50 + 272 * v185) + 208908;
      for ( i = (_DWORD *)(v3 + 48 * v50 + 1720); ; i += 12 )
      {
        v53 = *(_DWORD *)(v3 + 4 * v51 + 200864);
        v54 = v49 + *(_DWORD *)v185;
        v189 = i;
        v55 = v50 - 2;
        if ( v50 >= 5 )
          v55 = 3;
        if ( v53 >= 0x80 )
        {
          v57 = (-((0x1FFFF - v53) >> 31) & 0xA) + 6;
          v51 = v204;
          v58 = *(_DWORD *)(v3 + 4 * (v53 & 0xF) + 206156)
              + *(_DWORD *)(v3 + 4 * (*(_BYTE *)((v53 >> v57) + v3 + 198300) + 2 * (v57 + 32 * v55)) + 203084);
          i = v189;
          v56 = v58 + v54;
        }
        else
        {
          v56 = *(_DWORD *)(v3 + 4 * (v53 + (v55 << 7)) + 204108) + v54;
        }
        if ( v56 < *(i - 7) )
        {
          *(i - 7) = v56;
          *(i - 1) = 0;
          *i = v53 + 4;
          *(i - 5) = 0;
        }
        if ( v50 == *(_DWORD *)(v3 + 4 * v51 + 200860) )
        {
          v51 += 2;
          v204 = v51;
          if ( v51 == v182 )
            break;
        }
        v185 += 4;
        v49 = v192;
        ++v50;
      }
    }
    v180 = 1;
    if ( v181 == 1 )
      return sub_10054A30(v180, v3, a3);
    while ( 1 )
    {
      v59 = sub_10054BE0(v3, (int *)&v189);
      j = v59;
      if ( v59 >= *(_DWORD *)(v3 + 203056) )
      {
        *(_DWORD *)(v3 + 1684) = v189;
        *(_DWORD *)(v3 + 1680) = v59;
        return sub_10054A30(v180, v3, a3);
      }
      ++a2;
      v60 = *(_DWORD *)(48 * v180 + v3 + 1700);
      v61 = *(_DWORD *)(48 * v180 + v3 + 1716);
      v62 = v3 + 48 * v180;
      if ( v60 )
      {
        --v61;
        if ( *(_DWORD *)(v62 + 1704) )
        {
          v63 = *(_DWORD *)(v3 + 48 * *(_DWORD *)(v62 + 1708) + 1696);
          v64 = *(_DWORD *)(v62 + 1712) >= 4u ? dword_10099860[dword_10099890[v63]] : dword_10099860[dword_100998C0[v63]];
        }
        else
        {
          v64 = dword_10099860[*(_DWORD *)(v3 + 48 * v61 + 1696)];
        }
      }
      else
      {
        v64 = *(_DWORD *)(v3 + 48 * v61 + 1696);
      }
      if ( v61 != v180 - 1 )
        break;
      if ( *(_DWORD *)(v62 + 1720) )
        v182 = dword_10099860[v64];
      else
        v182 = dword_100998F0[v64];
LABEL_97:
      v72 = v199;
      v73 = v200;
      v74 = v182;
      *(_DWORD *)(v62 + 1724) = v198;
      v75 = v201;
      *(_DWORD *)(v62 + 1728) = v72;
      v76 = *(_DWORD *)(v62 + 1692);
      *(_DWORD *)(v62 + 1696) = v74;
      *(_DWORD *)(v62 + 1732) = v73;
      *(_DWORD *)(v62 + 1736) = v75;
      v77 = *(int (__cdecl **)(int))(v3 + 12);
      v78 = *(_DWORD *)(v3 + 24);
      v184 = v76;
      v185 = 0;
      v79 = (char *)(v77(v78) - 1);
      v206 = *v79;
      v80 = v79[-v198 - 1];
      v190 = &v79[-v198 - 1];
      v179 = v80;
      v81 = *(_DWORD *)(v3 + 206244) & a2;
      v187 = v81;
      v82 = 16 * v74 + v81;
      v191 = v82;
      v83 = v184 + *(_DWORD *)(v3 + 4 * ((unsigned int)*(_WORD *)(v3 + 2 * v82 + 206252) >> 4) + 200348);
      v183 = (unsigned int)v79;
      v84 = (unsigned __int8)*(v79 - 1);
      v186 = v83;
      v85 = *(_DWORD *)(v3 + 206228);
      v192 = a2 & *(_DWORD *)(v3 + 206240);
      v86 = *(_DWORD *)(v3 + 206248) + 1536 * ((v192 << v85) + (v84 >> (8 - v85)));
      if ( v74 < 7 )
      {
        v188 = 0;
        v88 = v206 | 0x100;
        do
        {
          v89 = ((signed int)-((v88 >> 7) & 1) >> 4) & 0x7F ^ ((unsigned int)*(_WORD *)(v86 + 2 * (v88 >> 8)) >> 4);
          v90 = *(_DWORD *)(v3 + 4 * v89 + 200348) + v188;
          v88 *= 2;
          v188 += *(_DWORD *)(v3 + 4 * v89 + 200348);
        }
        while ( v88 < 0x10000 );
        v87 = v90;
      }
      else
      {
        v87 = sub_10054D80(v80, v206, v3 + 200348, v86);
      }
      v91 = v87 + v186;
      v186 = v91;
      if ( v91 < *(_DWORD *)(v62 + 1740) )
      {
        *(_DWORD *)(v62 + 1740) = v91;
        *(_DWORD *)(v62 + 1764) = v180;
        *(_DWORD *)(v62 + 1768) = -1;
        *(_DWORD *)(v62 + 1748) = 0;
        v185 = 1;
      }
      v92 = v184
          + *(_DWORD *)(v3 + 4 * ((*(_WORD *)(v3 + 2 * v191 + 206252) ^ 0x7F0u) >> 4) + 200348)
          + *(_DWORD *)(v3 + 4 * ((*(_WORD *)(v3 + 2 * v74 + 206636) ^ 0x7F0u) >> 4) + 200348);
      v197 = v184 + *(_DWORD *)(v3 + 4 * ((*(_WORD *)(v3 + 2 * v191 + 206252) ^ 0x7F0u) >> 4) + 200348);
      v193 = v92;
      if ( v179 == v206 && (*(_DWORD *)(v62 + 1764) >= v180 || *(_DWORD *)(v62 + 1768)) )
      {
        v93 = v92
            + *(_DWORD *)(v3 + 4 * ((unsigned int)*(_WORD *)(v3 + 2 * v191 + 206732) >> 4) + 200348)
            + *(_DWORD *)(v3 + 4 * ((unsigned int)*(_WORD *)(v3 + 2 * v74 + 206660) >> 4) + 200348);
        if ( v93 <= *(_DWORD *)(v62 + 1740) )
        {
          *(_DWORD *)(v62 + 1740) = v93;
          *(_DWORD *)(v62 + 1764) = v180;
          *(_DWORD *)(v62 + 1768) = 0;
          *(_DWORD *)(v62 + 1748) = 0;
          v185 = 1;
        }
      }
      v94 = *(_DWORD *)(v3 + 1688);
      v188 = v94;
      if ( 4095 - v180 < v94 )
      {
        v94 = 4095 - v180;
        v188 = 4095 - v180;
      }
      if ( v94 >= 2 )
      {
        v95 = *(_DWORD *)(v3 + 203056);
        v184 = v94;
        if ( v94 > v95 )
          v184 = v95;
        if ( !v185 && v179 != v206 )
        {
          v96 = v95 + 1;
          if ( v96 > v94 )
            v96 = v94;
          v97 = 1;
          if ( v96 > 1 )
          {
            v98 = (_BYTE *)(v183 + 1);
            do
            {
              if ( *v98 != v98[(_DWORD)&v190[-v183]] )
                break;
              ++v97;
              ++v98;
            }
            while ( v97 < v96 );
          }
          v207 = v97 - 1;
          if ( v97 - 1 >= 2 )
          {
            v99 = dword_10099860[v182];
            v100 = *(_DWORD *)(v3 + 206244) & (a2 + 1);
            v101 = v100 + 16 * dword_10099860[v182];
            v102 = v186
                 + *(_DWORD *)(v3 + 4 * ((*(_WORD *)(v3 + 2 * v99 + 206636) ^ 0x7F0u) >> 4) + 200348)
                 + *(_DWORD *)(v3 + 4 * ((*(_WORD *)(v3 + 2 * v101 + 206252) ^ 0x7F0u) >> 4) + 200348);
            v103 = v207 + v180 + 1;
            v104 = v181;
            v191 = v100 + 16 * dword_10099860[v182];
            if ( v181 < v103 )
            {
              v192 = v3 + 48 * v181 + 1692;
              v105 = v103 - v181;
              v181 = v207 + v180 + 1;
              v106 = (_DWORD *)(v3 + 48 * v104 + 1692);
              do
              {
                v106 += 12;
                --v105;
                *v106 = 0x40000000;
              }
              while ( v105 );
              v101 = v191;
            }
            v107 = v102
                 + *(_DWORD *)(v3 + 4 * (v207 + 272 * v100) + 227412)
                 + *(_DWORD *)(v3 + 4 * ((unsigned int)*(_WORD *)(v3 + 2 * v99 + 206660) >> 4) + 200348)
                 + *(_DWORD *)(v3 + 4 * ((*(_WORD *)(v3 + 2 * v101 + 206732) ^ 0x7F0u) >> 4) + 200348);
            if ( v107 < *(_DWORD *)(v3 + 48 * v103 + 1692) )
            {
              *(_DWORD *)(v3 + 48 * v103 + 1692) = v107;
              *(_DWORD *)(v3 + 48 * v103 + 1716) = v180 + 1;
              *(_DWORD *)(v3 + 48 * v103 + 1720) = 0;
              *(_DWORD *)(v3 + 48 * v103 + 1700) = 1;
              *(_DWORD *)(v3 + 48 * v103 + 1704) = 0;
            }
          }
        }
        v191 = 2;
        v208 = 0;
        do
        {
          v108 = *(_BYTE *)v183;
          v185 = v183 - *(&v198 + v208) - 1;
          if ( v108 == *(_BYTE *)v185 && *(_BYTE *)(v183 + 1) == *(_BYTE *)(v185 + 1) )
          {
            v109 = 2;
            if ( v184 > 2 )
            {
              v110 = (_BYTE *)(v183 + 2);
              do
              {
                if ( *v110 != v110[v185 - v183] )
                  break;
                ++v109;
                ++v110;
              }
              while ( v109 < v184 );
            }
            v111 = v109 + v180;
            if ( v181 < v109 + v180 )
            {
              v112 = v111 - v181;
              v113 = (_DWORD *)(v3 + 48 * v181 + 1692);
              v181 = v109 + v180;
              do
              {
                v113 += 12;
                --v112;
                *v113 = 0x40000000;
              }
              while ( v112 );
            }
            v114 = v109;
            v115 = sub_10054B00(v208, v182, v3, v187);
            v116 = v193 + v115;
            v194 = 272 * v187;
            v195 = v116;
            v186 = v3 + 4 * (v109 + 272 * v187) + 227412;
            v117 = (unsigned int *)(v3 + 48 * v111 + 1720);
            v118 = (_DWORD *)(v3 + 4 * (v109 + 272 * v187) + 227412);
            do
            {
              v119 = v116 + *v118;
              if ( v119 < *(v117 - 7) )
              {
                *(v117 - 7) = v119;
                *(v117 - 1) = v180;
                *v117 = v208;
                *(v117 - 5) = 0;
              }
              --v109;
              --v118;
              v117 -= 12;
            }
            while ( v109 >= 2 );
            if ( !v208 )
              v191 = v114 + 1;
            v120 = v114 + 1;
            v121 = v114 + 1 + *(_DWORD *)(v3 + 203056);
            v186 = v121;
            if ( v121 > v188 )
            {
              v121 = v188;
              v186 = v188;
            }
            if ( v120 < v121 )
            {
              v122 = (_BYTE *)(v120 + v183);
              do
              {
                if ( *v122 != v122[v185 - v183] )
                  break;
                ++v120;
                ++v122;
              }
              while ( v120 < v186 );
            }
            v190 = (char *)(-1 - v114 + v120);
            if ( (unsigned int)v190 >= 2 )
            {
              v123 = *(_BYTE *)(v114 + v183);
              v124 = *(_DWORD *)(v3 + 206228);
              v125 = (unsigned int)*(_BYTE *)(v114 + v183 - 1) >> (8 - v124);
              v186 = v114 + a2;
              v126 = *(_BYTE *)(v114 + v185);
              v192 = *(_DWORD *)(v3 + 206240) & (v114 + a2);
              v127 = sub_10054D80(v126, v123, v3 + 200348, *(_DWORD *)(v3 + 206248) + 1536 * ((v192 << v124) + v125));
              v128 = *(_DWORD *)(v3 + 206244);
              v129 = dword_10099860[dword_100998C0[v182]];
              v130 = v195
                   + *(_DWORD *)(v3 + 4 * (v114 + v194) + 227412)
                   + *(_DWORD *)(v3
                               + 4
                               * ((unsigned int)*(_WORD *)(v3 + 2 * (16 * dword_100998C0[v182] + (v128 & v186)) + 206252) >> 4)
                               + 200348)
                   + v127;
              v131 = v128 & (v114 + a2 + 1);
              v132 = *(_WORD *)(v3 + 2 * v129 + 206636);
              v192 = v131 + 16 * dword_10099860[dword_100998C0[v182]];
              v133 = v130
                   + *(_DWORD *)(v3 + 4 * ((v132 ^ 0x7F0u) >> 4) + 200348)
                   + *(_DWORD *)(v3 + 4 * ((*(_WORD *)(v3 + 2 * v192 + 206252) ^ 0x7F0u) >> 4) + 200348);
              v134 = (unsigned int)(&v190[v180 + 1] + v114);
              v135 = v181;
              v194 = v134;
              if ( v181 < v134 )
              {
                v195 = v3 + 48 * v181 + 1692;
                v136 = v134 - v181;
                v181 += v136;
                v137 = (_DWORD *)(v3 + 48 * v135 + 1692);
                do
                {
                  v137 += 12;
                  --v136;
                  *v137 = 0x40000000;
                }
                while ( v136 );
                v134 = v194;
              }
              v138 = v133
                   + *(_DWORD *)(v3 + 4 * (_DWORD)&v190[272 * v131] + 227412)
                   + *(_DWORD *)(v3 + 4 * ((unsigned int)*(_WORD *)(v3 + 2 * v129 + 206660) >> 4) + 200348)
                   + *(_DWORD *)(v3 + 4 * ((*(_WORD *)(v3 + 2 * v192 + 206732) ^ 0x7F0u) >> 4) + 200348);
              if ( v138 < *(_DWORD *)(v3 + 48 * v134 + 1692) )
              {
                *(_DWORD *)(v3 + 48 * v134 + 1692) = v138;
                *(_DWORD *)(v3 + 48 * v134 + 1716) = v114 + v180 + 1;
                *(_DWORD *)(v3 + 48 * v134 + 1708) = v180;
                *(_DWORD *)(v3 + 48 * v134 + 1720) = 0;
                *(_DWORD *)(v3 + 48 * v134 + 1700) = 1;
                *(_DWORD *)(v3 + 48 * v134 + 1704) = 1;
                *(_DWORD *)(v3 + 48 * v134 + 1712) = v208;
              }
            }
          }
          ++v208;
        }
        while ( v208 < 4 );
        v139 = j;
        if ( j > v184 )
        {
          v140 = 0;
          v139 = v184;
          if ( v184 > *(_DWORD *)(v3 + 200860) )
          {
            do
              v140 += 2;
            while ( v184 > *(_DWORD *)(v3 + 4 * v140 + 200860) );
          }
          *(_DWORD *)(v3 + 4 * v140 + 200860) = v184;
          v189 = (_DWORD *)(v140 + 2);
        }
        v141 = v191;
        if ( v139 >= v191 )
        {
          v197 += *(_DWORD *)(v3 + 4 * ((unsigned int)*(_WORD *)(v3 + 2 * v182 + 206636) >> 4) + 200348);
          if ( v181 < v139 + v180 )
          {
            v142 = v139 + v180 - v181;
            v143 = (_DWORD *)(v3 + 48 * v181 + 1692);
            v181 += v142;
            do
            {
              v143 += 12;
              --v142;
              *v143 = 0x40000000;
            }
            while ( v142 );
          }
          v144 = 0;
          v209 = 0;
          if ( v141 > *(_DWORD *)(v3 + 200860) )
          {
            do
              v144 += 2;
            while ( v141 > *(_DWORD *)(v3 + 4 * v144 + 200860) );
            v209 = v144;
          }
          v145 = *(_DWORD *)(v3 + 4 * v209 + 200864);
          v146 = (-((0x1FFFF - v145) >> 31) & 0xA) + 6;
          v147 = *(_DWORD *)(v3 + 4 * v209 + 200864) >> v146;
          v148 = v141 + 1;
          v186 = *(_DWORD *)(v3 + 4 * v209 + 200864);
          v185 = *(_BYTE *)(v147 + v3 + 198300) + 2 * v146;
          v187 = v3 + 4 * (v141 + 272 * v187) + 208908;
          v149 = (_DWORD *)(v3 + 48 * (v141 + v180) + 1720);
          while ( 1 )
          {
            v150 = v197 + *(_DWORD *)v187;
            v184 = (unsigned int)v149;
            v192 = v148;
            v151 = v148 - 3;
            if ( v148 - 1 >= 5 )
              v151 = 3;
            if ( v145 >= 0x80 )
              v152 = *(_DWORD *)(v3 + 4 * (v145 & 0xF) + 206156)
                   + *(_DWORD *)(v3 + 4 * (v185 + (v151 << 6)) + 203084)
                   + v150;
            else
              v152 = *(_DWORD *)(v3 + 4 * (v145 + (v151 << 7)) + 204108) + v150;
            v191 = v152;
            if ( v152 < *(v149 - 7) )
            {
              *(v149 - 7) = v152;
              *(v149 - 1) = v180;
              *v149 = v145 + 4;
              *(v149 - 5) = 0;
            }
            if ( v148 - 1 == *(_DWORD *)(v3 + 4 * v209 + 200860) )
            {
              v153 = v183 - v145;
              v154 = v148 + *(_DWORD *)(v3 + 203056);
              v155 = v153 - 1;
              v156 = v148;
              if ( v154 > v188 )
                v154 = v188;
              if ( v148 < v154 )
              {
                v157 = v183 - v155;
                v158 = (_BYTE *)(v155 + v148);
                for ( j = v183 - v155; v158[v157] == *v158; v157 = j )
                {
                  ++v156;
                  ++v158;
                  if ( v156 >= v154 )
                    break;
                }
                v149 = (_DWORD *)v184;
              }
              v190 = (char *)(-1 - (v148 - 1) + v156);
              if ( (unsigned int)v190 >= 2 )
              {
                v159 = *(_DWORD *)(v3 + 206244);
                v160 = *(_DWORD *)(v3 + 206228);
                v161 = a2 + v148 - 1;
                j = v161;
                v162 = v161 & v159;
                v163 = sub_10054D80(
                         *(_BYTE *)(v155 + v148 - 1),
                         *(_BYTE *)(v148 + v183 - 1),
                         v3 + 200348,
                         *(_DWORD *)(v3 + 206248)
                       + 1536
                       * (((v161 & *(_DWORD *)(v3 + 206240)) << *(_DWORD *)(v3 + 206228))
                        + ((unsigned int)*(_BYTE *)(v183 + v148 - 2) >> (8 - v160))));
                v164 = dword_10099860[dword_10099890[v182]];
                v148 = v192;
                v165 = v191
                     + *(_DWORD *)(v3
                                 + 4
                                 * ((unsigned int)*(_WORD *)(v3 + 2 * (v162 + 16 * dword_10099890[v182]) + 206252) >> 4)
                                 + 200348)
                     + v163;
                v166 = *(_DWORD *)(v3 + 206244) & (v162 + 1);
                v167 = *(_WORD *)(v3 + 2 * v164 + 206636);
                v194 = v166 + 16 * v164;
                v168 = v165
                     + *(_DWORD *)(v3 + 4 * ((v167 ^ 0x7F0u) >> 4) + 200348)
                     + *(_DWORD *)(v3 + 4 * ((*(_WORD *)(v3 + 2 * v194 + 206252) ^ 0x7F0u) >> 4) + 200348);
                v169 = (unsigned int)(&v190[v180] + v192);
                v170 = v181;
                v195 = v169;
                if ( v181 < v169 )
                {
                  j = v3 + 48 * v181 + 1692;
                  v171 = v169 - v181;
                  v181 += v171;
                  v172 = (_DWORD *)(v3 + 48 * v170 + 1692);
                  do
                  {
                    v172 += 12;
                    --v171;
                    *v172 = 0x40000000;
                  }
                  while ( v171 );
                  v169 = v195;
                }
                v173 = *(_DWORD *)(v3 + 4 * ((unsigned int)*(_WORD *)(v3 + 2 * v164 + 206660) >> 4) + 200348)
                     + *(_DWORD *)(v3 + 4 * ((*(_WORD *)(v3 + 2 * v194 + 206732) ^ 0x7F0u) >> 4) + 200348);
                v149 = (_DWORD *)v184;
                v174 = v168 + *(_DWORD *)(v3 + 4 * (_DWORD)&v190[272 * v166] + 227412) + v173;
                if ( v174 < *(_DWORD *)(v3 + 48 * v169 + 1692) )
                {
                  *(_DWORD *)(v3 + 48 * v169 + 1692) = v174;
                  *(_DWORD *)(v3 + 48 * v169 + 1708) = v180;
                  v175 = v186;
                  *(_DWORD *)(v3 + 48 * v169 + 1716) = v148 + v180;
                  *(_DWORD *)(v3 + 48 * v169 + 1720) = 0;
                  *(_DWORD *)(v3 + 48 * v169 + 1700) = 1;
                  *(_DWORD *)(v3 + 48 * v169 + 1704) = 1;
                  *(_DWORD *)(v3 + 48 * v169 + 1712) = v175 + 4;
                }
              }
              v176 = v209 + 2;
              v209 = v176;
              if ( (_DWORD *)v176 == v189 )
                break;
              v145 = *(_DWORD *)(v3 + 4 * v176 + 200864);
              v186 = v145;
              if ( v145 >= 0x80 )
              {
                v177 = (-((0x1FFFF - v145) >> 31) & 0xA) + 6;
                v185 = *(_BYTE *)((v145 >> v177) + v3 + 198300) + 2 * v177;
              }
            }
            v187 += 4;
            v149 += 12;
            ++v148;
          }
        }
      }
      if ( ++v180 == v181 )
        return sub_10054A30(v180, v3, a3);
    }
    if ( v60 && *(_DWORD *)(v62 + 1704) )
    {
      v65 = *(_DWORD *)(v62 + 1712);
      v61 = *(_DWORD *)(v62 + 1708);
      v66 = dword_100998C0[v64];
      v205 = *(_DWORD *)(v62 + 1712);
    }
    else
    {
      v205 = *(_DWORD *)(v62 + 1720);
      if ( v205 < 4 )
      {
        v182 = dword_100998C0[v64];
        v65 = v205;
        goto LABEL_92;
      }
      v66 = dword_10099890[v64];
      v65 = *(_DWORD *)(v62 + 1720);
    }
    v182 = v66;
LABEL_92:
    v67 = 6 * v61;
    v68 = v3 + 8 * v67 + 1692;
    if ( v65 >= 4 )
    {
      v70 = *(_DWORD *)(v3 + 8 * v67 + 1728);
      v198 = v65 - 4;
      v199 = *(_DWORD *)(v68 + 32);
      v71 = *(_DWORD *)(v68 + 40);
      v200 = v70;
      v201 = v71;
    }
    else
    {
      v198 = *(_DWORD *)(v68 + 4 * v65 + 32);
      v69 = 1;
      if ( v65 < 1 || (v69 = v205 + 1, qmemcpy(&v199, (const void *)(v68 + 32), 4 * v65), v205 + 1 < 4) )
        qmemcpy(&v198 + v69, (const void *)(v68 + 4 * v69 + 32), 4 * (4 - v69));
    }
    goto LABEL_97;
  }
  *a3 = *(_DWORD *)(v3 + 4 * v182 + 200856) + 4;
  v24 = v23 - 1;
  if ( v23 != 1 )
  {
    *(_DWORD *)(v3 + 203060) += v24;
    (*(void (__cdecl **)(_DWORD, int))(v3 + 20))(*(_DWORD *)(v3 + 24), v24);
  }
  return v183;
}
// 10099860: using guessed type int dword_10099860[];
// 10099890: using guessed type int dword_10099890[];
// 100998C0: using guessed type int dword_100998C0[];
// 100998F0: using guessed type int dword_100998F0[];
// 10055DA0: using guessed type int var_10[4];

//----- (10057080) --------------------------------------------------------
int __usercall sub_10057080@<eax>(int a1@<eax>, int a2@<edi>, int a3@<esi>)
{
  int v3; // ebx@1
  int result; // eax@1

  v3 = a1;
  sub_10055960(a1, a3, a2, *(_DWORD *)(a1 + 18436), 1088 * a2 + a1 + 1028);
  result = *(_DWORD *)(v3 + 18436);
  *(_DWORD *)(v3 + 4 * a2 + 18440) = result;
  return result;
}

//----- (100570C0) --------------------------------------------------------
int __usercall sub_100570C0@<eax>(unsigned int *a1@<eax>, _WORD *a2@<edi>, int a3)
{
  unsigned int v3; // ecx@1
  int v4; // esi@1
  unsigned int v5; // edx@1
  int v6; // eax@1
  int result; // eax@4

  v3 = *a2;
  v4 = (int)a1;
  v5 = *a1;
  v6 = v3 * (*a1 >> 11);
  if ( a3 )
  {
    *(_QWORD *)(v4 + 8) += (unsigned int)v6;
    *(_DWORD *)v4 = v5 - v6;
    v3 -= v3 >> 5;
  }
  else
  {
    *(_DWORD *)v4 = v6;
    LOWORD(v3) = ((2048 - v3) >> 5) + v3;
  }
  *a2 = v3;
  result = *(_DWORD *)v4;
  if ( *(_DWORD *)v4 < 0x1000000u )
  {
    *(_DWORD *)v4 = result << 8;
    result = sub_10055AE0(v4);
  }
  return result;
}

//----- (10057120) --------------------------------------------------------
unsigned int __usercall sub_10057120@<eax>(int a1@<eax>, int a2@<ecx>, unsigned int a3@<ebx>)
{
  int v3; // edi@1
  int v4; // esi@1
  unsigned int result; // eax@2

  v3 = a1;
  v4 = a2;
  do
  {
    *(_DWORD *)v4 >>= 1;
    result = *(_DWORD *)v4;
    *(_QWORD *)(v4 + 8) += *(_DWORD *)v4 & -((a3 >> --v3) & 1);
    if ( result < 0x1000000 )
    {
      *(_DWORD *)v4 = result << 8;
      result = sub_10055AE0(v4);
    }
  }
  while ( v3 );
  return result;
}

//----- (100571D0) --------------------------------------------------------
int __usercall sub_100571D0@<eax>(int result@<eax>, int a2@<ecx>, int a3, unsigned int a4)
{
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // edx@3
  unsigned int v7; // ecx@3
  int v8; // eax@3
  int v9; // edi@3
  int v10; // [sp+Ch] [bp-4h]@2

  v4 = a2;
  v5 = 1;
  if ( result > 0 )
  {
    v10 = result;
    do
    {
      v6 = *(_DWORD *)v4;
      v7 = *(_WORD *)(a3 + 2 * v5);
      v8 = v7 * (*(_DWORD *)v4 >> 11);
      v9 = a4 & 1;
      if ( a4 & 1 )
      {
        *(_QWORD *)(v4 + 8) += (unsigned int)v8;
        *(_DWORD *)v4 = v6 - v8;
        v7 -= v7 >> 5;
      }
      else
      {
        *(_DWORD *)v4 = v8;
        LOWORD(v7) = ((2048 - v7) >> 5) + v7;
      }
      *(_WORD *)(a3 + 2 * v5) = v7;
      result = *(_DWORD *)v4;
      if ( *(_DWORD *)v4 < 0x1000000u )
      {
        *(_DWORD *)v4 = result << 8;
        result = sub_10055AE0(v4);
      }
      a4 >>= 1;
      v5 = v9 | 2 * v5;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (10057260) --------------------------------------------------------
int __usercall sub_10057260@<eax>(int result@<eax>, int a2, int a3, unsigned int a4)
{
  int v4; // ebp@1
  int v5; // esi@1
  int i; // ebx@1
  int v7; // edx@2
  unsigned int v8; // ecx@2
  int v9; // eax@2

  v4 = a3;
  v5 = result;
  for ( i = 1; v4; i = (a4 >> v4) & 1 | 2 * i )
  {
    v7 = *(_DWORD *)v5;
    --v4;
    v8 = *(_WORD *)(a2 + 2 * i);
    v9 = v8 * (*(_DWORD *)v5 >> 11);
    if ( (a4 >> v4) & 1 )
    {
      *(_QWORD *)(v5 + 8) += (unsigned int)v9;
      *(_DWORD *)v5 = v7 - v9;
      v8 -= v8 >> 5;
    }
    else
    {
      *(_DWORD *)v5 = v9;
      LOWORD(v8) = ((2048 - v8) >> 5) + v8;
    }
    *(_WORD *)(a2 + 2 * i) = v8;
    result = *(_DWORD *)v5;
    if ( *(_DWORD *)v5 < 0x1000000u )
    {
      *(_DWORD *)v5 = result << 8;
      result = sub_10055AE0(v5);
    }
  }
  return result;
}

//----- (100572E0) --------------------------------------------------------
int __usercall sub_100572E0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4)
{
  signed int v4; // ebp@1
  int v5; // esi@1
  unsigned int v6; // ebx@1
  int v7; // edi@2
  int v8; // ecx@2
  int v9; // edx@2
  unsigned int v10; // ecx@2
  _WORD *v11; // edx@2
  int v12; // eax@2
  int result; // eax@5

  v4 = 256;
  v5 = a2;
  v6 = a1 | 0x100;
  do
  {
    v7 = *(_DWORD *)v5;
    v8 = 2 * a4 & v4;
    a4 *= 2;
    v9 = v4 + v8 + (v6 >> 8);
    v10 = *(_WORD *)(a3 + 2 * v9);
    v11 = (_WORD *)(a3 + 2 * v9);
    v12 = v10 * (*(_DWORD *)v5 >> 11);
    if ( (v6 & 0x80u) != 0 )
    {
      *(_QWORD *)(v5 + 8) += (unsigned int)v12;
      *(_DWORD *)v5 = v7 - v12;
      v10 -= v10 >> 5;
    }
    else
    {
      *(_DWORD *)v5 = v12;
      LOWORD(v10) = ((2048 - v10) >> 5) + v10;
    }
    *v11 = v10;
    result = *(_DWORD *)v5;
    if ( *(_DWORD *)v5 < 0x1000000u )
    {
      *(_DWORD *)v5 = result << 8;
      result = sub_10055AE0(v5);
    }
    v6 *= 2;
    v4 &= ~(a4 ^ v6);
  }
  while ( v6 < 0x10000 );
  return result;
}

//----- (10057380) --------------------------------------------------------
int __usercall sub_10057380@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // esi@1
  unsigned int v4; // ebx@1
  int v5; // edi@2
  _WORD *v6; // ebp@2
  unsigned int v7; // ecx@2
  int v8; // eax@2
  int result; // eax@5

  v3 = a2;
  v4 = a1 | 0x100;
  do
  {
    v5 = *(_DWORD *)v3;
    v6 = (_WORD *)(a3 + 2 * (v4 >> 8));
    v7 = *v6;
    v8 = v7 * (*(_DWORD *)v3 >> 11);
    if ( (v4 & 0x80u) != 0 )
    {
      *(_QWORD *)(v3 + 8) += (unsigned int)v8;
      *(_DWORD *)v3 = v5 - v8;
      v7 -= v7 >> 5;
    }
    else
    {
      *(_DWORD *)v3 = v8;
      LOWORD(v7) = ((2048 - v7) >> 5) + v7;
    }
    *v6 = v7;
    result = *(_DWORD *)v3;
    if ( *(_DWORD *)v3 < 0x1000000u )
    {
      *(_DWORD *)v3 = result << 8;
      result = sub_10055AE0(v3);
    }
    v4 *= 2;
  }
  while ( v4 < 0x10000 );
  return result;
}

//----- (10057400) --------------------------------------------------------
int __usercall sub_10057400@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // ebx@1
  unsigned int v3; // ebp@3
  int result; // eax@3
  unsigned int v5; // edi@3
  unsigned int v6; // ebp@5
  unsigned int v7; // edi@5

  v2 = a1;
  if ( !*(_DWORD *)(a1 + 244900) )
  {
    sub_10055370(a2, a1);
    sub_10055550(v2);
  }
  v3 = 1 << *(_DWORD *)(v2 + 206236);
  result = *(_DWORD *)(v2 + 203056) - 1;
  v5 = 0;
  *(_DWORD *)(v2 + 244828) = result;
  *(_DWORD *)(v2 + 226324) = result;
  if ( v3 )
  {
    do
      result = sub_10057080(v2 + 207888, v5++, v2 + 200348);
    while ( v5 < v3 );
  }
  v6 = 1 << *(_DWORD *)(v2 + 206236);
  v7 = 0;
  if ( v6 )
  {
    do
      result = sub_10057080(v2 + 226392, v7++, v2 + 200348);
    while ( v7 < v6 );
  }
  return result;
}

//----- (100574A0) --------------------------------------------------------
int __usercall sub_100574A0@<eax>(int a1@<eax>, _WORD *a2@<edx>, unsigned int *a3@<ecx>, unsigned int a4)
{
  _WORD *v4; // edi@1
  int v5; // ebx@1
  unsigned int v6; // eax@1
  int v7; // esi@1
  int result; // eax@4
  unsigned int v9; // edx@5
  int v10; // ecx@5
  unsigned __int8 v11; // cf@5
  unsigned int v12; // eax@7
  unsigned int v13; // edx@7
  int v14; // ecx@11

  v4 = a2;
  v5 = a1;
  v6 = *a2;
  v7 = (int)a3;
  if ( a4 >= 8 )
  {
    v9 = *a3;
    v10 = v6 * (*a3 >> 11);
    v11 = __CFADD__(v10, *(_DWORD *)(v7 + 8));
    *(_DWORD *)(v7 + 8) += v10;
    *(_DWORD *)(v7 + 12) += v11;
    *(_DWORD *)v7 = v9 - v10;
    *v4 = v6 - (v6 >> 5);
    if ( *(_DWORD *)v7 < 0x1000000u )
    {
      *(_DWORD *)v7 <<= 8;
      sub_10055AE0(v7);
    }
    v12 = v4[1];
    v13 = *(_DWORD *)v7;
    if ( a4 >= 0x10 )
    {
      v14 = v12 * (v13 >> 11);
      *(_QWORD *)(v7 + 8) += (unsigned int)v14;
      *(_DWORD *)v7 = v13 - v14;
      v4[1] = v12 - (v12 >> 5);
      if ( *(_DWORD *)v7 < 0x1000000u )
      {
        *(_DWORD *)v7 <<= 8;
        sub_10055AE0(v7);
      }
      result = sub_10057260(v7, (int)(v4 + 258), 8, a4 - 16);
    }
    else
    {
      *(_DWORD *)v7 = v12 * (v13 >> 11);
      v4[1] = v12 + ((2048 - v12) >> 5);
      if ( *(_DWORD *)v7 < 0x1000000u )
      {
        *(_DWORD *)v7 <<= 8;
        sub_10055AE0(v7);
      }
      result = sub_10057260(v7, (int)&v4[8 * v5 + 130], 3, a4 - 8);
    }
  }
  else
  {
    *a3 = v6 * (*a3 >> 11);
    *a2 = v6 + ((2048 - v6) >> 5);
    if ( *a3 < 0x1000000 )
    {
      *a3 <<= 8;
      sub_10055AE0((int)a3);
    }
    result = sub_10057260(v7, (int)&v4[8 * v5 + 2], 3, a4);
  }
  return result;
}

//----- (10057620) --------------------------------------------------------
int __usercall sub_10057620@<eax>(int a1@<esi>)
{
  int result; // eax@3

  sub_10051270(a1 + 328);
  sub_10051270(a1 + 76);
  off_100AD04C(&off_100AD048, *(_DWORD *)(a1 + 280));
  *(_DWORD *)(a1 + 280) = 0;
  off_100AD04C(&off_100AD048, *(_DWORD *)(a1 + 444));
  *(_DWORD *)(a1 + 444) = 0;
  if ( !*(_DWORD *)(a1 + 488) )
  {
    off_100AD04C(&off_100AD048, *(_DWORD *)(a1 + 460));
    *(_DWORD *)(a1 + 460) = 0;
  }
  off_100AD04C(&off_100AD048, *(_DWORD *)(a1 + 206248));
  off_100AD04C(&off_100AD048, *(_DWORD *)(a1 + 245016));
  *(_DWORD *)(a1 + 206248) = 0;
  *(_DWORD *)(a1 + 245016) = 0;
  result = off_100AD04C(&off_100AD048, *(_DWORD *)(a1 + 244936));
  *(_DWORD *)(a1 + 244936) = 0;
  return result;
}
// 100AD048: using guessed type int (__cdecl *off_100AD048)(_DWORD, _DWORD);
// 100AD04C: using guessed type int (__cdecl *off_100AD04C)(_DWORD, _DWORD);

//----- (100576E0) --------------------------------------------------------
int __cdecl sub_100576E0(int a1, int a2)
{
  int v2; // edi@1
  int v3; // edx@1
  int v4; // ebp@1
  _WORD *v5; // esi@1
  unsigned int v6; // eax@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // eax@3
  bool v10; // zf@5
  int v11; // ebx@5
  int v12; // esi@5

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 244904);
  v4 = a1 + 244904;
  v5 = (_WORD *)(a1 + 2 * (a2 + 16 * *(_DWORD *)(a1 + 203080)) + 206252);
  v6 = *v5;
  v7 = v6 * (*(_DWORD *)(a1 + 244904) >> 11);
  *(_QWORD *)(v4 + 8) = (unsigned int)v7 + *(_QWORD *)(a1 + 244912);
  *(_DWORD *)v4 = v3 - v7;
  *v5 = v6 - (v6 >> 5);
  if ( *(_DWORD *)(a1 + 244904) < 0x1000000u )
  {
    *(_DWORD *)v4 = *(_DWORD *)(a1 + 244904) << 8;
    sub_10055AE0(v4);
  }
  v8 = *(_DWORD *)(a1 + 203080);
  v9 = *(_WORD *)(a1 + 2 * v8 + 206636);
  *(_DWORD *)v4 = v9 * (*(_DWORD *)v4 >> 11);
  *(_WORD *)(a1 + 2 * v8 + 206636) = v9 + ((unsigned int)(2048 - v9) >> 5);
  if ( *(_DWORD *)v4 < 0x1000000u )
  {
    *(_DWORD *)v4 <<= 8;
    sub_10055AE0(v4);
  }
  v10 = *(_DWORD *)(a1 + 244900) == 0;
  *(_DWORD *)(a1 + 203080) = dword_10099890[*(_DWORD *)(a1 + 203080)];
  v11 = a1 + 207888;
  v12 = v10;
  sub_100574A0(a2, (_WORD *)(a1 + 207888), (unsigned int *)v4, 0);
  if ( v12 )
  {
    v10 = (*(_DWORD *)(v11 + 4 * a2 + 18440))-- == 1;
    if ( v10 )
    {
      sub_10057080(v11, a2, a1 + 200348);
      v2 = a1;
    }
  }
  sub_10057260(v4, v2 + 207116, 6, 0x3Fu);
  sub_10057120(26, v4, 0x3FFFFFFu);
  return sub_100571D0(4, v4, v2 + 207856, 0xFu);
}
// 10099890: using guessed type int dword_10099890[];

//----- (10057850) --------------------------------------------------------
int __usercall sub_10057850@<eax>(int a1@<ebx>, int a2)
{
  bool v2; // zf@1
  signed int v3; // edi@3
  int v4; // edi@6
  unsigned __int8 v5; // cf@8
  int result; // eax@9

  v2 = *(_DWORD *)(a1 + 244960) == 0;
  *(_DWORD *)(a1 + 244980) = 1;
  if ( !v2 )
    sub_100576E0(a1, a2 & *(_DWORD *)(a1 + 206244));
  v3 = 5;
  do
  {
    sub_10055AE0(a1 + 244904);
    --v3;
  }
  while ( v3 );
  if ( !*(_DWORD *)(a1 + 244952) )
  {
    v4 = *(_DWORD *)(a1 + 244928) - *(_DWORD *)(a1 + 244936);
    if ( v4 != (**(int (__cdecl ***)(_DWORD, _DWORD, _DWORD))(a1 + 244940))(
                 *(_DWORD *)(a1 + 244940),
                 *(_DWORD *)(a1 + 244936),
                 v4) )
      *(_DWORD *)(a1 + 244952) = 9;
    v5 = __CFADD__(v4, *(_DWORD *)(a1 + 244944));
    *(_DWORD *)(a1 + 244944) += v4;
    *(_DWORD *)(a1 + 244928) = *(_DWORD *)(a1 + 244936);
    *(_DWORD *)(a1 + 244948) += v5;
  }
  result = *(_DWORD *)(a1 + 244988);
  if ( !result )
  {
    if ( *(_DWORD *)(a1 + 244952) )
      *(_DWORD *)(a1 + 244988) = 9;
    if ( *(_DWORD *)(a1 + 516) )
      *(_DWORD *)(a1 + 244988) = 8;
    result = *(_DWORD *)(a1 + 244988);
    if ( result )
      *(_DWORD *)(a1 + 244980) = 1;
  }
  return result;
}

//----- (10057910) --------------------------------------------------------
int __cdecl sub_10057910(int a1)
{
  int v1; // ebp@1
  int v2; // eax@1
  void (__cdecl *v3)(_DWORD); // ecx@2
  int result; // eax@3
  int v5; // edi@11
  bool v6; // zf@11
  _WORD *v7; // ecx@13
  int v8; // eax@13
  _DWORD *v9; // esi@13
  unsigned int v10; // eax@13
  int v11; // eax@15
  int v12; // ST08_4@15
  unsigned __int8 v13; // al@15
  signed int v14; // eax@20
  int v15; // edi@22
  int v16; // ecx@24
  int v17; // eax@24
  _DWORD *v18; // esi@24
  unsigned int v19; // eax@24
  _BYTE *v20; // eax@26
  int v21; // ebx@26
  int v22; // edi@26
  int v23; // ecx@26
  int v24; // edx@26
  int v25; // edx@30
  _WORD *v26; // esi@30
  unsigned int v27; // eax@30
  int v28; // ecx@30
  unsigned int v29; // eax@30
  int v30; // edx@33
  unsigned int v31; // eax@33
  _WORD *v32; // esi@33
  int v33; // edx@33
  int v34; // ecx@33
  unsigned int v35; // eax@33
  int v36; // edx@36
  int v37; // eax@36
  unsigned int v38; // eax@36
  _WORD *v39; // esi@39
  unsigned int v40; // eax@39
  int v41; // edx@39
  int v42; // ecx@39
  unsigned int v43; // eax@39
  int v44; // edx@42
  int v45; // eax@42
  unsigned int v46; // eax@42
  int v47; // edx@44
  _WORD *v48; // esi@44
  unsigned int v49; // eax@44
  int v50; // ecx@44
  unsigned int v51; // eax@44
  int v52; // ecx@49
  int v53; // ecx@56
  int v54; // eax@56
  unsigned int v55; // eax@56
  unsigned int v56; // eax@58
  unsigned int v57; // eax@61
  unsigned int v58; // esi@62
  unsigned int v59; // ecx@63
  int v60; // eax@65
  int v61; // edx@68
  int v62; // ecx@68
  unsigned int v63; // edi@68
  int v64; // ecx@71
  int v65; // edx@71
  int v66; // eax@71
  unsigned int v67; // ecx@71
  int v68; // ecx@72
  int v69; // eax@72
  unsigned __int8 v70; // cf@80
  unsigned int v71; // [sp+4h] [bp-14h]@20
  int v72; // [sp+8h] [bp-10h]@11
  unsigned int v73; // [sp+Ch] [bp-Ch]@22
  int v74; // [sp+10h] [bp-8h]@11
  int v75; // [sp+14h] [bp-4h]@39

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 245000);
  if ( v2 )
  {
    v3 = *(void (__cdecl **)(_DWORD))a1;
    *(_DWORD *)(a1 + 464) = v2;
    v3(*(_DWORD *)(v1 + 24));
    *(_DWORD *)(v1 + 245000) = 0;
  }
  result = *(_DWORD *)(v1 + 244988);
  if ( *(_DWORD *)(v1 + 244980) || result )
    return result;
  if ( *(_DWORD *)(v1 + 244952) )
    *(_DWORD *)(v1 + 244988) = 9;
  if ( *(_DWORD *)(v1 + 516) )
    *(_DWORD *)(v1 + 244988) = 8;
  result = *(_DWORD *)(v1 + 244988);
  if ( result )
  {
    *(_DWORD *)(v1 + 244980) = 1;
    return result;
  }
  v5 = *(_DWORD *)(v1 + 244968);
  v6 = *(_QWORD *)(v1 + 244968) == 0i64;
  v72 = v5;
  v74 = v5;
  if ( v6 )
  {
    if ( !(*(int (__cdecl **)(_DWORD))(v1 + 8))(*(_DWORD *)(v1 + 24)) )
      return sub_10057850(v1, v5);
    sub_10054BE0(v1, &a1);
    v7 = (_WORD *)(32 * *(_DWORD *)(v1 + 203080) + v1 + 206252);
    v8 = *v7;
    v9 = (_DWORD *)(v1 + 244904);
    *(_DWORD *)(v1 + 244904) = v8 * (*(_DWORD *)(v1 + 244904) >> 11);
    *v7 = v8 + ((unsigned int)(2048 - v8) >> 5);
    v10 = *(_DWORD *)(v1 + 244904);
    if ( v10 < 0x1000000 )
    {
      *v9 = *(_DWORD *)(v1 + 244904) << 8;
      sub_10055AE0((int)v9);
    }
    v11 = *(_DWORD *)(v1 + 24);
    v12 = -*(_DWORD *)(v1 + 203060);
    *(_DWORD *)(v1 + 203080) = dword_10099860[*(_DWORD *)(v1 + 203080)];
    v13 = (*(int (__cdecl **)(int, int))(v1 + 4))(v11, v12);
    sub_10057380(v13, v1 + 244904, *(_DWORD *)(v1 + 206248));
    --*(_DWORD *)(v1 + 203060);
    v72 = ++v5;
  }
  if ( !(*(int (__cdecl **)(_DWORD))(v1 + 8))(*(_DWORD *)(v1 + 24)) )
  {
LABEL_82:
    *(_QWORD *)(v1 + 244968) += (unsigned int)(v5 - v74);
    return sub_10057850(v1, v5);
  }
  while ( 1 )
  {
    v14 = *(_DWORD *)(v1 + 244900) ? sub_100555E0(v1, &v71) : sub_10055DA0(v1, v5, &v71);
    v15 = v72 & *(_DWORD *)(v1 + 206244);
    v73 = v14;
    a1 = v15;
    if ( v14 != 1 || v71 != -1 )
    {
      v25 = *(_DWORD *)(v1 + 244904);
      v26 = (_WORD *)(v1 + 2 * (v15 + 16 * *(_DWORD *)(v1 + 203080)) + 206252);
      v27 = *v26;
      v28 = v27 * (*(_DWORD *)(v1 + 244904) >> 11);
      *(_QWORD *)(v1 + 244912) += (unsigned int)v28;
      *(_DWORD *)(v1 + 244904) = v25 - v28;
      *v26 = v27 - (v27 >> 5);
      v29 = *(_DWORD *)(v1 + 244904);
      if ( v29 < 0x1000000 )
      {
        *(_DWORD *)(v1 + 244904) <<= 8;
        sub_10055AE0(v1 + 244904);
      }
      if ( v71 >= 4 )
      {
        v53 = *(_DWORD *)(v1 + 203080);
        v54 = *(_WORD *)(v1 + 2 * v53 + 206636);
        *(_DWORD *)(v1 + 244904) = v54 * (*(_DWORD *)(v1 + 244904) >> 11);
        *(_WORD *)(v1 + 2 * v53 + 206636) = v54 + ((unsigned int)(2048 - v54) >> 5);
        v55 = *(_DWORD *)(v1 + 244904);
        if ( v55 < 0x1000000 )
        {
          *(_DWORD *)(v1 + 244904) <<= 8;
          sub_10055AE0(v1 + 244904);
        }
        v56 = v73;
        v6 = *(_DWORD *)(v1 + 244900) == 0;
        *(_DWORD *)(v1 + 203080) = dword_10099890[*(_DWORD *)(v1 + 203080)];
        a1 = v6;
        sub_100574A0(v15, (_WORD *)(v1 + 207888), (unsigned int *)(v1 + 244904), v56 - 2);
        if ( a1 )
        {
          v6 = (*(_DWORD *)(v1 + 4 * v15 + 226328))-- == 1;
          if ( v6 )
            sub_10057080(v1 + 207888, v15, v1 + 200348);
        }
        v57 = v71 - 4;
        v71 = v57;
        if ( v57 >= 0x80 )
        {
          v59 = (-((0x1FFFF - v57) >> 31) & 0xA) + 6;
          v58 = *(_BYTE *)((v57 >> v59) + v1 + 198300) + 2 * v59;
        }
        else
        {
          v58 = *(_BYTE *)(v57 + v1 + 198300);
        }
        if ( v73 >= 5 )
          v60 = 3;
        else
          v60 = v73 - 2;
        sub_10057260(v1 + 244904, (v60 << 7) + v1 + 207116, 6, v58);
        if ( v58 >= 4 )
        {
          v61 = (v58 & 1 | 2) << ((v58 >> 1) - 1);
          v62 = v1 + 244904;
          v63 = v71 - v61;
          if ( v58 >= 0xE )
          {
            sub_10057120((v58 >> 1) - 5, v62, v63 >> 4);
            sub_100571D0(4, v1 + 244904, v1 + 207856, v63 & 0xF);
            ++*(_DWORD *)(v1 + 206220);
          }
          else
          {
            sub_100571D0((v58 >> 1) - 1, v62, v1 + 2 * (v61 - v58) + 207626, v63);
          }
        }
        v64 = *(_DWORD *)(v1 + 203072);
        v65 = *(_DWORD *)(v1 + 203068);
        v66 = *(_DWORD *)(v1 + 203064);
        ++*(_DWORD *)(v1 + 244976);
        *(_DWORD *)(v1 + 203076) = v64;
        v67 = v71;
        *(_DWORD *)(v1 + 203072) = v65;
        *(_DWORD *)(v1 + 203068) = v66;
        *(_DWORD *)(v1 + 203064) = v67;
      }
      else
      {
        v30 = *(_DWORD *)(v1 + 203080);
        v31 = *(_WORD *)(v1 + 2 * v30 + 206636);
        v32 = (_WORD *)(v1 + 2 * v30 + 206636);
        v33 = *(_DWORD *)(v1 + 244904);
        v34 = v31 * (*(_DWORD *)(v1 + 244904) >> 11);
        *(_QWORD *)(v1 + 244912) += (unsigned int)v34;
        *(_DWORD *)(v1 + 244904) = v33 - v34;
        *v32 = v31 - (v31 >> 5);
        v35 = *(_DWORD *)(v1 + 244904);
        if ( v35 < 0x1000000 )
        {
          *(_DWORD *)(v1 + 244904) <<= 8;
          sub_10055AE0(v1 + 244904);
        }
        if ( v71 )
        {
          v39 = (_WORD *)(v1 + 2 * *(_DWORD *)(v1 + 203080) + 206660);
          v40 = *v39;
          v75 = *(_DWORD *)(v1 + 4 * v71 + 203064);
          v41 = *(_DWORD *)(v1 + 244904);
          v42 = v40 * (*(_DWORD *)(v1 + 244904) >> 11);
          *(_QWORD *)(v1 + 244912) += (unsigned int)v42;
          *(_DWORD *)(v1 + 244904) = v41 - v42;
          *v39 = v40 - (v40 >> 5);
          v43 = *(_DWORD *)(v1 + 244904);
          if ( v43 < 0x1000000 )
          {
            *(_DWORD *)(v1 + 244904) <<= 8;
            sub_10055AE0(v1 + 244904);
          }
          if ( v71 == 1 )
          {
            v44 = *(_DWORD *)(v1 + 203080);
            v45 = *(_WORD *)(v1 + 2 * v44 + 206684);
            *(_DWORD *)(v1 + 244904) = v45 * (*(_DWORD *)(v1 + 244904) >> 11);
            *(_WORD *)(v1 + 2 * v44 + 206684) = v45 + ((unsigned int)(2048 - v45) >> 5);
            v46 = *(_DWORD *)(v1 + 244904);
            if ( v46 < 0x1000000 )
            {
              *(_DWORD *)(v1 + 244904) <<= 8;
              sub_10055AE0(v1 + 244904);
            }
          }
          else
          {
            v47 = *(_DWORD *)(v1 + 244904);
            v48 = (_WORD *)(v1 + 2 * *(_DWORD *)(v1 + 203080) + 206684);
            v49 = *v48;
            v50 = v49 * (*(_DWORD *)(v1 + 244904) >> 11);
            *(_QWORD *)(v1 + 244912) += (unsigned int)v50;
            *(_DWORD *)(v1 + 244904) = v47 - v50;
            *v48 = v49 - (v49 >> 5);
            v51 = *(_DWORD *)(v1 + 244904);
            if ( v51 < 0x1000000 )
            {
              *(_DWORD *)(v1 + 244904) <<= 8;
              sub_10055AE0(v1 + 244904);
            }
            sub_100570C0((unsigned int *)(v1 + 244904), (_WORD *)(v1 + 2 * *(_DWORD *)(v1 + 203080) + 206708), v71 - 2);
            if ( v71 == 3 )
              *(_DWORD *)(v1 + 203076) = *(_DWORD *)(v1 + 203072);
            v15 = a1;
            *(_DWORD *)(v1 + 203072) = *(_DWORD *)(v1 + 203068);
          }
          v52 = v75;
          *(_DWORD *)(v1 + 203068) = *(_DWORD *)(v1 + 203064);
          *(_DWORD *)(v1 + 203064) = v52;
        }
        else
        {
          v36 = *(_DWORD *)(v1 + 203080);
          v37 = *(_WORD *)(v1 + 2 * v36 + 206660);
          *(_DWORD *)(v1 + 244904) = v37 * (*(_DWORD *)(v1 + 244904) >> 11);
          *(_WORD *)(v1 + 2 * v36 + 206660) = v37 + ((unsigned int)(2048 - v37) >> 5);
          v38 = *(_DWORD *)(v1 + 244904);
          if ( v38 < 0x1000000 )
          {
            *(_DWORD *)(v1 + 244904) <<= 8;
            sub_10055AE0(v1 + 244904);
          }
          sub_100570C0(
            (unsigned int *)(v1 + 244904),
            (_WORD *)(v1 + 2 * (v15 + 16 * *(_DWORD *)(v1 + 203080)) + 206732),
            v73 != 1);
          v15 = a1;
        }
        if ( v73 == 1 )
        {
          *(_DWORD *)(v1 + 203080) = dword_100998F0[*(_DWORD *)(v1 + 203080)];
        }
        else
        {
          a1 = *(_DWORD *)(v1 + 244900) == 0;
          sub_100574A0(v15, (_WORD *)(v1 + 226392), (unsigned int *)(v1 + 244904), v73 - 2);
          if ( a1 )
          {
            v6 = (*(_DWORD *)(v1 + 4 * v15 + 244832))-- == 1;
            if ( v6 )
              sub_10057080(v1 + 226392, v15, v1 + 200348);
          }
          *(_DWORD *)(v1 + 203080) = dword_100998C0[*(_DWORD *)(v1 + 203080)];
        }
      }
    }
    else
    {
      v16 = v15 + 16 * *(_DWORD *)(v1 + 203080);
      v17 = *(_WORD *)(v1 + 2 * v16 + 206252);
      v18 = (_DWORD *)(v1 + 244904);
      *(_DWORD *)(v1 + 244904) = v17 * (*(_DWORD *)(v1 + 244904) >> 11);
      *(_WORD *)(v1 + 2 * v16 + 206252) = v17 + ((unsigned int)(2048 - v17) >> 5);
      v19 = *(_DWORD *)(v1 + 244904);
      if ( v19 < 0x1000000 )
      {
        *v18 = *(_DWORD *)(v1 + 244904) << 8;
        sub_10055AE0((int)v18);
      }
      v20 = (_BYTE *)((*(int (__cdecl **)(_DWORD))(v1 + 12))(*(_DWORD *)(v1 + 24)) - *(_DWORD *)(v1 + 203060));
      v21 = *(_DWORD *)(v1 + 206228);
      v22 = v72 & *(_DWORD *)(v1 + 206240);
      LOBYTE(a1) = *v20;
      v23 = v1 + 244904;
      v24 = *(_DWORD *)(v1 + 206248) + 1536 * ((v22 << v21) + ((unsigned int)*(v20 - 1) >> (8 - v21)));
      if ( *(_DWORD *)(v1 + 203080) >= 7u )
        sub_100572E0((unsigned __int8)a1, v23, v24, v20[-*(_DWORD *)(v1 + 203064) - 1]);
      else
        sub_10057380((unsigned __int8)a1, v23, v24);
      *(_DWORD *)(v1 + 203080) = dword_10099860[*(_DWORD *)(v1 + 203080)];
    }
    v68 = v73;
    *(_DWORD *)(v1 + 203060) -= v73;
    v69 = *(_DWORD *)(v1 + 203060);
    v72 += v68;
    if ( !v69 )
    {
      if ( !*(_DWORD *)(v1 + 244900) )
      {
        if ( *(_DWORD *)(v1 + 244976) >= 0x80u )
          sub_10055370(v68, v1);
        if ( *(_DWORD *)(v1 + 206220) >= 0x10u )
          sub_10055550(v1);
      }
      if ( !(*(int (__cdecl **)(_DWORD))(v1 + 8))(*(_DWORD *)(v1 + 24)) )
      {
        v5 = v72;
        goto LABEL_82;
      }
      if ( (unsigned int)(v72 - v74) >= 0x8000 )
        break;
    }
    v5 = v72;
  }
  v70 = __CFADD__(v72 - v74, *(_DWORD *)(v1 + 244968));
  *(_DWORD *)(v1 + 244968) += v72 - v74;
  *(_DWORD *)(v1 + 244972) += v70;
  result = *(_DWORD *)(v1 + 244988);
  if ( !result )
  {
    if ( *(_DWORD *)(v1 + 244952) )
      *(_DWORD *)(v1 + 244988) = 9;
    if ( *(_DWORD *)(v1 + 516) )
      *(_DWORD *)(v1 + 244988) = 8;
    result = *(_DWORD *)(v1 + 244988);
    if ( result )
      *(_DWORD *)(v1 + 244980) = 1;
  }
  return result;
}
// 10099860: using guessed type int dword_10099860[];
// 10099890: using guessed type int dword_10099890[];
// 100998C0: using guessed type int dword_100998C0[];
// 100998F0: using guessed type int dword_100998F0[];

//----- (100581B0) --------------------------------------------------------
signed int __usercall sub_100581B0@<eax>(int a1@<esi>)
{
  int v1; // eax@2
  int v2; // eax@7
  signed int result; // eax@8
  int v4; // ebx@10
  int v5; // eax@10
  int v6; // eax@13
  int v7; // ecx@13
  unsigned int v8; // ecx@16
  int v9; // eax@16

  if ( !*(_DWORD *)(a1 + 244936) )
  {
    v1 = off_100AD048(&off_100AD048, 0x10000);
    *(_DWORD *)(a1 + 244936) = v1;
    if ( !v1 )
      return 2;
    *(_DWORD *)(a1 + 244932) = v1 + 0x10000;
  }
  v2 = *(_DWORD *)(a1 + 244984) && !*(_DWORD *)(a1 + 244900) && *(_DWORD *)(a1 + 492);
  v4 = *(_DWORD *)(a1 + 206228) + *(_DWORD *)(a1 + 206232);
  *(_DWORD *)(a1 + 28) = v2;
  v5 = *(_DWORD *)(a1 + 206248);
  if ( !v5 || !*(_DWORD *)(a1 + 245016) || *(_DWORD *)(a1 + 244896) != v4 )
  {
    off_100AD04C(&off_100AD048, v5);
    off_100AD04C(&off_100AD048, *(_DWORD *)(a1 + 245016));
    *(_DWORD *)(a1 + 206248) = 0;
    *(_DWORD *)(a1 + 245016) = 0;
    *(_DWORD *)(a1 + 206248) = off_100AD048(&off_100AD048, 2 * (768 << v4));
    v6 = off_100AD048(&off_100AD048, 2 * (768 << v4));
    v7 = *(_DWORD *)(a1 + 206248);
    *(_DWORD *)(a1 + 245016) = v6;
    if ( !v7 || !v6 )
    {
      off_100AD04C(&off_100AD048, v7);
      off_100AD04C(&off_100AD048, *(_DWORD *)(a1 + 245016));
      *(_DWORD *)(a1 + 206248) = 0;
      *(_DWORD *)(a1 + 245016) = 0;
      return 2;
    }
    *(_DWORD *)(a1 + 244896) = v4;
  }
  v8 = *(_DWORD *)(a1 + 244992);
  *(_DWORD *)(a1 + 496) = v8 > 0x1000000;
  v9 = *(_DWORD *)(a1 + 203056);
  if ( !*(_DWORD *)(a1 + 28) )
  {
    if ( sub_100524B0(v9, 4096, 273, a1 + 412, v8) )
    {
      *(_DWORD *)(a1 + 24) = a1 + 412;
      sub_10052F50(a1, a1 + 412);
      return 0;
    }
    return 2;
  }
  result = sub_10051B20(v9, v8, a1 + 32, 4096);
  if ( !result )
  {
    *(_DWORD *)(a1 + 24) = a1 + 32;
    sub_100518B0(a1, a1 + 32);
    result = 0;
  }
  return result;
}
// 100AD048: using guessed type int (__cdecl *off_100AD048)(_DWORD, _DWORD);
// 100AD04C: using guessed type int (__cdecl *off_100AD04C)(_DWORD, _DWORD);

//----- (10058360) --------------------------------------------------------
signed int __usercall sub_10058360@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  unsigned int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // eax@1
  unsigned int v5; // eax@3
  unsigned int v6; // eax@4
  signed int result; // eax@9
  int v8; // ecx@9
  int v9; // ecx@10

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 244992);
  v3 = 0;
  v4 = 1;
  while ( v2 > v4 )
  {
    v5 = __ROL4__(v4, 1);
    if ( v2 <= v5 )
    {
      ++v3;
      break;
    }
    v6 = __ROL4__(v5, 1);
    if ( v2 <= v6 )
    {
      v3 += 2;
      break;
    }
    v3 += 3;
    v4 = __ROL4__(v6, 1);
    if ( v3 >= 0x1B )
      break;
  }
  *(_DWORD *)(v1 + 206224) = 2 * v3;
  *(_DWORD *)(v1 + 244980) = 0;
  *(_DWORD *)(v1 + 244988) = 0;
  result = sub_100581B0(v1);
  if ( !result )
  {
    sub_10055100(v8, v1);
    sub_10057400(v1, v9);
    *(_DWORD *)(v1 + 244968) = 0;
    *(_DWORD *)(v1 + 244972) = 0;
    result = 0;
  }
  return result;
}

//----- (10058400) --------------------------------------------------------
signed int __usercall sub_10058400@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // esi@1
  signed int v4; // eax@1
  signed int result; // eax@3
  int i; // edi@4

  v3 = a1;
  v4 = 0;
  do
    ++v4;
  while ( v4 < 16 );
  *(_DWORD *)(v3 + 245000) = a3;
  *(_DWORD *)(v3 + 244940) = a2;
  result = sub_10058360(v3);
  if ( !result )
  {
    for ( i = sub_10057910(v3); !i; i = sub_10057910(v3) )
    {
      if ( *(_DWORD *)(v3 + 244980) )
        break;
    }
    if ( *(_DWORD *)(v3 + 28) )
      sub_10051050(v3 + 76);
    result = i;
  }
  return result;
}

//----- (10058490) --------------------------------------------------------
signed int __usercall sub_10058490@<eax>(int a1@<eax>, int a2@<edx>, int *a3@<esi>, int a4, int a5)
{
  int v5; // edx@1
  signed int result; // eax@1
  int (*v7)(); // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1

  *(_DWORD *)(a1 + 245008) = a2;
  *(_DWORD *)(a1 + 245012) = a5;
  *(_DWORD *)(a1 + 245004) = sub_10054F40;
  v8 = a4;
  v5 = *a3;
  v7 = sub_10054960;
  v9 = v5;
  v10 = 0;
  *(_DWORD *)(a1 + 244960) = 0;
  result = sub_10058400(a1, (int)&v7, a1 + 245004);
  *a3 -= v9;
  if ( v10 )
    result = 7;
  return result;
}
// 10054960: using guessed type int sub_10054960();

//----- (10058500) --------------------------------------------------------
signed int __cdecl sub_10058500(int a1, int *a2, int a3, int a4, const void *a5, int a6, _DWORD *a7)
{
  int v7; // eax@1
  int v8; // ebx@1
  signed int v9; // edi@2
  signed int result; // eax@5

  v7 = off_100AD048(&off_100AD048, 283688);
  v8 = v7;
  if ( v7 )
  {
    sub_10055CB0(v7);
    v9 = sub_10055B90(a5, v8);
    if ( !v9 )
    {
      v9 = sub_100548D0(a7, a6, v8);
      if ( !v9 )
        v9 = sub_10058490(v8, a3, a2, a1, a4);
    }
    sub_10057620(v8);
    off_100AD04C(&off_100AD048, v8);
    result = v9;
  }
  else
  {
    result = 2;
  }
  return result;
}
// 100AD048: using guessed type int (__cdecl *off_100AD048)(_DWORD, _DWORD);
// 100AD04C: using guessed type int (__cdecl *off_100AD04C)(_DWORD, _DWORD);

//----- (10058590) --------------------------------------------------------
char __usercall sub_10058590@<al>(int a1@<ebx>, int a2@<edi>, unsigned int a3@<esi>)
{
  unsigned int v3; // eax@1
  int v4; // ecx@5
  unsigned int v5; // eax@5
  int v6; // edx@6
  unsigned int v7; // ecx@8
  signed int v8; // eax@8
  unsigned int v9; // ecx@11
  int v10; // eax@12
  __int16 v11; // dx@13
  char result; // al@15
  int v13[17]; // [sp+0h] [bp-88h]@1
  int v14[17]; // [sp+44h] [bp-44h]@5

  memset(v13, 0, 0x44u);
  v3 = 0;
  if ( a3 )
  {
    do
    {
      if ( *(_BYTE *)(v3 + a2) )
        ++v13[*(_BYTE *)(v3 + a2)];
      ++v3;
    }
    while ( v3 < a3 );
  }
  v4 = 0;
  v14[0] = 0;
  v5 = 1;
  do
  {
    v6 = v13[v5];
    v14[v5] = v4;
    ++v5;
    v4 = 2 * (v4 + v6);
  }
  while ( v5 <= 16 );
  if ( v4 == 0x20000 )
  {
LABEL_11:
    v9 = 0;
    if ( a3 )
    {
      do
      {
        v10 = *(_BYTE *)(v9 + a2);
        if ( *(_BYTE *)(v9 + a2) )
        {
          v11 = v14[v10];
          ++v14[v10];
          *(_WORD *)(a1 + 2 * v9) = v11;
        }
        ++v9;
      }
      while ( v9 < a3 );
    }
    result = 1;
  }
  else
  {
    v7 = 0;
    v8 = 1;
    while ( 1 )
    {
      v7 += v13[v8];
      if ( v7 > 1 )
        break;
      if ( (unsigned int)++v8 > 0x10 )
        goto LABEL_11;
    }
    result = 0;
  }
  return result;
}
// 10058590: using guessed type int var_88[17];
// 10058590: using guessed type int var_44[17];

//----- (10058640) --------------------------------------------------------
char __cdecl sub_10058640(unsigned int a1, int a2, unsigned int a3)
{
  char v3; // dl@4
  unsigned int v4; // ecx@4
  int v5; // edi@5
  unsigned int v6; // eax@5
  unsigned int v7; // edx@10
  unsigned int v8; // eax@10
  signed int v9; // esi@13
  char result; // al@14
  unsigned int v11; // eax@15
  size_t v12; // ecx@16
  int v13; // edx@18
  unsigned int i; // eax@18
  int v15; // eax@21
  unsigned int v16; // esi@27
  char *v17; // ebx@27
  int v18; // edi@28
  unsigned int v19; // eax@32
  int v20; // ecx@33
  int v21; // edx@34
  int v22; // esi@34
  size_t v23; // [sp+8h] [bp-2118h]@4
  int v24[34]; // [sp+Ch] [bp-2114h]@25
  int v25[35]; // [sp+94h] [bp-208Ch]@11
  char v26[8192]; // [sp+120h] [bp-2000h]@27

  if ( a1 && a1 <= 0x2000 && a3 - 1 <= 0x21 )
  {
    memset(&v23, 0, 0x8Cu);
    v3 = 0;
    v4 = 0;
    if ( !a1 )
      goto LABEL_41;
    do
    {
      v5 = a2;
      v6 = *(_BYTE *)(v4 + a2);
      if ( *(_BYTE *)(v4 + a2) )
      {
        ++*(&v23 + v6);
        if ( v6 > a3 )
          v3 = 1;
      }
      ++v4;
    }
    while ( v4 < a1 );
    if ( !v3 )
      goto LABEL_41;
    v7 = 0;
    v8 = 1;
    do
    {
      v25[v8] = v7;
      v7 += *(size_t *)((char *)&v23 + v8 * 4);
      ++v8;
    }
    while ( v8 <= 34 );
    if ( v7 - 2 <= 0x1FFE )
    {
      v9 = 1 << a3;
      if ( v7 <= 1 << a3 )
      {
        v11 = a3 + 1;
        if ( a3 + 1 <= 0x22 )
        {
          v12 = *(&v23 + a3);
          do
          {
            v12 += *(&v23 + v11++);
            *(&v23 + a3) = v12;
          }
          while ( v11 <= 0x22 );
        }
        v13 = 0;
        for ( i = a3; i; --i )
          v13 += *(&v23 + i) << (a3 - i);
        if ( v13 != v9 )
        {
          do
          {
            --*(&v23 + a3);
            v15 = a3 - 1;
            if ( a3 == 1 )
              return 0;
            while ( !*(&v23 + v15) )
            {
              if ( !--v15 )
                return 0;
            }
            --*(&v23 + v15);
            v24[v15] += 2;
            if ( !v15 )
              return 0;
            --v13;
          }
          while ( v13 != v9 );
          v16 = 1;
          v17 = v26;
          if ( a3 >= 1 )
          {
            do
            {
              v18 = *(&v23 + v16);
              if ( v18 )
              {
                memset(v17, v16, *(&v23 + v16));
                v17 += v18;
              }
              ++v16;
            }
            while ( v16 <= a3 );
            v5 = a2;
          }
          v19 = 0;
          do
          {
            v20 = *(_BYTE *)(v19 + v5);
            if ( *(_BYTE *)(v19 + v5) )
            {
              v21 = v25[v20];
              v22 = v21 + 1;
              LOBYTE(v21) = v26[v21];
              v25[v20] = v22;
              *(_BYTE *)(v19 + v5) = v21;
            }
            ++v19;
          }
          while ( v19 < a1 );
        }
        result = 1;
      }
      else
      {
        result = 0;
      }
    }
    else
    {
LABEL_41:
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10058640: using guessed type int var_208C[35];
// 10058640: using guessed type int var_2114[34];
// 10058640: using guessed type char var_2000[8192];

//----- (10058820) --------------------------------------------------------
char __usercall sub_10058820@<al>(int a1@<esi>, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4; // ebx@1
  unsigned int v5; // eax@3
  unsigned int v6; // edx@7
  int v7; // ebp@7
  int v8; // edi@7
  unsigned int v9; // eax@7
  int v10; // ecx@8
  int v11; // ebx@14
  signed int v12; // ebp@14
  int v13; // ecx@14
  int v14; // ebx@14
  unsigned int v15; // eax@19
  unsigned int v16; // ecx@19
  int v17; // ecx@22
  int v18; // eax@23
  signed int v19; // ebp@29
  FILE *v20; // eax@32
  int v21; // eax@34
  unsigned int v22; // edi@35
  int v23; // eax@37
  const char *v24; // eax@39
  char v25; // dl@43
  unsigned int v26; // eax@43
  int v27; // ecx@44
  int v28; // edx@45
  unsigned int v29; // eax@47
  signed int v30; // ebx@50
  int v31; // eax@51
  int v32; // ecx@52
  signed int v33; // ebp@60
  FILE *v34; // eax@63
  int v35; // eax@65
  unsigned int v36; // edi@66
  int v37; // eax@68
  FILE *v38; // ST14_4@70
  unsigned int i; // ebp@76
  int v40; // eax@78
  unsigned int v41; // edx@78
  unsigned int v42; // eax@79
  FILE *v43; // ST14_4@81
  int v44; // ecx@83
  int v45; // edx@86
  signed int v46; // edi@86
  int v47; // eax@86
  unsigned int v48; // ecx@90
  int v49; // eax@90
  int v50; // eax@92
  unsigned int v51; // eax@93
  int v52; // eax@98
  unsigned int v53; // ecx@98
  int v54; // eax@103
  int v56; // [sp+Ch] [bp-6E4h]@7
  int v57; // [sp+10h] [bp-6E0h]@7
  int v58; // [sp+14h] [bp-6DCh]@7
  unsigned int v59; // [sp+18h] [bp-6D8h]@7
  unsigned int v60; // [sp+1Ch] [bp-6D4h]@78
  int v61[17]; // [sp+20h] [bp-6D0h]@3
  int v62; // [sp+64h] [bp-68Ch]@14
  int v63; // [sp+68h] [bp-688h]@91
  int v64; // [sp+6Ch] [bp-684h]@91
  int v65; // [sp+70h] [bp-680h]@91
  int v66[13]; // [sp+74h] [bp-67Ch]@91
  int v67[18]; // [sp+A8h] [bp-648h]@14
  char DstBuf; // [sp+F0h] [bp-600h]@32
  CHAR OutputString; // [sp+2F0h] [bp-400h]@63
  CHAR v70; // [sp+4F0h] [bp-200h]@81

  v4 = a2;
  if ( !a2 || a4 > 0xB )
    return 0;
  *(_DWORD *)a1 = a2;
  memset(v61, 0, 0x44u);
  v5 = 0;
  if ( a2 )
  {
    do
    {
      if ( *(_BYTE *)(v5 + a3) )
        ++v61[*(_BYTE *)(v5 + a3)];
      ++v5;
    }
    while ( v5 < a2 );
  }
  v6 = 0;
  v7 = a1 + 28;
  v8 = 0;
  v59 = 0;
  v56 = -1;
  v9 = 1;
  v58 = 15;
  v57 = a1 + 28;
  do
  {
    v10 = v61[v9];
    if ( v10 )
    {
      if ( v56 >= v9 )
        v56 = v9;
      if ( v59 <= v9 )
        v59 = v9;
      v11 = (v10 + v8 - 1) << (16 - v9);
      v12 = 1 << v58;
      v13 = v61[v9];
      *(&v62 + v9) = v8;
      v67[v9] = v6;
      v14 = (v12 - 1) | v11;
      v7 = v57;
      *(_DWORD *)v57 = v14 + 1;
      v4 = a2;
      *(_DWORD *)(v7 + 68) = v6;
      v8 += v13;
      v6 += v13;
    }
    else
    {
      *(_DWORD *)v7 = 0;
    }
    --v58;
    ++v9;
    v7 += 4;
    v8 *= 2;
    v57 = v7;
  }
  while ( v9 <= 0x10 );
  *(_DWORD *)(a1 + 4) = v6;
  if ( v6 > *(_DWORD *)(a1 + 172) )
  {
    *(_DWORD *)(a1 + 172) = v6;
    if ( !v6 || (v6 - 1) & v6 )
    {
      v15 = (((v6 - 1) | ((v6 - 1) >> 16)) >> 8) | (v6 - 1) | ((v6 - 1) >> 16);
      v16 = ((((v15 >> 4) | v15) >> 2) | (v15 >> 4) | v15 | (((((v15 >> 4) | v15) >> 2) | (v15 >> 4) | v15) >> 1)) + 1;
      if ( v4 < v16 )
        v16 = v4;
      *(_DWORD *)(a1 + 172) = v16;
    }
    v17 = *(_DWORD *)(a1 + 176);
    if ( v17 )
    {
      v18 = v17 - 8;
      if ( *(_DWORD *)(v17 - 4) == ~*(_DWORD *)(v17 - 8) && v17 != 8 )
      {
        if ( v18 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v18, 0, 0, 1, dword_100AE9F4);
      }
      *(_DWORD *)(a1 + 176) = 0;
    }
    v19 = *(_DWORD *)(a1 + 172);
    if ( !v19 )
      v19 = 1;
    if ( (unsigned int)(2 * v19 + 8) > 0x7FFF0000 )
    {
      sprintf_s(
        &DstBuf,
        0x200u,
        "%s(%u): Assertion failed: \"%s\"\n",
        "crn_mem.cpp",
        216,
        "crnlib_new_array: Array too large!");
      OutputDebugStringA(&DstBuf);
      v20 = _iob_func();
      fputs(&DstBuf, v20 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
      v21 = 0;
      goto LABEL_42;
    }
    v22 = (2 * v19 + 11) & 0xFFFFFFFC;
    if ( v22 )
    {
      if ( v22 > 0x7FFF0000 )
      {
        v24 = "crnlib_malloc: size too big";
        goto LABEL_40;
      }
    }
    else
    {
      v22 = 4;
    }
    v57 = v22;
    v23 = off_100AD9F4(0, v22, &v57, 1, dword_100AE9F4);
    if ( v23 && v57 >= v22 )
      goto LABEL_41;
    v24 = "crnlib_malloc: out of memory";
LABEL_40:
    sub_100927E0((int)v24);
    v23 = 0;
LABEL_41:
    v21 = v23 + 8;
    *(_DWORD *)(v21 - 4) = v19;
    *(_DWORD *)(v21 - 8) = ~v19;
LABEL_42:
    *(_DWORD *)(a1 + 176) = v21;
  }
  v25 = v59;
  v26 = 0;
  *(_BYTE *)(a1 + 24) = v56;
  *(_BYTE *)(a1 + 25) = v25;
  if ( v4 )
  {
    do
    {
      v27 = *(_BYTE *)(v26 + a3);
      if ( *(_BYTE *)(v26 + a3) )
      {
        v28 = v67[v27];
        v67[v27] = v28 + 1;
        *(_WORD *)(*(_DWORD *)(a1 + 176) + 2 * v28) = v26;
      }
      ++v26;
    }
    while ( v26 < v4 );
  }
  v29 = a4;
  if ( a4 <= *(_BYTE *)(a1 + 24) )
  {
    v29 = 0;
    a4 = 0;
  }
  *(_DWORD *)(a1 + 8) = v29;
  if ( !v29 )
    goto LABEL_90;
  v30 = 1 << a4;
  if ( (unsigned int)(1 << a4) > *(_DWORD *)(a1 + 164) )
  {
    v31 = *(_DWORD *)(a1 + 168);
    *(_DWORD *)(a1 + 164) = v30;
    if ( v31 )
    {
      v32 = v31 - 8;
      if ( *(_DWORD *)(v31 - 4) == ~*(_DWORD *)(v31 - 8) && v31 != 8 )
      {
        if ( v32 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v32, 0, 0, 1, dword_100AE9F4);
      }
      *(_DWORD *)(a1 + 168) = 0;
    }
    v33 = 1 << a4;
    if ( !v30 )
      v33 = 1;
    if ( (unsigned int)(4 * v33 + 8) > 0x7FFF0000 )
    {
      sprintf_s(
        &OutputString,
        0x200u,
        "%s(%u): Assertion failed: \"%s\"\n",
        "crn_mem.cpp",
        216,
        "crnlib_new_array: Array too large!");
      OutputDebugStringA(&OutputString);
      v34 = _iob_func();
      fputs(&OutputString, v34 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
      v35 = 0;
      goto LABEL_75;
    }
    v36 = (4 * v33 + 11) & 0xFFFFFFFC;
    if ( v36 )
    {
      if ( v36 > 0x7FFF0000 )
      {
        sprintf_s(&v70, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_malloc: size too big");
        OutputDebugStringA(&v70);
        v43 = _iob_func() + 2;
        fputs(&v70, v43);
        goto LABEL_71;
      }
    }
    else
    {
      v36 = 4;
    }
    v56 = v36;
    v37 = off_100AD9F4(0, v36, &v56, 1, dword_100AE9F4);
    if ( v37 && v56 >= v36 )
    {
LABEL_74:
      v35 = v37 + 8;
      *(_DWORD *)(v35 - 4) = v33;
      *(_DWORD *)(v35 - 8) = ~v33;
LABEL_75:
      *(_DWORD *)(a1 + 168) = v35;
      goto LABEL_76;
    }
    sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_malloc: out of memory");
    OutputDebugStringA(&DstBuf);
    v38 = _iob_func() + 2;
    fputs(&DstBuf, v38);
LABEL_71:
    if ( IsDebuggerPresent() )
      DebugBreak();
    v37 = 0;
    goto LABEL_74;
  }
LABEL_76:
  memset(*(void **)(a1 + 168), 255, 4 * v30);
  for ( i = 1; i <= a4; ++i )
  {
    if ( v61[i] )
    {
      v40 = *(_DWORD *)(a1 + 4 * i + 24);
      v41 = *(&v62 + i);
      v60 = a4 - i;
      v42 = v40 ? (unsigned int)(v40 - 1) >> (16 - i) : -1;
      v44 = *(_DWORD *)(a1 + 4 * i + 92);
      v57 = v42;
      v56 = v41;
      if ( v41 <= v42 )
      {
        v58 = 2 * v44;
        do
        {
          if ( 1 << (a4 - i) )
          {
            v45 = *(_WORD *)(*(_DWORD *)(a1 + 176) + v58) | (i << 16);
            v46 = 1 << (a4 - i);
            v47 = 4 * (v56 << v60);
            do
            {
              *(_DWORD *)(*(_DWORD *)(a1 + 168) + v47) = v45;
              v47 += 4;
              --v46;
            }
            while ( v46 );
          }
          v58 += 2;
          ++v56;
        }
        while ( v56 <= (unsigned int)v57 );
      }
    }
  }
LABEL_90:
  v48 = 0;
  v49 = a1 + 100;
  do
  {
    *(_DWORD *)(v49 - 4) -= *(&v63 + v48);
    *(_DWORD *)v49 -= *(&v64 + v48);
    *(_DWORD *)(v49 + 4) -= *(&v65 + v48);
    *(_DWORD *)(v49 + 8) -= v66[v48];
    v48 += 4;
    v49 += 16;
  }
  while ( v48 < 0x10 );
  v50 = *(_BYTE *)(a1 + 24);
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = v50;
  if ( a4 )
  {
    v51 = a4;
    if ( a4 >= 1 )
    {
      while ( !v61[v51] )
      {
        if ( --v51 < 1 )
          goto LABEL_103;
      }
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 4 * v51 + 24);
      if ( v51 >= 1 )
      {
        v52 = a4 + 1;
        v53 = v59;
        *(_DWORD *)(a1 + 20) = a4 + 1;
        if ( a4 + 1 <= v53 )
        {
          while ( !v61[v52] )
          {
            if ( ++v52 > v53 )
              goto LABEL_103;
          }
          *(_DWORD *)(a1 + 20) = v52;
        }
      }
    }
  }
LABEL_103:
  v54 = 32 - *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 92) = -1;
  *(_DWORD *)(a1 + 12) = v54;
  *(_DWORD *)(a1 + 160) = 0xFFFFF;
  return 1;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 10058820: using guessed type int var_6D0[17];
// 10058820: using guessed type int var_648[18];
// 10058820: using guessed type int var_67C[13];

//----- (10058EC0) --------------------------------------------------------
int __usercall sub_10058EC0@<eax>(int a1@<eax>, unsigned int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // edi@1
  int i; // edx@1
  int v7; // ecx@2
  int v8; // eax@2
  int v9; // edx@4
  int v10; // esi@5
  int *v11; // ebp@5
  unsigned int v12; // ebx@5
  signed int v13; // edi@5
  int v14; // ecx@6
  signed int v15; // eax@6
  int v16; // ecx@7
  int v17; // edx@8
  unsigned int v18; // edi@9
  unsigned int v19; // eax@9
  char *v20; // eax@12
  int v21; // edi@12
  char *v22; // ebx@13
  int v23; // edi@13
  char *v24; // eax@13
  int v25; // ebx@13
  char *v26; // ecx@17
  int v27; // eax@17
  int v28; // eax@18
  int v30; // [sp+10h] [bp-C18h]@5
  signed int v31; // [sp+14h] [bp-C14h]@5
  unsigned int v32; // [sp+18h] [bp-C10h]@5
  int v33; // [sp+1Ch] [bp-C0Ch]@1
  char v34[4]; // [sp+28h] [bp-C00h]@12
  char v35; // [sp+2Ch] [bp-BFCh]@5
  int v36[256]; // [sp+428h] [bp-800h]@1
  int v37[256]; // [sp+828h] [bp-400h]@2

  v3 = a1;
  memset(v36, 0, 0x800u);
  v4 = 16 * (a2 >> 1);
  v33 = v4;
  v5 = v3 + v4;
  for ( i = v3; i != v5; i += 16 )
  {
    v7 = *(_DWORD *)(i + 8);
    v8 = (*(_DWORD *)i >> 8) & 0xFF;
    ++v36[(unsigned __int8)*(_DWORD *)i];
    ++v37[v8];
    ++v36[(unsigned __int8)v7];
    ++v37[(unsigned __int16)v7 >> 8];
  }
  if ( a2 & 1 )
  {
    v9 = *(_DWORD *)i;
    ++v36[(unsigned __int8)v9];
    ++v37[(unsigned __int16)v9 >> 8];
  }
  v10 = a3;
  v11 = v36;
  v30 = v3;
  v12 = 0;
  v13 = &v35 - (char *)v36;
  v32 = 0;
  v31 = &v35 - (char *)v36;
  do
  {
    v14 = 0;
    v15 = 128;
    do
    {
      *(int *)((char *)v11 + v13 - 4) = v14;
      v16 = *v11 + v14;
      v11 += 2;
      *(int *)((char *)v11 + v13 - 8) = v16;
      v14 = *(v11 - 1) + v16;
      --v15;
    }
    while ( v15 );
    v17 = v30;
    if ( v30 != v30 + v33 )
    {
      do
      {
        v18 = *(_DWORD *)v17;
        v19 = *(_DWORD *)(v17 + 8);
        if ( v12 )
        {
          v18 >>= 8;
          v19 >>= 8;
        }
        v18 = (unsigned __int8)v18;
        v19 = (unsigned __int8)v19;
        if ( (unsigned __int8)v18 == (unsigned __int8)v19 )
        {
          v20 = &v34[4 * v18];
          v21 = *(_DWORD *)v20;
          *(_DWORD *)v20 += 2;
          *(_DWORD *)(v10 + 8 * v21) = *(_DWORD *)v17;
          *(_DWORD *)(v10 + 8 * v21 + 4) = *(_DWORD *)(v17 + 4);
          *(_DWORD *)(v10 + 8 * v21 + 8) = *(_DWORD *)(v17 + 8);
          *(_DWORD *)(v10 + 8 * v21 + 12) = *(_DWORD *)(v17 + 12);
        }
        else
        {
          v22 = &v34[4 * v18];
          v23 = *(_DWORD *)v22;
          v24 = &v34[4 * v19];
          ++*(_DWORD *)v22;
          v25 = (*(_DWORD *)v24)++;
          *(_DWORD *)(v10 + 8 * v23) = *(_DWORD *)v17;
          *(_DWORD *)(v10 + 8 * v23 + 4) = *(_DWORD *)(v17 + 4);
          *(_DWORD *)(v10 + 8 * v25) = *(_DWORD *)(v17 + 8);
          *(_DWORD *)(v10 + 8 * v25 + 4) = *(_DWORD *)(v17 + 12);
          v12 = v32;
        }
        v17 += 16;
      }
      while ( v17 != v30 + v33 );
      v13 = v31;
    }
    if ( a2 & 1 )
    {
      v26 = &v34[4 * ((*(_DWORD *)v17 >> 8 * v12) & 0xFF)];
      v27 = (*(_DWORD *)v26)++;
      v13 = v31;
      *(_DWORD *)(v10 + 8 * v27) = *(_DWORD *)v17;
      *(_DWORD *)(v10 + 8 * v27 + 4) = *(_DWORD *)(v17 + 4);
    }
    v28 = v30;
    ++v12;
    v13 -= 1024;
    v30 = v10;
    v10 = v28;
    v32 = v12;
    v31 = v13;
  }
  while ( v12 < 2 );
  return v30;
}
// 10058EC0: using guessed type int var_800[256];
// 10058EC0: using guessed type int var_400[256];
// 10058EC0: using guessed type char var_C00[4];

//----- (100590F0) --------------------------------------------------------
char __usercall sub_100590F0@<al>(unsigned int a1@<eax>, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  unsigned int v6; // ebx@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edi@3
  _WORD *v9; // edx@4
  unsigned int v10; // eax@5
  int v12; // eax@14
  int v13; // ecx@14
  int v14; // ebp@14
  unsigned int v15; // ebx@14
  unsigned int v16; // edi@14
  _WORD *v17; // ecx@14
  int v18; // edx@17
  unsigned int v19; // esi@20
  __int16 v20; // dx@20
  int v21; // ebp@21
  unsigned int *v22; // ebp@26
  unsigned int v23; // ecx@26
  unsigned int v24; // edi@29
  unsigned int v25; // esi@29
  unsigned int v26; // edx@29
  unsigned int v27; // ecx@29
  char v28; // dl@32
  unsigned int v29; // [sp+8h] [bp-20h]@3
  __int16 *v30; // [sp+8h] [bp-20h]@14
  unsigned int v31; // [sp+8h] [bp-20h]@28
  unsigned int v32; // [sp+Ch] [bp-1Ch]@3
  int v33; // [sp+10h] [bp-18h]@3
  int v34; // [sp+10h] [bp-18h]@14
  int v35; // [sp+14h] [bp-14h]@16
  __int16 v36; // [sp+18h] [bp-10h]@16
  _WORD *v37; // [sp+1Ch] [bp-Ch]@14
  unsigned int v38; // [sp+20h] [bp-8h]@14
  unsigned int *v39; // [sp+24h] [bp-4h]@28

  v6 = a1;
  v7 = 0;
  if ( a1 && a1 <= 0x2000 )
  {
    v8 = 0;
    v29 = 0;
    v33 = 0;
    v32 = 0;
    if ( a1 > 0 )
    {
      v9 = (_WORD *)(a2 + 6);
      do
      {
        v10 = *(_WORD *)(a3 + 2 * v7);
        if ( *(_WORD *)(a3 + 2 * v7) )
        {
          v33 += v10;
          if ( v29 <= v10 )
            v29 = *(_WORD *)(a3 + 2 * v7);
          *(v9 - 1) = v7;
          *v9 = -1;
          *(_DWORD *)(v9 - 3) = v10;
          ++v8;
          v9 += 4;
        }
        else
        {
          *(_BYTE *)(v7 + a4) = 0;
        }
        ++v7;
      }
      while ( v7 < v6 );
      v32 = v8;
    }
    *a6 = v33;
    if ( v8 == 1 )
    {
      *(_BYTE *)(*(_WORD *)(a2 + 4) + a4) = 1;
      return 1;
    }
    v12 = sub_10058EC0(a2, v8, a2 + 131080);
    v13 = 8 * v8;
    *(_WORD *)(v13 + a2 + 4) = -1;
    *(_WORD *)(v13 + a2 + 6) = -1;
    *(_DWORD *)(v13 + a2) = -1;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v34 = 0;
    v38 = v32;
    v37 = (_WORD *)(a2 + 262160);
    v30 = (__int16 *)(a2 + 262160);
    v17 = (_WORD *)(v13 + v12 + 14);
    while ( 1 )
    {
      v35 = *(_DWORD *)(v12 + 8 * v14);
      v36 = v14;
      if ( v16 <= v15 || (v18 = (unsigned __int16)*v30, *(_DWORD *)(v12 + 8 * v18) >= *(_DWORD *)(v12 + 8 * v14)) )
      {
        v34 = ++v14;
      }
      else
      {
        v36 = *v30;
        ++v15;
        ++v30;
        v35 = *(_DWORD *)(v12 + 8 * v18);
      }
      v19 = *(_DWORD *)(v12 + 8 * v14);
      v20 = v14;
      if ( v16 > v15 )
      {
        v21 = (unsigned __int16)*v30;
        if ( *(_DWORD *)(v12 + 8 * v21) < v19 )
        {
          v20 = *v30;
          v19 = *(_DWORD *)(v12 + 8 * v21);
          ++v15;
          ++v30;
          goto LABEL_25;
        }
        v14 = v34;
      }
      v34 = v14 + 1;
LABEL_25:
      *v17 = v20;
      *(_DWORD *)(v17 - 3) = v35 + v19;
      *(v17 - 1) = v36;
      *v37 = v32 + v16 + 1;
      ++v37;
      ++v16;
      v17 += 4;
      if ( --v38 <= 1 )
      {
        v22 = (unsigned int *)a2;
        v23 = *(_WORD *)(a2 + 2 * v15 + 262160);
        if ( v12 == a2 )
          v22 = (unsigned int *)(a2 + 131080);
        v39 = v22;
        v31 = 0;
        while ( 1 )
        {
          while ( 1 )
          {
            v24 = *(_WORD *)(v12 + 8 * (unsigned __int16)v23 + 4);
            v25 = *(_WORD *)(v12 + 8 * (unsigned __int16)v23 + 6);
            v26 = v23 >> 16;
            v27 = (v23 + 0x10000) & 0xFFFF0000;
            if ( v24 >= v32 )
              break;
            if ( v31 <= v26 )
              v31 = v26;
            v28 = v26 + 1;
            *(_BYTE *)(*(_WORD *)(v12 + 8 * v24 + 4) + a4) = v28;
            if ( v25 >= v32 )
              goto LABEL_40;
            *(_BYTE *)(*(_WORD *)(v12 + 8 * v25 + 4) + a4) = v28;
            if ( v22 == v39 )
            {
              *a5 = v31 + 1;
              return 1;
            }
            v23 = *(v22 - 1);
            --v22;
          }
          if ( v25 >= v32 )
          {
            *v22 = v24 | v27;
            ++v22;
LABEL_40:
            v23 = v25 | v27;
            continue;
          }
          if ( v31 <= v26 )
            v31 = v26;
          *(_BYTE *)(*(_WORD *)(v12 + 8 * v25 + 4) + a4) = v26 + 1;
          v23 = v24 | v27;
        }
      }
      v14 = v34;
    }
  }
  return 0;
}

//----- (100593B0) --------------------------------------------------------
void __stdcall sub_100593B0(int a1, float a2, float a3, float a4, float a5, float a6, float a7)
{
  int *v7; // edx@1
  unsigned int v8; // ecx@1
  unsigned int v9; // eax@1
  unsigned int v10; // ebp@1
  int v11; // esi@2
  int v12; // edx@3
  int v13; // eax@6
  int v14; // edx@6
  unsigned int v15; // ebx@6
  int v16; // esi@8
  unsigned int v17; // eax@8
  int v18; // edx@8
  unsigned int v19; // eax@11
  char *v20; // ecx@13
  unsigned int v21; // ebp@17
  int v22; // edx@19
  signed int v23; // eax@19
  signed int v24; // ecx@19
  signed int v25; // esi@19
  int v26; // ebx@26
  unsigned int v27; // edx@28
  signed __int16 v28; // cx@28
  unsigned int v29; // eax@34
  char *v30; // ecx@36
  void *v31; // esi@40
  char *v32; // edi@40
  int v33; // eax@40
  unsigned int v34; // ecx@40
  int v35; // ebp@41
  unsigned int v36; // edi@41
  __int16 v37; // ax@42
  char v38; // bl@44
  int v39; // edx@44
  unsigned int v40; // eax@44
  signed __int16 v41; // ax@47
  signed __int16 v42; // si@47
  signed __int16 v43; // dx@47
  signed __int16 v44; // cx@53
  __int16 v45; // ax@53
  signed __int16 v46; // dx@53
  signed __int16 v47; // ax@53
  int v48; // ecx@60
  int *v49; // eax@60
  unsigned int v50; // ebx@60
  int v51; // edx@60
  unsigned int v52; // esi@60
  int v53; // ecx@61
  int v54; // ecx@61
  int v55; // eax@62
  int v56; // edx@62
  char *v57; // eax@62
  int v58; // edx@62
  int v59; // esi@62
  int v60; // eax@62
  int v61; // eax@63
  int v62; // eax@81
  int v63; // eax@84
  unsigned __int16 v64; // cx@86
  unsigned __int16 v65; // dx@86
  FILE *v66; // eax@88
  void *v67; // eax@93
  int v68; // [sp-18h] [bp-2B0h]@4
  const char *v69; // [sp-Ch] [bp-2A4h]@88
  char *v70; // [sp-8h] [bp-2A0h]@88
  FILE *v71; // [sp-4h] [bp-29Ch]@88
  unsigned __int8 v72; // [sp+14h] [bp-284h]@44
  unsigned __int8 v73; // [sp+15h] [bp-283h]@44
  unsigned __int8 v74; // [sp+16h] [bp-282h]@44
  unsigned __int8 v75; // [sp+18h] [bp-280h]@44
  unsigned __int8 v76; // [sp+19h] [bp-27Fh]@44
  unsigned __int8 v77; // [sp+1Ah] [bp-27Eh]@44
  unsigned int v78; // [sp+1Ch] [bp-27Ch]@6
  char v79; // [sp+23h] [bp-275h]@61
  unsigned int v80; // [sp+24h] [bp-274h]@6
  void *v81; // [sp+28h] [bp-270h]@6
  unsigned int v82; // [sp+2Ch] [bp-26Ch]@6
  unsigned int v83; // [sp+30h] [bp-268h]@6
  unsigned __int16 v84; // [sp+34h] [bp-264h]@4
  unsigned __int16 v85; // [sp+36h] [bp-262h]@6
  unsigned int v86; // [sp+38h] [bp-260h]@6
  unsigned int v87; // [sp+3Ch] [bp-25Ch]@6
  unsigned int v88; // [sp+40h] [bp-258h]@6
  int *v89; // [sp+44h] [bp-254h]@4
  int v90; // [sp+48h] [bp-250h]@4
  int v91; // [sp+4Ch] [bp-24Ch]@34
  int v92; // [sp+50h] [bp-248h]@11
  int v93; // [sp+54h] [bp-244h]@1
  int v94; // [sp+58h] [bp-240h]@1
  int v95; // [sp+5Ch] [bp-23Ch]@1
  int v96; // [sp+60h] [bp-238h]@1
  int v97; // [sp+64h] [bp-234h]@6
  int v98; // [sp+68h] [bp-230h]@6
  unsigned __int64 v99; // [sp+6Ch] [bp-22Ch]@61
  char v100[16]; // [sp+74h] [bp-224h]@60
  char DstBuf; // [sp+84h] [bp-214h]@88
  int v102; // [sp+294h] [bp-4h]@6

  v7 = *(int **)a1;
  v8 = *(_DWORD *)(*(_DWORD *)a1 + 8);
  v9 = 0;
  v10 = 0;
  v93 = 0;
  v94 = 0;
  v95 = 0;
  v96 = 0;
  if ( v8 )
  {
    v11 = v7[3];
    do
    {
      v12 = *(_BYTE *)(v11 + v9);
      ++*(&v93 + v12);
      v7 = &v93 + v12;
      ++v9;
    }
    while ( v9 < v8 );
  }
  v89 = &v68;
  sub_1004E980((int)v7, (int)&v84, a2, a3, a4, a5, a6, a7);
  v90 = 0;
  while ( 1 )
  {
    v13 = *(_DWORD *)(a1 + 4);
    v14 = *(_DWORD *)(v13 + 12);
    v97 = *(_DWORD *)(v13 + 8);
    v98 = v14;
    v81 = 0;
    v82 = 0;
    v83 = 0;
    v102 = 0;
    v88 = (unsigned int)v84 >> 11;
    v78 = v84 & 0x1F;
    v86 = v85 & 0x1F;
    v15 = ((unsigned int)v84 >> 5) & 0x3F;
    v87 = ((unsigned int)v85 >> 5) & 0x3F;
    v80 = (unsigned int)v85 >> 11;
    do
    {
      if ( v10 != 13 )
      {
        v16 = (signed int)(v10 / 3) % 3 - 1;
        v17 = v10 % 3 - 1 + (unsigned __int8)v88;
        v18 = (signed int)(v10 / 9) % 3 - 1;
        if ( v17 <= 0x1F && v16 + v15 <= 0x3F && v18 + (unsigned int)(unsigned __int8)v78 <= 0x1F )
        {
          LOWORD(v92) = sub_10092740(v17, v18 + (unsigned __int8)v78, v16 + v15);
          v19 = v82;
          HIWORD(v92) = v85;
          if ( v82 >= v83 )
          {
            sub_100943C0(v82 + 1, 0, (int)&v81, 1, 4u, 0);
            v19 = v82;
          }
          v20 = (char *)v81 + 4 * v19;
          if ( v20 )
            *(_DWORD *)v20 = v92;
          v82 = v19 + 1;
        }
      }
      ++v10;
    }
    while ( (signed int)v10 < 27 );
    v21 = 0;
    do
    {
      if ( v21 != 13 )
      {
        v22 = (signed int)(v21 / 9) % 3;
        v23 = v21 % 3 - 1 + (unsigned __int8)v80;
        v24 = (signed int)(v21 / 3) % 3 - 1 + (unsigned __int8)v87;
        v25 = v22 - 1 + (unsigned __int8)v86;
        if ( (unsigned int)v23 <= 0x1F && (unsigned int)v24 <= 0x3F && (unsigned int)v25 <= 0x1F )
        {
          if ( v23 & 0xFFFFFF00 )
            LOBYTE(v23) = ~(v23 >> 31);
          if ( v24 & 0xFFFFFF00 )
            LOBYTE(v24) = ~(v24 >> 31);
          v26 = v22 - 1 + (unsigned __int8)v86;
          if ( v25 & 0xFFFFFF00 )
            LOBYTE(v26) = ~(v25 >> 31);
          LOWORD(v23) = (unsigned __int8)v23;
          v27 = (unsigned __int8)v24;
          v28 = (unsigned __int8)v26;
          if ( (unsigned __int8)v23 >= 0x1Fu )
            LOWORD(v23) = 31;
          if ( v27 >= 0x3F )
            LOWORD(v27) = 63;
          if ( (unsigned __int8)v26 >= 0x1Fu )
            v28 = 31;
          HIWORD(v91) = v28 | 32 * (v27 | ((_WORD)v23 << 6));
          v29 = v82;
          LOWORD(v91) = v84;
          if ( v82 >= v83 )
          {
            sub_100943C0(v82 + 1, 0, (int)&v81, 1, 4u, 0);
            v29 = v82;
          }
          v30 = (char *)v81 + 4 * v29;
          if ( v30 )
            *(_DWORD *)v30 = v91;
          v82 = v29 + 1;
        }
      }
      ++v21;
    }
    while ( (signed int)v21 < 27 );
    v31 = v81;
    v32 = (char *)v81 + 4 * v82;
    sub_1004EBE0((unsigned int *)v81, (int *)v81 + v82, (signed int)(4 * v82) >> 2);
    v33 = sub_1004ECB0((int)v32);
    v34 = 0;
    v89 = (int *)((v33 - (signed int)v31) >> 2);
    v88 = 0;
    if ( v89 )
      break;
LABEL_84:
    v63 = *(_DWORD *)(a1 + 4);
    if ( *(_DWORD *)(v63 + 8) == v97 && *(_DWORD *)(v63 + 12) == v98 )
    {
      v102 = -1;
      v67 = v81;
      if ( !v81 )
        return;
      if ( (unsigned __int8)v81 & 7 )
      {
        v71 = (FILE *)"crnlib_free: bad ptr";
        v70 = (char *)216;
        v69 = "crn_mem.cpp";
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v71 = _iob_func() + 2;
        v70 = &DstBuf;
        goto LABEL_100;
      }
      v71 = (FILE *)dword_100AE9F4;
      goto LABEL_103;
    }
    v64 = *(_WORD *)v63;
    v65 = *(_WORD *)(v63 + 2);
    v102 = -1;
    v84 = v64;
    v85 = v65;
    if ( v81 )
    {
      if ( (unsigned __int8)v81 & 7 )
      {
        v71 = (FILE *)"crnlib_free: bad ptr";
        v70 = (char *)216;
        v69 = "crn_mem.cpp";
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v66 = _iob_func();
        fputs(&DstBuf, v66 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v81, 0, 0, 1, dword_100AE9F4);
      }
    }
    if ( (unsigned int)++v90 >= 8 )
      return;
    v10 = 0;
  }
  while ( 1 )
  {
    v35 = *((_WORD *)v81 + 2 * v34 + 1);
    v36 = *((_WORD *)v81 + 2 * v34);
    v78 = v35;
    if ( (unsigned __int16)v36 < (unsigned __int16)v35 )
    {
      v37 = v36;
      LOWORD(v36) = v35;
      LOWORD(v35) = v37;
      goto LABEL_60;
    }
    if ( (_WORD)v36 == (_WORD)v35 )
    {
      v87 = v36 >> 11;
      v75 = v36 >> 11;
      v80 = v35 & 0x1F;
      v86 = (unsigned int)(unsigned __int16)v35 >> 11;
      v72 = v86;
      v74 = v35 & 0x1F;
      v38 = v36 & 0x1F;
      v39 = (v36 >> 5) & 0x3F;
      v40 = ((unsigned int)(unsigned __int16)v35 >> 5) & 0x3F;
      v76 = (v36 >> 5) & 0x3F;
      v77 = v36 & 0x1F;
      v73 = ((unsigned int)(unsigned __int16)v35 >> 5) & 0x3F;
      if ( v93 + v95 <= (unsigned int)(v94 + v96) )
      {
        if ( v38 == 31 )
        {
          if ( (_BYTE)v87 == 31 )
          {
            if ( (_BYTE)v39 == 63 )
            {
LABEL_74:
              LOWORD(v35) = v78;
              if ( (_WORD)v36 )
                LOWORD(v35) = v78 - 1;
              else
                LOWORD(v36) = 1;
              goto LABEL_60;
            }
            v76 = v39 + 1;
          }
          else
          {
            v75 = v87 + 1;
          }
        }
        else
        {
          v77 = v38 + 1;
        }
      }
      else if ( (_BYTE)v80 )
      {
        v74 = v80 - 1;
      }
      else if ( (_BYTE)v86 )
      {
        v72 = v86 - 1;
      }
      else
      {
        if ( !(_BYTE)v40 )
          goto LABEL_74;
        v73 = v40 - 1;
      }
      v41 = v75;
      v42 = v76;
      v43 = v77;
      if ( v75 >= 0x1Fu )
        v41 = 31;
      if ( v76 >= 0x3Fu )
        v42 = 63;
      if ( v77 >= 0x1Fu )
        v43 = 31;
      v44 = v74;
      v45 = v43 | 32 * (v42 | (v41 << 6));
      v46 = v73;
      LOWORD(v36) = v45;
      v47 = v72;
      if ( v72 >= 0x1Fu )
        v47 = 31;
      if ( v73 >= 0x3Fu )
        v46 = 63;
      if ( v74 >= 0x1Fu )
        v44 = 31;
      LOWORD(v35) = v44 | 32 * (v46 | (v47 << 6));
    }
LABEL_60:
    sub_100924B0(v36, (int)v100, v35);
    v48 = a1;
    v49 = *(int **)a1;
    v50 = *(_DWORD *)(*(_DWORD *)a1 + 8);
    v51 = 0;
    v52 = 0;
    v78 = 0;
    v80 = 0;
    v87 = v50;
    if ( v50 )
    {
      v53 = *(_DWORD *)(a1 + 4);
      v79 = *((_BYTE *)v49 + 33);
      v99 = *(_QWORD *)(v53 + 8);
      v54 = v49[1];
      v86 = v49[3];
      do
      {
        v55 = *(_BYTE *)(v86 + v52);
        v56 = (unsigned __int8)v100[4 * v55];
        v57 = &v100[4 * v55];
        v58 = v56 - *(_BYTE *)v54;
        v59 = ((unsigned __int8)v57[1] - *(_BYTE *)(v54 + 1)) * ((unsigned __int8)v57[1] - *(_BYTE *)(v54 + 1));
        v60 = ((unsigned __int8)v57[2] - *(_BYTE *)(v54 + 2)) * ((unsigned __int8)v57[2] - *(_BYTE *)(v54 + 2));
        if ( v79 )
          v61 = v60 + 25 * v59 + 8 * v58 * v58;
        else
          v61 = v58 * v58 + v59 + v60;
        v78 += v61;
        v51 = v78;
        if ( v78 > v99 )
          break;
        v52 = v80 + 1;
        v54 += 4;
        v80 = v52;
      }
      while ( v52 < v87 );
      v48 = a1;
    }
    v62 = *(_DWORD *)(v48 + 4);
    if ( (unsigned __int64)(unsigned int)v51 < *(_QWORD *)(v62 + 8) )
    {
      *(_DWORD *)(v62 + 8) = v51;
      *(_DWORD *)(v62 + 12) = 0;
      **(_WORD **)(v48 + 4) = v36;
      *(_WORD *)(*(_DWORD *)(v48 + 4) + 2) = v35;
      if ( !*(_QWORD *)(*(_DWORD *)(v48 + 4) + 8) )
        break;
    }
    v34 = v88 + 1;
    v88 = v34;
    if ( v34 >= (unsigned int)v89 )
      goto LABEL_84;
  }
  v102 = -1;
  v67 = v81;
  if ( !v81 )
    return;
  if ( !((unsigned __int8)v81 & 7) )
  {
    v71 = (FILE *)dword_100AE9F4;
LABEL_103:
    off_100AD9F4(v67, 0, 0, 1, v71);
    return;
  }
  v71 = (FILE *)"crnlib_free: bad ptr";
  v70 = (char *)216;
  v69 = "crn_mem.cpp";
  sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
  OutputDebugStringA(&DstBuf);
  v71 = _iob_func() + 2;
  v70 = &DstBuf;
LABEL_100:
  fputs(v70, v71);
  if ( IsDebuggerPresent() )
    DebugBreak();
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100593B0: using guessed type char var_224[16];

//----- (10059BB0) --------------------------------------------------------
void __stdcall sub_10059BB0(int a1, float a2, int a3, int a4, float a5, int a6, int a7)
{
  double v7; // st7@2
  double v8; // st4@2
  double v9; // st5@2
  float v10; // ST2C_4@10
  float v11; // ST2C_4@10
  int v12; // edi@10
  float v13; // ST2C_4@10
  int v14; // ebp@10
  unsigned int v15; // eax@10
  int v16; // ebx@12
  int v17; // esi@12
  unsigned int v18; // ebp@12
  _DWORD *v19; // eax@12
  int v20; // ebp@14
  int v21; // ecx@14
  int v22; // edi@14
  unsigned int v23; // edi@14
  int v24; // eax@18
  unsigned int v25; // ebp@18
  unsigned int v26; // ebx@21
  int v27; // esi@21
  int v28; // esi@23
  char *v29; // eax@25
  char *v30; // eax@27
  unsigned int v31; // eax@27
  int v32; // ebx@33
  int v33; // ecx@33
  unsigned int v34; // ebp@33
  int v35; // ebx@33
  unsigned int v36; // esi@34
  unsigned int v37; // eax@34
  int v38; // eax@41
  unsigned int v39; // edi@41
  unsigned int v40; // ecx@41
  _BYTE *v41; // edx@42
  int v42; // esi@42
  int v43; // eax@43
  int v44; // ebx@49
  int v45; // eax@49
  FILE *v46; // ST14_4@53
  FILE *v47; // ST14_4@58
  float v48; // [sp+1Ch] [bp-264h]@10
  unsigned int v49; // [sp+1Ch] [bp-264h]@14
  unsigned int v50; // [sp+1Ch] [bp-264h]@41
  signed int v51; // [sp+20h] [bp-260h]@18
  __int16 v52; // [sp+20h] [bp-260h]@34
  float v53; // [sp+24h] [bp-25Ch]@1
  int v54; // [sp+24h] [bp-25Ch]@14
  __int16 v55; // [sp+24h] [bp-25Ch]@34
  float v56; // [sp+28h] [bp-258h]@1
  int v57; // [sp+28h] [bp-258h]@18
  int v58; // [sp+28h] [bp-258h]@33
  int v59; // [sp+2Ch] [bp-254h]@10
  unsigned int v60; // [sp+2Ch] [bp-254h]@32
  void *v61; // [sp+30h] [bp-250h]@10
  unsigned int v62; // [sp+34h] [bp-24Ch]@10
  unsigned int v63; // [sp+38h] [bp-248h]@10
  __int64 v64; // [sp+3Ch] [bp-244h]@10
  unsigned int v65; // [sp+44h] [bp-23Ch]@14
  int v66[8]; // [sp+4Ch] [bp-234h]@43
  char DstBuf; // [sp+6Ch] [bp-214h]@53
  int v68; // [sp+27Ch] [bp-4h]@10

  v56 = a2;
  v53 = a5;
  if ( a2 >= 0.0 )
  {
    v7 = 0.9990000128746033;
    if ( a2 > 0.9990000128746033 )
      v56 = 0.99900001;
    v8 = 0.0;
    v9 = 0.99900001;
  }
  else
  {
    v7 = 0.9990000128746033;
    v8 = 0.0;
    v9 = 0.99900001;
    v56 = 0.0;
  }
  if ( v8 <= a5 )
  {
    if ( a5 > v7 )
      v53 = v9;
  }
  else
  {
    v53 = v8;
  }
  v10 = v56 * 256.0;
  v11 = floor(v10);
  v12 = (signed __int64)v11;
  v13 = v53 * 256.0;
  v48 = floor(v13);
  v61 = 0;
  v62 = 0;
  v63 = 0;
  v64 = (signed __int64)v48;
  v14 = v64;
  v59 = v64;
  v68 = 0;
  sub_10036310((int)&v61, 0x100u);
  v15 = v62;
  if ( v62 >= v63 )
  {
    sub_100943C0(v62 + 1, 0, (int)&v61, 1, 4u, 0);
    v15 = v62;
  }
  *((_DWORD *)v61 + v15) = v12 | (v14 << 8);
  v62 = v15 + 1;
  v64 = 0i64;
  LOBYTE(v68) = 1;
  sub_1007C810((int)&v64, 0x80u);
  v16 = HIDWORD(v64);
  v17 = v14 + (v12 << 8);
  v18 = (unsigned int)(v14 + (v12 << 8)) >> 9;
  v19 = *(_DWORD **)(HIDWORD(v64) + 4 * v18);
  if ( !v19 )
  {
    v19 = sub_10036280();
    *(_DWORD *)(v16 + 4 * v18) = v19;
  }
  v20 = (signed __int64)v48;
  v22 = v12 - 11;
  v21 = v22;
  v65 = -11;
  v19[(v17 & 0x1FFu) >> 5] |= 1 << (v17 & 0x1F);
  v23 = (v22 << 8) + v59 - 11;
  v54 = v21;
  v49 = v23;
  while ( 1 )
  {
    if ( v21 >= 0 )
    {
      if ( v21 > 255 )
        break;
      v24 = v20 - 11;
      v51 = -11;
      v57 = v20 - 11;
      v25 = v21 + ((v20 - 11) << 8);
      do
      {
        if ( v24 >= 0 )
        {
          if ( v24 > 255 )
            break;
          v26 = v23 >> 9;
          v27 = *(_DWORD *)(HIDWORD(v64) + 4 * (v23 >> 9));
          if ( !v27 || ((1 << (v23 & 0x1F)) & *(_DWORD *)(v27 + 4 * ((v23 & 0x1FF) >> 5))) == 0 )
          {
            v28 = *(_DWORD *)(HIDWORD(v64) + 4 * (v25 >> 9));
            if ( !v28 || ((1 << (v25 & 0x1F)) & *(_DWORD *)(v28 + 4 * ((v25 & 0x1FF) >> 5))) == 0 )
            {
              v29 = *(char **)(HIDWORD(v64) + 4 * v26);
              if ( !v29 )
              {
                v29 = (char *)sub_10036280();
                *(_DWORD *)(HIDWORD(v64) + 4 * v26) = v29;
              }
              v30 = &v29[4 * ((v23 & 0x1FF) >> 5)];
              *(_DWORD *)v30 |= 1 << (v23 & 0x1F);
              v31 = v62;
              if ( v62 >= v63 )
              {
                sub_100943C0(v62 + 1, 0, (int)&v61, 1, 4u, 0);
                v31 = v62;
              }
              *((_DWORD *)v61 + v31) = v54 | (v57 << 8);
              v62 = v31 + 1;
            }
          }
        }
        v24 = v57 + 1;
        v25 += 256;
        ++v23;
        ++v51;
        ++v57;
      }
      while ( v51 <= 11 );
    }
    v21 = v54 + 1;
    v23 = v49 + 256;
    ++v65;
    ++v54;
    v49 += 256;
    if ( (signed int)v65 > 11 )
      break;
    v20 = v59;
  }
  v60 = 0;
  if ( v62 )
  {
    v32 = *(_DWORD *)(a1 + 4);
    v33 = *(_DWORD *)(v32 + 8);
    v34 = *(_DWORD *)(v32 + 12);
    v35 = v32 + 8;
    v58 = v35;
    v65 = v33;
    do
    {
      v36 = (unsigned __int8)*((_DWORD *)v61 + v60);
      v37 = *((_DWORD *)v61 + v60) >> 8;
      v52 = (unsigned __int8)*((_DWORD *)v61 + v60);
      v55 = v37;
      if ( v36 == v37 )
      {
        if ( v37 )
        {
          v55 = --v37;
          goto LABEL_41;
        }
        LOWORD(v36) = v36 + 1;
      }
      else
      {
        if ( v36 >= v37 )
          goto LABEL_41;
        v36 = *((_DWORD *)v61 + v60) >> 8;
        v55 = (unsigned __int8)*((_DWORD *)v61 + v60);
        v37 = (unsigned __int8)*((_DWORD *)v61 + v60);
      }
      v52 = v36;
LABEL_41:
      sub_10092180(v37);
      v38 = *(_DWORD *)a1;
      v39 = 0;
      v40 = 0;
      v50 = *(_DWORD *)(*(_DWORD *)a1 + 8);
      if ( v50 )
      {
        v41 = (_BYTE *)(*(_DWORD *)(v38 + 4) + *(_DWORD *)(v38 + 16));
        v42 = *(_DWORD *)(v38 + 12);
        do
        {
          v43 = *v41 - v66[*(_BYTE *)(v42 + v40)];
          v39 += v43 * v43;
          if ( v34 <= 0 && v39 > v65 )
            break;
          ++v40;
          v41 += 4;
        }
        while ( v40 < v50 );
        v35 = v58;
        LOWORD(v36) = v52;
      }
      if ( v34 > 0 || v39 < v65 )
      {
        *(_DWORD *)v35 = v39;
        *(_DWORD *)(v35 + 4) = 0;
        **(_WORD **)(a1 + 4) = v36;
        *(_WORD *)(*(_DWORD *)(a1 + 4) + 2) = v55;
        v44 = *(_DWORD *)(a1 + 4);
        v45 = *(_DWORD *)(v44 + 8);
        v34 = *(_DWORD *)(v44 + 12);
        v35 = v44 + 8;
        v65 = v45;
        v58 = v35;
        if ( !(v34 | v45) )
        {
          LOBYTE(v68) = 0;
          sub_1007C770((int)&v64);
          v68 = -1;
          if ( v61 )
          {
            if ( (unsigned __int8)v61 & 7 )
            {
              sprintf_s(
                &DstBuf,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_free: bad ptr");
              OutputDebugStringA(&DstBuf);
              v47 = _iob_func() + 2;
              fputs(&DstBuf, v47);
              goto LABEL_54;
            }
            off_100AD9F4(v61, 0, 0, 1, dword_100AE9F4);
          }
          return;
        }
      }
      ++v60;
    }
    while ( v60 < v62 );
  }
  LOBYTE(v68) = 0;
  sub_1007C770((int)&v64);
  v68 = -1;
  if ( v61 )
  {
    if ( (unsigned __int8)v61 & 7 )
    {
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v46 = _iob_func() + 2;
      fputs(&DstBuf, v46);
LABEL_54:
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(v61, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 10092180: using guessed type double __thiscall sub_10092180(_DWORD);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 10059BB0: using guessed type int var_234[8];

//----- (1005A170) --------------------------------------------------------
bool __userpurge sub_1005A170@<al>(int a1@<edx>, int a2@<edi>, int a3@<esi>, int a4)
{
  int v5; // ebx@3
  double v6; // st6@3
  double v7; // st5@3
  double v8; // st4@3
  unsigned int v9; // ebp@3
  double v10; // st7@3
  unsigned int v11; // ecx@3
  double v12; // st7@4
  char v13; // al@5
  unsigned __int8 v14; // dl@5
  double v15; // st2@6
  double v16; // st1@8
  int v17; // eax@9
  signed int v18; // ST28_4@9
  double v19; // rt1@9
  double v20; // st1@9
  double v21; // st3@9
  double v22; // rt2@10
  double v23; // st5@15
  double v24; // st4@15
  double v25; // rtt@16
  double v26; // st4@16
  double v27; // st5@16
  double v28; // st6@16
  double v29; // st5@16
  double v30; // st4@16
  double v31; // st6@19
  double v32; // st1@20
  double v33; // st5@21
  double v34; // rt0@21
  double v35; // st4@21
  double v36; // rtt@23
  int v37; // edx@24
  double v38; // [sp+18h] [bp-90h]@9
  double v39; // [sp+20h] [bp-88h]@9
  double v40; // [sp+28h] [bp-80h]@11
  double v41; // [sp+30h] [bp-78h]@3
  double v42; // [sp+38h] [bp-70h]@3
  double v43; // [sp+40h] [bp-68h]@3
  double v44; // [sp+48h] [bp-60h]@13
  double v45; // [sp+50h] [bp-58h]@13
  double v46; // [sp+58h] [bp-50h]@16
  double v47; // [sp+60h] [bp-48h]@3
  double v48; // [sp+68h] [bp-40h]@3
  double v49; // [sp+70h] [bp-38h]@3
  double v50; // [sp+78h] [bp-30h]@3
  double v51; // [sp+80h] [bp-28h]@3
  double v52; // [sp+88h] [bp-20h]@3
  double v53; // [sp+98h] [bp-10h]@13

  if ( !*(_DWORD *)(a3 + 8) )
    return 0;
  v5 = a4;
  v6 = 0.0;
  v7 = 0.0;
  *(_DWORD *)a4 = a3;
  v8 = 0.0;
  *(_DWORD *)(a4 + 4) = a2;
  *(_DWORD *)(a2 + 8) = -1;
  v50 = 0.0;
  *(_DWORD *)(a2 + 12) = -1;
  v51 = 0.0;
  *(_DWORD *)a2 = 0;
  v9 = *(_DWORD *)(a3 + 8);
  v10 = 0.0;
  v52 = 0.0;
  v11 = 0;
  v41 = 0.0;
  v42 = 0.0;
  v43 = 0.0;
  v47 = 0.0;
  v48 = 0.0;
  v49 = 0.0;
  if ( v9 )
  {
    v12 = 0.0;
    do
    {
      v13 = *(_BYTE *)(a3 + 32);
      v14 = *(_BYTE *)(*(_DWORD *)(a3 + 12) + v11);
      if ( v13 )
        v15 = (double)(unsigned __int8)byte_1009F8C0[v14] / 3.0;
      else
        v15 = (double)(unsigned __int8)byte_1009F8AC[v14] / 7.0;
      v16 = 1.0 - v15;
      if ( v13 )
      {
        v17 = *(_DWORD *)(a3 + 4);
        v18 = *(_BYTE *)(v17 + 4 * v11 + 1);
        v5 = a4;
        a1 = *(_BYTE *)(v17 + 4 * v11 + 2);
        v38 = (double)*(_BYTE *)(v17 + 4 * v11) / 255.0;
        v39 = (double)v18 / 255.0;
        v19 = v16;
        v20 = (double)(unsigned __int8)a1 / 255.0;
        v21 = v19;
      }
      else
      {
        a1 = *(_BYTE *)(*(_DWORD *)(a3 + 16) + 4 * v11 + *(_DWORD *)(a3 + 4));
        v22 = v16;
        v20 = (double)a1 / 255.0;
        v21 = v22;
        v38 = v20;
        v39 = v20;
      }
      v40 = v20;
      if ( !v11 )
      {
        v47 = v38;
        v48 = v39;
        a1 = HIDWORD(v40);
        v49 = v40;
      }
      ++v11;
      v6 = v6 + v21 * v21;
      v7 = v7 + v15 * v15;
      v8 = v8 + v21 * v15;
      v53 = v39 * v21;
      v50 = v38 * v21 + v50;
      v51 = v53 + v51;
      v52 = v21 * v40 + v52;
      v44 = v38 * v15;
      v45 = v39 * v15;
      v41 = v44 + v41;
      v42 = v45 + v42;
      v43 = v15 * v40 + v43;
    }
    while ( v11 < v9 );
    if ( 0.0 != v7 )
    {
      if ( 0.0 == v6 )
      {
        v31 = v7;
        v45 = 0.0;
        v46 = 0.0;
        v29 = v41 / v7;
        v30 = v42 / v31;
        v28 = v43 / v31;
      }
      else
      {
        v32 = v7 * v6 - v8 * v8;
        if ( v32 == 0.0 )
        {
          v33 = v48;
          v45 = v48;
          v46 = v49;
          v28 = v49;
          v35 = v47;
          v12 = v47;
        }
        else
        {
          v48 = v42 * v8;
          v49 = v43 * v8;
          v44 = v50 * v7;
          v45 = (v51 * v7 - v48) / v32;
          v46 = (v7 * v52 - v49) / v32;
          v53 = v42 * v6;
          v33 = (v53 - v51 * v8) / v32;
          v12 = (v44 - v41 * v8) / v32;
          v34 = (v6 * v43 - v8 * v52) / v32;
          v35 = (v41 * v6 - v50 * v8) / v32;
          v28 = v34;
        }
        v36 = v35;
        v30 = v33;
        v29 = v36;
      }
      goto LABEL_24;
    }
    v23 = v50;
    v24 = 0.0;
    v10 = v51;
  }
  else
  {
    v24 = 0.0;
    v23 = 0.0;
  }
  v25 = v24;
  v26 = v10;
  v12 = v23 / v6;
  v45 = v26 / v6;
  v27 = v52 / v6;
  v28 = v25;
  v46 = v27;
  v29 = v25;
  v30 = v25;
LABEL_24:
  *(float *)&v38 = v12;
  *((float *)&v38 + 1) = v45;
  *(float *)&v39 = v46;
  *(float *)&v41 = v29;
  *((float *)&v41 + 1) = v30;
  *(float *)&v42 = v28;
  sub_100365F0((int)&v38, a1, 0.0, 1.0);
  sub_100365F0((int)&v41, v37, 0.0, 1.0);
  if ( *(_BYTE *)(a3 + 32) )
    sub_100593B0(
      v5,
      *(float *)&v38,
      *((float *)&v38 + 1),
      *(float *)&v39,
      *(float *)&v41,
      *((float *)&v41 + 1),
      *(float *)&v42);
  else
    sub_10059BB0(v5, *(float *)&v38, SHIDWORD(v38), SLODWORD(v39), *(float *)&v41, SHIDWORD(v41), SLODWORD(v42));
  return *(_QWORD *)(a2 + 8) < *(_QWORD *)(a3 + 24);
}

//----- (1005A5B0) --------------------------------------------------------
int __cdecl sub_1005A5B0(char *a1)
{
  int v1; // edi@1
  const char *v2; // esi@1

  v1 = 0;
  v2 = "box";
  while ( stricmp(a1, v2) )
  {
    v2 += 40;
    ++v1;
    if ( (signed int)v2 >= (signed int)byte_10099BA8 )
      return -1;
  }
  return v1;
}

//----- (1005A5F0) --------------------------------------------------------
double __cdecl sub_1005A5F0(double a1)
{
  int v1; // ecx@1
  double v2; // st6@1
  double v3; // st5@1

  v1 = 0;
  v2 = 1.0;
  v3 = 1.0;
  do
  {
    v2 = v2 * (a1 * 0.5 / (double)++v1);
    v3 = v3 + v2 * v2;
  }
  while ( v3 * 1.0e-16 < v2 * v2 );
  return v3;
}

//----- (1005A6A0) --------------------------------------------------------
long double __cdecl sub_1005A6A0(double a1)
{
  long double v1; // st7@1
  long double result; // st7@3

  v1 = a1 * 3.141592653589793;
  if ( a1 * 3.141592653589793 >= 0.009999999776482582 || v1 <= -0.009999999776482582 )
    result = sin(v1) / v1;
  else
    result = v1 * v1 * (v1 * v1 / 120.0 - 0.1666666716337204) + 1.0;
  return result;
}

//----- (1005A6F0) --------------------------------------------------------
double __cdecl sub_1005A6F0(float a1, float a2, float a3)
{
  double v3; // st7@1
  double result; // st7@4
  float v5; // [sp+0h] [bp-4h]@1
  float v6; // [sp+8h] [bp+4h]@2
  float v7; // [sp+8h] [bp+4h]@4
  float v8; // [sp+8h] [bp+4h]@4
  float v9; // [sp+8h] [bp+4h]@6
  float v10; // [sp+8h] [bp+4h]@6

  v3 = a1;
  v5 = a1 * a1;
  if ( a1 < 0.0 )
  {
    v6 = -v3;
    v3 = v6;
  }
  if ( v3 >= 1.0 )
  {
    if ( v3 >= 2.0 )
    {
      result = 0.0;
    }
    else
    {
      v9 = a2 * 8.0
         + a3 * 24.0
         + v3 * (a2 * -12.0 - a3 * 48.0)
         + (-1.0 * a2 - a3 * 6.0) * (v5 * v3)
         + v5 * (a2 * 6.0 + a3 * 30.0);
      v10 = v9 / 6.0;
      result = v10;
    }
  }
  else
  {
    v7 = (a3 * 6.0 + 12.0 * a2 - 18.0) * v5 + v3 * v5 * (12.0 - 9.0 * a2 - a3 * 6.0) + 6.0 - (a2 + a2);
    v8 = v7 / 6.0;
    result = v8;
  }
  return result;
}

//----- (1005A810) --------------------------------------------------------
double __cdecl sub_1005A810(float a1, float a2)
{
  double result; // st7@1
  double v3; // st6@1
  float v4; // [sp+4h] [bp+4h]@2
  float v5; // [sp+4h] [bp+4h]@4
  float v6; // [sp+4h] [bp+4h]@5
  float v7; // [sp+4h] [bp+4h]@6

  result = 0.0;
  v3 = a1;
  if ( a1 < 0.0 )
  {
    v4 = -v3;
    v3 = v4;
  }
  if ( v3 < 1.5 )
  {
    v5 = v3 * v3;
    if ( v3 > 0.5 )
    {
      v7 = v3 * (-2.0 * a2 - 0.5) + v5 * a2 + (a2 + 1.0) * 0.75;
      result = v7;
    }
    else
    {
      v6 = -2.0 * a2 * v5 + (a2 + 1.0) * 0.5;
      result = v6;
    }
  }
  return result;
}

//----- (1005A8C0) --------------------------------------------------------
double __cdecl sub_1005A8C0(float a1)
{
  double result; // st7@1
  double v2; // st6@1
  float v3; // [sp+4h] [bp+4h]@2
  float v4; // [sp+4h] [bp+4h]@4
  float v5; // [sp+4h] [bp+4h]@4
  float v6; // [sp+4h] [bp+4h]@6
  float v7; // [sp+4h] [bp+4h]@6

  result = 0.0;
  v2 = a1;
  if ( a1 < 0.0 )
  {
    v3 = -v2;
    v2 = v3;
  }
  if ( v2 >= 1.0 )
  {
    if ( v2 < 2.0 )
    {
      v6 = 2.0 - v2;
      v7 = v6 * (v6 * v6) * 0.1666666716337204;
      result = v7;
    }
  }
  else
  {
    v4 = v2 * v2;
    v5 = v2 * (0.5 * v4) - v4 + 0.6666666865348816;
    result = v5;
  }
  return result;
}

//----- (1005A950) --------------------------------------------------------
double __cdecl sub_1005A950(float a1)
{
  double result; // st7@1
  double v2; // st6@1
  float v3; // [sp+4h] [bp+4h]@2
  float v4; // [sp+4h] [bp+4h]@4
  float v5; // [sp+4h] [bp+4h]@6
  float v6; // [sp+4h] [bp+4h]@6

  result = 0.0;
  v2 = a1;
  if ( a1 < 0.0 )
  {
    v3 = -v2;
    v2 = v3;
  }
  if ( v2 >= 0.5 )
  {
    if ( v2 < 1.5 )
    {
      v5 = v2 - 1.5;
      v6 = v5 * v5 * 0.5;
      result = v6;
    }
  }
  else
  {
    v4 = 0.75 - v2 * v2;
    result = v4;
  }
  return result;
}

//----- (1005A9C0) --------------------------------------------------------
double __cdecl sub_1005A9C0(float a1)
{
  double result; // st7@1
  double v2; // st6@1
  float v3; // [sp+4h] [bp+4h]@2
  float v4; // [sp+4h] [bp+4h]@4

  result = 0.0;
  v2 = a1;
  if ( a1 < 0.0 )
  {
    v3 = -v2;
    v2 = v3;
  }
  if ( v2 < 1.0 )
  {
    v4 = 1.0 - v2;
    result = v4;
  }
  return result;
}

//----- (1005AA00) --------------------------------------------------------
double __cdecl sub_1005AA00(float a1)
{
  double result; // st7@3

  if ( a1 < -0.5 || a1 >= 0.5 )
    result = 0.0;
  else
    result = 1.0;
  return result;
}

//----- (1005AA70) --------------------------------------------------------
double __cdecl sub_1005AA70(float a1)
{
  double result; // st7@1
  double v2; // st6@1
  long double v3; // ST40_8@4
  long double v4; // st7@4
  float v5; // ST40_4@6

  result = 0.0;
  v2 = a1;
  if ( a1 < 0.0 )
  {
    a1 = -v2;
    v2 = a1;
  }
  if ( v2 < 12.0 )
  {
    v3 = sub_1005A6A0(v2 / 12.0);
    v4 = sub_1005A6A0(a1) * v3;
    if ( fabs(v4) >= 0.00001249999968422344 )
    {
      v5 = v4;
      result = v5;
    }
    else
    {
      result = (float)0.0;
    }
  }
  return result;
}

//----- (1005AB00) --------------------------------------------------------
double __cdecl sub_1005AB00(float a1)
{
  double result; // st7@1
  double v2; // st6@1
  long double v3; // ST40_8@4
  long double v4; // st7@4
  float v5; // ST40_4@6

  result = 0.0;
  v2 = a1;
  if ( a1 < 0.0 )
  {
    a1 = -v2;
    v2 = a1;
  }
  if ( v2 < 6.0 )
  {
    v3 = sub_1005A6A0(v2 / 6.0);
    v4 = sub_1005A6A0(a1) * v3;
    if ( fabs(v4) >= 0.00001249999968422344 )
    {
      v5 = v4;
      result = v5;
    }
    else
    {
      result = (float)0.0;
    }
  }
  return result;
}

//----- (1005AB90) --------------------------------------------------------
double __cdecl sub_1005AB90(float a1)
{
  double result; // st7@1
  double v2; // st6@1
  long double v3; // ST40_8@4
  long double v4; // st7@4
  float v5; // ST40_4@6

  result = 0.0;
  v2 = a1;
  if ( a1 < 0.0 )
  {
    a1 = -v2;
    v2 = a1;
  }
  if ( v2 < 4.0 )
  {
    v3 = sub_1005A6A0(v2 * 0.25);
    v4 = sub_1005A6A0(a1) * v3;
    if ( fabs(v4) >= 0.00001249999968422344 )
    {
      v5 = v4;
      result = v5;
    }
    else
    {
      result = (float)0.0;
    }
  }
  return result;
}

//----- (1005AC20) --------------------------------------------------------
double __cdecl sub_1005AC20(float a1)
{
  double result; // st7@1
  double v2; // st6@1
  long double v3; // ST40_8@4
  long double v4; // st7@4
  float v5; // ST40_4@6

  result = 0.0;
  v2 = a1;
  if ( a1 < 0.0 )
  {
    a1 = -v2;
    v2 = a1;
  }
  if ( v2 < 3.0 )
  {
    v3 = sub_1005A6A0(v2 / 3.0);
    v4 = sub_1005A6A0(a1) * v3;
    if ( fabs(v4) >= 0.00001249999968422344 )
    {
      v5 = v4;
      result = v5;
    }
    else
    {
      result = (float)0.0;
    }
  }
  return result;
}

//----- (1005ACB0) --------------------------------------------------------
double __cdecl sub_1005ACB0(float a1)
{
  double result; // st7@1
  double v2; // st6@1
  float v3; // ST00_4@4
  float v4; // ST00_4@4
  long double v5; // st7@4
  float v6; // ST00_4@6

  result = 0.0;
  v2 = a1;
  if ( a1 < 0.0 )
  {
    a1 = -v2;
    v2 = a1;
  }
  if ( v2 < 1.25 )
  {
    v3 = a1 * (-2.0 * a1);
    v4 = exp(v3);
    v5 = sqrt(0.6366197723675814)
       * v4
       * (cos(v2 / 1.25 * 6.283185307179586) * 0.07684867084026337
        + cos(v2 / 1.25 * 3.141592653589793) * 0.4965606331825256
        + 0.4265907108783722);
    if ( fabs(v5) >= 0.00001249999968422344 )
    {
      v6 = v5;
      result = v6;
    }
    else
    {
      result = (float)0.0;
    }
  }
  return result;
}

//----- (1005AD90) --------------------------------------------------------
double __cdecl sub_1005AD90(float a1)
{
  double result; // st7@1
  double v2; // st6@1
  long double v3; // st7@4
  float v4; // ST30_4@6
  float v5; // [sp+50h] [bp+8h]@2

  result = 0.0;
  v2 = a1;
  if ( a1 < 0.0 )
  {
    v5 = -v2;
    v2 = v5;
  }
  if ( v2 < 3.0 )
  {
    v3 = (cos(v2 / 3.0 * 6.283185307179586) * 0.07684867084026337
        + cos(v2 / 3.0 * 3.141592653589793) * 0.4965606331825256
        + 0.4265907108783722)
       * sub_1005A6A0(v2);
    if ( fabs(v3) >= 0.00001249999968422344 )
    {
      v4 = v3;
      result = v4;
    }
    else
    {
      result = (float)0.0;
    }
  }
  return result;
}

//----- (1005AE60) --------------------------------------------------------
void __cdecl sub_1005AE60(float a1)
{
  sub_1005A6F0(a1, 0.0, 0.5);
}

//----- (1005AE90) --------------------------------------------------------
void __cdecl sub_1005AE90(float a1)
{
  sub_1005A6F0(a1, 0.33333334, 0.33333334);
}

//----- (1005AEC0) --------------------------------------------------------
void __cdecl sub_1005AEC0(float a1)
{
  sub_1005A810(a1, 0.80000001);
}

//----- (1005AEE0) --------------------------------------------------------
void __cdecl sub_1005AEE0(float a1)
{
  sub_1005A810(a1, 0.5);
}

//----- (1005AF00) --------------------------------------------------------
void __cdecl sub_1005AF00(float a1)
{
  sub_1005A810(a1, 1.0);
}

//----- (1005AF20) --------------------------------------------------------
double __cdecl sub_1005AF20(float a1)
{
  double result; // st7@1
  double v2; // st6@1
  float v3; // ST38_4@4
  double v4; // ST38_8@4
  double v5; // ST40_8@4
  double v6; // ST40_8@4
  long double v7; // st7@4
  float v8; // ST38_4@6

  result = 0.0;
  v2 = a1;
  if ( a1 < 0.0 )
  {
    a1 = -v2;
    v2 = a1;
  }
  if ( v2 < 3.0 )
  {
    v3 = exp(log(11.1225968) * 0.4) + 1.5014944;
    v4 = v3;
    v5 = sub_1005A5F0(sqrt(1.0 - a1 / 3.0 * (a1 / 3.0)) * v4);
    v6 = v5 / sub_1005A5F0(v4);
    v7 = sub_1005A6A0(a1) * v6;
    if ( fabs(v7) >= 0.00001249999968422344 )
    {
      v8 = v7;
      result = v8;
    }
    else
    {
      result = (float)0.0;
    }
  }
  return result;
}

//----- (1005B000) --------------------------------------------------------
unsigned int __usercall sub_1005B000@<eax>(signed int a1@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  char v3; // si@3
  signed int v4; // eax@3
  int i; // esi@3
  unsigned int v6; // ecx@4
  unsigned int v7; // ecx@8
  unsigned int v8; // eax@8
  unsigned int v9; // ecx@9
  unsigned int v10; // ecx@12
  unsigned int v11; // ecx@12

  v2 = a1;
  if ( a1 > 0 && a2 )
  {
    v3 = a1;
    v4 = a1 >> 2;
    for ( i = v3 & 3; v4 > 0; v2 = (v6 >> 11) + v6 )
    {
      v6 = ((32 * (*(_WORD *)a2 + v2) ^ *(_WORD *)(a2 + 2)) << 11) ^ (*(_WORD *)a2 + v2);
      --v4;
      a2 += 4;
    }
    if ( i != 1 )
    {
      if ( i == 2 )
      {
        v9 = ((*(_WORD *)a2 + v2) << 11) ^ (*(_WORD *)a2 + v2);
        v2 = (v9 >> 17) + v9;
      }
      else if ( i == 3 )
      {
        v7 = (((*(_WORD *)a2 + v2) ^ 4 * *(_BYTE *)(a2 + 2)) << 16) ^ (*(_WORD *)a2 + v2);
        v8 = v7 >> 11;
LABEL_11:
        v2 = v8 + v7;
        goto LABEL_12;
      }
LABEL_12:
      v10 = ((8 * v2 ^ (unsigned int)v2) >> 5) + (8 * v2 ^ v2);
      v11 = ((16 * v10 ^ v10) >> 17) + (16 * v10 ^ v10);
      return ((v11 << 25) ^ v11) + (((v11 << 25) ^ v11) >> 6);
    }
    v7 = ((*(_BYTE *)a2 + v2) << 10) ^ (*(_BYTE *)a2 + v2);
    v8 = v7 >> 1;
    goto LABEL_11;
  }
  return 0;
}

//----- (1005B0E0) --------------------------------------------------------
char __userpurge sub_1005B0E0@<al>(unsigned int a1@<eax>, int a2@<edi>, int (__stdcall **a3)(int, int *, int, unsigned int, int, int *, signed int, _DWORD, signed int, signed int, signed int, signed int, int), int a4)
{
  unsigned int v4; // ebx@1
  char result; // al@2
  unsigned int v6; // eax@3
  int v7; // eax@5
  unsigned int v8; // esi@5
  unsigned int v9; // eax@5
  int v10; // esi@11
  int v11; // ebp@11
  unsigned int v12; // eax@11
  char v13; // ch^2@11
  char v14; // dh^2@11
  int (__stdcall *v15)(int, int *, int, unsigned int, int, int *, signed int, _DWORD, signed int, signed int, signed int, signed int, int); // ecx@13
  int v16; // eax@13
  unsigned int v17; // eax@14
  unsigned int v18; // esi@14
  unsigned int v19; // esi@14
  int v20; // eax@23
  int v21; // ecx@28
  unsigned int v22; // eax@28
  unsigned int v23; // eax@28
  unsigned int v24; // ebx@28
  int v25; // [sp+34h] [bp-14h]@5
  int v26; // [sp+38h] [bp-10h]@13
  int v27; // [sp+3Ch] [bp-Ch]@8
  int v28; // [sp+40h] [bp-8h]@13
  int v29; // [sp+44h] [bp-4h]@17

  v4 = a1;
  if ( a1 <= 0x40000000 )
  {
    v6 = a1 >> 8;
    if ( v6 < 0x80 )
      v6 = 128;
    v7 = v4 + v6;
    v8 = v7 + 20;
    v25 = v7;
    v9 = *(_DWORD *)(a2 + 4);
    if ( v8 != v9 )
    {
      if ( v8 >= v9 )
      {
        if ( v8 > *(_DWORD *)(a2 + 8) )
        {
          LOBYTE(v27) = v8 == v9 + 1;
          sub_100943C0(v8, 0, a2, v8 == v9 + 1, 1u, 0);
        }
        memset((void *)(*(_DWORD *)(a2 + 4) + *(_DWORD *)a2), 0, v8 - *(_DWORD *)(a2 + 4));
      }
      *(_DWORD *)(a2 + 4) = v8;
    }
    v10 = *(_DWORD *)a2;
    *(_DWORD *)v10 = 0;
    *(_DWORD *)(v10 + 4) = 0;
    *(_DWORD *)(v10 + 8) = 0;
    *(_DWORD *)(v10 + 12) = 0;
    *(_DWORD *)(v10 + 16) = 0;
    *(_BYTE *)(v10 + 12) = BYTE3(v4);
    *(_BYTE *)(v10 + 15) = v4;
    v11 = v10 + 20;
    *(_BYTE *)(v10 + 13) = v4 << 8 >> 24;
    *(_BYTE *)(v10 + 14) = v4 << 16 >> 24;
    v12 = sub_1005B3F0(a4, v4);
    v13 = BYTE3(v12);
    v12 <<= 8;
    v14 = BYTE3(v12);
    v12 <<= 8;
    *(_BYTE *)(v10 + 16) = v13;
    *(_BYTE *)(v10 + 17) = v14;
    *(_BYTE *)(v10 + 18) = BYTE3(v12);
    *(_BYTE *)(v10 + 19) = v12 >> 16;
    if ( v4 )
    {
      v27 = 0;
      while ( 1 )
      {
        v26 = v25;
        v15 = *a3;
        v28 = 5;
        v16 = v15(v11, &v26, a4, v4, v10 + 3, &v28, -1, 0, -1, -1, -1, -1, ((unsigned int)dword_100AD974 > 1) + 1);
        if ( v16 != 7 )
          break;
        v17 = *(_DWORD *)(a2 + 4);
        v18 = ((v4 + 1) >> 1) + v25;
        v25 = v18;
        v19 = v18 + 20;
        if ( v19 != v17 )
        {
          if ( v19 >= v17 )
          {
            if ( v19 > *(_DWORD *)(a2 + 8) )
            {
              LOBYTE(v29) = v19 == v17 + 1;
              sub_100943C0(v19, 0, a2, v19 == v17 + 1, 1u, 0);
            }
            memset((void *)(*(_DWORD *)(a2 + 4) + *(_DWORD *)a2), 0, v19 - *(_DWORD *)(a2 + 4));
          }
          *(_DWORD *)(a2 + 4) = v19;
        }
        v10 = *(_DWORD *)a2;
        v11 = *(_DWORD *)a2 + 20;
        if ( (unsigned int)++v27 >= 3 )
          goto LABEL_23;
      }
      if ( !v16 )
      {
        v21 = v26 << 8;
        v22 = v26 << 16;
        *(_BYTE *)(v10 + 8) = BYTE3(v26);
        *(_BYTE *)(v10 + 9) = BYTE3(v21);
        *(_BYTE *)(v10 + 10) = BYTE3(v22);
        *(_BYTE *)(v10 + 11) = v22 >> 16;
        v23 = *(_DWORD *)(a2 + 4);
        v24 = v26 + 20;
        if ( v26 + 20 != v23 )
        {
          if ( v26 + 20 >= v23 )
          {
            if ( v24 > *(_DWORD *)(a2 + 8) )
              sub_100943C0(v26 + 20, 0, a2, v24 == v23 + 1, 1u, 0);
            memset((void *)(*(_DWORD *)(a2 + 4) + *(_DWORD *)a2), 0, v24 - *(_DWORD *)(a2 + 4));
          }
          *(_DWORD *)(a2 + 4) = v24;
        }
        goto LABEL_34;
      }
LABEL_23:
      v20 = *(_DWORD *)a2;
      if ( *(_DWORD *)a2 )
      {
        if ( v20 & 7 )
        {
          sub_100927E0((int)"crnlib_free: bad ptr");
          *(_DWORD *)a2 = 0;
          *(_DWORD *)(a2 + 4) = 0;
          *(_DWORD *)(a2 + 8) = 0;
          return 0;
        }
        off_100AD9F4(v20, 0, 0, 1, dword_100AE9F4);
        *(_DWORD *)a2 = 0;
        *(_DWORD *)(a2 + 4) = 0;
        *(_DWORD *)(a2 + 8) = 0;
      }
      result = 0;
    }
    else
    {
LABEL_34:
      *(_WORD *)v10 = 19504;
      *(_BYTE *)(v10 + 2) = sub_1005B3F0(v10 + 3, 0x11u);
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100AD974: using guessed type int dword_100AD974;
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1005B3A0) --------------------------------------------------------
int __usercall sub_1005B3A0@<eax>(int a1@<eax>, _BYTE *a2@<edx>)
{
  int v2; // esi@1
  int i; // eax@1
  int v4; // ecx@2

  v2 = a1;
  for ( i = 0xFFFF; v2; --v2 )
  {
    v4 = (unsigned __int16)(*a2 ^ ((unsigned __int16)i >> 8) ^ ((unsigned __int16)(*a2 ^ ((unsigned __int16)i >> 8)) >> 4));
    ++a2;
    i = 32 * v4 ^ (v4 << 12) ^ (unsigned __int16)(v4 ^ ((_WORD)i << 8));
  }
  return ~i;
}

//----- (1005B3F0) --------------------------------------------------------
int __usercall sub_1005B3F0@<eax>(int a1@<eax>, unsigned int a2)
{
  int v2; // esi@1
  unsigned int v3; // edi@1
  unsigned int v4; // ebx@1
  unsigned int v5; // ecx@1
  unsigned int v6; // edx@2
  int v7; // eax@3
  int v8; // ecx@4
  int v9; // edi@4
  int v10; // ecx@4
  int v11; // edi@4
  int v12; // ecx@4
  int v13; // edi@4
  int v14; // ecx@4
  int v15; // edi@4
  int v16; // ecx@4
  int v17; // edi@4
  int v18; // ecx@4
  int v19; // edi@4
  int v20; // ecx@4
  int v21; // edi@4
  unsigned int v22; // eax@7
  int v23; // ecx@8
  bool v24; // zf@12
  int v26; // [sp+10h] [bp-8h]@5
  int v27; // [sp+14h] [bp-4h]@5

  v2 = a1;
  v3 = 0;
  v4 = a2 % 0x15B0;
  v5 = 1;
  if ( a2 )
  {
    do
    {
      v6 = 0;
      if ( v4 > 7 )
      {
        v7 = 7 - v2;
        do
        {
          v8 = *(_BYTE *)v2 + v5;
          v9 = v8 + v3;
          v10 = *(_BYTE *)(v2 + 1) + v8;
          v11 = v10 + v9;
          v12 = *(_BYTE *)(v2 + 2) + v10;
          v13 = v12 + v11;
          v14 = *(_BYTE *)(v2 + 3) + v12;
          v15 = v14 + v13;
          v16 = *(_BYTE *)(v2 + 4) + v14;
          v17 = v16 + v15;
          v18 = *(_BYTE *)(v2 + 5) + v16;
          v19 = v18 + v17;
          v20 = *(_BYTE *)(v2 + 6) + v18;
          v21 = v20 + v19;
          v5 = *(_BYTE *)(v2 + 7) + v20;
          v2 += 8;
          v3 = v5 + v21;
          v6 += 8;
        }
        while ( v7 + v2 < v4 );
      }
      v27 = 0;
      v26 = 0;
      if ( v6 < v4 )
      {
        if ( (signed int)(v4 - v6) >= 2 )
        {
          v22 = ((v4 - v6 - 2) >> 1) + 1;
          v6 += 2 * v22;
          do
          {
            v23 = *(_BYTE *)v2 + v5;
            v27 += v23;
            v5 = *(_BYTE *)(v2 + 1) + v23;
            v26 += v5;
            v2 += 2;
            --v22;
          }
          while ( v22 );
        }
        if ( v6 < v4 )
        {
          v5 += *(_BYTE *)v2;
          v3 += v5;
          ++v2;
        }
        v3 += v27 + v26;
      }
      v5 %= 0xFFF1u;
      v3 %= 0xFFF1u;
      v24 = a2 == v4;
      a2 -= v4;
      v4 = 5552;
    }
    while ( !v24 );
  }
  return v5 + (v3 << 16);
}

//----- (1005B5A0) --------------------------------------------------------
void __usercall sub_1005B5A0(int a1@<eax>, int a2, int a3, int a4, int a5, int a6, int a7, float a8)
{
  int v8; // eax@1
  unsigned int v9; // eax@6
  signed int v10; // ecx@16
  signed int v11; // edi@18
  unsigned int v12; // eax@25
  int v13; // ecx@25
  _DWORD *v14; // ecx@26
  int v15; // ebx@28
  int *v16; // eax@28
  unsigned int v17; // edi@34
  int v18; // eax@34
  _DWORD *v19; // eax@35
  int v20; // ebx@37
  int *v21; // eax@37
  unsigned int v22; // edi@40
  unsigned int v23; // eax@40
  unsigned int v24; // ecx@40
  int v25; // edx@41
  int *v26; // esi@42
  int *v27; // edx@46
  unsigned int v28; // edi@50
  unsigned int v29; // ebx@50
  unsigned int v30; // ebx@52
  unsigned int v31; // edi@54
  unsigned int v32; // ebx@54
  unsigned int v33; // eax@56
  int v34; // ecx@63
  unsigned int v35; // eax@67
  int v36; // esi@68
  int v37; // ecx@68
  unsigned int v38; // edx@68
  int v39; // ecx@69
  int v40; // eax@69
  unsigned int v41; // eax@71
  int v42; // ecx@71
  int *v43; // eax@72
  double v44; // st7@78
  double v45; // st6@78
  unsigned int v46; // edi@80
  int v47; // esi@81
  double v48; // st5@81
  float v49; // ST2C_4@82
  double v50; // st7@82
  float v51; // ST24_4@84
  float v52; // ST30_4@84
  float v53; // ST2C_4@84
  float v54; // ST24_4@84
  int v55; // edi@88
  unsigned int v56; // edx@88
  int v57; // ecx@90
  int v58; // eax@90
  unsigned int v59; // eax@92
  int v60; // ecx@92
  int *v61; // eax@93
  int v62; // eax@95
  float v63; // ST30_4@100
  int v64; // ST10_4@100
  float v65; // ST24_4@100
  double v66; // st7@100
  double v67; // st7@100
  float v68; // ST24_4@100
  float v69; // ST30_4@100
  double v70; // st7@100
  unsigned int v71; // esi@103
  int v72; // ecx@113
  unsigned int v73; // esi@115
  int v74; // ecx@116
  int v75; // edx@116
  int v76; // eax@116
  unsigned int v77; // eax@118
  int v78; // edx@118
  int *v79; // eax@119
  unsigned int v80; // eax@124
  _WORD *v81; // edi@125
  FILE *v82; // eax@129
  FILE *v83; // eax@134
  FILE *v84; // eax@139
  signed int *v85; // [sp+0h] [bp-474h]@14
  unsigned int v86; // [sp+0h] [bp-474h]@50
  float v87; // [sp+0h] [bp-474h]@82
  float v88; // [sp+0h] [bp-474h]@88
  unsigned int v89; // [sp+4h] [bp-470h]@13
  unsigned int v90; // [sp+4h] [bp-470h]@50
  int v91; // [sp+4h] [bp-470h]@68
  unsigned int v92; // [sp+4h] [bp-470h]@80
  signed int v93; // [sp+4h] [bp-470h]@88
  unsigned int v94; // [sp+4h] [bp-470h]@103
  unsigned int v95; // [sp+8h] [bp-46Ch]@13
  unsigned int v96; // [sp+8h] [bp-46Ch]@56
  unsigned int v97; // [sp+8h] [bp-46Ch]@67
  signed int v98; // [sp+8h] [bp-46Ch]@88
  signed int v99; // [sp+Ch] [bp-468h]@19
  int v100; // [sp+Ch] [bp-468h]@89
  void *v101; // [sp+10h] [bp-464h]@50
  unsigned int v102; // [sp+14h] [bp-460h]@50
  unsigned int v103; // [sp+18h] [bp-45Ch]@50
  void *v104; // [sp+1Ch] [bp-458h]@54
  unsigned int v105; // [sp+20h] [bp-454h]@54
  unsigned int v106; // [sp+24h] [bp-450h]@54
  void *v107; // [sp+28h] [bp-44Ch]@63
  int v108; // [sp+2Ch] [bp-448h]@63
  int v109; // [sp+30h] [bp-444h]@63
  double v110; // [sp+34h] [bp-440h]@80
  int v111; // [sp+3Ch] [bp-438h]@13
  int v112; // [sp+40h] [bp-434h]@13
  int v113; // [sp+44h] [bp-430h]@13
  int v114; // [sp+48h] [bp-42Ch]@13
  int v115; // [sp+4Ch] [bp-428h]@13
  int v116; // [sp+54h] [bp-420h]@13
  double v117; // [sp+5Ch] [bp-418h]@81
  CHAR OutputString; // [sp+64h] [bp-410h]@134
  char DstBuf; // [sp+264h] [bp-210h]@129
  int v120; // [sp+468h] [bp-Ch]@1
  int (__thiscall *v121)(void *); // [sp+46Ch] [bp-8h]@1
  int v122; // [sp+470h] [bp-4h]@1

  v122 = -1;
  v121 = sub_10096437;
  v120 = a1;
  v8 = *(_DWORD *)a5;
  if ( *(_DWORD *)a5 )
  {
    if ( v8 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v8, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)a5 = 0;
    *(_DWORD *)(a5 + 4) = 0;
    *(_DWORD *)(a5 + 8) = 0;
  }
  v9 = *(_DWORD *)(a5 + 4);
  if ( a2 != v9 )
  {
    if ( a2 >= v9 )
    {
      if ( (unsigned int)a2 > *(_DWORD *)(a5 + 8) )
        sub_100943C0(a2, 0, a5, a2 == v9 + 1, 4u, 0);
      memset((void *)(*(_DWORD *)a5 + 4 * *(_DWORD *)(a5 + 4)), 0, 4 * (a2 - *(_DWORD *)(a5 + 4)));
    }
    *(_DWORD *)(a5 + 4) = a2;
  }
  if ( (unsigned int)a3 > 1 )
  {
    v89 = a2 * a2;
    v111 = 0;
    v112 = 0;
    v113 = 0;
    v114 = 0;
    v115 = 0;
    v122 = 0;
    v116 = 0;
    sub_1004E710(a2 * a2, (int)&v111);
    v122 = 1;
    v95 = 0;
    if ( (unsigned int)a3 > 0 )
    {
      v85 = (signed int *)(a4 + 4);
      do
      {
        if ( v95 )
          v10 = *(v85 - 2);
        else
          v10 = -1;
        v11 = *(v85 - 1);
        if ( v95 >= a3 - 1 )
          v99 = -1;
        else
          v99 = *v85;
        if ( v11 != v10 && v11 != -1 && v10 != -1 && v11 < v10 )
        {
          v12 = v10 + a2 * v11;
          v13 = *(_DWORD *)(v113 + 4 * ((unsigned int)(v10 + a2 * v11) >> 4));
          v14 = (_DWORD *)(v13 ? v13 + 4 * (v12 & 0xF) : &v116);
          v15 = *v14 + 1;
          v16 = (int *)sub_1004E7B0((int)&v111, v12);
          if ( v16 )
            *v16 = v15;
        }
        if ( v11 != v99 && v11 != -1 && v99 != -1 && v11 < v99 )
        {
          v17 = v99 + a2 * v11;
          v18 = *(_DWORD *)(v113 + 4 * (v17 >> 4));
          v19 = (_DWORD *)(v18 ? v18 + 4 * (v17 & 0xF) : &v116);
          v20 = *v19 + 1;
          v21 = (int *)sub_1004E7B0((int)&v111, v17);
          if ( v21 )
            *v21 = v20;
        }
        ++v85;
        ++v95;
      }
      while ( v95 < a3 );
    }
    v22 = 0;
    v23 = 0;
    v24 = 0;
    if ( v89 )
    {
      do
      {
        v25 = *(_DWORD *)(v113 + 4 * (v24 >> 4));
        if ( v25 )
          v26 = (int *)(v25 + 4 * (v24 & 0xF));
        else
          v26 = &v116;
        if ( *v26 > v22 )
        {
          if ( v25 )
            v27 = (int *)(v25 + 4 * (v24 & 0xF));
          else
            v27 = &v116;
          v22 = *v27;
          v23 = v24;
        }
        ++v24;
      }
      while ( v24 < v89 );
    }
    v28 = v23 / a2;
    v90 = v23 % a2;
    v86 = v23 / a2;
    v101 = 0;
    v102 = 0;
    v103 = 0;
    LOBYTE(v122) = 2;
    sub_10035640((int)&v101, a2);
    v29 = v102;
    if ( v102 >= v103 )
    {
      sub_100943C0(v102 + 1, 0, (int)&v101, 1, 2u, 0);
      v29 = v102;
    }
    *((_WORD *)v101 + v29) = v28;
    v30 = v29 + 1;
    v102 = v30;
    if ( v30 >= v103 )
    {
      sub_100943C0(v30 + 1, 0, (int)&v101, 1, 2u, 0);
      v30 = v102;
    }
    v31 = 0;
    *((_WORD *)v101 + v30) = v90;
    v32 = v30 + 1;
    v102 = v32;
    v104 = 0;
    v105 = 0;
    v106 = 0;
    LOBYTE(v122) = 3;
    if ( (unsigned int)a2 > 2 )
    {
      sub_10035640((int)&v104, a2 - 2);
      v31 = v105;
    }
    v33 = 0;
    v96 = 0;
    if ( a2 )
    {
      do
      {
        if ( v33 != v86 && v33 != v90 )
        {
          if ( v31 >= v106 )
          {
            sub_100943C0(v31 + 1, 0, (int)&v104, 1, 2u, 0);
            v31 = v105;
            v33 = v96;
          }
          *((_WORD *)v104 + v31++) = v33;
          v105 = v31;
        }
        v96 = ++v33;
      }
      while ( v33 < a2 );
    }
    v34 = 0;
    v107 = 0;
    v108 = 0;
    v109 = 0;
    if ( a2 )
    {
      if ( a2 )
      {
        sub_100943C0(a2, 0, (int)&v107, a2 == 1, 4u, 0);
        v34 = v108;
      }
      memset((char *)v107 + 4 * v34, 0, 4 * (a2 - v34));
      v108 = a2;
    }
    v35 = 0;
    LOBYTE(v122) = 4;
    v97 = 0;
    if ( v31 )
    {
      do
      {
        v36 = *((_WORD *)v104 + v35);
        v37 = 0;
        v38 = 0;
        v91 = 0;
        if ( v32 )
        {
          do
          {
            v39 = *((_WORD *)v101 + v38);
            v40 = v36;
            if ( v36 > v39 )
            {
              v40 = *((_WORD *)v101 + v38);
              v39 = v36;
            }
            v41 = v39 + a2 * v40;
            v42 = *(_DWORD *)(v113 + 4 * (v41 >> 4));
            if ( v42 )
              v43 = (int *)(v42 + 4 * (v41 & 0xF));
            else
              v43 = &v116;
            v37 = *v43 + v91;
            ++v38;
            v91 += *v43;
          }
          while ( v38 < v32 );
          v35 = v97;
          v31 = v105;
        }
        ++v35;
        *((_DWORD *)v107 + v36) = v37;
        v97 = v35;
      }
      while ( v35 < v31 );
      if ( v31 )
      {
        v44 = a8;
        v45 = 1.0;
        while ( 1 )
        {
          v46 = 0;
          v110 = 0.0;
          v92 = 0;
          if ( v105 )
          {
            do
            {
              v47 = *((_WORD *)v104 + v46);
              v48 = (double)*((unsigned int *)v107 + v47);
              v117 = v48;
              if ( a6 )
              {
                ((void (__cdecl *)(int, _DWORD, int))a6)(v47, *(_WORD *)v101, a7);
                v49 = v44;
                ((void (__cdecl *)(int, _DWORD, int))a6)(v47, *((_WORD *)v101 + v32 - 1), a7);
                v87 = v44;
                v50 = v49;
                if ( v87 >= (double)v49 )
                  v50 = v87;
                v51 = v50;
                v44 = a8;
                v45 = 1.0;
                v52 = 1.0 - a8;
                v53 = a8 + 1.0;
                v54 = (v53 - v52) * v51 + v52;
                v48 = (v117 + 1.0) * v54;
              }
              if ( v110 < v48 )
              {
                v110 = v48;
                v92 = v46;
              }
              ++v46;
            }
            while ( v46 < v105 );
          }
          v88 = 0.0;
          v55 = *((_WORD *)v104 + v92);
          v56 = 0;
          LODWORD(v117) = (char *)v104 + 2 * v92;
          v98 = 0;
          v93 = 0;
          if ( v32 )
          {
            v100 = v32 - 1;
            do
            {
              v57 = *((_WORD *)v101 + v56);
              v58 = v55;
              if ( v55 > v57 )
              {
                v58 = *((_WORD *)v101 + v56);
                v57 = v55;
              }
              v59 = v57 + a2 * v58;
              v60 = *(_DWORD *)(v113 + 4 * (v59 >> 4));
              if ( v60 )
                v61 = (int *)(v60 + 4 * (v59 & 0xF));
              else
                v61 = &v116;
              v62 = *v61 * v100;
              v88 = (double)v62 + v88;
              if ( v100 >= 0 )
                v98 += v62;
              else
                v93 -= v62;
              ++v56;
              v100 -= 2;
            }
            while ( v56 < v32 );
          }
          if ( a6 )
          {
            v63 = v45 - v44;
            v64 = *(_WORD *)v101;
            v65 = v44 + v45;
            v66 = v65 - v63;
            v110 = v66;
            ((void (__cdecl *)(int, int, int))a6)(v55, v64, a7);
            v67 = v66 * v110 + v63;
            v68 = v67;
            ((void (__cdecl *)(int, _DWORD, _DWORD))a6)(v55, *((_WORD *)v101 + v32 - 1), a7);
            v69 = v67 * v110 + v63;
            v88 = (double)v98 * v68 - (double)v93 * v69;
            v70 = 1.0;
          }
          else
          {
            v70 = v45;
          }
          if ( v88 <= 0.0 )
          {
            if ( v32 >= v103 )
            {
              sub_100943C0(v32 + 1, 0, (int)&v101, 1, 2u, 0);
              v70 = 1.0;
              v32 = v102;
            }
            *((_WORD *)v101 + v32++) = v55;
            v102 = v32;
          }
          else
          {
            v71 = v32 + 1;
            v94 = v32;
            if ( v32 + 1 != v32 )
            {
              if ( v32 + 1 >= v32 )
              {
                if ( v71 > v103 )
                {
                  sub_100943C0(v32 + 1, 0, (int)&v101, 1, 2u, 0);
                  v32 = v102;
                }
                memset((char *)v101 + 2 * v32, 0, 2 * (v71 - v32));
              }
              v32 = v71;
              v102 = v71;
            }
            memmove((char *)v101 + 2, v101, 2 * v94);
            v70 = 1.0;
            *(_WORD *)v101 = v55;
          }
          v72 = (LODWORD(v117) - (signed int)v104) >> 1;
          if ( v72 + 1 <= v105 )
          {
            memmove((char *)v104 + 2 * v72, (char *)v104 + 2 * v72 + 2, 2 * (v105 - v72 - 1));
            v70 = 1.0;
            --v105;
          }
          v73 = 0;
          if ( v105 )
          {
            do
            {
              v74 = *((_WORD *)v104 + v73);
              v75 = v55;
              v76 = v74;
              if ( v74 > v55 )
              {
                v76 = v55;
                v75 = *((_WORD *)v104 + v73);
              }
              v77 = v75 + a2 * v76;
              v78 = *(_DWORD *)(v113 + 4 * (v77 >> 4));
              if ( v78 )
                v79 = (int *)(v78 + 4 * (v77 & 0xF));
              else
                v79 = &v116;
              *((_DWORD *)v107 + v74) += *v79;
              ++v73;
            }
            while ( v73 < v105 );
            v32 = v102;
          }
          if ( !v105 )
            break;
          v45 = v70;
          v44 = a8;
        }
      }
    }
    v80 = 0;
    if ( a2 )
    {
      v81 = v101;
      do
      {
        *(_DWORD *)(*(_DWORD *)a5 + 4 * v81[v80]) = v80;
        ++v80;
      }
      while ( v80 < a2 );
    }
    LOBYTE(v122) = 3;
    if ( v107 )
    {
      if ( (unsigned __int8)v107 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v82 = _iob_func();
        fputs(&DstBuf, v82 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v107, 0, 0, 1, dword_100AE9F4);
      }
    }
    LOBYTE(v122) = 2;
    if ( v104 )
    {
      if ( (unsigned __int8)v104 & 7 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_free: bad ptr");
        OutputDebugStringA(&OutputString);
        v83 = _iob_func();
        fputs(&OutputString, v83 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v104, 0, 0, 1, dword_100AE9F4);
      }
    }
    LOBYTE(v122) = 1;
    if ( v101 )
    {
      if ( (unsigned __int8)v101 & 7 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_free: bad ptr");
        OutputDebugStringA(&OutputString);
        v84 = _iob_func();
        fputs(&OutputString, v84 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v101, 0, 0, 1, dword_100AE9F4);
      }
    }
    v122 = -1;
    sub_1004E640((int)&v111);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1005BF60) --------------------------------------------------------
unsigned int __thiscall sub_1005BF60(unsigned int *this)
{
  unsigned int v1; // edx@1
  unsigned int result; // eax@1
  int v3; // ecx@2
  unsigned int i; // eax@2
  int v5; // eax@4

  v1 = *this;
  result = 0;
  if ( *this > 0x10 )
  {
    v3 = 0;
    for ( i = v1; i > 1; ++v3 )
      i >>= 1;
    v5 = v3;
    if ( v3 != 32 && v1 > 1 << v3 )
      v5 = v3 + 1;
    result = v5 + 1;
    if ( result >= 0xB )
      LOBYTE(result) = 11;
    result = (unsigned __int8)result;
  }
  return result;
}

//----- (1005BFA0) --------------------------------------------------------
void __usercall sub_1005BFA0(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // eax@6
  int v3; // eax@11

  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 92) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  v1 = *(_DWORD *)(a1 + 40);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 44) = 0;
    *(_DWORD *)(a1 + 48) = 0;
  }
  v2 = *(_DWORD *)(a1 + 52);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 52) = 0;
    *(_DWORD *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 60) = 0;
  }
  v3 = *(_DWORD *)(a1 + 64);
  if ( v3 )
  {
    if ( v3 & 7 )
    {
      sub_100927E0((int)"crnlib_free: bad ptr");
      *(_DWORD *)(a1 + 64) = 0;
      *(_DWORD *)(a1 + 68) = 0;
      *(_DWORD *)(a1 + 72) = 0;
    }
    else
    {
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
      *(_DWORD *)(a1 + 64) = 0;
      *(_DWORD *)(a1 + 68) = 0;
      *(_DWORD *)(a1 + 72) = 0;
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1005C1B0) --------------------------------------------------------
unsigned int __userpurge sub_1005C1B0@<eax>(unsigned int result@<eax>, int a2@<ecx>, unsigned int a3)
{
  int v3; // esi@1
  _DWORD *v4; // edi@4
  unsigned int v5; // eax@4
  unsigned int v6; // eax@10
  int v7; // esi@10
  unsigned int v8; // eax@15
  int v9; // [sp+14h] [bp-4h]@4
  int v10; // [sp+14h] [bp-4h]@15

  v3 = a2;
  if ( result <= 0x10 )
  {
    *(_DWORD *)(a2 + 76) += result;
    if ( *(_BYTE *)(a2 + 80) )
      return result;
    v7 = a2 + 64;
    v10 = (unsigned __int16)result;
    v8 = *(_DWORD *)(a2 + 68);
    if ( v8 >= *(_DWORD *)(a2 + 72) )
      sub_100943C0(v8 + 1, 0, v7, 1, 8u, 0);
    result = *(_DWORD *)v7 + 8 * *(_DWORD *)(v7 + 4);
    if ( result )
    {
      *(_DWORD *)result = a3;
      *(_DWORD *)(result + 4) = v10;
    }
    goto LABEL_19;
  }
  result -= 16;
  if ( result )
  {
    *(_DWORD *)(a2 + 76) += result;
    if ( !*(_BYTE *)(a2 + 80) )
    {
      v9 = (unsigned __int16)result;
      v4 = (_DWORD *)(a2 + 64);
      v5 = *(_DWORD *)(a2 + 68);
      if ( v5 >= *(_DWORD *)(a2 + 72) )
        sub_100943C0(v5 + 1, 0, a2 + 64, 1, 8u, 0);
      result = *v4 + 8 * *(_DWORD *)(v3 + 68);
      if ( result )
      {
        *(_DWORD *)result = a3 >> 16;
        *(_DWORD *)(result + 4) = v9;
      }
      ++*(_DWORD *)(v3 + 68);
    }
  }
  *(_DWORD *)(v3 + 76) += 16;
  if ( !*(_BYTE *)(v3 + 80) )
  {
    v6 = *(_DWORD *)(v3 + 68);
    v7 = v3 + 64;
    if ( v6 >= *(_DWORD *)(v7 + 8) )
      sub_100943C0(v6 + 1, 0, v7, 1, 8u, 0);
    result = *(_DWORD *)v7 + 8 * *(_DWORD *)(v7 + 4);
    if ( result )
    {
      *(_DWORD *)result = (unsigned __int16)a3;
      *(_DWORD *)(result + 4) = 16;
      ++*(_DWORD *)(v7 + 4);
      return result;
    }
LABEL_19:
    ++*(_DWORD *)(v7 + 4);
  }
  return result;
}

//----- (1005C320) --------------------------------------------------------
char __userpurge sub_1005C320@<al>(unsigned int a1@<eax>, int a2, int a3, unsigned int a4)
{
  int v4; // ebp@1
  unsigned int v5; // esi@1
  unsigned int v6; // eax@3
  int *v7; // edi@3
  int v8; // ebx@9
  int v9; // ST08_4@9
  unsigned int v10; // eax@9
  unsigned int v11; // eax@17
  int v12; // ebx@23
  char result; // al@26
  int v14; // edi@29
  unsigned int v15; // eax@29
  unsigned int v16; // [sp+14h] [bp-4h]@9

  v4 = a2;
  v5 = a1;
  *(_BYTE *)(a2 + 32) = 1;
  *(_DWORD *)v4 = a1;
  if ( a4 >= 0x10 )
    a4 = 16;
  v6 = *(_DWORD *)(v4 + 20);
  v7 = (int *)(v4 + 16);
  if ( v5 != v6 )
  {
    if ( v5 >= v6 )
    {
      if ( v5 > *(_DWORD *)(v4 + 24) )
      {
        LOBYTE(a2) = v5 == v6 + 1;
        sub_100943C0(v5, 0, v4 + 16, v5 == v6 + 1, 1u, 0);
      }
      memset((void *)(*(_DWORD *)(v4 + 20) + *v7), 0, v5 - *(_DWORD *)(v4 + 20));
    }
    *(_DWORD *)(v4 + 20) = v5;
  }
  v8 = sub_10092A80(278544);
  v9 = *v7;
  v10 = *(_DWORD *)v4;
  v16 = 0;
  LOBYTE(a2) = sub_100590F0(v10, v8, a3, v9, &v16, &a2);
  if ( v8 )
  {
    if ( v8 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v8, 0, 0, 1, dword_100AE9F4);
  }
  if ( !(_BYTE)a2 || v16 > a4 && !sub_10058640(*(_DWORD *)v4, *v7, a4) )
    return 0;
  if ( *(_BYTE *)(v4 + 32) )
  {
    v11 = *(_DWORD *)(v4 + 8);
    if ( v5 != v11 )
    {
      if ( v5 >= v11 )
      {
        if ( v5 > *(_DWORD *)(v4 + 12) )
        {
          LOBYTE(a4) = v5 == v11 + 1;
          sub_100943C0(v5, 0, v4 + 4, v5 == v11 + 1, 2u, 0);
        }
        memset((void *)(*(_DWORD *)(v4 + 4) + 2 * *(_DWORD *)(v4 + 8)), 0, 2 * (v5 - *(_DWORD *)(v4 + 8)));
      }
      *(_DWORD *)(v4 + 8) = v5;
    }
    v12 = *(_DWORD *)(v4 + 28);
    if ( v12 )
    {
      sub_1004E5C0(v12);
      *(_DWORD *)(v4 + 28) = 0;
    }
    if ( !sub_10058590(*(_DWORD *)(v4 + 4), *v7, *(_DWORD *)v4) )
      return 0;
    goto LABEL_30;
  }
  sub_1003C8F0(v4 + 4);
  if ( !*(_DWORD *)(v4 + 28) )
    *(_DWORD *)(v4 + 28) = sub_1004E600();
  v14 = *v7;
  v15 = sub_1005BF60((unsigned int *)v4);
  result = sub_10058820(*(_DWORD *)(v4 + 28), *(_DWORD *)v4, v14, v15);
  if ( result )
LABEL_30:
    result = 1;
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1005C4E0) --------------------------------------------------------
void __usercall sub_1005C4E0(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // eax@6
  int v3; // ebx@11

  *(_DWORD *)a1 = 0;
  v1 = *(_DWORD *)(a1 + 4);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 12) = 0;
  }
  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 24) = 0;
  }
  v3 = *(_DWORD *)(a1 + 28);
  if ( v3 )
  {
    sub_1004E4D0(v3);
    if ( v3 & 7 )
    {
      sub_100927E0((int)"crnlib_free: bad ptr");
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 32) = 0;
      return;
    }
    off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 28) = 0;
  }
  *(_BYTE *)(a1 + 32) = 0;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1005C5A0) --------------------------------------------------------
void __thiscall sub_1005C5A0(void *this)
{
  _DWORD *v1; // edi@1
  int v2; // ebx@1
  int v3; // eax@5
  int v4; // eax@9

  v1 = this;
  v2 = *((_DWORD *)this + 7);
  if ( v2 )
  {
    sub_1004E4D0(v2);
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
  }
  v3 = v1[4];
  if ( v3 )
  {
    if ( v3 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
  }
  v4 = v1[1];
  if ( v4 )
  {
    if ( v4 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1005C690) --------------------------------------------------------
int __usercall sub_1005C690@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>)
{
  signed int v3; // ecx@1
  int result; // eax@1
  int *v5; // edi@2
  unsigned int v6; // eax@3
  char v7; // bl@3

  *(_DWORD *)(a3 + 32) -= a2;
  v3 = *(_DWORD *)(a3 + 32);
  *(_DWORD *)(a3 + 76) += a2;
  result = a1 << v3;
  *(_DWORD *)(a3 + 28) |= result;
  if ( v3 <= 24 )
  {
    v5 = (int *)(a3 + 40);
    do
    {
      v6 = *(_DWORD *)(a3 + 44);
      v7 = *(_BYTE *)(a3 + 31);
      if ( v6 >= *(_DWORD *)(a3 + 48) )
        sub_100943C0(v6 + 1, 0, a3 + 40, 1, 1u, 0);
      result = *v5;
      *(_BYTE *)(*v5 + (*(_DWORD *)(a3 + 44))++) = v7;
      *(_DWORD *)(a3 + 28) <<= 8;
      *(_DWORD *)(a3 + 32) += 8;
    }
    while ( *(_DWORD *)(a3 + 32) <= 24 );
  }
  return result;
}

//----- (1005C720) --------------------------------------------------------
int __usercall sub_1005C720@<eax>(int a1@<esi>)
{
  int *v1; // edi@1
  unsigned int v2; // eax@2
  char v3; // bl@2
  int result; // eax@4

  v1 = (int *)(a1 + 52);
  do
  {
    v2 = *(_DWORD *)(a1 + 56);
    v3 = *(_BYTE *)(a1 + 87);
    if ( v2 >= *(_DWORD *)(a1 + 60) )
      sub_100943C0(v2 + 1, 0, a1 + 52, 1, 1u, 0);
    result = *v1;
    *(_BYTE *)(*v1 + (*(_DWORD *)(a1 + 56))++) = v3;
    *(_DWORD *)(a1 + 76) += 8;
    *(_DWORD *)(a1 + 84) <<= 8;
    *(_DWORD *)(a1 + 92) <<= 8;
  }
  while ( *(_DWORD *)(a1 + 92) < 0x1000000u );
  return result;
}

//----- (1005C770) --------------------------------------------------------
unsigned int __usercall sub_1005C770@<eax>(__int16 a1@<ax>, unsigned int *a2@<edi>, int a3@<esi>)
{
  __int16 v3; // bx@1
  unsigned int result; // eax@1
  unsigned int v5; // eax@3
  __int16 v6; // dx@8
  unsigned int v7; // eax@10
  __int16 v8; // bx@10

  v3 = a1;
  result = *a2;
  if ( *a2 )
  {
    if ( result >= 3 )
    {
      if ( result > 6 )
        v6 = (((_WORD)result - 7) << 8) | 0x14;
      else
        v6 = (((_WORD)result - 3) << 8) | 0x13;
      v7 = *(_DWORD *)(a3 + 4);
      v8 = v6;
      if ( v7 >= *(_DWORD *)(a3 + 8) )
        sub_100943C0(v7 + 1, 0, a3, 1, 2u, 0);
      result = *(_DWORD *)(a3 + 4);
      *(_WORD *)(*(_DWORD *)a3 + 2 * result) = v8;
      ++*(_DWORD *)(a3 + 4);
      *a2 = 0;
    }
    else
    {
      do
      {
        --*a2;
        v5 = *(_DWORD *)(a3 + 4);
        if ( v5 >= *(_DWORD *)(a3 + 8) )
          sub_100943C0(v5 + 1, 0, a3, 1, 2u, 0);
        result = *(_DWORD *)(a3 + 4);
        *(_WORD *)(*(_DWORD *)a3 + 2 * result) = v3;
        ++*(_DWORD *)(a3 + 4);
      }
      while ( *a2 );
      --*a2;
      *a2 = 0;
    }
  }
  return result;
}

//----- (1005C810) --------------------------------------------------------
char __usercall sub_1005C810@<al>(unsigned int *a1@<edi>, int a2@<esi>)
{
  unsigned int v2; // eax@1
  unsigned int v3; // eax@3
  __int16 v4; // ax@8
  __int16 v5; // bx@10

  v2 = *a1;
  if ( *a1 )
  {
    if ( v2 >= 3 )
    {
      if ( v2 > 0xA )
        v4 = (((_WORD)v2 - 11) << 8) | 0x12;
      else
        v4 = (((_WORD)v2 - 3) << 8) | 0x11;
      v5 = v4;
      v2 = *(_DWORD *)(a2 + 4);
      if ( v2 >= *(_DWORD *)(a2 + 8) )
        LOBYTE(v2) = sub_100943C0(v2 + 1, 0, a2, 1, 2u, 0);
      *(_WORD *)(*(_DWORD *)a2 + 2 * (*(_DWORD *)(a2 + 4))++) = v5;
      *a1 = 0;
    }
    else
    {
      do
      {
        --*a1;
        v3 = *(_DWORD *)(a2 + 4);
        if ( v3 >= *(_DWORD *)(a2 + 8) )
          sub_100943C0(v3 + 1, 0, a2, 1, 2u, 0);
        v2 = *(_DWORD *)(a2 + 4);
        *(_WORD *)(*(_DWORD *)a2 + 2 * v2) = 0;
        ++*(_DWORD *)(a2 + 4);
      }
      while ( *a1 );
      --*a1;
      *a1 = 0;
    }
  }
  return v2;
}

//----- (1005C8A0) --------------------------------------------------------
char *__userpurge sub_1005C8A0@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // eax@1
  int v3; // eax@3
  char *result; // eax@7

  *(_DWORD *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 32;
  v2 = *(_DWORD *)(a1 + 44);
  if ( v2 )
  {
    if ( !v2 )
      v3 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a1 + 44) = 0;
  }
  sub_10032F10(a1 + 40, a2);
  if ( *(_DWORD *)(a1 + 68) )
    *(_DWORD *)(a1 + 68) = 0;
  result = *(char **)(a1 + 56);
  if ( result )
  {
    if ( (unsigned int)result <= 0 )
      result = (char *)memset(&result[*(_DWORD *)(a1 + 52)], 0, -(signed int)result);
    *(_DWORD *)(a1 + 56) = 0;
  }
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 92) = -1;
  return result;
}

//----- (1005C930) --------------------------------------------------------
char __userpurge sub_1005C930@<al>(unsigned int a1@<esi>, int a2, int a3, unsigned int a4)
{
  int v4; // ecx@1
  int v5; // ebx@1
  unsigned int v6; // eax@5
  unsigned int v7; // edi@5
  int v8; // edx@6
  char result; // al@12
  unsigned int v10; // eax@16
  unsigned int v11; // ecx@19
  unsigned int v12; // eax@20
  unsigned __int64 v13; // rax@21
  FILE *v14; // eax@27
  char v15; // [sp+Fh] [bp-229h]@25
  unsigned int v16; // [sp+10h] [bp-228h]@19
  int v17; // [sp+14h] [bp-224h]@1
  int v18; // [sp+18h] [bp-220h]@1
  int v19; // [sp+1Ch] [bp-21Ch]@1
  int v20; // [sp+24h] [bp-214h]@22
  char DstBuf; // [sp+28h] [bp-210h]@27
  int v22; // [sp+234h] [bp-4h]@5

  v4 = 0;
  v5 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  if ( a1 )
  {
    if ( a1 )
    {
      sub_100943C0(a1, 0, (int)&v17, a1 == 1, 2u, 0);
      v4 = v18;
      v5 = v17;
    }
    memset((void *)(v5 + 2 * v4), 0, 2 * (a1 - v4));
    v18 = a1;
  }
  v6 = 0;
  v7 = 0;
  v22 = 0;
  if ( !a1 )
    goto LABEL_33;
  do
  {
    v8 = a3;
    if ( v7 <= *(_DWORD *)(a3 + 4 * v6) )
      v7 = *(_DWORD *)(a3 + 4 * v6);
    ++v6;
  }
  while ( v6 < a1 );
  if ( v7 )
  {
    if ( v7 > 0xFFFF )
    {
      v11 = 0;
      v16 = 0;
      do
      {
        v12 = *(_DWORD *)(v8 + 4 * v11);
        if ( v12 )
        {
          v13 = ((v7 >> 1) + 0xFFFF * (unsigned __int64)v12) / v7;
          if ( v13 < 1 )
          {
            LOWORD(v13) = 1;
            v20 = 0;
          }
          v5 = v17;
          v11 = v16;
          v8 = a3;
          *(_WORD *)(v17 + 2 * v16) = v13;
        }
        v16 = ++v11;
      }
      while ( v11 < a1 );
    }
    else
    {
      v10 = 0;
      do
      {
        *(_WORD *)(v5 + 2 * v10) = *(_WORD *)(a3 + 4 * v10);
        ++v10;
      }
      while ( v10 < a1 );
    }
    v15 = sub_1005C320(a1, a2, v5, a4);
    v22 = -1;
    if ( v5 )
    {
      if ( v5 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v14 = _iob_func();
        fputs(&DstBuf, v14 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      }
    }
    result = v15;
  }
  else
  {
LABEL_33:
    v22 = -1;
    if ( v5 )
    {
      if ( v5 & 7 )
      {
        sub_100927E0((int)"crnlib_free: bad ptr");
        return 0;
      }
      off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
    }
    result = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1005CB70) --------------------------------------------------------
char __usercall sub_1005CB70@<al>(int a1@<esi>)
{
  signed int v1; // ecx@1
  unsigned int v2; // eax@1
  char v3; // bl@2

  *(_DWORD *)(a1 + 32) -= 7;
  v1 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 76) += 7;
  LOBYTE(v2) = 0;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 28);
  if ( v1 <= 24 )
  {
    do
    {
      v2 = *(_DWORD *)(a1 + 44);
      v3 = *(_BYTE *)(a1 + 31);
      if ( v2 >= *(_DWORD *)(a1 + 48) )
        LOBYTE(v2) = sub_100943C0(v2 + 1, 0, a1 + 40, 1, 1u, 0);
      *(_BYTE *)(*(_DWORD *)(a1 + 40) + (*(_DWORD *)(a1 + 44))++) = v3;
      *(_DWORD *)(a1 + 28) <<= 8;
      *(_DWORD *)(a1 + 32) += 8;
    }
    while ( *(_DWORD *)(a1 + 32) <= 24 );
  }
  return v2;
}

//----- (1005CC00) --------------------------------------------------------
int __usercall sub_1005CC00@<eax>(int result@<eax>)
{
  int v1; // esi@1
  unsigned int v2; // eax@2
  int v3; // eax@6
  int v4; // ecx@7
  unsigned int v5; // eax@12

  v1 = result;
  if ( *(_DWORD *)(result + 96) )
  {
    v2 = *(_DWORD *)(result + 84);
    if ( *(_DWORD *)(v1 + 92) <= 0x2000000u )
    {
      *(_DWORD *)(v1 + 84) = v2 + 0x800000;
      *(_DWORD *)(v1 + 92) = 0x8000;
    }
    else
    {
      *(_DWORD *)(v1 + 84) = v2 + 0x1000000;
      *(_DWORD *)(v1 + 92) = 0x800000;
    }
    if ( v2 > *(_DWORD *)(v1 + 84) )
    {
      v3 = *(_DWORD *)(v1 + 56) - 1;
      if ( v3 >= 0 )
      {
        while ( 1 )
        {
          v4 = *(_DWORD *)(v1 + 52);
          if ( *(_BYTE *)(v4 + v3) != -1 )
            break;
          *(_BYTE *)(v4 + --v3 + 1) = 0;
          if ( v3 < 0 )
            goto LABEL_11;
        }
        ++*(_BYTE *)(v3 + *(_DWORD *)(v1 + 52));
      }
    }
LABEL_11:
    for ( result = sub_1005C720(v1); *(_DWORD *)(v1 + 56) < 4u; *(_DWORD *)(v1 + 76) += 8 )
    {
      v5 = *(_DWORD *)(v1 + 56);
      if ( v5 >= *(_DWORD *)(v1 + 60) )
        sub_100943C0(v5 + 1, 0, v1 + 52, 1, 1u, 0);
      result = *(_DWORD *)(v1 + 56);
      *(_BYTE *)(result + *(_DWORD *)(v1 + 52)) = 0;
      ++*(_DWORD *)(v1 + 56);
    }
  }
  return result;
}

//----- (1005CCA0) --------------------------------------------------------
int __userpurge sub_1005CCA0@<eax>(int a1@<eax>, unsigned int *a2@<ecx>, int a3)
{
  unsigned int *v3; // edi@1
  unsigned int v4; // edx@1
  unsigned int v5; // ecx@1
  _BYTE *v6; // eax@2
  unsigned int v7; // ecx@7
  unsigned int v8; // eax@7
  unsigned int v9; // ecx@11
  int result; // eax@11
  _BYTE *v11; // ecx@14
  signed int v12; // ebp@14
  signed int v13; // ebx@16
  unsigned int v14; // eax@22
  unsigned int v15; // ebp@28
  unsigned int v16; // edx@28
  unsigned int i; // ecx@28
  FILE *v18; // eax@33
  unsigned int v19; // ebx@37
  unsigned int v20; // eax@40
  int v21; // ecx@40
  unsigned int v22; // ecx@42
  unsigned int v23; // eax@42
  unsigned int v24; // eax@47
  int v25; // eax@49
  int v26; // ecx@50
  int v27; // ebx@53
  unsigned int v28; // eax@54
  int v29; // eax@56
  int v30; // edx@57
  __int16 v31; // ax@61
  unsigned int v32; // ebp@61
  unsigned int v33; // edi@61
  int v34; // ecx@69
  int v35; // ebx@69
  unsigned int v36; // eax@71
  int v37; // eax@73
  int v38; // ecx@74
  FILE *v39; // eax@81
  unsigned int v40; // [sp+0h] [bp-294h]@14
  unsigned int v41; // [sp+0h] [bp-294h]@40
  unsigned int v42; // [sp+0h] [bp-294h]@60
  int v43; // [sp+4h] [bp-290h]@14
  void *v44; // [sp+8h] [bp-28Ch]@14
  unsigned int v45; // [sp+Ch] [bp-288h]@14
  unsigned int v46; // [sp+10h] [bp-284h]@14
  _BYTE *v47; // [sp+14h] [bp-280h]@14
  int v48; // [sp+18h] [bp-27Ch]@47
  unsigned int v49; // [sp+1Ch] [bp-278h]@6
  int v50; // [sp+20h] [bp-274h]@14
  int v51; // [sp+24h] [bp-270h]@30
  int v52; // [sp+28h] [bp-26Ch]@30
  int v53; // [sp+2Ch] [bp-268h]@30
  int v54; // [sp+30h] [bp-264h]@30
  int v55; // [sp+34h] [bp-260h]@30
  int v56; // [sp+38h] [bp-25Ch]@30
  int v57; // [sp+3Ch] [bp-258h]@30
  int v58; // [sp+40h] [bp-254h]@30
  char v59; // [sp+44h] [bp-250h]@30
  int v60; // [sp+48h] [bp-24Ch]@14
  int v61; // [sp+4Ch] [bp-248h]@14
  int v62; // [sp+50h] [bp-244h]@14
  __int16 v63[22]; // [sp+54h] [bp-240h]@28
  char DstBuf; // [sp+80h] [bp-214h]@33
  int v65; // [sp+288h] [bp-Ch]@1
  int (__thiscall *v66)(void *); // [sp+28Ch] [bp-8h]@1
  int v67; // [sp+290h] [bp-4h]@1

  v67 = -1;
  v66 = sub_1009698B;
  v65 = a1;
  v3 = a2;
  v4 = *a2;
  v5 = *a2;
  if ( !v5 )
    goto LABEL_7;
  v6 = (_BYTE *)(v3[4] + v5 - 1);
  while ( !*v6 )
  {
    --v5;
    --v6;
    if ( v5 <= 0 )
      goto LABEL_7;
  }
  v49 = v5;
  if ( !v5 )
  {
LABEL_7:
    v7 = 0x2000;
    v8 = 0;
    do
    {
      v7 >>= 1;
      ++v8;
    }
    while ( v7 > 0 );
    if ( v8 )
      sub_1005C1B0(v8, a3, 0);
    v9 = 0x2000;
    result = 0;
    do
    {
      v9 >>= 1;
      ++result;
    }
    while ( v9 > 0 );
    return result;
  }
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v67 = 0;
  sub_10035640((int)&v44, v4);
  v11 = (_BYTE *)v3[4];
  v12 = -1;
  v50 = 0;
  v43 = 0;
  v47 = v11;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  LOBYTE(v67) = 1;
  v40 = 0;
  do
  {
    if ( v40 >= v49 )
    {
      v13 = 255;
    }
    else
    {
      v13 = *v47++;
      if ( !v13 )
      {
        sub_1005C770(v12, (unsigned int *)&v43, (int)&v44);
        if ( ++v50 == 138 )
          sub_1005C810((unsigned int *)&v50, (int)&v44);
        goto LABEL_27;
      }
    }
    sub_1005C810((unsigned int *)&v50, (int)&v44);
    if ( v13 == v12 )
    {
      if ( ++v43 == 70 )
        sub_1005C770(v12, (unsigned int *)&v43, (int)&v44);
    }
    else
    {
      sub_1005C770(v12, (unsigned int *)&v43, (int)&v44);
      if ( v13 != 255 )
      {
        v14 = v45;
        if ( v45 >= v46 )
        {
          sub_100943C0(v45 + 1, 0, (int)&v44, 1, 2u, 0);
          v14 = v45;
        }
        *((_WORD *)v44 + v14) = v13;
        v45 = v14 + 1;
      }
    }
LABEL_27:
    v12 = v13;
    ++v40;
  }
  while ( v40 <= v49 );
  v15 = 0;
  memset(v63, 0, 0x2Au);
  v16 = v45;
  for ( i = 0; i < v16; ++i )
    ++v63[(unsigned __int8)*((_WORD *)v44 + i)];
  v51 = 0;
  v52 = 0;
  v53 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  LOBYTE(v67) = 2;
  if ( sub_1005C320(0x15u, (int)&v51, (int)v63, 7u) )
  {
    v19 = 21;
    do
    {
      if ( *(_BYTE *)(byte_10099BBC[v19 - 21] + v55) )
        break;
      --v19;
    }
    while ( v19 );
    v41 = v19;
    v20 = 0x2000;
    v21 = 0;
    do
    {
      v20 >>= 1;
      ++v21;
    }
    while ( v20 > 0 );
    v43 = v19 + v21 + 2 * v19 + 5;
    v22 = 0x2000;
    v23 = 0;
    do
    {
      v22 >>= 1;
      ++v23;
    }
    while ( v22 > 0 );
    if ( v23 )
      sub_1005C1B0(v23, a3, v49);
    *(_DWORD *)(a3 + 76) += 5;
    if ( !*(_BYTE *)(a3 + 80) )
    {
      v24 = *(_DWORD *)(a3 + 68);
      v48 = 5;
      if ( v24 >= *(_DWORD *)(a3 + 72) )
        sub_100943C0(v24 + 1, 0, a3 + 64, 1, 8u, 0);
      v25 = *(_DWORD *)(a3 + 64) + 8 * *(_DWORD *)(a3 + 68);
      if ( v25 )
      {
        v26 = v48;
        *(_DWORD *)v25 = v19;
        *(_DWORD *)(v25 + 4) = v26;
      }
      ++*(_DWORD *)(a3 + 68);
    }
    if ( v19 > 0 )
    {
      do
      {
        v27 = *(_BYTE *)((unsigned __int8)byte_10099BA8[v15] + v55);
        *(_DWORD *)(a3 + 76) += 3;
        if ( !*(_BYTE *)(a3 + 80) )
        {
          v28 = *(_DWORD *)(a3 + 68);
          v48 = 3;
          if ( v28 >= *(_DWORD *)(a3 + 72) )
            sub_100943C0(v28 + 1, 0, a3 + 64, 1, 8u, 0);
          v29 = *(_DWORD *)(a3 + 64) + 8 * *(_DWORD *)(a3 + 68);
          if ( v29 )
          {
            v30 = v48;
            *(_DWORD *)v29 = v27;
            *(_DWORD *)(v29 + 4) = v30;
          }
          ++*(_DWORD *)(a3 + 68);
        }
        ++v15;
      }
      while ( v15 < v41 );
    }
    v42 = 0;
    if ( v45 )
    {
      do
      {
        v31 = *((_WORD *)v44 + v42);
        v32 = (unsigned int)*((_WORD *)v44 + v42) >> 8;
        v33 = 0;
        switch ( (unsigned __int8)v31 )
        {
          case 0x11u:
            v33 = 3;
            break;
          case 0x12u:
            v33 = 7;
            break;
          case 0x13u:
            v33 = 2;
            break;
          case 0x14u:
            v33 = 6;
            break;
        }
        v34 = *(_BYTE *)(v55 + (unsigned __int8)v31);
        v43 += v34;
        v35 = *(_WORD *)(v52 + 2 * (unsigned __int8)v31);
        if ( v34 )
        {
          *(_DWORD *)(a3 + 76) += v34;
          if ( !*(_BYTE *)(a3 + 80) )
          {
            v36 = *(_DWORD *)(a3 + 68);
            v48 = (unsigned __int16)v34;
            if ( v36 >= *(_DWORD *)(a3 + 72) )
              sub_100943C0(v36 + 1, 0, a3 + 64, 1, 8u, 0);
            v37 = *(_DWORD *)(a3 + 64) + 8 * *(_DWORD *)(a3 + 68);
            if ( v37 )
            {
              v38 = v48;
              *(_DWORD *)v37 = v35;
              *(_DWORD *)(v37 + 4) = v38;
            }
            ++*(_DWORD *)(a3 + 68);
          }
        }
        if ( v33 )
        {
          sub_1005C1B0(v33, a3, v32);
          v43 += v33;
        }
        ++v42;
      }
      while ( v42 < v45 );
    }
    LOBYTE(v67) = 1;
    sub_1005C5A0(&v51);
    v67 = -1;
    if ( v44 )
    {
      if ( (unsigned __int8)v44 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v39 = _iob_func();
        fputs(&DstBuf, v39 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v44, 0, 0, 1, dword_100AE9F4);
      }
    }
    result = v43;
  }
  else
  {
    LOBYTE(v67) = 1;
    sub_1005C5A0(&v51);
    v67 = -1;
    if ( v44 )
    {
      if ( (unsigned __int8)v44 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v18 = _iob_func();
        fputs(&DstBuf, v18 + 2);
        if ( IsDebuggerPresent() )
        {
          DebugBreak();
          return 0;
        }
      }
      else
      {
        off_100AD9F4(v44, 0, 0, 1, dword_100AE9F4);
      }
    }
    result = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 1005CCA0: using guessed type __int16 var_240[22];

//----- (1005D260) --------------------------------------------------------
char __usercall sub_1005D260@<al>(int a1@<eax>)
{
  int v1; // esi@1
  unsigned int v2; // eax@1
  int v3; // ebx@2
  int v4; // eax@3
  int v5; // edx@4
  signed int v6; // ecx@5
  unsigned int v7; // eax@6
  char v8; // bl@6
  int v9; // ebp@13
  signed int v10; // ecx@15
  unsigned int v11; // eax@16
  char v12; // bl@16
  int v13; // edx@20
  bool v14; // cf@20
  int v15; // edx@21
  int v16; // edi@21
  unsigned int v17; // eax@21
  FILE *v18; // eax@25
  int v19; // edx@27
  signed int v20; // ecx@28
  unsigned int v21; // eax@29
  char v22; // bl@29
  unsigned int v24; // [sp+4h] [bp-20Ch]@1
  unsigned int v25; // [sp+8h] [bp-208h]@1
  int v26; // [sp+Ch] [bp-204h]@2
  char DstBuf; // [sp+10h] [bp-200h]@25

  v1 = a1;
  v2 = 0;
  *(_DWORD *)(v1 + 76) = 0;
  v24 = 0;
  v25 = 0;
  if ( *(_DWORD *)(v1 + 68) )
  {
    do
    {
      v3 = *(_DWORD *)(v1 + 64) + 8 * v2;
      LOWORD(v2) = *(_WORD *)(v3 + 4);
      v26 = v3;
      if ( (_WORD)v2 == -2 )
      {
        v4 = (32 - *(_DWORD *)(v1 + 32)) & 7;
        if ( v4 )
        {
          v5 = 8 - v4;
          if ( 8 != v4 )
          {
            *(_DWORD *)(v1 + 32) -= v5;
            v6 = *(_DWORD *)(v1 + 32);
            *(_DWORD *)(v1 + 76) += v5;
            *(_DWORD *)(v1 + 28) = *(_DWORD *)(v1 + 28);
            if ( v6 <= 24 )
            {
              do
              {
                v7 = *(_DWORD *)(v1 + 44);
                v8 = *(_BYTE *)(v1 + 31);
                if ( v7 >= *(_DWORD *)(v1 + 48) )
                  sub_100943C0(v7 + 1, 0, v1 + 40, 1, 1u, 0);
                *(_BYTE *)((*(_DWORD *)(v1 + 44))++ + *(_DWORD *)(v1 + 40)) = v8;
                *(_DWORD *)(v1 + 28) <<= 8;
                *(_DWORD *)(v1 + 32) += 8;
              }
              while ( *(_DWORD *)(v1 + 32) <= 24 );
            }
          }
        }
      }
      else if ( (_WORD)v2 == -1 )
      {
        if ( *(_DWORD *)(v1 + 92) < 0x1000000u )
        {
          do
          {
            if ( v24 >= *(_DWORD *)(v1 + 56) )
              v9 = 0;
            else
              v9 = *(_BYTE *)(*(_DWORD *)(v1 + 52) + v24++);
            *(_DWORD *)(v1 + 32) -= 8;
            v10 = *(_DWORD *)(v1 + 32);
            *(_DWORD *)(v1 + 76) += 8;
            *(_DWORD *)(v1 + 28) |= v9 << v10;
            if ( v10 <= 24 )
            {
              do
              {
                v11 = *(_DWORD *)(v1 + 44);
                v12 = *(_BYTE *)(v1 + 31);
                if ( v11 >= *(_DWORD *)(v1 + 48) )
                  sub_100943C0(v11 + 1, 0, v1 + 40, 1, 1u, 0);
                *(_BYTE *)((*(_DWORD *)(v1 + 44))++ + *(_DWORD *)(v1 + 40)) = v12;
                *(_DWORD *)(v1 + 28) <<= 8;
                *(_DWORD *)(v1 + 32) += 8;
              }
              while ( *(_DWORD *)(v1 + 32) <= 24 );
              v3 = v26;
            }
            v13 = *(_DWORD *)(v1 + 88);
            *(_DWORD *)(v1 + 92) <<= 8;
            v14 = *(_DWORD *)(v1 + 92) < 0x1000000u;
            *(_DWORD *)(v1 + 88) = v9 | (v13 << 8);
          }
          while ( v14 );
        }
        v15 = *(_DWORD *)(v1 + 92);
        v16 = *(_DWORD *)(v1 + 88);
        v17 = (*(_DWORD *)(v1 + 92) >> 11) * *(_WORD *)(v3 + 6);
        if ( v16 >= v17 )
        {
          *(_DWORD *)(v1 + 88) = v16 - v17;
          *(_DWORD *)(v1 + 92) = v15 - v17;
        }
        else
        {
          *(_DWORD *)(v1 + 92) = v17;
        }
        if ( v16 >= v17 != *(_DWORD *)v3 )
        {
          sprintf_s(
            &DstBuf,
            0x200u,
            "%s(%u): Assertion failed: \"%s\"\n",
            "crn_symbol_codec.cpp",
            1289,
            "bit == sym.m_bits");
          OutputDebugStringA(&DstBuf);
          v18 = _iob_func();
          fputs(&DstBuf, v18 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
      }
      else
      {
        v19 = *(_DWORD *)v3;
        v2 = (signed __int16)v2;
        if ( (_WORD)v2 )
        {
          *(_DWORD *)(v1 + 32) -= v2;
          v20 = *(_DWORD *)(v1 + 32);
          *(_DWORD *)(v1 + 76) += v2;
          *(_DWORD *)(v1 + 28) |= v19 << v20;
          if ( v20 <= 24 )
          {
            do
            {
              v21 = *(_DWORD *)(v1 + 44);
              v22 = *(_BYTE *)(v1 + 31);
              if ( v21 >= *(_DWORD *)(v1 + 48) )
                sub_100943C0(v21 + 1, 0, v1 + 40, 1, 1u, 0);
              *(_BYTE *)((*(_DWORD *)(v1 + 44))++ + *(_DWORD *)(v1 + 40)) = v22;
              *(_DWORD *)(v1 + 28) <<= 8;
              *(_DWORD *)(v1 + 32) += 8;
            }
            while ( *(_DWORD *)(v1 + 32) <= 24 );
          }
        }
      }
      v2 = v25 + 1;
      v25 = v2;
    }
    while ( v2 < *(_DWORD *)(v1 + 68) );
  }
  return sub_1005CB70(v1);
}

//----- (1005D4D0) --------------------------------------------------------
bool __userpurge sub_1005D4D0@<al>(int a1@<ebx>, unsigned int a2@<edi>, int a3@<esi>, int a4)
{
  int (__cdecl *v4)(int, signed int, int, unsigned int, _DWORD); // ecx@1
  unsigned int v5; // eax@3
  bool result; // al@7

  v4 = *(int (__cdecl **)(int, signed int, int, unsigned int, _DWORD))(a3 + 176);
  if ( !v4 )
    goto LABEL_13;
  if ( a2 <= 1 )
    v5 = 100;
  else
    v5 = 100 * a1 / (a2 - 1);
  if ( a4 == *(_DWORD *)(a3 + 528) && *(_DWORD *)(a3 + 532) == v5 )
    return *(_BYTE *)(a3 + 520) == 0;
  *(_DWORD *)(a3 + 532) = v5;
  if ( v4(a4, 25, a1, a2, *(_DWORD *)(a3 + 180)) )
  {
LABEL_13:
    result = 1;
  }
  else
  {
    *(_BYTE *)(a3 + 520) = 1;
    result = 0;
  }
  return result;
}

//----- (1005D550) --------------------------------------------------------
void __thiscall sub_1005D550(int this, int a2, int a3, int a4)
{
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  int v6; // eax@9
  int (__cdecl *v7)(signed int, signed int, int, unsigned int, int); // edi@9
  unsigned int v8; // ecx@9
  int v9; // esi@9
  unsigned int v10; // eax@11
  int v11; // eax@16
  int v12; // ebx@18
  unsigned int v13; // edi@18
  int v14; // ST10_4@25
  unsigned int v15; // [sp+8h] [bp-1Ch]@3
  int v16; // [sp+Ch] [bp-18h]@4
  int v17; // [sp+10h] [bp-14h]@4
  int v18; // [sp+14h] [bp-10h]@1
  _DWORD *v19; // [sp+18h] [bp-Ch]@2
  _DWORD *v20; // [sp+1Ch] [bp-8h]@2
  _WORD *v21; // [sp+20h] [bp-4h]@19

  v4 = 0;
  v5 = this;
  v18 = 0;
  if ( *(_DWORD *)(this + 204) )
  {
    v20 = (_DWORD *)(a4 + 144);
    v19 = (_DWORD *)(this + 224);
    while ( 1 )
    {
      v15 = 0;
      if ( *(_DWORD *)(v5 + 184) > 0u )
        break;
LABEL_23:
      v19 += 3;
      v20 += 3;
      if ( (unsigned int)++v18 >= *(_DWORD *)(v5 + 204) )
        return;
      v4 = 0;
    }
    v17 = 0;
    v16 = 0;
    while ( !*(_BYTE *)(v5 + 520) )
    {
      if ( GetCurrentThreadId() == *(_DWORD *)(v5 + 512) && 0 == *(_DWORD *)(v5 + 516) && !(v4 & 0x3F) )
      {
        v6 = *(_DWORD *)(v5 + 184);
        v7 = *(int (__cdecl **)(signed int, signed int, int, unsigned int, int))(v5 + 176);
        v8 = v6 * *(_DWORD *)(v5 + 204);
        v9 = v4 + v18 * v6;
        if ( v7 )
        {
          if ( v8 <= 1 )
          {
            v10 = 100;
          }
          else
          {
            v10 = 100 * v9 / (v8 - 1);
            v4 = v15;
          }
          if ( *(_DWORD *)(v5 + 528) != 7 || *(_DWORD *)(v5 + 532) != v10 )
          {
            v14 = *(_DWORD *)(v5 + 180);
            *(_DWORD *)(v5 + 532) = v10;
            if ( !v7(7, 25, v9, v8, v14) )
            {
              *(_BYTE *)(v5 + 520) = 1;
              return;
            }
          }
          else if ( *(_BYTE *)(v5 + 520) )
          {
            return;
          }
        }
      }
      v11 = *(_DWORD *)(*(_DWORD *)(v5 + 524) + 4);
      if ( !v11 || v4 % (v11 + 1) == a2 )
      {
        v12 = v16 + *v19;
        v13 = 0;
        if ( *(_BYTE *)(v12 + 1) )
        {
          v21 = (_WORD *)(v12 + 644);
          do
          {
            *v21 = sub_10042140(*(_DWORD *)(*v20 + v17) + 8 * v13++, a4);
            ++v21;
          }
          while ( v13 < *(_BYTE *)(v12 + 1) );
        }
        v4 = v15;
      }
      v16 += 660;
      v17 += 12;
      v15 = ++v4;
      if ( v4 >= *(_DWORD *)(v5 + 184) )
        goto LABEL_23;
    }
  }
}

//----- (1005D730) --------------------------------------------------------
void __thiscall sub_1005D730(int this, int a2, int a3, int a4)
{
  int v4; // esi@1
  unsigned int v5; // ebx@1
  int v6; // eax@9
  int v7; // edi@11
  unsigned int v8; // ebp@11
  int v9; // ebx@12
  _WORD *v10; // esi@12
  unsigned int v11; // [sp+8h] [bp-10h]@1
  int v12; // [sp+Ch] [bp-Ch]@2
  int v13; // [sp+10h] [bp-8h]@2
  int v14; // [sp+14h] [bp-4h]@1

  v4 = this;
  v5 = 0;
  v14 = this;
  v11 = 0;
  if ( *(_DWORD *)(this + 184) )
  {
    v13 = 0;
    v12 = 0;
    do
    {
      if ( *(_BYTE *)(v4 + 520) )
        break;
      if ( GetCurrentThreadId() == *(_DWORD *)(v4 + 512) && 0 == *(_DWORD *)(v4 + 516) && !(v5 & 0x3F) )
      {
        if ( !sub_1005D4D0(v5, *(_DWORD *)(v4 + 184), v4, 2) )
          return;
        v5 = v11;
        v4 = v14;
      }
      v6 = *(_DWORD *)(*(_DWORD *)(v4 + 524) + 4);
      if ( !v6 || v5 % (v6 + 1) == a2 )
      {
        v7 = v12 + *(_DWORD *)(v4 + 212);
        v8 = 0;
        if ( *(_BYTE *)(v7 + 1) )
        {
          v9 = 0;
          v10 = (_WORD *)(v7 + 644);
          do
          {
            *v10 = sub_10042BA0(*(_DWORD *)a4, v9 + *(_DWORD *)(**(_DWORD **)(a4 + 4) + v13));
            ++v8;
            ++v10;
            v9 += 24;
          }
          while ( v8 < *(_BYTE *)(v7 + 1) );
          v5 = v11;
          v4 = v14;
        }
      }
      v12 += 660;
      v13 += 12;
      v11 = ++v5;
    }
    while ( v5 < *(_DWORD *)(v4 + 184) );
  }
}

//----- (1005D840) --------------------------------------------------------
char __stdcall sub_1005D840(int a1)
{
  int v1; // esi@1
  unsigned int v2; // ebx@1
  unsigned int v4; // edi@3
  unsigned int v5; // edi@10
  unsigned int v6; // eax@11
  int v7; // ecx@11
  int v8; // edx@11
  unsigned int v9; // ebx@12
  int v10; // ebx@13
  int v11; // ebp@14
  int v12; // ecx@14
  int v13; // edx@14
  unsigned int v14; // esi@14
  unsigned int v15; // ecx@14
  int v16; // eax@17
  int v17; // [sp+8h] [bp-5Ch]@4
  unsigned int v18; // [sp+Ch] [bp-58h]@12
  int *v19; // [sp+10h] [bp-54h]@11
  unsigned int v20; // [sp+14h] [bp-50h]@9
  unsigned int v21; // [sp+18h] [bp-4Ch]@3
  int v22; // [sp+1Ch] [bp-48h]@4
  int v23; // [sp+20h] [bp-44h]@13
  unsigned int v24; // [sp+24h] [bp-40h]@11
  unsigned int v25; // [sp+28h] [bp-3Ch]@11
  unsigned int v26; // [sp+2Ch] [bp-38h]@11
  unsigned int v27; // [sp+30h] [bp-34h]@10
  int v28; // [sp+34h] [bp-30h]@9
  int v29; // [sp+38h] [bp-2Ch]@13
  int v30; // [sp+3Ch] [bp-28h]@11
  int v31; // [sp+40h] [bp-24h]@11
  unsigned int v32; // [sp+44h] [bp-20h]@11
  unsigned int v33; // [sp+48h] [bp-1Ch]@16
  unsigned int v34; // [sp+4Ch] [bp-18h]@16
  unsigned int v35; // [sp+50h] [bp-14h]@16
  unsigned int v36; // [sp+54h] [bp-10h]@16
  unsigned int v37; // [sp+58h] [bp-Ch]@16
  int v38; // [sp+5Ch] [bp-8h]@16
  int v39; // [sp+60h] [bp-4h]@16

  v1 = a1;
  v2 = 0;
  if ( !*(_DWORD *)(a1 + 204) )
    return 1;
  v4 = *(_DWORD *)(a1 + 324);
  v21 = 0;
  if ( v4 <= 0 )
    return 1;
  v17 = 0;
  v22 = 0;
  while ( (_BYTE)v2 )
  {
LABEL_8:
    if ( *(_DWORD *)(v17 + *(_DWORD *)(v1 + 344) + 4) )
    {
      v20 = 0;
      v28 = v22 + *(_DWORD *)(v1 + 320);
      do
      {
        v5 = 0;
        v27 = 0;
        do
        {
          v6 = 0;
          v7 = *(_DWORD *)(v1 + 344) + v17;
          v8 = *(_DWORD *)(v7 + 4);
          v26 = 0;
          v24 = -1;
          v25 = 0;
          v30 = *(_DWORD *)(v1 + 344) + v17;
          v31 = *(_DWORD *)(v7 + 4);
          v19 = (int *)&v32;
          do
          {
            v9 = 0;
            v18 = 0;
            if ( v8 )
            {
              v10 = *(_DWORD *)v7;
              v29 = *(_DWORD *)(v1 + 188);
              v23 = v8;
              do
              {
                v11 = *(_DWORD *)v10;
                v12 = *(_DWORD *)(a1 + 12 * *(_BYTE *)(v10 + 4) + 224) + 80 * *(_BYTE *)(v10 + 5);
                v13 = 660 * *(_DWORD *)v10;
                v14 = *(_DWORD *)(v12 + v13 + 328);
                v15 = *(_DWORD *)(v12 + v13 + 332);
                if ( v14 <= v15 )
                {
                  v34 = (v15 + 4 * v14) / 5;
                  v35 = (3 * v14 + 2 * v15) / 5;
                  v33 = v15;
                  v36 = (3 * v15 + 2 * v14) / 5;
                  v32 = v14;
                  v37 = (v14 + 4 * v15) / 5;
                  v38 = 0;
                  v39 = 255;
                }
                else
                {
                  sub_10092180(v15);
                  v5 = v27;
                }
                v16 = *(_BYTE *)(*(_DWORD *)(a1 + 4 * *(_BYTE *)(v10 + 4) + 28)
                               + 4
                               * (65 * v11
                                + ((v5 + 4 * *(_BYTE *)(v10 + 6)) & 3)
                                + 4
                                * (((v20 + 4 * *(_BYTE *)(v10 + 7)) & 3)
                                 + 4
                                 * (((v5 + 4 * *(_BYTE *)(v10 + 6)) >> 2) + 2 * ((v20 + 4 * *(_BYTE *)(v10 + 7)) >> 2))))
                               + v29)
                    - *v19;
                v10 += 8;
                v18 += v16 * v16;
                --v23;
              }
              while ( v23 );
              v1 = a1;
              v7 = v30;
              v6 = v25;
              v9 = v18;
              v8 = v31;
            }
            if ( v9 < v24 )
            {
              v24 = v9;
              v26 = v6;
            }
            ++v19;
            v25 = ++v6;
          }
          while ( v6 < 8 );
          if ( *(_BYTE *)(v28 + v5) != v26 )
            *(_BYTE *)(v28 + v5) = v26;
          v27 = ++v5;
        }
        while ( v5 < 4 );
        ++v20;
        v28 += 4;
      }
      while ( v20 < 4 );
      v2 = v21;
    }
    v4 = *(_DWORD *)(v1 + 324);
    v22 += 16;
    v17 += 12;
    v21 = ++v2;
    if ( v2 >= v4 )
      return 1;
  }
  if ( sub_1005D4D0(v2, v4, v1, 16) )
  {
    v2 = v21;
    goto LABEL_8;
  }
  return 0;
}
// 10092180: using guessed type double __thiscall sub_10092180(_DWORD);

//----- (1005DAE0) --------------------------------------------------------
char __stdcall sub_1005DAE0(int a1)
{
  int v1; // ebp@1
  unsigned int v2; // edi@1
  unsigned int v3; // ebx@1
  int v4; // ebx@5
  unsigned int v5; // esi@5
  int v6; // eax@10
  unsigned int v7; // edi@10
  _WORD *v8; // edx@11
  _WORD *v9; // ecx@11
  _WORD *v10; // ecx@14
  _WORD *v11; // eax@14
  signed int v12; // edx@14
  unsigned int v13; // edi@19
  unsigned int v14; // eax@19
  _DWORD *v15; // esi@19
  unsigned int v16; // eax@25
  int v17; // edx@26
  unsigned int v18; // edi@29
  unsigned int v19; // eax@29
  _DWORD *v20; // esi@29
  unsigned int v21; // eax@35
  int v22; // edx@36
  int v24; // [sp+10h] [bp-Ch]@2
  int v25; // [sp+14h] [bp-8h]@2
  unsigned int v26; // [sp+18h] [bp-4h]@1

  v1 = a1;
  sub_10041A90(*(_DWORD *)(a1 + 184), a1 + 192);
  v2 = *(_DWORD *)(a1 + 184);
  v3 = 0;
  v26 = 0;
  if ( v2 )
  {
    v25 = 0;
    v24 = 0;
    do
    {
      if ( !(_BYTE)v3 && !sub_1005D4D0(v3, v2, v1, 19) )
        return 0;
      v4 = v24 + *(_DWORD *)(v1 + 192);
      v5 = 0;
      do
      {
        if ( v5 )
        {
          if ( v5 > *(_DWORD *)(v1 + 204) )
            goto LABEL_16;
        }
        else if ( !*(_BYTE *)(v1 + 208) )
        {
          goto LABEL_16;
        }
        v6 = v25 + *(_DWORD *)(v1 + 12 * v5 + 212);
        v7 = 0;
        *(_BYTE *)v4 = *(_BYTE *)v6;
        *(_BYTE *)(v4 + 1) = *(_BYTE *)(v6 + 1);
        if ( *(_BYTE *)(v6 + 1) )
        {
          v8 = (_WORD *)(v6 + 324);
          v9 = (_WORD *)(v4 + 8 * v5 + 2);
          do
          {
            *v9 = *v8;
            ++v7;
            ++v9;
            v8 += 40;
          }
          while ( v7 < *(_BYTE *)(v6 + 1) );
          v1 = a1;
        }
        v10 = (_WORD *)(v4 + 8 * v5 + 28);
        v11 = (_WORD *)(v6 + 654);
        v12 = 2;
        do
        {
          *(v10 - 1) = *(v11 - 1);
          *v10 = *v11;
          v11 += 2;
          v10 += 2;
          --v12;
        }
        while ( v12 );
LABEL_16:
        ++v5;
      }
      while ( v5 < 3 );
      v2 = *(_DWORD *)(v1 + 184);
      v24 += 50;
      v25 += 660;
      v3 = v26 + 1;
      v26 = v3;
    }
    while ( v3 < v2 );
  }
  if ( *(_BYTE *)(v1 + 208) )
  {
    v13 = *(_DWORD *)(v1 + 288);
    v14 = *(_DWORD *)(v1 + 360);
    v15 = (_DWORD *)(v1 + 356);
    if ( v13 != v14 )
    {
      if ( v13 >= v14 )
      {
        if ( v13 > *(_DWORD *)(v1 + 364) )
          sub_100943C0(v13, 0, v1 + 356, v13 == v14 + 1, 4u, 0);
        memset((void *)(*v15 + 4 * *(_DWORD *)(v1 + 360)), 0, 4 * (v13 - *(_DWORD *)(v1 + 360)));
      }
      *(_DWORD *)(v1 + 360) = v13;
    }
    v16 = 0;
    if ( *(_DWORD *)(v1 + 288) )
    {
      v17 = 0;
      do
      {
        *(_DWORD *)(*v15 + 4 * v16++) = *(_DWORD *)(*(_DWORD *)(v1 + 284) + v17 + 12) | (*(_DWORD *)(*(_DWORD *)(v1 + 284) + v17 + 16) << 16);
        v17 += 40;
      }
      while ( v16 < *(_DWORD *)(v1 + 288) );
    }
  }
  if ( *(_DWORD *)(v1 + 204) )
  {
    v18 = *(_DWORD *)(v1 + 300);
    v19 = *(_DWORD *)(v1 + 372);
    v20 = (_DWORD *)(v1 + 368);
    if ( v18 != v19 )
    {
      if ( v18 >= v19 )
      {
        if ( v18 > *(_DWORD *)(v1 + 376) )
          sub_100943C0(v18, 0, v1 + 368, v18 == v19 + 1, 4u, 0);
        memset((void *)(*v20 + 4 * *(_DWORD *)(v1 + 372)), 0, 4 * (v18 - *(_DWORD *)(v1 + 372)));
      }
      *(_DWORD *)(v1 + 372) = v18;
    }
    v21 = 0;
    if ( *(_DWORD *)(v1 + 300) )
    {
      v22 = 0;
      do
      {
        *(_DWORD *)(*v20 + 4 * v21++) = *(_DWORD *)(*(_DWORD *)(v1 + 296) + v22 + 12) | (*(_DWORD *)(*(_DWORD *)(v1 + 296) + v22 + 16) << 8);
        v22 += 40;
      }
      while ( v21 < *(_DWORD *)(v1 + 300) );
    }
  }
  return 1;
}

//----- (1005DD50) --------------------------------------------------------
char __stdcall sub_1005DD50(int a1)
{
  int v1; // ebp@1
  char result; // al@2
  unsigned int v3; // edi@3
  unsigned int v4; // eax@3
  unsigned int v5; // esi@9
  unsigned int v6; // edx@10
  int v7; // eax@11
  unsigned int v8; // ecx@11
  int v9; // esi@12
  int v10; // ebx@12
  int v11; // eax@12
  int v12; // edx@12
  int v13; // ecx@12
  int v14; // edi@12
  unsigned int v15; // eax@15
  int v16; // ecx@15
  int v17; // edx@15
  int v18; // edx@15
  int v19; // eax@15
  int v20; // eax@16
  int v21; // [sp+4h] [bp-3Ch]@4
  unsigned int v22; // [sp+8h] [bp-38h]@10
  unsigned int v23; // [sp+Ch] [bp-34h]@11
  unsigned int v24; // [sp+10h] [bp-30h]@9
  unsigned int v25; // [sp+14h] [bp-2Ch]@8
  int v26; // [sp+18h] [bp-28h]@4
  unsigned int v27; // [sp+1Ch] [bp-24h]@10
  unsigned int v28; // [sp+20h] [bp-20h]@10
  int v29; // [sp+24h] [bp-1Ch]@8
  unsigned int v30; // [sp+28h] [bp-18h]@3
  int v31; // [sp+2Ch] [bp-14h]@12
  char v32; // [sp+30h] [bp-10h]@12
  char v33; // [sp+31h] [bp-Fh]@15
  char v34[14]; // [sp+32h] [bp-Eh]@15
  unsigned int v35; // [sp+44h] [bp+4h]@11

  v1 = a1;
  if ( *(_BYTE *)(a1 + 208) )
  {
    v3 = *(_DWORD *)(a1 + 312);
    v4 = 0;
    v30 = 0;
    if ( v3 )
    {
      v21 = 0;
      v26 = 0;
      while ( (_BYTE)v4 || sub_1005D4D0(v4, v3, v1, 15) )
      {
        if ( *(_DWORD *)(v21 + *(_DWORD *)(v1 + 332) + 4) )
        {
          v25 = 0;
          v29 = v26 + *(_DWORD *)(v1 + 308);
          do
          {
            v5 = 0;
            v24 = 0;
            do
            {
              v6 = 0;
              v28 = 0;
              v27 = -1;
              v22 = 0;
              do
              {
                v7 = v21 + *(_DWORD *)(v1 + 332);
                v8 = 0;
                v35 = 0;
                v23 = 0;
                if ( *(_DWORD *)(v7 + 4) > 0u )
                {
                  do
                  {
                    v9 = *(_DWORD *)(*(_DWORD *)v7 + 8 * v23);
                    v10 = *(_BYTE *)(*(_DWORD *)v7 + 8 * v23 + 6);
                    v11 = *(_DWORD *)v7 + 8 * v23;
                    v12 = 660 * v9 + 80 * *(_BYTE *)(v11 + 5);
                    v31 = *(_BYTE *)(v11 + 7);
                    v13 = *(_DWORD *)(v1 + 212);
                    v14 = v12 + v13 + 324;
                    sub_100924B0(*(_WORD *)(v12 + v13 + 328), (int)&v32, *(_WORD *)(v12 + v13 + 332));
                    if ( *(_DWORD *)(v14 + 4) == *(_DWORD *)(v14 + 8) && v22 == 3 )
                      v35 += 999999;
                    v15 = *(_DWORD *)(v1 + 188)
                        + 4
                        * (65 * v9
                         + ((v24 + 4 * v10) & 3)
                         + 4 * (((v25 + 4 * v31) & 3) + 4 * (((v24 + 4 * v10) >> 2) + 2 * ((v25 + 4 * v31) >> 2))));
                    v16 = *(_BYTE *)v15 - (unsigned __int8)*(&v32 + 4 * v22);
                    v17 = *(_BYTE *)(v15 + 1) - (unsigned __int8)*(&v33 + 4 * v22);
                    v18 = v17 * v17;
                    v19 = (*(_BYTE *)(v15 + 2) - (unsigned __int8)v34[4 * v22])
                        * (*(_BYTE *)(v15 + 2) - (unsigned __int8)v34[4 * v22]);
                    if ( *(_BYTE *)(v1 + 173) )
                      v20 = v19 + 25 * v18 + 8 * v16 * v16;
                    else
                      v20 = v16 * v16 + v18 + v19;
                    v35 += v20;
                    v7 = v21 + *(_DWORD *)(v1 + 332);
                    ++v23;
                  }
                  while ( v23 < *(_DWORD *)(v7 + 4) );
                  v5 = v24;
                  v8 = v35;
                  v6 = v22;
                }
                if ( v8 < v27 )
                {
                  v27 = v8;
                  v28 = v6;
                }
                v22 = ++v6;
              }
              while ( v6 < 4 );
              if ( *(_BYTE *)(v29 + v5) != v28 )
                *(_BYTE *)(v29 + v5) = v28;
              v24 = ++v5;
            }
            while ( v5 < 4 );
            ++v25;
            v29 += 4;
          }
          while ( v25 < 4 );
        }
        v3 = *(_DWORD *)(v1 + 312);
        v26 += 16;
        v21 += 12;
        v4 = v30 + 1;
        v30 = v4;
        if ( v4 >= v3 )
          goto LABEL_28;
      }
      result = 0;
    }
    else
    {
LABEL_28:
      result = 1;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}
// 1005DD50: using guessed type char var_E[14];

//----- (1005DFC0) --------------------------------------------------------
void __thiscall sub_1005DFC0(char *this, int a2, int a3, int a4)
{
  int v4; // ebx@1
  unsigned int v5; // edi@1
  int v6; // esi@1
  char v7; // al@3
  int v8; // eax@17
  int v9; // edx@19
  int v10; // edx@20
  char *v11; // eax@22
  int v12; // ecx@22
  int v13; // edi@23
  unsigned int v14; // esi@23
  unsigned int v15; // eax@26
  int v16; // edi@27
  int v17; // edx@27
  int v18; // edi@27
  __int32 *v19; // esi@29
  int v20; // ecx@30
  int v21; // edi@30
  int v22; // esi@33
  _BYTE *v23; // edi@33
  unsigned int v24; // ecx@33
  unsigned int v25; // edx@34
  int v26; // eax@35
  int v27; // edi@44
  unsigned int v28; // eax@44
  int v29; // eax@46
  unsigned int v30; // eax@52
  char v31; // cl@53
  int v32; // edi@53
  int v33; // edx@53
  int v34; // edi@53
  __int32 *v35; // esi@55
  int v36; // ecx@56
  int v37; // edi@56
  int v38; // eax@59
  _BYTE *v39; // ecx@59
  unsigned int v40; // edx@59
  unsigned int v41; // esi@60
  int v42; // eax@61
  int v43; // edx@64
  int v44; // edi@64
  int v45; // ebx@64
  int v46; // edi@64
  int v47; // eax@64
  int v48; // eax@65
  int *v49; // eax@76
  int v50; // edx@76
  unsigned int v51; // eax@76
  bool v52; // cf@76
  int v53; // edi@76
  int v54; // eax@78
  int v55; // [sp+Ch] [bp-DCh]@31
  unsigned int v56; // [sp+Ch] [bp-DCh]@54
  _WORD *v57; // [sp+10h] [bp-D8h]@29
  int v58; // [sp+10h] [bp-D8h]@59
  int v59; // [sp+14h] [bp-D4h]@29
  int v60; // [sp+14h] [bp-D4h]@56
  unsigned int v61; // [sp+18h] [bp-D0h]@28
  int v62; // [sp+18h] [bp-D0h]@57
  bool v63; // [sp+1Fh] [bp-C9h]@52
  int v64; // [sp+20h] [bp-C8h]@30
  int v65; // [sp+20h] [bp-C8h]@55
  int v66; // [sp+28h] [bp-C0h]@27
  int v67; // [sp+28h] [bp-C0h]@59
  unsigned int v68; // [sp+2Ch] [bp-BCh]@33
  int v69; // [sp+2Ch] [bp-BCh]@53
  unsigned int v70; // [sp+30h] [bp-B8h]@9
  int v71; // [sp+34h] [bp-B4h]@33
  _WORD *v72; // [sp+34h] [bp-B4h]@55
  int v73; // [sp+38h] [bp-B0h]@27
  unsigned int v74; // [sp+38h] [bp-B0h]@59
  unsigned int v75; // [sp+3Ch] [bp-ACh]@30
  int v76; // [sp+3Ch] [bp-ACh]@56
  int v77; // [sp+40h] [bp-A8h]@30
  unsigned int v78; // [sp+40h] [bp-A8h]@56
  char *v79; // [sp+44h] [bp-A4h]@1
  unsigned int v80; // [sp+48h] [bp-A0h]@26
  int v81; // [sp+48h] [bp-A0h]@59
  int v82; // [sp+4Ch] [bp-9Ch]@53
  int v83; // [sp+50h] [bp-98h]@22
  unsigned int v84; // [sp+54h] [bp-94h]@22
  int v85; // [sp+58h] [bp-90h]@22
  int v86; // [sp+5Ch] [bp-8Ch]@19
  int v87; // [sp+60h] [bp-88h]@10
  _DWORD *i; // [sp+64h] [bp-84h]@20
  unsigned int v89; // [sp+68h] [bp-80h]@22
  int v90; // [sp+6Ch] [bp-7Ch]@29
  unsigned int v91; // [sp+6Ch] [bp-7Ch]@52
  unsigned int v92; // [sp+70h] [bp-78h]@30
  unsigned int v93; // [sp+70h] [bp-78h]@56
  char *v94; // [sp+74h] [bp-74h]@2
  int v95; // [sp+78h] [bp-70h]@19
  int v96; // [sp+7Ch] [bp-6Ch]@56
  int v97; // [sp+80h] [bp-68h]@10
  int v98; // [sp+84h] [bp-64h]@4
  unsigned int v99; // [sp+88h] [bp-60h]@1
  int v100; // [sp+8Ch] [bp-5Ch]@7
  int v101; // [sp+94h] [bp-54h]@29
  int v102; // [sp+9Ch] [bp-4Ch]@55
  int v103; // [sp+A0h] [bp-48h]@55
  unsigned int v104; // [sp+A8h] [bp-40h]@25
  int v105; // [sp+ACh] [bp-3Ch]@25
  unsigned int v106; // [sp+B0h] [bp-38h]@25
  unsigned int v107; // [sp+B4h] [bp-34h]@25
  unsigned int v108; // [sp+B8h] [bp-30h]@25
  unsigned int v109; // [sp+BCh] [bp-2Ch]@25
  int v110; // [sp+C0h] [bp-28h]@25
  int v111; // [sp+C4h] [bp-24h]@25
  char v112; // [sp+C8h] [bp-20h]@52
  char v113[19]; // [sp+C9h] [bp-1Fh]@64
  int v114; // [sp+E4h] [bp-4h]@44

  v4 = a4;
  v5 = *(_DWORD *)(a4 + 8);
  v6 = (int)this;
  v79 = this;
  v99 = v5;
  if ( v5 <= *(_DWORD *)(a4 + 12) )
  {
    v94 = &this[12 * v5 + 212];
    while ( 1 )
    {
      v7 = *(_BYTE *)(v4 + 4);
      v98 = v7 ? v5 - 1 : 0;
      v100 = v7 ? *(_DWORD *)(v6 + 4 * v98 + 28) : 0;
      v70 = 0;
      if ( *(_DWORD *)(v6 + 184) > 0u )
        break;
LABEL_86:
      v94 += 12;
      v99 = ++v5;
      if ( v5 > *(_DWORD *)(v4 + 12) )
        return;
    }
    v87 = 0;
    v97 = 0;
    while ( !*(_BYTE *)(v6 + 520) )
    {
      if ( GetCurrentThreadId() == *(_DWORD *)(v6 + 512) && 0 == *(_DWORD *)(v6 + 516) && !(v70 & 0x7F) )
      {
        if ( !sub_1005D4D0(v70, *(_DWORD *)(v6 + 184), v6, v5 + 12) )
          return;
        v4 = a4;
      }
      v6 = (int)v79;
      v8 = *(_DWORD *)(*((_DWORD *)v79 + 131) + 4);
      if ( !v8 || v70 % (v8 + 1) == a2 )
      {
        v9 = v97 + *(_DWORD *)v94;
        v86 = 0;
        v95 = v97 + *(_DWORD *)v94;
        if ( *(_BYTE *)(v9 + 1) )
        {
          v10 = v9 + 332;
          for ( i = (_DWORD *)v10; ; v10 = (int)i )
          {
            v11 = (char *)&unk_100AD2F0 + 20 * *(_BYTE *)(v10 + 70);
            v89 = (unsigned int)dword_100AD2F8[5 * *(_BYTE *)(v10 + 70)] >> 2;
            v84 = *((_DWORD *)v11 + 3) >> 2;
            v85 = *(_DWORD *)v11 >> 2;
            v12 = *((_DWORD *)v11 + 1) >> 2;
            v83 = *((_DWORD *)v11 + 1) >> 2;
            if ( *(_BYTE *)(v4 + 4) )
            {
              v13 = *(_DWORD *)v10;
              v14 = *(_DWORD *)(v10 - 4);
              if ( v14 <= *(_DWORD *)v10 )
              {
                v106 = (v13 + 4 * v14) / 5;
                v107 = (3 * v14 + 2 * v13) / 5;
                v108 = (3 * v13 + 2 * v14) / 5;
                v104 = v14;
                v105 = v13;
                v109 = (v14 + 4 * v13) / 5;
                v110 = 0;
                v111 = 255;
              }
              else
              {
                sub_10092180(v13);
                v12 = v83;
              }
              v15 = 0;
              v80 = 0;
              if ( v84 )
              {
                v16 = v85 + 2 * v12;
                v17 = v16 + 326;
                v18 = v16 << 6;
                v73 = v18;
                v66 = v95 + 2 * v17;
                do
                {
                  v61 = 0;
                  if ( v89 )
                  {
                    LOBYTE(v101) = v98;
                    v19 = (__int32 *)(v4 + 28);
                    v90 = v4 + 28;
                    BYTE1(v101) = v86;
                    BYTE3(v101) = v15 + v12;
                    v59 = v18;
                    v57 = (_WORD *)v66;
                    do
                    {
                      v20 = *(_DWORD *)(v4 + 24);
                      v21 = 0;
                      v75 = -1;
                      v77 = 0;
                      v64 = 0;
                      v92 = *(_DWORD *)(v20 + 4);
                      if ( v92 )
                      {
                        v55 = 0;
                        while ( 2 )
                        {
                          v22 = v55 + *(_DWORD *)v20;
                          v23 = (_BYTE *)(v100 + *((_DWORD *)v79 + 47) + v87 + v59);
                          v24 = 0;
                          v68 = 0;
                          v71 = v100 + *((_DWORD *)v79 + 47) + v87 + v59;
                          while ( 2 )
                          {
                            v25 = 0;
                            do
                            {
                              v26 = *v23 - *(&v104 + *(_BYTE *)(v22 + v25));
                              v24 += v26 * v26;
                              if ( v24 > v75 )
                                goto LABEL_41;
                              ++v25;
                              v23 += 4;
                            }
                            while ( v25 < 4 );
                            v23 = (_BYTE *)(v71 + 16);
                            v22 += 4;
                            ++v68;
                            v71 += 16;
                            if ( v68 < 4 )
                              continue;
                            break;
                          }
                          if ( v24 >= v75 )
                          {
LABEL_41:
                            v21 = v77;
                            goto LABEL_42;
                          }
                          v21 = v64;
                          v75 = v24;
                          v77 = v64;
                          if ( !v24 )
                            break;
LABEL_42:
                          v55 += 16;
                          if ( ++v64 < v92 )
                          {
                            v20 = *(_DWORD *)(v4 + 24);
                            continue;
                          }
                          break;
                        }
                        v19 = (__int32 *)v90;
                        v4 = a4;
                      }
                      *v57 = v21;
                      sub_100911E0(v19);
                      v114 = 0;
                      v27 = **(_DWORD **)(v4 + 20) + 12 * v21;
                      v28 = *(_DWORD *)(v27 + 4);
                      if ( v28 >= *(_DWORD *)(v27 + 8) )
                        sub_100943C0(v28 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004AAB0, v27, 1, 8u, 0);
                      v29 = *(_DWORD *)v27 + 8 * *(_DWORD *)(v27 + 4);
                      if ( v29 )
                      {
                        *(_DWORD *)v29 = v70;
                        BYTE2(v101) = v61 + v85;
                        *(_DWORD *)(v29 + 4) = v101;
                      }
                      ++*(_DWORD *)(v27 + 4);
                      v114 = -1;
                      InterlockedExchange(v19, 0);
                      v59 += 64;
                      ++v57;
                      ++v61;
                    }
                    while ( v61 < v89 );
                    LOBYTE(v12) = v83;
                    v15 = v80;
                    v18 = v73;
                  }
                  v66 += 4;
                  ++v15;
                  v18 += 128;
                  v80 = v15;
                  v73 = v18;
                }
                while ( v15 < v84 );
              }
            }
            else
            {
              sub_100924B0(*(_WORD *)(v10 - 4), (int)&v112, *(_WORD *)v10);
              v63 = *(i - 1) == *i;
              v30 = 0;
              v91 = 0;
              if ( v84 )
              {
                v31 = v83;
                v32 = v85 + 2 * v83;
                v33 = v32 + 326;
                v34 = v32 << 6;
                v82 = v34;
                v69 = v95 + 2 * v33;
                do
                {
                  v56 = 0;
                  if ( v89 )
                  {
                    BYTE3(v102) = v31 + v30;
                    v35 = (__int32 *)(v4 + 28);
                    v103 = v4 + 28;
                    LOBYTE(v102) = 0;
                    BYTE1(v102) = v86;
                    v65 = v34;
                    v72 = (_WORD *)v69;
                    do
                    {
                      v36 = *(_DWORD *)(v4 + 24);
                      v37 = 0;
                      v78 = -1;
                      v76 = 0;
                      v60 = 0;
                      v96 = *(_DWORD *)(v4 + 24);
                      v93 = *(_DWORD *)(v36 + 4);
                      if ( v93 )
                      {
                        v62 = 0;
                        while ( 2 )
                        {
                          v38 = v62 + *(_DWORD *)v36;
                          v39 = (_BYTE *)(*((_DWORD *)v79 + 47) + v87 + v65 + 2);
                          v40 = 0;
                          v67 = 0;
                          v74 = 0;
                          v58 = v38;
                          v81 = *((_DWORD *)v79 + 47) + v87 + v65 + 2;
                          while ( 2 )
                          {
                            v41 = 0;
                            do
                            {
                              v42 = *(_BYTE *)(v58 + v41);
                              if ( v63 && v42 == 3 )
                                v67 = v40 + 999999;
                              v43 = *(v39 - 2) - (unsigned __int8)*(&v112 + 4 * v42);
                              v44 = *(v39 - 1) - (unsigned __int8)v113[4 * v42];
                              v45 = (unsigned __int8)*(&v112 + 4 * v42 + 2);
                              v46 = v44 * v44;
                              v47 = (*v39 - v45) * (*v39 - v45);
                              if ( v79[173] )
                                v48 = v47 + 25 * v46 + 8 * v43 * v43;
                              else
                                v48 = v43 * v43 + v46 + v47;
                              v40 = v48 + v67;
                              v67 = v40;
                              if ( v40 > v78 )
                                goto LABEL_73;
                              ++v41;
                              v39 += 4;
                            }
                            while ( v41 < 4 );
                            v58 += 4;
                            v39 = (_BYTE *)(v81 + 16);
                            ++v74;
                            v81 += 16;
                            if ( v74 < 4 )
                              continue;
                            break;
                          }
                          if ( v40 >= v78 )
                          {
LABEL_73:
                            v37 = v76;
                            goto LABEL_74;
                          }
                          v37 = v60;
                          v78 = v40;
                          v76 = v60;
                          if ( !v40 )
                            break;
LABEL_74:
                          v62 += 16;
                          if ( ++v60 < v93 )
                          {
                            v36 = v96;
                            continue;
                          }
                          break;
                        }
                        v4 = a4;
                        v35 = (__int32 *)v103;
                      }
                      *v72 = v37;
                      sub_100911E0(v35);
                      v114 = 1;
                      v49 = *(int **)(v4 + 20);
                      v50 = *v49;
                      v51 = *(_DWORD *)(*v49 + 12 * v37 + 4);
                      v52 = v51 < *(_DWORD *)(v50 + 12 * v37 + 8);
                      v53 = v50 + 12 * v37;
                      if ( !v52 )
                        sub_100943C0(v51 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004AAB0, v53, 1, 8u, 0);
                      v54 = *(_DWORD *)v53 + 8 * *(_DWORD *)(v53 + 4);
                      if ( v54 )
                      {
                        *(_DWORD *)v54 = v70;
                        BYTE2(v102) = v85 + v56;
                        *(_DWORD *)(v54 + 4) = v102;
                      }
                      ++*(_DWORD *)(v53 + 4);
                      v114 = -1;
                      InterlockedExchange(v35, 0);
                      v65 += 64;
                      ++v72;
                      ++v56;
                    }
                    while ( v56 < v89 );
                    v31 = v83;
                    v30 = v91;
                    v34 = v82;
                  }
                  v69 += 4;
                  ++v30;
                  v34 += 128;
                  v91 = v30;
                  v82 = v34;
                }
                while ( v30 < v84 );
              }
            }
            i += 20;
            if ( ++v86 >= (unsigned int)*(_BYTE *)(v95 + 1) )
              break;
          }
          v6 = (int)v79;
        }
      }
      v97 += 660;
      v87 += 260;
      v5 = v99;
      if ( ++v70 >= *(_DWORD *)(v6 + 184) )
        goto LABEL_86;
    }
  }
}
// 10092180: using guessed type double __thiscall sub_10092180(_DWORD);
// 100AD2F8: using guessed type int dword_100AD2F8[];
// 1005DFC0: using guessed type char var_1F[19];

//----- (1005E760) --------------------------------------------------------
void __stdcall sub_1005E760(int a1)
{
  int v1; // ebx@1
  unsigned int v2; // eax@2
  unsigned int v3; // esi@2
  _DWORD *v4; // edi@2
  unsigned int v5; // ebp@8
  int v6; // esi@10
  unsigned int v7; // esi@12
  unsigned int v8; // eax@12
  _DWORD *v9; // edi@12
  unsigned int v10; // ebp@18
  int v11; // esi@20
  unsigned int v12; // ebp@22
  unsigned int v13; // eax@22
  int v14; // esi@26
  int i; // edi@26
  unsigned int v16; // edi@31
  int v17; // ebp@32
  int v18; // esi@33
  int v19; // eax@34
  int v20; // edi@37
  int v21; // ebp@38
  unsigned __int16 v22; // ax@39
  char *v23; // esi@39
  unsigned int v24; // eax@43
  unsigned int v25; // edi@44
  int v26; // edx@45
  unsigned int v27; // eax@45
  unsigned int v28; // eax@45
  int v29; // edx@51
  int v30; // edi@54
  int v31; // edi@55
  int v32; // ecx@56
  unsigned int v33; // esi@56
  char *v34; // ebp@56
  unsigned int v35; // eax@60
  unsigned int v36; // edi@61
  int v37; // edx@62
  unsigned __int16 v38; // [sp-10h] [bp-74h]@39
  unsigned int v39; // [sp+4h] [bp-60h]@42
  unsigned int v40; // [sp+4h] [bp-60h]@59
  int v41; // [sp+8h] [bp-5Ch]@38
  _DWORD *v42; // [sp+8h] [bp-5Ch]@53
  int v43; // [sp+Ch] [bp-58h]@9
  int v44; // [sp+Ch] [bp-58h]@19
  int v45; // [sp+Ch] [bp-58h]@35
  unsigned int v46; // [sp+10h] [bp-54h]@37
  int v47; // [sp+10h] [bp-54h]@55
  int v48; // [sp+14h] [bp-50h]@37
  _DWORD *v49; // [sp+14h] [bp-50h]@53
  int v50; // [sp+18h] [bp-4Ch]@35
  int v51; // [sp+1Ch] [bp-48h]@36
  unsigned int v52; // [sp+20h] [bp-44h]@54
  int v53; // [sp+24h] [bp-40h]@54
  int v54; // [sp+28h] [bp-3Ch]@37
  unsigned int v55; // [sp+28h] [bp-3Ch]@52
  unsigned int v56; // [sp+2Ch] [bp-38h]@34
  int v57; // [sp+30h] [bp-34h]@52
  char v58; // [sp+34h] [bp-30h]@40
  char v59; // [sp+35h] [bp-2Fh]@45
  char v60; // [sp+36h] [bp-2Eh]@45
  char v61[13]; // [sp+37h] [bp-2Dh]@45
  unsigned int v62; // [sp+44h] [bp-20h]@58
  int v63; // [sp+48h] [bp-1Ch]@58
  unsigned int v64; // [sp+4Ch] [bp-18h]@58
  unsigned int v65; // [sp+50h] [bp-14h]@58
  unsigned int v66; // [sp+54h] [bp-10h]@58
  unsigned int v67; // [sp+58h] [bp-Ch]@58
  int v68; // [sp+5Ch] [bp-8h]@58
  int v69; // [sp+60h] [bp-4h]@58

  v1 = a1;
  if ( *(_BYTE *)(a1 + 174) )
  {
    v2 = *(_DWORD *)(a1 + 504);
    v3 = *(_DWORD *)(a1 + 184);
    v4 = (_DWORD *)(a1 + 500);
    if ( v3 != v2 )
    {
      if ( v3 >= v2 )
      {
        if ( v3 > *(_DWORD *)(a1 + 508) )
          sub_100943C0(v3, 0, a1 + 500, v3 == v2 + 1, 0x104u, 0);
        sub_10036CF0((void *)(*v4 + 260 * *(_DWORD *)(a1 + 504)), v3 - *(_DWORD *)(a1 + 504));
      }
      *(_DWORD *)(a1 + 504) = v3;
    }
    v5 = 0;
    if ( *(_DWORD *)(a1 + 184) )
    {
      v43 = 0;
      do
      {
        v6 = v43 + *v4;
        memset((void *)(v43 + *v4), 0, 0x104u);
        v43 += 260;
        *(float *)(v6 + 256) = 1.0;
        ++v5;
      }
      while ( v5 < *(_DWORD *)(a1 + 184) );
    }
    if ( *(_BYTE *)(a1 + 208) )
    {
      v7 = *(_DWORD *)(a1 + 184);
      v8 = *(_DWORD *)(a1 + 456);
      v9 = (_DWORD *)(a1 + 452);
      if ( v7 != v8 )
      {
        if ( v7 >= v8 )
        {
          if ( v7 > *(_DWORD *)(a1 + 460) )
            sub_100943C0(v7, 0, a1 + 452, v7 == v8 + 1, 0x104u, 0);
          sub_10036CF0((void *)(*v9 + 260 * *(_DWORD *)(a1 + 456)), v7 - *(_DWORD *)(a1 + 456));
        }
        *(_DWORD *)(a1 + 456) = v7;
      }
      v10 = 0;
      if ( *(_DWORD *)(a1 + 184) )
      {
        v44 = 0;
        do
        {
          v11 = v44 + *v9;
          memset((void *)(v44 + *v9), 0, 0x104u);
          v44 += 260;
          *(float *)(v11 + 256) = 1.0;
          ++v10;
        }
        while ( v10 < *(_DWORD *)(a1 + 184) );
      }
    }
    if ( *(_DWORD *)(a1 + 204) )
    {
      v12 = *(_DWORD *)(a1 + 184);
      v13 = *(_DWORD *)(a1 + 492);
      if ( v12 != v13 )
      {
        if ( v12 >= v13 )
        {
          if ( v12 > *(_DWORD *)(a1 + 496) )
            sub_100943C0(v12, 0, a1 + 488, v12 == v13 + 1, 0x104u, 0);
          v14 = *(_DWORD *)(a1 + 488) + 260 * *(_DWORD *)(a1 + 492);
          for ( i = v14 + 260 * (v12 - *(_DWORD *)(a1 + 492)); v14 != i; v14 += 260 )
          {
            if ( v14 )
            {
              memset((void *)v14, 0, 0x104u);
              *(float *)(v14 + 256) = 1.0;
            }
          }
        }
        *(_DWORD *)(a1 + 492) = v12;
      }
      v16 = 0;
      if ( *(_DWORD *)(a1 + 184) )
      {
        v17 = 0;
        do
        {
          v18 = v17 + *(_DWORD *)(a1 + 488);
          memset((void *)(v17 + *(_DWORD *)(a1 + 488)), 0, 0x104u);
          ++v16;
          *(float *)(v18 + 256) = 1.0;
          v17 += 260;
        }
        while ( v16 < *(_DWORD *)(a1 + 184) );
      }
    }
    v19 = 0;
    v56 = 0;
    if ( *(_DWORD *)(a1 + 184) )
    {
      v45 = 0;
      v50 = 0;
      do
      {
        v51 = v19 + *(_DWORD *)(v1 + 500);
        if ( *(_BYTE *)(v1 + 208) )
        {
          v20 = v45 + *(_DWORD *)(v1 + 212);
          v48 = v45 + *(_DWORD *)(v1 + 212);
          v54 = v19 + *(_DWORD *)(v1 + 452);
          v46 = 0;
          if ( *(_BYTE *)(v20 + 1) )
          {
            v21 = v20 + 332;
            v41 = v20 + 332;
            do
            {
              v22 = *(_WORD *)(v21 - 4);
              v23 = (char *)&unk_100AD2F0 + 20 * *(_BYTE *)(v21 + 70);
              v38 = *(_WORD *)v21;
              if ( v22 <= *(_WORD *)v21 )
                sub_10092630((int)&v58, v22, v38);
              else
                sub_100924B0(v22, (int)&v58, v38);
              v39 = 0;
              if ( *((_DWORD *)v23 + 3) )
              {
                v24 = *((_DWORD *)v23 + 2);
                do
                {
                  v25 = 0;
                  if ( v24 )
                  {
                    do
                    {
                      v26 = *(_BYTE *)((((_BYTE)v25 + *v23) & 3)
                                     + 4
                                     * ((((_BYTE)v39 + v23[4]) & 3)
                                      + 4
                                      * *(_WORD *)(v48
                                                 + 2
                                                 * (((v25 + *(_DWORD *)v23) >> 2)
                                                  + 2 * ((v39 + *((_DWORD *)v23 + 1)) >> 2)
                                                  + 326)))
                                     + *(_DWORD *)(v1 + 308));
                      v27 = v51
                          + 4
                          * (((v25 + *(_DWORD *)v23) & 3)
                           + 4
                           * (((v39 + *((_DWORD *)v23 + 1)) & 3)
                            + 4 * (((v25 + *(_DWORD *)v23) >> 2) + 2 * ((v39 + *((_DWORD *)v23 + 1)) >> 2))));
                      *(_BYTE *)v27 = *(&v58 + 4 * v26);
                      *(_BYTE *)(v27 + 1) = *(&v59 + 4 * v26);
                      *(_BYTE *)(v27 + 2) = *(&v60 + 4 * v26);
                      *(_BYTE *)(v27 + 3) = v61[4 * v26];
                      v1 = a1;
                      v28 = v54
                          + 4
                          * (((v25 + *(_DWORD *)v23) & 3)
                           + 4
                           * (((v39 + *((_DWORD *)v23 + 1)) & 3)
                            + 4 * (((v25 + *(_DWORD *)v23) >> 2) + 2 * ((v39 + *((_DWORD *)v23 + 1)) >> 2))));
                      *(_BYTE *)v28 = byte_100AE384[4 * v26];
                      *(_BYTE *)(v28 + 1) = byte_100AE385[4 * v26];
                      *(_BYTE *)(v28 + 2) = byte_100AE386[4 * v26];
                      *(_BYTE *)(v28 + 3) = byte_100AE387[4 * v26];
                      v24 = *((_DWORD *)v23 + 2);
                      ++v25;
                    }
                    while ( v25 < v24 );
                    v21 = v41;
                  }
                  ++v39;
                }
                while ( v39 < *((_DWORD *)v23 + 3) );
                v20 = v48;
              }
              v21 += 80;
              ++v46;
              v41 = v21;
            }
            while ( v46 < *(_BYTE *)(v20 + 1) );
            v19 = v50;
          }
        }
        v29 = *(_DWORD *)(v1 + 204);
        if ( v29 )
        {
          v57 = v19 + *(_DWORD *)(v1 + 488);
          v55 = 0;
          if ( v29 )
          {
            v42 = (_DWORD *)(v1 + 28);
            v49 = (_DWORD *)(v1 + 224);
            do
            {
              v30 = v45 + *v49;
              v52 = 0;
              v53 = v45 + *v49;
              if ( *(_BYTE *)(v30 + 1) )
              {
                v31 = v30 + 332;
                v47 = v31;
                do
                {
                  v32 = *(_DWORD *)v31;
                  v33 = *(_DWORD *)(v31 - 4);
                  v34 = (char *)&unk_100AD2F0 + 20 * *(_BYTE *)(v31 + 70);
                  if ( v33 <= *(_DWORD *)v31 )
                  {
                    v64 = (v32 + 4 * v33) / 5;
                    v65 = (3 * v33 + 2 * v32) / 5;
                    v63 = v32;
                    v66 = (3 * v32 + 2 * v33) / 5;
                    v62 = v33;
                    v67 = (v33 + 4 * v32) / 5;
                    v68 = 0;
                    v69 = 255;
                  }
                  else
                  {
                    sub_10092180(v32);
                    v31 = v47;
                  }
                  v40 = 0;
                  if ( *((_DWORD *)v34 + 3) )
                  {
                    v35 = *((_DWORD *)v34 + 2);
                    do
                    {
                      v36 = 0;
                      if ( v35 )
                      {
                        do
                        {
                          v37 = *(_BYTE *)((((_BYTE)v36 + *v34) & 3)
                                         + 4
                                         * ((((_BYTE)v40 + v34[4]) & 3)
                                          + 4
                                          * *(_WORD *)(v53
                                                     + 2
                                                     * (((v36 + *(_DWORD *)v34) >> 2)
                                                      + 2 * ((v40 + *((_DWORD *)v34 + 1)) >> 2)
                                                      + 326)))
                                         + *(_DWORD *)(v1 + 320));
                          *(_BYTE *)(*v42
                                   + 4
                                   * (((v36 + *(_DWORD *)v34) & 3)
                                    + 4
                                    * (((v40 + *((_DWORD *)v34 + 1)) & 3)
                                     + 4 * (((v36 + *(_DWORD *)v34) >> 2) + 2 * ((v40 + *((_DWORD *)v34 + 1)) >> 2))))
                                   + v51) = *((_BYTE *)&v62 + 4 * v37);
                          *(_BYTE *)(*v42
                                   + 4
                                   * (((v36 + *(_DWORD *)v34) & 3)
                                    + 4
                                    * (((v40 + *((_DWORD *)v34 + 1)) & 3)
                                     + 4 * (((v36 + *(_DWORD *)v34) >> 2) + 2 * ((v40 + *((_DWORD *)v34 + 1)) >> 2))))
                                   + v57) = 255 * v37 / 7u;
                          v35 = *((_DWORD *)v34 + 2);
                          v1 = a1;
                          ++v36;
                        }
                        while ( v36 < v35 );
                      }
                      ++v40;
                    }
                    while ( v40 < *((_DWORD *)v34 + 3) );
                    v31 = v47;
                  }
                  v31 += 80;
                  ++v52;
                  v47 = v31;
                }
                while ( v52 < *(_BYTE *)(v53 + 1) );
              }
              v49 += 3;
              ++v42;
              ++v55;
            }
            while ( v55 < *(_DWORD *)(v1 + 204) );
            v19 = v50;
          }
        }
        v45 += 660;
        v19 += 260;
        ++v56;
        v50 = v19;
      }
      while ( v56 < *(_DWORD *)(v1 + 184) );
    }
  }
}
// 10092180: using guessed type double __thiscall sub_10092180(_DWORD);
// 1005E760: using guessed type char var_2D[13];

//----- (1005EE00) --------------------------------------------------------
void __stdcall sub_1005EE00(int a1)
{
  int v1; // ebp@1
  unsigned int v2; // ebx@3
  int v3; // edi@4
  int v4; // esi@5
  int v5; // esi@5
  int v6; // esi@5
  unsigned int v7; // esi@7
  unsigned int v8; // eax@7
  unsigned int v9; // esi@13
  unsigned int v10; // eax@13
  unsigned int v11; // esi@19
  unsigned int v12; // eax@19
  unsigned int v13; // ebx@25
  int v14; // edi@26
  int v15; // esi@27
  int v16; // esi@27
  int v17; // esi@27
  int v18; // edi@29
  int v19; // eax@31
  int v20; // ebx@32
  unsigned __int16 v21; // ax@33
  char *v22; // esi@33
  unsigned int v23; // ebp@36
  unsigned int v24; // eax@37
  unsigned int v25; // edi@38
  unsigned int v26; // ecx@39
  signed int v27; // edx@39
  unsigned int v28; // ecx@41
  int v29; // eax@41
  unsigned int v30; // eax@43
  char *v31; // ecx@43
  char v32; // dl@43
  int v33; // esi@50
  int v34; // ebx@51
  unsigned int v35; // ecx@52
  unsigned int v36; // edi@52
  char *v37; // ebp@52
  unsigned int v38; // edi@55
  unsigned int v39; // eax@56
  unsigned int v40; // ecx@57
  int v41; // ebx@58
  int v42; // ST68_4@58
  int v43; // ebx@58
  unsigned __int16 v44; // [sp-10h] [bp-80h]@33
  int v45; // [sp+4h] [bp-6Ch]@32
  _DWORD *v46; // [sp+4h] [bp-6Ch]@49
  int v47; // [sp+8h] [bp-68h]@32
  int v48; // [sp+8h] [bp-68h]@51
  int v49; // [sp+Ch] [bp-64h]@29
  int v50; // [sp+10h] [bp-60h]@31
  int v51; // [sp+10h] [bp-60h]@50
  unsigned int v52; // [sp+14h] [bp-5Ch]@31
  unsigned int v53; // [sp+14h] [bp-5Ch]@55
  int v54; // [sp+18h] [bp-58h]@39
  _DWORD *v55; // [sp+18h] [bp-58h]@49
  int v56; // [sp+1Ch] [bp-54h]@29
  int v57; // [sp+20h] [bp-50h]@31
  unsigned int v58; // [sp+20h] [bp-50h]@50
  int v59; // [sp+24h] [bp-4Ch]@31
  unsigned int v60; // [sp+24h] [bp-4Ch]@48
  unsigned int v61; // [sp+28h] [bp-48h]@28
  int v62; // [sp+2Ch] [bp-44h]@31
  int v63; // [sp+2Ch] [bp-44h]@50
  int v64; // [sp+30h] [bp-40h]@51
  int v65; // [sp+34h] [bp-3Ch]@50
  int v66; // [sp+3Ch] [bp-34h]@50
  char v67[16]; // [sp+40h] [bp-30h]@34
  unsigned int v68; // [sp+50h] [bp-20h]@54
  unsigned int v69; // [sp+54h] [bp-1Ch]@54
  unsigned int v70; // [sp+58h] [bp-18h]@54
  unsigned int v71; // [sp+5Ch] [bp-14h]@54
  unsigned int v72; // [sp+60h] [bp-10h]@54
  unsigned int v73; // [sp+64h] [bp-Ch]@54
  int v74; // [sp+68h] [bp-8h]@54
  int v75; // [sp+6Ch] [bp-4h]@54

  v1 = a1;
  if ( *(_BYTE *)(a1 + 174) )
  {
    if ( *(_BYTE *)(a1 + 208) )
    {
      sub_10036B80(a1 + 404, *(_DWORD *)(a1 + 184));
      sub_10036B80(a1 + 440, *(_DWORD *)(a1 + 184));
      sub_10036B80(a1 + 428, *(_DWORD *)(a1 + 184));
      v2 = 0;
      if ( *(_DWORD *)(a1 + 184) )
      {
        v3 = 0;
        do
        {
          v4 = v3 + *(_DWORD *)(a1 + 404);
          memset((void *)(v3 + *(_DWORD *)(a1 + 404)), 0, 0x104u);
          *(float *)(v4 + 256) = 1.0;
          v5 = v3 + *(_DWORD *)(a1 + 440);
          memset((void *)(v3 + *(_DWORD *)(a1 + 440)), 0, 0x104u);
          *(float *)(v5 + 256) = 1.0;
          v6 = v3 + *(_DWORD *)(a1 + 428);
          memset((void *)(v3 + *(_DWORD *)(a1 + 428)), 0, 0x104u);
          ++v2;
          *(float *)(v6 + 256) = 1.0;
          v3 += 260;
        }
        while ( v2 < *(_DWORD *)(a1 + 184) );
      }
    }
    if ( *(_DWORD *)(a1 + 204) )
    {
      v7 = *(_DWORD *)(a1 + 184);
      v8 = *(_DWORD *)(a1 + 420);
      if ( v7 != v8 )
      {
        if ( v7 >= v8 )
        {
          if ( v7 > *(_DWORD *)(a1 + 424) )
            sub_100943C0(v7, 0, a1 + 416, v7 == v8 + 1, 0x104u, 0);
          sub_10036CF0((void *)(*(_DWORD *)(a1 + 416) + 260 * *(_DWORD *)(a1 + 420)), v7 - *(_DWORD *)(a1 + 420));
        }
        *(_DWORD *)(a1 + 420) = v7;
      }
      v9 = *(_DWORD *)(a1 + 184);
      v10 = *(_DWORD *)(a1 + 480);
      if ( v9 != v10 )
      {
        if ( v9 >= v10 )
        {
          if ( v9 > *(_DWORD *)(a1 + 484) )
            sub_100943C0(v9, 0, a1 + 476, v9 == v10 + 1, 0x104u, 0);
          sub_10036CF0((void *)(*(_DWORD *)(a1 + 476) + 260 * *(_DWORD *)(a1 + 480)), v9 - *(_DWORD *)(a1 + 480));
        }
        *(_DWORD *)(a1 + 480) = v9;
      }
      v11 = *(_DWORD *)(a1 + 184);
      v12 = *(_DWORD *)(a1 + 468);
      if ( v11 != v12 )
      {
        if ( v11 >= v12 )
        {
          if ( v11 > *(_DWORD *)(a1 + 472) )
            sub_100943C0(v11, 0, a1 + 464, v11 == v12 + 1, 0x104u, 0);
          sub_10036CF0((void *)(*(_DWORD *)(a1 + 464) + 260 * *(_DWORD *)(a1 + 468)), v11 - *(_DWORD *)(a1 + 468));
        }
        *(_DWORD *)(a1 + 468) = v11;
      }
      v13 = 0;
      if ( *(_DWORD *)(a1 + 184) )
      {
        v14 = 0;
        do
        {
          v15 = v14 + *(_DWORD *)(a1 + 416);
          memset((void *)(v14 + *(_DWORD *)(a1 + 416)), 0, 0x104u);
          *(float *)(v15 + 256) = 1.0;
          v16 = v14 + *(_DWORD *)(a1 + 476);
          memset((void *)(v14 + *(_DWORD *)(a1 + 476)), 0, 0x104u);
          *(float *)(v16 + 256) = 1.0;
          v17 = v14 + *(_DWORD *)(a1 + 464);
          memset((void *)(v14 + *(_DWORD *)(a1 + 464)), 0, 0x104u);
          ++v13;
          *(float *)(v17 + 256) = 1.0;
          v14 += 260;
        }
        while ( v13 < *(_DWORD *)(a1 + 184) );
      }
    }
    v61 = 0;
    if ( *(_DWORD *)(a1 + 184) )
    {
      v18 = 0;
      v49 = 0;
      v56 = 0;
      do
      {
        if ( *(_BYTE *)(v1 + 208) )
        {
          v62 = v18 + *(_DWORD *)(v1 + 404);
          v59 = v18 + *(_DWORD *)(v1 + 440);
          v57 = v18 + *(_DWORD *)(v1 + 428);
          v19 = v49 + *(_DWORD *)(v1 + 212);
          v52 = 0;
          v50 = v49 + *(_DWORD *)(v1 + 212);
          if ( *(_BYTE *)(v19 + 1) )
          {
            v20 = v19 + 336;
            v45 = v19 + 336;
            v47 = -336 - v19;
            do
            {
              v21 = *(_WORD *)(v20 - 8);
              v22 = (char *)&unk_100AD2F0 + 20 * *(_BYTE *)(v20 + 66);
              v44 = *(_WORD *)(v20 - 4);
              if ( v21 <= v44 )
                sub_10092630((int)v67, v21, v44);
              else
                sub_100924B0(v21, (int)v67, v44);
              v23 = 0;
              if ( *((_DWORD *)v22 + 3) )
              {
                v24 = *((_DWORD *)v22 + 2);
                do
                {
                  v25 = 0;
                  if ( v24 )
                  {
                    do
                    {
                      v54 = *(_BYTE *)(v20 + v23 * v24 + v25);
                      v26 = v59
                          + 4
                          * (((v25 + *(_DWORD *)v22) & 3)
                           + 4
                           * (((v23 + *((_DWORD *)v22 + 1)) & 3)
                            + 4 * (((v25 + *(_DWORD *)v22) >> 2) + 2 * ((v23 + *((_DWORD *)v22 + 1)) >> 2))));
                      v27 = 255 * v54 / 3u;
                      if ( v27 & 0xFFFFFF00 )
                        LOBYTE(v27) = ~(v27 >> 31);
                      *(_BYTE *)v26 = v27;
                      *(_BYTE *)(v26 + 1) = v27;
                      *(_BYTE *)(v26 + 2) = v27;
                      *(_BYTE *)(v26 + 3) = -1;
                      v28 = v57
                          + 4
                          * (((v25 + *(_DWORD *)v22) & 3)
                           + 4
                           * (((v23 + *((_DWORD *)v22 + 1)) & 3)
                            + 4 * (((v25 + *(_DWORD *)v22) >> 2) + 2 * ((v23 + *((_DWORD *)v22 + 1)) >> 2))));
                      v29 = 255 * *(_BYTE *)(v25 + v47 + v45 + v23 * *((_DWORD *)v22 + 2) + v50 + 16) / 3;
                      if ( v29 & 0xFFFFFF00 )
                        LOBYTE(v29) = ~(v29 >> 31);
                      *(_BYTE *)v28 = v29;
                      *(_BYTE *)(v28 + 1) = v29;
                      *(_BYTE *)(v28 + 2) = v29;
                      *(_BYTE *)(v28 + 3) = -1;
                      v20 = v45;
                      v30 = v62
                          + 4
                          * (((v25 + *(_DWORD *)v22) & 3)
                           + 4
                           * (((v23 + *((_DWORD *)v22 + 1)) & 3)
                            + 4 * (((v25 + *(_DWORD *)v22) >> 2) + 2 * ((v23 + *((_DWORD *)v22 + 1)) >> 2))));
                      v31 = &v67[4 * v54];
                      *(_BYTE *)v30 = *v31;
                      *(_BYTE *)(v30 + 1) = v31[1];
                      v32 = v31[2];
                      LOBYTE(v31) = v31[3];
                      *(_BYTE *)(v30 + 2) = v32;
                      *(_BYTE *)(v30 + 3) = (_BYTE)v31;
                      v24 = *((_DWORD *)v22 + 2);
                      ++v25;
                    }
                    while ( v25 < v24 );
                  }
                  ++v23;
                }
                while ( v23 < *((_DWORD *)v22 + 3) );
                v18 = v56;
              }
              v20 += 80;
              ++v52;
              v45 = v20;
            }
            while ( v52 < *(_BYTE *)(v50 + 1) );
            v1 = a1;
          }
        }
        v60 = 0;
        if ( *(_DWORD *)(v1 + 204) )
        {
          v46 = (_DWORD *)(v1 + 28);
          v55 = (_DWORD *)(v1 + 224);
          do
          {
            v33 = v49 + *v55;
            v66 = v18 + *(_DWORD *)(v1 + 416);
            v63 = v18 + *(_DWORD *)(v1 + 476);
            v65 = v18 + *(_DWORD *)(v1 + 464);
            v51 = v49 + *v55;
            v58 = 0;
            if ( *(_BYTE *)(v33 + 1) )
            {
              v34 = v33 + 336;
              v48 = v33 + 336;
              v64 = -336 - v33;
              do
              {
                v35 = *(_DWORD *)(v34 - 4);
                v36 = *(_DWORD *)(v34 - 8);
                v37 = (char *)&unk_100AD2F0 + 20 * *(_BYTE *)(v34 + 66);
                if ( v36 <= v35 )
                {
                  v70 = (v35 + 4 * v36) / 5;
                  v71 = (3 * v36 + 2 * v35) / 5;
                  v69 = v35;
                  v72 = (3 * v35 + 2 * v36) / 5;
                  v68 = v36;
                  v73 = (v36 + 4 * v35) / 5;
                  v74 = 0;
                  v75 = 255;
                }
                else
                {
                  sub_10092180(v35);
                  v33 = v51;
                }
                v38 = 0;
                v53 = 0;
                if ( *((_DWORD *)v37 + 3) )
                {
                  v39 = *((_DWORD *)v37 + 2);
                  do
                  {
                    v40 = 0;
                    if ( v39 )
                    {
                      do
                      {
                        v41 = *(_BYTE *)(v34 + v38 * v39 + v40);
                        v42 = v41;
                        *(_BYTE *)(*v46
                                 + 4
                                 * (((v40 + *(_DWORD *)v37) & 3)
                                  + 4
                                  * (((v38 + *((_DWORD *)v37 + 1)) & 3)
                                   + 4 * (((v40 + *(_DWORD *)v37) >> 2) + 2 * ((v38 + *((_DWORD *)v37 + 1)) >> 2))))
                                 + v63) = 255 * v41 / 7u;
                        v43 = 255 * *(_BYTE *)(v40 + v48 + v64 + v53 * *((_DWORD *)v37 + 2) + v51 + 16);
                        v38 = v53;
                        *(_BYTE *)(*v46
                                 + 4
                                 * (((v40 + *(_DWORD *)v37) & 3)
                                  + 4
                                  * (((v53 + *((_DWORD *)v37 + 1)) & 3)
                                   + 4 * (((v40 + *(_DWORD *)v37) >> 2) + 2 * ((v53 + *((_DWORD *)v37 + 1)) >> 2))))
                                 + v65) = ((signed int)(v43 + ((unsigned __int64)(-1840700269i64 * v43) >> 32)) >> 2)
                                        + ((unsigned int)(v43 + ((unsigned __int64)(-1840700269i64 * v43) >> 32)) >> 31);
                        v34 = v48;
                        *(_BYTE *)(*v46
                                 + 4
                                 * (((v40 + *(_DWORD *)v37) & 3)
                                  + 4
                                  * (((v38 + *((_DWORD *)v37 + 1)) & 3)
                                   + 4 * (((v40 + *(_DWORD *)v37) >> 2) + 2 * ((v38 + *((_DWORD *)v37 + 1)) >> 2))))
                                 + v66) = *((_BYTE *)&v68 + 4 * v42);
                        v39 = *((_DWORD *)v37 + 2);
                        ++v40;
                      }
                      while ( v40 < v39 );
                      v33 = v51;
                    }
                    v53 = ++v38;
                  }
                  while ( v38 < *((_DWORD *)v37 + 3) );
                }
                v34 += 80;
                ++v58;
                v48 = v34;
              }
              while ( v58 < *(_BYTE *)(v33 + 1) );
              v18 = v56;
              v1 = a1;
            }
            v55 += 3;
            ++v46;
            ++v60;
          }
          while ( v60 < *(_DWORD *)(v1 + 204) );
        }
        v49 += 660;
        v18 += 260;
        ++v61;
        v56 = v18;
      }
      while ( v61 < *(_DWORD *)(v1 + 184) );
    }
  }
}
// 10092180: using guessed type double __thiscall sub_10092180(_DWORD);
// 1005EE00: using guessed type char var_30[16];

//----- (1005F570) --------------------------------------------------------
signed int __usercall sub_1005F570@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // eax@6
  int v3; // eax@11
  int v4; // edi@16
  signed int v5; // ebp@16
  int v6; // eax@17
  int *v7; // ecx@23
  int v8; // eax@24
  int *v9; // ecx@29
  int v10; // eax@30
  int v11; // eax@35
  int v12; // eax@40
  int *v13; // ecx@45
  int v14; // eax@46
  int *v15; // ecx@51
  int v16; // eax@52
  int v17; // eax@57
  int v18; // eax@62
  int v19; // eax@67
  int v20; // eax@72
  int v21; // eax@77
  int v22; // eax@82
  int v23; // eax@87
  int v24; // eax@92
  int v25; // eax@97
  int v26; // eax@102
  int v27; // eax@107
  int v28; // eax@112
  int v29; // eax@117
  int v30; // eax@122
  signed int result; // eax@127

  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 188) = 0;
  v1 = *(_DWORD *)(a1 + 192);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 192) = 0;
    *(_DWORD *)(a1 + 196) = 0;
    *(_DWORD *)(a1 + 200) = 0;
  }
  *(_DWORD *)(a1 + 204) = 0;
  *(_WORD *)(a1 + 208) = 0;
  *(_BYTE *)(a1 + 210) = 0;
  v2 = *(_DWORD *)(a1 + 308);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 308) = 0;
    *(_DWORD *)(a1 + 312) = 0;
    *(_DWORD *)(a1 + 316) = 0;
  }
  v3 = *(_DWORD *)(a1 + 320);
  if ( v3 )
  {
    if ( v3 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 320) = 0;
    *(_DWORD *)(a1 + 324) = 0;
    *(_DWORD *)(a1 + 328) = 0;
  }
  v4 = a1 + 212;
  v5 = 3;
  do
  {
    v6 = *(_DWORD *)v4;
    if ( *(_DWORD *)v4 )
    {
      if ( v6 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v6, 0, 0, 1, dword_100AE9F4);
      *(_DWORD *)v4 = 0;
      *(_DWORD *)(v4 + 4) = 0;
      *(_DWORD *)(v4 + 8) = 0;
    }
    v4 += 12;
    --v5;
  }
  while ( v5 );
  *(_DWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 252) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 260) = 0;
  *(_DWORD *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 268) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 276) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  v7 = *(int **)(a1 + 284);
  if ( v7 )
  {
    sub_1004CE50(*(_DWORD *)(a1 + 288), v7);
    v8 = *(_DWORD *)(a1 + 284);
    if ( v8 )
    {
      if ( v8 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v8, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 284) = 0;
    *(_DWORD *)(a1 + 288) = 0;
    *(_DWORD *)(a1 + 292) = 0;
  }
  v9 = *(int **)(a1 + 296);
  if ( v9 )
  {
    sub_1004CE50(*(_DWORD *)(a1 + 300), v9);
    v10 = *(_DWORD *)(a1 + 296);
    if ( v10 )
    {
      if ( v10 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v10, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 296) = 0;
    *(_DWORD *)(a1 + 300) = 0;
    *(_DWORD *)(a1 + 304) = 0;
  }
  v11 = *(_DWORD *)(a1 + 308);
  if ( v11 )
  {
    if ( v11 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v11, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 308) = 0;
    *(_DWORD *)(a1 + 312) = 0;
    *(_DWORD *)(a1 + 316) = 0;
  }
  v12 = *(_DWORD *)(a1 + 320);
  if ( v12 )
  {
    if ( v12 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v12, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 320) = 0;
    *(_DWORD *)(a1 + 324) = 0;
    *(_DWORD *)(a1 + 328) = 0;
  }
  v13 = *(int **)(a1 + 332);
  if ( v13 )
  {
    sub_1003E4E0(*(_DWORD *)(a1 + 336), v13);
    v14 = *(_DWORD *)(a1 + 332);
    if ( v14 )
    {
      if ( v14 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v14, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 332) = 0;
    *(_DWORD *)(a1 + 336) = 0;
    *(_DWORD *)(a1 + 340) = 0;
  }
  v15 = *(int **)(a1 + 344);
  if ( v15 )
  {
    sub_1003E4E0(*(_DWORD *)(a1 + 348), v15);
    v16 = *(_DWORD *)(a1 + 344);
    if ( v16 )
    {
      if ( v16 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v16, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 344) = 0;
    *(_DWORD *)(a1 + 348) = 0;
    *(_DWORD *)(a1 + 352) = 0;
  }
  v17 = *(_DWORD *)(a1 + 356);
  if ( v17 )
  {
    if ( v17 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v17, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 356) = 0;
    *(_DWORD *)(a1 + 360) = 0;
    *(_DWORD *)(a1 + 364) = 0;
  }
  v18 = *(_DWORD *)(a1 + 368);
  if ( v18 )
  {
    if ( v18 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v18, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 368) = 0;
    *(_DWORD *)(a1 + 372) = 0;
    *(_DWORD *)(a1 + 376) = 0;
  }
  v19 = *(_DWORD *)(a1 + 380);
  if ( v19 )
  {
    if ( v19 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v19, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 380) = 0;
    *(_DWORD *)(a1 + 384) = 0;
    *(_DWORD *)(a1 + 388) = 0;
  }
  v20 = *(_DWORD *)(a1 + 392);
  if ( v20 )
  {
    if ( v20 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v20, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 392) = 0;
    *(_DWORD *)(a1 + 396) = 0;
    *(_DWORD *)(a1 + 400) = 0;
  }
  v21 = *(_DWORD *)(a1 + 404);
  if ( v21 )
  {
    if ( v21 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v21, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 404) = 0;
    *(_DWORD *)(a1 + 408) = 0;
    *(_DWORD *)(a1 + 412) = 0;
  }
  v22 = *(_DWORD *)(a1 + 416);
  if ( v22 )
  {
    if ( v22 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v22, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 416) = 0;
    *(_DWORD *)(a1 + 420) = 0;
    *(_DWORD *)(a1 + 424) = 0;
  }
  v23 = *(_DWORD *)(a1 + 440);
  if ( v23 )
  {
    if ( v23 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v23, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 440) = 0;
    *(_DWORD *)(a1 + 444) = 0;
    *(_DWORD *)(a1 + 448) = 0;
  }
  v24 = *(_DWORD *)(a1 + 428);
  if ( v24 )
  {
    if ( v24 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v24, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 428) = 0;
    *(_DWORD *)(a1 + 432) = 0;
    *(_DWORD *)(a1 + 436) = 0;
  }
  v25 = *(_DWORD *)(a1 + 452);
  if ( v25 )
  {
    if ( v25 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v25, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 452) = 0;
    *(_DWORD *)(a1 + 456) = 0;
    *(_DWORD *)(a1 + 460) = 0;
  }
  v26 = *(_DWORD *)(a1 + 488);
  if ( v26 )
  {
    if ( v26 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v26, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 488) = 0;
    *(_DWORD *)(a1 + 492) = 0;
    *(_DWORD *)(a1 + 496) = 0;
  }
  v27 = *(_DWORD *)(a1 + 476);
  if ( v27 )
  {
    if ( v27 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v27, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 476) = 0;
    *(_DWORD *)(a1 + 480) = 0;
    *(_DWORD *)(a1 + 484) = 0;
  }
  v28 = *(_DWORD *)(a1 + 464);
  if ( v28 )
  {
    if ( v28 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v28, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 464) = 0;
    *(_DWORD *)(a1 + 468) = 0;
    *(_DWORD *)(a1 + 472) = 0;
  }
  v29 = *(_DWORD *)(a1 + 488);
  if ( v29 )
  {
    if ( v29 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v29, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 488) = 0;
    *(_DWORD *)(a1 + 492) = 0;
    *(_DWORD *)(a1 + 496) = 0;
  }
  v30 = *(_DWORD *)(a1 + 500);
  if ( v30 )
  {
    if ( v30 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v30, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 500) = 0;
    *(_DWORD *)(a1 + 504) = 0;
    *(_DWORD *)(a1 + 508) = 0;
  }
  result = -1;
  *(_BYTE *)(a1 + 520) = 0;
  *(_DWORD *)(a1 + 528) = -1;
  *(_DWORD *)(a1 + 532) = -1;
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1005FC60) --------------------------------------------------------
void __stdcall sub_1005FC60(int a1)
{
  int v1; // eax@1
  int v2; // eax@5
  int v3; // eax@9
  int v4; // eax@13
  int v5; // eax@17
  int v6; // eax@21
  int v7; // eax@25
  int v8; // eax@29
  int v9; // eax@33
  int v10; // eax@37
  int v11; // eax@41
  int v12; // eax@45
  int v13; // eax@49
  int *v14; // ecx@53
  int v15; // eax@54
  int *v16; // ecx@58
  int v17; // eax@59
  int v18; // eax@63
  int v19; // eax@67
  int *v20; // ecx@71
  int v21; // eax@72
  int *v22; // ecx@76
  int v23; // eax@77
  int v24; // eax@81

  v1 = *(_DWORD *)(a1 + 500);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
  v2 = *(_DWORD *)(a1 + 488);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
  }
  v3 = *(_DWORD *)(a1 + 476);
  if ( v3 )
  {
    if ( v3 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
  }
  v4 = *(_DWORD *)(a1 + 464);
  if ( v4 )
  {
    if ( v4 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
  }
  v5 = *(_DWORD *)(a1 + 452);
  if ( v5 )
  {
    if ( v5 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
  }
  v6 = *(_DWORD *)(a1 + 440);
  if ( v6 )
  {
    if ( v6 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v6, 0, 0, 1, dword_100AE9F4);
  }
  v7 = *(_DWORD *)(a1 + 428);
  if ( v7 )
  {
    if ( v7 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v7, 0, 0, 1, dword_100AE9F4);
  }
  v8 = *(_DWORD *)(a1 + 416);
  if ( v8 )
  {
    if ( v8 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v8, 0, 0, 1, dword_100AE9F4);
  }
  v9 = *(_DWORD *)(a1 + 404);
  if ( v9 )
  {
    if ( v9 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v9, 0, 0, 1, dword_100AE9F4);
  }
  v10 = *(_DWORD *)(a1 + 392);
  if ( v10 )
  {
    if ( v10 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v10, 0, 0, 1, dword_100AE9F4);
  }
  v11 = *(_DWORD *)(a1 + 380);
  if ( v11 )
  {
    if ( v11 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v11, 0, 0, 1, dword_100AE9F4);
  }
  v12 = *(_DWORD *)(a1 + 368);
  if ( v12 )
  {
    if ( v12 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v12, 0, 0, 1, dword_100AE9F4);
  }
  v13 = *(_DWORD *)(a1 + 356);
  if ( v13 )
  {
    if ( v13 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v13, 0, 0, 1, dword_100AE9F4);
  }
  v14 = *(int **)(a1 + 344);
  if ( v14 )
  {
    sub_1003E4E0(*(_DWORD *)(a1 + 348), v14);
    v15 = *(_DWORD *)(a1 + 344);
    if ( v15 )
    {
      if ( v15 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v15, 0, 0, 1, dword_100AE9F4);
    }
  }
  v16 = *(int **)(a1 + 332);
  if ( v16 )
  {
    sub_1003E4E0(*(_DWORD *)(a1 + 336), v16);
    v17 = *(_DWORD *)(a1 + 332);
    if ( v17 )
    {
      if ( v17 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v17, 0, 0, 1, dword_100AE9F4);
    }
  }
  v18 = *(_DWORD *)(a1 + 320);
  if ( v18 )
  {
    if ( v18 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v18, 0, 0, 1, dword_100AE9F4);
  }
  v19 = *(_DWORD *)(a1 + 308);
  if ( v19 )
  {
    if ( v19 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v19, 0, 0, 1, dword_100AE9F4);
  }
  v20 = *(int **)(a1 + 296);
  if ( v20 )
  {
    sub_1004CE50(*(_DWORD *)(a1 + 300), v20);
    v21 = *(_DWORD *)(a1 + 296);
    if ( v21 )
    {
      if ( v21 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v21, 0, 0, 1, dword_100AE9F4);
    }
  }
  v22 = *(int **)(a1 + 284);
  if ( v22 )
  {
    sub_1004CE50(*(_DWORD *)(a1 + 288), v22);
    v23 = *(_DWORD *)(a1 + 284);
    if ( v23 )
    {
      if ( v23 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v23, 0, 0, 1, dword_100AE9F4);
    }
  }
  `eh vector destructor iterator'((void *)(a1 + 212), 0xCu, 3, sub_10038C00);
  v24 = *(_DWORD *)(a1 + 192);
  if ( v24 )
  {
    if ( v24 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v24, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10060150) --------------------------------------------------------
int __stdcall sub_10060150(int a1)
{
  sub_10036840(a1);
  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 188) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 196) = 0;
  *(_DWORD *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 204) = 0;
  *(_WORD *)(a1 + 208) = 0;
  *(_BYTE *)(a1 + 210) = 0;
  `eh vector constructor iterator'((void *)(a1 + 212), 0xCu, 3, (int)unknown_libname_3, sub_10038C00);
  *(_DWORD *)(a1 + 284) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 292) = 0;
  *(_DWORD *)(a1 + 296) = 0;
  *(_DWORD *)(a1 + 300) = 0;
  *(_DWORD *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 308) = 0;
  *(_DWORD *)(a1 + 312) = 0;
  *(_DWORD *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 332) = 0;
  *(_DWORD *)(a1 + 336) = 0;
  *(_DWORD *)(a1 + 340) = 0;
  *(_DWORD *)(a1 + 344) = 0;
  *(_DWORD *)(a1 + 348) = 0;
  *(_DWORD *)(a1 + 352) = 0;
  *(_DWORD *)(a1 + 356) = 0;
  *(_DWORD *)(a1 + 360) = 0;
  *(_DWORD *)(a1 + 364) = 0;
  *(_DWORD *)(a1 + 368) = 0;
  *(_DWORD *)(a1 + 372) = 0;
  *(_DWORD *)(a1 + 376) = 0;
  *(_DWORD *)(a1 + 380) = 0;
  *(_DWORD *)(a1 + 384) = 0;
  *(_DWORD *)(a1 + 388) = 0;
  *(_DWORD *)(a1 + 392) = 0;
  *(_DWORD *)(a1 + 396) = 0;
  *(_DWORD *)(a1 + 400) = 0;
  *(_DWORD *)(a1 + 404) = 0;
  *(_DWORD *)(a1 + 408) = 0;
  *(_DWORD *)(a1 + 412) = 0;
  *(_DWORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = 0;
  *(_DWORD *)(a1 + 424) = 0;
  *(_DWORD *)(a1 + 428) = 0;
  *(_DWORD *)(a1 + 432) = 0;
  *(_DWORD *)(a1 + 436) = 0;
  *(_DWORD *)(a1 + 440) = 0;
  *(_DWORD *)(a1 + 444) = 0;
  *(_DWORD *)(a1 + 448) = 0;
  *(_DWORD *)(a1 + 452) = 0;
  *(_DWORD *)(a1 + 456) = 0;
  *(_DWORD *)(a1 + 460) = 0;
  *(_DWORD *)(a1 + 464) = 0;
  *(_DWORD *)(a1 + 468) = 0;
  *(_DWORD *)(a1 + 472) = 0;
  *(_DWORD *)(a1 + 476) = 0;
  *(_DWORD *)(a1 + 480) = 0;
  *(_DWORD *)(a1 + 484) = 0;
  *(_DWORD *)(a1 + 488) = 0;
  *(_DWORD *)(a1 + 492) = 0;
  *(_DWORD *)(a1 + 496) = 0;
  *(_DWORD *)(a1 + 500) = 0;
  *(_DWORD *)(a1 + 504) = 0;
  *(_DWORD *)(a1 + 508) = 0;
  *(_DWORD *)(a1 + 512) = GetCurrentThreadId();
  *(_DWORD *)(a1 + 516) = 0;
  *(_BYTE *)(a1 + 520) = 0;
  *(_DWORD *)(a1 + 524) = 0;
  *(_DWORD *)(a1 + 528) = -1;
  *(_DWORD *)(a1 + 532) = -1;
  *(_DWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 252) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 260) = 0;
  *(_DWORD *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 268) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 276) = 0;
  return a1;
}
// 1003F6D0: using guessed type int unknown_libname_3();

//----- (10060390) --------------------------------------------------------
char __stdcall sub_10060390(int a1)
{
  int v1; // ebp@1
  unsigned int v2; // ebx@1
  unsigned int v3; // edi@2
  int v4; // ebx@6
  unsigned int v5; // edi@6
  int v6; // edx@7
  int v7; // ecx@8
  unsigned int v8; // esi@8
  unsigned int v9; // esi@11
  int v10; // eax@12
  int v11; // edx@12
  int v12; // ecx@12
  int v13; // ecx@12
  bool v14; // zf@12
  int v15; // ecx@12
  int v16; // eax@12
  char *v17; // ebp@12
  unsigned int v18; // eax@13
  unsigned int v19; // edi@13
  _BYTE *v20; // ebx@15
  signed int v21; // eax@17
  unsigned int v22; // eax@19
  char v23; // al@26
  int v24; // ecx@26
  FILE *v25; // eax@29
  FILE *v26; // ST14_4@34
  unsigned int v27; // edx@36
  int v28; // eax@37
  FILE *v29; // eax@40
  FILE *v30; // ST14_4@45
  unsigned int v32; // [sp+14h] [bp-894h]@12
  int v33; // [sp+18h] [bp-890h]@14
  void *v34; // [sp+1Ch] [bp-88Ch]@10
  unsigned int v35; // [sp+20h] [bp-888h]@10
  unsigned int v36; // [sp+24h] [bp-884h]@10
  void *v37; // [sp+28h] [bp-880h]@10
  unsigned int v38; // [sp+2Ch] [bp-87Ch]@10
  unsigned int v39; // [sp+30h] [bp-878h]@10
  unsigned int v40; // [sp+34h] [bp-874h]@6
  int v41; // [sp+38h] [bp-870h]@3
  unsigned int v42; // [sp+3Ch] [bp-86Ch]@10
  int v43; // [sp+40h] [bp-868h]@2
  int v44; // [sp+44h] [bp-864h]@12
  int v45; // [sp+48h] [bp-860h]@6
  int v46; // [sp+4Ch] [bp-85Ch]@12
  int v47; // [sp+50h] [bp-858h]@12
  unsigned __int16 v48; // [sp+54h] [bp-854h]@26
  unsigned __int16 v49; // [sp+56h] [bp-852h]@36
  int v50; // [sp+5Ch] [bp-84Ch]@36
  int v51; // [sp+60h] [bp-848h]@36
  int v52; // [sp+64h] [bp-844h]@26
  int v53; // [sp+68h] [bp-840h]@26
  int v54; // [sp+6Ch] [bp-83Ch]@26
  void *v55; // [sp+70h] [bp-838h]@26
  unsigned int v56; // [sp+74h] [bp-834h]@26
  void *v57; // [sp+78h] [bp-830h]@26
  int v58; // [sp+7Ch] [bp-82Ch]@26
  int v59; // [sp+84h] [bp-824h]@26
  int v60; // [sp+88h] [bp-820h]@26
  char v61; // [sp+8Ch] [bp-81Ch]@26
  char v62; // [sp+8Dh] [bp-81Bh]@26
  char v63; // [sp+8Eh] [bp-81Ah]@26
  CHAR OutputString; // [sp+94h] [bp-814h]@34
  CHAR v65; // [sp+294h] [bp-614h]@40
  char DstBuf; // [sp+494h] [bp-414h]@29
  CHAR v67; // [sp+694h] [bp-214h]@45
  int v68; // [sp+8A4h] [bp-4h]@10

  v1 = a1;
  v2 = 0;
  if ( !*(_DWORD *)(a1 + 204) )
    return 1;
  v3 = *(_DWORD *)(a1 + 300);
  v43 = 0;
  if ( v3 <= 0 )
    return 1;
  v41 = 0;
  while ( (_BYTE)v2 || sub_1005D4D0(v2, v3, v1, 18) )
  {
    v4 = v41 + *(_DWORD *)(v1 + 296);
    v5 = 0;
    v45 = v4;
    v40 = 0;
    if ( !*(_DWORD *)(v4 + 4) )
      goto LABEL_49;
    v6 = *(_DWORD *)v4;
    do
    {
      v7 = *(_BYTE *)(*(_DWORD *)(v1 + 12 * (*(_DWORD *)(v6 + 4) >> 16) + 224)
                    + 660 * *(_DWORD *)v6
                    + 80 * (unsigned __int16)*(_DWORD *)(v6 + 4)
                    + 400)
         * *(_BYTE *)(*(_DWORD *)(v1 + 12 * (*(_DWORD *)(v6 + 4) >> 16) + 224)
                    + 660 * *(_DWORD *)v6
                    + 80 * (unsigned __int16)*(_DWORD *)(v6 + 4)
                    + 401);
      v8 = v7 + v40;
      ++v5;
      v6 += 8;
      v40 += v7;
    }
    while ( v5 < *(_DWORD *)(v4 + 4) );
    if ( !v8 )
      goto LABEL_49;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v68 = 0;
    v37 = 0;
    v38 = 0;
    v39 = 0;
    LOBYTE(v68) = 1;
    sub_10038B00((int)&v34, v8);
    sub_10032F10((int)&v37, v8);
    v42 = 0;
    if ( *(_DWORD *)(v4 + 4) > 0u )
    {
      v9 = v38;
      do
      {
        v10 = *(_DWORD *)(*(_DWORD *)v4 + 8 * v42);
        v11 = (unsigned __int16)*(_DWORD *)(*(_DWORD *)v4 + 8 * v42 + 4);
        v12 = *(_DWORD *)(*(_DWORD *)v4 + 8 * v42 + 4) >> 16;
        v47 = v12;
        v13 = *(_DWORD *)(v1 + 12 * v12 + 224) + 660 * v10;
        v11 *= 10;
        v14 = *(_BYTE *)(v13 + 8 * v11 + 401) == 0;
        v15 = v13 + 8 * v11 + 324;
        v46 = *(_DWORD *)(v1 + 188) + 260 * v10;
        v16 = *(_BYTE *)(v15 + 78);
        v44 = v15;
        v17 = (char *)&unk_100AD2F0 + 20 * v16;
        v32 = 0;
        if ( !v14 )
        {
          do
          {
            v18 = *(_BYTE *)(v15 + 76);
            v19 = 0;
            if ( *(_BYTE *)(v15 + 76) )
            {
              BYTE3(v33) = -1;
              do
              {
                v20 = (_BYTE *)(v19 + v32 * v18 + v15 + 12);
                if ( v9 >= v39 )
                {
                  sub_100943C0(v9 + 1, 0, (int)&v37, 1, 1u, 0);
                  v9 = v38;
                }
                *((_BYTE *)v37 + v9) = *v20;
                v21 = *(_BYTE *)(*(_DWORD *)(a1 + 4 * v47 + 28)
                               + 4
                               * (((v19 + *(_DWORD *)v17) & 3)
                                + 4
                                * (((v32 + *((_DWORD *)v17 + 1)) & 3)
                                 + 4 * (((v19 + *(_DWORD *)v17) >> 2) + 2 * ((v32 + *((_DWORD *)v17 + 1)) >> 2))))
                               + v46);
                v38 = ++v9;
                if ( v21 & 0xFFFFFF00 )
                  LOBYTE(v21) = ~(v21 >> 31);
                LOBYTE(v33) = v21;
                BYTE1(v33) = v21;
                BYTE2(v33) = v21;
                v22 = v35;
                if ( v35 >= v36 )
                {
                  sub_100943C0(v35 + 1, 0, (int)&v34, 1, 4u, 0);
                  v22 = v35;
                }
                *((_DWORD *)v34 + v22) = v33;
                v15 = v44;
                v35 = v22 + 1;
                v18 = *(_BYTE *)(v44 + 76);
                ++v19;
              }
              while ( v19 < v18 );
              v4 = v45;
            }
            ++v32;
          }
          while ( v32 < *(_BYTE *)(v15 + 77) );
        }
        v1 = a1;
        ++v42;
      }
      while ( v42 < *(_DWORD *)(v4 + 4) );
      v8 = v40;
    }
    v59 = -1;
    v60 = -1;
    v23 = *(_BYTE *)(v1 + 173);
    v54 = 0;
    v58 = 0;
    v62 = v23;
    v55 = v34;
    v56 = v8;
    v63 = 1;
    v57 = v37;
    v61 = 0;
    v59 = *(_DWORD *)(v4 + 24);
    v24 = *(_DWORD *)(v4 + 28);
    v52 = 0;
    v53 = 0;
    v60 = v24;
    v54 = v43;
    if ( sub_1005A170(v43, (int)&v48, (int)&v54, (int)&v52) )
    {
      *(_DWORD *)(v4 + 24) = v50;
      *(_DWORD *)(v4 + 28) = v51;
      *(_DWORD *)(v4 + 12) = v48;
      v27 = 0;
      *(_DWORD *)(v4 + 16) = v49;
      if ( *(_DWORD *)(v4 + 4) )
      {
        do
        {
          v28 = *(_DWORD *)(v1 + 12 * (*(_DWORD *)(*(_DWORD *)v4 + 8 * v27 + 4) >> 16) + 224)
              + 660 * *(_DWORD *)(*(_DWORD *)v4 + 8 * v27)
              + 80 * (unsigned __int16)*(_DWORD *)(*(_DWORD *)v4 + 8 * v27 + 4)
              + 324;
          *(_DWORD *)(v28 + 4) = v48;
          ++v27;
          *(_DWORD *)(v28 + 8) = v49;
        }
        while ( v27 < *(_DWORD *)(v4 + 4) );
      }
      LOBYTE(v68) = 0;
      if ( v37 )
      {
        if ( (unsigned __int8)v37 & 7 )
        {
          sprintf_s(&v65, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&v65);
          v29 = _iob_func();
          fputs(&v65, v29 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v37, 0, 0, 1, dword_100AE9F4);
        }
      }
      v68 = -1;
      if ( !v34 )
        goto LABEL_49;
      if ( (unsigned __int8)v34 & 7 )
      {
        sprintf_s(&v67, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&v67);
        v30 = _iob_func() + 2;
        fputs(&v67, v30);
LABEL_46:
        if ( IsDebuggerPresent() )
          DebugBreak();
        goto LABEL_49;
      }
      off_100AD9F4(v34, 0, 0, 1, dword_100AE9F4);
    }
    else
    {
      LOBYTE(v68) = 0;
      if ( v37 )
      {
        if ( (unsigned __int8)v37 & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v25 = _iob_func();
          fputs(&DstBuf, v25 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v37, 0, 0, 1, dword_100AE9F4);
        }
      }
      v68 = -1;
      if ( !v34 )
        goto LABEL_49;
      if ( (unsigned __int8)v34 & 7 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_free: bad ptr");
        OutputDebugStringA(&OutputString);
        v26 = _iob_func() + 2;
        fputs(&OutputString, v26);
        goto LABEL_46;
      }
      off_100AD9F4(v34, 0, 0, 1, dword_100AE9F4);
    }
LABEL_49:
    v3 = *(_DWORD *)(v1 + 300);
    v41 += 40;
    v2 = v43 + 1;
    v43 = v2;
    if ( v2 >= v3 )
      return 1;
  }
  return 0;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100609B0) --------------------------------------------------------
char __stdcall sub_100609B0(int a1)
{
  int v1; // esi@1
  unsigned int v2; // edi@2
  unsigned int v3; // ebx@2
  int v4; // ebx@7
  unsigned int v5; // edi@7
  unsigned int v6; // ebp@7
  int v7; // ecx@8
  unsigned int v8; // ebp@12
  int v9; // ecx@13
  unsigned int v10; // edi@13
  bool v11; // zf@13
  char *v12; // edx@13
  unsigned int v13; // eax@14
  unsigned int v14; // ebx@14
  _BYTE *v15; // esi@15
  unsigned int v16; // eax@15
  int v17; // esi@17
  unsigned int v18; // esi@17
  unsigned int v19; // edi@17
  int v20; // edx@19
  unsigned int v21; // edx@20
  char v22; // cl@24
  int v23; // edx@24
  FILE *v24; // eax@27
  FILE *v25; // ST14_4@32
  unsigned int v26; // ecx@34
  int v27; // eax@35
  FILE *v28; // eax@38
  FILE *v29; // ST14_4@43
  void *v31; // [sp+10h] [bp-890h]@11
  unsigned int v32; // [sp+14h] [bp-88Ch]@11
  unsigned int v33; // [sp+18h] [bp-888h]@11
  void *v34; // [sp+1Ch] [bp-884h]@11
  unsigned int v35; // [sp+20h] [bp-880h]@11
  unsigned int v36; // [sp+24h] [bp-87Ch]@11
  unsigned int v37; // [sp+28h] [bp-878h]@2
  int v38; // [sp+2Ch] [bp-874h]@3
  unsigned int v39; // [sp+30h] [bp-870h]@13
  unsigned int v40; // [sp+34h] [bp-86Ch]@11
  int v41; // [sp+38h] [bp-868h]@13
  char *v42; // [sp+3Ch] [bp-864h]@13
  unsigned int v43; // [sp+40h] [bp-860h]@10
  int v44; // [sp+44h] [bp-85Ch]@7
  int v45; // [sp+48h] [bp-858h]@13
  unsigned __int16 v46; // [sp+4Ch] [bp-854h]@24
  unsigned __int16 v47; // [sp+4Eh] [bp-852h]@34
  int v48; // [sp+54h] [bp-84Ch]@34
  int v49; // [sp+58h] [bp-848h]@34
  int v50; // [sp+5Ch] [bp-844h]@24
  int v51; // [sp+60h] [bp-840h]@24
  unsigned int v52; // [sp+64h] [bp-83Ch]@24
  void *v53; // [sp+68h] [bp-838h]@24
  unsigned int v54; // [sp+6Ch] [bp-834h]@24
  void *v55; // [sp+70h] [bp-830h]@24
  int v56; // [sp+74h] [bp-82Ch]@24
  int v57; // [sp+7Ch] [bp-824h]@24
  int v58; // [sp+80h] [bp-820h]@24
  char v59; // [sp+84h] [bp-81Ch]@24
  char v60; // [sp+85h] [bp-81Bh]@24
  char v61; // [sp+86h] [bp-81Ah]@24
  CHAR OutputString; // [sp+8Ch] [bp-814h]@32
  CHAR v63; // [sp+28Ch] [bp-614h]@38
  char DstBuf; // [sp+48Ch] [bp-414h]@27
  CHAR v65; // [sp+68Ch] [bp-214h]@43
  int v66; // [sp+89Ch] [bp-4h]@11

  v1 = a1;
  if ( !*(_BYTE *)(a1 + 208) )
    return 1;
  v2 = *(_DWORD *)(a1 + 288);
  v3 = 0;
  v37 = 0;
  if ( !v2 )
    return 1;
  v38 = 0;
  while ( (_BYTE)v3 || sub_1005D4D0(v3, v2, v1, 17) )
  {
    v4 = v38 + *(_DWORD *)(v1 + 284);
    v5 = 0;
    v6 = 0;
    v44 = v4;
    if ( *(_DWORD *)(v4 + 4) )
    {
      v7 = *(_DWORD *)v4;
      do
      {
        ++v5;
        v6 += *(_BYTE *)(*(_DWORD *)(a1 + 212) + 660 * *(_DWORD *)v7 + 80 * *(_DWORD *)(v7 + 4) + 400)
            * *(_BYTE *)(*(_DWORD *)(a1 + 212) + 660 * *(_DWORD *)v7 + 80 * *(_DWORD *)(v7 + 4) + 401);
        v7 += 8;
      }
      while ( v5 < *(_DWORD *)(v4 + 4) );
      v43 = v6;
      if ( v6 )
      {
        v34 = 0;
        v35 = 0;
        v36 = 0;
        v66 = 0;
        v31 = 0;
        v32 = 0;
        v33 = 0;
        LOBYTE(v66) = 1;
        sub_10038B00((int)&v34, v6);
        sub_10032F10((int)&v31, v6);
        v40 = 0;
        if ( *(_DWORD *)(v4 + 4) > 0u )
        {
          v8 = v35;
          do
          {
            v9 = *(_DWORD *)(a1 + 212)
               + 660 * *(_DWORD *)(*(_DWORD *)v4 + 8 * v40)
               + 80 * *(_DWORD *)(*(_DWORD *)v4 + 8 * v40 + 4)
               + 324;
            v45 = *(_DWORD *)(a1 + 188) + 260 * *(_DWORD *)(*(_DWORD *)v4 + 8 * v40);
            v10 = 0;
            v11 = *(_BYTE *)(v9 + 77) == 0;
            v12 = (char *)&unk_100AD2F0 + 20 * *(_BYTE *)(v9 + 78);
            v41 = v9;
            v42 = v12;
            v39 = 0;
            if ( !v11 )
            {
              do
              {
                v13 = *(_BYTE *)(v9 + 76);
                v14 = 0;
                if ( *(_BYTE *)(v9 + 76) )
                {
                  do
                  {
                    v15 = (_BYTE *)(v14 + v10 * v13 + v9 + 12);
                    v16 = v32;
                    if ( v32 >= v33 )
                    {
                      sub_100943C0(v32 + 1, 0, (int)&v31, 1, 1u, 0);
                      v16 = v32;
                    }
                    *((_BYTE *)v31 + v16) = *v15;
                    v17 = *((_DWORD *)v42 + 1);
                    v32 = v16 + 1;
                    v18 = v10 + v17;
                    v19 = v14 + *(_DWORD *)v42;
                    if ( v8 >= v36 )
                    {
                      sub_100943C0(v8 + 1, 0, (int)&v34, 1, 4u, 0);
                      v8 = v35;
                    }
                    v20 = *(_DWORD *)(v45 + 4 * ((v19 & 3) + 4 * ((v18 & 3) + 4 * ((v19 >> 2) + 2 * (v18 >> 2)))));
                    v9 = v41;
                    v10 = v39;
                    *((_DWORD *)v34 + v8) = v20;
                    v13 = *(_BYTE *)(v9 + 76);
                    ++v8;
                    ++v14;
                    v35 = v8;
                  }
                  while ( v14 < v13 );
                }
                v21 = *(_BYTE *)(v9 + 77);
                v39 = ++v10;
              }
              while ( v10 < v21 );
              v4 = v44;
            }
            ++v40;
          }
          while ( v40 < *(_DWORD *)(v4 + 4) );
          v6 = v43;
        }
        v57 = -1;
        v58 = -1;
        v22 = *(_BYTE *)(a1 + 173);
        v52 = 0;
        v56 = 0;
        v60 = v22;
        v53 = v34;
        v61 = 1;
        v55 = v31;
        v54 = v6;
        v59 = 1;
        v57 = *(_DWORD *)(v4 + 24);
        v23 = *(_DWORD *)(v4 + 28);
        v50 = 0;
        v51 = 0;
        v58 = v23;
        v52 = v37;
        if ( sub_1005A170(v23, (int)&v46, (int)&v52, (int)&v50) )
        {
          *(_DWORD *)(v4 + 24) = v48;
          *(_DWORD *)(v4 + 28) = v49;
          *(_DWORD *)(v4 + 12) = v46;
          v26 = 0;
          *(_DWORD *)(v4 + 16) = v47;
          if ( *(_DWORD *)(v4 + 4) )
          {
            do
            {
              v27 = *(_DWORD *)(a1 + 212)
                  + 660 * *(_DWORD *)(*(_DWORD *)v4 + 8 * v26)
                  + 80 * *(_DWORD *)(*(_DWORD *)v4 + 8 * v26 + 4)
                  + 324;
              *(_DWORD *)(v27 + 4) = v46;
              ++v26;
              *(_DWORD *)(v27 + 8) = v47;
            }
            while ( v26 < *(_DWORD *)(v4 + 4) );
          }
          LOBYTE(v66) = 0;
          if ( v31 )
          {
            if ( (unsigned __int8)v31 & 7 )
            {
              sprintf_s(&v63, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
              OutputDebugStringA(&v63);
              v28 = _iob_func();
              fputs(&v63, v28 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v31, 0, 0, 1, dword_100AE9F4);
            }
          }
          v66 = -1;
          if ( v34 )
          {
            if ( !((unsigned __int8)v34 & 7) )
            {
              off_100AD9F4(v34, 0, 0, 1, dword_100AE9F4);
              goto LABEL_47;
            }
            sprintf_s(&v65, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
            OutputDebugStringA(&v65);
            v29 = _iob_func() + 2;
            fputs(&v65, v29);
            goto LABEL_44;
          }
        }
        else
        {
          LOBYTE(v66) = 0;
          if ( v31 )
          {
            if ( (unsigned __int8)v31 & 7 )
            {
              sprintf_s(
                &DstBuf,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_free: bad ptr");
              OutputDebugStringA(&DstBuf);
              v24 = _iob_func();
              fputs(&DstBuf, v24 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v31, 0, 0, 1, dword_100AE9F4);
            }
          }
          v66 = -1;
          if ( v34 )
          {
            if ( !((unsigned __int8)v34 & 7) )
            {
              off_100AD9F4(v34, 0, 0, 1, dword_100AE9F4);
              goto LABEL_47;
            }
            sprintf_s(
              &OutputString,
              0x200u,
              "%s(%u): Assertion failed: \"%s\"\n",
              "crn_mem.cpp",
              216,
              "crnlib_free: bad ptr");
            OutputDebugStringA(&OutputString);
            v25 = _iob_func() + 2;
            fputs(&OutputString, v25);
LABEL_44:
            if ( IsDebuggerPresent() )
              DebugBreak();
            goto LABEL_47;
          }
        }
      }
    }
LABEL_47:
    v2 = *(_DWORD *)(a1 + 288);
    v38 += 40;
    v3 = v37 + 1;
    v37 = v3;
    if ( v3 >= v2 )
      return 1;
    v1 = a1;
  }
  return 0;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10060F80) --------------------------------------------------------
void __thiscall sub_10060F80(void *this, int a2, int a3, int a4)
{
  char v4; // di@1
  int v5; // esi@1
  unsigned int v6; // ebx@1
  int v7; // eax@9
  int v8; // ebx@11
  unsigned int v9; // ecx@11
  unsigned int v10; // eax@12
  int v11; // ecx@16
  int v12; // edi@16
  int v13; // eax@16
  bool v14; // zf@16
  char *v15; // edi@16
  unsigned int v16; // edx@17
  unsigned int v17; // eax@19
  unsigned int v18; // ecx@26
  int v19; // ecx@33
  int v20; // eax@33
  unsigned int v21; // ecx@33
  int v22; // eax@33
  int v23; // edx@33
  int v24; // ecx@33
  int v25; // edi@33
  int v26; // eax@33
  size_t v27; // edi@33
  char *v28; // ecx@33
  void *v29; // eax@45
  int v30; // [sp-10h] [bp-4E0h]@47
  int v31; // [sp-Ch] [bp-4DCh]@47
  int v32; // [sp-4h] [bp-4D4h]@47
  unsigned int v33; // [sp+Ch] [bp-4C4h]@14
  int v34; // [sp+Ch] [bp-4C4h]@32
  unsigned int v35; // [sp+10h] [bp-4C0h]@16
  unsigned int v36; // [sp+10h] [bp-4C0h]@32
  void *v37; // [sp+14h] [bp-4BCh]@1
  unsigned int v38; // [sp+18h] [bp-4B8h]@1
  unsigned int v39; // [sp+1Ch] [bp-4B4h]@1
  unsigned int v40; // [sp+20h] [bp-4B0h]@1
  int v41; // [sp+24h] [bp-4ACh]@15
  void *v42; // [sp+28h] [bp-4A8h]@1
  unsigned int v43; // [sp+2Ch] [bp-4A4h]@1
  unsigned int v44; // [sp+30h] [bp-4A0h]@1
  int v45; // [sp+34h] [bp-49Ch]@2
  unsigned int v46; // [sp+38h] [bp-498h]@17
  int v47; // [sp+3Ch] [bp-494h]@16
  int v48; // [sp+40h] [bp-490h]@11
  int v49; // [sp+44h] [bp-48Ch]@16
  int v50; // [sp+48h] [bp-488h]@18
  int v51; // [sp+4Ch] [bp-484h]@29
  void *v52; // [sp+50h] [bp-480h]@32
  int v53; // [sp+58h] [bp-478h]@32
  int v54; // [sp+5Ch] [bp-474h]@32
  unsigned __int8 v55; // [sp+60h] [bp-470h]@32
  unsigned __int8 v56; // [sp+61h] [bp-46Fh]@32
  char v57; // [sp+62h] [bp-46Eh]@32
  unsigned int v58; // [sp+68h] [bp-468h]@32
  void *v59; // [sp+6Ch] [bp-464h]@32
  unsigned int v60; // [sp+70h] [bp-460h]@32
  int v61; // [sp+74h] [bp-45Ch]@32
  int v62; // [sp+78h] [bp-458h]@32
  char v63; // [sp+7Ch] [bp-454h]@32
  int v64; // [sp+80h] [bp-450h]@32
  int v65; // [sp+84h] [bp-44Ch]@32
  int v66; // [sp+88h] [bp-448h]@32
  int v67; // [sp+8Ch] [bp-444h]@32
  int v68; // [sp+90h] [bp-440h]@32
  int v69; // [sp+94h] [bp-43Ch]@32
  int v70; // [sp+98h] [bp-438h]@32
  int v71; // [sp+9Ch] [bp-434h]@32
  int v72; // [sp+A0h] [bp-430h]@32
  int v73; // [sp+A4h] [bp-42Ch]@32
  int v74; // [sp+A8h] [bp-428h]@32
  int v75; // [sp+ACh] [bp-424h]@32
  int v76; // [sp+B0h] [bp-420h]@32
  int v77; // [sp+B4h] [bp-41Ch]@32
  int v78; // [sp+4B8h] [bp-18h]@32
  int v79; // [sp+4BCh] [bp-14h]@32
  int v80; // [sp+4CCh] [bp-4h]@1

  v4 = 0;
  v5 = (int)this;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v80 = 0;
  sub_10038B00((int)&v37, 0x200u);
  v42 = 0;
  v43 = 0;
  v44 = 0;
  LOBYTE(v80) = 1;
  sub_10032F10((int)&v42, 0x200u);
  v6 = 0;
  v40 = 0;
  if ( *(_DWORD *)(v5 + 300) > 0u )
  {
    v45 = 0;
    while ( !*(_BYTE *)(v5 + 520) )
    {
      if ( GetCurrentThreadId() == *(_DWORD *)(v5 + 512) && 0 == *(_DWORD *)(v5 + 516) && !(v6 & 0x3F) )
      {
        if ( !sub_1005D4D0(v6, *(_DWORD *)(v5 + 300), v5, 8) )
        {
          LOBYTE(v80) = 0;
          if ( v42 )
          {
            if ( (unsigned __int8)v42 & 7 )
              sub_100927E0((int)"crnlib_free: bad ptr");
            else
              off_100AD9F4(v42, 0, 0, 1, dword_100AE9F4);
          }
          v80 = -1;
          v29 = v37;
          if ( !v37 )
            return;
          if ( (unsigned __int8)v37 & 7 )
            goto LABEL_51;
          v32 = dword_100AE9F4;
          v31 = 0;
          v30 = 0;
          goto LABEL_53;
        }
        v6 = v40;
        v4 = 0;
      }
      v7 = *(_DWORD *)(*(_DWORD *)(v5 + 524) + 4);
      if ( !v7 || v6 % (v7 + 1) == a2 )
      {
        v8 = v45 + *(_DWORD *)(v5 + 296);
        v9 = *(_DWORD *)(v8 + 4);
        v48 = v45 + *(_DWORD *)(v5 + 296);
        if ( v9 )
        {
          v10 = v38;
          if ( v38 )
          {
            v38 = 0;
            v10 = 0;
          }
          v33 = 0;
          if ( v9 > 0 )
          {
            *(_WORD *)((char *)&v41 + 1) = 0;
            BYTE3(v41) = 0;
            do
            {
              v11 = *(_DWORD *)(*(_DWORD *)v8 + 8 * v33);
              v12 = (unsigned __int16)*(_DWORD *)(*(_DWORD *)v8 + 8 * v33 + 4);
              v47 = *(_DWORD *)(*(_DWORD *)v8 + 8 * v33 + 4) >> 16;
              v13 = *(_BYTE *)(*(_DWORD *)(v5 + 12 * v47 + 224) + 660 * v11 + 80 * v12 + 82);
              v14 = dword_100AD2FC[5 * v13] == 0;
              v15 = (char *)&unk_100AD2F0 + 20 * v13;
              v49 = v11;
              LOBYTE(v41) = 0;
              v35 = 0;
              if ( !v14 )
              {
                do
                {
                  v16 = 0;
                  v46 = 0;
                  if ( *((_DWORD *)v15 + 2) )
                  {
                    v50 = 65 * v11;
                    do
                    {
                      v17 = v38;
                      LOBYTE(v41) = *(_BYTE *)(*(_DWORD *)(v5 + 4 * v47 + 28)
                                             + 4
                                             * (v50
                                              + ((v16 + *(_DWORD *)v15) & 3)
                                              + 4
                                              * (((v35 + *((_DWORD *)v15 + 1)) & 3)
                                               + 4
                                               * (((v16 + *(_DWORD *)v15) >> 2) + 2
                                                                                * ((v35 + *((_DWORD *)v15 + 1)) >> 2))))
                                             + *(_DWORD *)(v5 + 188));
                      if ( v38 >= v39 )
                      {
                        sub_100943C0(v38 + 1, 0, (int)&v37, 1, 4u, 0);
                        v17 = v38;
                      }
                      *((_DWORD *)v37 + v17) = v41;
                      v16 = v46 + 1;
                      v38 = v17 + 1;
                      v46 = v16;
                    }
                    while ( v16 < *((_DWORD *)v15 + 2) );
                    v8 = v48;
                    v11 = v49;
                  }
                  ++v35;
                }
                while ( v35 < *((_DWORD *)v15 + 3) );
              }
              v10 = v38;
              ++v33;
            }
            while ( v33 < *(_DWORD *)(v8 + 4) );
            v4 = 0;
          }
          v18 = v43;
          if ( v10 != v43 )
          {
            if ( v10 >= v43 )
            {
              if ( v10 > v44 )
              {
                LOBYTE(v51) = v10 == v43 + 1;
                sub_100943C0(v10, 0, (int)&v42, v10 == v43 + 1, 1u, v4);
                v18 = v43;
                v10 = v38;
              }
              memset((char *)v42 + v18, 0, v10 - v18);
              v10 = v38;
            }
            v43 = v10;
          }
          v60 = v10;
          v58 = v40;
          v59 = v37;
          v61 = 0;
          v62 = 4;
          v63 = 0;
          v52 = v42;
          v64 = 0;
          v65 = 0;
          v66 = 0;
          v67 = 0;
          v68 = 0;
          v69 = 0;
          v70 = 0;
          v71 = 0;
          v72 = 0;
          v73 = 0;
          v74 = 0;
          v75 = 0;
          v76 = 0;
          v77 = 0;
          v78 = 0;
          v79 = 0;
          LOBYTE(v80) = 6;
          sub_10032F10((int)&v66, 0x10u);
          sub_10036310((int)&v69, 0x10u);
          LOBYTE(v80) = 7;
          sub_10093A30((int)&v64, (int)&v58, (int)&v52);
          *(_DWORD *)(v8 + 12) = v55;
          *(_DWORD *)(v8 + 16) = v56;
          v34 = 0;
          *(_BYTE *)(v8 + 32) = v57 != 0;
          *(_DWORD *)(v8 + 24) = v53;
          *(_DWORD *)(v8 + 28) = v54;
          v36 = 0;
          if ( *(_DWORD *)(v8 + 4) > 0u )
          {
            do
            {
              v19 = *(_DWORD *)v8 + 8 * v36;
              v20 = *(_DWORD *)v19;
              v21 = *(_DWORD *)(v19 + 4);
              v22 = *(_DWORD *)(v5 + 12 * (v21 >> 16) + 224) + 660 * v20;
              v23 = 80 * (unsigned __int16)v21;
              v24 = *(_BYTE *)(v22 + v23 + 80);
              v25 = *(_BYTE *)(v22 + v23 + 81);
              v26 = v23 + v22;
              v27 = v24 * v25;
              *(_DWORD *)(v26 + 324) = v40;
              *(_DWORD *)(v26 + 328) = v55;
              *(_DWORD *)(v26 + 332) = v56;
              *(_BYTE *)(v26 + 403) = v57 != 0;
              *(_BYTE *)(v26 + 400) = *(_BYTE *)(v26 + 80);
              *(_BYTE *)(v26 + 401) = *(_BYTE *)(v26 + 81);
              v28 = (char *)v42 + v34;
              *(_BYTE *)(v26 + 402) = *(_BYTE *)(v26 + 82);
              memcpy((void *)(v26 + 336), v28, v27);
              v34 += v27;
              ++v36;
            }
            while ( v36 < *(_DWORD *)(v8 + 4) );
            v4 = 0;
          }
          LOBYTE(v80) = 1;
          sub_10032BC0((int)&v64);
        }
        v6 = v40;
      }
      v45 += 40;
      v40 = ++v6;
      if ( v6 >= *(_DWORD *)(v5 + 300) )
        break;
    }
  }
  LOBYTE(v80) = 0;
  if ( v42 )
  {
    if ( (unsigned __int8)v42 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v42, 0, 0, 1, dword_100AE9F4);
  }
  v80 = -1;
  v29 = v37;
  if ( v37 )
  {
    if ( (unsigned __int8)v37 & 7 )
    {
LABEL_51:
      sub_100927E0((int)"crnlib_free: bad ptr");
    }
    else
    {
      v32 = dword_100AE9F4;
      v31 = 0;
      v30 = 0;
LABEL_53:
      off_100AD9F4(v29, v30, v31, 1, v32);
    }
  }
}
// 100AD2FC: using guessed type int dword_100AD2FC[];
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10061520) --------------------------------------------------------
void __userpurge sub_10061520(int a1@<eax>, unsigned int a2@<ecx>, _DWORD *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9, int a10)
{
  unsigned int v10; // esi@1
  unsigned int v11; // ebp@1
  unsigned int v12; // edi@1
  char *v13; // ecx@2
  int v14; // eax@4
  unsigned int v15; // esi@4
  char *v16; // [sp+0h] [bp-56Ch]@2
  int v17; // [sp+4h] [bp-568h]@8
  char *v18; // [sp+8h] [bp-564h]@8
  unsigned int v19; // [sp+Ch] [bp-560h]@8
  int v20; // [sp+10h] [bp-55Ch]@8
  int v21; // [sp+14h] [bp-558h]@8
  char v22; // [sp+18h] [bp-554h]@8
  int v23; // [sp+1Ch] [bp-550h]@8
  int v24; // [sp+20h] [bp-54Ch]@8
  int v25; // [sp+24h] [bp-548h]@8
  int v26; // [sp+28h] [bp-544h]@8
  int v27; // [sp+2Ch] [bp-540h]@8
  int v28; // [sp+30h] [bp-53Ch]@8
  int v29; // [sp+34h] [bp-538h]@8
  int v30; // [sp+38h] [bp-534h]@8
  int v31; // [sp+3Ch] [bp-530h]@8
  int v32; // [sp+40h] [bp-52Ch]@8
  int v33; // [sp+44h] [bp-528h]@8
  int v34; // [sp+48h] [bp-524h]@8
  int v35; // [sp+4Ch] [bp-520h]@8
  int v36; // [sp+50h] [bp-51Ch]@8
  int v37; // [sp+454h] [bp-118h]@8
  int v38; // [sp+458h] [bp-114h]@8
  char v39; // [sp+45Ch] [bp-110h]@8
  char v40; // [sp+45Eh] [bp-10Eh]@2
  int v41; // [sp+560h] [bp-Ch]@1
  int (__thiscall *v42)(void *); // [sp+564h] [bp-8h]@1
  int v43; // [sp+568h] [bp-4h]@1

  v43 = -1;
  v42 = sub_10096A7A;
  v41 = a1;
  v10 = a8;
  v11 = 0;
  v12 = a2;
  if ( a8 )
  {
    v13 = &v40;
    v16 = &v40;
    do
    {
      if ( v12 > 0 )
      {
        v14 = *(_DWORD *)(a5 + 20) + 4 * (a6 + *(_DWORD *)(a5 + 8) * (v11 + a7));
        v15 = v12;
        do
        {
          *(v13 - 2) = *(_BYTE *)v14;
          *(v13 - 1) = *(_BYTE *)(v14 + 1);
          *v13 = *(_BYTE *)(v14 + 2);
          v13[1] = *(_BYTE *)(v14 + 3);
          v14 += 4;
          v13 += 4;
          --v15;
        }
        while ( v15 );
        v10 = a8;
      }
      ++v11;
      v13 = &v16[4 * v12];
      v16 += 4 * v12;
    }
    while ( v11 < v10 );
  }
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v43 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  LOBYTE(v43) = 4;
  sub_10032F10((int)&v25, 0x10u);
  sub_10036310((int)&v28, 0x10u);
  v43 = 5;
  v17 = a4;
  v18 = &v39;
  v20 = a9;
  *a3 = a10;
  v19 = v10 * v12;
  v22 = 0;
  v21 = 2;
  sub_10093A30((int)&v23, (int)&v17, (int)a3);
  v43 = -1;
  sub_10032BC0((int)&v23);
}

//----- (100616D0) --------------------------------------------------------
bool __stdcall sub_100616D0(int a1, char a2)
{
  char v2; // bl@1
  unsigned int v3; // esi@1
  unsigned int v4; // ebp@1
  double v5; // st7@4
  double v6; // st6@4
  double v7; // st5@4
  char *v8; // edi@5
  signed int v9; // ebx@5
  unsigned int v10; // esi@6
  int v11; // eax@6
  int (__cdecl *v12)(unsigned int, signed int, int, unsigned int, _DWORD); // edi@15
  unsigned int v13; // ecx@15
  signed int v14; // eax@17
  int v16; // esi@25
  char *v17; // eax@25
  double v18; // st4@26
  unsigned int v19; // ebx@28
  unsigned int v20; // eax@28
  unsigned int v21; // ecx@28
  unsigned int v22; // esi@28
  unsigned int v23; // eax@28
  unsigned int v24; // edx@28
  int v25; // ecx@28
  unsigned int v26; // ecx@29
  double v27; // st3@31
  unsigned int v28; // eax@31
  unsigned int v29; // esi@37
  double v30; // st3@37
  char *v31; // eax@37
  unsigned int v32; // edi@37
  char *v33; // ecx@38
  char *v34; // edx@40
  char *v35; // ecx@40
  unsigned int v36; // edi@45
  char *v37; // edx@45
  int v38; // esi@45
  char *v39; // ecx@45
  unsigned int v40; // eax@47
  unsigned int v41; // esi@47
  int v42; // edi@47
  char v43; // dl@48
  int v44; // ebx@48
  char *v45; // ebp@48
  bool v46; // zf@48
  char *v47; // edi@52
  char *v48; // esi@52
  unsigned int v49; // eax@54
  int v50; // ecx@55
  double v51; // st4@56
  int v52; // ecx@58
  float v53; // ST28_4@58
  double v54; // st4@59
  int v55; // ecx@61
  float v56; // ST28_4@61
  double v57; // st4@62
  int v58; // ecx@64
  float v59; // ST28_4@64
  double v60; // st4@65
  int v61; // ecx@67
  float v62; // ST28_4@67
  double v63; // st4@68
  int v64; // ecx@70
  float v65; // ST28_4@70
  double v66; // st4@71
  int v67; // ecx@73
  float v68; // ST28_4@73
  double v69; // st4@74
  int v70; // ecx@76
  float v71; // ST28_4@76
  double v72; // st4@77
  unsigned int v73; // esi@80
  _DWORD *v74; // eax@80
  unsigned int v75; // eax@91
  _DWORD *v76; // ebx@94
  unsigned int v77; // edi@96
  int v78; // ebp@98
  unsigned int v79; // esi@98
  double v80; // st5@99
  signed int v81; // eax@100
  char v82; // al@101
  signed int v83; // eax@105
  int v84; // edx@110
  int v85; // edi@113
  void (*v86)(char *, size_t, const char *, ...); // ebp@115
  void (__cdecl *v87)(const char *, FILE *); // ebx@115
  int *v88; // esi@116
  int v89; // eax@117
  FILE *v90; // eax@119
  int *v91; // eax@123
  FILE *v92; // eax@125
  int v93; // edi@130
  int v94; // eax@130
  struct _SINGLE_LIST_ENTRY *v95; // esi@130
  FILE *v96; // eax@132
  int v97; // ebx@134
  PSINGLE_LIST_ENTRY v98; // eax@135
  FILE *v99; // eax@138
  FILE *v100; // eax@145
  int v101; // ecx@149
  bool v102; // bl@153
  float v103; // [sp+10h] [bp-CE4h]@0
  char *v104; // [sp+14h] [bp-CE0h]@37
  int v105; // [sp+1Ch] [bp-CD8h]@26
  char *v106; // [sp+20h] [bp-CD4h]@28
  char *v107; // [sp+24h] [bp-CD0h]@26
  _DWORD *v108; // [sp+28h] [bp-CCCh]@13
  unsigned int v109; // [sp+2Ch] [bp-CC8h]@1
  int v110; // [sp+30h] [bp-CC4h]@13
  unsigned __int64 v111; // [sp+34h] [bp-CC0h]@5
  unsigned int v112; // [sp+40h] [bp-CB4h]@3
  int v113; // [sp+44h] [bp-CB0h]@1
  char *v114; // [sp+48h] [bp-CACh]@26
  char *v115; // [sp+4Ch] [bp-CA8h]@45
  int v116; // [sp+50h] [bp-CA4h]@45
  int v117; // [sp+54h] [bp-CA0h]@12
  int v118; // [sp+58h] [bp-C9Ch]@13
  unsigned int v119; // [sp+5Ch] [bp-C98h]@13
  int v120; // [sp+60h] [bp-C94h]@9
  int v121; // [sp+64h] [bp-C90h]@80
  int v122; // [sp+68h] [bp-C8Ch]@80
  int v123; // [sp+6Ch] [bp-C88h]@80
  int v124; // [sp+70h] [bp-C84h]@80
  int v125; // [sp+74h] [bp-C80h]@80
  int v126; // [sp+78h] [bp-C7Ch]@80
  int v127; // [sp+7Ch] [bp-C78h]@80
  int v128; // [sp+80h] [bp-C74h]@80
  int v129; // [sp+84h] [bp-C70h]@80
  int v130; // [sp+88h] [bp-C6Ch]@80
  int v131; // [sp+8Ch] [bp-C68h]@80
  int v132; // [sp+90h] [bp-C64h]@80
  int v133; // [sp+94h] [bp-C60h]@80
  int v134; // [sp+98h] [bp-C5Ch]@80
  int v135; // [sp+9Ch] [bp-C58h]@80
  float v136; // [sp+A0h] [bp-C54h]@79
  int v137; // [sp+A4h] [bp-C50h]@58
  int v138; // [sp+A8h] [bp-C4Ch]@61
  int v139; // [sp+ACh] [bp-C48h]@64
  int v140; // [sp+B0h] [bp-C44h]@67
  int v141; // [sp+B4h] [bp-C40h]@70
  int v142; // [sp+B8h] [bp-C3Ch]@73
  int v143; // [sp+BCh] [bp-C38h]@76
  int v144; // [sp+C0h] [bp-C34h]@80
  int v145; // [sp+C4h] [bp-C30h]@80
  int v146; // [sp+C8h] [bp-C2Ch]@80
  int v147; // [sp+CCh] [bp-C28h]@80
  int v148; // [sp+D0h] [bp-C24h]@80
  int v149; // [sp+D4h] [bp-C20h]@80
  int v150; // [sp+D8h] [bp-C1Ch]@80
  int v151; // [sp+DCh] [bp-C18h]@80
  float v152; // [sp+E0h] [bp-C14h]@80
  LARGE_INTEGER PerformanceCount; // [sp+E4h] [bp-C10h]@88
  int v154; // [sp+ECh] [bp-C08h]@88
  int v155; // [sp+F0h] [bp-C04h]@88
  char v156; // [sp+F4h] [bp-C00h]@88
  int v157; // [sp+100h] [bp-BF4h]@80
  int v158; // [sp+108h] [bp-BECh]@129
  char v159; // [sp+10Ch] [bp-BE8h]@129
  int v160; // [sp+110h] [bp-BE4h]@129
  unsigned int v161; // [sp+114h] [bp-BE0h]@129
  char *v162; // [sp+118h] [bp-BDCh]@129
  int v163; // [sp+11Ch] [bp-BD8h]@129
  _DWORD *v164; // [sp+120h] [bp-BD4h]@129
  int v165; // [sp+124h] [bp-BD0h]@129
  int v166; // [sp+128h] [bp-BCCh]@80
  int v167; // [sp+12Ch] [bp-BC8h]@80
  int v168; // [sp+130h] [bp-BC4h]@80
  int v169; // [sp+134h] [bp-BC0h]@80
  int v170; // [sp+138h] [bp-BBCh]@80
  int v171; // [sp+13Ch] [bp-BB8h]@80
  int v172; // [sp+140h] [bp-BB4h]@80
  int v173; // [sp+144h] [bp-BB0h]@80
  int v174; // [sp+148h] [bp-BACh]@80
  int v175; // [sp+14Ch] [bp-BA8h]@80
  int v176; // [sp+150h] [bp-BA4h]@80
  int v177; // [sp+154h] [bp-BA0h]@80
  int v178; // [sp+158h] [bp-B9Ch]@80
  int v179; // [sp+15Ch] [bp-B98h]@80
  int v180; // [sp+160h] [bp-B94h]@80
  float v181; // [sp+164h] [bp-B90h]@80
  int v182; // [sp+168h] [bp-B8Ch]@80
  char v183[20]; // [sp+16Ch] [bp-B88h]@40
  struct _SINGLE_LIST_ENTRY *v184; // [sp+180h] [bp-B74h]@143
  char v185; // [sp+184h] [bp-B70h]@1
  int v186; // [sp+1A0h] [bp-B54h]@98
  unsigned int v187; // [sp+1A4h] [bp-B50h]@96
  char v188[4]; // [sp+214h] [bp-AE0h]@3
  char v189[140]; // [sp+218h] [bp-ADCh]@5
  char v190; // [sp+2A4h] [bp-A50h]@48
  char v191; // [sp+2A5h] [bp-A4Fh]@52
  CHAR OutputString; // [sp+2E4h] [bp-A10h]@125
  CHAR v193; // [sp+4E4h] [bp-810h]@132
  CHAR v194; // [sp+6E4h] [bp-610h]@138
  char DstBuf; // [sp+8E4h] [bp-410h]@119
  CHAR v196; // [sp+AE4h] [bp-210h]@145
  int v197; // [sp+CF0h] [bp-4h]@1

  sub_10043810((int)&v185);
  v2 = a2;
  v3 = 0;
  v4 = 0;
  v197 = 0;
  v113 = 0;
  v109 = 0;
  if ( a2 )
  {
    v3 = *(_DWORD *)(a1 + 204);
    v4 = 1;
    v113 = 1;
    v109 = v3;
  }
  `eh vector constructor iterator'(v188, 0xCu, 12, (int)unknown_libname_3, sub_10038C00);
  LOBYTE(v197) = 1;
  v112 = v4;
  if ( v4 > v3 )
    goto LABEL_88;
  v5 = 0.5;
  v6 = 0.25;
  v7 = 0.125;
  while ( 1 )
  {
    LODWORD(v111) = 48 * v4;
    v8 = &v189[48 * v4];
    v9 = 4;
    do
    {
      v10 = *(_DWORD *)(a1 + 184);
      v11 = *(_DWORD *)v8;
      if ( v10 != *(_DWORD *)v8 )
      {
        if ( v10 >= *(_DWORD *)v8 && v10 > *((_DWORD *)v8 + 1) )
        {
          LOBYTE(v120) = v10 == v11 + 1;
          sub_100943C0(v10, 0, (int)(v8 - 4), v10 == v11 + 1, 0x40u, 0);
          v5 = 0.5;
          v7 = 0.125;
          v6 = 0.25;
        }
        *(_DWORD *)v8 = v10;
      }
      v8 += 12;
      --v9;
    }
    while ( v9 );
    v117 = 0;
    if ( *(_DWORD *)(a1 + 184) > 0u )
      break;
LABEL_86:
    v112 = ++v4;
    if ( v4 > v109 )
    {
      v2 = a2;
LABEL_88:
      v156 &= 0xFCu;
      PerformanceCount.QuadPart = 0i64;
      v154 = 0;
      v155 = 0;
      if ( 0.0 == dbl_100BF5B8 )
      {
        QueryPerformanceFrequency(&Frequency);
        v111 = __PAIR__(Frequency.s.HighPart, 0) & 0x8000000000000000ui64;
        dbl_100BF5B8 = 1.0 / (double)(unsigned __int64)Frequency.QuadPart;
        QueryPerformanceCounter(&::PerformanceCount);
      }
      QueryPerformanceCounter(&PerformanceCount);
      v156 = v156 & 0xFD | 1;
      if ( v2 )
        v75 = *(_DWORD *)(a1 + 12);
      else
        v75 = *(_DWORD *)(a1 + 4);
      sub_100438D0((int)&v185, v75);
      v46 = v2 == 0;
      v76 = (_DWORD *)(a1 + 320);
      if ( v46 )
        v76 = (_DWORD *)(a1 + 308);
      v108 = v76;
      sub_10036C30((int)v76, v187);
      v77 = 0;
      if ( v187 > 0 )
      {
        v110 = 0;
        do
        {
          v78 = v186 + v110;
          v79 = 0;
          do
          {
            *(float *)&v111 = *(float *)(v78 + 4 * v79);
            v80 = *(float *)&v111;
            if ( a2 )
            {
              v81 = (signed int)(v80 * 8.0);
              if ( v81 >= 0 )
              {
                if ( v81 > 7 )
                  v81 = 7;
                v82 = byte_1009F8A4[v81];
              }
              else
              {
                v82 = 0;
              }
            }
            else
            {
              v83 = (signed int)(v80 * 4.0);
              if ( v83 >= 0 )
              {
                if ( v83 > 3 )
                  v83 = 3;
              }
              else
              {
                v83 = 0;
              }
              v82 = byte_1009F8BC[v83];
            }
            v84 = (v79 & 3) + 4 * ((v79 >> 2) + 4 * v77);
            ++v79;
            *(_BYTE *)(v84 + *v76) = v82;
          }
          while ( v79 < 0x10 );
          v110 += 64;
          ++v77;
        }
        while ( v77 < v187 );
      }
      if ( a2 )
        v85 = a1 + 344;
      else
        v85 = a1 + 332;
      v86 = (void (*)(char *, size_t, const char *, ...))sprintf_s;
      v87 = (void (__cdecl *)(const char *, FILE *))fputs;
      if ( *(_DWORD *)v85 )
      {
        v88 = *(int **)v85;
        for ( LODWORD(v111) = *(_DWORD *)v85 + 12 * *(_DWORD *)(v85 + 4); v88 != (int *)v111; v88 += 3 )
        {
          v89 = *v88;
          if ( *v88 )
          {
            if ( v89 & 7 )
            {
              sprintf_s(
                &DstBuf,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_free: bad ptr");
              OutputDebugStringA(&DstBuf);
              v90 = _iob_func();
              fputs(&DstBuf, v90 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v89, 0, 0, 1, dword_100AE9F4);
            }
          }
        }
        v91 = *(int **)v85;
        if ( *(_DWORD *)v85 )
        {
          if ( (unsigned __int8)v91 & 7 )
          {
            sprintf_s(
              &OutputString,
              0x200u,
              "%s(%u): Assertion failed: \"%s\"\n",
              "crn_mem.cpp",
              216,
              "crnlib_free: bad ptr");
            OutputDebugStringA(&OutputString);
            v92 = _iob_func();
            fputs(&OutputString, v92 + 2);
            if ( IsDebuggerPresent() )
              DebugBreak();
          }
          else
          {
            off_100AD9F4(v91, 0, 0, 1, dword_100AE9F4);
          }
        }
        *(_DWORD *)v85 = 0;
        *(_DWORD *)(v85 + 4) = 0;
        *(_DWORD *)(v85 + 8) = 0;
      }
      sub_10033720(v85, v108[1]);
      v160 = v113;
      v158 = a1;
      v159 = a2;
      v164 = v108;
      v161 = v109;
      v162 = &v185;
      v163 = v85;
      v165 = 0;
      v109 = 0;
      while ( 1 )
      {
        v93 = *(_DWORD *)(a1 + 524);
        v113 = 16;
        v94 = off_100AD9F4(0, 16, &v113, 1, dword_100AE9F4);
        v95 = (struct _SINGLE_LIST_ENTRY *)v94;
        if ( v94 && (unsigned int)v113 >= 0x10 )
        {
          *(_DWORD *)v94 = &off_100A4F34;
          *(_DWORD *)(v94 + 4) = a1;
          *(_DWORD *)(v94 + 8) = sub_1005DFC0;
          *(_DWORD *)(v94 + 12) = 1;
          InterlockedIncrement((LPLONG)(v93 + 80));
          v97 = *(_DWORD *)v93;
          if ( *(_BYTE *)(*(_DWORD *)v93 + 16) )
          {
            v98 = InterlockedPopEntrySList((PSLIST_HEADER)(v97 + 8));
            if ( v98 )
              goto LABEL_156;
          }
          v105 = 32;
          v98 = (PSINGLE_LIST_ENTRY)off_100AD9F4(0, 32, &v105, 1, dword_100AE9F4);
          if ( !v98 || (unsigned int)v105 < 0x20 )
          {
            sprintf_s(
              &v194,
              0x200u,
              "%s(%u): Assertion failed: \"%s\"\n",
              "crn_mem.cpp",
              216,
              "crnlib_malloc: out of memory");
            OutputDebugStringA(&v194);
            v99 = _iob_func();
            fputs(&v194, v99 + 2);
            if ( IsDebuggerPresent() )
              DebugBreak();
            v98 = 0;
          }
          if ( v98 )
          {
LABEL_156:
            if ( v98 != (PSINGLE_LIST_ENTRY)-8 )
            {
              v98[2].Next = (struct _SINGLE_LIST_ENTRY *)v109;
              v98[3].Next = 0;
              v98[4].Next = (struct _SINGLE_LIST_ENTRY *)&v158;
              v98[5].Next = v95;
              v98[6].Next = (struct _SINGLE_LIST_ENTRY *)1;
              v98[7].Next = v184;
            }
            InterlockedPushEntrySList((PSLIST_HEADER)v97, v98);
            if ( !ReleaseSemaphore(*(HANDLE *)(v93 + 72), 1, 0) )
            {
              sprintf_s(
                &v196,
                0x200u,
                "%s(%u): Failure: \"%s\"\n",
                "crn_threading_win32.cpp",
                198,
                "\"semaphore: ReleaseSemaphore() failed\"");
              OutputDebugStringA(&v196);
              v100 = _iob_func();
              fputs(&v196, v100 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
              if ( !byte_100AE9F8 )
                exit(1);
              RaiseException(0x100u, 0, 0, 0);
            }
          }
          else
          {
            InterlockedIncrement((LPLONG)(v93 + 84));
          }
        }
        else
        {
          v86(&v193, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_malloc: out of memory");
          OutputDebugStringA(&v193);
          v96 = _iob_func();
          v87(&v193, v96 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        v101 = *(_DWORD *)(a1 + 524);
        if ( ++v109 > *(_DWORD *)(v101 + 4) )
          break;
        v87 = (void (__cdecl *)(const char *, FILE *))fputs;
        v86 = (void (*)(char *, size_t, const char *, ...))sprintf_s;
      }
      sub_10091500(v101);
      v102 = *(_BYTE *)(a1 + 520) == 0;
      LOBYTE(v197) = 0;
      `eh vector destructor iterator'(v188, 0xCu, 12, sub_10038C00);
      v197 = -1;
      sub_10041960((int)&v185);
      return v102;
    }
  }
  v110 = 0;
  v108 = 0;
  v118 = 0;
  v119 = 0;
  while ( 1 )
  {
    if ( v117 & 0x3F )
      goto LABEL_25;
    v12 = *(int (__cdecl **)(unsigned int, signed int, int, unsigned int, _DWORD))(a1 + 176);
    v13 = *(_DWORD *)(a1 + 184);
    if ( !v12 )
      goto LABEL_25;
    v14 = v13 <= 1 ? 100 : v119 / (v13 - 1);
    if ( v4 + 9 != *(_DWORD *)(a1 + 528) || *(_DWORD *)(a1 + 532) != v14 )
      break;
    if ( *(_BYTE *)(a1 + 520) )
      goto LABEL_22;
LABEL_25:
    v16 = v118 + *(_DWORD *)(a1 + 12 * v4 + 212);
    v17 = (char *)*(_BYTE *)(v16 + 1);
    if ( *(_BYTE *)(v16 + 1) )
    {
      v105 = *(_BYTE *)v16;
      v107 = (char *)(v16 + 328);
      v114 = v17;
      *(float *)&v105 = (double)v105 / 7.0;
      *(float *)&v105 = 1.149999976158142 - *(float *)&v105 * 0.1499999761581421;
      v18 = *(float *)&v105;
      do
      {
        if ( v4 )
        {
          v28 = (unsigned int)((*(_DWORD *)v107 - *((_DWORD *)v107 + 1)) * (*(_DWORD *)v107 - *((_DWORD *)v107 + 1))) >> 3;
        }
        else
        {
          v19 = 8 * (*(_WORD *)v107 & 0x1F) | ((*(_WORD *)v107 & 0x1Fu) >> 2);
          LODWORD(v103) = 4 * (((unsigned int)*(_WORD *)v107 >> 5) & 0x3F) | ((((unsigned int)*(_WORD *)v107 >> 5) & 0x3F) >> 4);
          v20 = *((_WORD *)v107 + 2);
          v106 = (char *)(8 * ((unsigned int)*(_WORD *)v107 >> 11) | ((unsigned int)*(_WORD *)v107 >> 13));
          v21 = v20;
          v22 = v20 >> 11;
          v23 = 8 * (v20 & 0x1F) | ((v20 & 0x1F) >> 2);
          v24 = 4 * ((v21 >> 5) & 0x3F) | (((v21 >> 5) & 0x3F) >> 4);
          v25 = 8 * v22 | (v22 >> 2);
          if ( *(_BYTE *)(a1 + 173) )
            v26 = ((unsigned __int8)v19 - (unsigned __int8)v23) * ((unsigned __int8)v19 - (unsigned __int8)v23)
                + 25 * (LOBYTE(v103) - (unsigned __int8)v24) * (LOBYTE(v103) - (unsigned __int8)v24)
                + 8 * ((unsigned __int8)v106 - (unsigned __int8)v25) * ((unsigned __int8)v106 - (unsigned __int8)v25);
          else
            v26 = ((unsigned __int8)v106 - (unsigned __int8)v25) * ((unsigned __int8)v106 - (unsigned __int8)v25)
                + (LOBYTE(v103) - (unsigned __int8)v24) * (LOBYTE(v103) - (unsigned __int8)v24)
                + ((unsigned __int8)v19 - (unsigned __int8)v23) * ((unsigned __int8)v19 - (unsigned __int8)v23);
          v27 = *(float *)((char *)v108 + *(_DWORD *)(a1 + 188) + 256);
          v105 = LOWORD(v103) | 0xC00;
          v28 = (signed __int64)(v27 * (double)(v26 / 0x7D0));
        }
        if ( v28 >= 1 )
        {
          if ( v28 > 0x800 )
            v28 = 2048;
        }
        else
        {
          v28 = 1;
        }
        v29 = 0;
        v30 = (double)v28 * v18;
        v105 = LOWORD(v103) | 0xC00;
        v31 = (char *)&unk_100AD2F0 + 20 * (unsigned __int8)v107[74];
        v32 = (unsigned int)dword_100AD2FC[5 * (unsigned __int8)v107[74]] >> 2;
        v104 = (char *)&unk_100AD2F0 + 20 * (unsigned __int8)v107[74];
        if ( v32 )
        {
          v33 = (char *)(*((_DWORD *)v31 + 2) >> 2);
          v106 = (char *)(*((_DWORD *)v31 + 2) >> 2);
          do
          {
            if ( v33 )
            {
              v34 = v106;
              v35 = &v183[4 * (v29 + (*((_DWORD *)v31 + 1) >> 2) + 2 * (*(_DWORD *)v31 >> 2))];
              do
              {
                *(_DWORD *)v35 = (signed __int64)v30;
                v35 += 8;
                --v34;
              }
              while ( v34 );
              v33 = v106;
            }
            ++v29;
          }
          while ( v29 < v32 );
        }
        if ( *((_DWORD *)v31 + 3) )
        {
          v36 = *((unsigned int *)v31 + 1);
          v37 = (char *)*((_DWORD *)v31 + 2);
          v38 = *((_DWORD *)v31 + 3);
          v39 = v107 + 8;
          v103 = *((float *)v31 + 1);
          v105 = *((int *)v31 + 2);
          v115 = v107 + 8;
          v116 = v38;
          do
          {
            if ( v37 )
            {
              v40 = *(_DWORD *)v31;
              v41 = v36 >> 2;
              v42 = v36 & 3;
              v106 = v37;
              do
              {
                v43 = *v39;
                v44 = v42 + 4 * (v41 + 2 * (v40 >> 2));
                v45 = &v190 + (v40 & 3);
                ++v39;
                ++v40;
                v46 = v106-- == (char *)1;
                v45[4 * v44] = v43;
              }
              while ( !v46 );
              *(float *)&v36 = v103;
              v37 = (char *)v105;
              v4 = v112;
              v31 = v104;
            }
            ++v36;
            v39 = &v115[(_DWORD)v37];
            v46 = v116-- == 1;
            v103 = *(float *)&v36;
            v115 = &v115[(_DWORD)v37];
          }
          while ( !v46 );
        }
        v107 += 80;
        --v114;
      }
      while ( v114 );
    }
    v47 = &v191;
    v115 = &v191;
    v106 = v183;
    v48 = &v188[v111];
    v105 = 2;
    do
    {
      v114 = v48;
      v107 = v106;
      v116 = 2;
      do
      {
        v49 = 0;
        do
        {
          v50 = (unsigned __int8)v47[v49 - 1];
          if ( v4 )
            v51 = ((double)(unsigned __int8)byte_1009F8AC[v50] + v5) * v7;
          else
            v51 = ((double)(unsigned __int8)byte_1009F8C0[v50] + v5) * v6;
          v52 = (unsigned __int8)v47[v49];
          v53 = v51;
          *((float *)&v137 + v49) = v53;
          if ( v4 )
            v54 = ((double)(unsigned __int8)byte_1009F8AC[v52] + v5) * v7;
          else
            v54 = ((double)(unsigned __int8)byte_1009F8C0[v52] + v5) * v6;
          v55 = (unsigned __int8)v47[v49 + 1];
          v56 = v54;
          *((float *)&v138 + v49) = v56;
          if ( v4 )
            v57 = ((double)(unsigned __int8)byte_1009F8AC[v55] + v5) * v7;
          else
            v57 = ((double)(unsigned __int8)byte_1009F8C0[v55] + v5) * v6;
          v58 = (unsigned __int8)v47[v49 + 2];
          v59 = v57;
          *((float *)&v139 + v49) = v59;
          if ( v4 )
            v60 = ((double)(unsigned __int8)byte_1009F8AC[v58] + v5) * v7;
          else
            v60 = ((double)(unsigned __int8)byte_1009F8C0[v58] + v5) * v6;
          v61 = (unsigned __int8)v47[v49 + 3];
          v62 = v60;
          *((float *)&v140 + v49) = v62;
          if ( v4 )
            v63 = ((double)(unsigned __int8)byte_1009F8AC[v61] + v5) * v7;
          else
            v63 = ((double)(unsigned __int8)byte_1009F8C0[v61] + v5) * v6;
          v64 = (unsigned __int8)v47[v49 + 4];
          v65 = v63;
          *((float *)&v141 + v49) = v65;
          if ( v4 )
            v66 = ((double)(unsigned __int8)byte_1009F8AC[v64] + v5) * v7;
          else
            v66 = ((double)(unsigned __int8)byte_1009F8C0[v64] + v5) * v6;
          v67 = (unsigned __int8)v47[v49 + 5];
          v68 = v66;
          *((float *)&v142 + v49) = v68;
          if ( v4 )
            v69 = ((double)(unsigned __int8)byte_1009F8AC[v67] + v5) * v7;
          else
            v69 = ((double)(unsigned __int8)byte_1009F8C0[v67] + v5) * v6;
          v70 = (unsigned __int8)v47[v49 + 6];
          v71 = v69;
          *((float *)&v143 + v49) = v71;
          if ( v4 )
            v72 = ((double)(unsigned __int8)byte_1009F8AC[v70] + v5) * v7;
          else
            v72 = ((double)(unsigned __int8)byte_1009F8C0[v70] + v5) * v6;
          v103 = v72;
          v49 += 8;
          *(&v136 + v49) = v103;
        }
        while ( v49 < 0x10 );
        v73 = *(_DWORD *)v107;
        v125 = v141;
        v126 = v142;
        v127 = v143;
        v128 = v144;
        v129 = v145;
        v130 = v146;
        v131 = v147;
        v121 = v137;
        v166 = v137;
        v122 = v138;
        v132 = v148;
        v167 = v138;
        v170 = v141;
        v123 = v139;
        v133 = v149;
        v168 = v139;
        v171 = v142;
        v173 = v144;
        v134 = v150;
        v172 = v143;
        v174 = v145;
        v176 = v147;
        v135 = v151;
        v175 = v146;
        v177 = v148;
        v169 = v140;
        v179 = v150;
        v124 = v140;
        v136 = v152;
        v178 = v149;
        v180 = v151;
        v181 = v152;
        v182 = 0;
        v74 = sub_1004E450((int)&v185, (int)&v166);
        sub_1004D580((int)&v157, (int)&v185, (int)v74);
        if ( v73 <= -1 - v73 )
          *(_DWORD *)(v157 + 76) += v73;
        else
          *(_DWORD *)(v157 + 76) = -1;
        sub_10038C30(v110 + *(_DWORD *)v114, (int)&v137);
        v107 += 8;
        v4 = v112;
        v48 = v114 + 12;
        v47 += 32;
        v5 = 0.5;
        v46 = v116-- == 1;
        v7 = 0.125;
        v6 = 0.25;
        v114 += 12;
      }
      while ( !v46 );
      v106 += 4;
      v47 = v115 + 16;
      v46 = v105-- == 1;
      v115 += 16;
    }
    while ( !v46 );
    v119 += 100;
    v118 += 660;
    v108 += 65;
    v110 += 64;
    if ( (unsigned int)++v117 >= *(_DWORD *)(a1 + 184) )
      goto LABEL_86;
  }
  *(_DWORD *)(a1 + 532) = v14;
  if ( v12(v4 + 9, 25, v117, v13, *(_DWORD *)(a1 + 180)) != 0 )
  {
    v5 = 0.5;
    v7 = 0.125;
    v6 = 0.25;
    goto LABEL_25;
  }
  *(_BYTE *)(a1 + 520) = 1;
LABEL_22:
  LOBYTE(v197) = 0;
  `eh vector destructor iterator'(v188, 0xCu, 12, sub_10038C00);
  v197 = -1;
  sub_10041960((int)&v185);
  return 0;
}
// 1003F6D0: using guessed type int unknown_libname_3();
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);
// 100AD2FC: using guessed type int dword_100AD2FC[];
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100AE9F8: using guessed type char byte_100AE9F8;
// 100BF5B8: using guessed type double dbl_100BF5B8;
// 100616D0: using guessed type char var_AE0[4];
// 100616D0: using guessed type char var_ADC[140];
// 100616D0: using guessed type char var_B88[20];

//----- (10062740) --------------------------------------------------------
bool __usercall sub_10062740@<al>(int a1@<esi>)
{
  bool result; // al@2
  unsigned int v2; // ebx@3
  int v3; // edi@4
  int v4; // eax@4
  int v5; // [sp+8h] [bp-4h]@4

  if ( *(_DWORD *)(a1 + 204) )
  {
    v2 = 0;
    do
    {
      v3 = *(_DWORD *)(a1 + 524);
      v5 = 16;
      v4 = off_100AD9F4(0, 16, &v5, 1, dword_100AE9F4);
      if ( v4 && (unsigned int)v5 >= 0x10 )
      {
        *(_DWORD *)v4 = &off_100A4F34;
        *(_DWORD *)(v4 + 4) = a1;
        *(_DWORD *)(v4 + 8) = sub_10060F80;
        *(_DWORD *)(v4 + 12) = 1;
        sub_100916A0(v4, v3, v2, 0, 0);
      }
      else
      {
        sub_100927E0((int)"crnlib_malloc: out of memory");
      }
      ++v2;
    }
    while ( v2 <= *(_DWORD *)(*(_DWORD *)(a1 + 524) + 4) );
    sub_10091500(*(_DWORD *)(a1 + 524));
    result = *(_BYTE *)(a1 + 520) == 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100627E0) --------------------------------------------------------
char __userpurge sub_100627E0@<al>(int a1@<eax>, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // ebx@1
  unsigned int v4; // esi@3
  unsigned int v5; // edx@3
  int v6; // eax@6
  int (__cdecl *v7)(signed int, signed int, int, unsigned int, int); // esi@6
  unsigned int v8; // ecx@6
  int v9; // edi@6
  signed int v10; // eax@8
  int v11; // ebp@13
  int v12; // esi@13
  unsigned int v13; // edi@13
  unsigned int v14; // eax@13
  bool v15; // zf@18
  char *v16; // ebp@20
  unsigned int v17; // eax@21
  unsigned int v18; // eax@24
  _DWORD *v19; // eax@24
  unsigned int v20; // edi@26
  unsigned int v21; // ebp@26
  float *v22; // eax@27
  int v23; // edx@27
  unsigned int v24; // esi@27
  double v25; // st7@31
  int v26; // ecx@33
  int v27; // ST14_4@38
  _DWORD *v29; // eax@42
  int v30; // esi@45
  int v31; // eax@45
  float v32; // ecx@46
  unsigned int v33; // ecx@47
  unsigned int v34; // eax@50
  unsigned int v35; // ecx@52
  _DWORD *v36; // esi@52
  unsigned int v37; // edi@52
  int v38; // edi@60
  int v39; // eax@60
  struct _SINGLE_LIST_ENTRY *v40; // esi@60
  FILE *v41; // eax@62
  int v42; // ebx@64
  PSINGLE_LIST_ENTRY v43; // eax@65
  FILE *v44; // eax@68
  int v45; // ecx@76
  int v46; // ecx@84
  int v47; // ebx@84
  float v48; // edi@85
  int v49; // esi@87
  unsigned int v50; // eax@87
  int v51; // edi@87
  int v52; // eax@89
  int v53; // [sp+0h] [bp-5C4h]@4
  struct _SINGLE_LIST_ENTRY *v54; // [sp+0h] [bp-5C4h]@59
  _WORD *v55; // [sp+0h] [bp-5C4h]@85
  unsigned int v56; // [sp+4h] [bp-5C0h]@2
  _DWORD *v57; // [sp+4h] [bp-5C0h]@81
  int v58; // [sp+8h] [bp-5BCh]@4
  unsigned int v59; // [sp+8h] [bp-5BCh]@82
  unsigned int v60; // [sp+Ch] [bp-5B8h]@22
  unsigned int v61; // [sp+Ch] [bp-5B8h]@80
  unsigned int v62; // [sp+10h] [bp-5B4h]@20
  int v63; // [sp+10h] [bp-5B4h]@83
  float v64; // [sp+14h] [bp-5B0h]@26
  float v65; // [sp+18h] [bp-5ACh]@26
  int v66; // [sp+1Ch] [bp-5A8h]@13
  float v67; // [sp+20h] [bp-5A4h]@41
  int v68; // [sp+24h] [bp-5A0h]@3
  int v69; // [sp+28h] [bp-59Ch]@4
  int v70; // [sp+2Ch] [bp-598h]@19
  int v71; // [sp+30h] [bp-594h]@16
  float v72; // [sp+34h] [bp-590h]@42
  float v73; // [sp+38h] [bp-58Ch]@42
  unsigned int v74; // [sp+3Ch] [bp-588h]@3
  int v75; // [sp+40h] [bp-584h]@18
  int v76; // [sp+44h] [bp-580h]@42
  float v77; // [sp+4Ch] [bp-578h]@24
  int v78; // [sp+50h] [bp-574h]@23
  int v79; // [sp+54h] [bp-570h]@24
  int v80; // [sp+58h] [bp-56Ch]@24
  float v81; // [sp+60h] [bp-564h]@42
  float v82; // [sp+64h] [bp-560h]@42
  int v83; // [sp+68h] [bp-55Ch]@42
  struct _SINGLE_LIST_ENTRY *v84; // [sp+74h] [bp-550h]@73
  char v85; // [sp+78h] [bp-54Ch]@2
  unsigned int v86; // [sp+98h] [bp-52Ch]@52
  int v87[6]; // [sp+108h] [bp-4BCh]@2
  char v88; // [sp+120h] [bp-4A4h]@20
  int v89; // [sp+13Ch] [bp-488h]@27
  unsigned int v90; // [sp+140h] [bp-484h]@26
  char DstBuf; // [sp+1B0h] [bp-414h]@62
  CHAR OutputString; // [sp+3B0h] [bp-214h]@68
  int v93; // [sp+5B8h] [bp-Ch]@1
  int (__thiscall *v94)(void *); // [sp+5BCh] [bp-8h]@1
  int v95; // [sp+5C0h] [bp-4h]@1

  v95 = -1;
  v94 = sub_10096D11;
  v93 = a1;
  v2 = a2;
  v3 = 0;
  if ( !*(_DWORD *)(a2 + 204) )
    return 1;
  sub_10041C10((int)&v85);
  v95 = 0;
  `eh vector constructor iterator'(v87, 0xCu, 2, (int)unknown_libname_3, sub_100371F0);
  v95 = 1;
  v56 = 0;
  if ( *(_DWORD *)(a2 + 204) <= 0u )
  {
LABEL_50:
    v34 = *(_DWORD *)(v2 + 8);
    if ( *(_DWORD *)(v2 + 280) < v34 )
      v34 = *(_DWORD *)(v2 + 280);
    sub_10041CA0((int)&v85, v34);
    v35 = *(_DWORD *)(v2 + 300);
    v36 = (_DWORD *)(v2 + 296);
    v37 = v86;
    if ( v86 != v35 )
    {
      if ( v86 >= v35 )
      {
        if ( v86 > *(_DWORD *)(v2 + 304) )
        {
          LOBYTE(v67) = v86 == v35 + 1;
          sub_100943C0(v86, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004A140, v2 + 296, v86 == v35 + 1, 0x28u, 0);
        }
        sub_1004CE10(*v36 + 40 * *(_DWORD *)(v2 + 300), v37 - *(_DWORD *)(v2 + 300));
      }
      else
      {
        sub_1004CE50(v35 - v86, (int *)(*v36 + 40 * v86));
      }
      *(_DWORD *)(v2 + 300) = v37;
    }
    v54 = 0;
    do
    {
      v38 = *(_DWORD *)(v2 + 524);
      v68 = 16;
      v39 = off_100AD9F4(0, 16, &v68, 1, dword_100AE9F4);
      v40 = (struct _SINGLE_LIST_ENTRY *)v39;
      if ( v39 && (unsigned int)v68 >= 0x10 )
      {
        *(_DWORD *)v39 = &off_100A4F34;
        *(_DWORD *)(v39 + 4) = v2;
        *(_DWORD *)(v39 + 8) = sub_1005D550;
        *(_DWORD *)(v39 + 12) = 1;
        InterlockedIncrement((LPLONG)(v38 + 80));
        v42 = *(_DWORD *)v38;
        if ( *(_BYTE *)(*(_DWORD *)v38 + 16) )
        {
          v43 = InterlockedPopEntrySList((PSLIST_HEADER)(v42 + 8));
          if ( v43 )
            goto LABEL_98;
        }
        v66 = 32;
        v43 = (PSINGLE_LIST_ENTRY)off_100AD9F4(0, 32, &v66, 1, dword_100AE9F4);
        if ( !v43 || (unsigned int)v66 < 0x20 )
        {
          sprintf_s(
            &OutputString,
            0x200u,
            "%s(%u): Assertion failed: \"%s\"\n",
            "crn_mem.cpp",
            216,
            "crnlib_malloc: out of memory");
          OutputDebugStringA(&OutputString);
          v44 = _iob_func();
          fputs(&OutputString, v44 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
          v43 = 0;
        }
        if ( v43 )
        {
LABEL_98:
          if ( v43 != (PSINGLE_LIST_ENTRY)-8 )
          {
            v43[2].Next = v54;
            v43[3].Next = 0;
            v43[4].Next = (struct _SINGLE_LIST_ENTRY *)&v85;
            v43[5].Next = v40;
            v43[6].Next = (struct _SINGLE_LIST_ENTRY *)1;
            v43[7].Next = v84;
          }
          InterlockedPushEntrySList((PSLIST_HEADER)v42, v43);
          if ( !ReleaseSemaphore(*(HANDLE *)(v38 + 72), 1, 0) )
            sub_10091080();
        }
        else
        {
          InterlockedIncrement((LPLONG)(v38 + 84));
        }
      }
      else
      {
        sprintf_s(
          &DstBuf,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_malloc: out of memory");
        OutputDebugStringA(&DstBuf);
        v41 = _iob_func();
        fputs(&DstBuf, v41 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      v45 = *(_DWORD *)(v2 + 524);
      v54 = (struct _SINGLE_LIST_ENTRY *)((char *)v54 + 1);
    }
    while ( (unsigned int)v54 <= *(_DWORD *)(v45 + 4) );
    sub_10091500(v45);
    if ( *(_BYTE *)(v2 + 520) )
    {
      v95 = 4;
      `eh vector destructor iterator'(v87, 0xCu, 2, sub_100371F0);
      v95 = -1;
      sub_100417D0((int)&v85);
      return 0;
    }
    v61 = 0;
    if ( *(_DWORD *)(v2 + 204) )
    {
      v57 = (_DWORD *)(v2 + 224);
      do
      {
        v59 = 0;
        if ( *(_DWORD *)(v2 + 184) )
        {
          v63 = 0;
          do
          {
            v46 = v63 + *v57;
            v47 = 0;
            v71 = v46;
            if ( *(_BYTE *)(v46 + 1) )
            {
              LODWORD(v48) = v61 << 16;
              LODWORD(v67) = v61 << 16;
              v55 = (_WORD *)(v46 + 644);
              while ( 1 )
              {
                v49 = *(_DWORD *)(v2 + 296) + 40 * *v55;
                v50 = *(_DWORD *)(v49 + 4);
                v51 = v47 | LODWORD(v48);
                if ( v50 >= *(_DWORD *)(v49 + 8) )
                {
                  sub_100943C0(v50 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004A100, v49, 1, 8u, 0);
                  v46 = v71;
                }
                v52 = *(_DWORD *)v49 + 8 * *(_DWORD *)(v49 + 4);
                if ( v52 )
                {
                  *(_DWORD *)v52 = v59;
                  *(_DWORD *)(v52 + 4) = v51;
                }
                ++*(_DWORD *)(v49 + 4);
                ++v55;
                if ( ++v47 >= (unsigned int)*(_BYTE *)(v46 + 1) )
                  break;
                v48 = v67;
              }
            }
            v63 += 660;
            ++v59;
          }
          while ( v59 < *(_DWORD *)(v2 + 184) );
        }
        v57 += 3;
        ++v61;
      }
      while ( v61 < *(_DWORD *)(v2 + 204) );
    }
    v95 = 5;
    `eh vector destructor iterator'(v87, 0xCu, 2, sub_100371F0);
    v95 = -1;
    sub_100417D0((int)&v85);
    return 1;
  }
  while ( 1 )
  {
    v4 = *(_DWORD *)(v2 + 184);
    v74 = 12 * v3;
    sub_10033720((int)&v87[3 * v3], v4);
    v5 = 0;
    v68 = 0;
    if ( *(_DWORD *)(v2 + 184) )
      break;
LABEL_49:
    v56 = ++v3;
    if ( v3 >= *(_DWORD *)(v2 + 204) )
      goto LABEL_50;
  }
  v53 = 0;
  v69 = 0;
  v58 = 0;
  while ( 1 )
  {
    if ( v5 & 0x3F )
      goto LABEL_13;
    v6 = *(_DWORD *)(v2 + 184);
    v7 = *(int (__cdecl **)(signed int, signed int, int, unsigned int, int))(v2 + 176);
    v8 = v6 * *(_DWORD *)(v2 + 204);
    v9 = v5 + v3 * v6;
    if ( !v7 )
      goto LABEL_13;
    v10 = v8 <= 1 ? 100 : 100 * v9 / (v8 - 1);
    if ( *(_DWORD *)(v2 + 528) != 6 || *(_DWORD *)(v2 + 532) != v10 )
      break;
    if ( *(_BYTE *)(v2 + 520) )
      goto LABEL_40;
LABEL_13:
    v11 = v58 + *(_DWORD *)(v74 + v2 + 224);
    v12 = v69 + v87[v74 / 4];
    v13 = *(_BYTE *)(v11 + 1);
    v14 = *(_DWORD *)(v12 + 4);
    v66 = v11;
    if ( v13 != v14 )
    {
      if ( v13 >= v14 && v13 > *(_DWORD *)(v12 + 8) )
      {
        LOBYTE(v71) = v13 == v14 + 1;
        sub_100943C0(v13, 0, v12, v13 == v14 + 1, 8u, 0);
      }
      *(_DWORD *)(v12 + 4) = v13;
    }
    v15 = *(_BYTE *)(v11 + 1) == 0;
    v75 = 0;
    if ( !v15 )
    {
      v70 = v66 + 80;
      do
      {
        v16 = (char *)&unk_100AD2F0 + 20 * *(_BYTE *)(v70 + 2);
        sub_10043260((int)&v88);
        LOBYTE(v95) = 3;
        v62 = 0;
        if ( *((_DWORD *)v16 + 3) )
        {
          v17 = *((_DWORD *)v16 + 2);
          do
          {
            v60 = 0;
            if ( v17 > 0 )
            {
              v78 = 0;
              do
              {
                v18 = *(_BYTE *)(*(_DWORD *)(a2 + 4 * v56 + 28)
                               + 4
                               * (v53
                                + ((v60 + *(_DWORD *)v16) & 3)
                                + 4
                                * (((v62 + *((_DWORD *)v16 + 1)) & 3)
                                 + 4 * (((v60 + *(_DWORD *)v16) >> 2) + 2 * ((v62 + *((_DWORD *)v16 + 1)) >> 2))))
                               + *(_DWORD *)(a2 + 188));
                v79 = *(_BYTE *)(*(_DWORD *)(a2 + 4 * v56 + 28)
                               + 4
                               * (v53
                                + ((v60 + *(_DWORD *)v16) & 3)
                                + 4
                                * (((v62 + *((_DWORD *)v16 + 1)) & 3)
                                 + 4 * (((v60 + *(_DWORD *)v16) >> 2) + 2 * ((v62 + *((_DWORD *)v16 + 1)) >> 2))))
                               + *(_DWORD *)(a2 + 188));
                v77 = (double)v18 / 255.0;
                v19 = sub_1004E3E0((int)&v77, (int)&v88);
                sub_1004D460((int)&v80, (int)&v88, (int)v19);
                ++*(_DWORD *)(v80 + 16);
                v17 = *((_DWORD *)v16 + 2);
                ++v60;
              }
              while ( v60 < v17 );
            }
            ++v62;
          }
          while ( v62 < *((_DWORD *)v16 + 3) );
        }
        sub_10043320((int)&v88);
        v20 = v90;
        v21 = *(_BYTE *)v70 * *(_BYTE *)(v70 + 1);
        v64 = 0.0;
        v65 = 0.0;
        if ( v90 > 0 )
        {
          v22 = &v64;
          v23 = v89 - (_DWORD)&v64;
          v24 = v90;
          do
          {
            if ( v22 != (float *)((char *)v22 + v23) )
              *v22 = *(float *)((char *)v22 + v23);
            ++v22;
            --v24;
          }
          while ( v24 );
        }
        v25 = v64;
        if ( v20 == 1 )
          v65 = v64;
        v26 = 0;
        while ( *(&v64 + v26) <= (double)*(&v65 + v26) )
        {
          if ( *(&v64 + v26) == *(&v65 + v26) && (unsigned int)++v26 < 1 )
            continue;
          goto LABEL_42;
        }
        v67 = v64;
        v64 = v65;
        v65 = v67;
        v25 = v64;
LABEL_42:
        v72 = v25;
        v73 = v65;
        v81 = v72;
        v82 = v65;
        v83 = 0;
        v29 = sub_1004E290((int)&v81, (int)&v85);
        sub_1004D100((int)&v76, (int)&v85, (int)v29);
        if ( v21 <= -1 - v21 )
          *(_DWORD *)(v76 + 20) += v21;
        else
          *(_DWORD *)(v76 + 20) = -1;
        v30 = v75;
        v31 = *(_DWORD *)(v69 + v87[v74 / 4]) + 8 * v75;
        if ( (float *)v31 != &v72 )
        {
          v32 = v73;
          *(float *)v31 = v72;
          *(float *)(v31 + 4) = v32;
        }
        LOBYTE(v95) = 1;
        sub_10041700((int)&v88);
        v33 = *(_BYTE *)(v66 + 1);
        v70 += 80;
        v75 = v30 + 1;
      }
      while ( v30 + 1 < v33 );
    }
    v58 += 660;
    v69 += 12;
    v53 += 65;
    v3 = v56;
    v5 = v68 + 1;
    v68 = v5;
    v2 = a2;
    if ( v5 >= *(_DWORD *)(a2 + 184) )
      goto LABEL_49;
  }
  v27 = *(_DWORD *)(v2 + 180);
  *(_DWORD *)(v2 + 532) = v10;
  if ( v7(6, 25, v9, v8, v27) != 0 )
    goto LABEL_13;
  *(_BYTE *)(v2 + 520) = 1;
LABEL_40:
  v95 = 2;
  `eh vector destructor iterator'(v87, 0xCu, 2, sub_100371F0);
  v95 = -1;
  sub_100417D0((int)&v85);
  return 0;
}
// 1003F6D0: using guessed type int unknown_libname_3();
// 1004A100: using guessed type int sub_1004A100();
// 1004A140: using guessed type int sub_1004A140();
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100627E0: using guessed type int var_4BC[6];

//----- (100630D0) --------------------------------------------------------
char __stdcall sub_100630D0(int a1)
{
  int v1; // esi@2
  unsigned int v2; // edi@2
  union _SLIST_HEADER *v3; // ebx@2
  int v4; // ebx@7
  char *v5; // ecx@7
  unsigned int v6; // edi@7
  unsigned int v7; // eax@7
  bool v8; // zf@12
  int v9; // eax@14
  char *v10; // edi@14
  unsigned int v11; // eax@15
  unsigned int v12; // edx@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v15; // eax@17
  unsigned __int8 v16; // dl@17
  signed int v17; // eax@17
  double v18; // st7@18
  _DWORD *v19; // eax@20
  unsigned int v20; // ecx@20
  int v21; // edx@20
  int v22; // edi@22
  int *v23; // eax@23
  int v24; // edx@23
  int v25; // ecx@24
  int v26; // ebx@25
  int v27; // ecx@25
  float v28; // eax@31
  float v29; // ecx@31
  float v30; // edx@31
  int v31; // eax@32
  float v32; // edx@33
  float v33; // ecx@33
  float v34; // edx@33
  float v35; // ecx@33
  float v36; // edx@33
  unsigned int v37; // edx@34
  unsigned int v38; // eax@36
  unsigned int v39; // ecx@38
  _DWORD *v40; // edi@38
  unsigned int v41; // ebx@38
  int v43; // ebx@52
  int v44; // eax@52
  struct _SINGLE_LIST_ENTRY *v45; // edi@52
  FILE *v46; // eax@54
  int v47; // eax@56
  PSINGLE_LIST_ENTRY v48; // eax@57
  FILE *v49; // eax@60
  int v50; // edx@68
  int v51; // ecx@72
  unsigned int v52; // ebx@72
  int v53; // edi@74
  unsigned int v54; // eax@74
  int v55; // eax@76
  unsigned int v56; // eax@78
  void *v57; // eax@80
  char *v58; // edi@81
  char *v59; // esi@81
  int v60; // eax@82
  FILE *v61; // eax@84
  FILE *v62; // eax@92
  int v63; // [sp+Ch] [bp-9E4h]@14
  __int64 v64; // [sp+10h] [bp-9E0h]@18
  _WORD *v65; // [sp+18h] [bp-9D8h]@3
  unsigned int v66; // [sp+1Ch] [bp-9D4h]@16
  unsigned int v67; // [sp+20h] [bp-9D0h]@3
  int v68; // [sp+24h] [bp-9CCh]@3
  char *v69; // [sp+28h] [bp-9C8h]@7
  PSLIST_HEADER ListHead; // [sp+2Ch] [bp-9C4h]@2
  float v71; // [sp+30h] [bp-9C0h]@22
  float v72; // [sp+34h] [bp-9BCh]@22
  float v73; // [sp+38h] [bp-9B8h]@22
  float v74; // [sp+3Ch] [bp-9B4h]@22
  float v75; // [sp+40h] [bp-9B0h]@22
  float v76; // [sp+44h] [bp-9ACh]@22
  void *v77; // [sp+48h] [bp-9A8h]@2
  int v78; // [sp+4Ch] [bp-9A4h]@2
  int v79; // [sp+50h] [bp-9A0h]@2
  int v80; // [sp+54h] [bp-99Ch]@13
  int v81; // [sp+58h] [bp-998h]@3
  int v82; // [sp+5Ch] [bp-994h]@18
  int v83; // [sp+60h] [bp-990h]@18
  int v84; // [sp+64h] [bp-98Ch]@18
  double v85; // [sp+68h] [bp-988h]@14
  int v86; // [sp+74h] [bp-97Ch]@7
  unsigned int v87; // [sp+78h] [bp-978h]@12
  int v88; // [sp+7Ch] [bp-974h]@58
  float v89; // [sp+80h] [bp-970h]@32
  float v90; // [sp+84h] [bp-96Ch]@32
  float v91; // [sp+88h] [bp-968h]@32
  float v92; // [sp+8Ch] [bp-964h]@32
  float v93; // [sp+90h] [bp-960h]@32
  struct _SINGLE_LIST_ENTRY *v94; // [sp+94h] [bp-95Ch]@32
  int v95; // [sp+9Ch] [bp-954h]@10
  char *v96; // [sp+A0h] [bp-950h]@51
  void **v97; // [sp+A4h] [bp-94Ch]@51
  int v98; // [sp+A8h] [bp-948h]@20
  int v99; // [sp+ACh] [bp-944h]@20
  int v100; // [sp+B0h] [bp-940h]@20
  int v101; // [sp+B4h] [bp-93Ch]@20
  int v102; // [sp+B8h] [bp-938h]@20
  char v103; // [sp+C0h] [bp-930h]@2
  unsigned int v104; // [sp+E0h] [bp-910h]@38
  char v105; // [sp+150h] [bp-8A0h]@14
  int v106; // [sp+16Ch] [bp-884h]@23
  int v107; // [sp+170h] [bp-880h]@22
  CHAR OutputString; // [sp+1E0h] [bp-810h]@60
  CHAR v109; // [sp+3E0h] [bp-610h]@84
  char DstBuf; // [sp+5E0h] [bp-410h]@54
  CHAR v111; // [sp+7E0h] [bp-210h]@92
  int v112; // [sp+9ECh] [bp-4h]@2

  if ( !*(_BYTE *)(a1 + 208) )
    return 1;
  sub_10042350((int)&v103);
  v112 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  LOBYTE(v112) = 1;
  sub_10033720((int)&v77, *(_DWORD *)(a1 + 184));
  v1 = a1;
  v2 = *(_DWORD *)(a1 + 184);
  v3 = 0;
  ListHead = 0;
  if ( v2 )
  {
    v65 = 0;
    v81 = 0;
    v67 = 0;
    v68 = 0;
    do
    {
      if ( !(_BYTE)v3 )
      {
        if ( !sub_1005D4D0((int)v3, v2, v1, 1) )
          goto LABEL_41;
        v1 = a1;
      }
      v4 = v68 + *(_DWORD *)(v1 + 212);
      v5 = (char *)v77 + v81;
      v6 = *(_BYTE *)(v4 + 1);
      v7 = *(_DWORD *)((char *)v77 + v81 + 4);
      v86 = v68 + *(_DWORD *)(v1 + 212);
      v69 = (char *)v77 + v81;
      if ( v6 != v7 )
      {
        if ( v6 >= v7 && v6 > *((_DWORD *)v5 + 2) )
        {
          LOBYTE(v95) = v6 == v7 + 1;
          sub_100943C0(v6, 0, (int)v77 + v81, v6 == v7 + 1, 0x18u, 0);
          v5 = v69;
        }
        *((_DWORD *)v5 + 1) = v6;
      }
      v8 = *(_BYTE *)(v4 + 1) == 0;
      v87 = 0;
      if ( !v8 )
      {
        v69 = 0;
        v80 = v86 + 80;
        do
        {
          v9 = *(_BYTE *)(v80 + 2);
          v10 = (char *)&unk_100AD2F0 + 20 * v9;
          LODWORD(v85) = (char *)&unk_100AD2F0 + 20 * v9;
          sub_10042C60((int)&v105);
          LOBYTE(v112) = 2;
          v8 = *((_DWORD *)v10 + 3) == 0;
          *(float *)&v63 = 0.0;
          if ( !v8 )
          {
            v11 = *((_DWORD *)v10 + 2);
            do
            {
              v66 = 0;
              if ( v11 )
              {
                do
                {
                  v12 = (unsigned int)&v65[2
                                         * (((v63 + *((_DWORD *)v10 + 1)) & 3)
                                          + 4
                                          * (((v66 + *(_DWORD *)v10) >> 2)
                                           + 2 * ((unsigned int)(v63 + *((_DWORD *)v10 + 1)) >> 2)))]
                      + ((v66 + *(_DWORD *)v10) & 3);
                  v13 = *(_DWORD *)(v1 + 188);
                  v14 = *(_BYTE *)(v13 + 4 * v12 + 2);
                  v15 = v13 + 4 * v12;
                  v16 = *(_BYTE *)(v15 + 1);
                  v17 = *(_BYTE *)v15;
                  if ( *(_BYTE *)(v1 + 173) )
                  {
                    *(float *)&v82 = (double)v17 / 255.0;
                    LODWORD(v64) = v14;
                    *(float *)&v83 = (double)v16 / 255.0;
                    *(float *)&v84 = (double)v14 / 255.0;
                    *(float *)&v82 = *(float *)&v82 * 0.5;
                    v18 = *(float *)&v84 * 0.25;
                  }
                  else
                  {
                    *(float *)&v82 = (double)v17 / 255.0;
                    LODWORD(v64) = v14;
                    *(float *)&v83 = (double)v16 / 255.0;
                    v18 = (double)v14 / 255.0;
                  }
                  *(float *)&v84 = v18;
                  v98 = v82;
                  v99 = v83;
                  v100 = v84;
                  v101 = 0;
                  v19 = sub_1004E360((int)&v98, (int)&v105);
                  sub_1004D340((int)&v102, (int)&v105, (int)v19);
                  v20 = v66;
                  v21 = LODWORD(v85);
                  ++*(_DWORD *)(v102 + 24);
                  v11 = *(_DWORD *)(v21 + 8);
                  v1 = a1;
                  v66 = v20 + 1;
                  v10 = (char *)v21;
                }
                while ( v20 + 1 < v11 );
              }
              ++v63;
            }
            while ( (unsigned int)v63 < *((_DWORD *)v10 + 3) );
          }
          sub_10042D20((int)&v105);
          v64 = (signed __int64)((double)(*(_BYTE *)v80 * (unsigned int)*(_BYTE *)(v80 + 1))
                               * *(float *)(v67 + *(_DWORD *)(v1 + 188) + 256));
          v22 = v107;
          v71 = 0.0;
          v72 = 0.0;
          v73 = 0.0;
          v66 = v64;
          v74 = 0.0;
          v75 = 0.0;
          v76 = 0.0;
          if ( v107 )
          {
            v23 = (int *)&v71;
            v24 = v106 - (_DWORD)&v71;
            do
            {
              v25 = (int)v23 + v24;
              if ( v23 != (int *)((char *)v23 + v24) )
              {
                *v23 = *(_DWORD *)v25;
                v26 = *(_DWORD *)(v25 + 4);
                v27 = *(_DWORD *)(v25 + 8);
                v23[1] = v26;
                v23[2] = v27;
              }
              v23 += 3;
              --v22;
            }
            while ( v22 );
            v22 = v107;
          }
          if ( v22 == 1 )
          {
            v74 = v71;
            v75 = v72;
            v76 = v73;
          }
          *(float *)&v63 = v71 * v71;
          *(float *)&v64 = v72 * v72 + *(float *)&v63;
          *(float *)&v63 = v73 * v73 + *(float *)&v64;
          *(float *)&v64 = sqrt(*(float *)&v63);
          *(float *)&v85 = *(float *)&v64;
          *(float *)&v63 = v74 * v74;
          *(float *)&v64 = v75 * v75 + *(float *)&v63;
          *(float *)&v63 = v76 * v76 + *(float *)&v64;
          v85 = *(float *)&v85;
          *(float *)&v64 = sqrt(*(float *)&v63);
          if ( *(float *)&v64 < v85 )
          {
            v28 = v71;
            v29 = v72;
            v71 = v74;
            v30 = v73;
            v72 = v75;
            v74 = v28;
            v75 = v29;
            v73 = v76;
            v76 = v30;
          }
          v89 = v71;
          v90 = v72;
          v91 = v73;
          v92 = v74;
          v93 = v75;
          *(float *)&v94 = v76;
          sub_10042410((int)&v89, (int)&v103, v66);
          v31 = (int)&v69[*(_DWORD *)((char *)v77 + v81)];
          if ( (float *)v31 != &v89 )
          {
            v32 = v90;
            *(float *)v31 = v89;
            v33 = v91;
            *(float *)(v31 + 4) = v32;
            v34 = v92;
            *(float *)(v31 + 8) = v33;
            v35 = v93;
            *(float *)(v31 + 12) = v34;
            v36 = *(float *)&v94;
            *(float *)(v31 + 16) = v35;
            *(float *)(v31 + 20) = v36;
          }
          LOBYTE(v112) = 1;
          sub_10041510((int)&v105);
          v37 = *(_BYTE *)(v86 + 1);
          v80 += 80;
          v69 += 24;
          ++v87;
        }
        while ( v87 < v37 );
      }
      v2 = *(_DWORD *)(v1 + 184);
      v68 += 660;
      v67 += 260;
      v81 += 12;
      v65 = (_WORD *)((char *)v65 + 65);
      v3 = (PSLIST_HEADER)((char *)ListHead + 1);
      ListHead = v3;
    }
    while ( (unsigned int)v3 < v2 );
  }
  v38 = *(_DWORD *)v1;
  if ( *(_DWORD *)(v1 + 280) < *(_DWORD *)v1 )
    v38 = *(_DWORD *)(v1 + 280);
  sub_100424D0((int)&v103, (int)&v103, v38);
  v39 = *(_DWORD *)(v1 + 288);
  v40 = (_DWORD *)(v1 + 284);
  v41 = v104;
  if ( v104 != v39 )
  {
    if ( v104 >= v39 )
    {
      if ( v104 > *(_DWORD *)(v1 + 292) )
      {
        LOBYTE(v64) = v104 == v39 + 1;
        sub_100943C0(v104, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004A140, v1 + 284, v104 == v39 + 1, 0x28u, 0);
      }
      sub_1004CE10(*v40 + 40 * *(_DWORD *)(v1 + 288), v41 - *(_DWORD *)(v1 + 288));
    }
    else
    {
      sub_1004CE50(v39 - v104, (int *)(*v40 + 40 * v104));
    }
    *(_DWORD *)(v1 + 288) = v41;
  }
  v96 = &v103;
  v97 = &v77;
  v65 = 0;
  do
  {
    v43 = *(_DWORD *)(v1 + 524);
    v63 = 16;
    v44 = off_100AD9F4(0, 16, &v63, 1, dword_100AE9F4);
    v45 = (struct _SINGLE_LIST_ENTRY *)v44;
    if ( v44 && (unsigned int)v63 >= 0x10 )
    {
      *(_DWORD *)v44 = &off_100A4F34;
      *(_DWORD *)(v44 + 4) = v1;
      *(_DWORD *)(v44 + 8) = sub_1005D730;
      *(_DWORD *)(v44 + 12) = 1;
      InterlockedIncrement((LPLONG)(v43 + 80));
      v47 = *(_DWORD *)v43;
      v8 = *(_BYTE *)(*(_DWORD *)v43 + 16) == 0;
      ListHead = *(PSLIST_HEADER *)v43;
      if ( !v8 )
      {
        v48 = InterlockedPopEntrySList((PSLIST_HEADER)(v47 + 8));
        if ( v48 )
          goto LABEL_99;
      }
      v88 = 32;
      v48 = (PSINGLE_LIST_ENTRY)off_100AD9F4(0, 32, &v88, 1, dword_100AE9F4);
      if ( !v48 || (unsigned int)v88 < 0x20 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_malloc: out of memory");
        OutputDebugStringA(&OutputString);
        v49 = _iob_func();
        fputs(&OutputString, v49 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
        v48 = 0;
      }
      if ( v48 )
      {
LABEL_99:
        if ( v48 != (PSINGLE_LIST_ENTRY)-8 )
        {
          v48[2].Next = (struct _SINGLE_LIST_ENTRY *)v65;
          v48[3].Next = 0;
          v48[4].Next = (struct _SINGLE_LIST_ENTRY *)&v96;
          v48[5].Next = v45;
          v48[6].Next = (struct _SINGLE_LIST_ENTRY *)1;
          v48[7].Next = v94;
        }
        InterlockedPushEntrySList(ListHead, v48);
        if ( !ReleaseSemaphore(*(HANDLE *)(v43 + 72), 1, 0) )
          sub_10091080();
      }
      else
      {
        InterlockedIncrement((LPLONG)(v43 + 84));
      }
    }
    else
    {
      sprintf_s(
        &DstBuf,
        0x200u,
        "%s(%u): Assertion failed: \"%s\"\n",
        "crn_mem.cpp",
        216,
        "crnlib_malloc: out of memory");
      OutputDebugStringA(&DstBuf);
      v46 = _iob_func();
      fputs(&DstBuf, v46 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    v50 = *(_DWORD *)(v1 + 524);
    v65 = (_WORD *)((char *)v65 + 1);
  }
  while ( (unsigned int)v65 <= *(_DWORD *)(v50 + 4) );
  sub_10091500(v50);
  if ( !*(_BYTE *)(v1 + 520) )
  {
    v8 = *(_DWORD *)(v1 + 184) == 0;
    v67 = 0;
    if ( !v8 )
    {
      v68 = 0;
      do
      {
        v51 = v68 + *(_DWORD *)(v1 + 212);
        v52 = 0;
        LODWORD(v64) = v51;
        if ( *(_BYTE *)(v51 + 1) )
        {
          v65 = (_WORD *)(v51 + 644);
          do
          {
            v53 = *(_DWORD *)(v1 + 284) + 40 * *v65;
            v54 = *(_DWORD *)(v53 + 4);
            if ( v54 >= *(_DWORD *)(v53 + 8) )
            {
              sub_100943C0(v54 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004A100, v53, 1, 8u, 0);
              v51 = v64;
            }
            v55 = *(_DWORD *)v53 + 8 * *(_DWORD *)(v53 + 4);
            if ( v55 )
            {
              *(_DWORD *)v55 = v67;
              *(_DWORD *)(v55 + 4) = v52;
            }
            ++*(_DWORD *)(v53 + 4);
            v56 = *(_BYTE *)(v51 + 1);
            ++v65;
            ++v52;
          }
          while ( v52 < v56 );
        }
        v68 += 660;
        ++v67;
      }
      while ( v67 < *(_DWORD *)(v1 + 184) );
    }
    LOBYTE(v112) = 0;
    v57 = v77;
    if ( v77 )
    {
      v58 = (char *)v77 + 12 * v78;
      v59 = (char *)v77;
      if ( v77 != v58 )
      {
        do
        {
          v60 = *(_DWORD *)v59;
          if ( *(_DWORD *)v59 )
          {
            if ( v60 & 7 )
            {
              sprintf_s(&v109, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
              OutputDebugStringA(&v109);
              v61 = _iob_func();
              fputs(&v109, v61 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v60, 0, 0, 1, dword_100AE9F4);
            }
          }
          v59 += 12;
        }
        while ( v59 != v58 );
        v57 = v77;
      }
      if ( v57 )
      {
        if ( (unsigned __int8)v57 & 7 )
        {
          sprintf_s(&v111, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&v111);
          v62 = _iob_func();
          fputs(&v111, v62 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v57, 0, 0, 1, dword_100AE9F4);
        }
      }
    }
    v112 = -1;
    sub_10041440((int)&v103);
    return 1;
  }
LABEL_41:
  LOBYTE(v112) = 0;
  if ( v77 )
  {
    sub_1003E4E0(v78, (int *)v77);
    if ( v77 )
    {
      if ( (unsigned __int8)v77 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v77, 0, 0, 1, dword_100AE9F4);
    }
  }
  v112 = -1;
  sub_10041440((int)&v103);
  return 0;
}
// 1004A100: using guessed type int sub_1004A100();
// 1004A140: using guessed type int sub_1004A140();
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10063BD0) --------------------------------------------------------
int __fastcall sub_10063BD0(int a1, int a2, int a3, int a4, int a5, int a6, unsigned int a7, _BYTE *a8)
{
  unsigned int v8; // ecx@1
  int v9; // esi@1
  unsigned int v10; // edi@1
  char *v11; // ebp@2
  char *v12; // ecx@4
  int v13; // eax@4
  int result; // eax@8
  __int16 v15; // cx@8
  __int16 v16; // dx@8
  __int16 v17; // [sp+10h] [bp-10Ch]@8
  __int16 v18; // [sp+14h] [bp-108h]@8
  char v19; // [sp+18h] [bp-104h]@8
  char v20; // [sp+1Ah] [bp-102h]@2

  v8 = a7;
  v9 = a6;
  v10 = 0;
  if ( a7 )
  {
    v11 = &v20;
    do
    {
      if ( v9 )
      {
        v12 = v11;
        v13 = *(_DWORD *)(a2 + 20) + 4 * (a4 + *(_DWORD *)(a2 + 8) * (v10 + a5));
        do
        {
          *(v12 - 2) = *(_BYTE *)v13;
          *(v12 - 1) = *(_BYTE *)(v13 + 1);
          *v12 = *(_BYTE *)(v13 + 2);
          v12[1] = *(_BYTE *)(v13 + 3);
          v13 += 4;
          v12 += 4;
          --v9;
        }
        while ( v9 );
        v8 = a7;
        v9 = a6;
      }
      ++v10;
      v11 += 4 * v9;
    }
    while ( v10 < v8 );
  }
  sub_1006B0B0((unsigned int *)&v17, a8, v8 * v9, (int)&v19, (unsigned int *)&v18, 0);
  result = a3;
  v15 = v18;
  v16 = v17;
  *(_DWORD *)(a3 + 12) = a8;
  *(_WORD *)(a3 + 8) = v15;
  *(_WORD *)(a3 + 10) = v16;
  *(_BYTE *)(a3 + 16) = 0;
  *(_DWORD *)a3 = 0x7FFFFFFF;
  *(_DWORD *)(a3 + 4) = 0;
  return result;
}

//----- (10063CB0) --------------------------------------------------------
void __thiscall sub_10063CB0(void *this, int a2, int a3, int a4)
{
  int v4; // esi@1
  char *v5; // ebx@1
  unsigned int v6; // edi@1
  bool v7; // zf@3
  unsigned int v8; // ebx@5
  unsigned int v9; // ecx@10
  unsigned int v10; // eax@12
  int v11; // eax@17
  unsigned int v12; // ecx@20
  int v13; // eax@21
  void *v14; // eax@28
  int v15; // ecx@32
  int v16; // eax@32
  int v17; // ebx@33
  int v18; // edi@33
  int v19; // edi@33
  int v20; // edx@33
  int v21; // edx@33
  int v22; // edx@33
  int v23; // edi@33
  unsigned int v24; // edi@33
  int v25; // edi@33
  int v26; // edx@33
  int v27; // edx@33
  int v28; // edx@33
  int v29; // edi@33
  char *v30; // ebx@36
  int *v31; // edi@36
  unsigned int v32; // edx@37
  int v33; // eax@37
  int v34; // ecx@37
  char *v35; // esi@41
  FILE *v36; // edi@42
  int v37; // eax@42
  unsigned int v38; // ecx@42
  int v39; // edx@42
  unsigned int v40; // ebx@43
  double v41; // st7@43
  int v42; // eax@43
  double v43; // st7@44
  unsigned int v44; // edi@44
  int v45; // edx@45
  _BYTE *v46; // eax@46
  int v47; // ecx@47
  double v48; // st6@49
  double v49; // st7@49
  int v50; // eax@49
  char *v51; // ebx@55
  int v52; // ecx@56
  unsigned __int16 v53; // dx@57
  unsigned __int16 v54; // ax@57
  unsigned int v55; // ecx@57
  unsigned int v56; // eax@58
  char *v57; // edx@58
  unsigned int v58; // edi@59
  char *v59; // eax@60
  int v60; // esi@60
  char v61; // dl@60
  int v62; // esi@64
  unsigned int v63; // esi@64
  unsigned int v64; // ecx@65
  unsigned int v65; // eax@66
  int v66; // edi@67
  int v67; // ecx@67
  int v68; // edx@67
  int v69; // esi@71
  unsigned int v70; // ebx@74
  int *v71; // esi@75
  char *v72; // edi@75
  int v73; // edi@78
  signed int v74; // esi@78
  char v75; // cl@79
  unsigned int v76; // edx@79
  double v77; // st7@79
  long double v78; // st6@79
  float *v79; // esi@79
  unsigned int v80; // ebx@79
  double v81; // st7@83
  double v82; // st5@86
  double v83; // st5@90
  int v84; // eax@90
  double v85; // st5@90
  double v86; // st5@93
  int v87; // eax@93
  int v88; // edi@93
  double v89; // st4@94
  int v90; // edx@97
  char *v91; // ecx@97
  unsigned int v92; // ebx@107
  char *v93; // esi@112
  int v94; // eax@112
  int v95; // eax@113
  _BYTE *v96; // esi@114
  int v97; // ecx@114
  char *v98; // edx@115
  char *v99; // esi@115
  int v100; // ecx@115
  bool v101; // dl@115
  int v102; // ecx@116
  char *v103; // edx@116
  int v104; // ecx@117
  int v105; // ebx@120
  unsigned int v106; // esi@120
  char *v107; // ecx@120
  void *v108; // edx@121
  unsigned int v109; // eax@121
  int v110; // esi@123
  int v111; // edi@123
  unsigned int v112; // edi@123
  unsigned int v113; // edi@123
  float v114; // edx@123
  int v115; // edi@123
  unsigned int v116; // esi@123
  char *v117; // ecx@125
  char *v118; // edx@127
  unsigned int v119; // eax@128
  unsigned int v120; // esi@129
  int v121; // eax@130
  unsigned int v122; // edi@130
  float v123; // esi@130
  unsigned int v124; // eax@130
  char v125; // cl@130
  int v126; // esi@130
  unsigned int v127; // eax@134
  unsigned int v128; // [sp-10h] [bp-1030h]@139
  unsigned int v129; // [sp-Ch] [bp-102Ch]@139
  FILE *v130; // [sp-4h] [bp-1024h]@1
  _DWORD *v131; // [sp+10h] [bp-1010h]@44
  char *v132; // [sp+14h] [bp-100Ch]@44
  float v133; // [sp+18h] [bp-1008h]@1
  int v134; // [sp+1Ch] [bp-1004h]@1
  void *v135; // [sp+20h] [bp-1000h]@41
  char *v136; // [sp+24h] [bp-FFCh]@32
  unsigned int v137; // [sp+28h] [bp-FF8h]@33
  char *v138; // [sp+2Ch] [bp-FF4h]@41
  char *v139; // [sp+30h] [bp-FF0h]@36
  int v140; // [sp+34h] [bp-FECh]@32
  char *v141; // [sp+38h] [bp-FE8h]@39
  unsigned int v142; // [sp+3Ch] [bp-FE4h]@33
  float v143; // [sp+40h] [bp-FE0h]@43
  char v144; // [sp+47h] [bp-FD9h]@79
  unsigned int v145; // [sp+48h] [bp-FD8h]@20
  int *v146; // [sp+4Ch] [bp-FD4h]@39
  unsigned int v147; // [sp+50h] [bp-FD0h]@5
  unsigned int v148; // [sp+54h] [bp-FCCh]@3
  int v149; // [sp+58h] [bp-FC8h]@32
  int v150; // [sp+5Ch] [bp-FC4h]@47
  unsigned int v151; // [sp+60h] [bp-FC0h]@3
  float *v152; // [sp+64h] [bp-FBCh]@41
  float v153; // [sp+68h] [bp-FB8h]@43
  int v154; // [sp+6Ch] [bp-FB4h]@1
  int v155; // [sp+70h] [bp-FB0h]@1
  int v156; // [sp+74h] [bp-FACh]@1
  int v157; // [sp+78h] [bp-FA8h]@1
  int v158; // [sp+7Ch] [bp-FA4h]@1
  int v159; // [sp+80h] [bp-FA0h]@1
  void *v160; // [sp+84h] [bp-F9Ch]@1
  int v161; // [sp+88h] [bp-F98h]@1
  int v162; // [sp+8Ch] [bp-F94h]@1
  int v163; // [sp+90h] [bp-F90h]@79
  int v164; // [sp+94h] [bp-F8Ch]@79
  int v165; // [sp+98h] [bp-F88h]@79
  int v166; // [sp+9Ch] [bp-F84h]@79
  int v167; // [sp+A0h] [bp-F80h]@79
  int v168; // [sp+A4h] [bp-F7Ch]@79
  int v169; // [sp+A8h] [bp-F78h]@79
  int v170; // [sp+ACh] [bp-F74h]@79
  char v171[16]; // [sp+B0h] [bp-F70h]@57
  char v172[32]; // [sp+C0h] [bp-F60h]@67
  char v173[10]; // [sp+E0h] [bp-F40h]@36
  __int16 v174; // [sp+EAh] [bp-F36h]@57
  int v175; // [sp+ECh] [bp-F34h]@3
  int v176; // [sp+104h] [bp-F1Ch]@3
  int v177; // [sp+11Ch] [bp-F04h]@3
  int v178; // [sp+134h] [bp-EECh]@3
  int v179; // [sp+14Ch] [bp-ED4h]@3
  int v180; // [sp+164h] [bp-EBCh]@3
  int v181; // [sp+17Ch] [bp-EA4h]@3
  int v182; // [sp+194h] [bp-E8Ch]@3
  int v183; // [sp+1ACh] [bp-E74h]@3
  float v184[18]; // [sp+1B8h] [bp-E68h]@38
  char v185[20]; // [sp+200h] [bp-E20h]@1
  char v186[268]; // [sp+214h] [bp-E0Ch]@53
  char DstBuf; // [sp+320h] [bp-D00h]@3
  double v188; // [sp+340h] [bp-CE0h]@86
  char v189[16]; // [sp+520h] [bp-B00h]@39
  char v190[416]; // [sp+530h] [bp-AF0h]@63
  char v191[576]; // [sp+6D0h] [bp-950h]@36
  char v192; // [sp+910h] [bp-710h]@3
  char v193; // [sp+930h] [bp-6F0h]@93
  char v194[1156]; // [sp+B90h] [bp-490h]@39
  int v195; // [sp+101Ch] [bp-4h]@1

  v4 = (int)this;
  v134 = (int)this;
  v154 = 0;
  v155 = 0;
  v156 = 0;
  v157 = 0;
  v158 = 15;
  v159 = 0;
  v160 = 0;
  v161 = 0;
  v162 = 0;
  v195 = 0;
  `eh vector constructor iterator'(v185, 0x24u, 8, (int)sub_100336F0, sub_100336C0);
  v133 = COERCE_FLOAT(&v130);
  LOBYTE(v195) = 1;
  sub_10034090((int)&v154, 8u, 8u, -16777216);
  v5 = v185;
  v6 = 8;
  do
  {
    v133 = COERCE_FLOAT(&v130);
    sub_10034090((int)v5, 8u, 8u, -16777216);
    v5 += 36;
    --v6;
  }
  while ( v6 );
  memset(&DstBuf, 0, 0x140u);
  v175 = 0;
  v176 = 0;
  v177 = 0;
  v178 = 0;
  v179 = 0;
  v180 = 0;
  v181 = 0;
  v182 = 0;
  v183 = 0;
  memset(&v192, 0, 0x280u);
  v7 = *(_BYTE *)(v4 + 172) == 0;
  v148 = 0;
  v151 = 0;
  if ( v7 )
  {
    v148 = 5;
    v151 = 7;
  }
  v8 = 0;
  v147 = 0;
  if ( *(_DWORD *)(v4 + 184) <= 0u )
    goto LABEL_140;
  while ( 2 )
  {
    if ( *(_BYTE *)(v4 + 520) )
    {
      LOBYTE(v195) = 0;
      `eh vector destructor iterator'(v185, 0x24u, 8, sub_100336C0);
      v195 = -1;
      v14 = v160;
      if ( v160 == (void *)v6 )
        return;
      if ( (unsigned __int8)v160 & 7 )
      {
        v130 = (FILE *)"crnlib_free: bad ptr";
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v130 = _iob_func() + 2;
        fputs(&DstBuf, v130);
LABEL_143:
        if ( IsDebuggerPresent() )
          DebugBreak();
        return;
      }
LABEL_139:
      v130 = (FILE *)dword_100AE9F4;
      v129 = v6;
      v128 = v6;
      goto LABEL_146;
    }
    if ( GetCurrentThreadId() != *(_DWORD *)(v4 + 512) )
      goto LABEL_17;
    if ( 0 != *(_DWORD *)(v4 + 516) )
      goto LABEL_17;
    if ( v8 & 0x1FF )
      goto LABEL_17;
    v9 = *(_DWORD *)(v4 + 184);
    if ( *(_DWORD *)(v4 + 176) == v6 )
      goto LABEL_17;
    if ( v9 <= 1 )
    {
      v10 = 100;
    }
    else
    {
      v10 = 100 * v8 / (v9 - 1);
      v6 = 0;
    }
    if ( *(_DWORD *)(v4 + 528) != v6 || *(_DWORD *)(v4 + 532) != v10 )
    {
      *(_DWORD *)(v4 + 532) = v10;
      if ( (*(int (__cdecl **)(unsigned int, signed int, unsigned int, unsigned int, _DWORD))(v4 + 176))(
             v6,
             25,
             v8,
             v9,
             *(_DWORD *)(v4 + 180)) != 0 )
        goto LABEL_17;
      *(_BYTE *)(v4 + 520) = 1;
      goto LABEL_28;
    }
    if ( *(_BYTE *)(v4 + 520) )
    {
LABEL_28:
      LOBYTE(v195) = 0;
      `eh vector destructor iterator'(v185, 0x24u, 8, sub_100336C0);
      v195 = -1;
      v14 = v160;
      if ( v160 == (void *)v6 )
        return;
      if ( (unsigned __int8)v160 & 7 )
      {
        sub_100927E0((int)"crnlib_free: bad ptr");
        return;
      }
      goto LABEL_139;
    }
LABEL_17:
    v11 = *(_DWORD *)(*(_DWORD *)(v4 + 524) + 4);
    if ( v11 != v6 )
    {
      if ( v8 % (v11 + 1) != a2 )
        goto LABEL_134;
      v8 = v147;
      v4 = v134;
      v6 = 0;
    }
    v12 = 0;
    v145 = v6;
    if ( *(_DWORD *)(v4 + 164) > v6 )
    {
      v13 = v4 + 36;
      while ( v8 < *(_DWORD *)v13 || v8 >= *(_DWORD *)v13 + *(_DWORD *)(v13 + 4) )
      {
        ++v12;
        v13 += 8;
        if ( v12 >= *(_DWORD *)(v4 + 164) )
          goto LABEL_32;
      }
      v145 = v12;
    }
LABEL_32:
    v15 = 65 * v8;
    v136 = (char *)v6;
    v149 = 65 * v8;
    v140 = 4 * v156;
    v16 = v159 + 6;
    do
    {
      v17 = *(_DWORD *)(v4 + 188);
      v142 = 2 * (v6 >> 2);
      v18 = v6 & 3;
      v137 = v18;
      v19 = 4 * (v18 + 4 * v142);
      v20 = v17 + 4 * (v19 + v15);
      *(_BYTE *)(v16 - 6) = *(_BYTE *)v20;
      *(_BYTE *)(v16 - 5) = *(_BYTE *)(v20 + 1);
      *(_BYTE *)(v16 - 4) = *(_BYTE *)(v20 + 2);
      *(_BYTE *)(v16 - 3) = *(_BYTE *)(v20 + 3);
      v21 = *(_DWORD *)(v4 + 188) + 4 * (v19 + v15) + 4;
      *(_BYTE *)(v16 - 2) = *(_BYTE *)v21;
      *(_BYTE *)(v16 - 1) = *(_BYTE *)(v21 + 1);
      *(_BYTE *)v16 = *(_BYTE *)(v21 + 2);
      *(_BYTE *)(v16 + 1) = *(_BYTE *)(v21 + 3);
      v22 = *(_DWORD *)(v4 + 188) + 4 * (v19 + v15) + 8;
      *(_BYTE *)(v16 + 2) = *(_BYTE *)v22;
      *(_BYTE *)(v16 + 3) = *(_BYTE *)(v22 + 1);
      *(_BYTE *)(v16 + 4) = *(_BYTE *)(v22 + 2);
      *(_BYTE *)(v16 + 5) = *(_BYTE *)(v22 + 3);
      v23 = *(_DWORD *)(v4 + 188) + 4 * (v15 + v19) + 12;
      *(_BYTE *)(v16 + 6) = *(_BYTE *)v23;
      *(_BYTE *)(v16 + 7) = *(_BYTE *)(v23 + 1);
      *(_BYTE *)(v16 + 8) = *(_BYTE *)(v23 + 2);
      LOBYTE(v22) = *(_BYTE *)(v23 + 3);
      v24 = v142;
      *(_BYTE *)(v16 + 9) = v22;
      v25 = 4 * (v137 + 4 * v24 + 4);
      v26 = *(_DWORD *)(v4 + 188) + 4 * (v25 + v15);
      *(_BYTE *)(v16 + 10) = *(_BYTE *)v26;
      *(_BYTE *)(v16 + 11) = *(_BYTE *)(v26 + 1);
      *(_BYTE *)(v16 + 12) = *(_BYTE *)(v26 + 2);
      *(_BYTE *)(v16 + 13) = *(_BYTE *)(v26 + 3);
      v27 = *(_DWORD *)(v4 + 188) + 4 * (v25 + v15) + 4;
      *(_BYTE *)(v16 + 14) = *(_BYTE *)v27;
      *(_BYTE *)(v16 + 15) = *(_BYTE *)(v27 + 1);
      *(_BYTE *)(v16 + 16) = *(_BYTE *)(v27 + 2);
      *(_BYTE *)(v16 + 17) = *(_BYTE *)(v27 + 3);
      v28 = *(_DWORD *)(v4 + 188) + 4 * (v25 + v15) + 8;
      *(_BYTE *)(v16 + 18) = *(_BYTE *)v28;
      *(_BYTE *)(v16 + 19) = *(_BYTE *)(v28 + 1);
      *(_BYTE *)(v16 + 20) = *(_BYTE *)(v28 + 2);
      *(_BYTE *)(v16 + 21) = *(_BYTE *)(v28 + 3);
      v29 = *(_DWORD *)(v4 + 188) + 4 * (v15 + v25) + 12;
      *(_BYTE *)(v16 + 22) = *(_BYTE *)v29;
      *(_BYTE *)(v16 + 23) = *(_BYTE *)(v29 + 1);
      *(_BYTE *)(v16 + 24) = *(_BYTE *)(v29 + 2);
      LOBYTE(v28) = *(_BYTE *)(v29 + 3);
      v6 = (unsigned int)(v136 + 1);
      *(_BYTE *)(v16 + 25) = v28;
      v16 += v140;
      v136 = (char *)v6;
    }
    while ( v6 < 8 );
    if ( *(_BYTE *)(v4 + 208) && v148 < 9 )
    {
      v30 = &v191[64 * v148];
      v139 = &v173[24 * v148];
      v31 = &dword_100AD2F8[5 * v148];
      v136 = (char *)(9 - v148);
      do
      {
        memset(v30, 0, 0x40u);
        v32 = v31[1];
        v33 = *v31;
        v34 = *(v31 - 1);
        v130 = (FILE *)v30;
        sub_10063BD0(v34, (int)&v154, (int)v139, *(v31 - 2), v34, v33, v32, v30);
        v139 += 24;
        v30 += 64;
        v31 += 5;
        --v136;
      }
      while ( v136 );
    }
    memset(v184, 0, 0x48u);
    v7 = *(_DWORD *)(v4 + 204) == 0;
    v137 = 0;
    if ( !v7 )
    {
      LODWORD(v133) = v134 + 28;
      v146 = (int *)(v134 + 28);
      v136 = &v194[64 * v148];
      v141 = &v189[24 * v148];
      do
      {
        if ( v148 < 9 )
        {
          v152 = &v184[v148];
          v135 = v136;
          v35 = (char *)&unk_100AD2F0 + 20 * v148;
          v138 = v141;
          v142 = 9 - v148;
          do
          {
            v36 = (FILE *)v135;
            memset(v135, 0, 0x40u);
            v37 = *v146;
            v38 = *((_DWORD *)v35 + 3);
            v39 = *((_DWORD *)v35 + 1);
            v130 = v36;
            sub_10061520(
              (int)v138,
              *((_DWORD *)v35 + 2),
              v138,
              v147,
              (int)&v154,
              *(_DWORD *)v35,
              v39,
              v38,
              v37,
              (int)v36);
            if ( *(_DWORD *)(v134 + 204) )
            {
              v40 = *((_DWORD *)v35 + 3);
              v140 = v40 * *((_DWORD *)v35 + 2);
              v41 = 1.0 / (double)(unsigned int)v140;
              v139 = (char *)LODWORD(v133);
              v42 = *(_DWORD *)(v134 + 204);
              v143 = *(float *)&v152;
              v140 = v42;
              v153 = v41;
              do
              {
                v43 = v153;
                v44 = 0;
                *(float *)&v131 = 0.0;
                *(float *)&v132 = 0.0;
                if ( v40 )
                {
                  do
                  {
                    v45 = *((_DWORD *)v35 + 2);
                    if ( v45 )
                    {
                      v46 = (_BYTE *)(*(_DWORD *)v139 + v159
                                                      + 4 * (*(_DWORD *)v35 + v156 * (v44 + *((_DWORD *)v35 + 1))));
                      do
                      {
                        v47 = *v46;
                        v150 = *v46;
                        *(float *)&v131 = (double)(unsigned int)v150 + *(float *)&v131;
                        v150 = v47 * v47;
                        v46 += 4;
                        --v45;
                        *(float *)&v132 = (double)(unsigned int)(v47 * v47) + *(float *)&v132;
                      }
                      while ( v45 );
                    }
                    v40 = *((_DWORD *)v35 + 3);
                    ++v44;
                  }
                  while ( v44 < v40 );
                }
                *(float *)&v131 = v43 * *(float *)&v131;
                v48 = v43 * *(float *)&v132;
                v49 = *(float *)&v131;
                *(float *)&v131 = v48;
                *(float *)&v132 = *(float *)&v131 - v49 * v49;
                *(float *)&v131 = sqrt(*(float *)&v132);
                v50 = LODWORD(v143);
                v139 += 4;
                *(float *)LODWORD(v143) = *(float *)&v131;
                v7 = v140-- == 1;
                LODWORD(v143) = v50 + 36;
              }
              while ( !v7 );
            }
            v135 = (char *)v135 + 64;
            v138 += 24;
            ++v152;
            v35 += 20;
            --v142;
          }
          while ( *(float *)&v142 != 0.0 );
        }
        ++v146;
        v141 += 216;
        v136 += 576;
        ++v137;
      }
      while ( v137 < *(_DWORD *)(v134 + 204) );
    }
    if ( v151 < 8 )
    {
      v131 = (_DWORD *)(84 * v151);
      v135 = (void *)(40 * v151);
      v132 = &v186[36 * v151];
      v140 = 8 - v151;
      do
      {
        v7 = *(_DWORD *)((char *)v131 + (_DWORD)dword_100AD050) == 0;
        *(float *)&v142 = 0.0;
        if ( !v7 )
        {
          v138 = (char *)v131;
          v51 = (char *)(v131 + 67286037);
          do
          {
            v7 = *(_BYTE *)(v134 + 208) == 0;
            v52 = *((_DWORD *)v51 + 4);
            v143 = *((float *)v51 + 4);
            if ( !v7 )
            {
              v53 = *(&v174 + 12 * v52);
              v54 = *(_WORD *)&v173[24 * v52 + 8];
              LODWORD(v133) = &v191[64 * v52];
              sub_100924B0(v54, (int)v171, v53);
              v55 = 0;
              if ( *((_DWORD *)v51 + 3) )
              {
                v56 = *((_DWORD *)v51 + 2);
                v57 = v132;
                do
                {
                  v58 = 0;
                  if ( v56 )
                  {
                    do
                    {
                      v59 = &v171[4 * *(_BYTE *)(v58 + v55 * v56 + LODWORD(v133))];
                      v60 = *(_DWORD *)v57
                          + 4 * (v58 + *(_DWORD *)v51 + *((_DWORD *)v57 - 3) * (v55 + *((_DWORD *)v51 + 1)));
                      *(_BYTE *)v60 = *v59;
                      *(_BYTE *)(v60 + 1) = v59[1];
                      v61 = v59[2];
                      LOBYTE(v59) = v59[3];
                      *(_BYTE *)(v60 + 2) = v61;
                      v57 = v132;
                      *(_BYTE *)(v60 + 3) = (_BYTE)v59;
                      v56 = *((_DWORD *)v51 + 2);
                      ++v58;
                    }
                    while ( v58 < v56 );
                  }
                  ++v55;
                }
                while ( v55 < *((_DWORD *)v51 + 3) );
              }
            }
            v7 = *(_DWORD *)(v134 + 204) == 0;
            v137 = 0;
            if ( !v7 )
            {
              v146 = (int *)(v134 + 28);
              v141 = &v194[64 * LODWORD(v143)];
              v136 = &v190[24 * LODWORD(v143)];
              do
              {
                v62 = (unsigned __int8)*v136;
                sub_10092180((unsigned __int8)v136[1]);
                v63 = 0;
                if ( *((_DWORD *)v51 + 3) )
                {
                  v64 = *((_DWORD *)v138 + 67286039);
                  do
                  {
                    v65 = 0;
                    if ( v64 )
                    {
                      do
                      {
                        v66 = (unsigned __int8)*(&v141[v65] + v63 * v64);
                        v67 = *v146 + 4 * (v65 + *(_DWORD *)v51 + *((_DWORD *)v132 - 3) * (v63 + *((_DWORD *)v51 + 1)));
                        v68 = *(_DWORD *)v132;
                        v133 = *(float *)&v51;
                        *(_BYTE *)(v67 + v68) = v172[4 * v66];
                        v64 = *((_DWORD *)v138 + 67286039);
                        *(float *)&v51 = v133;
                        ++v65;
                      }
                      while ( v65 < v64 );
                    }
                    ++v63;
                  }
                  while ( v63 < *((_DWORD *)v51 + 3) );
                }
                v136 += 216;
                v141 += 576;
                ++v146;
                ++v137;
              }
              while ( v137 < *(_DWORD *)(v134 + 204) );
            }
            v138 += 20;
            v51 += 20;
            ++v142;
          }
          while ( v142 < *(_DWORD *)((char *)v131 + (_DWORD)dword_100AD050) );
        }
        v69 = v134;
        if ( *(_BYTE *)(v134 + 172) )
        {
          if ( *(_BYTE *)(v134 + 208) )
            sub_1007AC30((int)v135 + (_DWORD)&DstBuf, (int)(v132 - 20), (int)&v154, 0, 3u);
          v70 = 0;
          if ( *(_DWORD *)(v69 + 204) )
          {
            v71 = (int *)(v69 + 28);
            v72 = (char *)v135 + (_DWORD)&v192;
            do
            {
              sub_1007AC30((int)v72, (int)(v132 - 20), (int)&v154, *v71, 1u);
              ++v70;
              ++v71;
              v72 += 320;
            }
            while ( v70 < *(_DWORD *)(v134 + 204) );
          }
        }
        v131 += 21;
        v132 += 36;
        v135 = (char *)v135 + 40;
        --v140;
      }
      while ( v140 );
    }
    v73 = v134;
    v7 = *(_BYTE *)(v134 + 172) == 0;
    v74 = 7;
    v132 = (char *)7;
    if ( !v7 )
    {
      v75 = *(_BYTE *)(v134 + 208);
      v76 = *(_DWORD *)(v134 + 204);
      v143 = 0.0;
      v77 = 0.0;
      v78 = 3.0;
      v163 = 0;
      v164 = 0;
      v165 = 0;
      v166 = 0;
      v167 = 0;
      v168 = 0;
      v169 = 0;
      v170 = 0;
      *(float *)&v132 = 0.0;
      *(float *)&v141 = 0.0;
      v144 = v75;
      v137 = v76;
      v79 = (float *)&v163;
      v135 = 0;
      v80 = 0;
      do
      {
        if ( v144 )
        {
          v131 = *(_DWORD **)(v73 + 16);
          if ( v145 && *(float *)&v131 > 0.25 )
          {
            v133 = pow(v78, (double)v145);
            v133 = *(float *)&v131 / v133;
            v81 = v133;
            if ( v133 < 0.25 )
              v81 = 0.25;
            *(float *)&v131 = v81;
            v77 = 0.0;
            v78 = 3.0;
          }
          v150 = dword_100AD050[v80] - 1;
          v133 = (double)(unsigned int)v150 / v78;
          v133 = v133 * (*(float *)&v131 - v77) + v77;
          v82 = *(double *)((char *)v135 + (_DWORD)&v188) - v133;
          if ( v82 <= v77 )
            v82 = v77;
          *v79 = v82;
        }
        if ( v137 )
        {
          v83 = *(float *)(v73 + 24) * *v79;
          v150 = dword_100AD050[v80] - 1;
          v84 = v150;
          *v79 = v83;
          v85 = (double)v150;
          if ( v84 < 0 )
            v85 = v85 + 4294967300.0;
          v133 = v85 / v78;
          v133 = v133 * (*(float *)(v73 + 20) - v77) + v77;
          *(float *)&v142 = 0.0;
          if ( v137 )
          {
            v86 = v133;
            v87 = *(_DWORD *)(v134 + 204);
            v88 = 0;
            v136 = (char *)v135 + (_DWORD)&v193;
            v140 = v87;
            do
            {
              v89 = *(double *)v136 - v86;
              if ( v89 <= v77 )
                v89 = v77;
              v7 = dword_100AD050[v80] == 0;
              v133 = v89;
              *v79 = v133 + *v79;
              if ( !v7 )
              {
                v90 = dword_100AD050[v80];
                v91 = (char *)&unk_100AD064 + v80 * 4;
                do
                {
                  v133 = v184[v88 + *(_DWORD *)v91];
                  if ( v133 >= (double)*(float *)&v142 )
                    *(float *)&v142 = v133;
                  v91 += 20;
                  --v90;
                }
                while ( v90 );
              }
              v136 += 320;
              v88 += 9;
              --v140;
            }
            while ( v140 );
            v73 = v134;
          }
        }
        if ( v143 < (double)*v79 )
        {
          v143 = *v79;
          v132 = v141;
        }
        ++v141;
        v135 = (char *)v135 + 40;
        v80 += 21;
        ++v79;
      }
      while ( v80 < 168 );
      v74 = (signed int)v132;
    }
    InterlockedIncrement((LPLONG)(v73 + 4 * v74 + 248));
    v138 = (char *)(84 * v74);
    InterlockedExchangeAdd((LPLONG)(v73 + 280), dword_100AD050[21 * v74]);
    v92 = 0;
    do
    {
      if ( v92 )
      {
        if ( v92 > *(_DWORD *)(v134 + 204) )
          goto LABEL_118;
      }
      else if ( !*(_BYTE *)(v134 + 208) )
      {
        goto LABEL_118;
      }
      v93 = v138;
      v94 = *(_DWORD *)(v134 + 12 * v92 + 212) + 660 * v147;
      *(_BYTE *)v94 = (_BYTE)v132;
      *(_BYTE *)(v94 + 1) = v93[(_DWORD)dword_100AD050];
      v7 = *(_DWORD *)&v93[(_DWORD)dword_100AD050] == 0;
      v137 = 0;
      if ( !v7 )
      {
        v95 = v94 + 80;
        v135 = v93 + 269144156;
        do
        {
          v96 = v135;
          v97 = *((_DWORD *)v135 + 2);
          *(_BYTE *)(v95 + 2) = v97;
          *(_BYTE *)v95 = *v96;
          *(_BYTE *)(v95 + 1) = v96[4];
          *(_DWORD *)(v95 - 76) = 0;
          if ( v92 )
          {
            v102 = v92 + v97 + 8 * v92 - 8 - 1;
            v103 = &v189[24 * v102];
            *(_DWORD *)(v95 - 72) = (unsigned __int8)v103[16];
            *(_DWORD *)(v95 - 68) = (unsigned __int8)v103[17];
            qmemcpy((void *)(v95 - 64), &v194[64 * v102], 0x40u);
            v101 = v103[18] != 0;
          }
          else
          {
            v98 = &v173[24 * v97];
            v99 = &v191[64 * v97];
            *(_DWORD *)(v95 - 72) = *((_WORD *)v98 + 4);
            v100 = *((_WORD *)v98 + 5);
            v101 = v98[16];
            *(_DWORD *)(v95 - 68) = v100;
            qmemcpy((void *)(v95 - 64), v99, 0x40u);
          }
          v104 = v137;
          v135 = (char *)v135 + 20;
          *(_BYTE *)(v95 + 3) = v101;
          v95 += 80;
          v137 = v104 + 1;
        }
        while ( (unsigned int)(v104 + 1) < *(_DWORD *)&v138[(_DWORD)dword_100AD050] );
      }
LABEL_118:
      ++v92;
    }
    while ( v92 < 3 );
    if ( *(_BYTE *)(v134 + 174) )
    {
      v105 = v149;
      *(float *)&v106 = 0.0;
      *(float *)&v131 = 0.0;
      v107 = &v185[36 * (_DWORD)v132];
      do
      {
        v108 = (void *)(2 * (v106 >> 2));
        v109 = 0;
        v135 = (void *)(2 * (v106 >> 2));
        v139 = (char *)(v106 & 3);
        while ( 1 )
        {
          v110 = *((_DWORD *)v107 + 5) + 4 * (v109 + v106 * *((_DWORD *)v107 + 2));
          v111 = *(_DWORD *)(v134 + 380) + 4 * (v105 + (v109 & 3) + 4 * (_DWORD)&v139[4 * ((_DWORD)v108 + (v109 >> 2))]);
          *(_BYTE *)v111 = *(_BYTE *)v110;
          *(_BYTE *)(v111 + 1) = *(_BYTE *)(v110 + 1);
          *(_BYTE *)(v111 + 2) = *(_BYTE *)(v110 + 2);
          *(_BYTE *)(v111 + 3) = *(_BYTE *)(v110 + 3);
          v132 = (char *)(*((_DWORD *)v107 + 5) + 4 * (v109 + (_DWORD)v131 * *((_DWORD *)v107 + 2)) + 4);
          v112 = *(_DWORD *)(v134 + 380)
               + 4 * (v105 + (((_BYTE)v109 + 1) & 3) + 4 * (_DWORD)&v139[4 * ((_DWORD)v135 + ((v109 + 1) >> 2))]);
          *(_BYTE *)v112 = *v132;
          *(_BYTE *)(v112 + 1) = v132[1];
          *(_BYTE *)(v112 + 2) = v132[2];
          *(_BYTE *)(v112 + 3) = v132[3];
          v132 = (char *)(*((_DWORD *)v107 + 5) + 4 * (v109 + (_DWORD)v131 * *((_DWORD *)v107 + 2)) + 8);
          v113 = *(_DWORD *)(v134 + 380)
               + 4 * (v105 + (((_BYTE)v109 + 2) & 3) + 4 * (_DWORD)&v139[4 * ((_DWORD)v135 + ((v109 + 2) >> 2))]);
          v114 = *(float *)&v132;
          *(_BYTE *)v113 = *v132;
          *(_BYTE *)(v113 + 1) = *(_BYTE *)(LODWORD(v114) + 1);
          *(_BYTE *)(v113 + 2) = *(_BYTE *)(LODWORD(v114) + 2);
          *(_BYTE *)(v113 + 3) = *(_BYTE *)(LODWORD(v114) + 3);
          v115 = *((_DWORD *)v107 + 5) + 4 * (v109 + (_DWORD)v131 * *((_DWORD *)v107 + 2)) + 12;
          v105 = v149;
          v116 = *(_DWORD *)(v134 + 380)
               + 4 * (v149 + (((_BYTE)v109 - 1) & 3) + 4 * (_DWORD)&v139[4 * ((_DWORD)v135 + ((v109 + 3) >> 2))]);
          *(_BYTE *)v116 = *(_BYTE *)v115;
          *(_BYTE *)(v116 + 1) = *(_BYTE *)(v115 + 1);
          *(_BYTE *)(v116 + 2) = *(_BYTE *)(v115 + 2);
          v109 += 4;
          *(_BYTE *)(v116 + 3) = *(_BYTE *)(v115 + 3);
          v106 = (unsigned int)v131;
          if ( v109 >= 8 )
            break;
          v108 = v135;
        }
        v106 = (unsigned int)v131 + 1;
        v131 = (_DWORD *)v106;
      }
      while ( v106 < 8 );
      v117 = v138;
      v7 = *(_DWORD *)&v138[(_DWORD)dword_100AD050] == 0;
      v137 = 0;
      if ( !v7 )
      {
        v136 = v138 + 269144164;
        do
        {
          v7 = dword_100AD2FC[5 * *(_DWORD *)v136] == 0;
          v118 = (char *)&unk_100AD2F0 + 20 * *(_DWORD *)v136;
          v133 = *(float *)v136;
          v145 = 0;
          if ( !v7 )
          {
            v119 = *((_DWORD *)v118 + 2);
            do
            {
              v120 = 0;
              v149 = 0;
              if ( v119 )
              {
                do
                {
                  v121 = v120 + *(_DWORD *)v118;
                  v122 = (v120 + *(_DWORD *)v118) >> 2;
                  v123 = v133;
                  v124 = *(_DWORD *)(v134 + 392)
                       + 4
                       * (v105
                        + (v121 & 3)
                        + 4
                        * (((v145 + *((_DWORD *)v118 + 1)) & 3) + 4 * (v122 + 2 * ((v145 + *((_DWORD *)v118 + 1)) >> 2))));
                  *(_BYTE *)v124 = byte_100AE384[4 * LODWORD(v133)];
                  *(_BYTE *)(v124 + 1) = byte_100AE385[4 * LODWORD(v123)];
                  *(_BYTE *)(v124 + 2) = byte_100AE386[4 * LODWORD(v123)];
                  v125 = byte_100AE387[4 * LODWORD(v123)];
                  v126 = v149;
                  *(_BYTE *)(v124 + 3) = v125;
                  v119 = *((_DWORD *)v118 + 2);
                  v120 = v126 + 1;
                  v149 = v120;
                }
                while ( v120 < v119 );
              }
              ++v145;
            }
            while ( v145 < *((_DWORD *)v118 + 3) );
            v117 = v138;
          }
          v136 += 20;
          ++v137;
        }
        while ( v137 < *(_DWORD *)&v117[(_DWORD)dword_100AD050] );
      }
    }
LABEL_134:
    v127 = v147 + 1;
    v147 = v127;
    if ( v127 < *(_DWORD *)(v134 + 184) )
    {
      v8 = v127;
      v6 = 0;
      v4 = v134;
      continue;
    }
    break;
  }
LABEL_140:
  LOBYTE(v195) = 0;
  `eh vector destructor iterator'(v185, 0x24u, 8, sub_100336C0);
  v195 = -1;
  v14 = v160;
  if ( v160 )
  {
    if ( (unsigned __int8)v160 & 7 )
    {
      v130 = (FILE *)"crnlib_free: bad ptr";
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v130 = _iob_func() + 2;
      fputs(&DstBuf, v130);
      goto LABEL_143;
    }
    v130 = (FILE *)dword_100AE9F4;
    v129 = 0;
    v128 = 0;
LABEL_146:
    off_100AD9F4(v14, v128, v129, 1, v130);
  }
}
// 10092180: using guessed type double __thiscall sub_10092180(_DWORD);
// 100AD050: using guessed type int dword_100AD050[];
// 100AD05C: using guessed type int dword_100AD05C;
// 100AD2F8: using guessed type int dword_100AD2F8[];
// 100AD2FC: using guessed type int dword_100AD2FC[];
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 10063CB0: using guessed type char var_E20[20];
// 10063CB0: using guessed type char var_F40[10];
// 10063CB0: using guessed type char var_950[576];
// 10063CB0: using guessed type float var_E68[18];
// 10063CB0: using guessed type char var_490[1156];
// 10063CB0: using guessed type char var_B00[16];
// 10063CB0: using guessed type char var_E0C[268];
// 10063CB0: using guessed type char var_F70[16];
// 10063CB0: using guessed type char var_AF0[416];
// 10063CB0: using guessed type char var_F60[32];

//----- (10064F30) --------------------------------------------------------
bool __stdcall sub_10064F30(int a1)
{
  int v1; // esi@1
  signed int v2; // edi@1
  int v3; // eax@2
  unsigned int v4; // esi@10
  int v5; // edi@11
  unsigned int v6; // ebx@14
  unsigned int v7; // eax@14
  int v8; // esi@18
  int i; // edi@18
  unsigned int v10; // ebx@23
  unsigned int v11; // eax@23
  int v12; // esi@27
  int j; // edi@27
  unsigned int v14; // ebx@32
  int v15; // edi@33
  int v16; // esi@34
  int v17; // esi@34
  int v18; // edi@36
  int v19; // eax@36
  struct _SINGLE_LIST_ENTRY *v20; // esi@36
  FILE *v21; // eax@38
  int v22; // ebx@40
  PSINGLE_LIST_ENTRY v23; // eax@41
  FILE *v24; // eax@44
  FILE *v25; // eax@51
  int v26; // ecx@55
  int v28; // [sp+14h] [bp-624h]@17
  unsigned int v29; // [sp+18h] [bp-620h]@35
  int v30; // [sp+1Ch] [bp-61Ch]@36
  struct _SINGLE_LIST_ENTRY *v31; // [sp+34h] [bp-604h]@49
  CHAR OutputString; // [sp+38h] [bp-600h]@44
  char DstBuf; // [sp+238h] [bp-400h]@38
  CHAR v34; // [sp+438h] [bp-200h]@51

  *(_DWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 252) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 260) = 0;
  *(_DWORD *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 268) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 276) = 0;
  v1 = a1 + 212;
  v2 = 3;
  do
  {
    v3 = *(_DWORD *)v1;
    if ( *(_DWORD *)v1 )
    {
      if ( v3 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
    }
    v1 += 12;
    --v2;
  }
  while ( v2 );
  if ( *(_BYTE *)(a1 + 208) )
    sub_10041B10(*(_DWORD *)(a1 + 184), a1 + 212);
  v4 = 0;
  if ( *(_DWORD *)(a1 + 204) > 0u )
  {
    v5 = a1 + 224;
    do
    {
      sub_10041B10(*(_DWORD *)(a1 + 184), v5);
      ++v4;
      v5 += 12;
    }
    while ( v4 < *(_DWORD *)(a1 + 204) );
  }
  if ( *(_BYTE *)(a1 + 174) )
  {
    v6 = *(_DWORD *)(a1 + 184);
    v7 = *(_DWORD *)(a1 + 384);
    if ( v6 != v7 )
    {
      if ( v6 >= v7 )
      {
        if ( v6 > *(_DWORD *)(a1 + 388) )
        {
          LOBYTE(v28) = v6 == v7 + 1;
          sub_100943C0(v6, 0, a1 + 380, v6 == v7 + 1, 0x104u, 0);
        }
        v8 = *(_DWORD *)(a1 + 380) + 260 * *(_DWORD *)(a1 + 384);
        for ( i = v8 + 260 * (v6 - *(_DWORD *)(a1 + 384)); v8 != i; v8 += 260 )
        {
          if ( v8 )
          {
            memset((void *)v8, 0, 0x104u);
            *(float *)(v8 + 256) = 1.0;
          }
        }
      }
      *(_DWORD *)(a1 + 384) = v6;
    }
    v10 = *(_DWORD *)(a1 + 184);
    v11 = *(_DWORD *)(a1 + 396);
    if ( v10 != v11 )
    {
      if ( v10 >= v11 )
      {
        if ( v10 > *(_DWORD *)(a1 + 400) )
        {
          LOBYTE(v28) = v10 == v11 + 1;
          sub_100943C0(v10, 0, a1 + 392, v10 == v11 + 1, 0x104u, 0);
        }
        v12 = *(_DWORD *)(a1 + 392) + 260 * *(_DWORD *)(a1 + 396);
        for ( j = v12 + 260 * (v10 - *(_DWORD *)(a1 + 396)); v12 != j; v12 += 260 )
        {
          if ( v12 )
          {
            memset((void *)v12, 0, 0x104u);
            *(float *)(v12 + 256) = 1.0;
          }
        }
      }
      *(_DWORD *)(a1 + 396) = v10;
    }
    v14 = 0;
    if ( *(_DWORD *)(a1 + 184) )
    {
      v15 = 0;
      do
      {
        v16 = v15 + *(_DWORD *)(a1 + 380);
        memset((void *)(v15 + *(_DWORD *)(a1 + 380)), 0, 0x104u);
        *(float *)(v16 + 256) = 1.0;
        v17 = v15 + *(_DWORD *)(a1 + 392);
        memset((void *)(v15 + *(_DWORD *)(a1 + 392)), 0, 0x104u);
        ++v14;
        *(float *)(v17 + 256) = 1.0;
        v15 += 260;
      }
      while ( v14 < *(_DWORD *)(a1 + 184) );
    }
  }
  *(_DWORD *)(a1 + 280) = 0;
  v29 = 0;
  do
  {
    v18 = *(_DWORD *)(a1 + 524);
    v30 = 16;
    v19 = off_100AD9F4(0, 16, &v30, 1, dword_100AE9F4);
    v20 = (struct _SINGLE_LIST_ENTRY *)v19;
    if ( v19 && (unsigned int)v30 >= 0x10 )
    {
      *(_DWORD *)v19 = &off_100A4F34;
      *(_DWORD *)(v19 + 4) = a1;
      *(_DWORD *)(v19 + 8) = sub_10063CB0;
      *(_DWORD *)(v19 + 12) = 1;
      InterlockedIncrement((LPLONG)(v18 + 80));
      v22 = *(_DWORD *)v18;
      if ( *(_BYTE *)(*(_DWORD *)v18 + 16) )
      {
        v23 = InterlockedPopEntrySList((PSLIST_HEADER)(v22 + 8));
        if ( v23 )
          goto LABEL_61;
      }
      v28 = 32;
      v23 = (PSINGLE_LIST_ENTRY)off_100AD9F4(0, 32, &v28, 1, dword_100AE9F4);
      if ( !v23 || (unsigned int)v28 < 0x20 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_malloc: out of memory");
        OutputDebugStringA(&OutputString);
        v24 = _iob_func();
        fputs(&OutputString, v24 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
        v23 = 0;
      }
      if ( v23 )
      {
LABEL_61:
        if ( v23 != (PSINGLE_LIST_ENTRY)-8 )
        {
          v23[2].Next = (struct _SINGLE_LIST_ENTRY *)v29;
          v23[3].Next = 0;
          v23[4].Next = 0;
          v23[5].Next = v20;
          v23[6].Next = (struct _SINGLE_LIST_ENTRY *)1;
          v23[7].Next = v31;
        }
        InterlockedPushEntrySList((PSLIST_HEADER)v22, v23);
        if ( !ReleaseSemaphore(*(HANDLE *)(v18 + 72), 1, 0) )
        {
          sprintf_s(
            &v34,
            0x200u,
            "%s(%u): Failure: \"%s\"\n",
            "crn_threading_win32.cpp",
            198,
            "\"semaphore: ReleaseSemaphore() failed\"");
          OutputDebugStringA(&v34);
          v25 = _iob_func();
          fputs(&v34, v25 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
          if ( !byte_100AE9F8 )
            exit(1);
          RaiseException(0x100u, 0, 0, 0);
        }
      }
      else
      {
        InterlockedIncrement((LPLONG)(v18 + 84));
      }
    }
    else
    {
      sprintf_s(
        &DstBuf,
        0x200u,
        "%s(%u): Assertion failed: \"%s\"\n",
        "crn_mem.cpp",
        216,
        "crnlib_malloc: out of memory");
      OutputDebugStringA(&DstBuf);
      v21 = _iob_func();
      fputs(&DstBuf, v21 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    v26 = *(_DWORD *)(a1 + 524);
    ++v29;
  }
  while ( v29 <= *(_DWORD *)(v26 + 4) );
  sub_10091500(v26);
  return *(_BYTE *)(a1 + 520) == 0;
}
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (10065420) --------------------------------------------------------
void __thiscall sub_10065420(int this, int a2, int a3, int a4)
{
  int v4; // edi@1
  void *v5; // eax@2
  unsigned int v6; // ebx@2
  int v7; // eax@10
  int v8; // esi@12
  unsigned int v9; // eax@12
  unsigned int v10; // ebx@13
  int v11; // ecx@16
  int v12; // eax@16
  bool v13; // zf@16
  char *v14; // edi@16
  unsigned int v15; // edx@17
  _DWORD *v16; // esi@19
  int v17; // edx@21
  unsigned int v18; // ecx@25
  char v19; // dl@31
  unsigned int v20; // ebx@31
  int v21; // eax@38
  int v22; // edx@38
  int v23; // ecx@38
  int v24; // edi@38
  int v25; // eax@38
  size_t v26; // edi@38
  char *v27; // ecx@38
  void *v28; // eax@48
  int v29; // [sp-10h] [bp-200h]@50
  int v30; // [sp-Ch] [bp-1FCh]@50
  int v31; // [sp-4h] [bp-1F4h]@50
  unsigned int v32; // [sp+10h] [bp-1E0h]@15
  int v33; // [sp+10h] [bp-1E0h]@37
  int v34; // [sp+14h] [bp-1DCh]@1
  int v35; // [sp+18h] [bp-1D8h]@2
  void *v36; // [sp+1Ch] [bp-1D4h]@2
  unsigned int v37; // [sp+20h] [bp-1D0h]@2
  unsigned int v38; // [sp+24h] [bp-1CCh]@2
  void *v39; // [sp+28h] [bp-1C8h]@2
  unsigned int v40; // [sp+2Ch] [bp-1C4h]@2
  unsigned int v41; // [sp+30h] [bp-1C0h]@2
  int v42; // [sp+34h] [bp-1BCh]@3
  unsigned int v43; // [sp+38h] [bp-1B8h]@16
  int v44; // [sp+3Ch] [bp-1B4h]@17
  int v45; // [sp+40h] [bp-1B0h]@16
  int v46; // [sp+44h] [bp-1ACh]@12
  int v47; // [sp+48h] [bp-1A8h]@28
  int v48; // [sp+4Ch] [bp-1A4h]@18
  int v49; // [sp+50h] [bp-1A0h]@31
  void *v50; // [sp+54h] [bp-19Ch]@31
  unsigned int v51; // [sp+58h] [bp-198h]@31
  int v52; // [sp+5Ch] [bp-194h]@31
  int v53; // [sp+60h] [bp-190h]@31
  __int16 v54; // [sp+64h] [bp-18Ch]@31
  char v55; // [sp+66h] [bp-18Ah]@31
  int v56; // [sp+67h] [bp-189h]@31
  int v57; // [sp+6Ch] [bp-184h]@31
  int v58; // [sp+70h] [bp-180h]@31
  int v59; // [sp+74h] [bp-17Ch]@31
  int v60; // [sp+78h] [bp-178h]@32
  int v61; // [sp+7Ch] [bp-174h]@37
  unsigned __int16 v62; // [sp+80h] [bp-170h]@37
  unsigned __int16 v63; // [sp+82h] [bp-16Eh]@37
  void *v64; // [sp+84h] [bp-16Ch]@31
  char v65; // [sp+88h] [bp-168h]@37
  int v66; // [sp+90h] [bp-160h]@31
  int v67; // [sp+1ECh] [bp-4h]@2

  v4 = this;
  v34 = this;
  if ( *(_BYTE *)(this + 208) )
  {
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v67 = 0;
    sub_10038B00((int)&v36, 0x200u);
    v5 = 0;
    v39 = 0;
    v40 = 0;
    v41 = 0;
    v6 = 0;
    LOBYTE(v67) = 1;
    v35 = 0;
    if ( *(_DWORD *)(v4 + 288) > 0u )
    {
      v42 = 0;
      while ( !*(_BYTE *)(v4 + 520) )
      {
        if ( GetCurrentThreadId() == *(_DWORD *)(v4 + 512) && 0 == *(_DWORD *)(v4 + 516) && !(v6 & 0x3F) )
        {
          if ( !sub_1005D4D0(v6, *(_DWORD *)(v4 + 288), v34, 3) )
          {
            LOBYTE(v67) = 0;
            if ( v39 )
            {
              if ( (unsigned __int8)v39 & 7 )
                sub_100927E0((int)"crnlib_free: bad ptr");
              else
                off_100AD9F4(v39, 0, 0, 1, dword_100AE9F4);
            }
            v67 = -1;
            v28 = v36;
            if ( !v36 )
              return;
            if ( (unsigned __int8)v36 & 7 )
              goto LABEL_54;
            v31 = dword_100AE9F4;
            v30 = 0;
            v29 = 0;
            goto LABEL_56;
          }
          v6 = v35;
          v4 = v34;
        }
        v7 = *(_DWORD *)(*(_DWORD *)(v4 + 524) + 4);
        if ( !v7 || v6 % (v7 + 1) == a2 )
        {
          v8 = v42 + *(_DWORD *)(v4 + 284);
          v9 = *(_DWORD *)(v8 + 4);
          v46 = v42 + *(_DWORD *)(v4 + 284);
          if ( v9 )
          {
            v10 = v37;
            if ( v37 )
            {
              v37 = 0;
              v10 = 0;
            }
            v32 = 0;
            if ( v9 > 0 )
            {
              do
              {
                v11 = *(_DWORD *)(*(_DWORD *)v8 + 8 * v32);
                v12 = *(_BYTE *)(*(_DWORD *)(v4 + 212)
                               + 660 * *(_DWORD *)(*(_DWORD *)v8 + 8 * v32)
                               + 80 * *(_DWORD *)(*(_DWORD *)v8 + 8 * v32 + 4)
                               + 82);
                v13 = dword_100AD2FC[5 * v12] == 0;
                v14 = (char *)&unk_100AD2F0 + 20 * v12;
                v45 = *(_DWORD *)(*(_DWORD *)v8 + 8 * v32);
                v43 = 0;
                if ( !v13 )
                {
                  do
                  {
                    v15 = 0;
                    v44 = 0;
                    if ( *((_DWORD *)v14 + 2) )
                    {
                      v48 = 65 * v11;
                      do
                      {
                        v16 = (_DWORD *)(*(_DWORD *)(v34 + 188)
                                       + 4
                                       * (v48
                                        + ((v15 + *(_DWORD *)v14) & 3)
                                        + 4
                                        * (((v43 + *((_DWORD *)v14 + 1)) & 3)
                                         + 4 * (((v15 + *(_DWORD *)v14) >> 2) + 2 * ((v43 + *((_DWORD *)v14 + 1)) >> 2)))));
                        if ( v10 >= v38 )
                        {
                          sub_100943C0(v10 + 1, 0, (int)&v36, 1, 4u, 0);
                          v10 = v37;
                        }
                        v17 = v44;
                        *((_DWORD *)v36 + v10) = *v16;
                        v15 = v17 + 1;
                        v37 = ++v10;
                        v44 = v15;
                      }
                      while ( v15 < *((_DWORD *)v14 + 2) );
                      v11 = v45;
                      v8 = v46;
                    }
                    ++v43;
                  }
                  while ( v43 < *((_DWORD *)v14 + 3) );
                }
                v4 = v34;
                ++v32;
              }
              while ( v32 < *(_DWORD *)(v8 + 4) );
            }
            v18 = v40;
            if ( v10 != v40 )
            {
              if ( v10 >= v40 )
              {
                if ( v10 > v41 )
                {
                  LOBYTE(v47) = v10 == v40 + 1;
                  sub_100943C0(v10, 0, (int)&v39, v10 == v40 + 1, 1u, 0);
                  v18 = v40;
                }
                memset((char *)v39 + v18, 0, v10 - v18);
              }
              v40 = v10;
            }
            v19 = *(_BYTE *)(v4 + 173);
            v57 = 1;
            v58 = 1;
            v59 = 1;
            v50 = v36;
            v49 = v35;
            v52 = 128;
            v51 = v10;
            v54 = 0;
            v55 = v19;
            v53 = 4;
            v56 = 0;
            v64 = v39;
            sub_1007DB20((int)&v66);
            v20 = 0;
            LOBYTE(v67) = 2;
            if ( v50
              && sub_10084780((int)&v66, (int)&v49, (int)&v60)
              && *(_BYTE *)(v66 + 21)
              && *(_BYTE *)(v66 + 25)
              && !*(_BYTE *)(v66 + 20) )
            {
              sub_10084890((int)&v66);
            }
            *(_DWORD *)(v8 + 12) = v62;
            *(_DWORD *)(v8 + 16) = v63;
            *(_BYTE *)(v8 + 32) = v65;
            *(_DWORD *)(v8 + 24) = v60;
            *(_DWORD *)(v8 + 28) = v61;
            v33 = 0;
            if ( *(_DWORD *)(v8 + 4) > 0u )
            {
              do
              {
                v21 = *(_DWORD *)(v4 + 212) + 660 * *(_DWORD *)(*(_DWORD *)v8 + 8 * v20);
                v22 = 80 * *(_DWORD *)(*(_DWORD *)v8 + 8 * v20 + 4);
                v23 = *(_BYTE *)(v21 + v22 + 80);
                v24 = *(_BYTE *)(v21 + v22 + 81);
                v25 = v22 + v21;
                v26 = v23 * v24;
                *(_DWORD *)(v25 + 324) = v35;
                *(_DWORD *)(v25 + 328) = v62;
                *(_DWORD *)(v25 + 332) = v63;
                *(_BYTE *)(v25 + 403) = v65;
                *(_BYTE *)(v25 + 400) = *(_BYTE *)(v25 + 80);
                *(_BYTE *)(v25 + 401) = *(_BYTE *)(v25 + 81);
                v27 = (char *)v39 + v33;
                *(_BYTE *)(v25 + 402) = *(_BYTE *)(v25 + 82);
                memcpy((void *)(v25 + 336), v27, v26);
                v33 += v26;
                v4 = v34;
                ++v20;
              }
              while ( v20 < *(_DWORD *)(v8 + 4) );
            }
            LOBYTE(v67) = 1;
            sub_100328F0((int)&v66);
            v6 = v35;
          }
        }
        v42 += 40;
        v5 = v39;
        v35 = ++v6;
        if ( v6 >= *(_DWORD *)(v4 + 288) )
          break;
      }
    }
    LOBYTE(v67) = 0;
    if ( v5 )
    {
      if ( (unsigned __int8)v5 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
    }
    v67 = -1;
    v28 = v36;
    if ( v36 )
    {
      if ( (unsigned __int8)v36 & 7 )
      {
LABEL_54:
        sub_100927E0((int)"crnlib_free: bad ptr");
      }
      else
      {
        v31 = dword_100AE9F4;
        v30 = 0;
        v29 = 0;
LABEL_56:
        off_100AD9F4(v28, v29, v30, 1, v31);
      }
    }
  }
}
// 100AD2FC: using guessed type int dword_100AD2FC[];
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10065970) --------------------------------------------------------
bool __usercall sub_10065970@<al>(int a1@<esi>)
{
  bool result; // al@2
  unsigned int v2; // ebx@3
  int v3; // edi@4
  int v4; // eax@4
  int v5; // [sp+8h] [bp-4h]@4

  if ( *(_BYTE *)(a1 + 208) )
  {
    v2 = 0;
    do
    {
      v3 = *(_DWORD *)(a1 + 524);
      v5 = 16;
      v4 = off_100AD9F4(0, 16, &v5, 1, dword_100AE9F4);
      if ( v4 && (unsigned int)v5 >= 0x10 )
      {
        *(_DWORD *)v4 = &off_100A4F34;
        *(_DWORD *)(v4 + 4) = a1;
        *(_DWORD *)(v4 + 8) = sub_10065420;
        *(_DWORD *)(v4 + 12) = 1;
        sub_100916A0(v4, v3, v2, 0, 0);
      }
      else
      {
        sub_100927E0((int)"crnlib_malloc: out of memory");
      }
      ++v2;
    }
    while ( v2 <= *(_DWORD *)(*(_DWORD *)(a1 + 524) + 4) );
    sub_10091500(*(_DWORD *)(a1 + 524));
    result = *(_BYTE *)(a1 + 520) == 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10065A10) --------------------------------------------------------
bool __userpurge sub_10065A10@<al>(int a1@<ebx>, int a2, const void *a3, int a4)
{
  int v4; // eax@3
  int v5; // eax@5
  int v6; // eax@10
  bool result; // al@26

  if ( !a1 )
    goto LABEL_27;
  if ( !a4 )
    goto LABEL_27;
  v4 = *(_DWORD *)(a2 + 168);
  if ( v4 == 1 || v4 == 2 )
    goto LABEL_27;
  sub_1005F570(a2);
  qmemcpy((void *)a2, a3, 0xB8u);
  *(_DWORD *)(a2 + 188) = a4;
  v5 = *(_DWORD *)(a2 + 168);
  *(_DWORD *)(a2 + 184) = a1;
  switch ( v5 )
  {
    case 0:
      *(_BYTE *)(a2 + 208) = 1;
      break;
    case 3:
      *(_WORD *)(a2 + 208) = 257;
      *(_DWORD *)(a2 + 204) = 1;
      break;
    case 4:
      *(_BYTE *)(a2 + 209) = 1;
      *(_DWORD *)(a2 + 204) = 1;
      break;
    case 5:
    case 6:
      *(_WORD *)(a2 + 209) = 257;
      *(_DWORD *)(a2 + 204) = 2;
      break;
    default:
      goto LABEL_27;
  }
  if ( ((LOBYTE(v6) = sub_10064F30(a2), !*(_BYTE *)(a2 + 208))
     || sub_100630D0(a2) && (LOBYTE(v6) = sub_10065970(a2), (_BYTE)v6))
    && (!*(_DWORD *)(a2 + 204) || sub_100627E0(v6, a2) && sub_10062740(a2))
    && ((sub_1005EE00(a2), !*(_BYTE *)(a2 + 208)) || sub_100616D0(a2, 0))
    && (!*(_DWORD *)(a2 + 204) || sub_100616D0(a2, 1))
    && (!*(_BYTE *)(a2 + 208) || sub_1005DD50(a2) && sub_100609B0(a2))
    && (!*(_DWORD *)(a2 + 204) || sub_10060390(a2) && sub_1005D840(a2)) )
  {
    sub_1005E760(a2);
    result = sub_1005DAE0(a2) != 0;
  }
  else
  {
LABEL_27:
    result = 0;
  }
  return result;
}

//----- (10065C00) --------------------------------------------------------
int __userpurge sub_10065C00@<eax>(int result@<eax>, signed int a2@<edx>, float *a3@<ecx>, float a4)
{
  double v4; // st7@1
  signed int v5; // esi@1
  unsigned int v6; // edx@2
  double v7; // st6@3
  int v8; // ecx@5
  double v9; // st6@6

  v4 = a4;
  v5 = a2;
  if ( a2 >= 4 )
  {
    v6 = ((unsigned int)(a2 - 4) >> 2) + 1;
    v5 -= 4 * v6;
    do
    {
      result += 16;
      v7 = *a3 * v4;
      a3 += 4;
      --v6;
      *(float *)(result - 16) = v7 + *(float *)(result - 16);
      *(float *)(result - 12) = *(a3 - 3) * v4 + *(float *)(result - 12);
      *(float *)(result - 8) = *(a3 - 2) * v4 + *(float *)(result - 8);
      *(float *)(result - 4) = *(a3 - 1) * v4 + *(float *)(result - 4);
    }
    while ( v6 );
  }
  if ( v5 > 0 )
  {
    v8 = (int)a3 - result;
    do
    {
      --v5;
      v9 = *(float *)(v8 + result) * v4;
      result += 4;
      *(float *)(result - 4) = v9 + *(float *)(result - 4);
    }
    while ( v5 > 0 );
  }
  return result;
}

//----- (10065C80) --------------------------------------------------------
float *__userpurge sub_10065C80@<eax>(float *result@<eax>, signed int a2@<edx>, int a3@<ecx>, float a4)
{
  double v4; // st7@1
  signed int v5; // esi@1
  unsigned int v6; // edx@2
  double v7; // st6@3
  int v8; // ecx@5
  double v9; // st6@6

  v4 = a4;
  v5 = a2;
  if ( a2 >= 4 )
  {
    v6 = ((unsigned int)(a2 - 4) >> 2) + 1;
    v5 -= 4 * v6;
    do
    {
      a3 += 16;
      v7 = *result * v4;
      result += 4;
      --v6;
      *(float *)(a3 - 16) = v7;
      *(float *)(a3 - 12) = *(result - 3) * v4;
      *(float *)(a3 - 8) = *(result - 2) * v4;
      *(float *)(a3 - 4) = *(result - 1) * v4;
    }
    while ( v6 );
  }
  if ( v5 > 0 )
  {
    v8 = a3 - (_DWORD)result;
    do
    {
      --v5;
      v9 = *result * v4;
      ++result;
      *(float *)((char *)result + v8 - 4) = v9;
    }
    while ( v5 > 0 );
  }
  return result;
}

//----- (10065CF0) --------------------------------------------------------
int __userpurge sub_10065CF0@<eax>(int result@<eax>, int a2@<ecx>, float *a3)
{
  int v3; // ebx@1
  int i; // edi@1
  signed int v5; // edx@2
  int v6; // eax@2
  unsigned int v7; // esi@3
  int v8; // ebp@4
  float v9; // ST10_4@4
  float v10; // ST10_4@4
  float v11; // ST10_4@4
  int v12; // esi@6
  float v13; // [sp+8h] [bp-4h]@2

  v3 = *(_DWORD *)(result + 36);
  for ( i = *(_DWORD *)(result + 16); i > 0; ++a3 )
  {
    v5 = *(_WORD *)v3;
    v13 = 0.0;
    v6 = *(_DWORD *)(v3 + 4);
    if ( v5 >= 4 )
    {
      v7 = ((unsigned int)(v5 - 4) >> 2) + 1;
      v5 += -4 * v7;
      do
      {
        v8 = *(_WORD *)(v6 + 12);
        v6 += 32;
        --v7;
        v9 = *(float *)(a2 + 4 * *(_WORD *)(v6 - 28)) * *(float *)(v6 - 32) + v13;
        v10 = *(float *)(a2 + 4 * v8) * *(float *)(v6 - 24) + v9;
        v11 = v10 + *(float *)(a2 + 4 * *(_WORD *)(v6 - 12)) * *(float *)(v6 - 16);
        v13 = v11 + *(float *)(a2 + 4 * *(_WORD *)(v6 - 4)) * *(float *)(v6 - 8);
      }
      while ( v7 );
    }
    for ( ; v5 > 0; v13 = *(float *)(a2 + 4 * v12) * *(float *)(v6 - 8) + v13 )
    {
      v12 = *(_WORD *)(v6 + 4);
      --v5;
      v6 += 8;
    }
    *a3 = v13;
    result = (int)(a3 + 1);
    --i;
    v3 += 8;
  }
  return result;
}

//----- (10065E00) --------------------------------------------------------
void __usercall sub_10065E00(signed int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // esi@1
  unsigned int v4; // edi@2
  double v5; // st7@4
  double v6; // st7@9
  double v7; // st7@14
  double v8; // st7@19
  double v9; // st7@26
  float v10; // [sp+4h] [bp-4h]@3
  float v11; // [sp+4h] [bp-4h]@8
  float v12; // [sp+4h] [bp-4h]@13
  float v13; // [sp+4h] [bp-4h]@18
  float v14; // [sp+4h] [bp-4h]@25

  v3 = a1;
  if ( a1 >= 4 )
  {
    v4 = ((unsigned int)(a1 - 4) >> 2) + 1;
    v3 = a1 + -4 * v4;
    do
    {
      v10 = *(float *)a3;
      if ( *(float *)(a2 + 72) <= (double)v10 )
      {
        if ( *(float *)(a2 + 76) >= (double)v10 )
          goto LABEL_8;
        v5 = *(float *)(a2 + 76);
      }
      else
      {
        v5 = *(float *)(a2 + 72);
      }
      v10 = v5;
LABEL_8:
      *(float *)a3 = v10;
      v11 = *(float *)(a3 + 4);
      if ( *(float *)(a2 + 72) <= (double)v11 )
      {
        if ( *(float *)(a2 + 76) >= (double)v11 )
          goto LABEL_13;
        v6 = *(float *)(a2 + 76);
      }
      else
      {
        v6 = *(float *)(a2 + 72);
      }
      v11 = v6;
LABEL_13:
      *(float *)(a3 + 4) = v11;
      v12 = *(float *)(a3 + 8);
      if ( *(float *)(a2 + 72) <= (double)v12 )
      {
        if ( *(float *)(a2 + 76) >= (double)v12 )
          goto LABEL_18;
        v7 = *(float *)(a2 + 76);
      }
      else
      {
        v7 = *(float *)(a2 + 72);
      }
      v12 = v7;
LABEL_18:
      *(float *)(a3 + 8) = v12;
      v13 = *(float *)(a3 + 12);
      if ( *(float *)(a2 + 72) > (double)v13 )
      {
        v8 = *(float *)(a2 + 72);
LABEL_22:
        v13 = v8;
        goto LABEL_23;
      }
      if ( *(float *)(a2 + 76) < (double)v13 )
      {
        v8 = *(float *)(a2 + 76);
        goto LABEL_22;
      }
LABEL_23:
      a3 += 16;
      --v4;
      *(float *)(a3 - 4) = v13;
    }
    while ( v4 );
  }
  if ( v3 > 0 )
  {
    while ( 1 )
    {
      v14 = *(float *)a3;
      if ( *(float *)(a2 + 72) > (double)v14 )
        break;
      if ( *(float *)(a2 + 76) < (double)v14 )
      {
        v9 = *(float *)(a2 + 76);
        goto LABEL_29;
      }
LABEL_30:
      --v3;
      *(float *)a3 = v14;
      a3 += 4;
      if ( v3 <= 0 )
        return;
    }
    v9 = *(float *)(a2 + 72);
LABEL_29:
    v14 = v9;
    goto LABEL_30;
  }
}

//----- (10065FB0) --------------------------------------------------------
void __usercall sub_10065FB0(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // eax@5
  int v3; // eax@10
  int v4; // eax@12
  int v5; // eax@16
  int v6; // eax@21
  int v7; // eax@23
  int v8; // eax@27
  int v9; // eax@32
  int v10; // eax@36
  signed int v11; // edi@41
  int v12; // eax@42
  int v13; // eax@47

  v1 = *(_DWORD *)(a1 + 28);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
  v2 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 28) = 0;
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 32) = 0;
  }
  v3 = *(_DWORD *)(a1 + 36);
  if ( v3 && !*(_BYTE *)(a1 + 44) )
  {
    v4 = *(_DWORD *)(v3 + 4);
    if ( v4 )
    {
      if ( v4 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
    }
    v5 = *(_DWORD *)(a1 + 36);
    if ( v5 )
    {
      if ( v5 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 36) = 0;
  }
  v6 = *(_DWORD *)(a1 + 40);
  if ( v6 && !*(_BYTE *)(a1 + 45) )
  {
    v7 = *(_DWORD *)(v6 + 4);
    if ( v7 )
    {
      if ( v7 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v7, 0, 0, 1, dword_100AE9F4);
    }
    v8 = *(_DWORD *)(a1 + 40);
    if ( v8 )
    {
      if ( v8 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v8, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 40) = 0;
  }
  v9 = *(_DWORD *)(a1 + 48);
  if ( v9 )
  {
    if ( v9 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v9, 0, 0, 1, dword_100AE9F4);
  }
  v10 = *(_DWORD *)(a1 + 52);
  *(_DWORD *)(a1 + 48) = 0;
  if ( v10 )
  {
    if ( v10 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v10, 0, 0, 1, dword_100AE9F4);
  }
  *(_DWORD *)(a1 + 52) = 0;
  if ( *(_DWORD *)(a1 + 56) )
  {
    v11 = 0x10000;
    do
    {
      v12 = *(_DWORD *)(v11 + *(_DWORD *)(a1 + 56));
      if ( v12 )
      {
        if ( v12 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v12, 0, 0, 1, dword_100AE9F4);
      }
      v11 += 4;
    }
    while ( v11 < 0x20000 );
    v13 = *(_DWORD *)(a1 + 56);
    if ( v13 )
    {
      if ( v13 & 7 )
      {
        sub_100927E0((int)"crnlib_free: bad ptr");
        *(_DWORD *)(a1 + 56) = 0;
        return;
      }
      off_100AD9F4(v13, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 56) = 0;
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100661C0) --------------------------------------------------------
char __usercall sub_100661C0@<al>(const void *a1@<ebx>, int a2@<esi>)
{
  int v2; // edx@1
  char result; // al@2
  signed int v4; // edi@5
  int v5; // eax@5
  int v6; // eax@18

  v2 = *(_DWORD *)(a2 + 60);
  if ( v2 < *(_DWORD *)(a2 + 12) )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a2 + 48) + 4 * v2) )
    {
      v4 = 0;
      v5 = *(_DWORD *)(a2 + 56) + 8;
      while ( *(_DWORD *)(v5 - 8) != -1 )
      {
        if ( *(_DWORD *)(v5 - 4) == -1 )
        {
          ++v4;
          break;
        }
        if ( *(_DWORD *)v5 == -1 )
        {
          v4 += 2;
          break;
        }
        if ( *(_DWORD *)(v5 + 4) == -1 )
        {
          v4 += 3;
          break;
        }
        v4 += 4;
        v5 += 16;
        if ( v4 >= 0x4000 )
          break;
      }
      if ( v4 == 0x4000 )
      {
        *(_DWORD *)(a2 + 68) = 3;
        result = 0;
      }
      else
      {
        *(_BYTE *)(v2 + *(_DWORD *)(a2 + 52)) = 1;
        *(_DWORD *)(*(_DWORD *)(a2 + 56) + 4 * v4) = *(_DWORD *)(a2 + 60);
        if ( *(_DWORD *)(*(_DWORD *)(a2 + 56) + 4 * v4 + 0x10000)
          || (v6 = sub_10092A80(4 * *(_DWORD *)(a2 + 4)),
              (*(_DWORD *)(*(_DWORD *)(a2 + 56) + 4 * v4 + 0x10000) = v6) != 0) )
        {
          if ( *(_BYTE *)(a2 + 46) )
          {
            memcpy(*(void **)(*(_DWORD *)(a2 + 56) + 4 * v4 + 0x10000), a1, 4 * *(_DWORD *)(a2 + 4));
            ++*(_DWORD *)(a2 + 60);
            result = 1;
          }
          else
          {
            sub_10065CF0(a2, (int)a1, *(float **)(*(_DWORD *)(a2 + 56) + 4 * v4 + 0x10000));
            ++*(_DWORD *)(a2 + 60);
            result = 1;
          }
        }
        else
        {
          *(_DWORD *)(a2 + 68) = 1;
          result = 0;
        }
      }
    }
    else
    {
      *(_DWORD *)(a2 + 60) = v2 + 1;
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100663E0) --------------------------------------------------------
int __usercall sub_100663E0@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int result; // eax@2
  int v3; // ebp@3
  signed int v4; // ecx@3
  _WORD *v5; // eax@4
  float *v6; // edi@7
  signed int v7; // ebx@11
  float *v8; // edx@12
  int v9; // ecx@12
  signed int v10; // edi@12
  int v11; // eax@12
  float *v12; // eax@22
  int v13; // edx@25
  int v14; // eax@25
  int v15; // [sp+10h] [bp-8h]@8
  float *v16; // [sp+14h] [bp-4h]@7

  v1 = *(_DWORD *)(a1 + 64);
  if ( v1 == *(_DWORD *)(a1 + 20) )
  {
    result = 0;
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 40) + 8 * v1;
    v4 = 0;
    if ( *(_WORD *)v3 <= 0u )
    {
LABEL_7:
      v6 = *(float **)(a1 + 28);
      v16 = *(float **)(a1 + 28);
      if ( *(_BYTE *)(a1 + 46) )
        v15 = *(_DWORD *)(a1 + 32);
      else
        v15 = *(_DWORD *)(a1 + 28);
      v7 = 0;
      if ( *(_WORD *)v3 > 0u )
      {
        do
        {
          v8 = *(float **)(v3 + 4);
          v9 = LOWORD(v8[2 * v7 + 1]);
          v10 = 0;
          v11 = *(_DWORD *)(a1 + 56) + 8;
          while ( *(_DWORD *)(v11 - 8) != v9 )
          {
            if ( *(_DWORD *)(v11 - 4) == v9 )
            {
              ++v10;
              break;
            }
            if ( *(_DWORD *)v11 == v9 )
            {
              v10 += 2;
              break;
            }
            if ( *(_DWORD *)(v11 + 4) == v9 )
            {
              v10 += 3;
              break;
            }
            v10 += 4;
            v11 += 16;
            if ( v10 >= 0x4000 )
              break;
          }
          v12 = *(float **)(*(_DWORD *)(a1 + 56) + 4 * v10 + 0x10000);
          if ( v7 )
            sub_10065C00(v15, *(_DWORD *)(a1 + 4), v12, v8[2 * v7]);
          else
            sub_10065C80(v12, *(_DWORD *)(a1 + 4), v15, *v8);
          v13 = *(_WORD *)(*(_DWORD *)(v3 + 4) + 8 * v7 + 4);
          v14 = *(_DWORD *)(a1 + 48);
          if ( !--*(_DWORD *)(v14 + 4 * v13) )
          {
            *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v3 + 4) + 8 * v7 + 4) + *(_DWORD *)(a1 + 52)) = 0;
            *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4 * v10) = -1;
          }
          ++v7;
        }
        while ( v7 < *(_WORD *)v3 );
        v6 = v16;
      }
      if ( *(_BYTE *)(a1 + 46) )
        sub_10065CF0(a1, v15, v6);
      if ( *(float *)(a1 + 76) > (double)*(float *)(a1 + 72) )
        sub_10065E00(*(_DWORD *)(a1 + 16), a1, (int)v6);
      ++*(_DWORD *)(a1 + 64);
      result = *(_DWORD *)(a1 + 28);
    }
    else
    {
      v5 = (_WORD *)(*(_DWORD *)(v3 + 4) + 4);
      while ( *(_BYTE *)(*v5 + *(_DWORD *)(a1 + 52)) )
      {
        ++v4;
        v5 += 4;
        if ( v4 >= *(_WORD *)(*(_DWORD *)(a1 + 40) + 8 * *(_DWORD *)(a1 + 64)) )
          goto LABEL_7;
      }
      result = 0;
    }
  }
  return result;
}

//----- (10066550) --------------------------------------------------------
void *__cdecl sub_10066550(int a1, int a2, int a3, int a4, float a5, float a6, float a7)
{
  unsigned int v7; // esi@1
  void *v8; // eax@3
  void *v9; // ebx@3
  void *result; // eax@5
  unsigned int v11; // esi@8
  void *v12; // eax@10
  const char *v13; // eax@12
  double v14; // st7@17
  int v15; // ebx@17
  int v16; // ebp@17
  double v17; // st5@17
  double v18; // st6@18
  double v19; // st7@18
  char *v20; // esi@19
  signed int v21; // edi@21
  signed int v22; // eax@21
  double v23; // st7@21
  size_t v24; // ebp@23
  void *v25; // esi@23
  void *v26; // eax@25
  int v27; // edi@25
  double v28; // st7@30
  int v29; // edi@30
  signed int v30; // esi@31
  float v31; // eax@31
  _DWORD *v32; // ebx@31
  int v33; // ecx@31
  signed int v34; // ebp@31
  float v35; // ST28_4@36
  int v36; // edx@39
  int v37; // ecx@51
  float *v38; // eax@58
  void (*v39)(char *, size_t, const char *, ...); // esi@62
  void (__cdecl *v40)(const char *, FILE *); // edi@62
  FILE *(__cdecl *v41)(); // ebp@62
  void (__stdcall *v42)(LPCSTR); // ebx@62
  FILE *v43; // eax@63
  void *v44; // eax@66
  FILE *v45; // eax@67
  void *v46; // eax@70
  FILE *v47; // eax@71
  double v48; // st6@79
  double v49; // st7@79
  char *v50; // esi@80
  signed int v51; // edi@82
  signed int v52; // eax@82
  double v53; // st7@82
  size_t v54; // ebp@84
  void *v55; // esi@84
  void *v56; // eax@86
  int v57; // edi@86
  double v58; // st7@91
  int v59; // edi@91
  signed int v60; // esi@92
  float v61; // eax@92
  _DWORD *v62; // ebx@92
  int v63; // ecx@92
  signed int v64; // ebp@92
  double v65; // st7@93
  double v66; // st7@97
  int v67; // edx@100
  float v68; // ecx@112
  float *v69; // eax@119
  FILE *v70; // eax@123
  FILE *v71; // eax@127
  void *v72; // [sp-Ch] [bp-46Ch]@14
  int v73; // [sp+4h] [bp-45Ch]@14
  signed int v74; // [sp+18h] [bp-448h]@17
  signed int v75; // [sp+18h] [bp-448h]@31
  signed int v76; // [sp+18h] [bp-448h]@34
  float v77; // [sp+18h] [bp-448h]@36
  signed int v78; // [sp+18h] [bp-448h]@92
  signed int v79; // [sp+18h] [bp-448h]@95
  float v80; // [sp+18h] [bp-448h]@97
  void *v81; // [sp+1Ch] [bp-444h]@21
  float v82; // [sp+20h] [bp-440h]@34
  float v83; // [sp+24h] [bp-43Ch]@31
  float v84; // [sp+28h] [bp-438h]@18
  float v85; // [sp+2Ch] [bp-434h]@21
  int v86; // [sp+30h] [bp-430h]@32
  char *v87; // [sp+34h] [bp-42Ch]@19
  void *v88; // [sp+38h] [bp-428h]@10
  void *v89; // [sp+3Ch] [bp-424h]@3
  float v90; // [sp+40h] [bp-420h]@17
  int v91; // [sp+44h] [bp-41Ch]@30
  float v92; // [sp+48h] [bp-418h]@31
  float v93; // [sp+4Ch] [bp-414h]@31
  void *v94; // [sp+50h] [bp-410h]@25
  float v95; // [sp+54h] [bp-40Ch]@17
  int v96; // [sp+58h] [bp-408h]@3
  int v97; // [sp+5Ch] [bp-404h]@10
  CHAR OutputString; // [sp+60h] [bp-400h]@67
  char DstBuf; // [sp+260h] [bp-200h]@63

  v7 = (8 * a2 + 3) & 0xFFFFFFFC;
  if ( v7 )
  {
    if ( v7 > 0x7FFF0000 )
    {
      sub_100927E0((int)"crnlib_malloc: size too big");
      return 0;
    }
  }
  else
  {
    v7 = 4;
  }
  v96 = v7;
  v8 = (void *)off_100AD9F4(0, v7, &v96, 1, dword_100AE9F4);
  v9 = v8;
  v89 = v8;
  if ( !v8 || v96 < v7 )
  {
    sub_100927E0((int)"crnlib_malloc: out of memory");
    return 0;
  }
  memset(v8, 0, 8 * a2);
  v11 = (12 * a2 + 3) & 0xFFFFFFFC;
  if ( v11 )
  {
    if ( v11 > 0x7FFF0000 )
    {
      v13 = "crnlib_malloc: size too big";
LABEL_13:
      sub_100927E0((int)v13);
      if ( !((unsigned __int8)v9 & 7) )
      {
        v73 = dword_100AE9F4;
        v72 = v9;
LABEL_136:
        off_100AD9F4(v72, 0, 0, 1, v73);
        return 0;
      }
LABEL_78:
      sub_100927E0((int)"crnlib_free: bad ptr");
      return 0;
    }
  }
  else
  {
    v11 = 4;
  }
  v97 = v11;
  v12 = (void *)off_100AD9F4(0, v11, &v97, 1, dword_100AE9F4);
  v88 = v12;
  if ( !v12 || v97 < v11 )
  {
    v13 = "crnlib_malloc: out of memory";
    goto LABEL_13;
  }
  memset(v12, 0, 12 * a2);
  v14 = a6;
  v15 = 0;
  v16 = 0;
  v74 = 0;
  v95 = 1.0 / a6;
  v90 = (double)a2 / (double)a1;
  v17 = a5;
  if ( v90 < 1.0 )
  {
    v18 = v14 * (v17 / v90);
    v19 = v90;
    v84 = v18;
    if ( a2 <= 0 )
      goto LABEL_74;
    v20 = (char *)v88 + 8;
    v87 = (char *)v88 + 8;
    while ( 1 )
    {
      *(float *)&v81 = ((double)v74 + 0.5) / v19;
      *(float *)&v81 = *(float *)&v81 - 0.5;
      v85 = *(float *)&v81 + a7;
      *(float *)&v81 = v85 - v84;
      *(float *)&v81 = floor(*(float *)&v81);
      v21 = (signed int)*(float *)&v81;
      *(float *)&v81 = v85 + v84;
      *(float *)&v81 = ceil(*(float *)&v81);
      v22 = (signed int)*(float *)&v81;
      v23 = v85;
      *(_DWORD *)v20 = v22;
      *((float *)v20 - 2) = v23;
      ++v15;
      *((_DWORD *)v20 - 1) = v21;
      v20 += 12;
      v16 += v22 - v21 + 1;
      v74 = v15;
      if ( v15 >= a2 )
        break;
      v19 = v90;
    }
    if ( !v16 )
      goto LABEL_74;
    v24 = 8 * v16;
    v25 = (void *)((v24 + 3) & 0xFFFFFFFC);
    if ( v25 )
    {
      if ( (unsigned int)v25 > 0x7FFF0000 )
      {
        sub_100927E0((int)"crnlib_malloc: size too big");
LABEL_74:
        if ( (unsigned __int8)v89 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v89, 0, 0, 1, dword_100AE9F4);
        v46 = v88;
        if ( (unsigned __int8)v88 & 7 )
          goto LABEL_78;
        goto LABEL_73;
      }
    }
    else
    {
      v25 = (void *)4;
    }
    v94 = v25;
    *(float *)&v26 = COERCE_FLOAT(off_100AD9F4(0, v25, &v94, 1, dword_100AE9F4));
    v27 = (int)v26;
    v81 = v26;
    if ( *(float *)&v26 == 0.0 || v94 < v25 )
    {
      sub_100927E0((int)"crnlib_malloc: out of memory");
      goto LABEL_74;
    }
    memset(v26, 0, v24);
    v28 = 0.0;
    v91 = v27;
    v29 = 0;
LABEL_31:
    v30 = *((_DWORD *)v87 - 1);
    v93 = -1.0e20;
    v31 = *(float *)v87;
    v32 = v89;
    v85 = *((float *)v87 - 2);
    v33 = v91;
    v83 = v28;
    *((_WORD *)v89 + 4 * v29) = 0;
    v32[2 * v29 + 1] = v33;
    v92 = -6.8056469e38/*NaN*/;
    v84 = v31;
    v91 = v33 + 8 * (LODWORD(v31) - v30) + 8;
    v34 = v30;
    v75 = v30;
    if ( v30 <= SLODWORD(v31) )
    {
      do
      {
        *(float *)&v86 = (v85 - (double)v75) * v90 * v95;
        ((void (__cdecl *)(int))a4)(v86);
        v75 = ++v34;
        v83 = *(float *)&v86 + v83;
      }
      while ( v34 <= SLODWORD(v84) );
      v28 = 0.0;
    }
    v76 = v30;
    v82 = 1.0 / v83;
    v83 = v28;
    if ( v30 > SLODWORD(v84) )
    {
LABEL_62:
      v39 = (void (*)(char *, size_t, const char *, ...))sprintf_s;
      v40 = (void (__cdecl *)(const char *, FILE *))fputs;
      v41 = _iob_func;
      v42 = OutputDebugStringA;
      if ( (unsigned __int8)v81 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v43 = _iob_func();
        fputs(&DstBuf, v43 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v81, 0, 0, 1, dword_100AE9F4);
      }
      v44 = v89;
      if ( (unsigned __int8)v89 & 7 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_free: bad ptr");
        OutputDebugStringA(&OutputString);
        v45 = _iob_func();
        fputs(&OutputString, v45 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
        goto LABEL_70;
      }
LABEL_69:
      off_100AD9F4(v44, 0, 0, 1, dword_100AE9F4);
      goto LABEL_70;
    }
    v86 = -v30;
    while ( 1 )
    {
      v35 = (v85 - (double)v76) * v90 * v95;
      ((void (__cdecl *)(_DWORD))a4)(LODWORD(v35));
      v77 = v35 * v82;
      if ( 0.0 != v77 )
        break;
      v28 = 0.0;
LABEL_54:
      --v86;
      v76 = ++v30;
      if ( v30 > SLODWORD(v84) )
      {
        if ( v92 == -6.8056469e38/*NaN*/ || !LOWORD(v32[2 * v29]) )
          goto LABEL_62;
        if ( 1.0 != v83 )
        {
          v38 = (float *)(v32[2 * v29 + 1] + 8 * LODWORD(v92));
          *v38 = 1.0 - v83 + *v38;
        }
        v87 += 12;
        if ( ++v29 >= a2 )
          goto LABEL_60;
        goto LABEL_31;
      }
    }
    if ( v30 < 0 )
    {
      if ( a3 == 1 )
      {
        LOWORD(v36) = v86;
        if ( v86 < a1 )
          goto LABEL_51;
        goto LABEL_40;
      }
      if ( !a3 )
      {
        v36 = v86 % a1;
        if ( v86 % a1 )
          LOWORD(v36) = a1 - v36;
        goto LABEL_51;
      }
LABEL_47:
      LOWORD(v36) = 0;
      goto LABEL_51;
    }
    if ( v30 < a1 )
    {
      LOWORD(v36) = v30;
    }
    else
    {
      if ( a3 == 1 )
      {
        v36 = 2 * a1 - v30 - 1;
        if ( v36 >= 0 )
          goto LABEL_51;
        goto LABEL_47;
      }
      if ( a3 )
      {
LABEL_40:
        LOWORD(v36) = a1 - 1;
        goto LABEL_51;
      }
      v36 = v30 % a1;
    }
LABEL_51:
    v28 = 0.0;
    v37 = LOWORD(v32[2 * v29]);
    LOWORD(v32[2 * v29]) = v37 + 1;
    *(_WORD *)(v32[2 * v29 + 1] + 8 * v37 + 4) = v36;
    *(float *)(v32[2 * v29 + 1] + 8 * v37) = v77;
    v83 = v77 + v83;
    if ( v93 < (double)v77 )
    {
      v93 = v77;
      v92 = *(float *)&v37;
    }
    goto LABEL_54;
  }
  v48 = v14 * v17;
  v49 = v90;
  v84 = v48;
  if ( a2 <= 0 )
    goto LABEL_130;
  v50 = (char *)v88 + 8;
  v87 = (char *)v88 + 8;
  while ( 1 )
  {
    v82 = ((double)v74 + 0.5) / v49;
    v82 = v82 - 0.5;
    v85 = v82 + a7;
    v82 = v85 - v84;
    v82 = floor(v82);
    v51 = (signed int)v82;
    v82 = v85 + v84;
    v82 = ceil(v82);
    v52 = (signed int)v82;
    v53 = v85;
    *(_DWORD *)v50 = v52;
    *((float *)v50 - 2) = v53;
    ++v15;
    *((_DWORD *)v50 - 1) = v51;
    v50 += 12;
    v16 += v52 - v51 + 1;
    v74 = v15;
    if ( v15 >= a2 )
      break;
    v49 = v90;
  }
  if ( !v16 )
  {
LABEL_130:
    if ( (unsigned __int8)v89 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v89, 0, 0, 1, dword_100AE9F4);
    v46 = v88;
    if ( (unsigned __int8)v88 & 7 )
      goto LABEL_78;
    v73 = dword_100AE9F4;
LABEL_135:
    v72 = v46;
    goto LABEL_136;
  }
  v54 = 8 * v16;
  v55 = (void *)((v54 + 3) & 0xFFFFFFFC);
  if ( *(float *)&v55 == 0.0 )
  {
    v55 = (void *)4;
  }
  else if ( (unsigned int)v55 > 0x7FFF0000 )
  {
    sub_100927E0((int)"crnlib_malloc: size too big");
    goto LABEL_130;
  }
  v81 = v55;
  v56 = (void *)off_100AD9F4(0, v55, &v81, 1, dword_100AE9F4);
  v57 = (int)v56;
  v94 = v56;
  if ( !v56 || v81 < v55 )
  {
    sub_100927E0((int)"crnlib_malloc: out of memory");
    goto LABEL_130;
  }
  memset(v56, 0, v54);
  v58 = 0.0;
  v91 = v57;
  v59 = 0;
  do
  {
    v60 = *((_DWORD *)v87 - 1);
    v92 = -1.0e20;
    v61 = *(float *)v87;
    v62 = v89;
    v85 = *((float *)v87 - 2);
    *((_WORD *)v89 + 4 * v59) = 0;
    v83 = v58;
    v63 = v91;
    v62[2 * v59 + 1] = v91;
    v93 = -6.8056469e38/*NaN*/;
    v84 = v61;
    v91 = v63 + 8 * (LODWORD(v61) - v60) + 8;
    v64 = v60;
    v78 = v60;
    if ( v60 <= SLODWORD(v61) )
    {
      do
      {
        v82 = (v85 - (double)v78) * v95;
        v65 = v82;
        ((void (__cdecl *)(_DWORD))a4)(LODWORD(v82));
        v78 = ++v64;
        v83 = v65 + v83;
      }
      while ( v64 <= SLODWORD(v84) );
      v58 = 0.0;
    }
    v79 = v60;
    v90 = 1.0 / v83;
    v83 = v58;
    if ( v60 > SLODWORD(v84) )
    {
LABEL_122:
      v39 = (void (*)(char *, size_t, const char *, ...))sprintf_s;
      v40 = (void (__cdecl *)(const char *, FILE *))fputs;
      v41 = _iob_func;
      v42 = OutputDebugStringA;
      if ( (unsigned __int8)v94 & 7 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_free: bad ptr");
        OutputDebugStringA(&OutputString);
        v70 = _iob_func();
        fputs(&OutputString, v70 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v94, 0, 0, 1, dword_100AE9F4);
      }
      v44 = v89;
      if ( !((unsigned __int8)v89 & 7) )
        goto LABEL_69;
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v71 = _iob_func();
      fputs(&DstBuf, v71 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
LABEL_70:
      v46 = v88;
      if ( (unsigned __int8)v88 & 7 )
      {
        v39(&OutputString, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        v42(&OutputString);
        v47 = v41();
        v40(&OutputString, v47 + 2);
        if ( IsDebuggerPresent() )
        {
          DebugBreak();
          return 0;
        }
        return 0;
      }
LABEL_73:
      v73 = dword_100AE9F4;
      goto LABEL_135;
    }
    v86 = -v60;
    do
    {
      v82 = (v85 - (double)v79) * v95;
      v66 = v82;
      ((void (__cdecl *)(_DWORD))a4)(LODWORD(v82));
      v80 = v66 * v90;
      if ( 0.0 == v80 )
      {
        v58 = 0.0;
        goto LABEL_115;
      }
      if ( v60 < 0 )
      {
        if ( a3 == 1 )
        {
          LOWORD(v67) = v86;
          if ( v86 < a1 )
            goto LABEL_112;
LABEL_101:
          LOWORD(v67) = a1 - 1;
          goto LABEL_112;
        }
        if ( !a3 )
        {
          v67 = v86 % a1;
          if ( v86 % a1 )
            LOWORD(v67) = a1 - v67;
          goto LABEL_112;
        }
LABEL_108:
        LOWORD(v67) = 0;
        goto LABEL_112;
      }
      if ( v60 < a1 )
      {
        LOWORD(v67) = v60;
      }
      else
      {
        if ( a3 == 1 )
        {
          v67 = 2 * a1 - v60 - 1;
          if ( v67 >= 0 )
            goto LABEL_112;
          goto LABEL_108;
        }
        if ( a3 )
          goto LABEL_101;
        v67 = v60 % a1;
      }
LABEL_112:
      v58 = 0.0;
      LODWORD(v68) = LOWORD(v62[2 * v59]);
      LOWORD(v62[2 * v59]) = LOWORD(v68) + 1;
      *(_WORD *)(v62[2 * v59 + 1] + 8 * LODWORD(v68) + 4) = v67;
      *(float *)(v62[2 * v59 + 1] + 8 * LODWORD(v68)) = v80;
      v83 = v80 + v83;
      if ( v92 < (double)v80 )
      {
        v92 = v80;
        v93 = v68;
      }
LABEL_115:
      --v86;
      v79 = ++v60;
    }
    while ( v60 <= SLODWORD(v84) );
    if ( v93 == -6.8056469e38/*NaN*/ || !LOWORD(v62[2 * v59]) )
      goto LABEL_122;
    if ( 1.0 != v83 )
    {
      v69 = (float *)(v62[2 * v59 + 1] + 8 * LODWORD(v93));
      *v69 = 1.0 - v83 + *v69;
    }
    v87 += 12;
    ++v59;
  }
  while ( v59 < a2 );
LABEL_60:
  if ( (unsigned __int8)v88 & 7 )
  {
    sub_100927E0((int)"crnlib_free: bad ptr");
    result = v89;
  }
  else
  {
    off_100AD9F4(v88, 0, 0, 1, dword_100AE9F4);
    result = v89;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100670C0) --------------------------------------------------------
int __userpurge sub_100670C0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<esi>, int a5, int a6, int a7, float a8, int a9, int a10, int a11, float a12, float a13, float a14, float a15)
{
  double v15; // st7@1
  int v16; // ebp@1
  int v17; // eax@1
  int v18; // ebx@4
  const char *v19; // edi@4
  int v21; // edi@9
  void *v22; // eax@10
  void *v23; // eax@14
  size_t v24; // ebx@17
  unsigned int v25; // edi@17
  void *v26; // eax@19
  void *v27; // edi@21
  size_t v28; // ebx@23
  unsigned int v29; // edi@23
  void *v30; // eax@25
  void *v31; // edi@27
  int i; // ecx@29
  signed int v33; // eax@30
  int v34; // edx@31
  int v35; // eax@33
  signed int v36; // eax@37
  int v37; // ebx@39
  _WORD *v38; // eax@40
  int v39; // ecx@40
  int v40; // edi@42
  _WORD *v41; // eax@43
  int v42; // ecx@43
  int v43; // ecx@45
  int v44; // eax@45
  int v45; // eax@48
  bool v46; // zf@56
  unsigned int v47; // edi@57
  int v48; // eax@59
  const char *v49; // eax@61

  v15 = *(float *)&a7;
  *(_DWORD *)(a4 + 16) = a1;
  *(float *)(a4 + 72) = v15;
  v16 = 0;
  *(float *)(a4 + 76) = a8;
  *(_DWORD *)(a4 + 8) = a3;
  *(_DWORD *)(a4 + 12) = a2;
  *(_BYTE *)(a4 + 46) = 0;
  *(_DWORD *)(a4 + 4) = 0;
  *(_DWORD *)(a4 + 28) = 0;
  *(_DWORD *)(a4 + 32) = 0;
  *(_DWORD *)(a4 + 36) = 0;
  *(_WORD *)(a4 + 44) = 0;
  *(_DWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 48) = 0;
  *(_DWORD *)(a4 + 52) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_DWORD *)(a4 + 68) = 0;
  *(_DWORD *)(a4 + 20) = a5;
  *(_DWORD *)(a4 + 24) = a6;
  v17 = sub_10092A80(4 * a1);
  *(_DWORD *)(a4 + 28) = v17;
  if ( !v17 )
    goto LABEL_64;
  if ( *(float *)&a9 == 0.0 )
    *(float *)&a9 = COERCE_FLOAT("lanczos4");
  v18 = 0;
  v19 = "box";
  do
  {
    if ( !strcmp((const char *)a9, v19) )
      break;
    v19 += 40;
    ++v18;
  }
  while ( (signed int)v19 < (signed int)byte_10099BA8 );
  if ( v18 == 16 )
  {
    *(_DWORD *)(a4 + 68) = 2;
    return a4;
  }
  v21 = *(&off_10099948 + 10 * v18);
  a9 = SLODWORD(flt_1009994C[10 * v18]);
  if ( a10 )
  {
    *(_DWORD *)(a4 + 36) = a10;
    *(_BYTE *)(a4 + 44) = 1;
  }
  else
  {
    v22 = sub_10066550(*(_DWORD *)(a4 + 8), *(_DWORD *)(a4 + 16), *(_DWORD *)(a4 + 24), v21, *(float *)&a9, a12, a14);
    *(_DWORD *)(a4 + 36) = v22;
    if ( !v22 )
    {
      *(_DWORD *)(a4 + 68) = 1;
      return a4;
    }
  }
  if ( a11 )
  {
    *(_DWORD *)(a4 + 40) = a11;
    *(_BYTE *)(a4 + 45) = 1;
  }
  else
  {
    v23 = sub_10066550(*(_DWORD *)(a4 + 12), *(_DWORD *)(a4 + 20), *(_DWORD *)(a4 + 24), v21, *(float *)&a9, a13, a15);
    *(_DWORD *)(a4 + 40) = v23;
    if ( !v23 )
    {
      *(_DWORD *)(a4 + 68) = 1;
      return a4;
    }
  }
  v24 = 4 * *(_DWORD *)(a4 + 12);
  v25 = (v24 + 3) & 0xFFFFFFFC;
  if ( v25 )
  {
    if ( v25 > 0x7FFF0000 )
    {
      sub_100927E0((int)"crnlib_malloc: size too big");
      v27 = 0;
      goto LABEL_22;
    }
  }
  else
  {
    v25 = 4;
  }
  a9 = v25;
  v26 = (void *)off_100AD9F4(0, v25, &a9, 1, dword_100AE9F4);
  if ( v26 && a9 >= v25 )
  {
    v27 = v26;
    memset(v26, 0, v24);
  }
  else
  {
    sub_100927E0((int)"crnlib_malloc: out of memory");
    v27 = 0;
  }
LABEL_22:
  *(_DWORD *)(a4 + 48) = v27;
  if ( !v27 )
  {
LABEL_64:
    *(_DWORD *)(a4 + 68) = 1;
    return a4;
  }
  v28 = *(_DWORD *)(a4 + 12);
  v29 = (v28 + 3) & 0xFFFFFFFC;
  if ( !v29 )
  {
    v29 = 4;
LABEL_25:
    a7 = v29;
    v30 = (void *)off_100AD9F4(0, v29, &a7, 1, dword_100AE9F4);
    if ( v30 && a7 >= v29 )
    {
      v31 = v30;
      memset(v30, 0, v28);
    }
    else
    {
      sub_100927E0((int)"crnlib_malloc: out of memory");
      v31 = 0;
    }
    goto LABEL_28;
  }
  if ( v29 <= 0x7FFF0000 )
    goto LABEL_25;
  sub_100927E0((int)"crnlib_malloc: size too big");
  v31 = 0;
LABEL_28:
  *(_DWORD *)(a4 + 52) = v31;
  if ( !v31 )
    goto LABEL_64;
  for ( i = 0; i < *(_DWORD *)(a4 + 20); ++i )
  {
    v33 = 0;
    if ( *(_WORD *)(*(_DWORD *)(a4 + 40) + 8 * i) > 0u )
    {
      do
      {
        v34 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a4 + 40) + 8 * i + 4) + 8 * v33 + 4);
        ++*(_DWORD *)(*(_DWORD *)(a4 + 48) + 4 * v34);
        ++v33;
      }
      while ( v33 < *(_WORD *)(*(_DWORD *)(a4 + 40) + 8 * i) );
    }
  }
  a9 = 0x20000;
  v35 = off_100AD9F4(0, 0x20000, &a9, 1, dword_100AE9F4);
  if ( !v35 || (unsigned int)a9 < 0x20000 )
  {
    sub_100927E0((int)"crnlib_malloc: out of memory");
    v35 = 0;
  }
  *(_DWORD *)(a4 + 56) = v35;
  if ( !v35 )
    goto LABEL_64;
  v36 = 0;
  do
  {
    *(_DWORD *)(v36 + *(_DWORD *)(a4 + 56)) = -1;
    *(_DWORD *)(v36 + *(_DWORD *)(a4 + 56) + 0x10000) = 0;
    v36 += 4;
  }
  while ( v36 < 0x10000 );
  v37 = 0;
  *(_DWORD *)(a4 + 64) = 0;
  *(_DWORD *)(a4 + 60) = 0;
  if ( *(_DWORD *)(a4 + 16) > 0 )
  {
    v38 = *(_WORD **)(a4 + 36);
    v39 = *(_DWORD *)(a4 + 16);
    do
    {
      v37 += *v38;
      v38 += 4;
      --v39;
    }
    while ( v39 );
  }
  v40 = *(_DWORD *)(a4 + 20);
  if ( v40 > 0 )
  {
    v41 = *(_WORD **)(a4 + 40);
    v42 = *(_DWORD *)(a4 + 20);
    do
    {
      v16 += *v41;
      v41 += 4;
      --v42;
    }
    while ( v42 );
  }
  v43 = v37 * *(_DWORD *)(a4 + 12) + 4 * v16 * *(_DWORD *)(a4 + 16) / 3;
  v44 = v37 * v40 + 4 * v16 * *(_DWORD *)(a4 + 8) / 3;
  if ( v43 > v44 || v43 == v44 && *(_DWORD *)(a4 + 8) < *(_DWORD *)(a4 + 16) )
  {
    v45 = *(_DWORD *)(a4 + 8);
    *(_BYTE *)(a4 + 46) = 1;
  }
  else
  {
    v45 = *(_DWORD *)(a4 + 16);
    *(_BYTE *)(a4 + 46) = 0;
  }
  v46 = *(_BYTE *)(a4 + 46) == 0;
  *(_DWORD *)(a4 + 4) = v45;
  if ( v46 )
    return a4;
  v47 = (4 * v45 + 3) & 0xFFFFFFFC;
  if ( v47 )
  {
    if ( v47 > 0x7FFF0000 )
    {
      v49 = "crnlib_malloc: size too big";
      goto LABEL_62;
    }
  }
  else
  {
    v47 = 4;
  }
  a7 = v47;
  v48 = off_100AD9F4(0, v47, &a7, 1, dword_100AE9F4);
  if ( !v48 || a7 < v47 )
  {
    v49 = "crnlib_malloc: out of memory";
LABEL_62:
    sub_100927E0((int)v49);
    v48 = 0;
  }
  *(_DWORD *)(a4 + 32) = v48;
  if ( !v48 )
    goto LABEL_64;
  return a4;
}
// 1009994C: using guessed type float flt_1009994C[];
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10067950) --------------------------------------------------------
int __thiscall sub_10067950(int this, void *a2, size_t a3, int a4)
{
  int v4; // esi@1
  FILE *v5; // eax@1
  signed int v7; // ebp@6

  v4 = this;
  v5 = *(FILE **)(this + 4);
  if ( !v5 )
    return -1;
  if ( *(_BYTE *)(this + 8) )
  {
    *(_BYTE *)a4 = 1;
    return 0;
  }
  if ( *(_BYTE *)(this + 9) )
    return -1;
  v7 = fread(a2, 1u, a3, v5);
  if ( v7 < (signed int)a3 )
  {
    if ( ferror(*(FILE **)(v4 + 4)) )
    {
      *(_BYTE *)(v4 + 9) = 1;
      return -1;
    }
    *(_BYTE *)(v4 + 8) = 1;
    *(_BYTE *)a4 = 1;
  }
  return v7;
}

//----- (10067A70) --------------------------------------------------------
_DWORD *__stdcall sub_10067A70(int a1)
{
  _DWORD *result; // eax@1
  FILE *v2; // eax@3
  _DWORD *v3; // [sp+0h] [bp-204h]@2
  char DstBuf; // [sp+4h] [bp-200h]@3

  result = *(_DWORD **)(a1 + 64);
  *(_DWORD *)(a1 + 76) = 0;
  if ( result )
  {
    do
    {
      v3 = (_DWORD *)*result;
      if ( (unsigned __int8)result & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v2 = _iob_func();
        fputs(&DstBuf, v2 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(result, 0, 0, 1, dword_100AE9F4);
      }
      result = v3;
    }
    while ( v3 );
    result = (_DWORD *)a1;
    *(_DWORD *)(a1 + 64) = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 64) = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10067B70) --------------------------------------------------------
char __usercall sub_10067B70@<al>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  _BYTE *v3; // edi@1
  int v4; // eax@1
  int v5; // eax@2
  int v6; // esi@5
  signed int v7; // ecx@5

  v1 = a1;
  v2 = *(_BYTE *)(a1 + 524) == 0;
  v3 = (_BYTE *)(a1 + 524);
  v4 = a1 + 653;
  *(_DWORD *)(v1 + 516) = 0;
  *(_DWORD *)(v1 + 512) = v4;
  if ( v2 )
  {
    do
    {
      v5 = (*(int (__stdcall **)(int, int, _BYTE *))(**(_DWORD **)(v1 + 76) + 4))(
             *(_DWORD *)(v1 + 516) + v1 + 653,
             0x2000 - *(_DWORD *)(v1 + 516),
             v3);
      if ( v5 == -1 )
      {
        *(_DWORD *)(v1 + 13320) = -225;
        sub_10067A70(v1);
        longjmp((int *__attribute__((__org_typedef(jmp_buf))) )v1, -225);
      }
      *(_DWORD *)(v1 + 516) += v5;
      v4 = *(_DWORD *)(v1 + 516);
    }
    while ( v4 < 0x2000 && !*v3 );
    *(_DWORD *)(v1 + 13328) += v4;
    v6 = v4 + *(_DWORD *)(v1 + 512);
    v7 = 64;
    LOBYTE(v4) = -39;
    do
    {
      *(_BYTE *)v6 = -1;
      *(_BYTE *)(v6 + 1) = -39;
      v6 += 2;
      --v7;
    }
    while ( v7 );
  }
  return v4;
}

//----- (10068220) --------------------------------------------------------
char __usercall sub_10068220@<al>(int a1@<ecx>, FILE *a2@<edi>, char *a3, int a4)
{
  char result; // al@1
  int v5; // ebp@2
  char v6; // dl@4
  __int16 v7; // bx@5
  signed int v8; // ebx@6
  int v9; // [sp-2h] [bp-4h]@1

  v9 = a1;
  result = *a3;
  if ( *a3 )
  {
    v5 = a4 - 4;
    while ( 2 )
    {
      ++a3;
      switch ( result )
      {
        case 49:
          v6 = *(_BYTE *)(v5 + 4);
          v5 += 4;
          BYTE3(v9) = v6;
          fwrite((char *)&v9 + 3, 1u, 1u, a2);
          goto LABEL_7;
        case 50:
          v7 = *(_WORD *)(v5 + 4);
          v5 += 4;
          BYTE3(v9) = v7;
          fwrite((char *)&v9 + 3, 1u, 1u, a2);
          BYTE3(v9) = HIBYTE(v7);
          fwrite((char *)&v9 + 3, 1u, 1u, a2);
          goto LABEL_7;
        case 52:
          v8 = *(_DWORD *)(v5 + 4);
          v5 += 4;
          BYTE3(v9) = v8;
          fwrite((char *)&v9 + 3, 1u, 1u, a2);
          BYTE3(v9) = BYTE1(v8);
          fwrite((char *)&v9 + 3, 1u, 1u, a2);
          BYTE3(v9) = v8 >> 16;
          fwrite((char *)&v9 + 3, 1u, 1u, a2);
          BYTE3(v9) = BYTE3(v8);
          fwrite((char *)&v9 + 3, 1u, 1u, a2);
          goto LABEL_7;
        case 32:
LABEL_7:
          result = *a3;
          if ( !*a3 )
            return result;
          continue;
        default:
          return result;
      }
    }
  }
  return result;
}

//----- (10068350) --------------------------------------------------------
char __usercall sub_10068350@<al>(FILE *a1@<edi>, char *a2, char a3)
{
  return sub_10068220((int)a2, a1, a2, (int)&a3);
}

//----- (10068370) --------------------------------------------------------
size_t __usercall sub_10068370@<eax>(FILE *a1@<ecx>, size_t result@<eax>, int a3@<edx>, int a4, int a5, int a6, int a7, int a8, size_t a9)
{
  FILE *v9; // edi@1
  int v10; // ebx@2
  int v11; // ecx@5
  int v12; // ebp@5
  int v13; // esi@5
  _BYTE *v14; // esi@8
  int v15; // ebp@14
  int v16; // ecx@14
  unsigned int v17; // edx@14
  int v18; // ecx@14
  int v19; // ST0C_4@14
  int v20; // ST0C_4@15
  int v21; // ST08_4@15
  char v22; // [sp+Dh] [bp-1Fh]@14
  char v23; // [sp+Eh] [bp-1Eh]@14
  size_t v24; // [sp+10h] [bp-1Ch]@2
  _BYTE *v25; // [sp+14h] [bp-18h]@5
  size_t v26; // [sp+18h] [bp-14h]@2
  int v27; // [sp+1Ch] [bp-10h]@8
  int v28; // [sp+20h] [bp-Ch]@8
  int v29; // [sp+24h] [bp-8h]@5
  int v30; // [sp+28h] [bp-4h]@1

  v9 = a1;
  v30 = 0;
  if ( a5 >= 0 )
  {
    v26 = result;
    v24 = 0;
    v10 = 0;
  }
  else
  {
    v10 = result - 1;
    v26 = -1;
    v24 = result - 1;
  }
  if ( v10 != v26 )
  {
    v11 = a6;
    v12 = a7;
    v13 = a7 * a6 * a5;
    v29 = a7 * a6 * a5;
    v25 = (_BYTE *)(a7 * a6 * v10 + a3 + 3);
    while ( 1 )
    {
      if ( v11 > 0 )
      {
        v14 = v25;
        v27 = v11;
        v28 = -1 - a4;
        do
        {
          if ( a8 < 0 )
            fwrite(&v14[v12 - 4], 1u, 1u, v9);
          switch ( v12 )
          {
            case 1:
            case 2:
              sub_10068350(v9, (char *)&unk_1009AEE4, *(v14 - 3));
              break;
            case 4:
              if ( a8 )
                goto LABEL_15;
              v15 = *v14;
              v16 = v15 * (*(v14 - 3) - 255);
              v17 = v15 * *(v14 - 2) + ((unsigned __int64)(-2139062143i64 * v15 * *(v14 - 2)) >> 32);
              v18 = v15 * (*(v14 - 1) - 255);
              v10 = ((signed int)v17 >> 7) + (v17 >> 31);
              v23 = ((signed int)(v18 + ((unsigned __int64)(-2139062143i64 * v18) >> 32)) >> 7)
                  + ((unsigned int)(v18 + ((unsigned __int64)(-2139062143i64 * v18) >> 32)) >> 31)
                  - 1;
              v22 = ((signed int)v17 >> 7) + (v17 >> 31);
              v19 = (unsigned __int8)*(&v22 + a4);
              sub_10068350(v9, (char *)&unk_1009AEE8, *(&v22 - a4));
              v12 = a7;
              goto LABEL_18;
            case 3:
LABEL_15:
              v20 = v14[a4 - 2];
              v21 = *(v14 - 2);
              sub_10068350(v9, (char *)&unk_1009AEEC, v14[v28 - 1]);
              break;
            default:
              break;
          }
          if ( a8 > 0 )
            fwrite(&v14[v10 - 3], 1u, 1u, v9);
LABEL_18:
          v14 += v12;
          --v27;
        }
        while ( v27 );
        v13 = v29;
        v10 = v24;
      }
      result = fwrite(&v30, a9, 1u, v9);
      v10 += a5;
      v25 += v13;
      v24 = v10;
      if ( v10 == v26 )
        break;
      v11 = a6;
    }
  }
  return result;
}

//----- (10068570) --------------------------------------------------------
BOOL __usercall sub_10068570@<eax>(const char *a1@<eax>, int a2, int a3, int a4, size_t a5, int a6, int a7, int a8, size_t a9, char *a10, char a11)
{
  FILE *v11; // edi@1

  v11 = fopen(a1, "wb");
  if ( v11 )
  {
    sub_10068220((int)&a11, v11, a10, (int)&a11);
    sub_10068370(v11, a5, a7, a2, a3, a4, a6, a8, a9);
    fclose(v11);
  }
  return v11 != 0;
}

//----- (100686F0) --------------------------------------------------------
int __usercall sub_100686F0@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ecx@1
  int result; // eax@1
  int v3; // esi@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@2
  unsigned int v6; // ecx@2
  unsigned int v7; // ecx@2

  v1 = 12345;
  result = 65435;
  v3 = 34221;
  v4 = 0;
  do
  {
    v5 = (((result << 17) ^ (unsigned int)result) >> 13) ^ (result << 17) ^ result;
    result = 32 * v5 ^ v5;
    v6 = 33 * ((4097 * v1 + 2127912214) ^ ((4097 * v1 + 2127912214) >> 19) ^ 0xC761C23C) + 374761393;
    v7 = 9 * ((v6 << 9) ^ (v6 - 744332180)) - 42973499;
    v3 = 69069 * v3 + 1234567;
    v1 = (v7 >> 16) ^ v7 ^ 0xB55A4F09;
    *(_DWORD *)(a1 + 4 * v4++) = v1 ^ result ^ v3;
  }
  while ( v4 < 0x10 );
  *(_DWORD *)(a1 + 64) = 0;
  return result;
}

//----- (10068790) --------------------------------------------------------
unsigned __int32 __usercall sub_10068790@<eax>(int a1@<edi>)
{
  unsigned int v1; // ecx@1
  unsigned __int32 result; // eax@1
  unsigned int v3; // esi@1
  unsigned int v4; // eax@2
  unsigned int v5; // ecx@2
  unsigned int v6; // ecx@2

  v1 = -559038913;
  result = _byteswap_ulong(0xDEADBE3F) ^ 0xAAC29377;
  v3 = 0;
  do
  {
    v4 = (((result << 17) ^ result) >> 13) ^ (result << 17) ^ result;
    result = 32 * v4 ^ v4;
    v5 = 33 * ((4097 * v1 + 2127912214) ^ ((4097 * v1 + 2127912214) >> 19) ^ 0xC761C23C) + 374761393;
    v6 = 9 * ((v5 << 9) ^ (v5 - 744332180)) - 42973499;
    v1 = (v6 >> 16) ^ v6 ^ 0xB55A4F09;
    *(_DWORD *)(a1 + 4 * v3++) = v1 ^ result;
  }
  while ( v3 < 0x10 );
  *(_DWORD *)(a1 + 64) = 0;
  return result;
}

//----- (10068990) --------------------------------------------------------
int __usercall sub_10068990@<eax>(int result@<eax>, int a2@<ecx>)
{
  int v2; // ecx@1
  int v3; // edx@1
  int v4; // esi@1
  int v5; // edi@1
  int v6; // ebx@2
  int v7; // ecx@2
  int v8; // ebx@2
  int v9; // esi@2
  int v10; // edi@2
  int v11; // edx@2
  int v12; // ecx@2
  int v13; // ebx@2
  int v14; // edx@2
  int v15; // ebx@2
  int v16; // ebx@2
  int v17; // esi@2
  int v18; // edi@2
  int v19; // ecx@2
  int v20; // edx@2
  int v21; // ebx@2
  int v22; // ecx@2
  int v23; // ebx@2
  int v24; // ebx@2
  int v25; // esi@2
  int v26; // edi@2
  int v27; // edx@2
  int v28; // ecx@2
  int v29; // ebx@2
  int v30; // edx@2
  int v31; // ebx@2
  int v32; // ebx@2
  int v33; // esi@2
  int v34; // edi@2
  int v35; // ecx@2
  int v36; // ebx@2
  int v37; // edx@2
  int v38; // ebp@2
  int v39; // ecx@2
  bool v40; // zf@2
  signed int v41; // [sp+10h] [bp-4h]@1

  *(_DWORD *)result = -236298515;
  *(_DWORD *)(result + 12) = a2;
  *(_DWORD *)(result + 8) = a2;
  *(_DWORD *)(result + 4) = a2;
  v2 = *(_DWORD *)result;
  v3 = *(_DWORD *)(result + 4);
  v4 = *(_DWORD *)(result + 8);
  v5 = *(_DWORD *)(result + 12);
  v41 = 4;
  do
  {
    v6 = __ROL4__(v3, 27);
    v7 = v2 - v6;
    v8 = __ROL4__(v4, 17);
    v9 = v5 + v4;
    v10 = v7 + v5;
    v11 = v3 ^ v8;
    v12 = v11 + v7;
    v13 = __ROL4__(v9, 27);
    v14 = v11 - v13;
    v15 = __ROL4__(v10, 17);
    v16 = v9 ^ v15;
    v17 = v10 + v12;
    v18 = v12 + v14;
    v19 = v16;
    v20 = v16 + v14;
    v21 = __ROL4__(v17, 27);
    v22 = v19 - v21;
    v23 = __ROL4__(v18, 17);
    v24 = v17 ^ v23;
    v25 = v18 + v20;
    v26 = v20 + v22;
    v27 = v24;
    v28 = v24 + v22;
    v29 = __ROL4__(v25, 27);
    v30 = v27 - v29;
    v31 = __ROL4__(v26, 17);
    v32 = v25 ^ v31;
    v33 = v26 + v28;
    v34 = v28 + v30;
    v35 = v32;
    v36 = v32 + v30;
    v37 = __ROL4__(v33, 27);
    v38 = v35 - v37;
    v39 = __ROL4__(v34, 17);
    v2 = v33 ^ v39;
    v40 = v41-- == 1;
    v3 = v34 + v36;
    *(_DWORD *)result = v2;
    v4 = v36 + v38;
    v5 = v2 + v38;
  }
  while ( !v40 );
  *(_DWORD *)(result + 12) = v5;
  *(_DWORD *)(result + 8) = v4;
  *(_DWORD *)(result + 4) = v3;
  return result;
}

//----- (10068A50) --------------------------------------------------------
unsigned int __usercall sub_10068A50@<eax>(int a1@<esi>)
{
  int v1; // ebx@1
  int v2; // ecx@2
  unsigned int v3; // ecx@2
  unsigned int v4; // eax@2
  int v5; // edx@2
  int v6; // eax@2
  int v7; // edx@2
  int v8; // edi@2
  int v9; // edi@2
  int v10; // ecx@2
  int v11; // edx@2
  int v12; // edi@2
  int v13; // ecx@2
  int v14; // eax@2
  int v15; // ebp@2
  int v16; // edx@2
  unsigned int result; // eax@2
  bool v18; // zf@2
  signed int v19; // [sp+10h] [bp-4h]@1

  sub_10068990(a1, 18959);
  v1 = a1 + 32;
  *(_DWORD *)(a1 + 16) = 12345;
  *(_DWORD *)(a1 + 20) = 65435;
  *(_DWORD *)(a1 + 24) = 34221;
  *(_DWORD *)(a1 + 28) = 7654321;
  sub_100686F0(a1 + 32);
  v19 = 100;
  do
  {
    v2 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 16) = 69069 * *(_DWORD *)(a1 + 16) + 12345;
    v3 = v2 ^ (v2 << 13) ^ ((v2 ^ (unsigned int)(v2 << 13)) >> 17);
    v4 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 20) = v3 ^ 32 * v3;
    *(_QWORD *)(a1 + 24) = *(_DWORD *)(a1 + 28) + 698769069i64 * v4;
    v5 = __ROL4__(*(_DWORD *)(a1 + 4), 27);
    v6 = *(_DWORD *)a1 - v5;
    v7 = *(_DWORD *)(a1 + 8);
    v8 = __ROL4__(*(_DWORD *)(a1 + 8), 17);
    v9 = *(_DWORD *)(a1 + 4) ^ v8;
    v10 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)a1 = v9;
    *(_DWORD *)(a1 + 8) = v6 + v10;
    *(_DWORD *)(a1 + 12) = v6 + v9;
    *(_DWORD *)(a1 + 4) = v10 + v7;
    v11 = *(_DWORD *)(a1 + 96);
    v12 = *(_DWORD *)(v1 + 4 * (((_BYTE)v11 - 3) & 0xF));
    v13 = *(_DWORD *)(v1 + 4 * v11) ^ v12 ^ ((v12 ^ 2 * *(_DWORD *)(v1 + 4 * v11)) << 15);
    v14 = (*(_DWORD *)(v1 + 4 * (((_BYTE)v11 - 7) & 0xF)) >> 11) ^ *(_DWORD *)(v1 + 4 * (((_BYTE)v11 - 7) & 0xF));
    v15 = v14 ^ v13;
    *(_DWORD *)(v1 + 4 * v11) = v15;
    v16 = ((unsigned __int8)*(_DWORD *)(a1 + 96) - 1) & 0xF;
    *(_DWORD *)(a1 + 96) = v16;
    result = *(_DWORD *)(v1 + 4 * v16) ^ v13 ^ v15 ^ 32 * (v15 & 0xFED22169) ^ 4
                                                                             * (*(_DWORD *)(v1 + 4 * v16) ^ ((v13 ^ (v14 << 10)) << 16));
    v18 = v19-- == 1;
    *(_DWORD *)(v1 + 4 * v16) = result;
  }
  while ( !v18 );
  return result;
}

//----- (10068BB0) --------------------------------------------------------
int __usercall sub_10068BB0@<eax>(void *a1@<ecx>, int a2@<eax>, size_t a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // edi@1
  int result; // eax@1

  v5 = *(_DWORD *)(a2 + 8);
  v6 = *(_DWORD *)a2;
  v7 = *(_DWORD *)(a2 + 4);
  memset(a1, 2, a3);
  *(_DWORD *)a4 = (unsigned __int8)byte_100AF220[2 * v5] | 32
                                                         * ((unsigned __int8)byte_100AF020[2 * v7] | ((unsigned __int8)byte_100AF220[2 * v6] << 6));
  result = (unsigned __int8)byte_100AF221[2 * v5];
  *(_DWORD *)a5 = result | 32 * ((unsigned __int8)byte_100AF021[2 * v7] | ((unsigned __int8)byte_100AF221[2 * v6] << 6));
  return result;
}

//----- (10068C20) --------------------------------------------------------
char __usercall sub_10068C20@<al>(int a1@<eax>, unsigned int a2, int a3, _BYTE *a4)
{
  int v4; // ebx@1
  int v5; // edx@1
  int v6; // ebp@1
  int v7; // esi@1
  int v8; // edi@1
  int v9; // ecx@1
  int v10; // edx@1
  char result; // al@1
  int v12; // edi@1
  int v13; // edx@1
  int v14; // esi@1
  int v15; // edi@2
  int v16; // eax@3
  int v17; // ebp@3
  int v18; // eax@4
  int v19; // ebp@6
  char v20; // [sp+13h] [bp-11h]@1
  int v21; // [sp+14h] [bp-10h]@1
  int v22; // [sp+18h] [bp-Ch]@1
  int v23; // [sp+1Ch] [bp-8h]@1
  int v24; // [sp+20h] [bp-4h]@1

  v4 = *(_BYTE *)a1 - *(_BYTE *)(a1 + 4);
  v5 = *(_BYTE *)(a1 + 1) - *(_BYTE *)(a1 + 5);
  v6 = *(_BYTE *)(a1 + 2) - *(_BYTE *)(a1 + 6);
  v7 = v5 * *(_BYTE *)(a1 + 1) + v4 * *(_BYTE *)a1 + v6 * *(_BYTE *)(a1 + 2);
  v8 = v4 * *(_BYTE *)(a1 + 4) + v5 * *(_BYTE *)(a1 + 5) + v6 * *(_BYTE *)(a1 + 6);
  v21 = *(_BYTE *)(a1 + 2) - *(_BYTE *)(a1 + 6);
  v22 = *(_BYTE *)(a1 + 1) - *(_BYTE *)(a1 + 5);
  v9 = v4 * *(_BYTE *)(a1 + 8) + v5 * *(_BYTE *)(a1 + 9) + v6 * *(_BYTE *)(a1 + 10);
  v10 = v4 * *(_BYTE *)(a1 + 12) + v5 * *(_BYTE *)(a1 + 13) + v21 * *(_BYTE *)(a1 + 14);
  result = 0;
  v12 = (v10 + v8) >> 1;
  v13 = (v9 + v10) >> 1;
  v14 = (v9 + v7) >> 1;
  v24 = v12;
  v20 = 0;
  v23 = 0;
  if ( a2 )
  {
    v15 = a3 + 1;
    do
    {
      v16 = v22 * *(_BYTE *)v15;
      v17 = v16 + v4 * *(_BYTE *)(v15 - 1) + v21 * *(_BYTE *)(v15 + 1);
      if ( v17 >= v13 )
      {
        LOBYTE(v18) = v17 >= v14 ? 0 : 2;
      }
      else
      {
        LOBYTE(v16) = v17 >= v24;
        v18 = 2 * v16 + 1;
      }
      v19 = v23;
      a4[v23] = v18;
      if ( (_BYTE)v18 != *a4 )
        v20 = 1;
      v15 += 4;
      ++v23;
    }
    while ( v19 + 1 < a2 );
    result = v20;
  }
  return result;
}

//----- (10068DB0) --------------------------------------------------------
_DWORD __cdecl sub_10068DB0(unsigned int a1, _DWORD a2, _DWORD a3, _DWORD a4)
{
  _BYTE *v4; // ecx@2
  unsigned int v5; // esi@2
  _DWORD v6; // kr00_4@3
  _DWORD v7; // kr04_4@3
  _QWORD v8; // rax@3
  unsigned __int8 v9; // cf@3
  unsigned int v10; // eax@4
  _BYTE *v11; // edi@5
  int v12; // esi@6
  int v13; // edx@6
  _BYTE v14; // cl@10
  _BYTE v15; // dl@10
  unsigned int v16; // edi@10
  _BYTE *v17; // eax@11
  int v18; // esi@12
  int v19; // edx@12
  unsigned int v20; // ebx@15
  int v21; // esi@19
  int v22; // edx@19
  int v23; // ecx@19
  _BYTE *v24; // esi@20
  _DWORD v25; // ebp@21
  _DWORD v26; // ebx@21
  _DWORD v27; // edi@21
  int v28; // ecx@21
  _QWORD v29; // rax@21
  unsigned __int64 v30; // rax@24
  _BYTE v31; // dl@31
  _BYTE v32; // ST25_1@32
  _BYTE v33; // al@32
  _BYTE v34; // dl@32
  _BYTE v35; // cl@32
  _DWORD result; // eax@34
  _BYTE v37; // [sp+14h] [bp-68h]@10
  _WORD v38; // [sp+14h] [bp-68h]@15
  _BYTE v39; // [sp+15h] [bp-67h]@10
  _BYTE v40; // [sp+16h] [bp-66h]@10
  _BYTE v41; // [sp+16h] [bp-66h]@15
  _BYTE v42; // [sp+17h] [bp-65h]@10
  unsigned int v43; // [sp+18h] [bp-64h]@4
  unsigned int v44; // [sp+18h] [bp-64h]@10
  _WORD v45; // [sp+18h] [bp-64h]@15
  _BYTE v46; // [sp+1Ah] [bp-62h]@15
  _BYTE v47; // [sp+1Bh] [bp-61h]@15
  unsigned int v48; // [sp+1Ch] [bp-60h]@4
  _DWORD v49; // [sp+1Ch] [bp-60h]@11
  int v50; // [sp+1Ch] [bp-60h]@19
  signed int v51; // [sp+20h] [bp-5Ch]@4
  int v52; // [sp+20h] [bp-5Ch]@19
  signed int v53; // [sp+24h] [bp-58h]@10
  unsigned int v54; // [sp+24h] [bp-58h]@15
  int v55; // [sp+28h] [bp-54h]@11
  unsigned int v56; // [sp+28h] [bp-54h]@20
  int v57; // [sp+2Ch] [bp-50h]@19
  int v58; // [sp+30h] [bp-4Ch]@19
  _WORD v59; // [sp+34h] [bp-48h]@24
  _WORD v60; // [sp+37h] [bp-45h]@24
  unsigned int v61; // [sp+3Ch] [bp-40h]@4
  unsigned int v62; // [sp+40h] [bp-3Ch]@4
  int v63; // [sp+44h] [bp-38h]@4
  unsigned __int64 v64; // [sp+48h] [bp-34h]@1
  __int64 v65; // [sp+50h] [bp-2Ch]@1
  __int64 v66; // [sp+58h] [bp-24h]@1
  __int64 v67; // [sp+60h] [bp-1Ch]@24
  __int64 v68; // [sp+68h] [bp-14h]@24
  __int64 v69; // [sp+70h] [bp-Ch]@24

  v64 = 0i64;
  v65 = 0i64;
  v66 = 0i64;
  if ( a1 )
  {
    v4 = (_BYTE *)(a2 + 2);
    v5 = a1;
    do
    {
      v6 = v64;
      v7 = *(v4 - 2);
      LODWORD(v64) = v7 + v64;
      LODWORD(v8) = *(v4 - 1);
      v64 = __PAIR__(HIDWORD(v64), v7) + v6;
      v8 = (signed int)v8;
      v9 = __CFADD__((_DWORD)v8, (_DWORD)v65);
      LODWORD(v65) = v8 + v65;
      LODWORD(v8) = *v4;
      HIDWORD(v65) += HIDWORD(v8) + v9;
      v66 += (signed int)v8;
      v4 += 4;
      --v5;
    }
    while ( v5 );
  }
  v61 = (v64 + (a1 >> 1)) / a1;
  v62 = (v65 + (unsigned __int64)(a1 >> 1)) / a1;
  v63 = (v66 + (unsigned __int64)(a1 >> 1)) / a1;
  v10 = 0;
  v51 = -1;
  v48 = 0;
  v43 = 0;
  if ( a1 )
  {
    v11 = (_BYTE *)(a2 + 2);
    do
    {
      v12 = (*(v11 - 1) - v62) * (*(v11 - 1) - v62);
      v13 = (*(v11 - 2) - v61) * (*(v11 - 2) - v61);
      if ( v13 + v12 + (*v11 - v63) * (*v11 - v63) <= v51 )
      {
        v10 = v48;
      }
      else
      {
        v10 = v43;
        v51 = v13 + v12 + (*v11 - v63) * (*v11 - v63);
        v48 = v43;
      }
      v11 += 4;
      ++v43;
    }
    while ( v43 < a1 );
  }
  v14 = *(_BYTE *)(a2 + 4 * v10);
  v39 = *(_BYTE *)(a2 + 4 * v10 + 1);
  v15 = *(_BYTE *)(a2 + 4 * v10 + 2);
  v16 = 0;
  v37 = *(_BYTE *)(a2 + 4 * v10);
  v40 = *(_BYTE *)(a2 + 4 * v10 + 2);
  v42 = *(_BYTE *)(a2 + 4 * v10 + 3);
  v53 = -1;
  v44 = 0;
  if ( a1 )
  {
    v17 = (_BYTE *)(a2 + 2);
    v49 = v15;
    v55 = a2 + 2;
    do
    {
      v18 = (*(v17 - 1) - v39) * (*(v17 - 1) - v39);
      v19 = (*(v17 - 2) - v14) * (*(v17 - 2) - v14);
      if ( v19 + v18 + (*v17 - v49) * (*v17 - v49) > v53 )
      {
        v16 = v44;
        v53 = v19 + v18 + (*v17 - v49) * (*v17 - v49);
      }
      v17 = (_BYTE *)(v55 + 4);
      ++v44;
      v55 += 4;
    }
    while ( v44 < a1 );
  }
  v47 = *(_BYTE *)(a2 + 4 * v16 + 3);
  LOBYTE(v45) = (v61 + *(_BYTE *)(a2 + 4 * v16)) >> 1;
  HIBYTE(v38) = (v62 + v39) >> 1;
  HIBYTE(v45) = (v62 + *(_BYTE *)(a2 + 4 * v16 + 1)) >> 1;
  v20 = (v61 + v37) >> 1;
  LOBYTE(v38) = v20;
  v41 = (v63 + (unsigned int)v40) >> 1;
  v46 = (v63 + (unsigned int)*(_BYTE *)(a2 + 4 * v16 + 2)) >> 1;
  v54 = 0;
  while ( (_BYTE)v20 != (_BYTE)v45 || HIBYTE(v38) != HIBYTE(v45) || v41 != v46 )
  {
    memset(&v64, 0, 0x30u);
    v61 = 0;
    v62 = 0;
    v21 = HIBYTE(v45) - HIBYTE(v38);
    v22 = v46 - v41;
    v23 = (unsigned __int8)v45 - (unsigned __int8)v20;
    v58 = v23 * (unsigned __int8)v20
        + v21 * HIBYTE(v38)
        + v22 * v41
        + v23 * (unsigned __int8)v45
        + v21 * HIBYTE(v45)
        + v22 * v46;
    v57 = 2 * v23;
    v52 = 2 * v21;
    v50 = 2 * v22;
    if ( a1 )
    {
      v24 = (_BYTE *)(a2 + 2);
      v56 = a1;
      do
      {
        v25 = *(v24 - 1);
        v26 = *v24;
        v27 = v50 * v26 + v52 * v25 + v57 * *(v24 - 2) > v58;
        v28 = 24 * v27;
        v29 = *(v24 - 2);
        v9 = __CFADD__((_DWORD)v29, *((_DWORD *)&v64 + 6 * v27));
        *(_DWORD *)((char *)&v64 + v28) += v29;
        *(_DWORD *)((char *)&v64 + v28 + 4) += HIDWORD(v29) + v9;
        v9 = __CFADD__(v25, *((_DWORD *)&v65 + 6 * v27));
        *(_DWORD *)((char *)&v65 + v28) += v25;
        *(_DWORD *)((char *)&v65 + v28 + 4) += ((unsigned __int64)v25 >> 32) + v9;
        v9 = __CFADD__(v26, *((_DWORD *)&v66 + 6 * v27));
        *(_DWORD *)((char *)&v66 + v28) += v26;
        *(_DWORD *)((char *)&v66 + v28 + 4) += ((unsigned __int64)v26 >> 32) + v9;
        ++*(&v61 + v27);
        v24 += 4;
        --v56;
      }
      while ( v56 );
    }
    if ( !v61 || !v62 )
    {
      LOBYTE(v20) = v38;
      break;
    }
    LOBYTE(v59) = (v64 + (v61 >> 1)) / v61;
    HIBYTE(v59) = (v65 + (unsigned __int64)(v61 >> 1)) / v61;
    LOBYTE(v60) = (v67 + (unsigned __int64)(v62 >> 1)) / v62;
    HIBYTE(v60) = (v68 + (unsigned __int64)(v62 >> 1)) / v62;
    v30 = (v69 + (unsigned __int64)(v62 >> 1)) / v62;
    LOBYTE(v20) = v38;
    if ( v59 != v38
      || (unsigned __int8)((v66 + (unsigned __int64)(v61 >> 1)) / v61) != v41
      || v60 != v45
      || (_BYTE)v30 != v46 )
    {
      v46 = v30;
      v41 = (v66 + (unsigned __int64)(v61 >> 1)) / v61;
      v45 = v60;
      v38 = v59;
      ++v54;
      LOBYTE(v20) = v59;
      if ( v54 < 4 )
        continue;
    }
    break;
  }
  v31 = HIBYTE(v38);
  if ( v41 * v41 + HIBYTE(v38) * HIBYTE(v38) + (unsigned __int8)v20 * (unsigned int)(unsigned __int8)v20 <= v46 * v46 + HIBYTE(v45) * HIBYTE(v45) + (unsigned __int8)v45 * (unsigned int)(unsigned __int8)v45 )
  {
    v35 = v42;
  }
  else
  {
    v32 = HIBYTE(v45);
    v33 = v20;
    LOBYTE(v20) = v45;
    HIBYTE(v45) = v31;
    v34 = v41;
    LOBYTE(v45) = v33;
    v35 = v47;
    v41 = v46;
    v46 = v34;
    v31 = v32;
    v47 = v42;
  }
  *(_BYTE *)(a3 + 1) = v31;
  *(_BYTE *)(a3 + 2) = v41;
  *(_BYTE *)(a3 + 3) = v35;
  *(_BYTE *)a3 = v20;
  result = a4;
  *(_BYTE *)a4 = v45;
  *(_BYTE *)(a4 + 1) = HIBYTE(v45);
  *(_BYTE *)(a4 + 2) = v46;
  *(_BYTE *)(a4 + 3) = v47;
  return result;
}
// 10068DB0: too many cbuild loops

//----- (10069310) --------------------------------------------------------
int __usercall sub_10069310@<eax>(int a1@<eax>, int a2@<ecx>, unsigned int a3, _DWORD *a4, _DWORD *a5, int a6)
{
  int v6; // ebx@1
  _BYTE *v7; // ebp@1
  unsigned int v8; // ecx@1
  int v9; // eax@1
  _BYTE *v10; // edx@2
  int v11; // esi@2
  int v12; // ecx@3
  signed int v13; // ebx@9
  int v14; // edx@9
  int result; // eax@9
  unsigned int v16; // esi@9
  int v17; // edi@12
  int v18; // ecx@12
  int v19; // [sp+8h] [bp-4h]@9
  _BYTE *v20; // [sp+18h] [bp+Ch]@10

  v6 = *(_BYTE *)(a2 + a1);
  v7 = (_BYTE *)(a2 + a1);
  v8 = a3;
  v9 = v6;
  if ( a3 > 1 )
  {
    v10 = v7 + 4;
    v11 = a3 - 1;
    do
    {
      v12 = *v10;
      if ( v9 >= v12 )
        v9 = *v10;
      if ( v6 <= v12 )
        v6 = *v10;
      v10 += 4;
      --v11;
    }
    while ( v11 );
    v8 = a3;
  }
  *a4 = v6;
  v13 = v6 - v9;
  *a5 = v9;
  v14 = 7 * v9 - (v13 >> 1);
  result = 2 * v13;
  v16 = 0;
  v19 = v14;
  if ( v8 )
  {
    v20 = v7;
    while ( 1 )
    {
      v18 = 7 * *v7 - v14;
      v17 = 4 * v13;
      result = -((((v17 - v18) >> 31) & 4)
               + (((v13
                  + (2 * v13 & ((2 * v13 - (v18 - (v17 & ((v17 - v18) >> 31)))) >> 31))
                  - (v18
                   - (v17 & ((v17 - v18) >> 31)))) >> 31) & 1)
               + (((2 * v13 - (v18 - (v17 & ((v17 - v18) >> 31)))) >> 31) & 2)) & 7;
      *(_BYTE *)(v16++ + a6) = result ^ (result < 2);
      v7 = v20 + 4;
      v20 += 4;
      if ( v16 >= a3 )
        break;
      v14 = v19;
    }
  }
  return result;
}

//----- (10069400) --------------------------------------------------------
bool __usercall sub_10069400@<al>(int a1@<eax>, unsigned int a2@<ecx>, int a3, int *a4, int *a5)
{
  double v5; // st6@1
  int *v6; // ebp@1
  double v7; // st5@1
  unsigned int v8; // ebx@1
  double v9; // st7@1
  unsigned int v10; // ecx@1
  int v11; // esi@1
  double v12; // st3@1
  double v13; // st4@1
  double v14; // st2@1
  double v15; // st7@2
  int v16; // eax@2
  double v17; // rt2@3
  double v18; // st4@3
  double v19; // rtt@3
  double v20; // st3@4
  int v21; // edx@4
  double v22; // rt0@4
  double v23; // st1@4
  double v24; // rt1@4
  double v25; // ST48_8@4
  double v26; // ST18_8@4
  double v27; // st2@4
  double v28; // ST28_8@4
  double v29; // ST38_8@4
  double v30; // st7@4
  double v31; // rt2@4
  double v32; // st4@4
  double v33; // st3@4
  int v34; // edx@4
  double v35; // st2@4
  double v36; // ST40_8@4
  double v37; // ST48_8@4
  double v38; // ST18_8@4
  double v39; // st1@4
  double v40; // ST28_8@4
  double v41; // st5@4
  double v42; // st7@4
  double v43; // ST30_8@4
  double v44; // st6@4
  double v45; // ST20_8@4
  double v46; // st4@4
  double v47; // st3@4
  int v48; // edx@4
  double v49; // st2@4
  double v50; // ST40_8@4
  double v51; // ST48_8@4
  double v52; // ST18_8@4
  double v53; // st1@4
  double v54; // ST28_8@4
  double v55; // ST58_8@4
  double v56; // ST38_8@4
  double v57; // ST50_8@4
  double v58; // ST20_8@4
  double v59; // st7@4
  double v60; // st6@4
  int v61; // edx@4
  double v62; // st5@4
  double v63; // st4@4
  double v64; // st2@4
  double v65; // rt0@4
  double v66; // st2@4
  double v67; // st7@4
  double v68; // rt2@4
  double v69; // st2@4
  double v70; // st6@4
  double v71; // st3@4
  double v72; // st2@5
  double v73; // rt1@5
  double v74; // st2@5
  double v75; // rt2@5
  _BYTE *v76; // edx@7
  double v77; // ST48_8@8
  int v78; // eax@8
  double v79; // ST58_8@8
  double v80; // ST50_8@8
  double v81; // st1@8
  long double v82; // st2@9
  long double v83; // st3@12
  signed int v84; // eax@12
  signed int v85; // esi@16
  signed int v86; // eax@16
  int v87; // edi@20
  signed int v88; // eax@20
  signed int v89; // eax@24
  signed int v90; // edi@28
  signed int v91; // eax@28
  int v92; // esi@32
  signed int v93; // eax@32
  int v94; // eax@36
  bool result; // al@38
  int v96; // [sp+Ch] [bp-4Ch]@12
  double v97; // [sp+10h] [bp-48h]@1
  int v98; // [sp+10h] [bp-48h]@12
  double v99; // [sp+18h] [bp-40h]@1
  double v100; // [sp+18h] [bp-40h]@9
  double v101; // [sp+20h] [bp-38h]@1
  double v102; // [sp+28h] [bp-30h]@1
  double v103; // [sp+28h] [bp-30h]@9
  double v104; // [sp+30h] [bp-28h]@1
  double v105; // [sp+40h] [bp-18h]@12
  double v106; // [sp+48h] [bp-10h]@9

  v5 = 0.0;
  v6 = a4;
  v7 = 0.0;
  v8 = a2;
  v97 = 0.0;
  v9 = 0.0;
  v10 = 0;
  v104 = 0.0;
  v11 = a1;
  v12 = 0.0;
  v13 = 0.0;
  v101 = 0.0;
  v99 = 0.0;
  v102 = 0.0;
  v14 = 0.0;
  if ( (signed int)v8 >= 4 )
  {
    v15 = 0.0;
    v16 = a3 + 2;
    while ( 1 )
    {
      v20 = (double)*(_BYTE *)(v16 - 2);
      v21 = *(_BYTE *)(v11 + v10);
      v22 = (double)*(_BYTE *)v16;
      v23 = v5 + (double)dword_100A4F48[v21];
      v24 = (double)*(_BYTE *)(v16 - 1);
      v25 = v7 + (double)dword_100A504C[v21];
      v26 = (double)dword_100A4F58[v21] + v97;
      v27 = (double)dword_100A4F38[v21];
      v28 = v27 * v20 + v101;
      v29 = v27 * v22 + v104;
      v30 = v15 + v20;
      v31 = v13 + v27 * v24;
      v32 = (double)*(_BYTE *)(v16 + 2);
      v33 = (double)*(_BYTE *)(v16 + 3);
      v34 = *(_BYTE *)(v11 + v10 + 1);
      v35 = (double)*(_BYTE *)(v16 + 4);
      v36 = (double)dword_100A4F48[v34] + v23;
      v37 = (double)dword_100A504C[v34] + v25;
      v38 = (double)dword_100A4F58[v34] + v26;
      v39 = (double)dword_100A4F38[v34];
      v40 = v39 * v32 + v28;
      v41 = v31 + v39 * v33;
      v42 = v30 + v32;
      v43 = v24 + v102 + v33;
      v44 = v39 * v35 + v29;
      v45 = v35 + v22 + v99;
      v46 = (double)*(_BYTE *)(v16 + 6);
      v47 = (double)*(_BYTE *)(v16 + 7);
      v48 = *(_BYTE *)(v11 + v10 + 2);
      v49 = (double)*(_BYTE *)(v16 + 8);
      v50 = (double)dword_100A4F48[v48] + v36;
      v51 = (double)dword_100A504C[v48] + v37;
      v52 = (double)dword_100A4F58[v48] + v38;
      v53 = (double)dword_100A4F38[v48];
      v54 = v53 * v46 + v40;
      v55 = v41 + v53 * v47;
      v56 = v44 + v53 * v49;
      v57 = v42 + v46;
      v58 = v49 + v45;
      v59 = (double)*(_BYTE *)(v16 + 10);
      v60 = (double)*(_BYTE *)(v16 + 11);
      v61 = *(_BYTE *)(v11 + v10 + 3);
      v62 = (double)*(_BYTE *)(v16 + 12);
      v63 = (double)dword_100A4F48[v61] + v50;
      v97 = (double)dword_100A4F58[v61] + v52;
      v64 = (double)dword_100A4F38[v61];
      v101 = v64 * v59 + v54;
      v65 = v64 * v60 + v55;
      v104 = v64 * v62 + v56;
      v66 = v59;
      v67 = v65;
      v68 = v66 + v57;
      v69 = v60;
      v70 = v68;
      v102 = v69 + v47 + v43;
      v71 = v62;
      v7 = (double)dword_100A504C[v61] + v51;
      v99 = v71 + v58;
      v10 += 4;
      v16 += 16;
      if ( v10 >= v8 - 3 )
        break;
      v17 = v63;
      v18 = v70;
      v5 = v17;
      v19 = v18;
      v13 = v67;
      v15 = v19;
    }
    v12 = 0.0;
    v6 = a4;
    v72 = v67;
    v9 = v97;
    v73 = v72;
    v74 = v63;
    v13 = v73;
    v75 = v74;
    v14 = v70;
    v5 = v75;
  }
  if ( v10 < v8 )
  {
    v76 = (_BYTE *)(a3 + 4 * v10 + 2);
    do
    {
      v77 = (double)*(v76 - 2);
      v78 = *(_BYTE *)(v10 + v11);
      v79 = (double)*(v76 - 1);
      v80 = (double)*v76;
      ++v10;
      v76 += 4;
      v5 = v5 + (double)dword_100A4F48[v78];
      v7 = v7 + (double)dword_100A504C[v78];
      v81 = (double)dword_100A4F38[v78];
      v101 = v77 * v81 + v101;
      v13 = v13 + v81 * v79;
      v104 = v81 * v80 + v104;
      v102 = v79 + v102;
      v99 = v80 + v99;
      v14 = v14 + v77;
      v9 = v9 + (double)dword_100A4F58[v78];
    }
    while ( v10 < v8 );
  }
  v106 = v14 * 3.0 - v101;
  v103 = v102 * 3.0 - v13;
  v100 = 3.0 * v99 - v104;
  v82 = v9 * v7 - v5 * v5;
  if ( v12 == v7 || v9 == v12 || fabs(v82) < 0.00001249999968422344 )
  {
    result = 0;
  }
  else
  {
    v83 = 0.364705890417099 / v82;
    v96 = *a5;
    v98 = *v6;
    v105 = 2.032258033752441 * (0.364705890417099 / v82);
    v84 = (signed int)((v101 * v7 - v106 * v5) * (0.364705890417099 / v82) + 0.5);
    if ( v84 >= 0 )
    {
      if ( v84 > 31 )
        v84 = 31;
    }
    else
    {
      v84 = 0;
    }
    v85 = v84 << 11;
    *v6 = v84 << 11;
    v86 = (signed int)((v13 * v7 - v103 * v5) * v105 + 0.5);
    if ( v86 >= 0 )
    {
      if ( v86 > 63 )
        v86 = 63;
    }
    else
    {
      v86 = 0;
    }
    v87 = v85 | 32 * v86;
    *v6 = v87;
    v88 = (signed int)((v7 * v104 - v100 * v5) * v83 + 0.5);
    if ( v88 >= 0 )
    {
      if ( v88 > 31 )
        v88 = 31;
    }
    else
    {
      v88 = 0;
    }
    *v6 = v87 | v88;
    v89 = (signed int)((v106 * v9 - v101 * v5) * v83 + 0.5);
    if ( v89 >= 0 )
    {
      if ( v89 > 31 )
        v89 = 31;
    }
    else
    {
      v89 = 0;
    }
    v90 = v89 << 11;
    *a5 = v89 << 11;
    v91 = (signed int)((v103 * v9 - v13 * v5) * v105 + 0.5);
    if ( v91 >= 0 )
    {
      if ( v91 > 63 )
        v91 = 63;
    }
    else
    {
      v91 = 0;
    }
    v92 = v90 | 32 * v91;
    *a5 = v92;
    v93 = (signed int)((v9 * v100 - v5 * v104) * v83 + 0.5);
    if ( v93 >= 0 )
    {
      if ( v93 > 31 )
        v93 = 31;
    }
    else
    {
      v93 = 0;
    }
    v94 = v92 | v93;
    *a5 = v94;
    result = v96 != v94 || v98 != *v6;
  }
  return result;
}
// 100A4F38: using guessed type int dword_100A4F38[];
// 100A4F48: using guessed type int dword_100A4F48[];
// 100A4F58: using guessed type int dword_100A4F58[];
// 100A504C: using guessed type int dword_100A504C[];

//----- (10069990) --------------------------------------------------------
int __usercall sub_10069990@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>)
{
  int v3; // esi@1
  int v4; // ebx@1
  int v5; // ebp@1
  int v6; // edi@1
  int v7; // edx@1
  unsigned int v8; // edx@1
  unsigned int v9; // edx@1
  int v10; // edx@1
  unsigned int v11; // edx@1
  int result; // eax@1

  *(_BYTE *)a3 = byte_100AF460[(unsigned __int16)a2 >> 11];
  *(_BYTE *)(a3 + 1) = byte_100AF420[(a2 >> 5) & 0x3F];
  *(_BYTE *)(a3 + 2) = byte_100AF460[a2 & 0x1F];
  *(_BYTE *)(a3 + 3) = 0;
  *(_BYTE *)(a3 + 4) = byte_100AF460[(unsigned __int16)a1 >> 11];
  *(_BYTE *)(a3 + 5) = byte_100AF420[(a1 >> 5) & 0x3F];
  *(_BYTE *)(a3 + 6) = byte_100AF460[a1 & 0x1F];
  *(_BYTE *)(a3 + 7) = 0;
  v3 = *(_BYTE *)a3;
  v4 = *(_BYTE *)(a3 + 1);
  v5 = *(_BYTE *)(a3 + 5);
  v6 = *(_BYTE *)(a3 + 4);
  *(_BYTE *)(a3 + 8) = ((unsigned __int64)(1431655766i64 * (v6 + 2 * v3)) >> 32)
                     + ((unsigned int)((unsigned __int64)(1431655766i64 * (v6 + 2 * v3)) >> 32) >> 31);
  v7 = *(_BYTE *)(a3 + 6);
  *(_BYTE *)(a3 + 9) = ((unsigned __int64)(1431655766i64 * (v5 + 2 * v4)) >> 32)
                     + ((unsigned int)((unsigned __int64)(1431655766i64 * (v5 + 2 * v4)) >> 32) >> 31);
  v8 = (unsigned __int64)(1431655766i64 * (v7 + 2 * *(_BYTE *)(a3 + 2))) >> 32;
  *(_BYTE *)(a3 + 10) = v8 + (v8 >> 31);
  v9 = (unsigned __int64)(1431655766i64 * (v3 + 2 * v6)) >> 32;
  *(_BYTE *)(a3 + 12) = v9 + (v9 >> 31);
  v10 = *(_BYTE *)(a3 + 6);
  *(_BYTE *)(a3 + 13) = ((unsigned __int64)(1431655766i64 * (v4 + 2 * v5)) >> 32)
                      + ((unsigned int)((unsigned __int64)(1431655766i64 * (v4 + 2 * v5)) >> 32) >> 31);
  v11 = (unsigned __int64)(1431655766i64 * (*(_BYTE *)(a3 + 2) + 2 * v10)) >> 32;
  result = v11 + (v11 >> 31);
  *(_BYTE *)(a3 + 14) = result;
  return result;
}

//----- (10069B00) --------------------------------------------------------
unsigned int __usercall sub_10069B00@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // esi@1
  char v4; // cl@1
  unsigned int result; // eax@1
  unsigned int v6; // ecx@1
  _BYTE *v7; // esi@1
  unsigned int v8; // edx@1
  int v9; // edi@2
  char v10; // [sp+8h] [bp-18h]@1
  char v11; // [sp+Ch] [bp-14h]@1
  char v12[16]; // [sp+10h] [bp-10h]@1

  v3 = a1;
  sub_10069310(a3, a2, 0x10u, &v10, &v11, (int)v12);
  v4 = v11;
  *(_BYTE *)v3 = v10;
  *(_BYTE *)(v3 + 1) = v4;
  result = 0;
  v6 = 0;
  v7 = (_BYTE *)(v3 + 2);
  v8 = 0;
  do
  {
    v9 = (unsigned __int8)v12[v8] << v6;
    v6 += 3;
    result |= v9;
    if ( v6 >= 8 )
    {
      *v7++ = result;
      result >>= 8;
      v6 -= 8;
    }
    ++v8;
  }
  while ( v8 < 0x10 );
  return result;
}
// 10069B00: using guessed type char var_10[16];

//----- (10069B70) --------------------------------------------------------
int __cdecl sub_10069B70(unsigned int a1, int a2, unsigned int a3, unsigned int a4, unsigned __int64 a5)
{
  int v5; // edi@1
  int v6; // ebx@1
  int v7; // esi@1
  int v8; // eax@1
  int v9; // ecx@1
  int v10; // edx@1
  unsigned int v11; // ecx@1
  _BYTE *v12; // ebp@2
  int v13; // eax@5
  signed int v14; // eax@6
  char *v15; // ST14_4@9
  int v16; // eax@9
  int v17; // ecx@9
  unsigned int v18; // et0@9
  int v19; // eax@9
  unsigned int v20; // eax@9
  unsigned __int64 v21; // kr18_8@9
  int result; // eax@11
  int v23; // [sp+18h] [bp-34h]@1
  int v24; // [sp+1Ch] [bp-30h]@1
  int v25; // [sp+20h] [bp-2Ch]@1
  int v26; // [sp+24h] [bp-28h]@1
  unsigned __int64 v27; // [sp+28h] [bp-24h]@1
  unsigned __int8 v28; // [sp+38h] [bp-14h]@1
  unsigned __int8 v29; // [sp+39h] [bp-13h]@1
  unsigned __int8 v30; // [sp+3Ah] [bp-12h]@1
  unsigned __int8 v31; // [sp+3Ch] [bp-10h]@1
  unsigned __int8 v32; // [sp+3Dh] [bp-Fh]@1
  unsigned __int8 v33; // [sp+3Eh] [bp-Eh]@1
  unsigned __int8 v34; // [sp+40h] [bp-Ch]@1
  unsigned __int8 v35; // [sp+41h] [bp-Bh]@1
  unsigned __int8 v36; // [sp+42h] [bp-Ah]@1
  unsigned __int8 v37; // [sp+44h] [bp-8h]@1
  unsigned __int8 v38; // [sp+45h] [bp-7h]@1
  unsigned __int8 v39; // [sp+46h] [bp-6h]@1

  sub_10069990(a4, a3, (int)&v28);
  v5 = v29 - v32;
  v6 = v30 - v33;
  v7 = v28 - v31;
  v8 = v7 * v34 + v5 * v35 + v6 * v36;
  v9 = v7 * v37 + v5 * v38 + v6 * v39;
  v25 = (v9 + v7 * v31 + v5 * v32 + v6 * v33) >> 1;
  v10 = (v8 + v9) >> 1;
  v11 = 0;
  v24 = v10;
  v26 = (v5 * v29 + v6 * v30 + v7 * v28 + v8) >> 1;
  v27 = 0i64;
  v23 = 0;
  if ( a1 )
  {
    v12 = (_BYTE *)(a2 + 2);
    while ( 1 )
    {
      if ( a3 == a4 )
      {
        v14 = 0;
      }
      else
      {
        v13 = v6 * *v12 + v7 * *(v12 - 2) + v5 * *(v12 - 1);
        if ( v13 >= v10 )
        {
          v11 = v27;
          v14 = v13 >= v26 ? 0 : 2;
        }
        else
        {
          v11 = v27;
          v14 = 2 * (v13 >= v25) + 1;
        }
      }
      v15 = (char *)(&v28 + 4 * v14);
      v16 = *(v12 - 1) - (unsigned __int8)v15[1];
      v18 = (v16 * v16
           + (*(v12 - 2) - (unsigned __int8)*v15) * (*(v12 - 2) - (unsigned __int8)*v15)
           + __PAIR__(HIDWORD(v27), v11)) >> 32;
      v17 = v16 * v16 + (*(v12 - 2) - (unsigned __int8)*v15) * (*(v12 - 2) - (unsigned __int8)*v15) + v11;
      v19 = *v12 - (unsigned __int8)v15[2];
      v21 = v19 * v19 + __PAIR__(v18, v17);
      v20 = v21 >> 32;
      v11 = v21;
      v27 = __PAIR__(v20, (unsigned int)v21);
      if ( __PAIR__(v20, (unsigned int)v21) >= a5 )
        break;
      v12 += 4;
      if ( ++v23 >= a1 )
        break;
      v10 = v24;
    }
    result = v21;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10069DA0) --------------------------------------------------------
char __cdecl sub_10069DA0(unsigned int a1, int a2, _DWORD *a3, _DWORD *a4, int a5, int a6)
{
  _BYTE *v6; // ebx@1
  unsigned int v7; // edi@1
  int v8; // ebp@2
  unsigned int v9; // esi@2
  char *v10; // esi@8
  int v11; // ecx@9
  int v12; // edx@9
  int v13; // esi@9
  char result; // al@12
  unsigned int v15; // ebx@13
  int v16; // eax@13
  double v17; // st6@13
  double v18; // st5@13
  double v19; // st4@13
  unsigned int v20; // edi@13
  double v21; // st7@13
  int v22; // ecx@14
  int v23; // edx@14
  int v24; // esi@14
  unsigned int v25; // edi@14
  int v26; // eax@14
  double v27; // st3@15
  double v28; // st2@15
  double v29; // st1@15
  int v30; // ST48_4@15
  double v31; // st6@15
  int v32; // ebx@15
  double v33; // st5@15
  double v34; // st4@15
  double v35; // st7@15
  double v36; // st3@15
  double v37; // st2@15
  double v38; // st1@15
  int v39; // ST48_4@15
  double v40; // st6@15
  int v41; // ebx@15
  double v42; // st5@15
  double v43; // st4@15
  double v44; // st7@15
  double v45; // st3@15
  double v46; // st2@15
  double v47; // st1@15
  double v48; // st6@15
  double v49; // st5@15
  int v50; // ST48_4@15
  double v51; // st4@15
  int v52; // ebx@15
  double v53; // st7@15
  double v54; // st3@15
  double v55; // st2@15
  double v56; // rt0@15
  int v57; // edx@18
  int v58; // esi@18
  int v59; // ebx@18
  _BYTE *v60; // eax@18
  int v61; // ecx@18
  double v62; // st3@19
  double v63; // st2@19
  int v64; // ST48_4@19
  double v65; // rt1@19
  double v66; // st6@21
  double v67; // st5@21
  double v68; // st4@21
  double v69; // st7@21
  double v70; // st3@21
  double v71; // st2@21
  double v72; // st1@21
  double v73; // ST38_8@21
  double v74; // ST28_8@21
  double v75; // ST48_8@21
  double v76; // st2@21
  double v77; // ST40_8@21
  double v78; // ST38_8@21
  double v79; // ST28_8@21
  double v80; // ST48_8@21
  double v81; // ST30_8@21
  double v82; // ST40_8@21
  double v83; // ST38_8@21
  double v84; // ST28_8@21
  double v85; // ST48_8@21
  double v86; // st2@21
  long double v87; // rt0@21
  long double v88; // st7@21
  double v89; // rt1@21
  double v90; // st2@21
  long double v91; // st6@21
  long double v92; // st5@21
  long double v93; // st4@21
  long double v94; // st3@21
  long double v95; // st3@23
  signed int v96; // esi@26
  signed int v97; // edi@26
  long double v98; // st4@27
  long double v99; // st5@27
  long double v100; // st6@27
  long double v101; // st7@27
  unsigned __int8 v102; // bl@28
  int v103; // ecx@28
  int v104; // edi@28
  char *v105; // edx@29
  int v106; // esi@30
  unsigned __int8 v107; // [sp+14h] [bp-78h]@28
  unsigned __int8 v108; // [sp+15h] [bp-77h]@28
  unsigned __int8 v109; // [sp+16h] [bp-76h]@28
  signed int i; // [sp+18h] [bp-74h]@2
  unsigned __int8 v111; // [sp+18h] [bp-74h]@28
  unsigned __int8 v112; // [sp+1Ah] [bp-72h]@28
  signed int v113; // [sp+20h] [bp-6Ch]@2
  signed int v114; // [sp+20h] [bp-6Ch]@26
  signed int v115; // [sp+28h] [bp-64h]@26
  __int64 v116; // [sp+30h] [bp-5Ch]@2
  int v117; // [sp+30h] [bp-5Ch]@14
  signed int v118; // [sp+30h] [bp-5Ch]@26
  int v119; // [sp+38h] [bp-54h]@29
  int v120; // [sp+40h] [bp-4Ch]@8
  int v121; // [sp+44h] [bp-48h]@9
  int v122; // [sp+48h] [bp-44h]@9
  int v123; // [sp+4Ch] [bp-40h]@8
  int v124; // [sp+50h] [bp-3Ch]@10
  int v125; // [sp+54h] [bp-38h]@11
  double v126; // [sp+78h] [bp-14h]@13
  double v127; // [sp+80h] [bp-Ch]@13

  v6 = (_BYTE *)a2;
  v7 = 0;
  do
  {
    v8 = *v6;
    v116 = *v6;
    v9 = 4;
    v113 = *v6;
    for ( i = *v6; v9 < 4 * a1; v9 += 4 )
    {
      v116 += v6[v9];
      if ( i >= v6[v9] )
        i = v6[v9];
      v8 = v113;
      if ( v113 <= v6[v9] )
      {
        v8 = v6[v9];
        v113 = v6[v9];
      }
    }
    v10 = (char *)&v123 + v7 * 4;
    *(int *)((char *)&v120 + v7 * 4) = v8;
    ++v7;
    ++v6;
    *(_DWORD *)&v10[a5 - (_DWORD)&v123] = (v116 + (a1 >> 1)) / a1;
    *(_DWORD *)v10 = i;
  }
  while ( v7 < 3 );
  v11 = v120;
  v12 = v122;
  v13 = v121;
  if ( v123 != v120 || v124 != v121 || v125 != v122 )
  {
    v15 = a1;
    v16 = a5;
    v17 = 0.0;
    v18 = 0.0;
    v19 = 0.0;
    v20 = 0;
    v21 = 0.0;
    v126 = 0.0;
    v127 = 0.0;
    if ( (signed int)a1 >= 4 )
    {
      v22 = *(_DWORD *)a5;
      v23 = *(_DWORD *)(a5 + 4);
      v24 = *(_DWORD *)(a5 + 8);
      v25 = ((a1 - 4) >> 2) + 1;
      v26 = a2 + 2;
      v117 = 4 * v25;
      do
      {
        v27 = (double)(*(_BYTE *)(v26 - 2) - v22);
        v28 = (double)(*(_BYTE *)(v26 - 1) - v23);
        v29 = (double)(*(_BYTE *)v26 - v24);
        v30 = *(_BYTE *)(v26 + 2) - v22;
        v31 = v17 + v27 * v27;
        v32 = *(_BYTE *)(v26 + 3) - v23;
        v33 = v18 + v28 * v27;
        v34 = v19 + v27 * v29;
        v35 = v21 + v28 * v28;
        v126 = v28 * v29 + v126;
        v127 = v29 * v29 + v127;
        v36 = (double)v30;
        v37 = (double)v32;
        v38 = (double)(*(_BYTE *)(v26 + 4) - v24);
        v39 = *(_BYTE *)(v26 + 6) - v22;
        v40 = v31 + v36 * v36;
        v41 = *(_BYTE *)(v26 + 7) - v23;
        v42 = v33 + v37 * v36;
        v43 = v34 + v36 * v38;
        v44 = v35 + v37 * v37;
        v126 = v37 * v38 + v126;
        v127 = v38 * v38 + v127;
        v45 = (double)v39;
        v46 = (double)v41;
        v47 = (double)(*(_BYTE *)(v26 + 8) - v24);
        v48 = v40 + v45 * v45;
        v49 = v42 + v46 * v45;
        v50 = *(_BYTE *)(v26 + 10) - v22;
        v51 = v43 + v45 * v47;
        v52 = *(_BYTE *)(v26 + 11) - v23;
        v26 += 16;
        v53 = v44 + v46 * v46;
        v126 = v46 * v47 + v126;
        v127 = v47 * v47 + v127;
        v54 = (double)v50;
        v55 = (double)v52;
        --v25;
        v17 = v48 + v54 * v54;
        v18 = v49 + v55 * v54;
        v56 = (double)(*(_BYTE *)(v26 - 4) - v24);
        v19 = v51 + v54 * v56;
        v21 = v53 + v55 * v55;
        v126 = v55 * v56 + v126;
        v127 = v56 * v56 + v127;
      }
      while ( v25 );
      v11 = v120;
      v16 = a5;
      v20 = v117;
      v12 = v122;
      v13 = v121;
      v15 = a1;
    }
    if ( v20 < v15 )
    {
      v57 = *(_DWORD *)v16;
      v58 = *(_DWORD *)(v16 + 4);
      v59 = *(_DWORD *)(v16 + 8);
      v60 = (_BYTE *)(a2 + 4 * v20 + 2);
      v61 = a1 - v20;
      do
      {
        v62 = (double)(*(v60 - 2) - v57);
        v63 = (double)(*(v60 - 1) - v58);
        v64 = *v60 - v59;
        v60 += 4;
        --v61;
        v17 = v17 + v62 * v62;
        v18 = v18 + v63 * v62;
        v65 = (double)v64;
        v19 = v19 + v62 * v65;
        v21 = v21 + v63 * v63;
        v126 = v63 * v65 + v126;
        v127 = v65 * v65 + v127;
      }
      while ( v61 );
      v13 = v121;
      v12 = v122;
      v11 = v120;
    }
    v66 = v17 * 0.003921568859368563;
    v67 = v18 * 0.003921568859368563;
    v68 = v19 * 0.003921568859368563;
    v69 = v21 * 0.003921568859368563;
    v70 = v126 * 0.003921568859368563;
    v127 = 0.003921568859368563 * v127;
    v71 = (double)(v11 - v123);
    v72 = (double)(v13 - v124);
    v73 = (double)(v12 - v125);
    v74 = v71 * v67 + v72 * v69 + v70 * v73;
    v75 = v72 * v70 + v68 * v71 + v127 * v73;
    v76 = v67 * v72 + v66 * v71 + v68 * v73;
    v77 = v74;
    v78 = v75;
    v79 = v74 * v69 + v67 * v76 + v75 * v70;
    v80 = v76 * v68 + v70 * v77 + v127 * v75;
    v81 = v67 * v77 + v66 * v76 + v68 * v78;
    v82 = v79;
    v83 = v80;
    v84 = v79 * v69 + v67 * v81 + v80 * v70;
    v85 = v81 * v68 + v70 * v82 + v127 * v80;
    v86 = v67 * v82 + v66 * v81 + v68 * v83;
    v87 = v69 * v84 + v67 * v86 + v85 * v70;
    v88 = v85 * v127 + v70 * v84 + v68 * v86;
    v89 = v86;
    v90 = v66;
    v91 = v87;
    v92 = v89 * v90 + v67 * v84 + v68 * v85;
    v93 = fabs(v92);
    v94 = fabs(v87);
    if ( v94 >= v93 )
      v93 = v94;
    v95 = fabs(v88);
    if ( v95 >= v93 )
      v93 = v95;
    if ( v93 >= 4.0 )
    {
      v98 = 512.0 / v93;
      v99 = v92 * v98;
      v100 = v91 * v98;
      v101 = v88 * v98;
      v96 = (signed int)v99;
      v118 = (signed int)v99;
      v97 = (signed int)v100;
      v115 = (signed int)v100;
      v114 = (signed int)v101;
      *(float *)a6 = v99;
      *(float *)(a6 + 4) = v100;
      *(float *)(a6 + 8) = v101;
    }
    else
    {
      v96 = 148;
      v97 = 300;
      v118 = 148;
      v115 = 300;
      *(float *)a6 = 148.0;
      v114 = 58;
      *(float *)(a6 + 4) = 300.0;
      *(float *)(a6 + 8) = 58.0;
    }
    v107 = *(_BYTE *)a2;
    v111 = *(_BYTE *)a2;
    v108 = *(_BYTE *)(a2 + 1);
    v102 = *(_BYTE *)(a2 + 1);
    v103 = v114 * *(_BYTE *)(a2 + 2) + v97 * *(_BYTE *)(a2 + 1) + v96 * *(_BYTE *)a2;
    v104 = v114 * *(_BYTE *)(a2 + 2) + v97 * *(_BYTE *)(a2 + 1) + v96 * *(_BYTE *)a2;
    v109 = *(_BYTE *)(a2 + 2);
    v112 = *(_BYTE *)(a2 + 2);
    if ( a1 > 1 )
    {
      v105 = (char *)(a2 + 6);
      v119 = a1 - 1;
      do
      {
        v106 = v114 * (unsigned __int8)*v105 + v118 * (unsigned __int8)*(v105 - 2) + v115 * (unsigned __int8)*(v105 - 1);
        if ( v106 < v103 )
        {
          v107 = *(v105 - 2);
          v108 = *(v105 - 1);
          v103 = v114 * (unsigned __int8)*v105
               + v118 * (unsigned __int8)*(v105 - 2)
               + v115 * (unsigned __int8)*(v105 - 1);
          v109 = *v105;
        }
        if ( v106 > v104 )
        {
          v102 = *(v105 - 1);
          v111 = *(v105 - 2);
          v104 = v114 * (unsigned __int8)*v105
               + v118 * (unsigned __int8)*(v105 - 2)
               + v115 * (unsigned __int8)*(v105 - 1);
          v112 = *v105;
        }
        v105 += 4;
        --v119;
      }
      while ( v119 );
    }
    *a3 = ((31 * v112 + 128 + ((31 * v112 + 128) >> 8)) >> 8)
        + (((63 * v102 + 128 + ((63 * v102 + 128) >> 8)) >> 3) & 0xFFFFFFE0)
        + (8 * (31 * v111 + 128 + ((31 * v111 + 128) >> 8)) & 0xFFFFF800);
    *a4 = ((31 * v109 + 128 + ((31 * v109 + 128) >> 8)) >> 8)
        + (((63 * v108 + 128 + ((63 * v108 + 128) >> 8)) >> 3) & 0xFFFFFFE0)
        + (8 * (31 * v107 + 128 + ((31 * v107 + 128) >> 8)) & 0xFFFFF800);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1006A500) --------------------------------------------------------
char __cdecl sub_1006A500(size_t a1, int a2, int a3, int a4, void *a5)
{
  size_t v5; // esi@1
  size_t v6; // ebx@1
  _BYTE *v7; // ecx@4
  int v8; // edi@5
  int v9; // eax@5
  char *v10; // edi@5
  __int64 v11; // rax@5
  unsigned __int8 v12; // cf@5
  __int64 v13; // rax@5
  unsigned int v14; // edi@6
  unsigned int v15; // eax@6
  unsigned int v16; // ebp@6
  unsigned int v17; // ecx@6
  unsigned int v18; // ebp@10
  int v19; // eax@11
  int v20; // edx@11
  int v21; // eax@12
  unsigned int v22; // ebx@14
  unsigned int v23; // edi@14
  size_t v24; // ecx@14
  int v25; // eax@15
  _BYTE *v26; // ebp@15
  int v27; // edx@16
  int v28; // ecx@22
  signed __int16 v29; // ax@23
  signed __int16 v30; // dx@23
  signed __int16 v31; // cx@23
  unsigned int *v32; // edi@29
  unsigned int *v33; // ebx@29
  signed __int16 v34; // ax@30
  signed __int16 v35; // dx@30
  signed __int16 v36; // cx@30
  int v37; // ebp@40
  int v38; // ebx@40
  size_t v39; // edi@40
  _BYTE *v40; // ecx@41
  int v41; // esi@42
  int v42; // eax@42
  char *v43; // esi@42
  unsigned int v44; // et0@42
  int v45; // eax@42
  unsigned int v46; // et0@42
  int v47; // edx@42
  char v49; // [sp+15h] [bp-93h]@1
  char v50; // [sp+16h] [bp-92h]@6
  unsigned __int8 v51; // [sp+17h] [bp-91h]@11
  unsigned __int8 v52; // [sp+18h] [bp-90h]@6
  unsigned __int8 v53; // [sp+19h] [bp-8Fh]@6
  unsigned __int8 v54; // [sp+1Ah] [bp-8Eh]@6
  char v55; // [sp+1Bh] [bp-8Dh]@6
  unsigned __int8 v56; // [sp+1Ch] [bp-8Ch]@6
  unsigned __int8 v57; // [sp+1Dh] [bp-8Bh]@6
  unsigned __int8 v58; // [sp+1Eh] [bp-8Ah]@6
  char v59; // [sp+1Fh] [bp-89h]@6
  int v60; // [sp+20h] [bp-88h]@3
  unsigned int v61; // [sp+24h] [bp-84h]@3
  int v62; // [sp+28h] [bp-80h]@3
  unsigned int v63; // [sp+2Ch] [bp-7Ch]@3
  __int64 v64; // [sp+30h] [bp-78h]@3
  unsigned int v65; // [sp+3Ch] [bp-6Ch]@6
  char v66; // [sp+40h] [bp-68h]@6
  char v67; // [sp+41h] [bp-67h]@6
  char v68; // [sp+42h] [bp-66h]@6
  char v69; // [sp+43h] [bp-65h]@6
  char v70; // [sp+44h] [bp-64h]@6
  char v71; // [sp+45h] [bp-63h]@6
  char v72; // [sp+46h] [bp-62h]@6
  char v73; // [sp+47h] [bp-61h]@6
  unsigned int v74; // [sp+48h] [bp-60h]@10
  char *v75; // [sp+4Ch] [bp-5Ch]@8
  int v76; // [sp+50h] [bp-58h]@1
  int v77; // [sp+54h] [bp-54h]@11
  int v78; // [sp+58h] [bp-50h]@12
  int v79; // [sp+5Ch] [bp-4Ch]@11
  int v80; // [sp+60h] [bp-48h]@14
  unsigned int v81; // [sp+64h] [bp-44h]@14
  unsigned int v82; // [sp+68h] [bp-40h]@14
  int v83; // [sp+6Ch] [bp-3Ch]@11
  unsigned __int64 v84; // [sp+70h] [bp-38h]@15
  int v85; // [sp+78h] [bp-30h]@16
  int v86; // [sp+7Ch] [bp-2Ch]@1
  int v87; // [sp+80h] [bp-28h]@1
  int v88; // [sp+84h] [bp-24h]@1
  char v89[16]; // [sp+88h] [bp-20h]@3
  char v90; // [sp+98h] [bp-10h]@38

  v5 = a1;
  v6 = 0;
  v49 = 0;
  v86 = 31;
  v87 = 63;
  v88 = 31;
  v76 = 0;
  while ( 1 )
  {
    sub_10069990(*(_DWORD *)a4, *(_DWORD *)a3, (int)v89);
    v60 = 0;
    v61 = 0;
    v62 = 0;
    v63 = 0;
    v64 = 0i64;
    if ( v5 > 0 )
    {
      v7 = (_BYTE *)(a2 + 2);
      do
      {
        v8 = *((_BYTE *)a5 + v6);
        v9 = *(v7 - 2) - (unsigned __int8)v89[4 * v8];
        v10 = &v89[4 * v8];
        v11 = v9 * v9;
        v12 = __CFADD__((_DWORD)v11, v60);
        v60 += v11;
        LODWORD(v11) = *(v7 - 1);
        v61 += HIDWORD(v11) + v12;
        v13 = (signed int)((v11 - (unsigned __int8)v10[1]) * (v11 - (unsigned __int8)v10[1]));
        v12 = __CFADD__((_DWORD)v13, v62);
        v62 += v13;
        LODWORD(v13) = *v7;
        v63 += HIDWORD(v13) + v12;
        v64 += (signed int)((v13 - (unsigned __int8)v10[2]) * (v13 - (unsigned __int8)v10[2]));
        ++v6;
        v7 += 4;
      }
      while ( v6 < v5 );
    }
    v14 = *(_WORD *)a3;
    v15 = *(_WORD *)a3;
    v53 = (v14 >> 5) & 0x3F;
    v16 = *(_WORD *)a4;
    v54 = v15 & 0x1F;
    v52 = v15 >> 11;
    v58 = v16 & 0x1F;
    v56 = v16 >> 11;
    v57 = (v16 >> 5) & 0x3F;
    v67 = 4 * v53 | (((v14 >> 5) & 0x3F) >> 4);
    v66 = 8 * (v14 >> 11) | (v14 >> 13);
    v68 = 8 * (v14 & 0x1F) | ((unsigned __int8)(v14 & 0x1F) >> 2);
    v55 = -1;
    v59 = -1;
    v69 = -1;
    v70 = 8 * v56 | (v16 >> 13);
    v71 = 4 * v57 | (((v16 >> 5) & 0x3F) >> 4);
    v72 = 8 * (v16 & 0x1F) | ((unsigned __int8)(v16 & 0x1F) >> 2);
    v17 = 0;
    v73 = -1;
    v50 = 0;
    v65 = 0;
    do
    {
      if ( *(&v61 + 2 * v17) | *(&v60 + 2 * v17) )
      {
        v75 = byte_100AF420;
        if ( v17 != 1 )
          v75 = byte_100AF460;
        v18 = 0;
        v74 = 0;
        do
        {
          *(&v79 + (v18 ^ 1)) = (unsigned __int8)*(&v66 + 4 * (v18 ^ 1) + v17);
          v19 = v17 + 4 * v18;
          v83 = v19;
          LOBYTE(v19) = *(&v52 + v19);
          v20 = -1;
          v77 = -1;
          v51 = v19;
          do
          {
            v21 = v20 + v51;
            v78 = v20 + v51;
            if ( v20 + v51 >= 0 && v21 <= *(&v86 + v17) )
            {
              *(&v79 + v18) = (unsigned __int8)v75[v21];
              v81 = (v80 + 2 * v79) / 3u;
              v22 = 0;
              v23 = 0;
              v24 = 0;
              v82 = (v79 + 2 * v80) / 3u;
              if ( v5 )
              {
                v25 = *(&v61 + 2 * v65);
                v26 = (_BYTE *)(a2 + v65);
                LODWORD(v84) = *(&v60 + 2 * v65);
                HIDWORD(v84) = v25;
                do
                {
                  v27 = *((_BYTE *)a5 + v24);
                  v85 = *v26;
                  v23 = ((*(&v79 + v27) - v85) * (*(&v79 + v27) - v85) + __PAIR__(v23, v22)) >> 32;
                  v22 += (*(&v79 + v27) - v85) * (*(&v79 + v27) - v85);
                  if ( __PAIR__(v23, v22) >= v84 )
                    break;
                  ++v24;
                  v26 += 4;
                }
                while ( v24 < v5 );
                v18 = v74;
              }
              if ( v23 <= *(&v61 + 2 * v65) && (v23 < *(&v61 + 2 * v65) || v22 < *(&v60 + 2 * v65)) )
              {
                v28 = v83;
                v51 = v78;
                *(&v52 + v83) = v78;
                *(&v66 + v28) = *((_BYTE *)&v79 + 4 * v18);
                if ( v18 )
                {
                  v29 = v56;
                  v30 = v57;
                  v31 = v58;
                  if ( v56 >= 0x1Fu )
                    v29 = 31;
                  if ( v57 >= 0x3Fu )
                    v30 = 63;
                  if ( v58 >= 0x1Fu )
                    v31 = 31;
                  v32 = (unsigned int *)a4;
                  v33 = (unsigned int *)a3;
                  *(_DWORD *)a4 = (unsigned __int16)v31 | (unsigned __int16)(32 * (v30 | (v29 << 6)));
                }
                else
                {
                  v34 = v52;
                  v35 = v53;
                  v36 = v54;
                  if ( v52 >= 0x1Fu )
                    v34 = 31;
                  if ( v53 >= 0x3Fu )
                    v35 = 63;
                  if ( v54 >= 0x1Fu )
                    v36 = 31;
                  v33 = (unsigned int *)a3;
                  v32 = (unsigned int *)a4;
                  *(_DWORD *)a3 = (unsigned __int16)v36 | (unsigned __int16)(32 * (v35 | (v34 << 6)));
                }
                if ( *v32 == *v33 )
                {
                  memset(a5, 0, v5);
                }
                else
                {
                  sub_10069990(*v32, *v33, (int)&v90);
                  sub_10068C20((int)&v90, v5, a2, a5);
                }
                sub_10069990(*v32, *v33, (int)v89);
                v37 = 0;
                v38 = 0;
                v39 = 0;
                v60 = 0;
                v61 = 0;
                v62 = 0;
                v63 = 0;
                v64 = 0i64;
                if ( v5 )
                {
                  v40 = (_BYTE *)(a2 + 2);
                  do
                  {
                    v41 = *((_BYTE *)a5 + v39);
                    v42 = *(v40 - 2) - (unsigned __int8)v89[4 * v41];
                    v43 = &v89[4 * v41];
                    v44 = (v42 * v42 + __PAIR__(v61, v37)) >> 32;
                    v37 += v42 * v42;
                    v61 = v44;
                    v45 = *(v40 - 1) - (unsigned __int8)v43[1];
                    v46 = (v45 * v45 + __PAIR__(v63, v38)) >> 32;
                    v38 += v45 * v45;
                    v63 = v46;
                    v47 = (unsigned __int8)v43[2];
                    v5 = a1;
                    v64 += (*v40 - v47) * (*v40 - v47);
                    ++v39;
                    v40 += 4;
                  }
                  while ( v39 < a1 );
                  v62 = v38;
                  v60 = v37;
                }
                v18 = v74;
                v50 = 1;
              }
              v17 = v65;
            }
            v20 = v77 + 2;
            v77 = v20;
          }
          while ( v20 <= 1 );
          v74 = ++v18;
        }
        while ( v18 < 2 );
      }
      v65 = ++v17;
    }
    while ( v17 < 3 );
    if ( !v50 )
      break;
    v49 = 1;
    if ( (unsigned int)++v76 >= 2 )
      break;
    v6 = 0;
  }
  return v49;
}
// 1006A500: using guessed type char var_20[16];

//----- (1006AA20) --------------------------------------------------------
char __usercall sub_1006AA20@<al>(int a1@<eax>, size_t a2, int a3, int a4, int a5, void *a6)
{
  int v6; // esi@1
  int v7; // eax@1
  unsigned int v8; // edx@1
  int v9; // edi@1
  unsigned int v10; // eax@1
  float v11; // ST64_4@2
  float v12; // ST64_4@2
  float v13; // ST64_4@2
  double v14; // st5@2
  double v15; // st7@2
  unsigned int v16; // eax@3
  char v17; // bl@3
  unsigned int v18; // ecx@3
  char v19; // si@3
  unsigned int v20; // ebx@3
  signed int v21; // eax@4
  signed int v22; // esi@5
  signed int v23; // eax@8
  signed int v24; // edi@9
  float v25; // ST60_4@12
  signed int v26; // eax@12
  unsigned int v27; // edi@17
  signed int v28; // eax@18
  signed int v29; // esi@19
  signed int v30; // eax@22
  signed int v31; // ebx@23
  float v32; // ST60_4@26
  signed int v33; // eax@26
  unsigned int v34; // eax@31
  unsigned __int8 v35; // al@31
  unsigned __int8 v36; // si@31
  signed __int64 v37; // rax@31
  int v38; // esi@31
  int v39; // eax@32
  unsigned int v40; // eax@33
  unsigned int v41; // ebx@33
  unsigned __int8 v42; // al@35
  unsigned __int8 v43; // si@35
  signed __int64 v44; // rax@35
  int v45; // esi@35
  int v46; // edi@35
  int *v47; // esi@35
  int v48; // eax@35
  int v49; // edi@36
  unsigned int v50; // edx@36
  unsigned int v51; // esi@36
  unsigned int v52; // edi@36
  unsigned __int64 v53; // rax@36
  unsigned int v54; // eax@40
  char v55; // bl@40
  int v56; // edx@46
  bool v57; // zf@47
  float v59; // [sp+50h] [bp-138h]@4
  float v60; // [sp+50h] [bp-138h]@8
  float v61; // [sp+50h] [bp-138h]@18
  float v62; // [sp+50h] [bp-138h]@22
  unsigned int v63; // [sp+50h] [bp-138h]@31
  unsigned int v64; // [sp+54h] [bp-134h]@2
  unsigned int v65; // [sp+58h] [bp-130h]@3
  float v66; // [sp+5Ch] [bp-12Ch]@2
  float v67; // [sp+60h] [bp-128h]@2
  float v68; // [sp+64h] [bp-124h]@2
  unsigned int v69; // [sp+68h] [bp-120h]@3
  float v70; // [sp+6Ch] [bp-11Ch]@2
  float v71; // [sp+70h] [bp-118h]@2
  float v72; // [sp+74h] [bp-114h]@2
  float v73; // [sp+78h] [bp-110h]@2
  float v74; // [sp+7Ch] [bp-10Ch]@2
  float v75; // [sp+80h] [bp-108h]@2
  unsigned int v76; // [sp+84h] [bp-104h]@33
  unsigned int v77; // [sp+88h] [bp-100h]@32
  float v78; // [sp+8Ch] [bp-FCh]@3
  float v79; // [sp+90h] [bp-F8h]@3
  float v80; // [sp+94h] [bp-F4h]@3
  unsigned __int64 v81; // [sp+98h] [bp-F0h]@2
  __int64 v82; // [sp+A0h] [bp-E8h]@35
  float v83; // [sp+A8h] [bp-E0h]@3
  float v84; // [sp+ACh] [bp-DCh]@3
  float v85; // [sp+B0h] [bp-D8h]@3
  float v86; // [sp+B4h] [bp-D4h]@3
  float v87; // [sp+B8h] [bp-D0h]@3
  float v88; // [sp+BCh] [bp-CCh]@3
  unsigned int v89; // [sp+C0h] [bp-C8h]@32
  unsigned int v90; // [sp+C4h] [bp-C4h]@35
  int v91; // [sp+C8h] [bp-C0h]@31
  int v92; // [sp+CCh] [bp-BCh]@31
  int v93; // [sp+D0h] [bp-B8h]@31
  int v94; // [sp+D4h] [bp-B4h]@31
  int v95; // [sp+D8h] [bp-B0h]@31
  int v96; // [sp+DCh] [bp-ACh]@31
  int v97; // [sp+E0h] [bp-A8h]@31
  int v98; // [sp+E4h] [bp-A4h]@31
  char v99; // [sp+E8h] [bp-A0h]@43
  int v100[18]; // [sp+F8h] [bp-90h]@16
  int v101[18]; // [sp+140h] [bp-48h]@30

  v6 = a1;
  v7 = sub_10069B70(a2, a3, *(_DWORD *)a4, *(_DWORD *)a5, 0xFFFFFFFFFFFFFFFFui64);
  v9 = v7;
  v10 = v8 | v7;
  if ( v10 )
  {
    v11 = *(float *)(v6 + 4) * *(float *)(v6 + 4)
        + *(float *)v6 * *(float *)v6
        + *(float *)(v6 + 8) * *(float *)(v6 + 8);
    v12 = sqrt(v11);
    v81 = __PAIR__(v8, v9);
    v13 = 1.0 / v12;
    v14 = v13;
    v15 = *(float *)v6 * v13;
    v64 = 0;
    v66 = v15;
    v67 = *(float *)(v6 + 4) * v14;
    v68 = v14 * *(float *)(v6 + 8);
    v70 = v66 * 0.02706329338252544;
    v71 = v67 * 0.02706329338252544;
    v72 = 0.02706329338252544 * v68;
    v70 = v70 * 31.0;
    v71 = v71 * 63.0;
    v72 = 31.0 * v72;
    v73 = v70 * -8.0;
    v74 = v71 * -8.0;
    v75 = -8.0 * v72;
    v73 = v73 + 0.5;
    v74 = v74 + 0.5;
    v75 = v75 + 0.5;
    do
    {
      v16 = *(_WORD *)a4;
      v17 = *(_WORD *)a4;
      v18 = *(_WORD *)a5;
      v19 = *(_WORD *)a5;
      v69 = v18 >> 11;
      v86 = (double)(unsigned __int8)(v16 >> 11);
      v87 = (double)((v16 >> 5) & 0x3F);
      v65 = v19 & 0x1F;
      v88 = (double)(v17 & 0x1F);
      v83 = (double)(unsigned __int8)(v18 >> 11);
      v20 = 0;
      v84 = (double)((v18 >> 5) & 0x3F);
      v85 = (double)(signed int)v65;
      v78 = v73 + v86;
      v79 = v74 + v87;
      v80 = v75 + v88;
      do
      {
        v59 = floor(v78);
        v21 = (signed int)v59;
        if ( v21 >= 0 )
        {
          v22 = 31;
          if ( v21 <= 31 )
            v22 = (signed int)v59;
        }
        else
        {
          v22 = 0;
        }
        v60 = floor(v79);
        v23 = (signed int)v60;
        if ( v23 >= 0 )
        {
          v24 = 63;
          if ( v23 <= 63 )
            v24 = (signed int)v60;
        }
        else
        {
          v24 = 0;
        }
        v25 = floor(v80);
        v26 = (signed int)v25;
        if ( v26 >= 0 )
        {
          if ( v26 > 31 )
            v26 = 31;
        }
        else
        {
          v26 = 0;
        }
        v78 = v70 + v78;
        v100[v20++] = v26 | 32 * (v24 | (v22 << 6));
        v79 = v71 + v79;
        v80 = v72 + v80;
      }
      while ( v20 < 0x11 );
      v27 = 0;
      v66 = v73 + v83;
      v67 = v74 + v84;
      v68 = v75 + v85;
      do
      {
        v61 = floor(v66);
        v28 = (signed int)v61;
        if ( v28 >= 0 )
        {
          v29 = 31;
          if ( v28 <= 31 )
            v29 = (signed int)v61;
        }
        else
        {
          v29 = 0;
        }
        v62 = floor(v67);
        v30 = (signed int)v62;
        if ( v30 >= 0 )
        {
          v31 = 63;
          if ( v30 <= 63 )
            v31 = (signed int)v62;
        }
        else
        {
          v31 = 0;
        }
        v32 = floor(v68);
        v33 = (signed int)v32;
        if ( v33 >= 0 )
        {
          if ( v33 > 31 )
            v33 = 31;
        }
        else
        {
          v33 = 0;
        }
        v66 = v70 + v66;
        v101[v27++] = v33 | 32 * (v31 | (v29 << 6));
        v67 = v71 + v67;
        v68 = v72 + v68;
      }
      while ( v27 < 0x11 );
      v34 = *(_DWORD *)a4;
      v69 = *(_DWORD *)a5;
      v63 = v34;
      v91 = 0;
      v93 = 0;
      v95 = 0;
      v97 = 0;
      v92 = 0;
      v94 = 0;
      v96 = 0;
      v98 = 0;
      v65 = v34 | (v69 << 16);
      v35 = sub_1005B000(4, (int)&v65);
      v36 = v35;
      v37 = 1i64 << (v35 & 0x3F);
      v38 = v36 >> 6;
      *(&v91 + 2 * v38) = v37;
      *(&v92 + 2 * v38) = HIDWORD(v37);
      v65 = 0;
      do
      {
        v39 = v100[v65];
        v77 = 0;
        v89 = v39;
        do
        {
          v40 = v101[v77];
          v41 = v89;
          v76 = v40;
          if ( v89 < v40 )
          {
            v76 = v89;
            v41 = v40;
            v40 = v89;
          }
          v90 = v41 | (v40 << 16);
          v42 = sub_1005B000(4, (int)&v90);
          v43 = v42;
          v44 = 1i64 << (v42 & 0x3F);
          v45 = v43 >> 6;
          v46 = *(&v91 + 2 * v45);
          v47 = &v91 + 2 * v45;
          v82 = v44;
          v48 = v47[1];
          if ( !(HIDWORD(v44) & v48 | (unsigned int)v82 & v46) )
          {
            v49 = v82 | v46;
            v50 = v81;
            v47[1] = HIDWORD(v82) | v48;
            *v47 = v49;
            v51 = HIDWORD(v81);
            v52 = v76;
            LODWORD(v53) = sub_10069B70(a2, a3, v41, v76, __PAIR__(HIDWORD(v81), v50));
            if ( v53 < __PAIR__(v51, (unsigned int)v81) )
            {
              v63 = v41;
              v69 = v52;
              v81 = v53;
            }
          }
          ++v77;
        }
        while ( v77 < 0x11 );
        ++v65;
      }
      while ( v65 < 0x11 );
      v54 = v69;
      v55 = 0;
      if ( v63 != *(_DWORD *)a4 || v69 != *(_DWORD *)a5 )
      {
        *(_DWORD *)a4 = v63;
        *(_DWORD *)a5 = v54;
        if ( v54 == *(_DWORD *)a4 )
        {
          memset(a6, 0, a2);
        }
        else
        {
          sub_10069990(v54, *(_DWORD *)a4, (int)&v99);
          sub_10068C20((int)&v99, a2, a3, a6);
        }
        v55 = 1;
      }
      LOBYTE(v10) = sub_1006A500(a2, a3, a4, a5, a6);
      if ( (_BYTE)v10 )
      {
        v10 = v56 | sub_10069B70(a2, a3, *(_DWORD *)a4, *(_DWORD *)a5, 0xFFFFFFFFFFFFFFFFui64);
        v57 = v10 == 0;
      }
      else
      {
        v57 = v55 == 0;
      }
      if ( v57 )
        break;
      v10 = v64 + 1;
      v64 = v10;
    }
    while ( v10 < 4 );
  }
  return v10;
}
// 1006AA20: using guessed type int var_90[18];
// 1006AA20: using guessed type int var_48[18];

//----- (1006B0B0) --------------------------------------------------------
unsigned int __usercall sub_1006B0B0@<eax>(unsigned int *a1@<ebx>, _BYTE *a2@<edi>, unsigned int a3@<esi>, int a4, unsigned int *a5, char a6)
{
  int v6; // ecx@3
  int v7; // ecx@8
  unsigned int result; // eax@12
  char v9; // [sp+8h] [bp-28h]@1
  char v10; // [sp+14h] [bp-1Ch]@1
  char v11; // [sp+20h] [bp-10h]@3

  if ( !sub_10069DA0(a3, a4, a5, a1, (int)&v9, (int)&v10) )
    goto LABEL_4;
  if ( *a1 == *a5 )
  {
    memset(a2, 0, a3);
    goto LABEL_4;
  }
  sub_10069990(*a1, *a5, (int)&v11);
  if ( !sub_10068C20(v6, a3, a4, a2) )
  {
LABEL_4:
    sub_10068BB0(a2, (int)&v9, a3, (int)a5, (int)a1);
    goto LABEL_12;
  }
  if ( sub_10069400((int)a2, a3, a4, (int *)a5, (int *)a1) )
  {
    if ( *a1 == *a5 )
    {
      memset(a2, 0, a3);
    }
    else
    {
      sub_10069990(*a1, *a5, (int)&v11);
      sub_10068C20(v7, a3, a4, a2);
    }
  }
  if ( a6 )
    sub_1006AA20((int)&v10, a3, a4, (int)a5, (int)a1, a2);
LABEL_12:
  result = *a5;
  if ( *a5 < *a1 )
  {
    *a5 = *a1;
    *a1 = result;
    result = 0;
    if ( a3 )
    {
      do
        a2[result++] ^= 1u;
      while ( result < a3 );
    }
  }
  return result;
}

//----- (1006B1B0) --------------------------------------------------------
unsigned int __usercall sub_1006B1B0@<eax>(char a1@<al>, int a2@<edx>, int a3)
{
  int v3; // ebp@1
  char v4; // ah@1
  char v5; // ah@1
  unsigned int v6; // ecx@1
  char *v7; // eax@1
  signed int v8; // edx@1
  unsigned int result; // eax@3
  int v10; // [sp+14h] [bp-14h]@1
  char v11; // [sp+18h] [bp-10h]@1
  char v12; // [sp+26h] [bp-2h]@1

  v3 = a3;
  sub_1006B0B0((unsigned int *)&v10, &v11, 0x10u, a2, (unsigned int *)&a3, a1);
  v4 = BYTE1(a3);
  *(_BYTE *)v3 = a3;
  *(_BYTE *)(v3 + 1) = v4;
  v5 = BYTE1(v10);
  *(_BYTE *)(v3 + 2) = v10;
  *(_BYTE *)(v3 + 3) = v5;
  v6 = 0;
  v7 = &v12;
  v8 = 4;
  do
  {
    v6 = 4 * ((unsigned __int8)*(v7 - 1) | 4 * ((unsigned __int8)*v7 | 4 * (4 * v6 | (unsigned __int8)v7[1]))) | (unsigned __int8)*(v7 - 2);
    v7 -= 4;
    --v8;
  }
  while ( v8 );
  *(_BYTE *)(v3 + 4) = v6;
  result = v6 >> 16;
  *(_BYTE *)(v3 + 5) = BYTE1(v6);
  *(_BYTE *)(v3 + 6) = v6 >> 16;
  *(_BYTE *)(v3 + 7) = BYTE3(v6);
  return result;
}

//----- (1006B290) --------------------------------------------------------
char __userpurge sub_1006B290@<al>(unsigned int a1@<ecx>, int a2@<esi>, int a3)
{
  int (__cdecl *v3)(unsigned int, int); // edi@1
  unsigned int v4; // eax@3
  int v5; // ecx@6
  unsigned int v6; // edx@6
  char result; // al@6

  v3 = *(int (__cdecl **)(unsigned int, int))(a2 + 1596);
  if ( !v3
    || (!a1 ? (v4 = 100) : (v4 = *(_DWORD *)(a2 + 20) + ((a1 >> 1) + a3 * *(_DWORD *)(a2 + 24)) / a1),
        v4 == *(_DWORD *)(a2 + 1624)
     || (v5 = *(_DWORD *)(a2 + 1600),
         v6 = v4 * *(_DWORD *)(a2 + 1608),
         *(_DWORD *)(a2 + 1624) = v4,
         (result = v3(*(_DWORD *)(a2 + 1604) + v6 / 0x64, v5)) != 0)) )
  {
    result = 1;
  }
  else
  {
    *(_BYTE *)(a2 + 16) = 1;
  }
  return result;
}

//----- (1006B310) --------------------------------------------------------
char __cdecl sub_1006B310(int a1, int a2)
{
  int (__cdecl *v2)(unsigned int, int); // ecx@1
  unsigned int v3; // edx@2
  unsigned int v4; // edi@3
  int v5; // ST04_4@3
  char result; // al@3

  v2 = *(int (__cdecl **)(unsigned int, int))(a2 + 1596);
  if ( !v2
    || (v3 = *(_DWORD *)(a2 + 20) + (a1 * *(_DWORD *)(a2 + 24) + 50) / 0x64u, v3 == *(_DWORD *)(a2 + 1624))
    || (v4 = v3 * *(_DWORD *)(a2 + 1608),
        v5 = *(_DWORD *)(a2 + 1600),
        *(_DWORD *)(a2 + 1624) = v3,
        (result = v2(*(_DWORD *)(a2 + 1604) + v4 / 0x64, v5)) != 0) )
  {
    result = 1;
  }
  else
  {
    *(_BYTE *)(a2 + 16) = 1;
  }
  return result;
}

//----- (1006B380) --------------------------------------------------------
int __thiscall sub_1006B380(_DWORD *this, int a2, int a3, int a4)
{
  _DWORD *v4; // esi@1
  unsigned int v5; // ebx@1
  int v6; // edi@1
  int v7; // eax@1
  int v8; // eax@8
  int v9; // edi@10
  unsigned int v10; // ebx@11
  _DWORD *v11; // ecx@18
  int v12; // eax@18
  int v13; // esi@18
  unsigned int v14; // eax@18
  bool v15; // cf@18
  int *v16; // esi@18
  unsigned int v17; // edi@24
  unsigned int v18; // esi@28
  unsigned __int64 v19; // rax@29
  int v20; // eax@30
  int v21; // edx@30
  int v22; // eax@30
  _DWORD *v23; // ebx@30
  int v24; // edx@31
  unsigned int v25; // esi@31
  unsigned int v26; // ecx@31
  int v27; // eax@34
  unsigned int v28; // edx@39
  int v29; // esi@39
  int v30; // eax@41
  unsigned int v31; // eax@45
  __int16 v32; // si@46
  int v33; // edi@46
  int v34; // ecx@47
  int v35; // eax@51
  int *v37; // [sp-10h] [bp-D0h]@52
  void (__thiscall *v38)(void *); // [sp-4h] [bp-C4h]@52
  _DWORD *v39; // [sp+10h] [bp-B0h]@1
  int *v40; // [sp+14h] [bp-ACh]@23
  unsigned int v41; // [sp+18h] [bp-A8h]@25
  int v42; // [sp+1Ch] [bp-A4h]@18
  signed int v43; // [sp+1Ch] [bp-A4h]@23
  int v44; // [sp+20h] [bp-A0h]@25
  int *v45; // [sp+24h] [bp-9Ch]@28
  int v46; // [sp+28h] [bp-98h]@25
  int v47; // [sp+2Ch] [bp-94h]@23
  int v48; // [sp+30h] [bp-90h]@23
  int v49; // [sp+34h] [bp-8Ch]@2
  unsigned __int64 v50; // [sp+38h] [bp-88h]@29
  unsigned int v51; // [sp+44h] [bp-7Ch]@1
  unsigned int v52; // [sp+48h] [bp-78h]@28
  unsigned int v53; // [sp+4Ch] [bp-74h]@28
  unsigned __int64 v54; // [sp+50h] [bp-70h]@28
  unsigned int v55; // [sp+5Ch] [bp-64h]@29
  int v56; // [sp+60h] [bp-60h]@1
  int v57; // [sp+64h] [bp-5Ch]@11
  int v58; // [sp+68h] [bp-58h]@18
  int v59; // [sp+6Ch] [bp-54h]@1
  unsigned int v60; // [sp+70h] [bp-50h]@13
  int v61; // [sp+78h] [bp-48h]@30
  int v62; // [sp+7Ch] [bp-44h]@30
  unsigned int v63; // [sp+80h] [bp-40h]@24
  int v64; // [sp+84h] [bp-3Ch]@30
  int v65; // [sp+88h] [bp-38h]@30
  int v66; // [sp+8Ch] [bp-34h]@31
  unsigned int v67; // [sp+90h] [bp-30h]@28
  unsigned int v68; // [sp+94h] [bp-2Ch]@33
  unsigned int v69; // [sp+98h] [bp-28h]@33
  unsigned int v70; // [sp+9Ch] [bp-24h]@33
  unsigned int v71; // [sp+A0h] [bp-20h]@33
  unsigned int v72; // [sp+A4h] [bp-1Ch]@33
  int v73; // [sp+A8h] [bp-18h]@33
  int v74; // [sp+ACh] [bp-14h]@33
  int v75; // [sp+BCh] [bp-4h]@1

  v4 = this;
  v39 = this;
  `eh vector constructor iterator'(&v56, 0xCu, 2, (int)unknown_libname_3, sub_10038C00);
  v5 = 0;
  v75 = 0;
  sub_10036310((int)&v56, 0x800u);
  sub_10036310((int)&v59, 0x800u);
  v6 = a4;
  v7 = *(_DWORD *)(*(_DWORD *)a4 + 4);
  v51 = 0;
  if ( v7 )
  {
    v49 = 0;
    while ( 1 )
    {
      if ( *((_BYTE *)v4 + 16) )
      {
        v38 = sub_10038C00;
        v37 = &v56;
        goto LABEL_53;
      }
      if ( !(_BYTE)v5
        && GetCurrentThreadId() == v4[2]
        && 0 == v4[3]
        && !sub_1006B290(*(_DWORD *)(*(_DWORD *)v6 + 4) - 1, (int)v4, v5) )
      {
        break;
      }
      v8 = *(_DWORD *)(*v4 + 4);
      if ( !v8 || v5 % (v8 + 1) == a2 )
      {
        v9 = v49 + **(_DWORD **)a4;
        if ( *(_DWORD *)(v9 + 4) > 1u )
        {
          v10 = 0;
          if ( v57 )
            v57 = 0;
          if ( v60 )
          {
            if ( v60 <= 0 )
              memset((void *)(v59 + 4 * v60), 0, -4 * v60);
            v60 = 0;
          }
          if ( *(_DWORD *)(v9 + 4) <= 0u )
          {
            v11 = v39;
          }
          else
          {
            do
            {
              v11 = v39;
              v42 = *(_DWORD *)(*(_DWORD *)v9 + 4 * v10);
              v12 = v39[9] + 8 * *(_DWORD *)(*(_DWORD *)v9 + 4 * v10) * v39[10];
              v13 = -3 * (*(_BYTE *)(v12 + 1) < *(_BYTE *)v12) + 3;
              v14 = *(&v57 + v13);
              v15 = v14 < *(&v58 + v13);
              v16 = &v56 + v13;
              if ( !v15 )
              {
                sub_100943C0(v14 + 1, 0, (int)v16, 1, 4u, 0);
                v11 = v39;
              }
              *(_DWORD *)(*v16 + 4 * v16[1]++) = v42;
              ++v10;
            }
            while ( v10 < *(_DWORD *)(v9 + 4) );
          }
          v47 = 0;
          v48 = 0;
          v40 = &v56;
          v43 = 2;
          do
          {
            v17 = v40[1];
            v63 = v17;
            if ( v17 > 1 )
            {
              v46 = 0;
              v44 = 0;
              v41 = 0;
              while ( 1 )
              {
                while ( 1 )
                {
                  v18 = 0;
                  v52 = 0;
                  v54 = 0xFFFFFFFFFFi64;
                  v53 = 0;
                  v45 = (int *)&v67;
                  do
                  {
                    v19 = 0i64;
                    v50 = 0i64;
                    v55 = 0;
                    if ( v17 )
                    {
                      v20 = v11[10];
                      v65 = v11[8];
                      v21 = v11[9];
                      v64 = v20;
                      v22 = v11[403];
                      v23 = (_DWORD *)*v40;
                      v62 = v21;
                      v61 = v22;
                      do
                      {
                        v24 = *v23 * v64;
                        v25 = *(_BYTE *)(v62 + 8 * v24);
                        v66 = v65 + 4 * (v44 + 4 * (v46 + 4 * *v23));
                        v26 = *(_BYTE *)(v62 + 8 * v24 + 1);
                        if ( v25 <= v26 )
                        {
                          v69 = (v26 + 4 * v25) / 5;
                          v70 = (3 * v25 + 2 * v26) / 5;
                          v68 = v26;
                          v71 = (3 * v26 + 2 * v25) / 5;
                          v67 = v25;
                          v72 = (v25 + 4 * v26) / 5;
                          v73 = 0;
                          v74 = 255;
                        }
                        else
                        {
                          sub_10092180(v26);
                          v17 = v63;
                        }
                        v27 = *(_BYTE *)(v61 + v66) - *v45;
                        v50 += v27 * v27;
                        ++v23;
                        ++v55;
                      }
                      while ( v55 < v17 );
                      v11 = v39;
                      v18 = v53;
                      v19 = v50;
                    }
                    if ( v19 < v54 )
                    {
                      v54 = v19;
                      v52 = v18;
                    }
                    ++v45;
                    v53 = ++v18;
                  }
                  while ( v18 < 8 );
                  v28 = v41 >> 3;
                  v29 = *((_BYTE *)&v47 + (v41 >> 3) + 2);
                  if ( v41 >> 3 < 5 )
                    v29 |= *((_BYTE *)&v47 + v28 + 3) << 8;
                  v30 = (v52 << (v41 & 7)) | v29 & ~(7 << (v41 & 7));
                  *((_BYTE *)&v47 + v28 + 2) = v30;
                  if ( v28 < 5 )
                    *((_BYTE *)&v47 + v28 + 3) = BYTE1(v30);
                  v41 += 3;
                  if ( (unsigned int)++v44 >= 4 )
                    break;
                  v11 = v39;
                }
                ++v46;
                if ( v41 >= 0x30 )
                  break;
                v11 = v39;
                v44 = 0;
              }
              v31 = 0;
              if ( v17 )
              {
                v32 = HIWORD(v48);
                v33 = *(int *)((char *)&v47 + 2);
                do
                {
                  v34 = v39[9] + 8 * *(_DWORD *)(*v40 + 4 * v31) * v39[10];
                  *(_DWORD *)(v34 + 2) = v33;
                  ++v31;
                  *(_WORD *)(v34 + 6) = v32;
                }
                while ( v31 < v40[1] );
              }
              v11 = v39;
            }
            v40 += 3;
            --v43;
          }
          while ( v43 );
          v5 = v51;
          v4 = v39;
        }
      }
      v6 = a4;
      v35 = *(_DWORD *)a4;
      v49 += 12;
      v51 = ++v5;
      if ( v5 >= *(_DWORD *)(v35 + 4) )
        goto LABEL_52;
    }
    v38 = sub_10038C00;
    v37 = &v56;
  }
  else
  {
LABEL_52:
    v38 = sub_10038C00;
    v37 = &v56;
  }
LABEL_53:
  v75 = -1;
  return `eh vector destructor iterator'(v37, 0xCu, 2, v38);
}
// 1003F6D0: using guessed type int unknown_libname_3();
// 10092180: using guessed type double __thiscall sub_10092180(_DWORD);

//----- (1006B870) --------------------------------------------------------
void __thiscall sub_1006B870(void *this, int a2, int a3, int a4)
{
  unsigned int v4; // ebx@1
  int v5; // esi@1
  int v6; // ecx@1
  char v7; // dl@1
  unsigned int v8; // ecx@1
  unsigned int v9; // edx@1
  int v10; // edx@3
  unsigned int v11; // edi@3
  int v12; // eax@11
  int v13; // edi@13
  unsigned int v14; // ecx@13
  unsigned int v15; // eax@13
  int v16; // ecx@19
  unsigned int v17; // eax@19
  void *v18; // edx@24
  int v19; // eax@25
  _BYTE *v20; // ecx@26
  char v21; // bl@26
  bool v22; // zf@26
  int v23; // eax@31
  unsigned int v24; // eax@32
  int v25; // eax@33
  char v26; // dl@33
  unsigned int v27; // esi@33
  unsigned int v28; // edi@34
  int v29; // edx@36
  unsigned int v30; // edi@38
  int v31; // edx@40
  unsigned int v32; // edi@42
  int v33; // ebx@42
  int v34; // edx@44
  unsigned int v35; // edi@46
  int v36; // edx@48
  void *v37; // eax@55
  unsigned int v38; // [sp+Ch] [bp-4CCh]@24
  int v39; // [sp+Ch] [bp-4CCh]@34
  int v40; // [sp+Ch] [bp-4CCh]@38
  unsigned int v41; // [sp+10h] [bp-4C8h]@13
  signed int v42; // [sp+10h] [bp-4C8h]@25
  void *v43; // [sp+10h] [bp-4C8h]@32
  int v44; // [sp+14h] [bp-4C4h]@34
  int v45; // [sp+14h] [bp-4C4h]@38
  int v46; // [sp+14h] [bp-4C4h]@46
  unsigned int v47; // [sp+18h] [bp-4C0h]@19
  unsigned int v48; // [sp+18h] [bp-4C0h]@32
  void *v49; // [sp+1Ch] [bp-4BCh]@1
  unsigned int v50; // [sp+20h] [bp-4B8h]@1
  unsigned int v51; // [sp+24h] [bp-4B4h]@1
  void *v52; // [sp+28h] [bp-4B0h]@1
  unsigned int v53; // [sp+2Ch] [bp-4ACh]@1
  unsigned int v54; // [sp+30h] [bp-4A8h]@1
  unsigned int v55; // [sp+34h] [bp-4A4h]@3
  int v56; // [sp+38h] [bp-4A0h]@4
  int v57; // [sp+3Ch] [bp-49Ch]@2
  int v58; // [sp+40h] [bp-498h]@30
  int v59; // [sp+44h] [bp-494h]@30
  int v60; // [sp+48h] [bp-490h]@1
  int v61; // [sp+4Ch] [bp-48Ch]@16
  int v62; // [sp+50h] [bp-488h]@22
  int v63; // [sp+54h] [bp-484h]@13
  unsigned int v64; // [sp+58h] [bp-480h]@1
  void *v65; // [sp+5Ch] [bp-47Ch]@1
  int v66; // [sp+60h] [bp-478h]@1
  int v67; // [sp+64h] [bp-474h]@1
  int v68; // [sp+68h] [bp-470h]@1
  char v69; // [sp+6Ch] [bp-46Ch]@1
  void *v70; // [sp+70h] [bp-468h]@29
  unsigned __int8 v71; // [sp+80h] [bp-458h]@30
  unsigned __int8 v72; // [sp+81h] [bp-457h]@30
  int v73; // [sp+88h] [bp-450h]@1
  int v74; // [sp+8Ch] [bp-44Ch]@1
  int v75; // [sp+90h] [bp-448h]@1
  int v76; // [sp+94h] [bp-444h]@1
  int v77; // [sp+98h] [bp-440h]@1
  int v78; // [sp+9Ch] [bp-43Ch]@1
  int v79; // [sp+A0h] [bp-438h]@1
  int v80; // [sp+A4h] [bp-434h]@1
  int v81; // [sp+A8h] [bp-430h]@1
  int v82; // [sp+ACh] [bp-42Ch]@1
  int v83; // [sp+B0h] [bp-428h]@1
  int v84; // [sp+B4h] [bp-424h]@1
  int v85; // [sp+B8h] [bp-420h]@1
  int v86; // [sp+BCh] [bp-41Ch]@1
  int v87; // [sp+4C0h] [bp-18h]@1
  int v88; // [sp+4C4h] [bp-14h]@1
  int v89; // [sp+4D4h] [bp-4h]@1

  v4 = 0;
  v5 = (int)this;
  v60 = (int)this;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v89 = 0;
  sub_10038B00((int)&v49, 0x400u);
  v52 = 0;
  v53 = 0;
  v54 = 0;
  LOBYTE(v89) = 1;
  sub_10032F10((int)&v52, 0x400u);
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v84 = 0;
  v85 = 0;
  v86 = 0;
  v87 = 0;
  v88 = 0;
  LOBYTE(v89) = 6;
  sub_10032F10((int)&v75, 0x10u);
  sub_10036310((int)&v78, 0x10u);
  LOBYTE(v89) = 7;
  v6 = *(_DWORD *)(v5 + 1612);
  v7 = *(_BYTE *)(v5 + 1616);
  v68 = *(_DWORD *)(v5 + 48);
  v69 = v7;
  v67 = v6;
  v8 = *(_DWORD *)(v5 + 1720);
  v64 = 0;
  v65 = 0;
  v66 = 0;
  v9 = ((((((((((((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1)) >> 8) | ((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1)) >> 4) | ((((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1)) >> 8) | ((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1)) >> 2) | ((((((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1)) >> 8) | ((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1)) >> 4) | ((((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1)) >> 8) | ((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1)) >> 1) | ((((((((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1)) >> 8) | ((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1)) >> 4) | ((((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1)) >> 8) | ((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1)) >> 2) | ((((((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1)) >> 8) | ((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1)) >> 4) | ((((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1)) >> 8) | ((v8 / 0x64 - 1) >> 16) | (v8 / 0x64 - 1))
      + 1) >> 1;
  if ( v9 <= 8 )
  {
    v57 = 8;
    v9 = 8;
  }
  v10 = v9 - 1;
  v11 = 0;
  v57 = v10;
  v55 = 0;
  if ( v8 <= 0 )
  {
LABEL_55:
    LOBYTE(v89) = 1;
    sub_10032BC0((int)&v73);
    LOBYTE(v89) = 0;
    v37 = v52;
    if ( !v52 )
      goto LABEL_62;
    if ( (unsigned __int8)v52 & 7 )
    {
      sub_100927E0((int)"crnlib_free: bad ptr");
      goto LABEL_62;
    }
LABEL_61:
    off_100AD9F4(v37, 0, 0, 1, dword_100AE9F4);
    goto LABEL_62;
  }
  v56 = 0;
  while ( *(_BYTE *)(v5 + 16) == (_BYTE)v4 )
  {
    if ( !(v11 & v10)
      && GetCurrentThreadId() == *(_DWORD *)(v5 + 8)
      && 0 == *(_DWORD *)(v5 + 12)
      && !sub_1006B290(*(_DWORD *)(v5 + 1720) - 1, v5, v11) )
    {
      goto LABEL_55;
    }
    v12 = *(_DWORD *)(*(_DWORD *)v5 + 4);
    if ( !v12 || v11 % (v12 + 1) == a2 )
    {
      v13 = v56 + *(_DWORD *)(v5 + 1716);
      v14 = v53;
      v15 = 16 * *(_DWORD *)(v13 + 4);
      v63 = v56 + *(_DWORD *)(v5 + 1716);
      v41 = v15;
      if ( v15 != v53 )
      {
        if ( v15 >= v53 )
        {
          if ( v15 > v54 )
          {
            LOBYTE(v61) = v15 == v53 + 1;
            sub_100943C0(v15, 0, (int)&v52, v15 == v53 + 1, 1u, 0);
            v15 = v41;
            v14 = v53;
          }
          memset((char *)v52 + v14, 0, v15 - v14);
          v15 = v41;
        }
        v53 = v15;
      }
      v16 = v50;
      v17 = 16 * *(_DWORD *)(v13 + 4);
      v47 = v17;
      if ( v17 != v50 )
      {
        if ( v17 >= v50 && v17 > v51 )
        {
          LOBYTE(v62) = v17 == v50 + 1;
          sub_100943C0(v17, 0, (int)&v49, v17 == v50 + 1, 4u, v4);
          v17 = v47;
        }
        v50 = v17;
        v16 = v17;
      }
      v18 = v49;
      v38 = 0;
      if ( *(_DWORD *)(v13 + 4) > 0u )
      {
        do
        {
          v42 = 16;
          v19 = *(_DWORD *)(v5 + 32) + (*(_DWORD *)(*(_DWORD *)v13 + 4 * v4) << 6) + 2;
          do
          {
            v20 = v18;
            *(_BYTE *)v18 = *(_BYTE *)(v19 - 2);
            *((_BYTE *)v18 + 1) = *(_BYTE *)(v19 - 1);
            *((_BYTE *)v18 + 2) = *(_BYTE *)v19;
            v21 = *(_BYTE *)(v19 + 1);
            v18 = (char *)v18 + 4;
            v19 += 4;
            v22 = v42-- == 1;
            v20[3] = v21;
          }
          while ( !v22 );
          v4 = v38 + 1;
          v38 = v4;
        }
        while ( v4 < *(_DWORD *)(v13 + 4) );
        v18 = v49;
        v16 = v50;
        v4 = 0;
      }
      v64 = v55;
      v66 = v16;
      v65 = v18;
      v70 = v52;
      if ( *(_DWORD *)(v5 + 48) )
      {
        sub_10093A30((int)&v73, (int)&v64, (int)&v70);
        v59 = v71;
        v58 = v72;
      }
      else
      {
        v23 = *(_DWORD *)(v5 + 1612);
        sub_10069310(v16, &v59, &v58, v52);
      }
      v24 = 0;
      v43 = v52;
      v48 = 0;
      if ( *(_DWORD *)(v13 + 4) > 0u )
      {
        do
        {
          v25 = *(_DWORD *)(v5 + 36) + 8 * *(_DWORD *)(*(_DWORD *)v13 + 4 * v24) * *(_DWORD *)(v5 + 40);
          v26 = v58;
          *(_BYTE *)v25 = v59;
          *(_BYTE *)(v25 + 1) = v26;
          v27 = 6;
          do
          {
            v28 = (v27 - 6) >> 3;
            v39 = (v27 - 6) & 7;
            v44 = *(_BYTE *)(v25 + v28 + 2);
            if ( v28 < 5 )
              v44 |= *(_BYTE *)(v28 + v25 + 3) << 8;
            v29 = (*(_BYTE *)v43 << v39) | v44 & ~(7 << v39);
            *(_BYTE *)(v25 + v28 + 2) = v29;
            if ( v28 < 5 )
              *(_BYTE *)(v28 + v25 + 3) = BYTE1(v29);
            v30 = (v27 - 3) >> 3;
            v40 = (v27 - 3) & 7;
            v45 = *(_BYTE *)(v25 + v30 + 2);
            if ( v30 < 5 )
              v45 |= *(_BYTE *)(v30 + v25 + 3) << 8;
            v31 = (*((_BYTE *)v43 + 1) << v40) | v45 & ~(7 << v40);
            *(_BYTE *)(v25 + v30 + 2) = v31;
            if ( v30 < 5 )
              *(_BYTE *)(v30 + v25 + 3) = BYTE1(v31);
            v32 = v27 >> 3;
            v33 = *(_BYTE *)(v25 + (v27 >> 3) + 2);
            if ( v27 >> 3 < 5 )
              v33 |= *(_BYTE *)(v32 + v25 + 3) << 8;
            v34 = (*((_BYTE *)v43 + 2) << (v27 & 7)) | v33 & ~(7 << (v27 & 7));
            *(_BYTE *)(v25 + v32 + 2) = v34;
            if ( v32 < 5 )
              *(_BYTE *)(v32 + v25 + 3) = BYTE1(v34);
            v35 = (v27 + 3) >> 3;
            v46 = *(_BYTE *)(v25 + v35 + 2);
            if ( v35 < 5 )
              v46 |= *(_BYTE *)(v35 + v25 + 3) << 8;
            v36 = (*((_BYTE *)v43 + 3) << ((v27 + 3) & 7)) | v46 & ~(7 << ((v27 + 3) & 7));
            *(_BYTE *)(v25 + v35 + 2) = v36;
            if ( v35 < 5 )
              *(_BYTE *)(v35 + v25 + 3) = BYTE1(v36);
            v43 = (char *)v43 + 4;
            v27 += 12;
          }
          while ( v27 < 0x36 );
          v13 = v63;
          v5 = v60;
          v24 = v48 + 1;
          v48 = v24;
        }
        while ( v24 < *(_DWORD *)(v63 + 4) );
        v4 = 0;
      }
      v11 = v55;
    }
    v56 += 12;
    v55 = ++v11;
    if ( v11 >= *(_DWORD *)(v5 + 1720) )
      goto LABEL_55;
    v10 = v57;
  }
  LOBYTE(v89) = 1;
  sub_10032BC0((int)&v73);
  LOBYTE(v89) = 0;
  v37 = v52;
  if ( v52 )
  {
    if ( (unsigned __int8)v52 & 7 )
    {
      sub_100927E0((int)"crnlib_free: bad ptr");
      goto LABEL_62;
    }
    goto LABEL_61;
  }
LABEL_62:
  v89 = -1;
  if ( v49 )
  {
    if ( (unsigned __int8)v49 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v49, 0, 0, 1, dword_100AE9F4);
  }
}
// 10069310: using guessed type double __cdecl sub_10069310(_DWORD, _DWORD, _DWORD, _DWORD);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1006BE80) --------------------------------------------------------
void __stdcall sub_1006BE80(int a1)
{
  int *v1; // ecx@1
  int v2; // eax@2

  sub_100388E0(a1 + 5184);
  `eh vector destructor iterator'((void *)(a1 + 2112), 0xCu, 256, sub_100371F0);
  `eh vector destructor iterator'((void *)(a1 + 1744), 0x58u, 4, sub_10036FD0);
  v1 = *(int **)(a1 + 1716);
  if ( v1 )
  {
    sub_1003E4E0(*(_DWORD *)(a1 + 1720), v1);
    v2 = *(_DWORD *)(a1 + 1716);
    if ( v2 )
    {
      if ( v2 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    }
  }
  sub_1003EAE0(a1 + 1628);
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1006BF60) --------------------------------------------------------
int __stdcall sub_1006BF60(int a1)
{
  int *v1; // ecx@1
  int v2; // eax@2
  int v3; // esi@7
  signed int v4; // edi@7
  int *v5; // eax@9
  int result; // eax@15

  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 255;
  *(_DWORD *)(a1 + 48) = 4;
  *(_DWORD *)(a1 + 1596) = 0;
  *(_DWORD *)(a1 + 1600) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 52) = 1;
  memset((void *)(a1 + 60), 0, 0x600u);
  *(_DWORD *)(a1 + 1612) = 3;
  *(_DWORD *)(a1 + 1604) = 0;
  *(_DWORD *)(a1 + 1608) = 100;
  *(_BYTE *)(a1 + 1616) = 1;
  sub_1003EC70(a1 + 1628);
  v1 = *(int **)(a1 + 1716);
  if ( v1 )
  {
    sub_1003E4E0(*(_DWORD *)(a1 + 1720), v1);
    v2 = *(_DWORD *)(a1 + 1716);
    if ( v2 )
    {
      if ( v2 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 1716) = 0;
    *(_DWORD *)(a1 + 1720) = 0;
    *(_DWORD *)(a1 + 1724) = 0;
  }
  *(_DWORD *)(a1 + 1620) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 100;
  sub_10037DB0(a1 + 1728);
  v3 = a1 + 2112;
  v4 = 256;
  do
  {
    if ( *(_DWORD *)v3 )
    {
      sub_1003E4E0(*(_DWORD *)(v3 + 4), *(int **)v3);
      v5 = *(int **)v3;
      if ( *(_DWORD *)v3 )
      {
        if ( (unsigned __int8)v5 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      }
      *(_DWORD *)v3 = 0;
      *(_DWORD *)(v3 + 4) = 0;
      *(_DWORD *)(v3 + 8) = 0;
    }
    v3 += 12;
    --v4;
  }
  while ( v4 );
  result = sub_10038970(a1 + 5184);
  *(_DWORD *)(a1 + 1624) = -1;
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1006C0C0) --------------------------------------------------------
int __userpurge sub_1006C0C0@<eax>(int a1@<edi>, int a2)
{
  *(_DWORD *)a2 = a1;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_BYTE *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 24) = 100;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  sub_100339F0(a2 + 44);
  *(_DWORD *)(a2 + 1620) = 0;
  *(_DWORD *)(a2 + 1624) = -1;
  *(_DWORD *)(a2 + 1628) = 0;
  *(_DWORD *)(a2 + 1632) = 0;
  *(_DWORD *)(a2 + 1636) = 0;
  *(_DWORD *)(a2 + 1640) = 0;
  *(_DWORD *)(a2 + 1644) = 0;
  *(_DWORD *)(a2 + 1648) = 0;
  *(_DWORD *)(a2 + 1652) = 0;
  *(_DWORD *)(a2 + 1656) = 0;
  *(_DWORD *)(a2 + 1660) = 0;
  *(float *)(a2 + 1664) = 0.0;
  *(_DWORD *)(a2 + 1668) = 0;
  *(_DWORD *)(a2 + 1672) = 0;
  *(_DWORD *)(a2 + 1676) = 0;
  *(_DWORD *)(a2 + 1680) = 0;
  *(_DWORD *)(a2 + 1684) = 0;
  *(_BYTE *)(a2 + 1688) = 0;
  *(_DWORD *)(a2 + 1692) = 0;
  *(_DWORD *)(a2 + 1696) = 0;
  *(_DWORD *)(a2 + 1700) = 0;
  *(_DWORD *)(a2 + 1704) = 0;
  *(_DWORD *)(a2 + 1708) = 0;
  *(_DWORD *)(a2 + 1712) = 0;
  *(_DWORD *)(a2 + 1716) = 0;
  *(_DWORD *)(a2 + 1720) = 0;
  *(_DWORD *)(a2 + 1724) = 0;
  *(_DWORD *)(a2 + 1728) = a1;
  `eh vector constructor iterator'((void *)(a2 + 1744), 0x58u, 4, (int)sub_10039C90, sub_10036FD0);
  *(_DWORD *)(a2 + 2100) = 0;
  *(_DWORD *)(a2 + 2104) = 0;
  *(_BYTE *)(a2 + 2108) = 0;
  `eh vector constructor iterator'((void *)(a2 + 2112), 0xCu, 256, (int)unknown_libname_3, sub_100371F0);
  *(_DWORD *)(a2 + 5184) = 0;
  *(_DWORD *)(a2 + 5188) = 0;
  *(_DWORD *)(a2 + 5192) = 0;
  *(_DWORD *)(a2 + 5196) = 32;
  *(_DWORD *)(a2 + 5204) = 0;
  *(_DWORD *)(a2 + 5208) = 0;
  *(_DWORD *)(a2 + 5212) = 0;
  return a2;
}
// 1003F6D0: using guessed type int unknown_libname_3();

//----- (1006C250) --------------------------------------------------------
char __stdcall sub_1006C250(int a1, unsigned int a2, int a3)
{
  int v3; // esi@1
  int v4; // edi@1
  double v5; // st7@1
  unsigned int v6; // eax@2
  int v7; // edx@3
  int v8; // eax@3
  unsigned __int8 v9; // bl@3
  char *v10; // esi@3
  char *v11; // edi@4
  unsigned int v12; // ebp@4
  unsigned int v13; // eax@5
  unsigned int v14; // edx@5
  int v15; // ecx@5
  unsigned int v16; // edx@7
  double v17; // st6@10
  unsigned int v18; // eax@13
  unsigned int v19; // edx@13
  int v20; // ecx@13
  unsigned int v21; // edx@15
  double v22; // st6@18
  unsigned int v23; // edx@21
  unsigned int v24; // edx@23
  double v25; // st6@26
  unsigned int v26; // eax@29
  unsigned int v27; // edx@29
  unsigned int v28; // edx@31
  double v29; // st6@34
  unsigned int v30; // eax@39
  unsigned int v31; // edi@40
  unsigned int v32; // eax@43
  unsigned int v33; // esi@43
  unsigned int v34; // eax@48
  char *v35; // esi@48
  int *v36; // eax@56
  unsigned int v37; // esi@62
  unsigned int v38; // ecx@63
  unsigned __int64 v39; // rax@64
  int v40; // ebp@71
  int v41; // ebx@71
  int v42; // ebx@72
  char *v43; // edx@72
  int v44; // ecx@73
  int v45; // eax@73
  int v46; // ecx@73
  int v47; // ecx@73
  unsigned int v48; // ecx@73
  _DWORD *v49; // esi@74
  _DWORD *v50; // ebp@74
  void *v51; // ebx@78
  void *v53; // ebx@85
  float v54; // [sp+14h] [bp-ACh]@9
  float v55; // [sp+14h] [bp-ACh]@17
  float v56; // [sp+14h] [bp-ACh]@25
  float v57; // [sp+14h] [bp-ACh]@33
  int v58; // [sp+14h] [bp-ACh]@61
  unsigned __int8 v59; // [sp+1Ah] [bp-A6h]@3
  char v60; // [sp+1Bh] [bp-A5h]@4
  unsigned int v61; // [sp+1Ch] [bp-A4h]@1
  int v62; // [sp+1Ch] [bp-A4h]@72
  signed int v63; // [sp+20h] [bp-A0h]@1
  int v64; // [sp+20h] [bp-A0h]@62
  unsigned int v65; // [sp+28h] [bp-98h]@2
  int v66; // [sp+2Ch] [bp-94h]@1
  void *v67; // [sp+30h] [bp-90h]@67
  int v68; // [sp+34h] [bp-8Ch]@67
  int v69; // [sp+38h] [bp-88h]@67
  int v70; // [sp+3Ch] [bp-84h]@1
  int v71; // [sp+40h] [bp-80h]@43
  int v72[4]; // [sp+44h] [bp-7Ch]@45
  int v73; // [sp+54h] [bp-6Ch]@1
  int v74; // [sp+58h] [bp-68h]@48
  int v75[4]; // [sp+5Ch] [bp-64h]@48
  char v76; // [sp+6Ch] [bp-54h]@48
  char v77; // [sp+74h] [bp-4Ch]@4
  int v78; // [sp+BCh] [bp-4h]@1

  v3 = a3;
  v4 = a1;
  `eh vector constructor iterator'(&v70, 0xCu, 2, (int)unknown_libname_3, sub_10038C00);
  v78 = 0;
  `eh vector constructor iterator'(&v73, 0xCu, 2, (int)unknown_libname_3, sub_10038C00);
  LOBYTE(v78) = 1;
  v5 = 0.0;
  v66 = 0;
  v61 = 0;
  v63 = 2;
  do
  {
    v6 = 0;
    v65 = 0;
    if ( *(_DWORD *)(v4 + 28) <= 0u )
      goto LABEL_54;
    do
    {
      v7 = v6 * *(_DWORD *)(v4 + 40);
      v8 = *(_DWORD *)(v4 + 36);
      v9 = *(_BYTE *)(v8 + 8 * v7 + 1);
      v10 = (char *)(v8 + 8 * v7);
      v59 = *v10;
      if ( v9 >= (unsigned __int8)*v10 != v66 )
        goto LABEL_52;
      v60 = 0;
      v11 = &v77;
      v12 = 6;
      do
      {
        v13 = (v12 - 6) >> 3;
        v14 = (unsigned __int8)v10[v13 + 2];
        v15 = (v12 - 6) & 7;
        if ( v13 < 5 )
          v14 |= (unsigned __int8)v10[v13 + 3] << 8;
        v16 = (v14 >> v15) & 7;
        if ( v59 > v9 )
        {
          v17 = (double)(unsigned __int8)byte_1009F8AC[v16];
        }
        else
        {
          if ( v16 >= 6 )
          {
            v54 = v5;
            v60 = 1;
            goto LABEL_13;
          }
          v17 = (double)(unsigned __int8)byte_1009F8B4[v16];
        }
        v54 = v17;
LABEL_13:
        *((float *)v11 - 2) = v54;
        v18 = (v12 - 3) >> 3;
        v19 = (unsigned __int8)v10[v18 + 2];
        v20 = (v12 - 3) & 7;
        if ( v18 < 5 )
          v19 |= (unsigned __int8)v10[v18 + 3] << 8;
        v21 = (v19 >> v20) & 7;
        if ( v59 > v9 )
        {
          v22 = (double)(unsigned __int8)byte_1009F8AC[v21];
        }
        else
        {
          if ( v21 >= 6 )
          {
            v55 = v5;
            v60 = 1;
            goto LABEL_21;
          }
          v22 = (double)(unsigned __int8)byte_1009F8B4[v21];
        }
        v55 = v22;
LABEL_21:
        *((float *)v11 - 1) = v55;
        v23 = (unsigned __int8)v10[(v12 >> 3) + 2];
        if ( v12 >> 3 < 5 )
          v23 |= (unsigned __int8)v10[(v12 >> 3) + 3] << 8;
        v24 = (v23 >> (v12 & 7)) & 7;
        if ( v59 > v9 )
        {
          v25 = (double)(unsigned __int8)byte_1009F8AC[v24];
        }
        else
        {
          if ( v24 >= 6 )
          {
            v56 = v5;
            v60 = 1;
            goto LABEL_29;
          }
          v25 = (double)(unsigned __int8)byte_1009F8B4[v24];
        }
        v56 = v25;
LABEL_29:
        *(float *)v11 = v56;
        v26 = (v12 + 3) >> 3;
        v27 = (unsigned __int8)v10[v26 + 2];
        if ( v26 < 5 )
          v27 |= (unsigned __int8)v10[v26 + 3] << 8;
        v28 = (v27 >> ((v12 + 3) & 7)) & 7;
        if ( v59 > v9 )
        {
          v29 = (double)(unsigned __int8)byte_1009F8AC[v28];
        }
        else
        {
          if ( v28 >= 6 )
          {
            v57 = v5;
            v60 = 1;
            goto LABEL_37;
          }
          v29 = (double)(unsigned __int8)byte_1009F8B4[v28];
        }
        v57 = v29;
LABEL_37:
        v12 += 12;
        *((float *)v11 + 1) = v57;
        v11 += 16;
      }
      while ( v12 < 0x36 );
      if ( !v60 )
      {
        v30 = (v59 - v9) * (v59 - (unsigned int)v9) >> 3;
        if ( v30 >= 1 )
        {
          v31 = 2048;
          if ( v30 <= 0x800 )
            v31 = (v59 - v9) * (v59 - (unsigned int)v9) >> 3;
        }
        else
        {
          v31 = 1;
        }
        v32 = *(int *)((char *)&v71 + v61);
        v33 = v32 + 1;
        if ( v32 + 1 != v32 )
        {
          if ( v32 + 1 >= v32 && v33 > v72[v61 / 4] )
            sub_100943C0(
              v33,
              (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003DD80,
              (int)&v70 + v61,
              v33 == v32 + 1,
              0x44u,
              0);
          *(int *)((char *)&v71 + v61) = v33;
        }
        sub_10038C30(*(int *)((char *)&v70 + v61) + 68 * *(int *)((char *)&v71 + v61) - 68, (int)&v76);
        *(_DWORD *)(*(int *)((char *)&v70 + v61) + 68 * *(int *)((char *)&v71 + v61) - 4) = v31;
        v34 = *(int *)((char *)&v74 + v61);
        v35 = (char *)&v74 + v61;
        if ( v34 >= v75[v61 / 4] )
          sub_100943C0(v34 + 1, 0, (int)&v73 + v61, 1, 4u, 0);
        v5 = 0.0;
        *(_DWORD *)(*(int *)((char *)&v73 + v61) + 4 * (*(_DWORD *)v35)++) = v65;
      }
      v4 = a1;
LABEL_52:
      v6 = v65 + 1;
      v65 = v6;
    }
    while ( v6 < *(_DWORD *)(v4 + 28) );
    v3 = a3;
LABEL_54:
    ++v66;
    v61 += 12;
    --v63;
  }
  while ( v63 );
  if ( *(_DWORD *)v3 )
  {
    sub_1003E4E0(*(_DWORD *)(v3 + 4), *(int **)v3);
    v36 = *(int **)v3;
    if ( *(_DWORD *)v3 )
    {
      if ( (unsigned __int8)v36 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v36, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)v3 = 0;
    *(_DWORD *)(v3 + 4) = 0;
    *(_DWORD *)(v3 + 8) = 0;
  }
  v58 = 0;
  while ( 1 )
  {
    v37 = *(&v71 + 3 * v58);
    v64 = 12 * v58;
    if ( !v37 )
      goto LABEL_82;
    v38 = *(_DWORD *)(a1 + 28);
    if ( (double)v37 / (double)v38 < 0.009999999776482582 )
      goto LABEL_82;
    v39 = (a2 * (unsigned __int64)v37 + v38 - 1) / v38;
    if ( (unsigned int)v39 < 0x40 )
      LODWORD(v39) = 64;
    if ( (unsigned int)v39 >= v37 )
      goto LABEL_82;
    v67 = 0;
    v68 = 0;
    v69 = 0;
    LOBYTE(v78) = 2;
    HIDWORD(v39) = *(_DWORD *)(a1 + 24);
    if ( v58 )
    {
      HIDWORD(v39) += 16;
      *(_DWORD *)(a1 + 24) = 17;
    }
    else
    {
      *(_DWORD *)(a1 + 24) = 16;
    }
    *(_DWORD *)(a1 + 20) = HIDWORD(v39);
    if ( !sub_10037E90(a1 + 1728, (int)&v70 + v64, v39, (int)&v67, (int)sub_1006B310, a1) )
      break;
    v40 = *(_DWORD *)(a3 + 4);
    v41 = v68;
    sub_10037280(a3, v68 + v40, 1);
    if ( v41 )
    {
      v42 = 12 * v40;
      v43 = (char *)v67 + 8;
      v62 = v68;
      do
      {
        v44 = *(_DWORD *)(*(_DWORD *)a3 + v42);
        v45 = v42 + *(_DWORD *)a3;
        *(_DWORD *)v45 = *((_DWORD *)v43 - 2);
        *((_DWORD *)v43 - 2) = v44;
        v46 = *(_DWORD *)(v45 + 4);
        *(_DWORD *)(v45 + 4) = *((_DWORD *)v43 - 1);
        *((_DWORD *)v43 - 1) = v46;
        v47 = *(_DWORD *)(v45 + 8);
        *(_DWORD *)(v45 + 8) = *(_DWORD *)v43;
        *(_DWORD *)v43 = v47;
        v48 = 0;
        if ( *(_DWORD *)(v45 + 4) )
        {
          do
          {
            v49 = *(_DWORD **)v45;
            v50 = *(_DWORD **)v45;
            if ( v48 < *(_DWORD *)(v45 + 4) )
            {
              v50 = &v49[v48];
              v49 += v48;
            }
            ++v48;
            *v49 = *(_DWORD *)(*(int *)((char *)&v73 + v64) + 4 * *v50);
          }
          while ( v48 < *(_DWORD *)(v45 + 4) );
        }
        v42 += 12;
        v43 += 12;
        --v62;
      }
      while ( v62 );
    }
    LOBYTE(v78) = 1;
    v51 = v67;
    if ( v67 )
    {
      sub_1003E4E0(v68, (int *)v67);
      if ( (unsigned __int8)v51 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v51, 0, 0, 1, dword_100AE9F4);
    }
LABEL_82:
    if ( (unsigned int)++v58 >= 2 )
    {
      LOBYTE(v78) = 0;
      `eh vector destructor iterator'(&v73, 0xCu, 2, sub_10038C00);
      v78 = -1;
      `eh vector destructor iterator'(&v70, 0xCu, 2, sub_10038C00);
      return 1;
    }
  }
  LOBYTE(v78) = 1;
  v53 = v67;
  if ( v67 )
  {
    sub_1003E4E0(v68, (int *)v67);
    if ( (unsigned __int8)v53 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v53, 0, 0, 1, dword_100AE9F4);
  }
  LOBYTE(v78) = 0;
  `eh vector destructor iterator'(&v73, 0xCu, 2, sub_10038C00);
  v78 = -1;
  `eh vector destructor iterator'(&v70, 0xCu, 2, sub_10038C00);
  return 0;
}
// 1003F6D0: using guessed type int unknown_libname_3();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 1006C250: using guessed type int var_7C[4];
// 1006C250: using guessed type int var_64[4];

//----- (1006C8E0) --------------------------------------------------------
char __thiscall sub_1006C8E0(void *this, int a2, int a3, const void *a4)
{
  int v4; // ebp@1
  void *v5; // ebx@1
  unsigned int v6; // ebx@1
  unsigned int v7; // eax@3
  int v8; // ecx@4
  int v9; // eax@4
  int v10; // edi@4
  int v11; // esi@4
  unsigned int v12; // edi@4
  double v13; // st7@5
  int v14; // edx@7
  unsigned int v15; // ecx@7
  char *v16; // eax@7
  unsigned int v17; // ebx@8
  unsigned int v18; // edi@10
  int v19; // esi@10
  int v20; // ebx@10
  unsigned int v21; // ecx@11
  unsigned int v22; // ebp@11
  int v23; // ecx@13
  char v24; // dl@13
  unsigned int v25; // ecx@13
  int v26; // ecx@15
  char v27; // dl@15
  unsigned int v28; // ecx@15
  int v29; // ecx@17
  char v30; // dl@17
  unsigned int v31; // edx@17
  int v32; // ecx@19
  char v33; // dl@19
  bool v34; // zf@20
  unsigned int v35; // eax@21
  char *v36; // edi@23
  int v37; // ebp@23
  int v38; // ecx@23
  int v39; // eax@23
  char *v40; // edx@24
  char *v41; // ecx@26
  char *v42; // eax@26
  int v43; // esi@26
  char *v44; // ebp@29
  char *v45; // ebx@29
  char *v46; // esi@29
  __int64 v47; // rax@29
  int v48; // ecx@29
  unsigned int v49; // esi@29
  unsigned int v50; // esi@32
  unsigned int v51; // edi@32
  unsigned int v52; // ecx@32
  char *v53; // ebp@33
  int v54; // eax@34
  int v55; // eax@34
  int v56; // eax@37
  unsigned __int64 v57; // kr18_8@38
  unsigned int v58; // eax@38
  char *v59; // ebp@39
  unsigned int v60; // edi@39
  unsigned int v61; // esi@40
  char *v62; // ecx@41
  int v63; // eax@42
  long double v64; // st7@43
  long double v65; // st7@44
  long double v66; // st6@48
  double v67; // st7@51
  long double v68; // st6@54
  int *v69; // ebp@57
  int v70; // ebx@58
  unsigned int v71; // ecx@59
  unsigned int v72; // esi@59
  unsigned int v73; // ecx@63
  unsigned int v74; // ebp@64
  int v75; // edx@66
  signed int v76; // eax@66
  unsigned int v77; // esi@66
  int v78; // edi@66
  signed int v79; // ecx@66
  char v80; // cl@68
  int v81; // ecx@72
  signed int v82; // eax@72
  int v83; // ecx@72
  int v84; // edx@72
  int v85; // ecx@72
  int v86; // esi@76
  int v87; // edi@76
  unsigned int v88; // eax@76
  int v89; // ebp@81
  char *v90; // eax@81
  unsigned int v91; // edi@82
  unsigned int v92; // edx@83
  unsigned int v93; // eax@84
  unsigned int v94; // ecx@84
  int v95; // eax@85
  int v96; // ecx@85
  int v97; // ecx@87
  unsigned int v98; // ecx@89
  int v99; // ecx@93
  int (__cdecl *v100)(unsigned int, int); // edi@93
  unsigned int v101; // ecx@93
  unsigned int v102; // eax@95
  int v103; // ecx@98
  unsigned int v104; // edx@98
  void *v105; // eax@106
  FILE *v106; // eax@108
  int v108; // eax@112
  _BYTE *v109; // esi@117
  char *v110; // eax@117
  int v111; // edx@117
  signed int v112; // edi@117
  int v113; // ecx@118
  int v114; // ecx@120
  int v115; // ecx@122
  int v116; // ecx@124
  unsigned int v117; // eax@127
  unsigned int v118; // ebx@128
  unsigned int v119; // eax@131
  int v120; // edi@131
  int v121; // eax@133
  int v122; // ecx@134
  int v123; // eax@135
  void *v124; // eax@137
  int v125; // esi@142
  int (__cdecl *v126)(unsigned int, int); // edi@145
  signed int v127; // eax@147
  int v128; // ecx@150
  unsigned int v129; // edx@150
  unsigned __int64 v130; // rt0@151
  int (__cdecl *v131)(unsigned int, int *); // ecx@152
  int v132; // eax@153
  unsigned int v133; // edx@154
  FILE *v134; // eax@158
  int *v135; // [sp-4h] [bp-73Ch]@4
  char *v136; // [sp+10h] [bp-728h]@7
  unsigned int v137; // [sp+14h] [bp-724h]@10
  unsigned int v138; // [sp+18h] [bp-720h]@7
  char *v139; // [sp+1Ch] [bp-71Ch]@7
  int v140; // [sp+20h] [bp-718h]@4
  long double v141; // [sp+24h] [bp-714h]@4
  unsigned int i; // [sp+2Ch] [bp-70Ch]@3
  char v143; // [sp+33h] [bp-705h]@151
  __int64 v144; // [sp+34h] [bp-704h]@32
  double v145; // [sp+3Ch] [bp-6FCh]@7
  int v146; // [sp+48h] [bp-6F0h]@4
  int v147; // [sp+4Ch] [bp-6ECh]@6
  unsigned int v148; // [sp+50h] [bp-6E8h]@3
  long double v149; // [sp+54h] [bp-6E4h]@7
  unsigned __int8 v150; // [sp+60h] [bp-6D8h]@76
  unsigned int v151; // [sp+64h] [bp-6D4h]@4
  int v152; // [sp+68h] [bp-6D0h]@76
  int v153; // [sp+6Ch] [bp-6CCh]@4
  unsigned int v154; // [sp+70h] [bp-6C8h]@3
  __int64 v155; // [sp+74h] [bp-6C4h]@32
  unsigned int v156; // [sp+80h] [bp-6B8h]@4
  unsigned __int64 v157; // [sp+84h] [bp-6B4h]@42
  unsigned int v158; // [sp+8Ch] [bp-6ACh]@131
  unsigned int v159; // [sp+98h] [bp-6A0h]@31
  unsigned int v160; // [sp+9Ch] [bp-69Ch]@31
  unsigned int v161; // [sp+A0h] [bp-698h]@31
  unsigned int v162; // [sp+A4h] [bp-694h]@31
  unsigned int v163; // [sp+A8h] [bp-690h]@31
  unsigned int v164; // [sp+ACh] [bp-68Ch]@31
  int v165; // [sp+B0h] [bp-688h]@31
  int v166; // [sp+B4h] [bp-684h]@31
  float v167; // [sp+B8h] [bp-680h]@80
  float v168; // [sp+BCh] [bp-67Ch]@80
  int v169; // [sp+C0h] [bp-678h]@4
  int v170; // [sp+C4h] [bp-674h]@1
  int v171; // [sp+C8h] [bp-670h]@1
  int v172; // [sp+CCh] [bp-66Ch]@1
  int v173; // [sp+D0h] [bp-668h]@1
  int v174; // [sp+D4h] [bp-664h]@1
  int v175; // [sp+D8h] [bp-660h]@1
  void *v176; // [sp+DCh] [bp-65Ch]@1
  int v177; // [sp+E0h] [bp-658h]@1
  int v178; // [sp+E4h] [bp-654h]@1
  int v179; // [sp+E8h] [bp-650h]@142
  int v180; // [sp+ECh] [bp-64Ch]@142
  int v181; // [sp+F0h] [bp-648h]@142
  int v182; // [sp+F4h] [bp-644h]@142
  int v183; // [sp+FCh] [bp-63Ch]@142
  int v184; // [sp+100h] [bp-638h]@142
  __int64 v185; // [sp+104h] [bp-634h]@42
  int v186; // [sp+114h] [bp-624h]@3
  int v187; // [sp+118h] [bp-620h]@3
  int v188; // [sp+11Ch] [bp-61Ch]@3
  int v189; // [sp+120h] [bp-618h]@3
  int v190; // [sp+124h] [bp-614h]@3
  int v191; // [sp+128h] [bp-610h]@3
  int v192; // [sp+12Ch] [bp-60Ch]@3
  int v193; // [sp+130h] [bp-608h]@3
  char v194; // [sp+154h] [bp-5E4h]@37
  char v195; // [sp+155h] [bp-5E3h]@70
  char v196; // [sp+156h] [bp-5E2h]@24
  char v197; // [sp+157h] [bp-5E1h]@72
  char v198[252]; // [sp+158h] [bp-5E0h]@33
  char DstBuf[2]; // [sp+254h] [bp-4E4h]@66
  char v200[510]; // [sp+256h] [bp-4E2h]@7
  int v201; // [sp+454h] [bp-2E4h]@59
  int v202; // [sp+458h] [bp-2E0h]@29
  char v203[64]; // [sp+45Ch] [bp-2DCh]@37
  int v204; // [sp+49Ch] [bp-29Ch]@42
  int v205[163]; // [sp+4A0h] [bp-298h]@42
  int v206; // [sp+734h] [bp-4h]@1

  v4 = a2;
  v5 = this;
  sub_1006BF60(a2);
  *(_DWORD *)(a2 + 8) = GetCurrentThreadId();
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 28) = v5;
  *(_DWORD *)(a2 + 32) = a3;
  qmemcpy((void *)(a2 + 44), a4, 0x628u);
  sub_1003FE70(a2 + 1628, (unsigned int)v5);
  v6 = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 24) = 75;
  v170 = 0;
  v171 = 0;
  v172 = 0;
  v173 = 0;
  v174 = 15;
  v175 = 0;
  v176 = 0;
  v177 = 0;
  v178 = 0;
  v206 = 0;
  if ( !*(_BYTE *)(a2 + 52) || !*(_DWORD *)(a2 + 56) )
  {
    v108 = 0;
    v140 = 0;
    if ( *(_DWORD *)(a2 + 28) > 0u )
    {
      for ( i = 0; ; v6 = i )
      {
        if ( !(v108 & 0x1FF) && !sub_1006B290(*(_DWORD *)(a2 + 28) - 1, a2, v108) )
          return 0;
        v109 = (_BYTE *)(*(_DWORD *)(a2 + 1612) + v6 + *(_DWORD *)(a2 + 32));
        v110 = (char *)&v186 + 2;
        v111 = (int)(v109 + 8);
        v112 = 4;
        do
        {
          v113 = *v109;
          if ( v113 & 0xFFFFFF00 )
            v113 = ~(v113 >> 31) & 0xFF;
          *(v110 - 2) = v113;
          *(v110 - 1) = v113;
          *v110 = v113;
          v114 = *(_BYTE *)(v111 - 4);
          v110[1] = -1;
          if ( v114 & 0xFFFFFF00 )
            v114 = ~(v114 >> 31) & 0xFF;
          v110[2] = v114;
          v110[3] = v114;
          v110[4] = v114;
          v115 = *(_BYTE *)v111;
          v110[5] = -1;
          if ( v115 & 0xFFFFFF00 )
            v115 = ~(v115 >> 31) & 0xFF;
          v110[6] = v115;
          v110[7] = v115;
          v110[8] = v115;
          v116 = *(_BYTE *)(v111 + 4);
          v110[9] = -1;
          if ( v116 & 0xFFFFFF00 )
            v116 = ~(v116 >> 31) & 0xFF;
          v110[10] = v116;
          v110[11] = v116;
          v110[12] = v116;
          v110[13] = -1;
          v110 += 16;
          v109 += 16;
          v111 += 16;
          --v112;
        }
        while ( v112 );
        sub_10068DB0(0x10u, &v186, &v151, &v150);
        v152 = (unsigned __int8)v151;
        v117 = ((unsigned __int8)v151 - v150) * ((unsigned __int8)v151 - (unsigned int)v150) >> 3;
        v153 = v150;
        if ( v117 >= 1 )
        {
          v118 = 8;
          if ( v117 <= 8 )
            v118 = ((unsigned __int8)v151 - v150) * ((unsigned __int8)v151 - (unsigned int)v150) >> 3;
        }
        else
        {
          v118 = 1;
        }
        v119 = *(_DWORD *)(a2 + 1632);
        v158 = v118;
        *(float *)&v155 = (double)v152;
        v120 = v155;
        *((float *)&v155 + 1) = (double)v153;
        HIDWORD(v157) = HIDWORD(v155);
        if ( v119 >= *(_DWORD *)(a2 + 1636) )
          sub_100943C0(v119 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_10040A40, a2 + 1628, 1, 0xCu, 0);
        v121 = *(_DWORD *)(a2 + 1628) + 12 * *(_DWORD *)(a2 + 1632);
        if ( v121 )
        {
          v122 = HIDWORD(v157);
          *(_DWORD *)v121 = v120;
          *(_DWORD *)(v121 + 4) = v122;
          *(_DWORD *)(v121 + 8) = v118;
        }
        v123 = v140;
        ++*(_DWORD *)(a2 + 1632);
        i += 64;
        v140 = v123 + 1;
        if ( (unsigned int)(v123 + 1) >= *(_DWORD *)(a2 + 28) )
          break;
        v108 = v140;
      }
    }
    goto LABEL_136;
  }
  sub_1003F4C0(a2 + 1628, *(_DWORD *)(a2 + 28));
  v7 = 0;
  v186 = 0;
  v187 = 0;
  v188 = 0;
  v189 = 0;
  v190 = 0;
  v191 = 0;
  v192 = 0;
  v193 = 0;
  v154 = 0;
  i = 512;
  v148 = 0;
  if ( *(_DWORD *)(a2 + 56) <= 0u )
    goto LABEL_136;
LABEL_4:
  v8 = 3 * v7 + 15;
  v9 = *(_DWORD *)(v4 + 4 * v8 + 4);
  v10 = *(_DWORD *)(v4 + 4 * v8 + 8);
  v11 = v4 + 4 * v8;
  v169 = v10;
  v153 = v9;
  v12 = (unsigned int)(v10 + 1) >> 1;
  LODWORD(v141) = &v135;
  v140 = v4 + 4 * v8;
  v156 = (unsigned int)(v9 + 1) >> 1;
  v151 = v12;
  sub_10034090((int)&v170, 8 * v156, 8 * v12, -16777216);
  v146 = 0;
  if ( !v12 )
    goto LABEL_104;
  v13 = 0.0;
  while ( 1 )
  {
    v147 = 0;
    if ( v156 )
      break;
LABEL_102:
    if ( ++v146 >= v12 )
    {
      v4 = a2;
LABEL_104:
      v7 = v148 + 1;
      v148 = v7;
      if ( v7 < *(_DWORD *)(v4 + 56) )
        goto LABEL_4;
LABEL_136:
      v135 = (int *)v4;
      *(_DWORD *)(v4 + 20) = 75;
      *(_DWORD *)(v4 + 24) = 20;
      if ( sub_1003ED30(v4 + 1628, v4 + 1628, (int)v135) )
      {
        v179 = 0;
        v180 = 0;
        v181 = 0;
        v182 = 32;
        v183 = 0;
        v184 = 0;
        LOBYTE(v206) = 1;
        v125 = 0;
        *(_DWORD *)(v4 + 20) = 95;
        *(_DWORD *)(v4 + 24) = 5;
        if ( *(_DWORD *)(v4 + 28) <= 0u )
        {
LABEL_152:
          v131 = *(int (__cdecl **)(unsigned int, int *))(v4 + 1596);
          *(_DWORD *)(v4 + 1620) = v183 + 128;
          if ( v131 )
          {
            v132 = *(_DWORD *)(v4 + 20) + *(_DWORD *)(v4 + 24);
            if ( v132 != *(_DWORD *)(v4 + 1624) )
            {
              v135 = *(int **)(v4 + 1600);
              v133 = v132 * *(_DWORD *)(v4 + 1608);
              *(_DWORD *)(v4 + 1624) = v132;
              if ( !(unsigned __int8)v131(*(_DWORD *)(v4 + 1604) + v133 / 0x64, v135) )
                *(_BYTE *)(v4 + 16) = 1;
            }
          }
          LOBYTE(v206) = 0;
          sub_1003F520((int)&v179);
          v206 = -1;
          if ( v176 )
          {
            if ( (unsigned __int8)v176 & 7 )
            {
              v135 = (int *)"crnlib_free: bad ptr";
              sprintf_s(
                DstBuf,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_free: bad ptr");
              OutputDebugStringA(DstBuf);
              v134 = _iob_func();
              fputs(DstBuf, v134 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v176, 0, 0, 1, dword_100AE9F4);
            }
          }
          return 1;
        }
        v140 = 0;
        while ( 1 )
        {
          if ( !(v125 & 0x1FF) )
          {
            v126 = *(int (__cdecl **)(unsigned int, int))(v4 + 1596);
            if ( v126 )
            {
              v127 = *(_DWORD *)(v4 + 28) == 1 ? 100 : *(_DWORD *)(v4 + 20)
                                                     + (((unsigned int)(*(_DWORD *)(v4 + 28) - 1) >> 1)
                                                      + v125 * *(_DWORD *)(v4 + 24))
                                                     / (*(_DWORD *)(v4 + 28) - 1);
              if ( v127 != *(_DWORD *)(v4 + 1624) )
              {
                v128 = *(_DWORD *)(v4 + 1600);
                v129 = v127 * *(_DWORD *)(v4 + 1608);
                *(_DWORD *)(v4 + 1624) = v127;
                if ( !(unsigned __int8)v126(*(_DWORD *)(v4 + 1604) + v129 / 0x64, v128) )
                  break;
              }
            }
          }
          sub_10069B00((int)&v144, v140 + *(_DWORD *)(v4 + 32), *(_DWORD *)(v4 + 1612));
          HIDWORD(v130) = (unsigned __int64)BYTE7(v144) >> 24;
          LODWORD(v130) = WORD3(v144);
          HIDWORD(v130) = v130 >> 24;
          LODWORD(v130) = BYTE5(v144) | (WORD3(v144) << 8);
          HIDWORD(v130) = v130 >> 24;
          LODWORD(v130) = BYTE4(v144) | ((_DWORD)v130 << 8);
          HIDWORD(v130) = v130 >> 24;
          LODWORD(v130) = BYTE3(v144) | ((BYTE4(v144) | ((BYTE5(v144) | (WORD3(v144) << 8)) << 8)) << 8);
          LODWORD(v157) = BYTE2(v144) | ((_DWORD)v130 << 8);
          HIDWORD(v157) = v130 >> 24;
          v143 = 0;
          sub_1003F5E0((int)&v185, (int)&v179, &v157, &v143);
          v140 += 64;
          if ( (unsigned int)++v125 >= *(_DWORD *)(v4 + 28) )
            goto LABEL_152;
        }
        v135 = &v179;
        *(_BYTE *)(v4 + 16) = 1;
        LOBYTE(v206) = 0;
        sub_1003F520((int)v135);
        v206 = -1;
        v124 = v176;
        if ( !v176 )
          return 0;
        if ( (unsigned __int8)v176 & 7 )
        {
LABEL_139:
          sub_100927E0((int)"crnlib_free: bad ptr");
          return 0;
        }
        v135 = (int *)dword_100AE9F4;
      }
      else
      {
        v206 = -1;
        v124 = v176;
        if ( !v176 )
          return 0;
        if ( (unsigned __int8)v176 & 7 )
          goto LABEL_139;
        v135 = (int *)dword_100AE9F4;
      }
      off_100AD9F4(v124, 0, 0, 1, v135);
      return 0;
    }
  }
  while ( 1 )
  {
    v14 = *(_DWORD *)v11;
    LODWORD(v149) = *(_DWORD *)(v11 + 4);
    v138 = *(_DWORD *)(a2 + 32);
    LODWORD(v145) = v14;
    v15 = 8 * v146;
    LODWORD(v141) = 8 * v147 + 1;
    v136 = (char *)(8 * v146);
    v16 = v200;
    v139 = (char *)8;
    do
    {
      v17 = 4 * v169 - 1;
      if ( v15 < v17 )
        v17 = v15;
      v18 = LODWORD(v141);
      v19 = LODWORD(v145) + LODWORD(v149) * (v17 >> 2);
      v20 = v17 & 3;
      v137 = 2;
      do
      {
        v21 = v18 - 1;
        v22 = 4 * v153 - 1;
        if ( v18 - 1 >= v22 )
          v21 = 4 * v153 - 1;
        v23 = v138 + 4 * ((v21 & 3) + 4 * (v20 + 4 * (v19 + (v21 >> 2))));
        *(v16 - 2) = *(_BYTE *)v23;
        *(v16 - 1) = *(_BYTE *)(v23 + 1);
        v24 = *(_BYTE *)(v23 + 2);
        v16[1] = *(_BYTE *)(v23 + 3);
        *v16 = v24;
        v25 = v18;
        if ( v18 >= v22 )
          v25 = v22;
        v26 = v138 + 4 * ((v25 & 3) + 4 * (v20 + 4 * (v19 + (v25 >> 2))));
        v16[2] = *(_BYTE *)v26;
        v16[3] = *(_BYTE *)(v26 + 1);
        v27 = *(_BYTE *)(v26 + 2);
        LOBYTE(v26) = *(_BYTE *)(v26 + 3);
        v16[4] = v27;
        v16[5] = v26;
        v28 = v18 + 1;
        if ( v18 + 1 >= v22 )
          v28 = v22;
        v29 = v138 + 4 * ((v28 & 3) + 4 * (v20 + 4 * (v19 + (v28 >> 2))));
        v16[6] = *(_BYTE *)v29;
        v16[7] = *(_BYTE *)(v29 + 1);
        v30 = *(_BYTE *)(v29 + 2);
        LOBYTE(v29) = *(_BYTE *)(v29 + 3);
        v16[8] = v30;
        v31 = v18 + 2;
        v16[9] = v29;
        if ( v18 + 2 >= v22 )
          v31 = v22;
        v32 = v138 + ((v19 + (v31 >> 2)) << 6) + 4 * (4 * v20 + (v31 & 3));
        v16[10] = *(_BYTE *)v32;
        v16[11] = *(_BYTE *)(v32 + 1);
        v33 = *(_BYTE *)(v32 + 2);
        LOBYTE(v32) = *(_BYTE *)(v32 + 3);
        v16[12] = v33;
        v16[13] = v32;
        v16 += 16;
        v18 += 4;
        --v137;
      }
      while ( *(float *)&v137 != 0.0 );
      v15 = (unsigned int)(v136 + 1);
      v34 = v139-- == (char *)1;
      ++v136;
    }
    while ( !v34 );
    LODWORD(v145) = *(_DWORD *)(a2 + 1612);
    v35 = 0;
    v138 = 0;
    *(float *)&v137 = 0.0;
    while ( 1 )
    {
      v36 = *(char **)((char *)dword_100AD2FC + v35);
      v37 = *(int *)((char *)dword_100AD2F8 + v35);
      v38 = *(_DWORD *)((char *)&unk_100AD2F0 + v35);
      v39 = *(_DWORD *)((char *)&unk_100AD2F4 + v35);
      if ( v36 )
      {
        v136 = &v196;
        v40 = &v200[4 * (v38 + 8 * v39)];
        v139 = v36;
        do
        {
          if ( v37 )
          {
            v41 = v136;
            v42 = v40;
            v43 = v37;
            do
            {
              *(v41 - 2) = *(v42 - 2);
              *(v41 - 1) = *(v42 - 1);
              *v41 = *v42;
              v41[1] = v42[1];
              v42 += 4;
              v41 += 4;
              --v43;
            }
            while ( v43 );
          }
          v136 += 4 * v37;
          v40 += 32;
          --v139;
        }
        while ( v139 );
      }
      v44 = (char *)((_DWORD)v36 * v37);
      v45 = (char *)&v202 + v138;
      v46 = (char *)&v202 + v138 - 4;
      v136 = v44;
      sub_10069310(v44, v46, (char *)&v202 + v138, (char *)&v202 + v138 + 4);
      v48 = *(_DWORD *)v45;
      v49 = *(_DWORD *)v46;
      if ( v49 <= *(_DWORD *)v45 )
      {
        v161 = (v48 + 4 * v49) / 5;
        v162 = (3 * v49 + 2 * v48) / 5;
        v160 = v48;
        v163 = (3 * v48 + 2 * v49) / 5;
        LODWORD(v47) = 0;
        v159 = v49;
        v164 = (v49 + 4 * v48) / 5;
        v165 = 0;
        v166 = 255;
      }
      else
      {
        sub_10092180(v48);
        LODWORD(v47) = 0;
      }
      v50 = 0;
      v51 = 0;
      v52 = 0;
      v144 = 0i64;
      v155 = 0i64;
      if ( (signed int)v44 >= 2 )
      {
        v53 = &v198[LODWORD(v145)];
        v139 = &v198[LODWORD(v145)];
        do
        {
          v54 = (unsigned __int8)*(v53 - 4) - *(&v159 + (unsigned __int8)v45[v52 + 4]);
          v51 = (v54 * v54 + __PAIR__(v51, v50)) >> 32;
          v50 += v54 * v54;
          v55 = (unsigned __int8)*v53 - *(&v159 + (unsigned __int8)v45[v52 + 5]);
          v144 += v55 * v55;
          v52 += 2;
          v53 = v139 + 8;
          v139 += 8;
        }
        while ( v52 < (unsigned int)(v136 - 1) );
        v47 = v155;
      }
      if ( v52 < (unsigned int)v136 )
      {
        v56 = (unsigned __int8)*(&v194 + 4 * v52 + *(_DWORD *)(a2 + 1612))
            - *(&v159 + (unsigned __int8)*(&v203[v52] + v138));
        v47 = v56 * v56;
      }
      v57 = v47 + v144 + __PAIR__(v51, v50);
      v138 += 80;
      v58 = v137 + 20;
      *(_QWORD *)(v45 + 68) = v57;
      v137 = v58;
      if ( v58 >= 0xB4 )
        break;
      v35 = v137;
    }
    v59 = 0;
    v145 = -1.0;
    v136 = 0;
    v60 = 0;
    do
    {
      v61 = dword_100AD050[v60];
      if ( v61 > 0 )
      {
        v62 = (char *)&unk_100AD064 + v60 * 4;
        do
        {
          v63 = v205[20 * *(_DWORD *)v62];
          LODWORD(v185) = *(&v204 + 20 * *(_DWORD *)v62);
          HIDWORD(v185) = v63 & 0x7FFFFFFF;
          v157 = __PAIR__(v63 & 0x80000000, 0);
          v62 += 20;
          --v61;
          v13 = v13 + (double)__PAIR__((unsigned int)v63, (unsigned int)v185);
        }
        while ( v61 );
      }
      v141 = v13 * 0.015625;
      v64 = sqrt(v141);
      v149 = 999999.0;
      if ( 0.0 == v141 )
      {
        v13 = 0.0;
      }
      else
      {
        v65 = log10(255.0 / v64) * 20.0;
        if ( v65 >= 0.0 )
        {
          if ( v65 <= 500.0 )
          {
            v66 = v65;
            v13 = 0.0;
            v149 = v66;
          }
          else
          {
            v13 = 0.0;
            v149 = 500.0;
          }
        }
        else
        {
          v13 = 0.0;
          v149 = 0.0;
        }
      }
      *(float *)&v137 = 2.4000001;
      if ( v148 )
      {
        *(float *)&v141 = pow(3.0, (double)v148);
        *(float *)&v141 = 2.400000095367432 / *(float *)&v141;
        v67 = *(float *)&v141;
        if ( *(float *)&v141 < 0.25 )
          v67 = 0.25;
        *(float *)&v137 = v67;
        v13 = 0.0;
      }
      *(float *)&v141 = (double)(unsigned int)(dword_100AD050[v60] - 1) / 3.0;
      *(float *)&v141 = *(float *)&v141 * (*(float *)&v137 - v13) + v13;
      v68 = v149 - *(float *)&v141;
      if ( v145 < v68 )
      {
        v59 = v136;
        v145 = v68;
      }
      ++v136;
      v60 += 21;
    }
    while ( v60 < 168 );
    ++*(&v186 + (_DWORD)v59);
    v69 = &dword_100AD050[21 * (signed int)v59];
    LODWORD(v149) = v69;
    v139 = 0;
    if ( (unsigned int)*v69 > 0 )
    {
      v70 = (int)(v69 + 1);
      do
      {
        v71 = *(&v202 + 20 * *(_DWORD *)(v70 + 16));
        v72 = *(&v201 + 20 * *(_DWORD *)(v70 + 16));
        LODWORD(v141) = &v201 + 20 * *(_DWORD *)(v70 + 16);
        if ( v72 <= v71 )
        {
          v161 = (v71 + 4 * v72) / 5;
          v162 = (3 * v72 + 2 * v71) / 5;
          v160 = v71;
          v163 = (3 * v71 + 2 * v72) / 5;
          v159 = v72;
          v164 = (v72 + 4 * v71) / 5;
          v165 = 0;
          v166 = 255;
        }
        else
        {
          sub_10092180(v71);
        }
        v34 = *(_DWORD *)(v70 + 12) == 0;
        v138 = 0;
        if ( !v34 )
        {
          v73 = *(_DWORD *)(v70 + 8);
          do
          {
            v74 = 0;
            LODWORD(v145) = v138 + *(_DWORD *)(v70 + 4);
            if ( v73 )
            {
              v137 = v172 * (LODWORD(v145) + 8 * v146) + 8 * v147;
              do
              {
                v75 = v74 + *(_DWORD *)v70;
                v76 = (unsigned __int8)*(&DstBuf[4 * (v75 + 8 * LODWORD(v145))] + *(_DWORD *)(a2 + 1612));
                v77 = v76 & 0xFFFFFF00;
                v78 = v138 * v73 + v74;
                v79 = (unsigned __int8)*(&DstBuf[4 * (v75 + 8 * LODWORD(v145))] + *(_DWORD *)(a2 + 1612));
                if ( v76 & 0xFFFFFF00 )
                  LOBYTE(v79) = ~(v79 >> 31);
                *(&v194 + 4 * v78) = v79;
                v80 = v76;
                if ( v77 )
                  v80 = ~(v76 >> 31);
                *(&v195 + 4 * v78) = v80;
                if ( v77 )
                  LOBYTE(v76) = ~(v76 >> 31);
                v81 = LODWORD(v141);
                *(&v196 + 4 * v78) = v76;
                v82 = *(&v159 + *(_BYTE *)(v78 + v81 + 8));
                v83 = v75 + v137;
                v84 = v175;
                *(&v197 + 4 * v78) = -1;
                v85 = v84 + 4 * v83;
                if ( v82 & 0xFFFFFF00 )
                  LOBYTE(v82) = ~(v82 >> 31);
                *(_BYTE *)v85 = v82;
                *(_BYTE *)(v85 + 1) = v82;
                *(_BYTE *)(v85 + 2) = v82;
                *(_BYTE *)(v85 + 3) = -1;
                v73 = *(_DWORD *)(v70 + 8);
                ++v74;
              }
              while ( v74 < v73 );
            }
            ++v138;
          }
          while ( v138 < *(_DWORD *)(v70 + 12) );
        }
        v86 = *(_DWORD *)(v70 + 8);
        v87 = *(_DWORD *)(v70 + 12);
        sub_10068DB0(v87 * v86, &v194, &v152, &v150);
        LODWORD(v141) = (unsigned __int8)v152;
        v88 = ((unsigned __int8)v152 - v150) * ((unsigned __int8)v152 - (unsigned int)v150) >> 3;
        LODWORD(v145) = v150;
        if ( v88 >= 1 )
        {
          v137 = 8;
          if ( v88 <= 8 )
            v137 = ((unsigned __int8)v152 - v150) * ((unsigned __int8)v152 - (unsigned int)v150) >> 3;
        }
        else
        {
          v137 = 1;
        }
        v136 = 0;
        v167 = (double)SLODWORD(v141);
        v168 = (double)SLODWORD(v145);
        if ( v87 & 0xFFFFFFFC )
        {
          v89 = v140;
          v90 = v136;
          LODWORD(v141) = 2 * v146;
          do
          {
            v91 = (unsigned int)(&v90[LODWORD(v141)] + (*(_DWORD *)(v70 + 4) >> 2));
            if ( v91 < *(_DWORD *)(v89 + 8) )
            {
              v92 = 0;
              if ( v86 & 0xFFFFFFFC )
              {
                do
                {
                  v93 = *(_DWORD *)(v89 + 4);
                  v94 = v92 + (*(_DWORD *)v70 >> 2) + 2 * v147;
                  if ( v94 >= v93 )
                    break;
                  v95 = 12 * (v94 + *(_DWORD *)v89 + v91 * v93);
                  v96 = v95 + *(_DWORD *)(a2 + 1628);
                  if ( (float *)v96 != &v167 )
                  {
                    *(float *)v96 = v167;
                    *(float *)(v96 + 4) = v168;
                  }
                  v97 = *(_DWORD *)(a2 + 1628);
                  ++v154;
                  *(float *)(v97 + v95 + 8) = *(float *)&v137;
                  v86 = *(_DWORD *)(v70 + 8);
                  ++v92;
                }
                while ( v92 < *(_DWORD *)(v70 + 8) >> 2 );
                v90 = v136;
              }
            }
            ++v90;
            v98 = *(_DWORD *)(v70 + 12) >> 2;
            v136 = v90;
          }
          while ( (unsigned int)v90 < v98 );
        }
        v70 += 20;
        ++v139;
      }
      while ( (unsigned int)v139 < *(_DWORD *)LODWORD(v149) );
      v13 = 0.0;
    }
    if ( v154 < i )
      goto LABEL_100;
    v99 = *(_DWORD *)(a2 + 28);
    v100 = *(int (__cdecl **)(unsigned int, int))(a2 + 1596);
    i += 512;
    v101 = v99 - 1;
    if ( !v100 )
      goto LABEL_100;
    v102 = v101 ? *(_DWORD *)(a2 + 20) + ((v101 >> 1) + v154 * *(_DWORD *)(a2 + 24)) / v101 : 100;
    if ( v102 == *(_DWORD *)(a2 + 1624) )
      goto LABEL_100;
    v103 = *(_DWORD *)(a2 + 1600);
    v104 = v102 * *(_DWORD *)(a2 + 1608);
    *(_DWORD *)(a2 + 1624) = v102;
    if ( !(unsigned __int8)v100(*(_DWORD *)(a2 + 1604) + v104 / 0x64, v103) )
      break;
    v13 = 0.0;
LABEL_100:
    v11 = v140;
    if ( ++v147 >= v156 )
    {
      v12 = v151;
      goto LABEL_102;
    }
  }
  v206 = -1;
  v105 = v176;
  *(_BYTE *)(a2 + 16) = 1;
  if ( v105 )
  {
    if ( (unsigned __int8)v105 & 7 )
    {
      v135 = (int *)"crnlib_free: bad ptr";
      sprintf_s(DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(DstBuf);
      v106 = _iob_func();
      fputs(DstBuf, v106 + 2);
      if ( IsDebuggerPresent() )
      {
        DebugBreak();
        return 0;
      }
    }
    else
    {
      off_100AD9F4(v105, 0, 0, 1, dword_100AE9F4);
    }
  }
  return 0;
}
// 10040A40: using guessed type int sub_10040A40();
// 10069310: using guessed type double __cdecl sub_10069310(_DWORD, _DWORD, _DWORD, _DWORD);
// 10092180: using guessed type double __thiscall sub_10092180(_DWORD);
// 100AD050: using guessed type int dword_100AD050[];
// 100AD2F8: using guessed type int dword_100AD2F8[];
// 100AD2FC: using guessed type int dword_100AD2FC[];
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 1006C8E0: using guessed type char var_4E2[510];
// 1006C8E0: using guessed type char var_5E0[252];
// 1006C8E0: using guessed type char var_2DC[64];
// 1006C8E0: using guessed type int var_298[163];
// 1006C8E0: using guessed type char DstBuf[2];

//----- (1006DA30) --------------------------------------------------------
bool __stdcall sub_1006DA30(int a1, int a2, const void *a3)
{
  double v3; // st7@1
  unsigned int v4; // esi@1
  double v5; // st7@1
  unsigned int v6; // eax@1
  unsigned int v7; // ecx@5
  double v8; // st7@5
  unsigned int v9; // eax@5
  _DWORD *v10; // edi@9
  int v11; // ebx@11
  unsigned int v12; // ecx@11
  unsigned int v13; // eax@12
  int v14; // esi@12
  unsigned int v15; // esi@21
  int v16; // edx@22
  int *v17; // eax@22
  bool v18; // c0@26
  bool v19; // c3@26
  int v20; // eax@26
  int v21; // edi@32
  int v22; // eax@32
  struct _SINGLE_LIST_ENTRY *v23; // esi@32
  FILE *v24; // eax@34
  int v25; // ebx@36
  PSINGLE_LIST_ENTRY v26; // eax@37
  FILE *v27; // eax@40
  FILE *v28; // eax@47
  int v29; // ecx@51
  int v31; // esi@57
  int *v32; // eax@60
  int v33; // ecx@66
  int v34; // edi@67
  int v35; // eax@67
  struct _SINGLE_LIST_ENTRY *v36; // esi@67
  FILE *v37; // eax@69
  int v38; // ebx@71
  PSINGLE_LIST_ENTRY v39; // eax@72
  FILE *v40; // eax@75
  FILE *v41; // eax@82
  int v42; // ecx@86
  int v43; // [sp+14h] [bp-63Ch]@1
  unsigned int v44; // [sp+18h] [bp-638h]@1
  unsigned int v45; // [sp+1Ch] [bp-634h]@6
  int v46; // [sp+20h] [bp-630h]@1
  float v47; // [sp+24h] [bp-62Ch]@1
  __int64 v48; // [sp+28h] [bp-628h]@1
  int v49; // [sp+34h] [bp-61Ch]@66
  struct _SINGLE_LIST_ENTRY *v50; // [sp+4Ch] [bp-604h]@45
  char DstBuf; // [sp+50h] [bp-600h]@34
  CHAR OutputString; // [sp+250h] [bp-400h]@40
  CHAR v53; // [sp+450h] [bp-200h]@47

  *(_DWORD *)(a1 + 8) = GetCurrentThreadId();
  *(_DWORD *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 36) = a2;
  *(_DWORD *)(a1 + 40) = 1;
  qmemcpy((void *)(a1 + 44), a3, 0x628u);
  v3 = (double)*(unsigned int *)(a1 + 44);
  *(_DWORD *)(a1 + 1624) = -1;
  v47 = v3 / 255.0;
  *(float *)&v43 = pow(v47, 1.649999976158142);
  v4 = *(_DWORD *)(a1 + 1656);
  v46 = v43;
  *(float *)&v43 = pow(v47, 2.099999904632568);
  v5 = *(float *)&v43 * (double)v4;
  v43 = (unsigned __int16)v44 | 0xC00;
  v48 = (signed __int64)v5;
  v6 = (signed __int64)v5;
  if ( v6 >= 0x10 )
  {
    if ( v6 <= v4 )
      v4 = (signed __int64)v5;
  }
  else
  {
    v4 = 16;
  }
  v7 = *(_DWORD *)(a1 + 1620);
  v8 = (double)*(unsigned int *)(a1 + 1620) * *(float *)&v46;
  v43 = (unsigned __int16)v44 | 0xC00;
  v48 = (signed __int64)v8;
  v9 = (signed __int64)v8;
  if ( v9 >= 0x20 )
  {
    v45 = v7;
    if ( v9 <= v7 )
      v45 = (signed __int64)v8;
  }
  else
  {
    v45 = 32;
  }
  v10 = (_DWORD *)(a1 + 1716);
  if ( v47 < 1.0 )
  {
    sub_1003F290((void *)(a1 + 1716), a1 + 1628, v4);
  }
  else
  {
    sub_10037280((int)v10, *(_DWORD *)(a1 + 28), 0);
    v44 = 0;
    if ( *(_DWORD *)(a1 + 28) > 0u )
    {
      v11 = 0;
      v12 = 0;
      do
      {
        v13 = *(_DWORD *)(*v10 + v11 + 4);
        v14 = v11 + *v10;
        if ( v13 != 1 )
        {
          if ( v13 <= 1 )
          {
            if ( *(_DWORD *)(v14 + 8) < 1u )
            {
              LOBYTE(v43) = v13 == 0;
              sub_100943C0(1u, 0, v14, v43, 4u, 0);
            }
            memset((void *)(4 * *(_DWORD *)(v14 + 4) + *(_DWORD *)v14), 0, 4 - 4 * *(_DWORD *)(v14 + 4));
            v12 = v44;
          }
          *(_DWORD *)(v14 + 4) = 1;
        }
        **(_DWORD **)(v11 + *v10) = v12++;
        v11 += 12;
        v44 = v12;
      }
      while ( v12 < *(_DWORD *)(a1 + 28) );
    }
  }
  v15 = 0;
  if ( *(_DWORD *)(a1 + 1720) )
  {
    v16 = *(_DWORD *)(a1 + 1720);
    v17 = (int *)(*v10 + 4);
    do
    {
      if ( v15 <= *v17 )
        v15 = *v17;
      v17 += 3;
      --v16;
    }
    while ( v16 );
  }
  v18 = 1.0 < v47;
  v19 = 1.0 == v47;
  v20 = 3 * *(_DWORD *)a3 + 528;
  LODWORD(v48) = a1 + 4 * v20;
  *(_DWORD *)(a1 + 20) = 0;
  if ( v18 || v19 )
  {
    *(_DWORD *)(a1 + 24) = 100;
  }
  else if ( *(_DWORD *)(a1 + 4 * v20 + 4) )
  {
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 48) != 0 ? 50 : 10;
  }
  else
  {
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 48) != 0 ? 33 : 10;
  }
  v44 = 0;
  do
  {
    v21 = *(_DWORD *)a1;
    v46 = 16;
    v22 = off_100AD9F4(0, 16, &v46, 1, dword_100AE9F4);
    v23 = (struct _SINGLE_LIST_ENTRY *)v22;
    if ( v22 && (unsigned int)v46 >= 0x10 )
    {
      *(_DWORD *)v22 = &off_100A4F34;
      *(_DWORD *)(v22 + 4) = a1;
      *(_DWORD *)(v22 + 8) = sub_1006B870;
      *(_DWORD *)(v22 + 12) = 1;
      InterlockedIncrement((LPLONG)(v21 + 80));
      v25 = *(_DWORD *)v21;
      if ( *(_BYTE *)(*(_DWORD *)v21 + 16) )
      {
        v26 = InterlockedPopEntrySList((PSLIST_HEADER)(v25 + 8));
        if ( v26 )
          goto LABEL_91;
      }
      v43 = 32;
      v26 = (PSINGLE_LIST_ENTRY)off_100AD9F4(0, 32, &v43, 1, dword_100AE9F4);
      if ( !v26 || (unsigned int)v43 < 0x20 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_malloc: out of memory");
        OutputDebugStringA(&OutputString);
        v27 = _iob_func();
        fputs(&OutputString, v27 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
        v26 = 0;
      }
      if ( v26 )
      {
LABEL_91:
        if ( v26 != (PSINGLE_LIST_ENTRY)-8 )
        {
          v26[2].Next = (struct _SINGLE_LIST_ENTRY *)v44;
          v26[3].Next = 0;
          v26[4].Next = 0;
          v26[5].Next = v23;
          v26[6].Next = (struct _SINGLE_LIST_ENTRY *)1;
          v26[7].Next = v50;
        }
        InterlockedPushEntrySList((PSLIST_HEADER)v25, v26);
        if ( !ReleaseSemaphore(*(HANDLE *)(v21 + 72), 1, 0) )
        {
          sprintf_s(
            &v53,
            0x200u,
            "%s(%u): Failure: \"%s\"\n",
            "crn_threading_win32.cpp",
            198,
            "\"semaphore: ReleaseSemaphore() failed\"");
          OutputDebugStringA(&v53);
          v28 = _iob_func();
          fputs(&v53, v28 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
          if ( !byte_100AE9F8 )
LABEL_56:
            exit(1);
          RaiseException(0x100u, 0, 0, 0);
        }
      }
      else
      {
        InterlockedIncrement((LPLONG)(v21 + 84));
      }
    }
    else
    {
      sprintf_s(
        &DstBuf,
        0x200u,
        "%s(%u): Assertion failed: \"%s\"\n",
        "crn_mem.cpp",
        216,
        "crnlib_malloc: out of memory");
      OutputDebugStringA(&DstBuf);
      v24 = _iob_func();
      fputs(&DstBuf, v24 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    v29 = *(_DWORD *)a1;
    ++v44;
  }
  while ( v44 <= *(_DWORD *)(v29 + 4) );
  sub_10091500(v29);
  if ( *(_BYTE *)(a1 + 16) )
    return 0;
  if ( v47 >= 1.0 )
    return 1;
  v31 = v48;
  if ( !*(_DWORD *)(v48 + 4) )
  {
    sub_1006C250(a1, v45, v48);
    if ( *(_BYTE *)(a1 + 16) )
    {
      if ( *(_DWORD *)v31 )
      {
        sub_1003E4E0(*(_DWORD *)(v31 + 4), *(int **)v31);
        v32 = *(int **)v31;
        if ( *(_DWORD *)v31 )
        {
          if ( (unsigned __int8)v32 & 7 )
          {
            sub_100927E0((int)"crnlib_free: bad ptr");
            *(_DWORD *)v31 = 0;
            *(_DWORD *)(v31 + 4) = 0;
            *(_DWORD *)(v31 + 8) = 0;
            return 0;
          }
          off_100AD9F4(v32, 0, 0, 1, dword_100AE9F4);
        }
        *(_DWORD *)v31 = 0;
        *(_DWORD *)(v31 + 4) = 0;
        *(_DWORD *)(v31 + 8) = 0;
      }
      return 0;
    }
  }
  *(_DWORD *)(a1 + 20) += *(_DWORD *)(a1 + 24);
  v33 = 100 - *(_DWORD *)(a1 + 20);
  v49 = v31;
  *(_DWORD *)(a1 + 24) = v33;
  v45 = 0;
  do
  {
    v34 = *(_DWORD *)a1;
    v43 = 16;
    v35 = off_100AD9F4(0, 16, &v43, 1, dword_100AE9F4);
    v36 = (struct _SINGLE_LIST_ENTRY *)v35;
    if ( v35 && (unsigned int)v43 >= 0x10 )
    {
      *(_DWORD *)v35 = &off_100A4F34;
      *(_DWORD *)(v35 + 4) = a1;
      *(_DWORD *)(v35 + 8) = sub_1006B380;
      *(_DWORD *)(v35 + 12) = 1;
      InterlockedIncrement((LPLONG)(v34 + 80));
      v38 = *(_DWORD *)v34;
      if ( *(_BYTE *)(*(_DWORD *)v34 + 16) )
      {
        v39 = InterlockedPopEntrySList((PSLIST_HEADER)(v38 + 8));
        if ( v39 )
          goto LABEL_92;
      }
      v46 = 32;
      v39 = (PSINGLE_LIST_ENTRY)off_100AD9F4(0, 32, &v46, 1, dword_100AE9F4);
      if ( !v39 || (unsigned int)v46 < 0x20 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_malloc: out of memory");
        OutputDebugStringA(&OutputString);
        v40 = _iob_func();
        fputs(&OutputString, v40 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
        v39 = 0;
      }
      if ( v39 )
      {
LABEL_92:
        if ( v39 != (PSINGLE_LIST_ENTRY)-8 )
        {
          v39[2].Next = (struct _SINGLE_LIST_ENTRY *)v45;
          v39[3].Next = 0;
          v39[4].Next = (struct _SINGLE_LIST_ENTRY *)&v49;
          v39[5].Next = v36;
          v39[6].Next = (struct _SINGLE_LIST_ENTRY *)1;
          v39[7].Next = v50;
        }
        InterlockedPushEntrySList((PSLIST_HEADER)v38, v39);
        if ( !ReleaseSemaphore(*(HANDLE *)(v34 + 72), 1, 0) )
        {
          sprintf_s(
            &DstBuf,
            0x200u,
            "%s(%u): Failure: \"%s\"\n",
            "crn_threading_win32.cpp",
            198,
            "\"semaphore: ReleaseSemaphore() failed\"");
          OutputDebugStringA(&DstBuf);
          v41 = _iob_func();
          fputs(&DstBuf, v41 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
          if ( !byte_100AE9F8 )
            goto LABEL_56;
          RaiseException(0x100u, 0, 0, 0);
        }
      }
      else
      {
        InterlockedIncrement((LPLONG)(v34 + 84));
      }
    }
    else
    {
      sprintf_s(&v53, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_malloc: out of memory");
      OutputDebugStringA(&v53);
      v37 = _iob_func();
      fputs(&v53, v37 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    v42 = *(_DWORD *)a1;
    ++v45;
  }
  while ( v45 <= *(_DWORD *)(v42 + 4) );
  sub_10091500(v42);
  return *(_BYTE *)(a1 + 16) == 0;
}
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (1006E250) --------------------------------------------------------
char __userpurge sub_1006E250@<al>(unsigned int a1@<ecx>, int a2@<esi>, int a3)
{
  int (__cdecl *v3)(unsigned int, int); // edi@1
  unsigned int v4; // eax@3
  int v5; // ecx@6
  unsigned int v6; // edx@6
  char result; // al@6

  v3 = *(int (__cdecl **)(unsigned int, int))(a2 + 1600);
  if ( !v3
    || (!a1 ? (v4 = 100) : (v4 = *(_DWORD *)(a2 + 20) + ((a1 >> 1) + a3 * *(_DWORD *)(a2 + 24)) / a1),
        v4 == *(_DWORD *)(a2 + 1620)
     || (v5 = *(_DWORD *)(a2 + 1604),
         v6 = v4 * *(_DWORD *)(a2 + 1612),
         *(_DWORD *)(a2 + 1620) = v4,
         (result = v3(*(_DWORD *)(a2 + 1608) + v6 / 0x64, v5)) != 0)) )
  {
    result = 1;
  }
  else
  {
    *(_BYTE *)(a2 + 16) = 1;
  }
  return result;
}

//----- (1006E2D0) --------------------------------------------------------
char __cdecl sub_1006E2D0(int a1, int a2)
{
  int (__cdecl *v2)(unsigned int, int); // ecx@1
  unsigned int v3; // edx@2
  unsigned int v4; // edi@3
  int v5; // ST04_4@3
  char result; // al@3

  v2 = *(int (__cdecl **)(unsigned int, int))(a2 + 1600);
  if ( !v2
    || (v3 = *(_DWORD *)(a2 + 20) + (a1 * *(_DWORD *)(a2 + 24) + 50) / 0x64u, v3 == *(_DWORD *)(a2 + 1620))
    || (v4 = v3 * *(_DWORD *)(a2 + 1612),
        v5 = *(_DWORD *)(a2 + 1604),
        *(_DWORD *)(a2 + 1620) = v3,
        (result = v2(*(_DWORD *)(a2 + 1608) + v4 / 0x64, v5)) != 0) )
  {
    result = 1;
  }
  else
  {
    *(_BYTE *)(a2 + 16) = 1;
  }
  return result;
}

//----- (1006E340) --------------------------------------------------------
int __thiscall sub_1006E340(_DWORD *this, int a2, int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@8
  int v8; // ebx@10
  int v9; // esi@18
  int v10; // eax@18
  unsigned int v11; // eax@19
  unsigned int v12; // edx@22
  unsigned int v13; // ecx@23
  _BYTE *v14; // eax@23
  unsigned int v15; // eax@32
  int *v16; // eax@33
  unsigned int v17; // eax@33
  char v18; // bl@36
  unsigned int v19; // edx@38
  char *v20; // esi@39
  unsigned int v21; // ecx@40
  unsigned int v22; // ebx@40
  int v23; // eax@41
  int v24; // edi@41
  int v25; // edx@41
  int v26; // eax@41
  __int16 v27; // cx@41
  int v28; // eax@41
  unsigned __int16 v29; // dx@41
  unsigned __int16 v30; // cx@41
  int v31; // eax@45
  int v32; // ecx@45
  int v33; // eax@45
  int v34; // ecx@46
  int v35; // edx@46
  int v36; // kr04_4@47
  char v37; // dl@53
  char v38; // bl@53
  char v39; // dl@53
  unsigned int v40; // eax@55
  int v41; // esi@56
  int v42; // ecx@57
  int *v44; // [sp-10h] [bp-A0h]@61
  void (__thiscall *v45)(void *); // [sp-4h] [bp-94h]@61
  char v46; // [sp+Eh] [bp-82h]@35
  _DWORD *v47; // [sp+10h] [bp-80h]@1
  unsigned int i; // [sp+14h] [bp-7Ch]@17
  unsigned int v49; // [sp+14h] [bp-7Ch]@34
  unsigned int v50; // [sp+18h] [bp-78h]@36
  int v51; // [sp+1Ch] [bp-74h]@35
  int *v52; // [sp+20h] [bp-70h]@33
  int v53; // [sp+24h] [bp-6Ch]@10
  unsigned int v54; // [sp+24h] [bp-6Ch]@32
  unsigned int v55; // [sp+28h] [bp-68h]@1
  int v56; // [sp+2Ch] [bp-64h]@2
  unsigned int v57; // [sp+30h] [bp-60h]@38
  char v58; // [sp+34h] [bp-5Ch]@36
  unsigned int v59; // [sp+38h] [bp-58h]@35
  __int64 v60; // [sp+40h] [bp-50h]@40
  unsigned __int64 v61; // [sp+48h] [bp-48h]@36
  int v62; // [sp+54h] [bp-3Ch]@32
  char v63; // [sp+58h] [bp-38h]@39
  int v64; // [sp+68h] [bp-28h]@1
  unsigned int v65; // [sp+6Ch] [bp-24h]@11
  unsigned int v66; // [sp+70h] [bp-20h]@19
  int v67; // [sp+74h] [bp-1Ch]@1
  unsigned int v68; // [sp+78h] [bp-18h]@13
  unsigned int v69; // [sp+7Ch] [bp-14h]@27
  int v70; // [sp+8Ch] [bp-4h]@1

  v4 = (int)this;
  v47 = this;
  `eh vector constructor iterator'(&v64, 0xCu, 2, (int)unknown_libname_3, sub_10038C00);
  v5 = 0;
  v70 = 0;
  sub_10036310((int)&v64, 0x800u);
  sub_10036310((int)&v67, 0x800u);
  v6 = a4;
  v55 = 0;
  if ( *(_DWORD *)(*(_DWORD *)a4 + 4) )
  {
    v56 = 0;
    while ( 1 )
    {
      if ( *(_BYTE *)(v4 + 16) )
      {
        v45 = sub_10038C00;
        v44 = &v64;
        goto LABEL_62;
      }
      if ( !(_BYTE)v5
        && GetCurrentThreadId() == *(_DWORD *)(v4 + 8)
        && 0 == *(_DWORD *)(v4 + 12)
        && !sub_1006E250(*(_DWORD *)(*(_DWORD *)v6 + 4) - 1, v4, v5) )
      {
        break;
      }
      v7 = *(_DWORD *)(*(_DWORD *)v4 + 4);
      if ( !v7 || v5 % (v7 + 1) == a2 )
      {
        v8 = v56 + **(_DWORD **)a4;
        v53 = v56 + **(_DWORD **)a4;
        if ( *(_DWORD *)(v8 + 4) > 1u )
        {
          if ( v65 )
            v65 = 0;
          if ( v68 )
          {
            if ( v68 <= 0 )
              memset((void *)(v67 + 4 * v68), 0, -4 * v68);
            v68 = 0;
          }
          for ( i = 0; i < *(_DWORD *)(v8 + 4); ++i )
          {
            v9 = *(_DWORD *)(*(_DWORD *)v8 + 4 * i);
            v10 = v9 * *(_DWORD *)(v4 + 40);
            if ( (*(_BYTE *)(*(_DWORD *)(v4 + 36) + 8 * v10) | ((unsigned int)*(_BYTE *)(*(_DWORD *)(v4 + 36)
                                                                                       + 8 * v10
                                                                                       + 1) << 8)) <= (*(_BYTE *)(*(_DWORD *)(v4 + 36) + 8 * v10 + 2) | ((unsigned int)*(_BYTE *)(*(_DWORD *)(v4 + 36) + 8 * v10 + 3) << 8)) )
            {
              v12 = *(_DWORD *)(v4 + 48);
              if ( v12 )
              {
                v13 = 0;
                v14 = (_BYTE *)(*(_DWORD *)(v4 + 32) + (v9 << 6) + 3);
                while ( *v14 >= v12 )
                {
                  ++v13;
                  v14 += 4;
                  if ( v13 >= 0x10 )
                  {
                    v8 = v53;
                    goto LABEL_27;
                  }
                }
                v8 = v53;
              }
              else
              {
LABEL_27:
                if ( v68 >= v69 )
                  sub_100943C0(v68 + 1, 0, (int)&v67, 1, 4u, 0);
                *(_DWORD *)(v67 + 4 * v68++) = v9;
              }
            }
            else
            {
              v11 = v65;
              if ( v65 >= v66 )
              {
                sub_100943C0(v65 + 1, 0, (int)&v64, 1, 4u, 0);
                v11 = v65;
              }
              *(_DWORD *)(v64 + 4 * v11) = v9;
              ++v65;
            }
          }
          v15 = 0;
          v62 = 0;
          v54 = 0;
          do
          {
            v16 = &v64 + 3 * v15;
            v52 = v16;
            v17 = v16[1];
            if ( v17 > 1 )
            {
              v49 = 0;
              do
              {
                v51 = 0;
                v46 = *((_BYTE *)&v62 + v49);
                v59 = 0;
                do
                {
                  v18 = 0;
                  v58 = 0;
                  v61 = 0xFFFFFFFFFFi64;
                  v50 = 4;
                  if ( v54 == 1 )
                    v50 = 3;
                  v19 = 0;
                  v57 = 0;
                  if ( v50 )
                  {
                    v20 = &v63;
                    do
                    {
                      v21 = 0;
                      v22 = 0;
                      v60 = 0i64;
                      if ( v17 )
                      {
                        do
                        {
                          v23 = *(_DWORD *)(*v52 + 4 * v22);
                          v24 = *(_DWORD *)(v4 + 32) + 4 * (v51 + 4 * (v49 + 4 * v23));
                          v25 = v23 * v47[10];
                          v26 = v47[9];
                          v27 = *(_BYTE *)(v26 + 8 * v25 + 3);
                          v28 = v26 + 8 * v25;
                          v29 = *(_BYTE *)(v28 + 2) | (unsigned __int16)(v27 << 8);
                          v30 = *(_BYTE *)v28 | (unsigned __int16)(*(_BYTE *)(v28 + 1) << 8);
                          if ( v30 <= v29 )
                            sub_10092630((int)&v63, v30, v29);
                          else
                            sub_100924B0(v30, (int)&v63, v29);
                          if ( *((_BYTE *)v47 + 56) )
                          {
                            v31 = *(_BYTE *)v24 - (unsigned __int8)*v20;
                            v32 = *(_BYTE *)(v24 + 1) - (unsigned __int8)v20[1];
                            v33 = (*(_BYTE *)(v24 + 2) - (unsigned __int8)v20[2])
                                * (*(_BYTE *)(v24 + 2) - (unsigned __int8)v20[2])
                                + 25 * v32 * v32
                                + 8 * v31 * v31;
                          }
                          else
                          {
                            v34 = *(_BYTE *)v24 - (unsigned __int8)*v20;
                            v35 = *(_BYTE *)(v24 + 1) - (unsigned __int8)v20[1];
                            v33 = v34 * v34
                                + v35 * v35
                                + (*(_BYTE *)(v24 + 2) - (unsigned __int8)v20[2])
                                * (*(_BYTE *)(v24 + 2) - (unsigned __int8)v20[2]);
                          }
                          v36 = v33;
                          v17 = v52[1];
                          v60 += (unsigned int)v36;
                          v4 = (int)v47;
                          ++v22;
                        }
                        while ( v22 < v17 );
                        v21 = v60;
                        v19 = v57;
                      }
                      if ( __PAIR__(HIDWORD(v60), v21) < v61 )
                      {
                        v61 = __PAIR__(HIDWORD(v60), v21);
                        v58 = v19;
                      }
                      ++v19;
                      v20 += 4;
                      v57 = v19;
                    }
                    while ( v19 < v50 );
                    v18 = v58;
                  }
                  ++v51;
                  v37 = 3 << v59;
                  v38 = v18 << v59;
                  v59 += 2;
                  v39 = v38 | ~v37 & v46;
                  v46 = v39;
                }
                while ( v59 < 8 );
                *((_BYTE *)&v62 + v49++) = v39;
              }
              while ( v49 < 4 );
              v40 = 0;
              if ( v52[1] )
              {
                v41 = v62;
                do
                {
                  v42 = *(_DWORD *)(v4 + 36) + 8 * *(_DWORD *)(*v52 + 4 * v40++) * *(_DWORD *)(v4 + 40);
                  *(_DWORD *)(v42 + 4) = v41;
                }
                while ( v40 < v52[1] );
              }
            }
            v15 = v54 + 1;
            v54 = v15;
          }
          while ( v15 <= 1 );
        }
        v5 = v55;
      }
      v6 = a4;
      v56 += 12;
      v55 = ++v5;
      if ( v5 >= *(_DWORD *)(*(_DWORD *)a4 + 4) )
        goto LABEL_61;
    }
    v45 = sub_10038C00;
    v44 = &v64;
  }
  else
  {
LABEL_61:
    v45 = sub_10038C00;
    v44 = &v64;
  }
LABEL_62:
  v70 = -1;
  return `eh vector destructor iterator'(v44, 0xCu, 2, v45);
}
// 1003F6D0: using guessed type int unknown_libname_3();

//----- (1006E830) --------------------------------------------------------
int __stdcall sub_1006E830(int a1)
{
  int *v1; // ecx@1
  int v2; // eax@2
  int v3; // esi@7
  signed int v4; // edi@7
  int *v5; // eax@9
  int result; // eax@15

  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 255;
  *(_DWORD *)(a1 + 52) = 4;
  *(_DWORD *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 56) = 257;
  *(_DWORD *)(a1 + 1600) = 0;
  *(_DWORD *)(a1 + 1604) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_BYTE *)(a1 + 58) = 1;
  memset((void *)(a1 + 64), 0, 0x600u);
  *(_DWORD *)(a1 + 1608) = 0;
  *(_DWORD *)(a1 + 1612) = 100;
  sub_10037300(a1 + 1624);
  v1 = *(int **)(a1 + 1712);
  if ( v1 )
  {
    sub_1003E4E0(*(_DWORD *)(a1 + 1716), v1);
    v2 = *(_DWORD *)(a1 + 1712);
    if ( v2 )
    {
      if ( v2 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 1712) = 0;
    *(_DWORD *)(a1 + 1716) = 0;
    *(_DWORD *)(a1 + 1720) = 0;
  }
  *(_DWORD *)(a1 + 1616) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 100;
  sub_10037DB0(a1 + 1728);
  v3 = a1 + 2112;
  v4 = 256;
  do
  {
    if ( *(_DWORD *)v3 )
    {
      sub_1003E4E0(*(_DWORD *)(v3 + 4), *(int **)v3);
      v5 = *(int **)v3;
      if ( *(_DWORD *)v3 )
      {
        if ( (unsigned __int8)v5 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      }
      *(_DWORD *)v3 = 0;
      *(_DWORD *)(v3 + 4) = 0;
      *(_DWORD *)(v3 + 8) = 0;
    }
    v3 += 12;
    --v4;
  }
  while ( v4 );
  result = sub_10038970(a1 + 5184);
  *(_DWORD *)(a1 + 1620) = -1;
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1006E990) --------------------------------------------------------
void __stdcall sub_1006E990(int a1)
{
  int *v1; // ecx@1
  int v2; // eax@2

  sub_100388E0(a1 + 5184);
  `eh vector destructor iterator'((void *)(a1 + 2112), 0xCu, 256, sub_100371F0);
  `eh vector destructor iterator'((void *)(a1 + 1744), 0x58u, 4, sub_10036FD0);
  v1 = *(int **)(a1 + 1712);
  if ( v1 )
  {
    sub_1003E4E0(*(_DWORD *)(a1 + 1716), v1);
    v2 = *(_DWORD *)(a1 + 1712);
    if ( v2 )
    {
      if ( v2 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    }
  }
  sub_10036E20(a1 + 1624);
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1006EA70) --------------------------------------------------------
int __userpurge sub_1006EA70@<eax>(int a1@<edi>, int a2)
{
  *(_DWORD *)a2 = a1;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_BYTE *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 24) = 100;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  *(_DWORD *)(a2 + 44) = 255;
  *(_DWORD *)(a2 + 52) = 4;
  *(_DWORD *)(a2 + 48) = 0;
  *(_WORD *)(a2 + 56) = 257;
  *(_DWORD *)(a2 + 1600) = 0;
  *(_DWORD *)(a2 + 1604) = 0;
  *(_DWORD *)(a2 + 60) = 0;
  *(_BYTE *)(a2 + 58) = 1;
  memset((void *)(a2 + 64), 0, 0x600u);
  *(_DWORD *)(a2 + 1608) = 0;
  *(_DWORD *)(a2 + 1612) = 100;
  *(_DWORD *)(a2 + 1616) = 0;
  *(_DWORD *)(a2 + 1620) = -1;
  *(_DWORD *)(a2 + 1624) = 0;
  *(_DWORD *)(a2 + 1628) = 0;
  *(_DWORD *)(a2 + 1632) = 0;
  *(_DWORD *)(a2 + 1636) = 0;
  *(_DWORD *)(a2 + 1640) = 0;
  *(_DWORD *)(a2 + 1644) = 0;
  *(_DWORD *)(a2 + 1648) = 0;
  *(_DWORD *)(a2 + 1652) = 0;
  *(_DWORD *)(a2 + 1656) = 0;
  *(float *)(a2 + 1660) = 0.0;
  *(_DWORD *)(a2 + 1664) = 0;
  *(_DWORD *)(a2 + 1668) = 0;
  *(_DWORD *)(a2 + 1672) = 0;
  *(_DWORD *)(a2 + 1676) = 0;
  *(_DWORD *)(a2 + 1680) = 0;
  *(_BYTE *)(a2 + 1684) = 0;
  *(_DWORD *)(a2 + 1688) = 0;
  *(_DWORD *)(a2 + 1692) = 0;
  *(_DWORD *)(a2 + 1696) = 0;
  *(_DWORD *)(a2 + 1700) = 0;
  *(_DWORD *)(a2 + 1704) = 0;
  *(_DWORD *)(a2 + 1708) = 0;
  *(_DWORD *)(a2 + 1712) = 0;
  *(_DWORD *)(a2 + 1716) = 0;
  *(_DWORD *)(a2 + 1720) = 0;
  *(_DWORD *)(a2 + 1728) = a1;
  `eh vector constructor iterator'((void *)(a2 + 1744), 0x58u, 4, (int)sub_10039C90, sub_10036FD0);
  *(_DWORD *)(a2 + 2100) = 0;
  *(_DWORD *)(a2 + 2104) = 0;
  *(_BYTE *)(a2 + 2108) = 0;
  `eh vector constructor iterator'((void *)(a2 + 2112), 0xCu, 256, (int)unknown_libname_3, sub_100371F0);
  *(_DWORD *)(a2 + 5184) = 0;
  *(_DWORD *)(a2 + 5188) = 0;
  *(_DWORD *)(a2 + 5192) = 0;
  *(_DWORD *)(a2 + 5204) = 0;
  *(_DWORD *)(a2 + 5208) = 0;
  *(_DWORD *)(a2 + 5196) = 32;
  *(_DWORD *)(a2 + 5212) = 0;
  return a2;
}
// 1003F6D0: using guessed type int unknown_libname_3();

//----- (1006EC50) --------------------------------------------------------
bool __thiscall sub_1006EC50(int this, unsigned int a2, int a3)
{
  int v3; // edi@1
  unsigned int v4; // esi@1
  int v5; // eax@7
  unsigned int v6; // ecx@7
  signed int v7; // edx@7
  signed int v8; // ST30_4@7
  signed int v9; // edx@7
  signed int v10; // ST30_4@7
  unsigned int v11; // ecx@7
  signed int v12; // edx@7
  signed int v13; // ST30_4@7
  signed int v14; // edx@7
  signed int v15; // ST30_4@7
  signed int v16; // edx@7
  signed int v17; // ST30_4@7
  unsigned int v18; // ecx@7
  signed int v19; // edx@7
  signed int v20; // ST30_4@7
  signed int v21; // edx@7
  signed int v22; // ST30_4@7
  signed int v23; // edx@7
  signed int v24; // ST30_4@7
  unsigned int v25; // ecx@7
  signed int v26; // edx@7
  signed int v27; // ST30_4@7
  signed int v28; // edx@7
  signed int v29; // ST30_4@7
  signed int v30; // edx@7
  signed int v31; // ST30_4@7
  signed int v32; // ecx@7
  double v33; // st7@7
  unsigned int v34; // ecx@7
  unsigned int v35; // ebx@7
  unsigned int v36; // esi@7
  unsigned int v37; // eax@7
  unsigned int v38; // ecx@7
  unsigned int v39; // esi@7
  unsigned int v40; // eax@7
  unsigned int v41; // edx@7
  int v42; // ecx@7
  unsigned int v43; // ecx@8
  unsigned int v44; // ebx@11
  bool v45; // bl@15
  unsigned int v47; // [sp+10h] [bp-6Ch]@5
  int v48; // [sp+14h] [bp-68h]@7
  unsigned __int8 v49; // [sp+18h] [bp-64h]@7
  int v50; // [sp+1Ch] [bp-60h]@6
  void *v51; // [sp+20h] [bp-5Ch]@1
  unsigned int v52; // [sp+24h] [bp-58h]@1
  int v53; // [sp+28h] [bp-54h]@1
  float v54; // [sp+2Ch] [bp-50h]@7
  float v55; // [sp+30h] [bp-4Ch]@7
  float v56; // [sp+34h] [bp-48h]@7
  float v57; // [sp+38h] [bp-44h]@7
  float v58; // [sp+3Ch] [bp-40h]@7
  float v59; // [sp+40h] [bp-3Ch]@7
  float v60; // [sp+44h] [bp-38h]@7
  float v61; // [sp+48h] [bp-34h]@7
  float v62; // [sp+4Ch] [bp-30h]@7
  float v63; // [sp+50h] [bp-2Ch]@7
  float v64; // [sp+54h] [bp-28h]@7
  float v65; // [sp+58h] [bp-24h]@7
  float v66; // [sp+5Ch] [bp-20h]@7
  float v67; // [sp+60h] [bp-1Ch]@7
  float v68; // [sp+64h] [bp-18h]@7
  float v69; // [sp+68h] [bp-14h]@7
  int v70; // [sp+78h] [bp-4h]@5

  v3 = this;
  v4 = *(_DWORD *)(this + 28);
  *(_DWORD *)(this + 20) = *(_DWORD *)(this + 24);
  *(_DWORD *)(this + 24) = 33;
  v51 = 0;
  v52 = 0;
  v53 = 0;
  if ( v4 )
  {
    if ( v4 )
      sub_100943C0(v4, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003DD80, (int)&v51, v4 == 1, 0x44u, 0);
    v52 = v4;
  }
  v70 = 0;
  v47 = 0;
  if ( *(_DWORD *)(v3 + 28) > 0u )
  {
    v50 = 0;
    do
    {
      v5 = *(_DWORD *)(v3 + 36) + 8 * v47 * *(_DWORD *)(v3 + 40);
      v6 = *(_BYTE *)(v5 + 4);
      v7 = (unsigned __int8)byte_1009F8C0[(v6 >> 2) & 3];
      v54 = (double)(unsigned __int8)byte_1009F8C0[*(_BYTE *)(v5 + 4) & 3];
      v8 = v7;
      v9 = (unsigned __int8)byte_1009F8C0[(v6 >> 4) & 3];
      v55 = (double)v8;
      v10 = (unsigned __int8)byte_1009F8C0[(unsigned __int8)v6 >> 6];
      v56 = (double)v9;
      v11 = *(_BYTE *)(v5 + 5);
      v12 = (unsigned __int8)byte_1009F8C0[*(_BYTE *)(v5 + 5) & 3];
      v57 = (double)v10;
      v13 = v12;
      v14 = (unsigned __int8)byte_1009F8C0[(v11 >> 2) & 3];
      v58 = (double)v13;
      v15 = v14;
      v16 = (unsigned __int8)byte_1009F8C0[(v11 >> 4) & 3];
      v59 = (double)v15;
      v17 = (unsigned __int8)byte_1009F8C0[(unsigned __int8)v11 >> 6];
      v60 = (double)v16;
      v18 = *(_BYTE *)(v5 + 6);
      v19 = (unsigned __int8)byte_1009F8C0[*(_BYTE *)(v5 + 6) & 3];
      v61 = (double)v17;
      v20 = v19;
      v21 = (unsigned __int8)byte_1009F8C0[(v18 >> 2) & 3];
      v62 = (double)v20;
      v22 = v21;
      v23 = (unsigned __int8)byte_1009F8C0[(v18 >> 4) & 3];
      v63 = (double)v22;
      v64 = (double)v23;
      v24 = (unsigned __int8)byte_1009F8C0[(unsigned __int8)v18 >> 6];
      v25 = *(_BYTE *)(v5 + 7);
      v26 = (unsigned __int8)byte_1009F8C0[*(_BYTE *)(v5 + 7) & 3];
      v65 = (double)v24;
      v27 = v26;
      v28 = (unsigned __int8)byte_1009F8C0[(v25 >> 2) & 3];
      v66 = (double)v27;
      v29 = v28;
      v30 = (unsigned __int8)byte_1009F8C0[(v25 >> 4) & 3];
      v67 = (double)v29;
      v31 = v30;
      LOWORD(v30) = *(_BYTE *)(v5 + 1);
      v32 = (unsigned __int8)byte_1009F8C0[(unsigned __int8)v25 >> 6];
      v68 = (double)v31;
      v33 = (double)v32;
      v34 = (unsigned __int16)(*(_BYTE *)v5 | (unsigned __int16)((_WORD)v30 << 8));
      v69 = v33;
      v35 = 8 * (v34 & 0x1F) | ((v34 & 0x1F) >> 2);
      v36 = 4 * ((v34 >> 5) & 0x3F) | (((v34 >> 5) & 0x3F) >> 4);
      v48 = 8 * (v34 >> 11) | (v34 >> 13);
      v37 = (unsigned __int16)(*(_BYTE *)(v5 + 2) | (unsigned __int16)(*(_BYTE *)(v5 + 3) << 8));
      v38 = v37;
      v49 = v36;
      v39 = v37 >> 11;
      v40 = 8 * (v37 & 0x1F) | ((v37 & 0x1F) >> 2);
      v41 = 4 * ((v38 >> 5) & 0x3F) | (((v38 >> 5) & 0x3F) >> 4);
      v42 = 8 * v39 | (v39 >> 2);
      if ( *(_BYTE *)(v3 + 56) )
        v43 = 25 * (v49 - (unsigned __int8)v41) * (v49 - (unsigned __int8)v41)
            + ((unsigned __int8)v35 - (unsigned __int8)v40) * ((unsigned __int8)v35 - (unsigned __int8)v40)
            + 8 * ((unsigned __int8)v48 - (unsigned __int8)v42) * ((unsigned __int8)v48 - (unsigned __int8)v42);
      else
        v43 = ((unsigned __int8)v48 - (unsigned __int8)v42) * ((unsigned __int8)v48 - (unsigned __int8)v42)
            + (v49 - (unsigned __int8)v41) * (v49 - (unsigned __int8)v41)
            + ((unsigned __int8)v35 - (unsigned __int8)v40) * ((unsigned __int8)v35 - (unsigned __int8)v40);
      if ( v43 / 0x7D0 >= 1 )
      {
        v44 = 2048;
        if ( v43 / 0x7D0 <= 0x800 )
          v44 = v43 / 0x7D0;
      }
      else
      {
        v44 = 1;
      }
      sub_10038C30((int)v51 + v50, (int)&v54);
      *(_DWORD *)((char *)v51 + v50 + 64) = v44;
      ++v47;
      v50 += 68;
    }
    while ( v47 < *(_DWORD *)(v3 + 28) );
  }
  v45 = sub_10037E90(v3 + 1728, (int)&v51, a2, a3, (int)sub_1006E2D0, v3);
  v70 = -1;
  if ( v51 )
  {
    if ( (unsigned __int8)v51 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v51, 0, 0, 1, dword_100AE9F4);
  }
  return v45;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1006F060) --------------------------------------------------------
char __stdcall sub_1006F060(int a1, unsigned int a2, int a3, const void *a4)
{
  int v4; // ebp@1
  unsigned int v5; // esi@3
  double v6; // st7@4
  int v7; // edi@5
  int v8; // eax@5
  unsigned int v9; // edi@5
  float v10; // ST24_4@6
  float v11; // ST24_4@6
  double v12; // st7@6
  int v13; // eax@14
  unsigned int v14; // ecx@14
  char *v15; // eax@14
  unsigned int v16; // ebp@15
  int v17; // esi@17
  int v18; // ebp@17
  unsigned int v19; // edi@17
  unsigned int v20; // ecx@18
  unsigned int v21; // edx@18
  int v22; // ecx@20
  char v23; // bl@20
  unsigned int v24; // ecx@20
  int v25; // ecx@22
  char v26; // bl@22
  unsigned int v27; // ecx@22
  int v28; // ecx@24
  char v29; // bl@24
  int v30; // ecx@26
  char v31; // dl@26
  bool v32; // zf@27
  unsigned int v33; // eax@28
  int v34; // ebp@30
  int v35; // edi@30
  int v36; // ecx@30
  int v37; // eax@30
  char *v38; // ebx@31
  char *v39; // ecx@33
  char *v40; // eax@33
  int v41; // esi@33
  unsigned int v42; // ebp@36
  char *v43; // edi@36
  unsigned __int16 v44; // ax@36
  unsigned int v45; // esi@39
  char *v46; // ebx@40
  int v47; // eax@41
  int v48; // ecx@41
  int v49; // edx@41
  int v50; // eax@41
  int v51; // ecx@42
  int v52; // ebp@43
  unsigned int v53; // edi@43
  unsigned int v54; // esi@44
  char *v55; // ecx@45
  int v56; // eax@46
  long double v57; // st7@47
  long double v58; // st6@47
  long double v59; // st7@48
  float v60; // ST30_4@53
  float v61; // ST30_4@53
  long double v62; // st6@53
  int *v63; // ebp@58
  int v64; // ebp@59
  int v65; // esi@61
  char *v66; // edx@61
  int v67; // edi@62
  char *v68; // eax@63
  char *v69; // ecx@63
  int v70; // esi@66
  int v71; // ebx@66
  unsigned int v72; // ecx@66
  unsigned int v73; // eax@70
  unsigned int v74; // edx@72
  unsigned int v75; // edi@73
  int v76; // ebx@74
  unsigned int v77; // eax@75
  unsigned int v78; // ecx@75
  int v79; // ecx@76
  int v80; // ecx@76
  int v81; // eax@76
  int (__cdecl *v82)(unsigned int, int); // edi@83
  signed int v83; // eax@85
  int v84; // ecx@88
  unsigned int v85; // edx@88
  int v86; // esi@95
  int (__cdecl *v87)(unsigned int, int); // edi@98
  signed int v88; // eax@100
  char result; // al@102
  unsigned int v90; // eax@103
  unsigned int v91; // ecx@107
  unsigned int v92; // eax@111
  float v93; // esi@111
  int v94; // eax@113
  float v95; // edx@114
  float v96; // ecx@114
  float v97; // edx@114
  float v98; // ecx@114
  int v99; // eax@115
  int v100; // ecx@119
  unsigned int v101; // edx@119
  int (__cdecl *v102)(unsigned int, int); // ecx@121
  int v103; // eax@122
  int v104; // ST0C_4@123
  unsigned int v105; // edx@123
  unsigned __int16 v106; // [sp-4h] [bp-620h]@36
  signed int v107; // [sp+14h] [bp-608h]@14
  int v108; // [sp+14h] [bp-608h]@31
  int v109; // [sp+14h] [bp-608h]@61
  unsigned int v110; // [sp+14h] [bp-608h]@70
  signed int v111; // [sp+18h] [bp-604h]@17
  unsigned int i; // [sp+18h] [bp-604h]@28
  int v113; // [sp+18h] [bp-604h]@43
  unsigned int v114; // [sp+18h] [bp-604h]@67
  int v115; // [sp+1Ch] [bp-600h]@14
  char *v116; // [sp+1Ch] [bp-600h]@28
  int v117; // [sp+20h] [bp-5FCh]@14
  int v118; // [sp+20h] [bp-5FCh]@61
  unsigned int v119; // [sp+24h] [bp-5F8h]@3
  int v120; // [sp+24h] [bp-5F8h]@96
  unsigned int v121; // [sp+24h] [bp-5F8h]@108
  int v122; // [sp+28h] [bp-5F4h]@14
  char *v123; // [sp+28h] [bp-5F4h]@31
  unsigned int v124; // [sp+28h] [bp-5F4h]@58
  unsigned int v125; // [sp+2Ch] [bp-5F0h]@3
  int v126; // [sp+2Ch] [bp-5F0h]@104
  char v127; // [sp+33h] [bp-5E9h]@120
  __int64 v128; // [sp+34h] [bp-5E8h]@39
  _DWORD *v129; // [sp+3Ch] [bp-5E0h]@66
  unsigned int v130; // [sp+40h] [bp-5DCh]@5
  int v131; // [sp+44h] [bp-5D8h]@66
  unsigned int v132; // [sp+48h] [bp-5D4h]@3
  unsigned int v133; // [sp+4Ch] [bp-5D0h]@5
  unsigned int v134; // [sp+50h] [bp-5CCh]@12
  unsigned int v135; // [sp+54h] [bp-5C8h]@5
  int v136; // [sp+58h] [bp-5C4h]@9
  double v137; // [sp+5Ch] [bp-5C0h]@43
  float v138; // [sp+64h] [bp-5B8h]@70
  float v139; // [sp+68h] [bp-5B4h]@70
  float v140; // [sp+6Ch] [bp-5B0h]@70
  float v141; // [sp+70h] [bp-5ACh]@70
  float v142; // [sp+74h] [bp-5A8h]@70
  float v143; // [sp+78h] [bp-5A4h]@70
  long double v144; // [sp+7Ch] [bp-5A0h]@6
  int v145; // [sp+84h] [bp-598h]@5
  float v146; // [sp+88h] [bp-594h]@5
  int v147; // [sp+8Ch] [bp-590h]@14
  int v148; // [sp+90h] [bp-58Ch]@66
  int v149; // [sp+94h] [bp-588h]@5
  float v150; // [sp+98h] [bp-584h]@37
  float v151; // [sp+9Ch] [bp-580h]@111
  float v152; // [sp+A0h] [bp-57Ch]@111
  float v153; // [sp+ACh] [bp-570h]@111
  unsigned int v154; // [sp+B0h] [bp-56Ch]@111
  __int64 v155; // [sp+B4h] [bp-568h]@46
  unsigned __int64 v156; // [sp+BCh] [bp-560h]@46
  int v157; // [sp+C8h] [bp-554h]@95
  int v158; // [sp+CCh] [bp-550h]@95
  int v159; // [sp+D0h] [bp-54Ch]@95
  int v160; // [sp+D4h] [bp-548h]@95
  int v161; // [sp+DCh] [bp-540h]@95
  int v162; // [sp+E0h] [bp-53Ch]@95
  int v163; // [sp+E4h] [bp-538h]@3
  int v164; // [sp+E8h] [bp-534h]@3
  int v165; // [sp+ECh] [bp-530h]@3
  int v166; // [sp+F0h] [bp-52Ch]@3
  int v167; // [sp+F4h] [bp-528h]@3
  int v168; // [sp+F8h] [bp-524h]@3
  int v169; // [sp+FCh] [bp-520h]@3
  int v170; // [sp+100h] [bp-51Ch]@3
  double v171; // [sp+104h] [bp-518h]@13
  int v172; // [sp+118h] [bp-504h]@1
  int v173; // [sp+11Ch] [bp-500h]@1
  int v174; // [sp+120h] [bp-4FCh]@1
  int v175; // [sp+124h] [bp-4F8h]@1
  int v176; // [sp+128h] [bp-4F4h]@1
  int v177; // [sp+12Ch] [bp-4F0h]@1
  int v178; // [sp+130h] [bp-4ECh]@1
  int v179; // [sp+134h] [bp-4E8h]@1
  int v180; // [sp+138h] [bp-4E4h]@1
  char v181; // [sp+13Ch] [bp-4E0h]@36
  char v182; // [sp+13Eh] [bp-4DEh]@31
  char v183[254]; // [sp+23Eh] [bp-3DEh]@14
  char v184; // [sp+33Ch] [bp-2E0h]@28
  int v185; // [sp+384h] [bp-298h]@46
  int v186[162]; // [sp+388h] [bp-294h]@46
  int v187; // [sp+618h] [bp-4h]@1

  v4 = a1;
  sub_1006E830(a1);
  *(_DWORD *)(a1 + 8) = GetCurrentThreadId();
  *(_DWORD *)(a1 + 32) = a3;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 28) = a2;
  qmemcpy((void *)(a1 + 44), a4, 0x624u);
  sub_10039830(a1 + 1624, a2);
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 75;
  v172 = 0;
  v173 = 0;
  v174 = 0;
  v175 = 0;
  v176 = 15;
  v177 = 0;
  v178 = 0;
  v179 = 0;
  v180 = 0;
  v187 = 0;
  if ( *(_BYTE *)(a1 + 58) && *(_DWORD *)(a1 + 60) )
  {
    sub_10037D10(a1 + 1624, *(_DWORD *)(a1 + 28));
    v5 = 0;
    v163 = 0;
    v164 = 0;
    v165 = 0;
    v166 = 0;
    v167 = 0;
    v168 = 0;
    v169 = 0;
    v170 = 0;
    v125 = 0;
    v119 = 512;
    v132 = 0;
    if ( *(_DWORD *)(a1 + 60) > 0u )
    {
      v6 = 0.0;
      do
      {
        v7 = *(_DWORD *)(v4 + 12 * v5 + 68);
        v146 = 1.5;
        v135 = v4 + 12 * v5 + 64;
        v8 = *(_DWORD *)(v4 + 12 * v5 + 72);
        v145 = v7;
        v9 = (unsigned int)(v7 + 1) >> 1;
        v133 = v9;
        v149 = v8;
        v130 = (unsigned int)(v8 + 1) >> 1;
        if ( v5 )
        {
          LODWORD(v144) = v5;
          v10 = pow(3.099999904632568, (double)v5);
          v11 = 1.5 / v10;
          v12 = v11;
          if ( v11 < 0.25 )
            v12 = 0.25;
          v146 = v12;
          v6 = 0.0;
        }
        v136 = 0;
        if ( (unsigned int)(v8 + 1) >> 1 )
        {
          while ( 1 )
          {
            v134 = 0;
            if ( v9 )
            {
              v171 = v146 - v6;
              do
              {
                v13 = *(_DWORD *)v135;
                v147 = *(_DWORD *)(v135 + 4);
                v14 = 8 * v136;
                v117 = v13;
                v115 = *(_DWORD *)(a1 + 32);
                v122 = 8 * v136;
                v15 = v183;
                v107 = 8;
                do
                {
                  v16 = 4 * v149 - 1;
                  if ( v14 < v16 )
                    v16 = v14;
                  v17 = v117 + v147 * (v16 >> 2);
                  v18 = v16 & 3;
                  v19 = 8 * v134 + 1;
                  v111 = 2;
                  do
                  {
                    v20 = v19 - 1;
                    v21 = 4 * v145 - 1;
                    if ( v19 - 1 >= v21 )
                      v20 = 4 * v145 - 1;
                    v22 = v115 + 4 * ((v20 & 3) + 4 * (v18 + 4 * (v17 + (v20 >> 2))));
                    *(v15 - 2) = *(_BYTE *)v22;
                    *(v15 - 1) = *(_BYTE *)(v22 + 1);
                    v23 = *(_BYTE *)(v22 + 2);
                    v15[1] = *(_BYTE *)(v22 + 3);
                    *v15 = v23;
                    v24 = v19;
                    if ( v19 >= v21 )
                      v24 = v21;
                    v25 = v115 + 4 * ((v24 & 3) + 4 * (v18 + 4 * (v17 + (v24 >> 2))));
                    v15[2] = *(_BYTE *)v25;
                    v15[3] = *(_BYTE *)(v25 + 1);
                    v26 = *(_BYTE *)(v25 + 2);
                    LOBYTE(v25) = *(_BYTE *)(v25 + 3);
                    v15[4] = v26;
                    v15[5] = v25;
                    v27 = v19 + 1;
                    if ( v19 + 1 >= v21 )
                      v27 = v21;
                    v28 = v115 + 4 * ((v27 & 3) + 4 * (v18 + 4 * (v17 + (v27 >> 2))));
                    v15[6] = *(_BYTE *)v28;
                    v15[7] = *(_BYTE *)(v28 + 1);
                    v29 = *(_BYTE *)(v28 + 2);
                    LOBYTE(v28) = *(_BYTE *)(v28 + 3);
                    v15[8] = v29;
                    v15[9] = v28;
                    if ( v19 + 2 < v21 )
                      v21 = v19 + 2;
                    v30 = v115 + ((v17 + (v21 >> 2)) << 6) + 4 * (4 * v18 + (v21 & 3));
                    v15[10] = *(_BYTE *)v30;
                    v15[11] = *(_BYTE *)(v30 + 1);
                    v31 = *(_BYTE *)(v30 + 2);
                    LOBYTE(v30) = *(_BYTE *)(v30 + 3);
                    v15[12] = v31;
                    v15[13] = v30;
                    v15 += 16;
                    v19 += 4;
                    --v111;
                  }
                  while ( v111 );
                  v14 = v122 + 1;
                  v32 = v107-- == 1;
                  ++v122;
                }
                while ( !v32 );
                v33 = 0;
                v116 = &v184;
                for ( i = 0; ; v33 = i )
                {
                  v34 = *(int *)((char *)dword_100AD2FC + v33);
                  v35 = *(int *)((char *)dword_100AD2F8 + v33);
                  v36 = *(_DWORD *)((char *)&unk_100AD2F0 + v33);
                  v37 = *(_DWORD *)((char *)&unk_100AD2F4 + v33);
                  if ( v34 )
                  {
                    v123 = &v182;
                    v38 = &v183[4 * (v36 + 8 * v37)];
                    v108 = v34;
                    do
                    {
                      if ( v35 )
                      {
                        v39 = v123;
                        v40 = v38;
                        v41 = v35;
                        do
                        {
                          *(v39 - 2) = *(v40 - 2);
                          *(v39 - 1) = *(v40 - 1);
                          *v39 = *v40;
                          v39[1] = v40[1];
                          v40 += 4;
                          v39 += 4;
                          --v41;
                        }
                        while ( v41 );
                      }
                      v123 += 4 * v35;
                      v38 += 32;
                      --v108;
                    }
                    while ( v108 );
                  }
                  v42 = v35 * v34;
                  sub_1006B0B0((unsigned int *)v116 + 1, v116 + 8, v42, (int)&v181, (unsigned int *)v116, 0);
                  v43 = v116;
                  v44 = *(_WORD *)v116;
                  v106 = *((_WORD *)v116 + 2);
                  if ( *(_WORD *)v116 <= v106 )
                    sub_10092630((int)&v150, v44, v106);
                  else
                    sub_100924B0(v44, (int)&v150, v106);
                  v45 = 0;
                  v128 = 0i64;
                  if ( v42 )
                  {
                    v46 = &v182;
                    do
                    {
                      v47 = (unsigned __int8)v43[v45 + 8];
                      v48 = ((unsigned __int8)*(v46 - 2) - *((_BYTE *)&v150 + 4 * v47))
                          * ((unsigned __int8)*(v46 - 2) - *((_BYTE *)&v150 + 4 * v47));
                      v49 = ((unsigned __int8)*(v46 - 1) - *((_BYTE *)&v150 + 4 * v47 + 1))
                          * ((unsigned __int8)*(v46 - 1) - *((_BYTE *)&v150 + 4 * v47 + 1));
                      v50 = (unsigned __int8)*v46 - *((_BYTE *)&v150 + 4 * v47 + 2);
                      v43 = v116;
                      v128 += (unsigned int)(v48 + v49 + v50 * v50);
                      ++v45;
                      v46 += 4;
                    }
                    while ( v45 < v42 );
                  }
                  v51 = HIDWORD(v128);
                  *((_DWORD *)v43 + 18) = v128;
                  *((_DWORD *)v43 + 19) = v51;
                  i += 20;
                  v116 = v43 + 80;
                  if ( i >= 0xB4 )
                    break;
                }
                v137 = -1.0;
                v52 = 0;
                v6 = 0.0;
                v113 = 0;
                v53 = 0;
                do
                {
                  v54 = dword_100AD050[v53];
                  if ( v54 > 0 )
                  {
                    v55 = (char *)&unk_100AD064 + v53 * 4;
                    do
                    {
                      v56 = v186[20 * *(_DWORD *)v55];
                      LODWORD(v155) = *(&v185 + 20 * *(_DWORD *)v55);
                      HIDWORD(v155) = v56 & 0x7FFFFFFF;
                      v156 = __PAIR__(v56 & 0x80000000, 0);
                      v55 += 20;
                      --v54;
                      v6 = v6 + (double)__PAIR__((unsigned int)v56, (unsigned int)v155);
                    }
                    while ( v54 );
                  }
                  v144 = v6 * 0.005208333488553762;
                  v57 = sqrt(v144);
                  v58 = 999999.0;
                  if ( 0.0 == v144 )
                  {
                    v6 = 0.0;
                  }
                  else
                  {
                    v59 = log10(255.0 / v57) * 20.0;
                    v58 = 0.0;
                    if ( v59 >= 0.0 )
                    {
                      if ( v59 > 500.0 )
                        v59 = 500.0;
                      v58 = v59;
                      v6 = 0.0;
                    }
                    else
                    {
                      v6 = 0.0;
                    }
                  }
                  LODWORD(v144) = dword_100AD050[v53] - 1;
                  v60 = (double)LODWORD(v144) / 3.0;
                  v61 = v60 * v171 + v6;
                  v62 = v58 - v61;
                  if ( v137 < v62 )
                  {
                    v52 = v113;
                    v137 = v62;
                  }
                  ++v113;
                  v53 += 21;
                }
                while ( v53 < 168 );
                ++*(&v163 + v52);
                v63 = &dword_100AD050[21 * v52];
                LODWORD(v144) = v63;
                v124 = 0;
                if ( (unsigned int)*v63 > 0 )
                {
                  v64 = (int)(v63 + 1);
                  do
                  {
                    if ( *(_DWORD *)(v64 + 12) )
                    {
                      v118 = 4 * *(_DWORD *)(v64 + 8);
                      v65 = 8 * *(_DWORD *)(v64 + 4);
                      v66 = &v182;
                      v109 = *(_DWORD *)(v64 + 12);
                      do
                      {
                        v67 = *(_DWORD *)(v64 + 8);
                        if ( v67 )
                        {
                          v68 = v66;
                          v69 = &v183[4 * (v65 + *(_DWORD *)v64)];
                          do
                          {
                            *(v68 - 2) = *(v69 - 2);
                            *(v68 - 1) = *(v69 - 1);
                            *v68 = *v69;
                            v68[1] = v69[1];
                            v68 += 4;
                            v69 += 4;
                            --v67;
                          }
                          while ( v67 );
                        }
                        v66 += v118;
                        v65 += 8;
                        --v109;
                      }
                      while ( v109 );
                    }
                    v70 = *(_DWORD *)(v64 + 8);
                    v71 = *(_DWORD *)(v64 + 12);
                    sub_10068DB0(v71 * v70, &v181, &v131, &v148);
                    v147 = BYTE1(v131);
                    v129 = (_DWORD *)BYTE1(v148);
                    v72 = ((unsigned __int8)v131 - (unsigned __int8)v148)
                        * ((unsigned __int8)v131 - (unsigned __int8)v148)
                        + (BYTE1(v131) - BYTE1(v148)) * (BYTE1(v131) - BYTE1(v148))
                        + (BYTE2(v131) - BYTE2(v148)) * (BYTE2(v131) - BYTE2(v148));
                    LODWORD(v137) = BYTE2(v148);
                    if ( v72 / 0x1388 >= 1 )
                    {
                      v114 = 8;
                      if ( v72 / 0x1388 <= 8 )
                        v114 = v72 / 0x1388;
                    }
                    else
                    {
                      v114 = 1;
                    }
                    v73 = 0;
                    v138 = (double)(unsigned __int8)v131;
                    v139 = (double)v147;
                    v110 = 0;
                    v140 = (double)BYTE2(v131);
                    v141 = (double)(unsigned __int8)v148;
                    v142 = (double)(signed int)v129;
                    v143 = (double)SLODWORD(v137);
                    if ( v71 & 0xFFFFFFFC )
                    {
                      LODWORD(v137) = 2 * v136;
                      do
                      {
                        v74 = LODWORD(v137) + v73 + (*(_DWORD *)(v64 + 4) >> 2);
                        if ( v74 < *(_DWORD *)(v135 + 8) )
                        {
                          v75 = 0;
                          if ( v70 & 0xFFFFFFFC )
                          {
                            v76 = 2 * v134;
                            do
                            {
                              v77 = *(_DWORD *)(v135 + 4);
                              v78 = v76 + v75 + (*(_DWORD *)v64 >> 2);
                              if ( v78 >= v77 )
                                break;
                              v79 = 7 * (v78 + *(_DWORD *)v135 + v74 * v77);
                              v129 = (_DWORD *)(a1 + 1624);
                              v80 = 4 * v79;
                              v81 = v80 + *(_DWORD *)(a1 + 1624);
                              if ( (float *)v81 != &v138 )
                              {
                                *(float *)v81 = v138;
                                *(float *)(v81 + 4) = v139;
                                *(float *)(v81 + 8) = v140;
                                *(float *)(v81 + 12) = v141;
                                *(float *)(v81 + 16) = v142;
                                *(float *)(v81 + 20) = v143;
                              }
                              ++v125;
                              *(_DWORD *)(*v129 + v80 + 24) = v114;
                              v70 = *(_DWORD *)(v64 + 8);
                              ++v75;
                            }
                            while ( v75 < *(_DWORD *)(v64 + 8) >> 2 );
                          }
                        }
                        v73 = v110 + 1;
                        v110 = v73;
                      }
                      while ( v73 < *(_DWORD *)(v64 + 12) >> 2 );
                    }
                    v64 += 20;
                    ++v124;
                  }
                  while ( v124 < *(_DWORD *)LODWORD(v144) );
                  v6 = 0.0;
                }
                if ( v125 >= v119 )
                {
                  v82 = *(int (__cdecl **)(unsigned int, int))(a1 + 1600);
                  v119 += 512;
                  if ( v82 )
                  {
                    v83 = *(_DWORD *)(a1 + 28) == 1 ? 100 : *(_DWORD *)(a1 + 20)
                                                          + (((unsigned int)(*(_DWORD *)(a1 + 28) - 1) >> 1)
                                                           + v125 * *(_DWORD *)(a1 + 24))
                                                          / (*(_DWORD *)(a1 + 28) - 1);
                    if ( v83 != *(_DWORD *)(a1 + 1620) )
                    {
                      v84 = *(_DWORD *)(a1 + 1604);
                      v85 = v83 * *(_DWORD *)(a1 + 1612);
                      *(_DWORD *)(a1 + 1620) = v83;
                      if ( !(unsigned __int8)v82(*(_DWORD *)(a1 + 1608) + v85 / 0x64, v84) )
                      {
                        *(_BYTE *)(a1 + 16) = 1;
                        return 0;
                      }
                      v6 = 0.0;
                    }
                  }
                }
                ++v134;
              }
              while ( v134 < v133 );
            }
            if ( ++v136 >= v130 )
              break;
            v9 = v133;
          }
          v5 = v132;
          v4 = a1;
        }
        v132 = ++v5;
      }
      while ( v5 < *(_DWORD *)(v4 + 60) );
    }
    goto LABEL_94;
  }
  v90 = 0;
  v131 = 0;
  if ( *(_DWORD *)(a1 + 28) <= 0u )
  {
LABEL_94:
    *(_DWORD *)(v4 + 20) = 75;
    *(_DWORD *)(v4 + 24) = 20;
    if ( !sub_100373C0(v4 + 1624, v4 + 1624, v4) )
      return 0;
    v157 = 0;
    v158 = 0;
    v159 = 0;
    v160 = 32;
    v161 = 0;
    v162 = 0;
    LOBYTE(v187) = 1;
    v86 = 0;
    *(_DWORD *)(v4 + 20) = 95;
    *(_DWORD *)(v4 + 24) = 5;
    if ( *(_DWORD *)(v4 + 28) <= 0u )
    {
LABEL_121:
      v102 = *(int (__cdecl **)(unsigned int, int))(v4 + 1600);
      *(_DWORD *)(v4 + 1616) = v161 + 128;
      if ( v102 )
      {
        v103 = *(_DWORD *)(v4 + 20) + *(_DWORD *)(v4 + 24);
        if ( v103 != *(_DWORD *)(v4 + 1620) )
        {
          v104 = *(_DWORD *)(v4 + 1604);
          v105 = v103 * *(_DWORD *)(v4 + 1612);
          *(_DWORD *)(v4 + 1620) = v103;
          if ( !(unsigned __int8)v102(*(_DWORD *)(v4 + 1608) + v105 / 0x64, v104) )
            *(_BYTE *)(v4 + 16) = 1;
        }
      }
      LOBYTE(v187) = 0;
      sub_1003F520((int)&v157);
      result = 1;
    }
    else
    {
      v120 = 0;
      while ( 1 )
      {
        if ( !(v86 & 0x1FF) )
        {
          v87 = *(int (__cdecl **)(unsigned int, int))(v4 + 1600);
          if ( v87 )
          {
            v88 = *(_DWORD *)(v4 + 28) == 1 ? 100 : *(_DWORD *)(v4 + 20)
                                                  + (((unsigned int)(*(_DWORD *)(v4 + 28) - 1) >> 1)
                                                   + v86 * *(_DWORD *)(v4 + 24))
                                                  / (*(_DWORD *)(v4 + 28) - 1);
            if ( v88 != *(_DWORD *)(v4 + 1620) )
            {
              v100 = *(_DWORD *)(v4 + 1604);
              v101 = v88 * *(_DWORD *)(v4 + 1612);
              *(_DWORD *)(v4 + 1620) = v88;
              if ( !(unsigned __int8)v87(*(_DWORD *)(v4 + 1608) + v101 / 0x64, v100) )
                break;
            }
          }
        }
        sub_1006B1B0(0, v120 + *(_DWORD *)(v4 + 32), (int)&v128);
        v130 = BYTE4(v128) | ((BYTE5(v128) | (WORD3(v128) << 8)) << 8);
        v127 = 0;
        sub_10035840((int)&v171, (int)&v157, (int *)&v130, &v127);
        v120 += 64;
        if ( (unsigned int)++v86 >= *(_DWORD *)(v4 + 28) )
          goto LABEL_121;
      }
      *(_BYTE *)(v4 + 16) = 1;
      LOBYTE(v187) = 0;
      sub_1003F520((int)&v157);
      result = 0;
    }
    return result;
  }
  v126 = 0;
  while ( v90 & 0x1FF || sub_1006E250(*(_DWORD *)(a1 + 28) - 1, a1, v90) )
  {
    sub_10068DB0(0x10u, v126 + *(_DWORD *)(a1 + 32), &v133, &v132);
    LODWORD(v144) = BYTE1(v133);
    v145 = BYTE1(v132);
    v130 = (unsigned __int8)v133;
    v129 = (_DWORD *)(unsigned __int8)v132;
    LODWORD(v137) = BYTE2(v133);
    v91 = ((unsigned __int8)v133 - (unsigned __int8)v132) * ((unsigned __int8)v133 - (unsigned __int8)v132)
        + (BYTE1(v133) - BYTE1(v132)) * (BYTE1(v133) - BYTE1(v132))
        + (BYTE2(v133) - BYTE2(v132)) * (BYTE2(v133) - BYTE2(v132));
    if ( v91 / 0x1388 >= 1 )
    {
      v121 = 8;
      if ( v91 / 0x1388 <= 8 )
        v121 = v91 / 0x1388;
    }
    else
    {
      v121 = 1;
    }
    v138 = (double)(signed int)v130;
    v150 = v138;
    v92 = *(_DWORD *)(a1 + 1628);
    v139 = (double)SLODWORD(v144);
    v151 = v139;
    v140 = (double)SLODWORD(v137);
    v152 = v140;
    v141 = (double)(signed int)v129;
    v93 = v141;
    v142 = (double)v145;
    v143 = (double)BYTE2(v132);
    v153 = v143;
    v154 = v121;
    if ( v92 >= *(_DWORD *)(a1 + 1632) )
      sub_100943C0(v92 + 1, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1003B7E0, a1 + 1624, 1, 0x1Cu, 0);
    v94 = *(_DWORD *)(a1 + 1624) + 28 * *(_DWORD *)(a1 + 1628);
    if ( v94 )
    {
      v95 = v151;
      *(float *)v94 = v150;
      v96 = v152;
      *(float *)(v94 + 4) = v95;
      v97 = v153;
      *(float *)(v94 + 8) = v96;
      v98 = v142;
      *(float *)(v94 + 12) = v93;
      *(float *)(v94 + 16) = v98;
      *(float *)(v94 + 20) = v97;
      *(_DWORD *)(v94 + 24) = v121;
    }
    v99 = v131;
    ++*(_DWORD *)(a1 + 1628);
    v126 += 64;
    v90 = v99 + 1;
    v131 = v90;
    if ( v90 >= *(_DWORD *)(a1 + 28) )
      goto LABEL_94;
  }
  return 0;
}
// 100AD050: using guessed type int dword_100AD050[];
// 100AD2F8: using guessed type int dword_100AD2F8[];
// 100AD2FC: using guessed type int dword_100AD2FC[];
// 1006F060: using guessed type char var_3DE[254];
// 1006F060: using guessed type int var_294[162];

//----- (1006FE20) --------------------------------------------------------
void __thiscall sub_1006FE20(_DWORD *this, int a2, int a3, int a4)
{
  char v4; // bl@1
  int v5; // edi@1
  int v6; // edx@1
  unsigned int v7; // esi@1
  char v8; // al@1
  int v9; // edx@1
  unsigned int v10; // edx@1
  int v11; // edx@3
  void *v12; // eax@3
  int v13; // eax@13
  unsigned int v14; // ecx@15
  int v15; // eax@15
  unsigned int v16; // esi@15
  unsigned int v17; // eax@21
  char v18; // bl@22
  unsigned int v19; // ebx@25
  unsigned int v20; // eax@28
  int v21; // ecx@31
  int v22; // eax@31
  int v23; // eax@33
  _BYTE *v24; // edx@33
  unsigned int v25; // eax@33
  int v26; // eax@34
  int v27; // ST34_4@35
  int v28; // ecx@35
  int v29; // esi@35
  unsigned int v30; // edx@35
  int v31; // ST28_4@36
  unsigned int v32; // edi@37
  signed int v33; // ebx@38
  int v34; // eax@43
  int v35; // ecx@43
  int v36; // esi@43
  bool v37; // cf@44
  int v38; // edx@44
  int v39; // ecx@50
  bool v40; // zf@50
  unsigned int v41; // edx@53
  unsigned int v42; // esi@53
  void *v43; // ecx@58
  unsigned int v44; // eax@58
  char v45; // bl@58
  _BYTE *v46; // esi@58
  int v47; // ecx@59
  int v48; // eax@59
  signed int v49; // ebx@59
  char *v50; // esi@71
  char *v51; // edi@73
  int v52; // ebx@73
  unsigned int v53; // eax@81
  int v54; // eax@83
  int v55; // edx@83
  unsigned int v56; // ecx@83
  void *v57; // eax@94
  char v58; // [sp+13h] [bp-245h]@33
  char v59; // [sp+13h] [bp-245h]@58
  unsigned int v60; // [sp+14h] [bp-244h]@35
  int v61; // [sp+18h] [bp-240h]@15
  unsigned int v62; // [sp+18h] [bp-240h]@28
  unsigned int v63; // [sp+18h] [bp-240h]@58
  signed int v64; // [sp+18h] [bp-240h]@83
  int v65; // [sp+1Ch] [bp-23Ch]@33
  int v66; // [sp+1Ch] [bp-23Ch]@82
  _DWORD *v67; // [sp+20h] [bp-238h]@21
  unsigned int v68; // [sp+20h] [bp-238h]@35
  __int16 v69; // [sp+26h] [bp-232h]@29
  unsigned int v70; // [sp+28h] [bp-230h]@3
  __int16 v71; // [sp+2Ch] [bp-22Ch]@29
  __int16 v72; // [sp+2Ch] [bp-22Ch]@82
  bool v73; // [sp+2Fh] [bp-229h]@28
  unsigned __int8 v74; // [sp+34h] [bp-224h]@26
  unsigned __int8 v75; // [sp+35h] [bp-223h]@35
  unsigned __int8 v76; // [sp+36h] [bp-222h]@35
  unsigned __int8 v77; // [sp+38h] [bp-220h]@35
  unsigned __int8 v78; // [sp+39h] [bp-21Fh]@35
  unsigned __int8 v79; // [sp+3Ah] [bp-21Eh]@35
  unsigned __int8 v80; // [sp+3Ch] [bp-21Ch]@35
  unsigned __int8 v81; // [sp+3Dh] [bp-21Bh]@35
  unsigned __int8 v82; // [sp+3Eh] [bp-21Ah]@35
  unsigned __int8 v83; // [sp+40h] [bp-218h]@43
  unsigned __int8 v84; // [sp+41h] [bp-217h]@43
  unsigned __int8 v85; // [sp+42h] [bp-216h]@43
  unsigned int v86; // [sp+44h] [bp-214h]@31
  unsigned int v87; // [sp+48h] [bp-210h]@21
  _DWORD *v88; // [sp+4Ch] [bp-20Ch]@1
  LPLONG Target; // [sp+50h] [bp-208h]@21
  void *v90; // [sp+54h] [bp-204h]@3
  unsigned int v91; // [sp+58h] [bp-200h]@3
  int v92; // [sp+5Ch] [bp-1FCh]@3
  int v93; // [sp+60h] [bp-1F8h]@3
  int v94; // [sp+64h] [bp-1F4h]@73
  void *v95; // [sp+68h] [bp-1F0h]@1
  unsigned int v96; // [sp+6Ch] [bp-1ECh]@1
  unsigned int v97; // [sp+70h] [bp-1E8h]@1
  void *v98; // [sp+74h] [bp-1E4h]@1
  unsigned int v99; // [sp+78h] [bp-1E0h]@1
  unsigned int v100; // [sp+7Ch] [bp-1DCh]@1
  int v101; // [sp+80h] [bp-1D8h]@33
  LPLONG v102; // [sp+84h] [bp-1D4h]@34
  int v103; // [sp+88h] [bp-1D0h]@2
  int v104; // [sp+8Ch] [bp-1CCh]@73
  unsigned int v105; // [sp+90h] [bp-1C8h]@25
  int v106; // [sp+94h] [bp-1C4h]@31
  int v107; // [sp+98h] [bp-1C0h]@56
  int v108; // [sp+9Ch] [bp-1BCh]@37
  unsigned int v109; // [sp+A0h] [bp-1B8h]@1
  void *v110; // [sp+A4h] [bp-1B4h]@1
  unsigned int v111; // [sp+A8h] [bp-1B0h]@1
  int v112; // [sp+ACh] [bp-1ACh]@1
  int v113; // [sp+B0h] [bp-1A8h]@1
  char v114; // [sp+B4h] [bp-1A4h]@1
  char v115; // [sp+B5h] [bp-1A3h]@1
  char v116; // [sp+B6h] [bp-1A2h]@1
  int v117; // [sp+B7h] [bp-1A1h]@1
  int v118; // [sp+BCh] [bp-19Ch]@1
  int v119; // [sp+C0h] [bp-198h]@1
  int v120; // [sp+C4h] [bp-194h]@1
  int v121; // [sp+C8h] [bp-190h]@18
  _BYTE *v122; // [sp+CCh] [bp-18Ch]@31
  char v123; // [sp+D0h] [bp-188h]@75
  unsigned __int16 v124; // [sp+D8h] [bp-180h]@80
  unsigned __int16 v125; // [sp+DAh] [bp-17Eh]@80
  void *v126; // [sp+DCh] [bp-17Ch]@1
  char v127; // [sp+ECh] [bp-16Ch]@86
  int v128; // [sp+F8h] [bp-160h]@1
  int v129; // [sp+254h] [bp-4h]@1

  v4 = 0;
  v5 = (int)this;
  v88 = this;
  v95 = 0;
  v96 = 0;
  v97 = 0;
  v129 = 0;
  sub_10038B00((int)&v95, 0x400u);
  v98 = 0;
  v99 = 0;
  v100 = 0;
  LOBYTE(v129) = 1;
  sub_10032F10((int)&v98, 0x400u);
  sub_1007DB20((int)&v128);
  v6 = *(_DWORD *)(v5 + 52);
  v7 = *(_DWORD *)(v5 + 1716);
  v115 = *(_BYTE *)(v5 + 57);
  v8 = *(_BYTE *)(v5 + 56);
  v113 = v6;
  v9 = *(_DWORD *)(v5 + 48);
  v116 = v8;
  v112 = v9;
  v10 = ((((((((((((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1)) >> 8) | ((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1)) >> 4) | ((((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1)) >> 8) | ((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1)) >> 2) | ((((((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1)) >> 8) | ((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1)) >> 4) | ((((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1)) >> 8) | ((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1)) >> 1) | ((((((((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1)) >> 8) | ((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1)) >> 4) | ((((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1)) >> 8) | ((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1)) >> 2) | ((((((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1)) >> 8) | ((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1)) >> 4) | ((((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1)) >> 8) | ((v7 / 0x64 - 1) >> 16) | (v7 / 0x64 - 1))
       + 1) >> 1;
  v109 = 0;
  v110 = 0;
  v111 = 0;
  v114 = 0;
  v117 = 256;
  v118 = 1;
  v119 = 1;
  v120 = 1;
  v126 = 0;
  if ( v10 <= 8 )
  {
    v103 = 8;
    v10 = 8;
  }
  v11 = v10 - 1;
  v12 = 0;
  v103 = v11;
  v90 = 0;
  v91 = 0;
  v92 = 0;
  v93 = 0;
  LOBYTE(v129) = 3;
  v70 = 0;
  if ( v7 > 0 )
  {
    while ( 1 )
    {
      if ( *(_BYTE *)(v5 + 16) != v4 )
      {
        LOBYTE(v129) = 2;
        if ( v12 )
        {
          if ( (unsigned __int8)v12 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v12, 0, 0, 1, dword_100AE9F4);
        }
        LOBYTE(v129) = 1;
        sub_100328F0((int)&v128);
        LOBYTE(v129) = 0;
        v57 = v98;
        if ( v98 )
        {
          if ( !((unsigned __int8)v98 & 7) )
            goto LABEL_108;
          sub_100927E0((int)"crnlib_free: bad ptr");
        }
        goto LABEL_109;
      }
      if ( !(v11 & v70)
        && GetCurrentThreadId() == *(_DWORD *)(v5 + 8)
        && 0 == *(_DWORD *)(v5 + 12)
        && !sub_1006E250(*(_DWORD *)(v5 + 1716) - 1, v5, v70) )
      {
        break;
      }
      v13 = *(_DWORD *)(*(_DWORD *)v5 + 4);
      if ( !v13 || v70 % (v13 + 1) == a2 )
      {
        v14 = v99;
        v15 = *(_DWORD *)(v5 + 1712);
        v16 = 16 * *(_DWORD *)(v15 + 12 * v70 + 4);
        v61 = v15 + 12 * v70;
        if ( v16 != v99 )
        {
          if ( v16 >= v99 )
          {
            if ( v16 > v100 )
            {
              LOBYTE(v121) = v16 == v99 + 1;
              sub_100943C0(v16, 0, (int)&v98, v16 == v99 + 1, 1u, 0);
              v14 = v99;
            }
            memset((char *)v98 + v14, 0, v16 - v14);
          }
          v99 = v16;
        }
        v87 = 0;
        sub_10036D80(v61, (int)&v90);
        Target = (LPLONG)(v5 + 5212);
        sub_100911E0((LPLONG)(v5 + 5212));
        v67 = (_DWORD *)(v5 + 5184);
        v17 = sub_1003A680(v5 + 5184, (int)&v90);
        if ( v17 == *(_DWORD *)(v5 + 5188) )
        {
          v18 = 0;
        }
        else
        {
          v18 = 1;
          v87 = *(_DWORD *)(*v67 + 24 * v17 + 16);
        }
        InterlockedExchange(Target, 0);
        if ( v18 )
        {
          v19 = v87 >> 16;
          v105 = v87 >> 16;
          if ( (unsigned __int16)v87 <= HIWORD(v87) )
            sub_10092630((int)&v74, v87, HIWORD(v87));
          else
            sub_100924B0(v87, (int)&v74, HIWORD(v87));
          v73 = (unsigned __int16)v87 <= (unsigned __int16)v19;
          v20 = 0;
          v62 = 0;
          if ( v91 )
          {
            v69 = (unsigned __int16)v87 >> 8;
            v71 = (unsigned __int16)v19 >> 8;
            while ( 1 )
            {
              v21 = *((_DWORD *)v90 + v20);
              v22 = *(_DWORD *)(v5 + 32) + (*((_DWORD *)v90 + v20) << 6);
              v106 = v21;
              v122 = (_BYTE *)(v22 + 62);
              v86 = 16;
              while ( 1 )
              {
                v23 = *(_DWORD *)(v5 + 36) + 8 * v21 * *(_DWORD *)(v5 + 40);
                *(_BYTE *)v23 = v87;
                *(_BYTE *)(v23 + 1) = v69;
                *(_BYTE *)(v23 + 2) = v19;
                *(_BYTE *)(v23 + 3) = v71;
                v58 = *(_BYTE *)(v5 + 56);
                v24 = v122;
                v101 = v23;
                v25 = 0;
                Target = (LPLONG)15;
                v65 = (int)v122;
                do
                {
                  v102 = (LPLONG)(4 * v25);
                  v26 = *(v24 - 2);
                  if ( v58 )
                  {
                    v27 = *(v24 - 2) - v74;
                    v28 = *(v24 - 1);
                    v29 = *v24;
                    v68 = (v29 - v76) * (v29 - v76) + 25 * (v28 - v75) * (v28 - v75) + 8 * v27 * v27;
                    v60 = (v29 - v79) * (v29 - v79) + 25 * (v28 - v78) * (v28 - v78) + 8 * (v26 - v77) * (v26 - v77);
                    v30 = (v29 - v82) * (v29 - v82) + 25 * (v28 - v81) * (v28 - v81) + 8 * (v26 - v80) * (v26 - v80);
                  }
                  else
                  {
                    v31 = *(v24 - 2) - v74;
                    v28 = *(v24 - 1);
                    v29 = *v24;
                    v68 = (v29 - v76) * (v29 - v76) + v31 * v31 + (v28 - v75) * (v28 - v75);
                    v60 = (v26 - v77) * (v26 - v77) + (v28 - v78) * (v28 - v78) + (v29 - v79) * (v29 - v79);
                    v30 = (v26 - v80) * (v26 - v80) + (v28 - v81) * (v28 - v81) + (v29 - v82) * (v29 - v82);
                  }
                  v32 = v60;
                  v108 = 0;
                  if ( v60 >= v68 )
                  {
                    v32 = v68;
                    v33 = v108;
                  }
                  else
                  {
                    v33 = 1;
                  }
                  if ( v30 < v32 )
                  {
                    v33 = 2;
                    v32 = v30;
                  }
                  if ( v73 )
                  {
                    v38 = v65;
                    v5 = (int)v88;
                    v37 = (unsigned int)*(_BYTE *)(v65 + 1) < v88[12];
                  }
                  else
                  {
                    v34 = v26 - v83;
                    v35 = (v28 - v84) * (v28 - v84);
                    v36 = v29 - v85;
                    if ( v58 )
                    {
                      v37 = v36 * v36 + 25 * v35 + 8 * v34 * v34 < v32;
                      v38 = v65;
                      v5 = (int)v88;
                    }
                    else
                    {
                      v37 = v34 * v34 + v35 + v36 * v36 < v32;
                      v38 = v65;
                      v5 = (int)v88;
                    }
                  }
                  if ( v37 )
                    v33 = 3;
                  v24 = (_BYTE *)(v38 - 4);
                  v25 = v33 | (unsigned int)v102;
                  Target = (LPLONG)((char *)Target - 1);
                  v65 = (int)v24;
                }
                while ( (signed int)Target >= 0 );
                v39 = v101;
                *(_BYTE *)(v101 + 5) = BYTE1(v25);
                *(_BYTE *)(v39 + 4) = v25;
                v40 = v86-- == 1;
                *(_BYTE *)(v39 + 6) = v25 >> 16;
                *(_BYTE *)(v39 + 7) = BYTE3(v25);
                if ( v40 )
                  break;
                v21 = v106;
                LOBYTE(v19) = v105;
              }
              v20 = v62 + 1;
              v62 = v20;
              if ( v20 >= v91 )
                break;
              LOBYTE(v19) = v105;
            }
          }
        }
        else
        {
          v41 = v96;
          v42 = 16 * v91;
          if ( 16 * v91 != v96 )
          {
            if ( 16 * v91 >= v96 && v42 > v97 )
            {
              LOBYTE(v107) = v42 == v96 + 1;
              sub_100943C0(16 * v91, 0, (int)&v95, v42 == v96 + 1, 4u, 0);
            }
            v96 = v42;
            v41 = v42;
          }
          v43 = v95;
          v44 = 0;
          v45 = 0;
          v46 = v95;
          v59 = 0;
          v63 = 0;
          if ( v91 )
          {
            do
            {
              v47 = (int)(v46 + 6);
              v48 = *(_DWORD *)(v5 + 32) + (*((_DWORD *)v90 + v44) << 6) + 7;
              v49 = 4;
              do
              {
                if ( (unsigned int)*(_BYTE *)(v48 - 4) < *(_DWORD *)(v5 + 48) )
                  v59 = 1;
                *v46 = *(_BYTE *)(v48 - 7);
                *(_BYTE *)(v47 - 5) = *(_BYTE *)(v48 - 6);
                *(_BYTE *)(v47 - 4) = *(_BYTE *)(v48 - 5);
                *(_BYTE *)(v47 - 3) = *(_BYTE *)(v48 - 4);
                if ( (unsigned int)*(_BYTE *)v48 < *(_DWORD *)(v5 + 48) )
                  v59 = 1;
                *(_BYTE *)(v47 - 2) = *(_BYTE *)(v48 - 3);
                *(_BYTE *)(v47 - 1) = *(_BYTE *)(v48 - 2);
                *(_BYTE *)v47 = *(_BYTE *)(v48 - 1);
                *(_BYTE *)(v47 + 1) = *(_BYTE *)v48;
                if ( (unsigned int)*(_BYTE *)(v48 + 4) < *(_DWORD *)(v5 + 48) )
                  v59 = 1;
                *(_BYTE *)(v47 + 2) = *(_BYTE *)(v48 + 1);
                *(_BYTE *)(v47 + 3) = *(_BYTE *)(v48 + 2);
                *(_BYTE *)(v47 + 4) = *(_BYTE *)(v48 + 3);
                *(_BYTE *)(v47 + 5) = *(_BYTE *)(v48 + 4);
                if ( (unsigned int)*(_BYTE *)(v48 + 8) < *(_DWORD *)(v5 + 48) )
                  v59 = 1;
                *(_BYTE *)(v47 + 6) = *(_BYTE *)(v48 + 5);
                *(_BYTE *)(v47 + 7) = *(_BYTE *)(v48 + 6);
                *(_BYTE *)(v47 + 8) = *(_BYTE *)(v48 + 7);
                *(_BYTE *)(v47 + 9) = *(_BYTE *)(v48 + 8);
                v48 += 16;
                v46 += 16;
                v47 += 16;
                --v49;
              }
              while ( v49 );
              v44 = v63 + 1;
              v63 = v44;
            }
            while ( v44 < v91 );
            v43 = v95;
            v41 = v96;
            v45 = v59;
          }
          v40 = *(_DWORD *)(v5 + 52) == 0;
          v50 = (char *)v98;
          v109 = v70;
          v111 = v41;
          v110 = v43;
          v126 = v98;
          if ( !v40 || v45 )
          {
            v114 = v45;
            if ( v43
              && sub_10084780((int)&v128, (int)&v109, (int)&v123)
              && *(_BYTE *)(v128 + 21)
              && *(_BYTE *)(v128 + 25)
              && !*(_BYTE *)(v128 + 20) )
            {
              sub_10084890((int)&v128);
            }
            v52 = v125;
            v94 = v124;
            v104 = v125;
          }
          else
          {
            v51 = (char *)v98;
            sub_1006B0B0((unsigned int *)&v104, v98, v41, (int)v43, (unsigned int *)&v94, 1);
            v52 = v104;
            v50 = v51;
            v5 = (int)v88;
          }
          v53 = 0;
          v86 = 0;
          if ( v91 )
          {
            v72 = (unsigned __int16)v94 >> 8;
            v66 = (int)(v50 + 14);
            do
            {
              v54 = *(_DWORD *)(v5 + 36) + 8 * *((_DWORD *)v90 + v53) * *(_DWORD *)(v5 + 40);
              *(_BYTE *)v54 = v94;
              *(_BYTE *)(v54 + 1) = v72;
              v55 = v66;
              *(_BYTE *)(v54 + 3) = BYTE1(v52);
              *(_BYTE *)(v54 + 2) = v52;
              v56 = 0;
              v64 = 4;
              do
              {
                v56 = 4 * (*(_BYTE *)(v55 - 1) | 4 * (*(_BYTE *)v55 | 4 * (4 * v56 | *(_BYTE *)(v55 + 1)))) | *(_BYTE *)(v55 - 2);
                v55 -= 4;
                --v64;
              }
              while ( v64 );
              v66 += 16;
              *(_BYTE *)(v54 + 5) = BYTE1(v56);
              *(_BYTE *)(v54 + 4) = v56;
              *(_BYTE *)(v54 + 6) = v56 >> 16;
              *(_BYTE *)(v54 + 7) = BYTE3(v56);
              v53 = v86 + 1;
              v86 = v53;
            }
            while ( v53 < v91 );
          }
          v102 = Target;
          sub_100911E0(Target);
          LOBYTE(v129) = 4;
          v101 = v94 | (v52 << 16);
          sub_10038A20((int)&v90, (int)v67, (int)&v127, &v101);
          LOBYTE(v129) = 3;
          InterlockedExchange(v102, 0);
          v5 = (int)v88;
        }
        v4 = 0;
      }
      v37 = v70++ + 1 < *(_DWORD *)(v5 + 1716);
      v12 = v90;
      if ( !v37 )
        goto LABEL_4;
      v11 = v103;
    }
    LOBYTE(v129) = 2;
    if ( v90 )
    {
      if ( (unsigned __int8)v90 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v90, 0, 0, 1, dword_100AE9F4);
    }
    LOBYTE(v129) = 1;
    sub_100328F0((int)&v128);
    LOBYTE(v129) = 0;
    v57 = v98;
    if ( v98 )
    {
      if ( !((unsigned __int8)v98 & 7) )
        goto LABEL_108;
      sub_100927E0((int)"crnlib_free: bad ptr");
    }
  }
  else
  {
LABEL_4:
    LOBYTE(v129) = 2;
    if ( v12 )
    {
      if ( (unsigned __int8)v12 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v12, 0, 0, 1, dword_100AE9F4);
    }
    LOBYTE(v129) = 1;
    sub_100328F0((int)&v128);
    LOBYTE(v129) = 0;
    v57 = v98;
    if ( v98 )
    {
      if ( (unsigned __int8)v98 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
LABEL_108:
        off_100AD9F4(v57, 0, 0, 1, dword_100AE9F4);
    }
  }
LABEL_109:
  v129 = -1;
  if ( v95 )
  {
    if ( (unsigned __int8)v95 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v95, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10070950) --------------------------------------------------------
bool __stdcall sub_10070950(int a1, int a2, int a3, float a4)
{
  double v4; // st7@3
  unsigned int v5; // esi@3
  double v6; // st7@3
  unsigned int v7; // eax@3
  unsigned int v8; // ecx@7
  double v9; // st7@7
  unsigned int v10; // eax@7
  _DWORD *v11; // edi@11
  int v12; // ebx@13
  unsigned int v13; // ecx@13
  unsigned int v14; // eax@14
  int v15; // esi@14
  unsigned int v16; // esi@23
  int v17; // edx@24
  int *v18; // eax@24
  bool v19; // c0@28
  bool v20; // c3@28
  int v21; // eax@28
  int v22; // edi@34
  int v23; // eax@34
  struct _SINGLE_LIST_ENTRY *v24; // esi@34
  FILE *v25; // eax@36
  int v26; // ebx@38
  PSINGLE_LIST_ENTRY v27; // eax@39
  FILE *v28; // eax@42
  FILE *v29; // eax@49
  int v30; // ecx@53
  int v32; // esi@59
  int *v33; // eax@62
  int v34; // ecx@68
  int v35; // edi@69
  int v36; // eax@69
  struct _SINGLE_LIST_ENTRY *v37; // esi@69
  FILE *v38; // eax@71
  int v39; // ebx@73
  PSINGLE_LIST_ENTRY v40; // eax@74
  FILE *v41; // eax@77
  FILE *v42; // eax@84
  int v43; // ecx@88
  int v44; // [sp+14h] [bp-640h]@3
  unsigned int v45; // [sp+18h] [bp-63Ch]@3
  unsigned int v46; // [sp+1Ch] [bp-638h]@8
  int v47; // [sp+20h] [bp-634h]@3
  float v48; // [sp+24h] [bp-630h]@3
  __int64 v49; // [sp+28h] [bp-62Ch]@3
  int v50; // [sp+34h] [bp-620h]@68
  struct _SINGLE_LIST_ENTRY *v51; // [sp+4Ch] [bp-608h]@47
  char DstBuf; // [sp+50h] [bp-604h]@36
  CHAR OutputString; // [sp+250h] [bp-404h]@42
  CHAR v54; // [sp+450h] [bp-204h]@49

  *(_DWORD *)(a1 + 8) = GetCurrentThreadId();
  *(_DWORD *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 36) = a2;
  *(_DWORD *)(a1 + 40) = 1;
  qmemcpy((void *)(a1 + 44), (const void *)a3, 0x624u);
  if ( !*(_BYTE *)(a1 + 57) )
    *(_DWORD *)(a1 + 48) = 0;
  v4 = (double)*(unsigned int *)(a1 + 44);
  *(_DWORD *)(a1 + 1620) = -1;
  v48 = v4 / 255.0;
  *(float *)&v44 = a4 * 1.649999976158142;
  *(float *)&v44 = pow(v48, *(float *)&v44);
  v5 = *(_DWORD *)(a1 + 1652);
  v47 = v44;
  *(float *)&v44 = a4 * 1.799999952316284;
  *(float *)&v44 = pow(v48, *(float *)&v44);
  v6 = *(float *)&v44 * (double)v5;
  v44 = (unsigned __int16)v45 | 0xC00;
  v49 = (signed __int64)v6;
  v7 = (signed __int64)v6;
  if ( v7 >= 0x60 )
  {
    if ( v7 <= v5 )
      v5 = (signed __int64)v6;
  }
  else
  {
    v5 = 96;
  }
  v8 = *(_DWORD *)(a1 + 1616);
  v9 = (double)*(unsigned int *)(a1 + 1616) * *(float *)&v47;
  v44 = (unsigned __int16)v45 | 0xC00;
  v49 = (signed __int64)v9;
  v10 = (signed __int64)v9;
  if ( v10 >= 0x80 )
  {
    v46 = v8;
    if ( v10 <= v8 )
      v46 = (signed __int64)v9;
  }
  else
  {
    v46 = 128;
  }
  v11 = (_DWORD *)(a1 + 1712);
  if ( v48 < 1.0 )
  {
    sub_10037AF0((void *)(a1 + 1712), a1 + 1624, v5);
  }
  else
  {
    sub_10037280((int)v11, *(_DWORD *)(a1 + 28), 0);
    v45 = 0;
    if ( *(_DWORD *)(a1 + 28) > 0u )
    {
      v12 = 0;
      v13 = 0;
      do
      {
        v14 = *(_DWORD *)(*v11 + v12 + 4);
        v15 = v12 + *v11;
        if ( v14 != 1 )
        {
          if ( v14 <= 1 )
          {
            if ( *(_DWORD *)(v15 + 8) < 1u )
            {
              LOBYTE(v44) = v14 == 0;
              sub_100943C0(1u, 0, v15, v44, 4u, 0);
            }
            memset((void *)(4 * *(_DWORD *)(v15 + 4) + *(_DWORD *)v15), 0, 4 - 4 * *(_DWORD *)(v15 + 4));
            v13 = v45;
          }
          *(_DWORD *)(v15 + 4) = 1;
        }
        **(_DWORD **)(v12 + *v11) = v13++;
        v12 += 12;
        v45 = v13;
      }
      while ( v13 < *(_DWORD *)(a1 + 28) );
    }
  }
  v16 = 0;
  if ( *(_DWORD *)(a1 + 1716) )
  {
    v17 = *(_DWORD *)(a1 + 1716);
    v18 = (int *)(*v11 + 4);
    do
    {
      if ( v16 <= *v18 )
        v16 = *v18;
      v18 += 3;
      --v17;
    }
    while ( v17 );
  }
  v19 = 1.0 < v48;
  v20 = 1.0 == v48;
  v21 = 3 * *(_DWORD *)a3 + 528;
  LODWORD(v49) = a1 + 4 * v21;
  *(_DWORD *)(a1 + 20) = 0;
  if ( v19 || v20 )
  {
    *(_DWORD *)(a1 + 24) = 100;
  }
  else if ( *(_DWORD *)(a1 + 4 * v21 + 4) )
  {
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 52) != 0 ? 50 : 10;
  }
  else
  {
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 52) != 0 ? 33 : 10;
  }
  v45 = 0;
  do
  {
    v22 = *(_DWORD *)a1;
    v47 = 16;
    v23 = off_100AD9F4(0, 16, &v47, 1, dword_100AE9F4);
    v24 = (struct _SINGLE_LIST_ENTRY *)v23;
    if ( v23 && (unsigned int)v47 >= 0x10 )
    {
      *(_DWORD *)v23 = &off_100A4F34;
      *(_DWORD *)(v23 + 4) = a1;
      *(_DWORD *)(v23 + 8) = sub_1006FE20;
      *(_DWORD *)(v23 + 12) = 1;
      InterlockedIncrement((LPLONG)(v22 + 80));
      v26 = *(_DWORD *)v22;
      if ( *(_BYTE *)(*(_DWORD *)v22 + 16) )
      {
        v27 = InterlockedPopEntrySList((PSLIST_HEADER)(v26 + 8));
        if ( v27 )
          goto LABEL_93;
      }
      v44 = 32;
      v27 = (PSINGLE_LIST_ENTRY)off_100AD9F4(0, 32, &v44, 1, dword_100AE9F4);
      if ( !v27 || (unsigned int)v44 < 0x20 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_malloc: out of memory");
        OutputDebugStringA(&OutputString);
        v28 = _iob_func();
        fputs(&OutputString, v28 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
        v27 = 0;
      }
      if ( v27 )
      {
LABEL_93:
        if ( v27 != (PSINGLE_LIST_ENTRY)-8 )
        {
          v27[2].Next = (struct _SINGLE_LIST_ENTRY *)v45;
          v27[3].Next = 0;
          v27[4].Next = 0;
          v27[5].Next = v24;
          v27[6].Next = (struct _SINGLE_LIST_ENTRY *)1;
          v27[7].Next = v51;
        }
        InterlockedPushEntrySList((PSLIST_HEADER)v26, v27);
        if ( !ReleaseSemaphore(*(HANDLE *)(v22 + 72), 1, 0) )
        {
          sprintf_s(
            &v54,
            0x200u,
            "%s(%u): Failure: \"%s\"\n",
            "crn_threading_win32.cpp",
            198,
            "\"semaphore: ReleaseSemaphore() failed\"");
          OutputDebugStringA(&v54);
          v29 = _iob_func();
          fputs(&v54, v29 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
          if ( !byte_100AE9F8 )
LABEL_58:
            exit(1);
          RaiseException(0x100u, 0, 0, 0);
        }
      }
      else
      {
        InterlockedIncrement((LPLONG)(v22 + 84));
      }
    }
    else
    {
      sprintf_s(
        &DstBuf,
        0x200u,
        "%s(%u): Assertion failed: \"%s\"\n",
        "crn_mem.cpp",
        216,
        "crnlib_malloc: out of memory");
      OutputDebugStringA(&DstBuf);
      v25 = _iob_func();
      fputs(&DstBuf, v25 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    v30 = *(_DWORD *)a1;
    ++v45;
  }
  while ( v45 <= *(_DWORD *)(v30 + 4) );
  sub_10091500(v30);
  if ( *(_BYTE *)(a1 + 16) )
    return 0;
  if ( v48 >= 1.0 )
    return 1;
  v32 = v49;
  if ( !*(_DWORD *)(v49 + 4) )
  {
    sub_1006EC50(a1, v46, v49);
    if ( *(_BYTE *)(a1 + 16) )
    {
      if ( *(_DWORD *)v32 )
      {
        sub_1003E4E0(*(_DWORD *)(v32 + 4), *(int **)v32);
        v33 = *(int **)v32;
        if ( *(_DWORD *)v32 )
        {
          if ( (unsigned __int8)v33 & 7 )
          {
            sub_100927E0((int)"crnlib_free: bad ptr");
            *(_DWORD *)v32 = 0;
            *(_DWORD *)(v32 + 4) = 0;
            *(_DWORD *)(v32 + 8) = 0;
            return 0;
          }
          off_100AD9F4(v33, 0, 0, 1, dword_100AE9F4);
        }
        *(_DWORD *)v32 = 0;
        *(_DWORD *)(v32 + 4) = 0;
        *(_DWORD *)(v32 + 8) = 0;
      }
      return 0;
    }
  }
  *(_DWORD *)(a1 + 20) += *(_DWORD *)(a1 + 24);
  v34 = 100 - *(_DWORD *)(a1 + 20);
  v50 = v32;
  *(_DWORD *)(a1 + 24) = v34;
  v46 = 0;
  do
  {
    v35 = *(_DWORD *)a1;
    v44 = 16;
    v36 = off_100AD9F4(0, 16, &v44, 1, dword_100AE9F4);
    v37 = (struct _SINGLE_LIST_ENTRY *)v36;
    if ( v36 && (unsigned int)v44 >= 0x10 )
    {
      *(_DWORD *)v36 = &off_100A4F34;
      *(_DWORD *)(v36 + 4) = a1;
      *(_DWORD *)(v36 + 8) = sub_1006E340;
      *(_DWORD *)(v36 + 12) = 1;
      InterlockedIncrement((LPLONG)(v35 + 80));
      v39 = *(_DWORD *)v35;
      if ( *(_BYTE *)(*(_DWORD *)v35 + 16) )
      {
        v40 = InterlockedPopEntrySList((PSLIST_HEADER)(v39 + 8));
        if ( v40 )
          goto LABEL_94;
      }
      v47 = 32;
      v40 = (PSINGLE_LIST_ENTRY)off_100AD9F4(0, 32, &v47, 1, dword_100AE9F4);
      if ( !v40 || (unsigned int)v47 < 0x20 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_malloc: out of memory");
        OutputDebugStringA(&OutputString);
        v41 = _iob_func();
        fputs(&OutputString, v41 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
        v40 = 0;
      }
      if ( v40 )
      {
LABEL_94:
        if ( v40 != (PSINGLE_LIST_ENTRY)-8 )
        {
          v40[2].Next = (struct _SINGLE_LIST_ENTRY *)v46;
          v40[3].Next = 0;
          v40[4].Next = (struct _SINGLE_LIST_ENTRY *)&v50;
          v40[5].Next = v37;
          v40[6].Next = (struct _SINGLE_LIST_ENTRY *)1;
          v40[7].Next = v51;
        }
        InterlockedPushEntrySList((PSLIST_HEADER)v39, v40);
        if ( !ReleaseSemaphore(*(HANDLE *)(v35 + 72), 1, 0) )
        {
          sprintf_s(
            &DstBuf,
            0x200u,
            "%s(%u): Failure: \"%s\"\n",
            "crn_threading_win32.cpp",
            198,
            "\"semaphore: ReleaseSemaphore() failed\"");
          OutputDebugStringA(&DstBuf);
          v42 = _iob_func();
          fputs(&DstBuf, v42 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
          if ( !byte_100AE9F8 )
            goto LABEL_58;
          RaiseException(0x100u, 0, 0, 0);
        }
      }
      else
      {
        InterlockedIncrement((LPLONG)(v35 + 84));
      }
    }
    else
    {
      sprintf_s(&v54, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_malloc: out of memory");
      OutputDebugStringA(&v54);
      v38 = _iob_func();
      fputs(&v54, v38 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    v43 = *(_DWORD *)a1;
    ++v46;
  }
  while ( v46 <= *(_DWORD *)(v43 + 4) );
  sub_10091500(v43);
  return *(_BYTE *)(a1 + 16) == 0;
}
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (10071220) --------------------------------------------------------
int __stdcall sub_10071220(int a1)
{
  *(_DWORD *)a1 = &off_100A5030;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = -1;
  *(_WORD *)(a1 + 44) = 0;
  *(_WORD *)(a1 + 46) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 52) = 0;
  *(_WORD *)(a1 + 54) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = 15;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 88) = -1;
  *(_DWORD *)(a1 + 92) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 116) = 0;
  *(_DWORD *)(a1 + 128) = 4;
  *(_DWORD *)(a1 + 136) = 16777217;
  *(_DWORD *)(a1 + 132) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 148) = 0;
  *(_DWORD *)(a1 + 120) = 128;
  *(_DWORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 156) = 100;
  *(_WORD *)(a1 + 140) = 1;
  *(_DWORD *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 164) = 1;
  *(_DWORD *)(a1 + 168) = 1;
  *(_DWORD *)(a1 + 172) = 1;
  sub_10091840(a1 + 176);
  *(_DWORD *)(a1 + 268) = 255;
  *(_DWORD *)(a1 + 276) = 4;
  *(_DWORD *)(a1 + 272) = 0;
  *(_WORD *)(a1 + 280) = 257;
  *(_DWORD *)(a1 + 1824) = 0;
  *(_DWORD *)(a1 + 1828) = 0;
  *(_DWORD *)(a1 + 284) = 0;
  *(_BYTE *)(a1 + 282) = 1;
  memset((void *)(a1 + 288), 0, 0x600u);
  *(_DWORD *)(a1 + 1832) = 0;
  *(_DWORD *)(a1 + 1836) = 100;
  sub_100339F0(a1 + 1840);
  *(_DWORD *)(a1 + 3416) = 0;
  return a1;
}
// 100A5030: using guessed type int (__stdcall *off_100A5030)(char);

//----- (100713C0) --------------------------------------------------------
char __userpurge sub_100713C0@<al>(int a1@<eax>, int a2, int a3)
{
  void *v3; // esp@1
  int v4; // eax@1
  void (*v5)(char *, size_t, const char *, ...); // ebp@1
  char v6; // dl@1
  bool v7; // zf@3
  int v8; // esi@4
  signed int v9; // ebx@5
  unsigned int v10; // edi@7
  int v11; // ebp@10
  int v12; // eax@10
  FILE *v13; // eax@12
  unsigned int v14; // ebx@17
  int v15; // edi@17
  unsigned int v16; // edx@18
  unsigned int v17; // eax@19
  _BYTE *v18; // ecx@20
  int v19; // eax@29
  unsigned int v20; // edi@29
  char *v21; // ebx@30
  unsigned int v22; // esi@31
  char *v23; // ecx@32
  char result; // al@36
  int *v25; // esi@48
  int v26; // edx@49
  int v27; // eax@49
  int v28; // ecx@49
  int v29; // edx@49
  int v30; // eax@49
  int v31; // ecx@49
  int v32; // edx@49
  int v33; // eax@49
  int v34; // ecx@49
  FILE *v35; // eax@51
  int v36; // edx@54
  unsigned int v37; // esi@57
  int v38; // eax@57
  char *v39; // ebx@57
  char *v40; // edi@58
  int v41; // eax@60
  FILE *v42; // eax@62
  int v43; // ebx@64
  int v44; // eax@65
  FILE *v45; // eax@67
  int v46; // esi@69
  int v47; // eax@70
  int v48; // eax@70
  int v49; // eax@70
  int v50; // eax@70
  int v51; // eax@70
  int v52; // eax@70
  int v53; // eax@70
  int v54; // eax@70
  int v55; // eax@70
  int v56; // eax@70
  int v57; // eax@71
  FILE *v58; // eax@73
  FILE *v59; // eax@79
  void *v60; // eax@83
  int v61; // eax@84
  FILE *v62; // eax@86
  FILE *v63; // eax@90
  _DWORD *v64; // ecx@97
  unsigned int v65; // eax@97
  int v66; // edx@99
  int v67; // esi@102
  int v68; // eax@103
  char *v69; // eax@103
  int v70; // eax@103
  char *v71; // eax@105
  int v72; // eax@106
  FILE *v73; // eax@108
  FILE *v74; // eax@113
  char v75; // [sp+1h] [bp-19D9h]@1
  void *v76; // [sp+2h] [bp-19D8h]@4
  unsigned int v77; // [sp+2h] [bp-19D8h]@41
  void *v78; // [sp+2h] [bp-19D8h]@58
  void *v79; // [sp+6h] [bp-19D4h]@1
  int v80; // [sp+Ah] [bp-19D0h]@2
  void *v81; // [sp+Eh] [bp-19CCh]@2
  unsigned int v82; // [sp+12h] [bp-19C8h]@3
  char *v83; // [sp+16h] [bp-19C4h]@58
  char *v84; // [sp+1Ah] [bp-19C0h]@57
  void *v85; // [sp+1Eh] [bp-19BCh]@57
  int v86; // [sp+22h] [bp-19B8h]@57
  int v87; // [sp+26h] [bp-19B4h]@57
  int v88; // [sp+2Ah] [bp-19B0h]@49
  int v89; // [sp+2Eh] [bp-19ACh]@49
  int v90; // [sp+32h] [bp-19A8h]@49
  int v91; // [sp+36h] [bp-19A4h]@49
  int v92; // [sp+3Ah] [bp-19A0h]@49
  int v93; // [sp+3Eh] [bp-199Ch]@49
  int v94; // [sp+42h] [bp-1998h]@49
  int v95; // [sp+46h] [bp-1994h]@49
  int v96; // [sp+4Ah] [bp-1990h]@49
  char DstBuf; // [sp+4Eh] [bp-198Ch]@12
  CHAR v98; // [sp+24Eh] [bp-178Ch]@90
  CHAR v99; // [sp+44Eh] [bp-158Ch]@73
  CHAR v100; // [sp+64Eh] [bp-138Ch]@86
  CHAR OutputString; // [sp+84Eh] [bp-118Ch]@67
  CHAR v102; // [sp+A4Eh] [bp-F8Ch]@79
  char v103; // [sp+C4Eh] [bp-D8Ch]@1
  char v104; // [sp+C5Eh] [bp-D7Ch]@30
  char v105; // [sp+C66h] [bp-D74h]@2
  char v106; // [sp+C6Eh] [bp-D6Ch]@46
  int v107; // [sp+19CEh] [bp-Ch]@1
  int (__thiscall *v108)(void *); // [sp+19D2h] [bp-8h]@1
  int v109; // [sp+19D6h] [bp-4h]@1

  v109 = -1;
  v108 = sub_10096DDE;
  v107 = a1;
  v3 = alloca(6608);
  `eh vector constructor iterator'(&v103, 0x24u, 96, (int)sub_100336F0, sub_100336C0);
  v109 = 0;
  v4 = *(_DWORD *)(a2 + 112);
  v5 = (void (*)(char *, size_t, const char *, ...))sprintf_s;
  v6 = 0;
  v75 = 0;
  v79 = 0;
  if ( *(_DWORD *)(v4 + 8) )
  {
    v80 = (int)&v105;
    v81 = (void *)32;
    while ( 1 )
    {
      v7 = *(_DWORD *)(v4 + 20) == 0;
      v82 = 0;
      if ( !v7 )
        break;
LABEL_27:
      v4 = *(_DWORD *)(a2 + 112);
      v81 = (char *)v81 + 64;
      v80 += 576;
      v79 = (char *)v79 + 1;
      if ( (unsigned int)v79 >= *(_DWORD *)(v4 + 8) )
      {
        v5 = (void (*)(char *, size_t, const char *, ...))sprintf_s;
        goto LABEL_29;
      }
    }
    v8 = v80;
    v76 = v81;
    while ( 1 )
    {
      v9 = 1;
      if ( *(_DWORD *)(v4 + 12) >> v82 >= 1u )
        v9 = *(_DWORD *)(v4 + 12) >> v82;
      v10 = *(_DWORD *)(v4 + 16) >> v82;
      if ( v10 < 1 )
        v10 = 1;
      if ( !*(_DWORD *)((char *)v76 + v4) )
        break;
      v11 = *(_DWORD *)((char *)v76 + v4);
      v12 = *(_DWORD *)v8;
      if ( *(_DWORD *)v8 )
      {
        if ( v12 & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v13 = _iob_func();
          fputs(&DstBuf, v13 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v12, 0, 0, 1, dword_100AE9F4);
        }
        *(_DWORD *)v8 = 0;
        *(_DWORD *)(v8 + 4) = 0;
        *(_DWORD *)(v8 + 8) = 0;
      }
      *(_DWORD *)(v8 - 20) = v10;
      *(_DWORD *)(v8 - 4) = v11;
      *(_DWORD *)(v8 - 24) = v9;
      *(_DWORD *)(v8 - 16) = v9;
      *(_DWORD *)(v8 - 12) = v9 * v10;
      *(_DWORD *)(v8 - 8) = 15;
      if ( !v75 )
      {
        v14 = *(_DWORD *)(v8 - 20);
        v15 = 0;
        if ( v14 )
        {
          v16 = *(_DWORD *)(v8 - 24);
          while ( 1 )
          {
            v17 = 0;
            if ( v16 )
              break;
LABEL_23:
            if ( ++v15 >= v14 )
              goto LABEL_24;
          }
          v18 = (_BYTE *)(*(_DWORD *)(v8 - 4) + 4 * v15 * *(_DWORD *)(v8 - 16) + 3);
          while ( *v18 >= 0xFFu )
          {
            ++v17;
            v18 += 4;
            if ( v17 >= v16 )
              goto LABEL_23;
          }
          v75 = 1;
        }
        else
        {
LABEL_24:
          v75 = 0;
        }
      }
      v4 = *(_DWORD *)(a2 + 112);
      v76 = (char *)v76 + 4;
      v8 += 36;
      if ( ++v82 >= *(_DWORD *)(v4 + 20) )
      {
        v6 = v75;
        goto LABEL_27;
      }
    }
    v109 = -1;
    `eh vector destructor iterator'(&v103, 0x24u, 96, sub_100336C0);
    result = 0;
  }
  else
  {
LABEL_29:
    v19 = *(_DWORD *)(a2 + 112);
    v20 = 0;
    if ( *(_DWORD *)(v19 + 8) )
    {
      v21 = &v104;
      do
      {
        v22 = 0;
        if ( *(_DWORD *)(v19 + 20) )
        {
          v23 = v21;
          do
          {
            if ( v6 )
              *(_DWORD *)v23 |= 8u;
            else
              *(_DWORD *)v23 &= 0xFFFFFFF7;
            ++v22;
            v23 += 36;
          }
          while ( v22 < *(_DWORD *)(v19 + 20) );
        }
        ++v20;
        v21 += 576;
      }
      while ( v20 < *(_DWORD *)(v19 + 8) );
    }
    switch ( *(_DWORD *)(v19 + 24) )
    {
      case 3:
        v77 = 0;
        goto LABEL_45;
      case 4:
        v77 = 2;
        goto LABEL_45;
      case 5:
        v77 = 4;
        goto LABEL_45;
      case 6:
        v77 = 6;
LABEL_45:
        v7 = *(_DWORD *)(v19 + 8) == 0;
        v81 = 0;
        if ( !v7 )
        {
          v80 = (int)&v106;
          do
          {
            v7 = *(_DWORD *)(v19 + 20) == 0;
            v79 = 0;
            if ( !v7 )
            {
              v25 = (int *)v80;
              do
              {
                v88 = 0;
                v89 = 0;
                v90 = 0;
                v91 = 0;
                v92 = 15;
                v93 = 0;
                v94 = 0;
                v95 = 0;
                v96 = 0;
                LOBYTE(v109) = 1;
                sub_10033C70((int)&v88, (int)(v25 - 8));
                LOBYTE(v109) = 0;
                sub_1007B4C0((int)&v88, v77);
                v26 = v89;
                v27 = v90;
                *(v25 - 8) = v88;
                v28 = v91;
                *(v25 - 7) = v26;
                v29 = v92;
                *(v25 - 6) = v27;
                v30 = v93;
                *(v25 - 5) = v28;
                v31 = v94;
                *(v25 - 4) = v29;
                v32 = v95;
                *(v25 - 3) = v30;
                v33 = *(v25 - 2);
                *(v25 - 2) = v31;
                v34 = v96;
                *(v25 - 1) = v32;
                *v25 = v34;
                if ( v33 )
                {
                  if ( v33 & 7 )
                  {
                    sprintf_s(
                      &DstBuf,
                      0x200u,
                      "%s(%u): Assertion failed: \"%s\"\n",
                      "crn_mem.cpp",
                      216,
                      "crnlib_free: bad ptr");
                    OutputDebugStringA(&DstBuf);
                    v35 = _iob_func();
                    fputs(&DstBuf, v35 + 2);
                    if ( IsDebuggerPresent() )
                      DebugBreak();
                  }
                  else
                  {
                    off_100AD9F4(v33, 0, 0, 1, dword_100AE9F4);
                  }
                }
                v36 = *(_DWORD *)(a2 + 112);
                v25 += 9;
                v79 = (char *)v79 + 1;
              }
              while ( (unsigned int)v79 < *(_DWORD *)(v36 + 20) );
            }
            v19 = *(_DWORD *)(a2 + 112);
            v80 += 576;
            v81 = (char *)v81 + 1;
          }
          while ( (unsigned int)v81 < *(_DWORD *)(v19 + 8) );
          v5 = (void (*)(char *, size_t, const char *, ...))sprintf_s;
        }
        break;
      default:
        break;
    }
    v37 = *(_DWORD *)(*(_DWORD *)(a2 + 112) + 8);
    v85 = 0;
    v86 = 0;
    v87 = 0;
    sub_10033720((int)&v85, v37);
    LOBYTE(v109) = 2;
    v38 = *(_DWORD *)(a2 + 112);
    v7 = *(_DWORD *)(v38 + 8) == 0;
    v39 = (char *)v85;
    v84 = 0;
    if ( !v7 )
    {
      v40 = &v106;
      v83 = &v106;
      v78 = v85;
      do
      {
        v7 = *(_DWORD *)(v38 + 20) == 0;
        v82 = 0;
        if ( !v7 )
        {
          do
          {
            v79 = (void *)28;
            v41 = off_100AD9F4(0, 28, &v79, 1, dword_100AE9F4);
            if ( v41 && (unsigned int)v79 >= 0x1C )
            {
              *(_DWORD *)v41 = 0;
              *(_DWORD *)(v41 + 4) = 0;
              *(_DWORD *)(v41 + 8) = 15;
              *(_DWORD *)(v41 + 12) = 0;
              *(_DWORD *)(v41 + 16) = 0;
              *(_DWORD *)(v41 + 20) = 0;
              *(_DWORD *)(v41 + 24) = 0;
              v43 = v41;
            }
            else
            {
              v5(
                &DstBuf,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_malloc: out of memory");
              OutputDebugStringA(&DstBuf);
              v42 = _iob_func();
              fputs(&DstBuf, v42 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
              v43 = 0;
            }
            v80 = 36;
            v44 = off_100AD9F4(0, 36, &v80, 1, dword_100AE9F4);
            if ( v44 && (unsigned int)v80 >= 0x24 )
            {
              *(_DWORD *)v44 = 0;
              *(_DWORD *)(v44 + 4) = 0;
              *(_DWORD *)(v44 + 8) = 0;
              *(_DWORD *)(v44 + 12) = 0;
              *(_DWORD *)(v44 + 16) = 15;
              *(_DWORD *)(v44 + 20) = 0;
              *(_DWORD *)(v44 + 24) = 0;
              *(_DWORD *)(v44 + 28) = 0;
              *(_DWORD *)(v44 + 32) = 0;
              v46 = v44;
            }
            else
            {
              v5(
                &OutputString,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_malloc: out of memory");
              OutputDebugStringA(&OutputString);
              v45 = _iob_func();
              fputs(&OutputString, v45 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
              v46 = 0;
            }
            v47 = *(_DWORD *)v46;
            *(_DWORD *)v46 = *((_DWORD *)v40 - 8);
            *((_DWORD *)v40 - 8) = v47;
            v48 = *(_DWORD *)(v46 + 4);
            *(_DWORD *)(v46 + 4) = *((_DWORD *)v40 - 7);
            *((_DWORD *)v40 - 7) = v48;
            v49 = *(_DWORD *)(v46 + 8);
            *(_DWORD *)(v46 + 8) = *((_DWORD *)v40 - 6);
            *((_DWORD *)v40 - 6) = v49;
            v50 = *(_DWORD *)(v46 + 12);
            *(_DWORD *)(v46 + 12) = *((_DWORD *)v40 - 5);
            *((_DWORD *)v40 - 5) = v50;
            v51 = *(_DWORD *)(v46 + 16);
            *(_DWORD *)(v46 + 16) = *((_DWORD *)v40 - 4);
            *((_DWORD *)v40 - 4) = v51;
            v52 = *(_DWORD *)(v46 + 20);
            *(_DWORD *)(v46 + 20) = *((_DWORD *)v40 - 3);
            *((_DWORD *)v40 - 3) = v52;
            v53 = *(_DWORD *)(v46 + 24);
            *(_DWORD *)(v46 + 24) = *((_DWORD *)v40 - 2);
            *((_DWORD *)v40 - 2) = v53;
            v54 = *(_DWORD *)(v46 + 28);
            *(_DWORD *)(v46 + 28) = *((_DWORD *)v40 - 1);
            *((_DWORD *)v40 - 1) = v54;
            v55 = *(_DWORD *)(v46 + 32);
            *(_DWORD *)(v46 + 32) = *(_DWORD *)v40;
            *(_DWORD *)v40 = v55;
            v56 = *(_DWORD *)(v43 + 16);
            *(_DWORD *)v43 = 0;
            *(_DWORD *)(v43 + 4) = 0;
            *(_DWORD *)(v43 + 8) = 15;
            *(_DWORD *)(v43 + 12) = 0;
            *(_DWORD *)(v43 + 24) = 0;
            v81 = (void *)v56;
            if ( v56 )
            {
              v57 = *(_DWORD *)(v56 + 24);
              if ( v57 )
              {
                if ( v57 & 7 )
                {
                  v5(&v99, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
                  OutputDebugStringA(&v99);
                  v58 = _iob_func();
                  fputs(&v99, v58 + 2);
                  if ( IsDebuggerPresent() )
                    DebugBreak();
                }
                else
                {
                  off_100AD9F4(v57, 0, 0, 1, dword_100AE9F4);
                }
              }
              if ( (unsigned __int8)v81 & 7 )
              {
                v5(&v102, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
                OutputDebugStringA(&v102);
                v59 = _iob_func();
                fputs(&v102, v59 + 2);
                if ( IsDebuggerPresent() )
                  DebugBreak();
              }
              else
              {
                off_100AD9F4(v81, 0, 0, 1, dword_100AE9F4);
              }
              *(_DWORD *)(v43 + 16) = 0;
            }
            v60 = *(void **)(v43 + 20);
            v79 = v60;
            if ( v60 )
            {
              v61 = *(_DWORD *)v60;
              if ( v61 )
              {
                if ( v61 & 7 )
                {
                  v5(&v100, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
                  OutputDebugStringA(&v100);
                  v62 = _iob_func();
                  fputs(&v100, v62 + 2);
                  if ( IsDebuggerPresent() )
                    DebugBreak();
                }
                else
                {
                  off_100AD9F4(v61, 0, 0, 1, dword_100AE9F4);
                }
              }
              if ( (unsigned __int8)v79 & 7 )
              {
                v5(&v98, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
                OutputDebugStringA(&v98);
                v63 = _iob_func();
                fputs(&v98, v63 + 2);
                if ( IsDebuggerPresent() )
                  DebugBreak();
              }
              else
              {
                off_100AD9F4(v79, 0, 0, 1, dword_100AE9F4);
              }
              *(_DWORD *)(v43 + 20) = 0;
            }
            *(_DWORD *)(v43 + 16) = v46;
            *(_DWORD *)v43 = *(_DWORD *)v46;
            *(_DWORD *)(v43 + 4) = *(_DWORD *)(v46 + 4);
            *(_DWORD *)(v43 + 24) = 0;
            if ( (*(_DWORD *)(v46 + 16) >> 4) & 1 )
              *(_DWORD *)(v43 + 12) = ((*(_DWORD *)(v46 + 16) >> 3) & 1) != 0 ? 1098414156 : 2021161036;
            else
              *(_DWORD *)(v43 + 12) = ((*(_DWORD *)(v46 + 16) >> 3) & 1) != 0 ? 1094862674 : 2017609554;
            *(_DWORD *)(v43 + 8) = *(_DWORD *)(v46 + 16);
            v64 = v78;
            v65 = *((_DWORD *)v78 + 1);
            if ( v65 >= *((_DWORD *)v78 + 2) )
            {
              sub_100943C0(v65 + 1, 0, (int)v78, 1, 4u, 0);
              v64 = v78;
            }
            *(_DWORD *)(*v64 + 4 * v64[1]++) = v43;
            v66 = *(_DWORD *)(a2 + 112);
            v40 += 36;
            ++v82;
          }
          while ( v82 < *(_DWORD *)(v66 + 20) );
          v39 = (char *)v85;
        }
        v38 = *(_DWORD *)(a2 + 112);
        v78 = (char *)v78 + 12;
        v40 = v83 + 576;
        ++v84;
        v83 += 576;
      }
      while ( (unsigned int)v84 < *(_DWORD *)(v38 + 8) );
    }
    v67 = v86;
    if ( v86 )
    {
      sub_10087040(a3);
      v68 = **(_DWORD **)v39;
      *(_DWORD *)(a3 + 8) = *(_DWORD *)v68;
      *(_DWORD *)(a3 + 12) = *(_DWORD *)(v68 + 4);
      *(_DWORD *)(a3 + 16) = *(_DWORD *)(v68 + 8);
      *(_DWORD *)(a3 + 20) = *(_DWORD *)(v68 + 12);
      v69 = *(char **)(a3 + 24);
      *(_DWORD *)(a3 + 24) = v39;
      v39 = v69;
      v70 = *(_DWORD *)(a3 + 28);
      *(_DWORD *)(a3 + 28) = v67;
      v67 = v70;
      *(_DWORD *)(a3 + 32) = v87;
    }
    LOBYTE(v109) = 0;
    if ( v39 )
    {
      v71 = v39;
      v83 = v39;
      v84 = &v39[12 * v67];
      if ( v39 != v84 )
      {
        do
        {
          v72 = *(_DWORD *)v71;
          if ( v72 )
          {
            if ( v72 & 7 )
            {
              v5(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
              OutputDebugStringA(&DstBuf);
              v73 = _iob_func();
              fputs(&DstBuf, v73 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v72, 0, 0, 1, dword_100AE9F4);
            }
          }
          v71 = v83 + 12;
          v83 = v71;
        }
        while ( v71 != v84 );
      }
      if ( (unsigned __int8)v39 & 7 )
      {
        v5(&v98, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&v98);
        v74 = _iob_func();
        fputs(&v98, v74 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v39, 0, 0, 1, dword_100AE9F4);
      }
    }
    v109 = -1;
    `eh vector destructor iterator'(&v103, 0x24u, 96, sub_100336C0);
    result = 1;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10071F50) --------------------------------------------------------
void __stdcall sub_10071F50(void *a1)
{
  _DWORD *v1; // ebp@1
  char *v2; // esi@1
  int v3; // eax@1
  int v4; // eax@6
  void *v5; // [sp+14h] [bp+4h]@6

  v1 = a1;
  v2 = (char *)a1 + 4;
  sub_10087040((int)a1 + 4);
  sub_10091CF0((int)a1 + 4);
  *((_DWORD *)v2 + 2) = 0;
  *((_DWORD *)v2 + 3) = 0;
  *((_DWORD *)v2 + 4) = 15;
  *((_DWORD *)v2 + 5) = 0;
  *((_DWORD *)v2 + 9) = -1;
  sub_10091CF0((int)a1 + 44);
  sub_10087040((int)a1 + 52);
  sub_10091CF0((int)a1 + 52);
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 0;
  *((_DWORD *)a1 + 17) = 15;
  *((_DWORD *)a1 + 18) = 0;
  *((_DWORD *)a1 + 22) = -1;
  sub_10091CF0((int)a1 + 92);
  v3 = *((_DWORD *)a1 + 25);
  if ( v3 )
  {
    if ( v3 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
    *((_DWORD *)a1 + 25) = 0;
    *((_DWORD *)a1 + 26) = 0;
    *((_DWORD *)a1 + 27) = 0;
  }
  *((_DWORD *)a1 + 28) = 0;
  *((_DWORD *)a1 + 29) = 0;
  sub_10091720((int)a1 + 176);
  v4 = *((_DWORD *)a1 + 854);
  v5 = (void *)v4;
  if ( v4 )
  {
    sub_10033BD0(v4);
    if ( (unsigned __int8)v5 & 7 )
    {
      sub_100927E0((int)"crnlib_free: bad ptr");
      v1[854] = 0;
    }
    else
    {
      off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      v1[854] = 0;
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10072060) --------------------------------------------------------
void __thiscall sub_10072060(int this)
{
  int v1; // esi@1
  int v2; // ebx@1
  int v3; // eax@5

  v1 = this;
  *(_DWORD *)this = &off_100A5030;
  v2 = *(_DWORD *)(this + 3416);
  if ( v2 )
  {
    sub_10033BD0(*(_DWORD *)(this + 3416));
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
  }
  sub_100918E0(v1 + 176);
  v3 = *(_DWORD *)(v1 + 100);
  if ( v3 )
  {
    if ( v3 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
  }
  sub_10087290(v1 + 52);
  sub_10087290(v1 + 4);
  *(_DWORD *)v1 = &off_100A4FF4;
}
// 100A4FF4: using guessed type int (__stdcall *off_100A4FF4)(char);
// 100A5030: using guessed type int (__stdcall *off_100A5030)(char);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10072140) --------------------------------------------------------
void __thiscall sub_10072140(void *this)
{
  sub_10071F50(this);
}

//----- (10072150) --------------------------------------------------------
char __thiscall sub_10072150(void *this, int a2)
{
  void *v2; // esi@1
  unsigned int v3; // ecx@1
  unsigned int v4; // eax@1
  unsigned int v5; // edx@1
  unsigned int v6; // eax@7
  char result; // al@10
  int v8; // ebp@14
  signed int v9; // eax@14
  char v10; // bp@22

  v2 = this;
  sub_10071F50(this);
  *((_DWORD *)v2 + 28) = a2;
  v3 = *(_DWORD *)(a2 + 12);
  v4 = *(_DWORD *)(a2 + 16);
  v5 = v3;
  if ( v3 >= v4 )
    v5 = *(_DWORD *)(a2 + 16);
  if ( v5 < 1 )
    goto LABEL_25;
  if ( v3 > v4 )
    v4 = *(_DWORD *)(a2 + 12);
  if ( v4 > 0x1000 )
    goto LABEL_25;
  v6 = *(_DWORD *)(a2 + 20);
  if ( *(_DWORD *)(a2 + 8) < v6 )
    v6 = *(_DWORD *)(a2 + 8);
  if ( v6 >= 1 && sub_100713C0((int)v2 + 4, (int)v2, (int)v2 + 4) )
  {
    sub_10032380(*((_DWORD *)v2 + 28), (int)v2 + 120);
    if ( *(_DWORD *)(a2 + 476) )
    {
      *((_DWORD *)v2 + 36) = sub_100711F0;
      *((_DWORD *)v2 + 37) = a2;
    }
    v8 = *((_DWORD *)v2 + 28);
    v9 = sub_1008B750(*(_DWORD *)(v8 + 24));
    *((_DWORD *)v2 + 29) = v9;
    if ( !v9 )
      goto LABEL_26;
    if ( v9 == 827611204 && sub_10086B50((int)v2 + 4) && *((_BYTE *)v2 + 139) )
    {
      if ( *(_BYTE *)(v8 + 28) & 0x80 )
        *((_DWORD *)v2 + 29) = 1093752900;
    }
    if ( sub_100917D0(*(_DWORD *)(*((_DWORD *)v2 + 28) + 464), (int)v2 + 176) )
    {
      *((_DWORD *)v2 + 40) = (char *)v2 + 176;
      v10 = (*(_DWORD *)(a2 + 28) >> 1) & 1;
      sub_100339C0((int)v2 + 268, (int)v2 + 120, *(_DWORD *)(a2 + 420), v10);
      sub_10033A50((int)v2 + 1840, (int)v2 + 120, *(_DWORD *)(a2 + 420), v10);
      result = 1;
    }
    else
    {
LABEL_26:
      result = 0;
    }
  }
  else
  {
LABEL_25:
    result = 0;
  }
  return result;
}
// 100711F0: using guessed type int sub_100711F0();

//----- (10072280) --------------------------------------------------------
char __fastcall sub_10072280(int a1, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  char v4; // al@3
  bool v5; // zf@3
  int v6; // eax@4
  int v7; // eax@5
  int (*v8)(); // eax@11
  char result; // al@15

  v2 = a1;
  v3 = a2;
  if ( *(_DWORD *)(a1 + 420) == 255 || *(_DWORD *)(a1 + 24) == 1 )
  {
    sub_10087C90(a2 + 52, a2 + 4);
    if ( sub_1008B4D0(v3 + 52, *(_DWORD *)(v3 + 116), v3 + 120) )
      goto LABEL_19;
    return 0;
  }
  v4 = (*(_DWORD *)(a1 + 28) >> 1) & 1;
  v5 = *(_DWORD *)(a2 + 3416) == 0;
  *(_DWORD *)(a2 + 268) = *(_DWORD *)(a1 + 420);
  *(_BYTE *)(a2 + 282) = v4;
  *(_DWORD *)(a2 + 1840) = *(_DWORD *)(a1 + 420);
  *(_BYTE *)(a2 + 1848) = v4;
  if ( v5 )
  {
    v6 = sub_10092A80(20400);
    if ( v6 )
      v7 = sub_10033A80((void *)(v3 + 176), v6);
    else
      v7 = 0;
    *(_DWORD *)(v3 + 3416) = v7;
    if ( *(_DWORD *)(v2 + 476) )
    {
      *(_DWORD *)(v3 + 1824) = sub_100711C0;
      *(_DWORD *)(v3 + 1828) = v2;
      *(_DWORD *)(v3 + 3392) = sub_100711C0;
      *(_DWORD *)(v3 + 3396) = v2;
    }
    if ( sub_10087F90(v3 + 4, v7, v3 + 52, v3 + 268, (const void *)(v3 + 1840), *(_DWORD *)(v3 + 116)) )
    {
      if ( !*(_DWORD *)(v2 + 476) )
        goto LABEL_15;
      v8 = sub_10071190;
      goto LABEL_14;
    }
    return 0;
  }
  if ( !*(_DWORD *)(a1 + 476) )
    goto LABEL_15;
  v8 = sub_100711F0;
  *(_DWORD *)(a2 + 1828) = a1;
  *(_DWORD *)(a2 + 3396) = a1;
LABEL_14:
  *(_DWORD *)(v3 + 3392) = v8;
  *(_DWORD *)(v3 + 1824) = v8;
LABEL_15:
  result = sub_1008AC40(v3 + 4, *(_DWORD *)(v3 + 3416), v3 + 52, v3 + 268, v3 + 1840);
  if ( result )
LABEL_19:
    result = 1;
  return result;
}
// 10071190: using guessed type int sub_10071190();
// 100711C0: using guessed type int sub_100711C0();
// 100711F0: using guessed type int sub_100711F0();

//----- (10072420) --------------------------------------------------------
char __thiscall sub_10072420(int this, int a2, float *a3)
{
  int v3; // ebx@1
  int v5; // eax@12
  int v6; // edx@12
  int v7; // ecx@12
  int v8; // eax@12
  int v9; // eax@12
  int v10; // ecx@13
  double v11; // st7@15
  unsigned int v12; // eax@15
  int *v13; // [sp+Ch] [bp-44h]@7
  signed int (__stdcall *v14)(int, int *, void *, unsigned int *, int, unsigned int); // [sp+10h] [bp-40h]@7
  int v15; // [sp+14h] [bp-3Ch]@13
  unsigned int v16; // [sp+18h] [bp-38h]@13
  int v17; // [sp+1Ch] [bp-34h]@13
  int (__stdcall **v18)(char); // [sp+20h] [bp-30h]@5
  int v19; // [sp+24h] [bp-2Ch]@5
  int v20; // [sp+28h] [bp-28h]@5
  __int16 v21; // [sp+2Ch] [bp-24h]@5
  char v22; // [sp+2Eh] [bp-22h]@5
  int v23; // [sp+30h] [bp-20h]@5
  int v24; // [sp+34h] [bp-1Ch]@5
  int v25; // [sp+38h] [bp-18h]@5
  int v26; // [sp+3Ch] [bp-14h]@5
  int v27; // [sp+4Ch] [bp-4h]@5

  v3 = this;
  if ( a3 )
    *a3 = 0.0;
  if ( !*(_DWORD *)(this + 112) || !sub_10072280(a2, this) )
    return 0;
  v22 &= 0xF8u;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v27 = 0;
  v18 = &off_100A4DE4;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  LOBYTE(v27) = 1;
  v26 = 0;
  sub_100324C0((int)&v18);
  v27 = 2;
  if ( v22 & 1 )
    sub_10032F10((int)&v23, 0x80000u);
  v13 = (int *)&v18;
  LOBYTE(v14) = 1;
  if ( !sub_1008A020((int)&v18, v3 + 52, (int)&v13) )
  {
    v27 = -1;
    sub_100323F0((int)&v18);
    return 0;
  }
  if ( v22 & 1 )
    sub_10032F10((int)&v23, 0);
  v5 = *(_DWORD *)(v3 + 100);
  v6 = v24;
  *(_DWORD *)(v3 + 100) = v23;
  v7 = v25;
  v23 = v5;
  v8 = *(_DWORD *)(v3 + 104);
  *(_DWORD *)(v3 + 104) = v6;
  v24 = v8;
  v9 = *(_DWORD *)(v3 + 108);
  *(_DWORD *)(v3 + 108) = v7;
  v25 = v9;
  if ( a3 )
  {
    v13 = (int *)sub_10094030;
    v14 = sub_10094000;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    LOBYTE(v27) = 3;
    if ( sub_1005B0E0(
           *(_DWORD *)(v3 + 104),
           (int)&v15,
           (int (__stdcall **)(int, int *, int, unsigned int, int, int *, signed int, _DWORD, signed int, signed int, signed int, signed int, int))&v13,
           *(_DWORD *)(v3 + 100)) )
    {
      if ( v16 )
      {
        v13 = (int *)v16;
        v11 = (double)v16;
        sub_10086A70(v10, v3 + 4);
        v13 = (int *)v12;
        *a3 = v11 * 8.0 / (double)v12;
      }
    }
    LOBYTE(v27) = 2;
    sub_10038C00(&v15);
  }
  v27 = -1;
  sub_100323F0((int)&v18);
  return 1;
}
// 10086A70: using guessed type double __fastcall sub_10086A70(_DWORD, _DWORD);
// 100A4DE4: using guessed type int (__stdcall *off_100A4DE4)(char);

//----- (100729A0) --------------------------------------------------------
double __cdecl sub_100729A0(int a1, int a2, int a3)
{
  int v3; // eax@1
  unsigned int v4; // edx@1
  unsigned int v5; // esi@1
  unsigned int v6; // eax@1
  unsigned __int8 v7; // bl@1
  unsigned int v8; // ecx@1
  unsigned int v9; // ebp@1
  unsigned int v10; // edx@1
  unsigned int v11; // ST14_4@1
  unsigned int v12; // ST10_4@1
  unsigned int v13; // eax@1
  unsigned int v14; // ST1C_4@1
  int v15; // eax@1
  int v16; // ebx@1
  int v17; // esi@1
  double v18; // st7@1
  double result; // st7@3
  int v20; // [sp+2Ch] [bp+4h]@1
  unsigned int v21; // [sp+30h] [bp+8h]@1
  unsigned int v22; // [sp+34h] [bp+Ch]@1
  float v23; // [sp+34h] [bp+Ch]@1
  float v24; // [sp+34h] [bp+Ch]@3
  float v25; // [sp+34h] [bp+Ch]@4
  float v26; // [sp+34h] [bp+Ch]@4

  v3 = *(_DWORD *)(a3 + 356);
  v4 = *(_DWORD *)(v3 + 4 * a1);
  v5 = *(_DWORD *)(v3 + 4 * a2);
  v6 = (unsigned __int16)*(_DWORD *)(v3 + 4 * a1);
  v7 = 8 * (v6 & 0x1F) | ((unsigned __int8)(v6 & 0x1F) >> 2);
  v20 = 8 * (v6 >> 11) | (v6 >> 13);
  v21 = 4 * ((v6 >> 5) & 0x3F) | (((v6 >> 5) & 0x3F) >> 4);
  v4 >>= 16;
  v8 = (v4 >> 5) & 0x3F;
  v9 = v4 >> 11;
  v10 = 8 * (v4 & 0x1F) | ((v4 & 0x1F) >> 2);
  v11 = 8 * (v5 & 0x1F) | ((v5 & 0x1F) >> 2);
  v12 = 4 * (((unsigned int)(unsigned __int16)v5 >> 5) & 0x3F) | ((((unsigned int)(unsigned __int16)v5 >> 5) & 0x3F) >> 4);
  v13 = 8 * ((unsigned int)(unsigned __int16)v5 >> 11) | ((unsigned int)(unsigned __int16)v5 >> 13);
  v5 >>= 16;
  v22 = v13;
  v14 = 4 * ((v5 >> 5) & 0x3F) | (((v5 >> 5) & 0x3F) >> 4);
  v15 = v7;
  v16 = (unsigned __int8)(8 * (v5 & 0x1F) | ((unsigned __int8)(v5 & 0x1F) >> 2));
  v17 = (unsigned __int8)(8 * v9 | (v9 >> 2)) - (unsigned __int8)(8 * (v5 >> 11) | (v5 >> 13));
  v23 = (double)(((unsigned __int8)v20 - (unsigned __int8)v22) * ((unsigned __int8)v20 - (unsigned __int8)v22)
               + ((unsigned __int8)v21 - (unsigned __int8)v12) * ((unsigned __int8)v21 - (unsigned __int8)v12)
               + (v15 - (unsigned __int8)v11) * (v15 - (unsigned __int8)v11)
               + v17 * v17
               + ((unsigned __int8)(4 * v8 | (v8 >> 4)) - (unsigned __int8)v14)
               * ((unsigned __int8)(4 * v8 | (v8 >> 4)) - (unsigned __int8)v14)
               + ((unsigned __int8)v10 - v16) * ((unsigned int)(unsigned __int8)v10 - v16))
      / 8000.0;
  v18 = 0.0;
  if ( v23 < 0.0 || (v18 = v23, v23 <= 1.0) )
  {
    v25 = v18;
    v26 = 1.0 - v25;
    result = v26;
  }
  else
  {
    v24 = 1.0 - (float)1.0;
    result = v24;
  }
  return result;
}

//----- (10072BB0) --------------------------------------------------------
void __userpurge sub_10072BB0(int a1@<esi>, int a2, int a3, int a4, float a5)
{
  int v5; // ebx@1
  unsigned int v6; // ecx@1
  int v7; // ebp@1
  int v8; // eax@2
  signed int v9; // edi@2
  unsigned int v10; // eax@6
  unsigned int v11; // ebp@6
  int v12; // edi@10
  int i; // ebp@10
  int v14; // edx@16
  int v15; // ecx@16
  int v16; // eax@16
  unsigned int v17; // ebp@16
  unsigned int v18; // ecx@16
  unsigned int v19; // ecx@19
  int v20; // edx@19
  int v21; // ebp@19
  unsigned int v22; // eax@19
  int v23; // edi@21
  int v24; // edi@23
  unsigned int v25; // ebp@23
  int v26; // ebx@23
  int v27; // edi@25
  int v28; // ebp@25
  int v29; // ebx@25
  int v30; // edi@27
  unsigned int v31; // ebp@27
  int v32; // ebx@27
  int v33; // edi@29
  unsigned int v34; // ebp@29
  int v35; // [sp+8h] [bp-28h]@17
  int v36; // [sp+Ch] [bp-24h]@19
  int v37; // [sp+10h] [bp-20h]@6
  int v38; // [sp+10h] [bp-20h]@16
  int v39; // [sp+14h] [bp-1Ch]@5
  unsigned int v40; // [sp+18h] [bp-18h]@1
  unsigned int v41; // [sp+1Ch] [bp-14h]@16
  int v42; // [sp+20h] [bp-10h]@16
  signed int v43; // [sp+24h] [bp-Ch]@2
  int v44; // [sp+28h] [bp-8h]@4
  signed int v45; // [sp+2Ch] [bp-4h]@2

  v5 = a4;
  LOBYTE(v6) = 0;
  v7 = a2;
  v40 = 0;
  if ( a3 )
  {
    do
    {
      v8 = 0;
      v9 = v7;
      v45 = v7;
      v43 = 1;
      if ( v6 & 1 )
      {
        v9 = -1;
        v8 = v7 - 1;
        v45 = -1;
        v43 = -1;
      }
      v44 = v8;
      if ( v8 != v9 )
      {
        v39 = 8 * v8 + 1;
        do
        {
          v10 = *(_DWORD *)(v5 + 4);
          v11 = v10 + 1;
          v37 = v10 + 1;
          if ( v10 + 1 != v10 )
          {
            if ( v10 + 1 >= v10 )
            {
              if ( v11 > *(_DWORD *)(v5 + 8) )
                sub_100943C0(v10 + 1, 0, v5, 1, 0x104u, 0);
              v12 = *(_DWORD *)v5 + 260 * *(_DWORD *)(v5 + 4);
              for ( i = v12 + 260 * (v11 - *(_DWORD *)(v5 + 4)); v12 != i; v12 += 260 )
              {
                if ( v12 )
                {
                  memset((void *)v12, 0, 0x104u);
                  *(float *)(v12 + 256) = 1.0;
                }
              }
              v11 = v37;
            }
            *(_DWORD *)(v5 + 4) = v11;
          }
          v14 = *(_DWORD *)v5;
          v15 = 260 * *(_DWORD *)(v5 + 4);
          *(float *)(v15 + v14 - 4) = a5;
          v16 = v15 + v14 - 260;
          v17 = 0;
          v18 = 8 * v40;
          v38 = v16;
          v41 = 0;
          v42 = 8 * v40;
          do
          {
            v35 = v18;
            if ( v18 >= *(_DWORD *)(a1 + 4) - 1 )
              v35 = *(_DWORD *)(a1 + 4) - 1;
            v19 = v39;
            v20 = 2 * (v17 >> 2);
            v21 = v17 & 3;
            v36 = v21;
            v22 = 1;
            while ( 1 )
            {
              v23 = v19 - 1;
              if ( v19 - 1 >= *(_DWORD *)a1 - 1 )
                v23 = *(_DWORD *)a1 - 1;
              v24 = *(_DWORD *)(a1 + 20) + 4 * (v23 + v35 * *(_DWORD *)(a1 + 8));
              v25 = v38 + 4 * ((((_BYTE)v22 - 1) & 3) + 4 * (v21 + 4 * (v20 + ((v22 - 1) >> 2))));
              *(_BYTE *)v25 = *(_BYTE *)v24;
              *(_BYTE *)(v25 + 1) = *(_BYTE *)(v24 + 1);
              *(_BYTE *)(v25 + 2) = *(_BYTE *)(v24 + 2);
              *(_BYTE *)(v25 + 3) = *(_BYTE *)(v24 + 3);
              v26 = v19;
              if ( v19 >= *(_DWORD *)a1 - 1 )
                v26 = *(_DWORD *)a1 - 1;
              v27 = *(_DWORD *)(a1 + 20) + 4 * (v26 + v35 * *(_DWORD *)(a1 + 8));
              v28 = v38 + 4 * ((v22 & 3) + 4 * (v36 + 4 * (v20 + (v22 >> 2))));
              *(_BYTE *)v28 = *(_BYTE *)v27;
              *(_BYTE *)(v28 + 1) = *(_BYTE *)(v27 + 1);
              *(_BYTE *)(v28 + 2) = *(_BYTE *)(v27 + 2);
              *(_BYTE *)(v28 + 3) = *(_BYTE *)(v27 + 3);
              v29 = v19 + 1;
              if ( v19 + 1 >= *(_DWORD *)a1 - 1 )
                v29 = *(_DWORD *)a1 - 1;
              v30 = *(_DWORD *)(a1 + 20) + 4 * (v29 + v35 * *(_DWORD *)(a1 + 8));
              v31 = v38 + 4 * ((((_BYTE)v22 + 1) & 3) + 4 * (v36 + 4 * (v20 + ((v22 + 1) >> 2))));
              *(_BYTE *)v31 = *(_BYTE *)v30;
              *(_BYTE *)(v31 + 1) = *(_BYTE *)(v30 + 1);
              *(_BYTE *)(v31 + 2) = *(_BYTE *)(v30 + 2);
              *(_BYTE *)(v31 + 3) = *(_BYTE *)(v30 + 3);
              v32 = v19 + 2;
              if ( v19 + 2 >= *(_DWORD *)a1 - 1 )
                v32 = *(_DWORD *)a1 - 1;
              v33 = *(_DWORD *)(a1 + 20) + 4 * (v32 + v35 * *(_DWORD *)(a1 + 8));
              v34 = v38 + 4 * ((((_BYTE)v22 - 2) & 3) + 4 * (v36 + 4 * (v20 + ((v22 + 2) >> 2))));
              *(_BYTE *)v34 = *(_BYTE *)v33;
              *(_BYTE *)(v34 + 1) = *(_BYTE *)(v33 + 1);
              *(_BYTE *)(v34 + 2) = *(_BYTE *)(v33 + 2);
              v22 += 4;
              v19 += 4;
              *(_BYTE *)(v34 + 3) = *(_BYTE *)(v33 + 3);
              if ( v22 - 1 >= 8 )
                break;
              v21 = v36;
            }
            v17 = v41 + 1;
            v18 = v42 + 1;
            v41 = v17;
            ++v42;
          }
          while ( v17 < 8 );
          v5 = a4;
          v39 += 8 * v43;
          v44 += v43;
        }
        while ( v44 != v45 );
        v7 = a2;
      }
      v6 = v40 + 1;
      v40 = v6;
    }
    while ( v6 < a3 );
  }
}

//----- (10072EC0) --------------------------------------------------------
void __usercall sub_10072EC0(int a1@<edi>, int a2)
{
  int v2; // ecx@1
  unsigned int v3; // eax@2
  unsigned int v4; // ebx@2
  unsigned int v5; // esi@2

  v2 = *(_DWORD *)(a2 + 4);
  if ( v2 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    v4 = v3;
    v5 = v2 + v3;
    if ( v2 + v3 != v3 )
    {
      if ( v2 + v3 >= v3 )
      {
        if ( v5 > *(_DWORD *)(a1 + 8) )
          sub_100943C0(v5, 0, a1, v5 == v3 + 1, 1u, 0);
        memset((void *)(*(_DWORD *)(a1 + 4) + *(_DWORD *)a1), 0, v5 - *(_DWORD *)(a1 + 4));
      }
      *(_DWORD *)(a1 + 4) = v5;
    }
    memcpy((void *)(v4 + *(_DWORD *)a1), *(const void **)a2, *(_DWORD *)(a2 + 4));
  }
}

//----- (10072F40) --------------------------------------------------------
void *__usercall sub_10072F40@<eax>(int a1@<edi>, void *a2, size_t a3)
{
  size_t v3; // eax@1
  size_t v4; // ebx@1
  unsigned int v5; // esi@1

  v3 = *(_DWORD *)(a1 + 4);
  v4 = v3;
  v5 = v3 + a3;
  if ( v3 + a3 != v3 )
  {
    if ( v3 + a3 >= v3 )
    {
      if ( v5 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(v5, 0, a1, v5 == v3 + 1, 1u, 0);
      memset((void *)(*(_DWORD *)(a1 + 4) + *(_DWORD *)a1), 0, v5 - *(_DWORD *)(a1 + 4));
    }
    *(_DWORD *)(a1 + 4) = v5;
  }
  return memcpy((void *)(v4 + *(_DWORD *)a1), a2, a3);
}

//----- (10072FB0) --------------------------------------------------------
void __userpurge sub_10072FB0(int a1@<esi>, int a2, int a3)
{
  unsigned int v3; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // edi@7
  unsigned int v6; // eax@7
  unsigned int v7; // ebp@7
  int v8; // ecx@8
  int v9; // edi@10
  int v10; // ebp@10
  int v11; // edx@11
  int v12; // edx@11
  int v13; // edx@11
  int v14; // edx@11
  unsigned int v15; // edi@12
  int v16; // eax@16
  int v17; // ebx@16
  unsigned int v18; // edi@20
  signed int v19; // edx@20
  unsigned int v20; // eax@21
  unsigned int v21; // ecx@21
  unsigned int v22; // eax@24
  int v23; // ebp@24
  int v24; // edx@24
  int v25; // edi@24
  int v26; // ecx@25
  int v27; // ecx@25
  unsigned int v28; // ebp@26
  FILE *v29; // eax@34
  int v30; // [sp+Ch] [bp-22Ch]@10
  int v31; // [sp+Ch] [bp-22Ch]@22
  int v32; // [sp+10h] [bp-228h]@10
  unsigned int v33; // [sp+10h] [bp-228h]@21
  unsigned int v34; // [sp+14h] [bp-224h]@7
  int v35; // [sp+14h] [bp-224h]@24
  signed int v36; // [sp+18h] [bp-220h]@20
  unsigned int v37; // [sp+1Ch] [bp-21Ch]@7
  unsigned int v38; // [sp+1Ch] [bp-21Ch]@21
  unsigned int i; // [sp+20h] [bp-218h]@20
  unsigned int v40; // [sp+24h] [bp-214h]@7
  unsigned int v41; // [sp+24h] [bp-214h]@21
  unsigned int v42; // [sp+28h] [bp-210h]@16
  int v43; // [sp+2Ch] [bp-20Ch]@16
  int v44; // [sp+30h] [bp-208h]@16
  int v45; // [sp+34h] [bp-204h]@16
  char DstBuf; // [sp+38h] [bp-200h]@34

  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)(a3 + 4);
  if ( v4 != v3 )
  {
    if ( v4 >= v3 )
    {
      if ( v4 > *(_DWORD *)(a2 + 8) )
        sub_100943C0(v4, 0, a2, v4 == v3 + 1, 4u, 0);
      memset((void *)(*(_DWORD *)a2 + 4 * *(_DWORD *)(a2 + 4)), 0, 4 * (v4 - *(_DWORD *)(a2 + 4)));
    }
    *(_DWORD *)(a2 + 4) = v4;
  }
  v5 = *(_DWORD *)(a3 + 4);
  v6 = 0;
  v7 = 0;
  v37 = -1;
  v40 = 0;
  v34 = 0;
  if ( v5 )
  {
    v8 = *(_DWORD *)a3 + 1;
    while ( 1 )
    {
      v9 = 0;
      v30 = 0;
      v32 = 0;
      v10 = 0;
      do
      {
        v11 = *(_BYTE *)(*(_BYTE *)(v8 + v6 - 1) + a1);
        v9 += v11 * v11;
        v12 = *(_BYTE *)(*(_BYTE *)(v8 + v6) + a1);
        v10 += v12 * v12;
        v13 = *(_BYTE *)(*(_BYTE *)(v8 + v6 + 1) + a1);
        v32 += v13 * v13;
        v14 = *(_BYTE *)(*(_BYTE *)(v8 + v6 + 2) + a1);
        v30 += v14 * v14;
        v6 += 4;
      }
      while ( v6 < 0x10 );
      v15 = v32 + v10 + v30 + v9;
      if ( v15 >= v37 )
      {
        v7 = v40;
      }
      else
      {
        v7 = v34;
        v37 = v15;
        v40 = v34;
      }
      v5 = *(_DWORD *)(a3 + 4);
      v8 += 16;
      if ( ++v34 >= v5 )
        break;
      v6 = 0;
    }
  }
  v16 = 0;
  v17 = 0;
  v42 = v7;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  if ( v5 )
  {
    if ( v5 )
    {
      sub_100943C0(v5, 0, (int)&v43, v5 == 1, 1u, 0);
      v16 = v44;
      v17 = v43;
    }
    memset((void *)(v17 + v16), 0, v5 - v16);
  }
  *(_BYTE *)(v17 + v7) = 1;
  *(_DWORD *)(*(_DWORD *)a2 + 4 * v7) = 0;
  v18 = *(_DWORD *)(a3 + 4);
  v19 = 1;
  v36 = 1;
  for ( i = v18; v19 != v18; i = v18 )
  {
    v20 = 0;
    v21 = 0;
    v41 = -1;
    v38 = 0;
    v33 = 0;
    if ( v18 )
    {
      v31 = 0;
      do
      {
        if ( !*(_BYTE *)(v17 + v20) )
        {
          v22 = 0;
          v23 = 0;
          v35 = 0;
          v24 = *(_DWORD *)a3 + v31 + 1;
          v25 = *(_DWORD *)a3 + 16 * v42 + 1;
          do
          {
            v26 = *(_BYTE *)(*(_BYTE *)(v25 + v22 - 1) + a1) - *(_BYTE *)(*(_BYTE *)(v24 + v22 - 1) + a1);
            v23 += v26 * v26;
            v27 = *(_BYTE *)(*(_BYTE *)(v25 + v22) + a1) - *(_BYTE *)(*(_BYTE *)(v24 + v22) + a1);
            v35 += v27 * v27;
            v22 += 2;
          }
          while ( v22 < 0x10 );
          v28 = v35 + v23;
          v20 = v33;
          v17 = v43;
          v18 = i;
          if ( v28 >= v41 )
          {
            v21 = v38;
          }
          else
          {
            v21 = v33;
            v41 = v28;
            v38 = v33;
          }
        }
        v31 += 16;
        v33 = ++v20;
      }
      while ( v20 < v18 );
      v19 = v36;
    }
    *(_BYTE *)(v17 + v21) = 1;
    *(_DWORD *)(*(_DWORD *)a2 + 4 * v21) = v19;
    v42 = v21;
    v18 = *(_DWORD *)(a3 + 4);
    v36 = ++v19;
  }
  if ( v17 )
  {
    if ( v17 & 7 )
    {
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v29 = _iob_func();
      fputs(&DstBuf, v29 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(v17, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100732F0) --------------------------------------------------------
void __stdcall sub_100732F0(int a1, int a2)
{
  int v2; // ecx@1
  _DWORD *v3; // ebp@1
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  unsigned int v6; // edi@7
  unsigned int v7; // ebx@7
  unsigned int v8; // esi@7
  unsigned int v9; // eax@7
  int v10; // edx@8
  int v11; // ebp@9
  int v12; // eax@13
  int v13; // ebx@13
  unsigned int v14; // ebp@17
  signed int v15; // edi@17
  int v16; // eax@18
  int v17; // edx@18
  unsigned int v18; // ecx@18
  unsigned int v19; // esi@18
  int v20; // edi@19
  FILE *v21; // eax@29
  signed int i; // [sp+10h] [bp-21Ch]@17
  unsigned int v23; // [sp+14h] [bp-218h]@18
  unsigned int v24; // [sp+18h] [bp-214h]@18
  int v25; // [sp+1Ch] [bp-210h]@13
  int v26; // [sp+20h] [bp-20Ch]@13
  int v27; // [sp+24h] [bp-208h]@13
  int v28; // [sp+28h] [bp-204h]@18
  char DstBuf; // [sp+2Ch] [bp-200h]@29

  v2 = a2;
  v3 = (_DWORD *)a1;
  v4 = *(_DWORD *)(a1 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  if ( v5 != v4 )
  {
    if ( v5 >= v4 )
    {
      if ( v5 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(v5, 0, a1, v5 == v4 + 1, 4u, 0);
      memset((void *)(*(_DWORD *)a1 + 4 * *(_DWORD *)(a1 + 4)), 0, 4 * (v5 - *(_DWORD *)(a1 + 4)));
    }
    v2 = a2;
    *(_DWORD *)(a1 + 4) = v5;
  }
  v6 = *(_DWORD *)(v2 + 4);
  v7 = -1;
  v8 = 0;
  v9 = 0;
  if ( v6 )
  {
    v10 = *(_DWORD *)v2;
    do
    {
      v11 = *(_BYTE *)v10;
      if ( v11 + (unsigned int)*(_BYTE *)(v10 + 1) < v7 )
      {
        v7 = v11 + *(_BYTE *)(v10 + 1);
        v8 = v9;
      }
      ++v9;
      v10 += 4;
    }
    while ( v9 < v6 );
    v3 = (_DWORD *)a1;
  }
  v12 = 0;
  v13 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  if ( v6 )
  {
    if ( v6 )
    {
      sub_100943C0(v6, 0, (int)&v25, v6 == 1, 1u, 0);
      v12 = v26;
      v13 = v25;
    }
    memset((void *)(v13 + v12), 0, v6 - v12);
  }
  *(_BYTE *)(v13 + v8) = 1;
  *(_DWORD *)(*v3 + 4 * v8) = 0;
  v14 = *(_DWORD *)(a2 + 4);
  v15 = 1;
  for ( i = 1; v15 != v14; i = v15 )
  {
    v16 = *(_DWORD *)a2;
    v17 = *(_DWORD *)(*(_DWORD *)a2 + 4 * v8);
    v18 = 0;
    v28 = *(_BYTE *)(*(_DWORD *)a2 + 4 * v8 + 1);
    v19 = 0;
    v23 = -1;
    v24 = 0;
    if ( v14 )
    {
      v20 = v16;
      do
      {
        if ( !*(_BYTE *)(v13 + v19) )
        {
          v13 = v25;
          if ( (v28 - *(_BYTE *)(v20 + 1)) * (v28 - *(_BYTE *)(v20 + 1))
             + ((unsigned __int8)v17 - (*(_DWORD *)v20 & 0xFF)) * ((unsigned __int8)v17 - (*(_DWORD *)v20 & 0xFFu)) >= v23 )
          {
            v18 = v24;
          }
          else
          {
            v18 = v19;
            v23 = (v28 - *(_BYTE *)(v20 + 1)) * (v28 - *(_BYTE *)(v20 + 1))
                + ((unsigned __int8)v17 - (*(_DWORD *)v20 & 0xFF)) * ((unsigned __int8)v17 - (*(_DWORD *)v20 & 0xFF));
            v24 = v19;
          }
        }
        ++v19;
        v20 += 4;
      }
      while ( v19 < v14 );
      v15 = i;
    }
    *(_BYTE *)(v13 + v18) = 1;
    *(_DWORD *)(*(_DWORD *)a1 + 4 * v18) = v15;
    v8 = v18;
    v14 = *(_DWORD *)(a2 + 4);
    ++v15;
  }
  if ( v13 )
  {
    if ( v13 & 7 )
    {
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v21 = _iob_func();
      fputs(&DstBuf, v21 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(v13, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10073550) --------------------------------------------------------
void __stdcall sub_10073550(int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // edi@1
  unsigned int v4; // esi@1
  unsigned int v5; // ebp@7
  unsigned int v6; // esi@7
  int v7; // esi@8
  unsigned int v8; // eax@10
  unsigned int v9; // eax@10
  int v10; // eax@14
  int v11; // ebx@14
  unsigned int *v12; // ebx@21
  unsigned int v13; // edx@21
  unsigned int v14; // eax@21
  unsigned int v15; // esi@21
  unsigned int v16; // eax@21
  unsigned int v17; // ebp@21
  unsigned int v18; // edx@24
  unsigned int v19; // ecx@24
  unsigned int v20; // edi@24
  unsigned __int8 v21; // bl@24
  int v22; // esi@24
  int v23; // ecx@24
  FILE *v24; // eax@31
  unsigned int v25; // [sp+Ch] [bp-244h]@7
  unsigned int *v26; // [sp+Ch] [bp-244h]@22
  int i; // [sp+10h] [bp-240h]@8
  unsigned int v28; // [sp+10h] [bp-240h]@21
  unsigned int v29; // [sp+14h] [bp-23Ch]@7
  signed int v30; // [sp+14h] [bp-23Ch]@18
  unsigned int v31; // [sp+18h] [bp-238h]@18
  int v32; // [sp+1Ch] [bp-234h]@24
  unsigned int v33; // [sp+20h] [bp-230h]@7
  unsigned int v34; // [sp+20h] [bp-230h]@21
  int v35; // [sp+24h] [bp-22Ch]@21
  int v36; // [sp+28h] [bp-228h]@24
  int v37; // [sp+2Ch] [bp-224h]@14
  int v38; // [sp+30h] [bp-220h]@14
  int v39; // [sp+34h] [bp-21Ch]@14
  unsigned int v40; // [sp+38h] [bp-218h]@21
  unsigned int v41; // [sp+3Ch] [bp-214h]@21
  unsigned int v42; // [sp+40h] [bp-210h]@21
  unsigned int v43; // [sp+44h] [bp-20Ch]@24
  unsigned int v44; // [sp+48h] [bp-208h]@21
  unsigned int v45; // [sp+4Ch] [bp-204h]@21
  char DstBuf; // [sp+50h] [bp-200h]@31

  v2 = *(_DWORD *)(a1 + 4);
  v3 = a2;
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 != v2 )
  {
    if ( v4 >= v2 )
    {
      if ( v4 > *(_DWORD *)(a1 + 8) )
        sub_100943C0(v4, 0, a1, v4 == v2 + 1, 4u, 0);
      memset((void *)(*(_DWORD *)a1 + 4 * *(_DWORD *)(a1 + 4)), 0, 4 * (v4 - *(_DWORD *)(a1 + 4)));
    }
    *(_DWORD *)(a1 + 4) = v4;
  }
  v5 = *(_DWORD *)(a2 + 4);
  v6 = 0;
  v33 = -1;
  v25 = 0;
  v29 = 0;
  if ( v5 )
  {
    v7 = *(_DWORD *)a2;
    for ( i = *(_DWORD *)a2; ; v7 = i )
    {
      v8 = *(_WORD *)(v7 + 2);
      v9 = (unsigned __int8)(4 * (((unsigned int)*(_WORD *)v7 >> 5) & 0x3F) | ((((unsigned int)*(_WORD *)v7 >> 5) & 0x3F) >> 4))
         + (unsigned __int8)(4 * ((v8 >> 5) & 0x3F) | (((v8 >> 5) & 0x3F) >> 4))
         + (unsigned __int8)(8 * (*(_WORD *)v7 & 0x1F) | ((unsigned __int8)(*(_WORD *)v7 & 0x1F) >> 2))
         + (unsigned __int8)(8 * ((unsigned int)*(_WORD *)v7 >> 11) | ((unsigned int)*(_WORD *)v7 >> 13))
         + (unsigned __int8)(8 * (v8 & 0x1F) | ((unsigned __int8)(v8 & 0x1F) >> 2))
         + (unsigned __int8)(8 * (v8 >> 11) | (v8 >> 13));
      if ( v9 < v33 )
      {
        v33 = v9;
        v25 = v29;
      }
      i += 4;
      if ( ++v29 >= v5 )
        break;
    }
    v3 = a2;
    v6 = v25;
  }
  v10 = 0;
  v11 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  if ( v5 )
  {
    if ( v5 )
    {
      sub_100943C0(v5, 0, (int)&v37, v5 == 1, 1u, 0);
      v10 = v38;
      v11 = v37;
    }
    memset((void *)(v11 + v10), 0, v5 - v10);
  }
  *(_BYTE *)(v11 + v6) = 1;
  *(_DWORD *)(*(_DWORD *)a1 + 4 * v6) = 0;
  v30 = 1;
  v31 = *(_DWORD *)(v3 + 4);
  if ( v31 != 1 )
  {
    while ( 1 )
    {
      v12 = *(unsigned int **)v3;
      v13 = *(_DWORD *)(*(_DWORD *)v3 + 4 * v6);
      v14 = (unsigned __int16)*(_DWORD *)(*(_DWORD *)v3 + 4 * v6);
      v15 = *(_DWORD *)(*(_DWORD *)v3 + 4 * v6) & 0x1F;
      v13 >>= 16;
      v35 = 8 * (v14 >> 11) | (v14 >> 13);
      v45 = 4 * ((v14 >> 5) & 0x3F) | (((v14 >> 5) & 0x3F) >> 4);
      v41 = 4 * ((v13 >> 5) & 0x3F) | (((v13 >> 5) & 0x3F) >> 4);
      v16 = 0;
      v17 = -1;
      v34 = 0;
      v44 = 8 * v15 | (v15 >> 2);
      v42 = 8 * (v13 & 0x1F) | ((v13 & 0x1F) >> 2);
      v40 = 8 * (v13 >> 11) | (v13 >> 13);
      v28 = 0;
      if ( v31 )
      {
        v26 = v12;
        do
        {
          if ( !*(_BYTE *)(v37 + v16) )
          {
            v18 = *v12;
            v19 = ((unsigned int)(unsigned __int16)*v12 >> 5) & 0x3F;
            v20 = (unsigned int)(unsigned __int16)*v12 >> 11;
            v21 = 8 * (*(_BYTE *)v12 & 0x1F) | ((*v12 & 0x1F) >> 2);
            v32 = 8 * v20 | (v20 >> 2);
            v36 = 4 * v19 | (v19 >> 4);
            v18 >>= 16;
            v43 = 4 * ((v18 >> 5) & 0x3F) | (((v18 >> 5) & 0x3F) >> 4);
            v22 = (unsigned __int8)v40 - (unsigned __int8)(8 * (v18 >> 11) | (v18 >> 13));
            LOBYTE(v18) = 8 * (v18 & 0x1F) | ((unsigned __int8)(v18 & 0x1F) >> 2);
            v23 = v22 * v22
                + ((unsigned __int8)v41 - (unsigned __int8)v43) * ((unsigned __int8)v41 - (unsigned __int8)v43)
                + ((unsigned __int8)v42 - (unsigned __int8)v18) * ((unsigned __int8)v42 - (unsigned __int8)v18);
            if ( v23
               + ((unsigned __int8)v44 - v21) * ((unsigned __int8)v44 - v21)
               + ((unsigned __int8)v45 - (unsigned __int8)v36) * ((unsigned __int8)v45 - (unsigned __int8)v36)
               + ((unsigned __int8)v35 - (unsigned __int8)v32)
               * ((unsigned __int8)v35 - (unsigned int)(unsigned __int8)v32) < v17 )
            {
              v17 = v23
                  + ((unsigned __int8)v44 - v21) * ((unsigned __int8)v44 - v21)
                  + ((unsigned __int8)v45 - (unsigned __int8)v36) * ((unsigned __int8)v45 - (unsigned __int8)v36)
                  + ((unsigned __int8)v35 - (unsigned __int8)v32) * ((unsigned __int8)v35 - (unsigned __int8)v32);
              v34 = v28;
            }
          }
          v16 = v28 + 1;
          v12 = v26 + 1;
          v28 = v16;
          ++v26;
        }
        while ( v16 < v31 );
      }
      v6 = v34;
      *(_BYTE *)(v37 + v34) = 1;
      *(_DWORD *)(*(_DWORD *)a1 + 4 * v34) = v30++;
      v31 = *(_DWORD *)(a2 + 4);
      if ( v30 == v31 )
        break;
      v3 = a2;
    }
    v11 = v37;
  }
  if ( v11 )
  {
    if ( v11 & 7 )
    {
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v24 = _iob_func();
      fputs(&DstBuf, v24 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(v11, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100739F0) --------------------------------------------------------
char __usercall sub_100739F0@<al>(int a1@<eax>)
{
  int v1; // ebx@1
  void *v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  unsigned int v5; // eax@1
  char v6; // dh^2@1
  int v7; // edx@1
  unsigned int v8; // eax@1
  void **v9; // ebp@1
  int v10; // eax@1
  unsigned int v11; // eax@6
  unsigned int v12; // edi@6
  int v13; // eax@13
  char v14; // ch^2@13
  int v15; // eax@13
  int v16; // ecx@13
  int v17; // edx@13
  int v18; // eax@15
  char v19; // dh^2@15
  int v20; // eax@15
  unsigned __int64 v21; // rax@15
  int v22; // ecx@15
  int v23; // eax@17
  char v24; // dh^2@17
  int v25; // eax@17
  unsigned __int64 v26; // rax@17
  int v27; // ecx@17
  int v28; // eax@19
  char v29; // dh^2@19
  int v30; // eax@19
  unsigned __int64 v31; // rax@19
  int v32; // ecx@19
  char v33; // dh^2@20
  int v34; // eax@20
  int v35; // eax@20
  unsigned int v36; // eax@20
  size_t *v37; // esi@21
  size_t v38; // ecx@22
  unsigned int v39; // eax@23
  unsigned int v40; // edx@23
  unsigned int v41; // edi@23
  _WORD *v42; // edx@31
  _WORD *v43; // edi@31
  unsigned int v44; // edi@31
  int v45; // esi@32
  unsigned int v46; // eax@33
  int v47; // edi@34
  int v48; // esi@34
  unsigned int v49; // eax@34
  char v50; // ch^2@34
  int v51; // edi@34
  unsigned int v52; // eax@34
  unsigned int v53; // eax@34
  unsigned int v55; // [sp+10h] [bp-4Ch]@20
  unsigned int v56; // [sp+18h] [bp-44h]@23
  _WORD *v57; // [sp+18h] [bp-44h]@31
  int v58[16]; // [sp+1Ch] [bp-40h]@22

  v1 = a1;
  v2 = (void *)(a1 + 4184);
  memset((void *)(a1 + 4184), 0, 0x4Au);
  v3 = *(_WORD *)(*(_DWORD *)(v1 + 96) + 12) << 16;
  *(_BYTE *)(v1 + 4197) = *(_WORD *)(*(_DWORD *)(v1 + 96) + 12);
  *(_BYTE *)(v1 + 4196) = BYTE3(v3);
  v4 = *(_WORD *)(*(_DWORD *)(v1 + 96) + 16) << 16;
  *(_BYTE *)(v1 + 4199) = *(_WORD *)(*(_DWORD *)(v1 + 96) + 16);
  *(_BYTE *)(v1 + 4198) = BYTE3(v4);
  *(_BYTE *)(v1 + 4200) = *(_BYTE *)(*(_DWORD *)(v1 + 96) + 20);
  *(_BYTE *)(v1 + 4201) = *(_BYTE *)(*(_DWORD *)(v1 + 96) + 8);
  *(_BYTE *)(v1 + 4202) = *(_BYTE *)(*(_DWORD *)(v1 + 96) + 24);
  v5 = *(_DWORD *)(*(_DWORD *)(v1 + 96) + 468) << 8;
  *(_BYTE *)(v1 + 4209) = *(_DWORD *)(*(_DWORD *)(v1 + 96) + 468) >> 24;
  v6 = BYTE3(v5);
  v5 <<= 8;
  *(_BYTE *)(v1 + 4212) = v5 >> 16;
  *(_BYTE *)(v1 + 4211) = BYTE3(v5);
  *(_BYTE *)(v1 + 4210) = v6;
  v7 = *(_DWORD *)(*(_DWORD *)(v1 + 96) + 472) << 8;
  v8 = *(_DWORD *)(*(_DWORD *)(v1 + 96) + 472) << 16;
  *(_BYTE *)(v1 + 4213) = *(_DWORD *)(*(_DWORD *)(v1 + 96) + 472) >> 24;
  v9 = (void **)(v1 + 4260);
  *(_BYTE *)(v1 + 4214) = BYTE3(v7);
  *(_BYTE *)(v1 + 4215) = BYTE3(v8);
  *(_BYTE *)(v1 + 4216) = v8 >> 16;
  v10 = *(_DWORD *)(v1 + 4260);
  if ( v10 )
  {
    if ( v10 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v10, 0, 0, 1, dword_100AE9F4);
    *v9 = 0;
    *(_DWORD *)(v1 + 4264) = 0;
    *(_DWORD *)(v1 + 4268) = 0;
  }
  sub_10032F10(v1 + 4260, 0x200000u);
  sub_10072F40(v1 + 4260, v2, 0x4Au);
  v11 = *(_DWORD *)(v1 + 4264);
  v12 = *(_DWORD *)(v1 + 4264) + 4 * *(_DWORD *)(*(_DWORD *)(v1 + 96) + 20) - 4;
  if ( v12 != v11 )
  {
    if ( v12 >= v11 )
    {
      if ( v12 > *(_DWORD *)(v1 + 4268) )
        sub_100943C0(v12, 0, v1 + 4260, v12 == v11 + 1, 1u, 0);
      memset((char *)*v9 + *(_DWORD *)(v1 + 4264), 0, v12 - *(_DWORD *)(v1 + 4264));
    }
    *(_DWORD *)(v1 + 4264) = v12;
  }
  if ( *(_DWORD *)(v1 + 5256) )
  {
    v13 = *(_WORD *)(v1 + 4632) << 16;
    *(_BYTE *)(v1 + 4224) = *(_WORD *)(v1 + 4632);
    *(_BYTE *)(v1 + 4223) = BYTE3(v13);
    v14 = *(_DWORD *)(v1 + 5256) << 8 >> 24;
    v15 = *(_DWORD *)(v1 + 5256) << 16;
    *(_BYTE *)(v1 + 4222) = *(_BYTE *)(v1 + 5256);
    *(_BYTE *)(v1 + 4220) = v14;
    *(_BYTE *)(v1 + 4221) = BYTE3(v15);
    v16 = *(_DWORD *)(v1 + 4264) << 8;
    v17 = *(_DWORD *)(v1 + 4264) << 16;
    *(_BYTE *)(v1 + 4219) = *(_BYTE *)(v1 + 4264);
    *(_BYTE *)(v1 + 4217) = BYTE3(v16);
    *(_BYTE *)(v1 + 4218) = BYTE3(v17);
    sub_10072EC0(v1 + 4260, v1 + 5252);
  }
  if ( *(_DWORD *)(v1 + 5268) )
  {
    v18 = *(_WORD *)(v1 + 4584) << 16;
    *(_BYTE *)(v1 + 4232) = *(_WORD *)(v1 + 4584);
    *(_BYTE *)(v1 + 4231) = BYTE3(v18);
    v19 = *(_DWORD *)(v1 + 5268) << 8 >> 24;
    v20 = *(_DWORD *)(v1 + 5268) << 16;
    *(_BYTE *)(v1 + 4230) = *(_BYTE *)(v1 + 5268);
    *(_BYTE *)(v1 + 4228) = v19;
    *(_BYTE *)(v1 + 4229) = BYTE3(v20);
    v21 = (unsigned __int64)(*(_DWORD *)(v1 + 4264) << 8) << 8;
    v22 = *(_DWORD *)(v1 + 4264) << 16;
    *(_BYTE *)(v1 + 4225) = BYTE4(v21);
    *(_BYTE *)(v1 + 4226) = BYTE3(v22);
    *(_BYTE *)(v1 + 4227) = (unsigned int)v21 >> 16;
    sub_10072EC0(v1 + 4260, v1 + 5264);
  }
  if ( *(_DWORD *)(v1 + 5280) )
  {
    v23 = *(_WORD *)(v1 + 4644) << 16;
    *(_BYTE *)(v1 + 4240) = *(_WORD *)(v1 + 4644);
    *(_BYTE *)(v1 + 4239) = BYTE3(v23);
    v24 = *(_DWORD *)(v1 + 5280) << 8 >> 24;
    v25 = *(_DWORD *)(v1 + 5280) << 16;
    *(_BYTE *)(v1 + 4238) = *(_BYTE *)(v1 + 5280);
    *(_BYTE *)(v1 + 4236) = v24;
    *(_BYTE *)(v1 + 4237) = BYTE3(v25);
    v26 = (unsigned __int64)(*(_DWORD *)(v1 + 4264) << 8) << 8;
    v27 = *(_DWORD *)(v1 + 4264) << 16;
    *(_BYTE *)(v1 + 4233) = BYTE4(v26);
    *(_BYTE *)(v1 + 4234) = BYTE3(v27);
    *(_BYTE *)(v1 + 4235) = (unsigned int)v26 >> 16;
    sub_10072EC0(v1 + 4260, v1 + 5276);
  }
  if ( *(_DWORD *)(v1 + 5292) )
  {
    v28 = *(_WORD *)(v1 + 4596) << 16;
    *(_BYTE *)(v1 + 4248) = *(_WORD *)(v1 + 4596);
    *(_BYTE *)(v1 + 4247) = BYTE3(v28);
    v29 = *(_DWORD *)(v1 + 5292) << 8 >> 24;
    v30 = *(_DWORD *)(v1 + 5292) << 16;
    *(_BYTE *)(v1 + 4246) = *(_BYTE *)(v1 + 5292);
    *(_BYTE *)(v1 + 4244) = v29;
    *(_BYTE *)(v1 + 4245) = BYTE3(v30);
    v31 = (unsigned __int64)(*(_DWORD *)(v1 + 4264) << 8) << 8;
    v32 = *(_DWORD *)(v1 + 4264) << 16;
    *(_BYTE *)(v1 + 4241) = BYTE4(v31);
    *(_BYTE *)(v1 + 4242) = BYTE3(v32);
    *(_BYTE *)(v1 + 4243) = (unsigned int)v31 >> 16;
    sub_10072EC0(v1 + 4260, v1 + 5288);
  }
  v33 = *(_DWORD *)(v1 + 4264) << 16 >> 24;
  v34 = *(_DWORD *)(v1 + 4264) & 0xFFFF;
  *(_BYTE *)(v1 + 4251) = *(_DWORD *)(v1 + 4264) << 8 >> 24;
  *(_BYTE *)(v1 + 4253) = v34;
  *(_BYTE *)(v1 + 4252) = v33;
  v35 = *(_DWORD *)(v1 + 5244) & 0xFFFF;
  *(_BYTE *)(v1 + 4249) = *(_DWORD *)(v1 + 5244) << 16 >> 24;
  *(_BYTE *)(v1 + 4250) = v35;
  sub_10072EC0(v1 + 4260, v1 + 5240);
  v36 = 0;
  v55 = 0;
  if ( *(_DWORD *)(v1 + 4072) > 0u )
  {
    v37 = (size_t *)(v1 + 5052);
    do
    {
      v58[v36] = *(_DWORD *)(v1 + 4264);
      v38 = *v37;
      if ( *v37 )
      {
        v39 = *(_DWORD *)(v1 + 4264);
        v40 = v39;
        v41 = v38 + v39;
        v56 = *(_DWORD *)(v1 + 4264);
        if ( v38 + v39 != v39 )
        {
          if ( v38 + v39 >= v39 )
          {
            if ( v41 > *(_DWORD *)(v1 + 4268) )
              sub_100943C0(v41, 0, v1 + 4260, v41 == v39 + 1, 1u, 0);
            memset((char *)*v9 + *(_DWORD *)(v1 + 4264), 0, v41 - *(_DWORD *)(v1 + 4264));
            v40 = v56;
          }
          *(_DWORD *)(v1 + 4264) = v41;
        }
        memcpy((char *)*v9 + v40, (const void *)*(v37 - 1), *v37);
        v36 = v55;
      }
      ++v36;
      v37 += 3;
      v55 = v36;
    }
    while ( v36 < *(_DWORD *)(v1 + 4072) );
  }
  v42 = *v9;
  v43 = *v9;
  qmemcpy(*v9, (const void *)(v1 + 4184), 0x48u);
  v43[36] = *(_WORD *)(v1 + 4256);
  v44 = 0;
  v57 = v42;
  if ( *(_DWORD *)(v1 + 4072) )
  {
    v45 = (int)(v42 + 36);
    do
    {
      v46 = v58[v44];
      *(_BYTE *)(v45 - 2) = (unsigned int)v58[v44] >> 24;
      v46 <<= 8;
      *(_BYTE *)(v45 - 1) = BYTE3(v46);
      v46 <<= 8;
      *(_BYTE *)v45 = BYTE3(v46);
      *(_BYTE *)(v45 + 1) = v46 >> 16;
      ++v44;
      v45 += 4;
    }
    while ( v44 < *(_DWORD *)(v1 + 4072) );
  }
  v47 = *(_DWORD *)(v1 + 4072);
  *v42 = 30792;
  v48 = (int)(v42 + 3);
  v49 = *(_DWORD *)(v1 + 4264) << 8;
  v50 = *(_DWORD *)(v1 + 4264) << 8 >> 24;
  *(_BYTE *)v48 = *(_DWORD *)(v1 + 4264) >> 24;
  v49 <<= 8;
  *(_BYTE *)(v48 + 2) = BYTE3(v49);
  *(_BYTE *)(v48 + 3) = v49 >> 16;
  *(_BYTE *)(v48 + 1) = v50;
  v51 = 4 * v47 + 70;
  v52 = (unsigned __int16)sub_1005B3A0(*(_DWORD *)(v1 + 4264) - v51, (_BYTE *)*v9 + v51) << 16;
  *((_BYTE *)v57 + 11) = v52 >> 16;
  *((_BYTE *)v57 + 10) = BYTE3(v52);
  *((_BYTE *)v57 + 2) = (unsigned int)(v51 << 16) >> 24;
  *((_BYTE *)v57 + 3) = v51;
  v53 = (unsigned __int16)sub_1005B3A0(v51 - 6, (_BYTE *)v48) << 16;
  *((_BYTE *)v57 + 5) = v53 >> 16;
  *((_BYTE *)v57 + 4) = BYTE3(v53);
  return 1;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100739F0: using guessed type int var_40[16];

//----- (10073FE0) --------------------------------------------------------
void __thiscall sub_10073FE0(int this, int a2, int a3, int a4)
{
  int v4; // edx@1
  int v5; // edi@1
  int v6; // eax@3
  int v7; // esi@3
  float v8; // [sp+1Ch] [bp+Ch]@3

  v4 = a4;
  v5 = *(_DWORD *)(a4 + 12);
  if ( *(_DWORD *)(a4 + 8) == v5 )
  {
    sub_10072FB0((int)byte_1009F8AC, *(_DWORD *)(a4 + 4), this + 4592);
  }
  else
  {
    v6 = *(_DWORD *)(a4 + 8);
    v7 = *(_DWORD *)a4;
    v8 = (double)*(unsigned int *)(a4 + 8) / (double)(unsigned int)(v5 - 1);
    sub_1005B5A0(
      *(_DWORD *)(this + 4596),
      *(_DWORD *)(this + 4596),
      *(_DWORD *)(v7 + 4),
      *(_DWORD *)v7,
      *(_DWORD *)(v4 + 4),
      v6 != 0 ? (unsigned int)sub_10072670 : 0,
      this + 4592,
      v8);
  }
}
// 10072670: using guessed type int sub_10072670();

//----- (10074080) --------------------------------------------------------
void __thiscall sub_10074080(int this, int a2, int a3, void *a4)
{
  void *v4; // ebx@1
  int v5; // esi@1
  int v6; // eax@3
  int v7; // edx@3
  void *v8; // [sp+1Ch] [bp+Ch]@3

  v4 = a4;
  v5 = *((_DWORD *)a4 + 3);
  if ( *((_DWORD *)a4 + 2) == v5 )
  {
    sub_100732F0(*((_DWORD *)a4 + 1), this + 4640);
  }
  else
  {
    v6 = *((_DWORD *)a4 + 2);
    v7 = *(_DWORD *)a4;
    *(float *)&v8 = (double)*((unsigned int *)a4 + 2) / (double)(unsigned int)(v5 - 1);
    sub_1005B5A0(
      *(_DWORD *)(this + 4644),
      *(_DWORD *)(this + 4644),
      *(_DWORD *)(v7 + 4),
      *(_DWORD *)v7,
      *((_DWORD *)v4 + 1),
      v6 != 0 ? (unsigned int)sub_100728F0 : 0,
      this + 4272,
      *(float *)&v8);
  }
  if ( (unsigned __int8)v4 & 7 )
    sub_100927E0((int)"crnlib_free: bad ptr");
  else
    off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
}
// 100728F0: using guessed type int sub_100728F0();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10074140) --------------------------------------------------------
void __thiscall sub_10074140(int this, int a2, int a3, void *a4)
{
  int *v4; // ebx@1
  int v5; // edx@1
  int v6; // eax@3
  void *v7; // [sp+18h] [bp+Ch]@3

  v4 = (int *)a4;
  v5 = *((_DWORD *)a4 + 2);
  if ( *((_DWORD *)a4 + 1) == v5 )
  {
    sub_10072FB0((int)byte_1009F8C0, *(_DWORD *)a4, this + 4580);
  }
  else
  {
    v6 = *((_DWORD *)a4 + 1);
    *(float *)&v7 = (double)*((unsigned int *)a4 + 1) / (double)(unsigned int)(v5 - 1);
    sub_1005B5A0(
      *(_DWORD *)(this + 4136),
      *(_DWORD *)(this + 4584),
      *(_DWORD *)(this + 4136),
      *(_DWORD *)(this + 4132),
      *v4,
      v6 != 0 ? (unsigned int)sub_100727B0 : 0,
      this + 4580,
      *(float *)&v7);
  }
  if ( (unsigned __int8)v4 & 7 )
    sub_100927E0((int)"crnlib_free: bad ptr");
  else
    off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
}
// 100727B0: using guessed type int sub_100727B0();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10074200) --------------------------------------------------------
void __thiscall sub_10074200(int this, int a2, int a3, void *a4)
{
  int *v4; // ebx@1
  int v5; // edx@1
  int v6; // eax@3
  void *v7; // [sp+18h] [bp+Ch]@3

  v4 = (int *)a4;
  v5 = *((_DWORD *)a4 + 2);
  if ( *((_DWORD *)a4 + 1) == v5 )
  {
    sub_10073550(*(_DWORD *)a4, this + 4628);
  }
  else
  {
    v6 = *((_DWORD *)a4 + 1);
    *(float *)&v7 = (double)*((unsigned int *)a4 + 1) / (double)(unsigned int)(v5 - 1);
    sub_1005B5A0(
      *(_DWORD *)(this + 4100),
      *(_DWORD *)(this + 4632),
      *(_DWORD *)(this + 4100),
      *(_DWORD *)(this + 4096),
      *v4,
      v6 != 0 ? (unsigned int)sub_100729A0 : 0,
      this + 4272,
      *(float *)&v7);
  }
  if ( (unsigned __int8)v4 & 7 )
    sub_100927E0((int)"crnlib_free: bad ptr");
  else
    off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100742C0) --------------------------------------------------------
unsigned int __stdcall sub_100742C0(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  signed int v3; // ebp@1
  int v4; // eax@2
  unsigned int v5; // edi@2
  unsigned int result; // eax@7
  unsigned int v7; // edx@13
  int v8; // ecx@15
  int v9; // eax@15
  int v10; // eax@19
  int v11; // ebp@20
  int v12; // esi@20
  _WORD *v13; // ebp@23
  int v14; // ebx@24
  _WORD *v15; // ebp@27
  signed int v16; // ebx@28
  unsigned int v17; // eax@29
  int v18; // edi@29
  int v19; // [sp+10h] [bp-18h]@20
  int v20; // [sp+14h] [bp-14h]@14
  signed int v21; // [sp+18h] [bp-10h]@27
  int v22; // [sp+1Ch] [bp-Ch]@15
  unsigned int v23; // [sp+20h] [bp-8h]@20
  unsigned int v24; // [sp+24h] [bp-4h]@13

  v1 = a1;
  sub_10036BD0(a1 + 4084, *(_DWORD *)(a1 + 4168));
  v2 = a1 + 4104;
  v3 = 3;
  do
  {
    v4 = *(_DWORD *)(v2 - 8);
    v5 = 0;
    if ( v4 )
    {
      if ( v4 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
      *(_DWORD *)(v2 - 8) = 0;
      *(_DWORD *)(v2 - 4) = 0;
      *(_DWORD *)v2 = 0;
    }
    result = *(_DWORD *)(v2 + 28);
    if ( result )
    {
      if ( result & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        result = off_100AD9F4(result, 0, 0, 1, dword_100AE9F4);
      *(_DWORD *)(v2 + 28) = 0;
      *(_DWORD *)(v2 + 32) = 0;
      *(_DWORD *)(v2 + 36) = 0;
    }
    v2 += 12;
    --v3;
  }
  while ( v3 );
  v7 = 0;
  v24 = 0;
  if ( *(_DWORD *)(a1 + 4168) > 0u )
  {
    v20 = 0;
    do
    {
      v8 = v20 + *(_DWORD *)(v1 + 4464);
      v9 = 0;
      v22 = v20 + *(_DWORD *)(v1 + 4464);
      while ( !*(_BYTE *)(v1 + v9 + 4080) )
      {
        if ( (unsigned int)++v9 >= 3 )
          goto LABEL_20;
      }
      v10 = 3 * v9;
      *(_DWORD *)(*(_DWORD *)(v1 + 4084) + 8 * v7) = *(_DWORD *)(v1 + 4 * v10 + 4100);
      *(_DWORD *)(*(_DWORD *)(v1 + 4084) + 8 * v7 + 4) = *(_DWORD *)(v1 + 4 * v10 + 4136);
LABEL_20:
      result = 0;
      v11 = v8 + 26;
      v23 = 0;
      v19 = v8 + 26;
      v12 = v1 + 4100;
      do
      {
        if ( *(_BYTE *)(v1 + result + 4080) )
        {
          if ( *(_BYTE *)(v8 + 1) )
          {
            v13 = (_WORD *)(v11 - 24);
            do
            {
              v14 = *v13;
              if ( *(_DWORD *)v12 >= *(_DWORD *)(v12 + 4) )
                sub_100943C0(*(_DWORD *)v12 + 1, 0, v12 - 4, 1, 4u, 0);
              *(_DWORD *)(*(_DWORD *)(v12 - 4) + 4 * (*(_DWORD *)v12)++) = v14;
              ++v5;
              ++v13;
            }
            while ( v5 < *(_BYTE *)(v22 + 1) );
          }
          v15 = (_WORD *)v19;
          v21 = 2;
          do
          {
            v16 = 2;
            do
            {
              v17 = *(_DWORD *)(v12 + 36);
              v18 = *v15;
              if ( v17 >= *(_DWORD *)(v12 + 40) )
                sub_100943C0(v17 + 1, 0, v12 + 32, 1, 4u, 0);
              *(_DWORD *)(*(_DWORD *)(v12 + 32) + 4 * (*(_DWORD *)(v12 + 36))++) = v18;
              ++v15;
              --v16;
            }
            while ( v16 );
            --v21;
          }
          while ( v21 );
          v1 = a1;
          result = v23;
          v8 = v22;
          v7 = v24;
          v5 = 0;
        }
        ++result;
        v11 = v19 + 8;
        v12 += 12;
        v23 = result;
        v19 += 8;
      }
      while ( result < 3 );
      v20 += 50;
      v24 = ++v7;
    }
    while ( v7 < *(_DWORD *)(v1 + 4168) );
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100744C0) --------------------------------------------------------
int __stdcall sub_100744C0(int a1)
{
  int v1; // esi@1
  int v2; // eax@3
  FILE *v3; // eax@5
  int v4; // eax@11
  int v5; // eax@16
  int v6; // eax@22
  FILE *v7; // eax@24
  int v8; // eax@28
  FILE *v9; // eax@30
  int v10; // eax@35
  FILE *v11; // eax@37
  int v12; // eax@41
  FILE *v13; // eax@43
  int v14; // eax@47
  FILE *v15; // eax@49
  int v16; // eax@54
  FILE *v17; // eax@56
  int v18; // eax@60
  FILE *v19; // eax@62
  int v20; // eax@68
  FILE *v21; // eax@70
  int v22; // eax@75
  FILE *v23; // eax@77
  int v24; // eax@81
  FILE *v25; // eax@83
  int v26; // eax@87
  FILE *v27; // eax@89
  int v28; // eax@93
  FILE *v29; // eax@95
  int result; // eax@99
  FILE *v31; // eax@101
  signed int v32; // [sp+10h] [bp-A0Ch]@2
  signed int v33; // [sp+10h] [bp-A0Ch]@21
  int v34; // [sp+10h] [bp-A0Ch]@53
  int v35; // [sp+10h] [bp-A0Ch]@67
  signed int v36; // [sp+14h] [bp-A08h]@1
  int v37; // [sp+14h] [bp-A08h]@21
  int v38; // [sp+14h] [bp-A08h]@53
  signed int v39; // [sp+18h] [bp-A04h]@53
  signed int v40; // [sp+18h] [bp-A04h]@67
  CHAR v41; // [sp+1Ch] [bp-A00h]@37
  char DstBuf; // [sp+21Ch] [bp-800h]@5
  CHAR OutputString; // [sp+41Ch] [bp-600h]@24
  CHAR v44; // [sp+61Ch] [bp-400h]@30
  CHAR v45; // [sp+81Ch] [bp-200h]@95

  *(_DWORD *)(a1 + 96) = 0;
  v1 = a1 + 124;
  v36 = 6;
  do
  {
    v32 = 16;
    do
    {
      *(_DWORD *)(v1 - 4) = 0;
      v2 = *(_DWORD *)v1;
      if ( *(_DWORD *)v1 )
      {
        if ( v2 & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v3 = _iob_func();
          fputs(&DstBuf, v3 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
        }
        *(_DWORD *)v1 = 0;
        *(_DWORD *)(v1 + 4) = 0;
        *(_DWORD *)(v1 + 8) = 0;
      }
      *(_DWORD *)(v1 - 24) = 0;
      *(_DWORD *)(v1 - 20) = 0;
      *(_DWORD *)(v1 - 16) = 0;
      *(_DWORD *)(v1 - 12) = 0;
      *(_DWORD *)(v1 - 8) = 15;
      v1 += 36;
      --v32;
    }
    while ( v32 );
    --v36;
  }
  while ( v36 );
  memset((void *)(a1 + 3556), 0, 0x200u);
  v4 = *(_DWORD *)(a1 + 4068);
  if ( v4 )
  {
    if ( v4 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 4068) = 0;
    *(_DWORD *)(a1 + 4072) = 0;
    *(_DWORD *)(a1 + 4076) = 0;
  }
  *(_WORD *)(a1 + 4080) = 0;
  *(_BYTE *)(a1 + 4082) = 0;
  v5 = *(_DWORD *)(a1 + 4084);
  if ( v5 )
  {
    if ( v5 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a1 + 4084) = 0;
    *(_DWORD *)(a1 + 4088) = 0;
    *(_DWORD *)(a1 + 4092) = 0;
  }
  v37 = a1 + 4104;
  v33 = 3;
  do
  {
    v6 = *(_DWORD *)(v37 - 8);
    if ( v6 )
    {
      if ( v6 & 7 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_free: bad ptr");
        OutputDebugStringA(&OutputString);
        v7 = _iob_func();
        fputs(&OutputString, v7 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v6, 0, 0, 1, dword_100AE9F4);
      }
      *(_DWORD *)(v37 - 8) = 0;
      *(_DWORD *)(v37 - 4) = 0;
      *(_DWORD *)v37 = 0;
    }
    v8 = *(_DWORD *)(v37 + 28);
    if ( v8 )
    {
      if ( v8 & 7 )
      {
        sprintf_s(&v44, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&v44);
        v9 = _iob_func();
        fputs(&v44, v9 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v8, 0, 0, 1, dword_100AE9F4);
      }
      *(_DWORD *)(v37 + 28) = 0;
      *(_DWORD *)(v37 + 32) = 0;
      *(_DWORD *)(v37 + 36) = 0;
    }
    v37 += 12;
    --v33;
  }
  while ( v33 );
  *(_DWORD *)(a1 + 4168) = 0;
  v10 = *(_DWORD *)(a1 + 4172);
  if ( v10 )
  {
    if ( v10 & 7 )
    {
      sprintf_s(&v41, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&v41);
      v11 = _iob_func();
      fputs(&v41, v11 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(v10, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 4172) = 0;
    *(_DWORD *)(a1 + 4176) = 0;
    *(_DWORD *)(a1 + 4180) = 0;
  }
  memset((void *)(a1 + 4184), 0, 0x4Au);
  v12 = *(_DWORD *)(a1 + 4260);
  if ( v12 )
  {
    if ( v12 & 7 )
    {
      sprintf_s(&v41, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&v41);
      v13 = _iob_func();
      fputs(&v41, v13 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(v12, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 4260) = 0;
    *(_DWORD *)(a1 + 4264) = 0;
    *(_DWORD *)(a1 + 4268) = 0;
  }
  sub_1005F570(a1 + 4272);
  v14 = *(_DWORD *)(a1 + 4808);
  if ( v14 )
  {
    if ( v14 & 7 )
    {
      sprintf_s(&v41, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&v41);
      v15 = _iob_func();
      fputs(&v41, v15 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(v14, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 4808) = 0;
    *(_DWORD *)(a1 + 4812) = 0;
    *(_DWORD *)(a1 + 4816) = 0;
  }
  sub_1005C4E0(a1 + 4820);
  v38 = a1 + 4864;
  v34 = a1 + 4976;
  v39 = 2;
  do
  {
    v16 = *(_DWORD *)(v38 - 8);
    if ( v16 )
    {
      if ( v16 & 7 )
      {
        sprintf_s(&v41, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&v41);
        v17 = _iob_func();
        fputs(&v41, v17 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v16, 0, 0, 1, dword_100AE9F4);
      }
      *(_DWORD *)(v38 - 8) = 0;
      *(_DWORD *)(v38 - 4) = 0;
      *(_DWORD *)v38 = 0;
    }
    sub_1005C4E0(v34 - 96);
    v18 = *(_DWORD *)(v38 + 88);
    if ( v18 )
    {
      if ( v18 & 7 )
      {
        sprintf_s(&v41, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&v41);
        v19 = _iob_func();
        fputs(&v41, v19 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v18, 0, 0, 1, dword_100AE9F4);
      }
      *(_DWORD *)(v38 + 88) = 0;
      *(_DWORD *)(v38 + 92) = 0;
      *(_DWORD *)(v38 + 96) = 0;
    }
    sub_1005C4E0(v34);
    v38 += 12;
    v34 += 36;
    --v39;
  }
  while ( v39 );
  v35 = a1 + 5048;
  v40 = 16;
  do
  {
    v20 = *(_DWORD *)v35;
    if ( *(_DWORD *)v35 )
    {
      if ( v20 & 7 )
      {
        sprintf_s(&v41, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&v41);
        v21 = _iob_func();
        fputs(&v41, v21 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v20, 0, 0, 1, dword_100AE9F4);
      }
      *(_DWORD *)v35 = 0;
      *(_DWORD *)(v35 + 4) = 0;
      *(_DWORD *)(v35 + 8) = 0;
    }
    v35 += 12;
    --v40;
  }
  while ( v40 );
  v22 = *(_DWORD *)(a1 + 5240);
  if ( v22 )
  {
    if ( v22 & 7 )
    {
      sprintf_s(&v44, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&v44);
      v23 = _iob_func();
      fputs(&v44, v23 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(v22, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 5240) = 0;
    *(_DWORD *)(a1 + 5244) = 0;
    *(_DWORD *)(a1 + 5248) = 0;
  }
  v24 = *(_DWORD *)(a1 + 5252);
  if ( v24 )
  {
    if ( v24 & 7 )
    {
      sprintf_s(&OutputString, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&OutputString);
      v25 = _iob_func();
      fputs(&OutputString, v25 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(v24, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 5252) = 0;
    *(_DWORD *)(a1 + 5256) = 0;
    *(_DWORD *)(a1 + 5260) = 0;
  }
  v26 = *(_DWORD *)(a1 + 5264);
  if ( v26 )
  {
    if ( v26 & 7 )
    {
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v27 = _iob_func();
      fputs(&DstBuf, v27 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(v26, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 5264) = 0;
    *(_DWORD *)(a1 + 5268) = 0;
    *(_DWORD *)(a1 + 5272) = 0;
  }
  v28 = *(_DWORD *)(a1 + 5276);
  if ( v28 )
  {
    if ( v28 & 7 )
    {
      sprintf_s(&v45, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&v45);
      v29 = _iob_func();
      fputs(&v45, v29 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(v28, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 5276) = 0;
    *(_DWORD *)(a1 + 5280) = 0;
    *(_DWORD *)(a1 + 5284) = 0;
  }
  result = *(_DWORD *)(a1 + 5288);
  if ( result )
  {
    if ( result & 7 )
    {
      sprintf_s(&v45, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&v45);
      v31 = _iob_func();
      fputs(&v45, v31 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(result, 0, 0, 1, dword_100AE9F4);
    }
    result = a1;
    *(_DWORD *)(a1 + 5288) = 0;
    *(_DWORD *)(a1 + 5292) = 0;
    *(_DWORD *)(a1 + 5296) = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10074F00) --------------------------------------------------------
unsigned int __stdcall sub_10074F00(int a1)
{
  int v1; // esi@1
  unsigned int result; // eax@3
  unsigned int v3; // ecx@3
  int v4; // edi@4
  unsigned int v5; // ebx@5
  float v6; // ST28_4@6
  int v7; // esi@6
  double v8; // st7@7
  float v9; // ST28_4@9
  int v10; // [sp+14h] [bp-10h]@4
  float v11; // [sp+18h] [bp-Ch]@6
  unsigned int v12; // [sp+20h] [bp-4h]@3

  v1 = a1;
  sub_10036A70(a1 + 4172, *(_DWORD *)(a1 + 4168));
  if ( *(_DWORD *)(a1 + 4176) )
    *(_DWORD *)(a1 + 4176) = 0;
  result = *(_DWORD *)(a1 + 96);
  v3 = 0;
  v12 = 0;
  if ( *(_DWORD *)(result + 20) )
  {
    result = *(_DWORD *)(result + 8);
    v10 = a1 + 100;
    v4 = a1 + 3564;
    do
    {
      v5 = 0;
      if ( result )
      {
        v6 = pow(1.299999952316284, (double)v3);
        v7 = v10;
        v11 = v6;
        do
        {
          v8 = v11;
          if ( v11 > 12.0 )
            v8 = 12.0;
          v9 = v8;
          sub_10072BB0(v7, *(_DWORD *)v4, *(_DWORD *)(v4 + 4), a1 + 4172, v9);
          result = *(_DWORD *)(*(_DWORD *)(a1 + 96) + 8);
          ++v5;
          v7 += 576;
        }
        while ( v5 < result );
        v3 = v12;
        v1 = a1;
      }
      v10 += 36;
      ++v3;
      v4 += 32;
      v12 = v3;
    }
    while ( v3 < *(_DWORD *)(*(_DWORD *)(v1 + 96) + 20) );
  }
  return result;
}

//----- (10075010) --------------------------------------------------------
char __userpurge sub_10075010@<al>(unsigned int a1@<eax>, int a2, int a3, char a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // ebp@1
  unsigned int v10; // ebx@1
  unsigned int v11; // eax@2
  _DWORD *v12; // esi@2
  unsigned int v13; // eax@9
  signed int v14; // eax@23
  unsigned int v15; // ecx@23
  unsigned int v16; // edi@23
  int v17; // ebx@24
  int v18; // ecx@34
  unsigned int v19; // eax@36
  int v20; // eax@38
  unsigned int v21; // eax@43
  int v22; // eax@44
  int v23; // edx@44
  unsigned int v24; // ebx@47
  int v25; // ecx@48
  int v26; // edi@49
  int v27; // eax@49
  int v28; // ecx@53
  unsigned int v29; // eax@55
  int v30; // esi@55
  int v31; // eax@57
  int v32; // esi@62
  unsigned int v33; // ebx@63
  int v34; // ecx@64
  int *v35; // eax@64
  int v36; // ecx@64
  int v37; // edi@66
  int v38; // eax@66
  int v39; // ecx@70
  unsigned int v40; // eax@72
  int v41; // esi@72
  int v42; // eax@74
  int v43; // edx@80
  int v44; // esi@80
  unsigned int v45; // eax@82
  int v46; // eax@83
  int v47; // edi@86
  int v48; // eax@86
  int v49; // ecx@90
  int v50; // ebx@90
  unsigned int v51; // eax@92
  int v52; // eax@94
  int v53; // edx@99
  int v54; // edi@99
  int *v55; // ebx@99
  int v56; // eax@99
  int v57; // ecx@103
  unsigned int v58; // eax@105
  int v59; // eax@107
  int v61; // [sp+10h] [bp-68h]@53
  _DWORD *v62; // [sp+10h] [bp-68h]@64
  unsigned int v63; // [sp+10h] [bp-68h]@82
  unsigned int v64; // [sp+14h] [bp-64h]@23
  int v65; // [sp+18h] [bp-60h]@24
  int v66; // [sp+1Ch] [bp-5Ch]@43
  int v67; // [sp+20h] [bp-58h]@70
  int *v68; // [sp+24h] [bp-54h]@64
  int v69; // [sp+24h] [bp-54h]@103
  unsigned int v70; // [sp+28h] [bp-50h]@23
  int v71; // [sp+30h] [bp-48h]@36
  int v72; // [sp+38h] [bp-40h]@55
  int v73; // [sp+40h] [bp-38h]@72
  int v74; // [sp+48h] [bp-30h]@92
  int v75; // [sp+50h] [bp-28h]@105
  int v76; // [sp+54h] [bp-24h]@23
  int v77; // [sp+58h] [bp-20h]@23
  int v78; // [sp+5Ch] [bp-1Ch]@23
  int v79; // [sp+60h] [bp-18h]@23
  int v80; // [sp+64h] [bp-14h]@23
  int v81; // [sp+68h] [bp-10h]@23
  int v82; // [sp+6Ch] [bp-Ch]@24
  int v83; // [sp+70h] [bp-8h]@24
  int v84; // [sp+74h] [bp-4h]@24
  int v85; // [sp+7Ch] [bp+4h]@43
  unsigned int v86; // [sp+80h] [bp+8h]@43
  unsigned int v87; // [sp+80h] [bp+8h]@80
  int v88; // [sp+84h] [bp+Ch]@34
  int v89; // [sp+84h] [bp+Ch]@43
  unsigned int v90; // [sp+84h] [bp+Ch]@81

  v9 = a2;
  v10 = a1;
  if ( !a5 )
  {
    v11 = *(_DWORD *)(a2 + 4812);
    v12 = (_DWORD *)(a2 + 4808);
    if ( v11 != 512 )
    {
      if ( v11 <= 0x200 )
      {
        if ( *(_DWORD *)(a2 + 4816) < 0x200u )
          sub_100943C0(0x200u, 0, a2 + 4808, v11 == 511, 4u, 0);
        memset((void *)(*v12 + 4 * *(_DWORD *)(a2 + 4812)), 0, 4 * (512 - *(_DWORD *)(a2 + 4812)));
      }
      *(_DWORD *)(a2 + 4812) = 512;
    }
    if ( a4 )
    {
      v13 = 0;
      if ( *(_DWORD *)(a2 + 4812) )
      {
        do
          *(_DWORD *)(*v12 + 4 * v13++) = 0;
        while ( v13 < *(_DWORD *)(a2 + 4812) );
      }
    }
    if ( a6 )
    {
      sub_100366C0(a2 + 4856, *(_DWORD *)(a6 + 4));
      if ( a4 )
        sub_10036820(a2 + 4856);
    }
    if ( a7 )
    {
      sub_100366C0(a2 + 4952, *(_DWORD *)(a7 + 4));
      if ( a4 )
        sub_10036820(a2 + 4952);
    }
    if ( a8 )
    {
      sub_100366C0(a2 + 4868, *(_DWORD *)(a8 + 4));
      if ( a4 )
        sub_10036820(a2 + 4868);
    }
    if ( a9 )
    {
      sub_100366C0(a2 + 4964, *(_DWORD *)(a9 + 4));
      if ( a4 )
        sub_10036820(a2 + 4964);
    }
  }
  v14 = 0;
  v15 = v10 + a3;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v16 = v10;
  v64 = v10;
  v70 = v10 + a3;
  if ( v10 < v10 + a3 )
  {
    v17 = 50 * v10;
    v82 = 1;
    v83 = 2;
    v84 = 0;
    v65 = v17;
    while ( 1 )
    {
      if ( !v14 )
      {
        if ( v16 < v15 )
          v14 = *(_BYTE *)(v17 + *(_DWORD *)(v9 + 4464));
        if ( v16 + 1 < v15 )
          v14 |= 8 * *(_BYTE *)(v17 + *(_DWORD *)(v9 + 4464) + 50);
        if ( v16 + 2 < v15 )
          v14 |= *(_BYTE *)(v17 + *(_DWORD *)(v9 + 4464) + 100) << 6;
        if ( a5 )
        {
          v18 = *(_BYTE *)(*(_DWORD *)(v9 + 4836) + v14);
          v88 = *(_WORD *)(*(_DWORD *)(v9 + 4824) + 2 * v14);
          if ( *(_BYTE *)(*(_DWORD *)(v9 + 4836) + v14) )
          {
            *(_DWORD *)(a5 + 76) += v18;
            if ( !*(_BYTE *)(a5 + 80) )
            {
              v19 = *(_DWORD *)(a5 + 68);
              v71 = (unsigned __int16)v18;
              if ( v19 >= *(_DWORD *)(a5 + 72) )
                sub_100943C0(v19 + 1, 0, a5 + 64, 1, 8u, 0);
              v20 = *(_DWORD *)(a5 + 64) + 8 * *(_DWORD *)(a5 + 68);
              if ( v20 )
              {
                *(_DWORD *)v20 = v88;
                *(_DWORD *)(v20 + 4) = v71;
              }
              ++*(_DWORD *)(a5 + 68);
            }
          }
        }
        else
        {
          ++*(_DWORD *)(*(_DWORD *)(v9 + 4808) + 4 * v14);
        }
        v14 = 3;
      }
      v66 = v14 - 1;
      v89 = v17 + *(_DWORD *)(v9 + 4464);
      v85 = *(_DWORD *)(v9 + 4084) + 8 * v16;
      v21 = 0;
      v86 = 0;
      do
      {
        v22 = *(&v82 + v21);
        v23 = a5;
        if ( *(_BYTE *)(v22 + v9 + 4080) )
        {
          if ( v22 )
          {
            v32 = a8;
            if ( a8 )
            {
              v33 = 0;
              if ( *(_BYTE *)(v89 + 1) )
              {
                v34 = v9 + 12 * v22 + 4096;
                v35 = &v76 + v22;
                v62 = (_DWORD *)v34;
                v36 = *v35;
                v68 = v35;
                while ( 1 )
                {
                  v37 = *(_DWORD *)(*(_DWORD *)v32 + 4 * *(_DWORD *)(*v62 + 4 * (v33 + *(_DWORD *)v85)));
                  v38 = *(_DWORD *)(*(_DWORD *)v32 + 4 * *(_DWORD *)(*v62 + 4 * (v33 + *(_DWORD *)v85))) - v36;
                  if ( v38 < 0 )
                    v38 += *(_DWORD *)(v32 + 4);
                  if ( v23 )
                  {
                    v39 = *(_BYTE *)(*(_DWORD *)(v9 + 4932) + v38);
                    v67 = *(_WORD *)(*(_DWORD *)(v9 + 4920) + 2 * v38);
                    if ( *(_BYTE *)(*(_DWORD *)(v9 + 4932) + v38) )
                    {
                      *(_DWORD *)(v23 + 76) += v39;
                      if ( !*(_BYTE *)(v23 + 80) )
                      {
                        v40 = *(_DWORD *)(v23 + 68);
                        v41 = v23 + 64;
                        v73 = (unsigned __int16)v39;
                        if ( v40 >= *(_DWORD *)(v23 + 72) )
                        {
                          sub_100943C0(v40 + 1, 0, v23 + 64, 1, 8u, 0);
                          v23 = a5;
                        }
                        v42 = *(_DWORD *)v41 + 8 * *(_DWORD *)(v41 + 4);
                        if ( v42 )
                        {
                          *(_DWORD *)v42 = v67;
                          *(_DWORD *)(v42 + 4) = v73;
                        }
                        ++*(_DWORD *)(v41 + 4);
                      }
                    }
                  }
                  else
                  {
                    ++*(_DWORD *)(*(_DWORD *)(v9 + 4868) + 4 * v38);
                  }
                  ++v33;
                  v36 = v37;
                  if ( v33 >= *(_BYTE *)(v89 + 1) )
                    break;
                  v32 = a8;
                }
                *v68 = v37;
              }
            }
          }
          else if ( a6 )
          {
            v24 = 0;
            if ( *(_BYTE *)(v89 + 1) )
            {
              v25 = v76;
              do
              {
                v26 = *(_DWORD *)(*(_DWORD *)a6 + 4 * *(_DWORD *)(*(_DWORD *)(v9 + 4096) + 4 * (v24 + *(_DWORD *)v85)));
                v27 = *(_DWORD *)(*(_DWORD *)a6 + 4 * *(_DWORD *)(*(_DWORD *)(v9 + 4096) + 4 * (v24 + *(_DWORD *)v85)))
                    - v25;
                if ( v27 < 0 )
                  v27 += *(_DWORD *)(a6 + 4);
                if ( v23 )
                {
                  v28 = *(_BYTE *)(*(_DWORD *)(v9 + 4896) + v27);
                  v61 = *(_WORD *)(*(_DWORD *)(v9 + 4884) + 2 * v27);
                  if ( *(_BYTE *)(*(_DWORD *)(v9 + 4896) + v27) )
                  {
                    *(_DWORD *)(v23 + 76) += v28;
                    if ( !*(_BYTE *)(v23 + 80) )
                    {
                      v29 = *(_DWORD *)(v23 + 68);
                      v30 = v23 + 64;
                      v72 = (unsigned __int16)v28;
                      if ( v29 >= *(_DWORD *)(v23 + 72) )
                      {
                        sub_100943C0(v29 + 1, 0, v23 + 64, 1, 8u, 0);
                        v23 = a5;
                      }
                      v31 = *(_DWORD *)v30 + 8 * *(_DWORD *)(v30 + 4);
                      if ( v31 )
                      {
                        *(_DWORD *)v31 = v61;
                        *(_DWORD *)(v31 + 4) = v72;
                      }
                      ++*(_DWORD *)(v30 + 4);
                    }
                  }
                }
                else
                {
                  ++*(_DWORD *)(*(_DWORD *)(v9 + 4856) + 4 * v27);
                }
                ++v24;
                v25 = v26;
              }
              while ( v24 < *(_BYTE *)(v89 + 1) );
              v76 = v26;
            }
          }
        }
        v21 = v86 + 1;
        v86 = v21;
      }
      while ( v21 < 3 );
      v43 = a7;
      v44 = a5;
      v87 = 0;
      do
      {
        v90 = 0;
        do
        {
          v45 = 0;
          v63 = 0;
          do
          {
            v46 = *(&v82 + v45);
            if ( *(_BYTE *)(v46 + v9 + 4080) )
            {
              if ( v46 )
              {
                if ( a9 )
                {
                  v53 = *(_DWORD *)(*(_DWORD *)(v9 + 12 * v46 + 4132) + 4 * (v90 + v87 + *(_DWORD *)(v85 + 4)));
                  v54 = *(_DWORD *)(*(_DWORD *)a9 + 4 * v53);
                  v55 = &v79 + v46;
                  v56 = *(_DWORD *)(*(_DWORD *)a9 + 4 * v53) - *v55;
                  if ( v56 < 0 )
                    v56 += *(_DWORD *)(a9 + 4);
                  if ( a5 )
                  {
                    v57 = *(_BYTE *)(*(_DWORD *)(v9 + 5028) + v56);
                    v69 = *(_WORD *)(*(_DWORD *)(v9 + 5016) + 2 * v56);
                    if ( *(_BYTE *)(*(_DWORD *)(v9 + 5028) + v56) )
                    {
                      *(_DWORD *)(a5 + 76) += v57;
                      if ( !*(_BYTE *)(a5 + 80) )
                      {
                        v58 = *(_DWORD *)(a5 + 68);
                        v75 = (unsigned __int16)v57;
                        if ( v58 >= *(_DWORD *)(a5 + 72) )
                          sub_100943C0(v58 + 1, 0, a5 + 64, 1, 8u, 0);
                        v59 = *(_DWORD *)(a5 + 64) + 8 * *(_DWORD *)(a5 + 68);
                        if ( v59 )
                        {
                          *(_DWORD *)v59 = v69;
                          *(_DWORD *)(v59 + 4) = v75;
                        }
                        ++*(_DWORD *)(a5 + 68);
                      }
                    }
                  }
                  else
                  {
                    ++*(_DWORD *)(*(_DWORD *)(v9 + 4964) + 4 * v56);
                  }
                  v43 = a7;
                  v44 = a5;
                  *v55 = v54;
                }
              }
              else if ( v43 )
              {
                v47 = *(_DWORD *)(*(_DWORD *)v43
                                + 4 * *(_DWORD *)(*(_DWORD *)(v9 + 4132) + 4 * (v90 + v87 + *(_DWORD *)(v85 + 4))));
                v48 = v47 - v79;
                if ( v47 - v79 < 0 )
                  v48 += *(_DWORD *)(v43 + 4);
                if ( v44 )
                {
                  v49 = *(_BYTE *)(*(_DWORD *)(v9 + 4992) + v48);
                  v50 = *(_WORD *)(*(_DWORD *)(v9 + 4980) + 2 * v48);
                  if ( *(_BYTE *)(*(_DWORD *)(v9 + 4992) + v48) )
                  {
                    *(_DWORD *)(v44 + 76) += v49;
                    if ( !*(_BYTE *)(v44 + 80) )
                    {
                      v51 = *(_DWORD *)(a5 + 68);
                      v74 = (unsigned __int16)v49;
                      if ( v51 >= *(_DWORD *)(a5 + 72) )
                      {
                        sub_100943C0(v51 + 1, 0, a5 + 64, 1, 8u, 0);
                        v43 = a7;
                      }
                      v52 = *(_DWORD *)(a5 + 64) + 8 * *(_DWORD *)(a5 + 68);
                      if ( v52 )
                      {
                        *(_DWORD *)v52 = v50;
                        *(_DWORD *)(v52 + 4) = v74;
                      }
                      ++*(_DWORD *)(a5 + 68);
                      v44 = a5;
                    }
                  }
                  v79 = v47;
                }
                else
                {
                  ++*(_DWORD *)(*(_DWORD *)(v9 + 4952) + 4 * v48);
                  v79 = v47;
                }
              }
            }
            v45 = v63 + 1;
            v63 = v45;
          }
          while ( v45 < 3 );
          ++v90;
        }
        while ( v90 < 2 );
        v87 += 2;
      }
      while ( v87 < 4 );
      v15 = v70;
      v16 = v64 + 1;
      v17 = v65 + 50;
      v64 = v16;
      v65 += 50;
      if ( v16 >= v70 )
        break;
      v14 = v66;
    }
  }
  return 1;
}

//----- (10075740) --------------------------------------------------------
BOOL __thiscall sub_10075740(int this)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // eax@5
  int v4; // eax@9
  int v5; // eax@13
  int v6; // eax@17
  int v7; // eax@21
  int v8; // eax@25
  int v9; // eax@29
  int v10; // eax@33
  int v11; // eax@37
  BOOL result; // eax@41

  v1 = this;
  *(_DWORD *)this = &off_100A5010;
  v2 = *(_DWORD *)(this + 5288);
  if ( v2 )
  {
    if ( v2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
  }
  v3 = *(_DWORD *)(v1 + 5276);
  if ( v3 )
  {
    if ( v3 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
  }
  v4 = *(_DWORD *)(v1 + 5264);
  if ( v4 )
  {
    if ( v4 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
  }
  v5 = *(_DWORD *)(v1 + 5252);
  if ( v5 )
  {
    if ( v5 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
  }
  v6 = *(_DWORD *)(v1 + 5240);
  if ( v6 )
  {
    if ( v6 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v6, 0, 0, 1, dword_100AE9F4);
  }
  `eh vector destructor iterator'((void *)(v1 + 5048), 0xCu, 16, sub_10038C00);
  `eh vector destructor iterator'((void *)(v1 + 4976), 0x24u, 2, sub_1005C5A0);
  `eh vector destructor iterator'((void *)(v1 + 4952), 0xCu, 2, sub_10038C00);
  `eh vector destructor iterator'((void *)(v1 + 4880), 0x24u, 2, sub_1005C5A0);
  `eh vector destructor iterator'((void *)(v1 + 4856), 0xCu, 2, sub_10038C00);
  sub_1005C5A0((void *)(v1 + 4820));
  v7 = *(_DWORD *)(v1 + 4808);
  if ( v7 )
  {
    if ( v7 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v7, 0, 0, 1, dword_100AE9F4);
  }
  sub_1005FC60(v1 + 4272);
  v8 = *(_DWORD *)(v1 + 4260);
  if ( v8 )
  {
    if ( v8 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v8, 0, 0, 1, dword_100AE9F4);
  }
  v9 = *(_DWORD *)(v1 + 4172);
  if ( v9 )
  {
    if ( v9 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v9, 0, 0, 1, dword_100AE9F4);
  }
  `eh vector destructor iterator'((void *)(v1 + 4132), 0xCu, 3, sub_10038C00);
  `eh vector destructor iterator'((void *)(v1 + 4096), 0xCu, 3, sub_10038C00);
  v10 = *(_DWORD *)(v1 + 4084);
  if ( v10 )
  {
    if ( v10 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v10, 0, 0, 1, dword_100AE9F4);
  }
  v11 = *(_DWORD *)(v1 + 4068);
  if ( v11 )
  {
    if ( v11 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v11, 0, 0, 1, dword_100AE9F4);
  }
  `eh vector destructor iterator'((void *)(v1 + 100), 0x24u, 96, sub_100336C0);
  result = sub_100918E0(v1 + 4);
  *(_DWORD *)v1 = &off_100A4FF4;
  return result;
}
// 100A4FF4: using guessed type int (__stdcall *off_100A4FF4)(char);
// 100A5010: using guessed type int (__stdcall *off_100A5010)(char);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10075AA0) --------------------------------------------------------
int __stdcall sub_10075AA0(int a1)
{
  *(_DWORD *)a1 = &off_100A5010;
  sub_10091840(a1 + 4);
  *(_DWORD *)(a1 + 96) = 0;
  `eh vector constructor iterator'((void *)(a1 + 100), 0x24u, 96, (int)sub_100336F0, sub_100336C0);
  *(_DWORD *)(a1 + 4068) = 0;
  *(_DWORD *)(a1 + 4072) = 0;
  *(_DWORD *)(a1 + 4076) = 0;
  *(_DWORD *)(a1 + 4084) = 0;
  *(_DWORD *)(a1 + 4088) = 0;
  *(_DWORD *)(a1 + 4092) = 0;
  `eh vector constructor iterator'((void *)(a1 + 4096), 0xCu, 3, (int)unknown_libname_3, sub_10038C00);
  `eh vector constructor iterator'((void *)(a1 + 4132), 0xCu, 3, (int)unknown_libname_3, sub_10038C00);
  *(_DWORD *)(a1 + 4172) = 0;
  *(_DWORD *)(a1 + 4176) = 0;
  *(_DWORD *)(a1 + 4180) = 0;
  *(_DWORD *)(a1 + 4260) = 0;
  *(_DWORD *)(a1 + 4264) = 0;
  *(_DWORD *)(a1 + 4268) = 0;
  sub_10060150(a1 + 4272);
  *(_DWORD *)(a1 + 4808) = 0;
  *(_DWORD *)(a1 + 4812) = 0;
  *(_DWORD *)(a1 + 4816) = 0;
  *(_DWORD *)(a1 + 4820) = 0;
  *(_DWORD *)(a1 + 4824) = 0;
  *(_DWORD *)(a1 + 4828) = 0;
  *(_DWORD *)(a1 + 4832) = 0;
  *(_DWORD *)(a1 + 4836) = 0;
  *(_DWORD *)(a1 + 4840) = 0;
  *(_DWORD *)(a1 + 4844) = 0;
  *(_DWORD *)(a1 + 4848) = 0;
  *(_BYTE *)(a1 + 4852) = 0;
  `eh vector constructor iterator'((void *)(a1 + 4856), 0xCu, 2, (int)unknown_libname_2, sub_10038C00);
  `eh vector constructor iterator'((void *)(a1 + 4880), 0x24u, 2, (int)sub_1005C080, sub_1005C5A0);
  `eh vector constructor iterator'((void *)(a1 + 4952), 0xCu, 2, (int)unknown_libname_2, sub_10038C00);
  `eh vector constructor iterator'((void *)(a1 + 4976), 0x24u, 2, (int)sub_1005C080, sub_1005C5A0);
  `eh vector constructor iterator'((void *)(a1 + 5048), 0xCu, 16, (int)unknown_libname_3, sub_10038C00);
  *(_DWORD *)(a1 + 5240) = 0;
  *(_DWORD *)(a1 + 5244) = 0;
  *(_DWORD *)(a1 + 5248) = 0;
  *(_DWORD *)(a1 + 5252) = 0;
  *(_DWORD *)(a1 + 5256) = 0;
  *(_DWORD *)(a1 + 5260) = 0;
  *(_DWORD *)(a1 + 5264) = 0;
  *(_DWORD *)(a1 + 5268) = 0;
  *(_DWORD *)(a1 + 5272) = 0;
  *(_DWORD *)(a1 + 5276) = 0;
  *(_DWORD *)(a1 + 5280) = 0;
  *(_DWORD *)(a1 + 5284) = 0;
  *(_DWORD *)(a1 + 5288) = 0;
  *(_DWORD *)(a1 + 5292) = 0;
  *(_DWORD *)(a1 + 5296) = 0;
  return a1;
}
// 10036920: using guessed type int unknown_libname_2();
// 1003F6D0: using guessed type int unknown_libname_3();
// 1005C080: using guessed type int sub_1005C080();
// 100A5010: using guessed type int (__stdcall *off_100A5010)(char);

//----- (10075CE0) --------------------------------------------------------
char __stdcall sub_10075CE0(int a1)
{
  int v1; // ebx@1
  char v2; // di@1
  int v3; // esi@2
  int v4; // edx@5
  signed int v5; // ebp@5
  unsigned int v6; // edi@7
  int v7; // eax@10
  FILE *v8; // eax@12
  int v9; // ecx@19
  char result; // al@20
  int *v11; // esi@26
  unsigned int v12; // ebp@27
  int v13; // ecx@28
  int v14; // edx@28
  int v15; // eax@28
  int v16; // ecx@28
  int v17; // edx@28
  int v18; // ecx@28
  int v19; // eax@28
  int v20; // edx@28
  int v21; // ecx@28
  FILE *v22; // eax@30
  int v23; // eax@36
  _DWORD *v24; // ebp@36
  FILE *v25; // eax@38
  unsigned int v26; // esi@42
  unsigned int v27; // eax@42
  int v28; // ecx@46
  int v29; // eax@46
  int i; // ecx@46
  unsigned int v31; // ecx@51
  int v32; // eax@52
  int v33; // ebx@53
  signed int v34; // esi@54
  unsigned int v35; // edi@56
  int v36; // edx@58
  unsigned int v37; // ST30_4@58
  unsigned int v38; // edi@58
  unsigned int v39; // esi@58
  int v40; // edx@58
  int v41; // [sp+10h] [bp-448h]@3
  unsigned int v42; // [sp+10h] [bp-448h]@21
  int v43; // [sp+10h] [bp-448h]@51
  int v44; // [sp+14h] [bp-444h]@2
  unsigned int v45; // [sp+14h] [bp-444h]@25
  signed int v46; // [sp+14h] [bp-444h]@54
  unsigned int v47; // [sp+18h] [bp-440h]@1
  int v48; // [sp+18h] [bp-440h]@26
  int v49; // [sp+1Ch] [bp-43Ch]@10
  signed int v50; // [sp+20h] [bp-438h]@4
  signed int v51; // [sp+24h] [bp-434h]@2
  int v52; // [sp+28h] [bp-430h]@28
  int v53; // [sp+2Ch] [bp-42Ch]@28
  int v54; // [sp+30h] [bp-428h]@28
  int v55; // [sp+34h] [bp-424h]@28
  int v56; // [sp+38h] [bp-420h]@28
  int v57; // [sp+3Ch] [bp-41Ch]@28
  int v58; // [sp+40h] [bp-418h]@28
  int v59; // [sp+44h] [bp-414h]@28
  int v60; // [sp+48h] [bp-410h]@28
  char DstBuf; // [sp+4Ch] [bp-40Ch]@12
  CHAR OutputString; // [sp+24Ch] [bp-20Ch]@38
  int v63; // [sp+454h] [bp-4h]@28

  v1 = a1;
  v2 = 0;
  v47 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 96) + 8) )
  {
    v3 = a1 + 124;
    v51 = 32;
    v44 = a1 + 124;
    while ( 1 )
    {
      v41 = 0;
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 96) + 20) > 0u )
        break;
LABEL_18:
      v51 += 64;
      v3 = v44 + 576;
      ++v47;
      v44 += 576;
      if ( v47 >= *(_DWORD *)(*(_DWORD *)(a1 + 96) + 8) )
        goto LABEL_19;
    }
    v50 = v51;
    while ( 1 )
    {
      v4 = *(_DWORD *)(a1 + 96);
      v5 = 1;
      if ( *(_DWORD *)(v4 + 12) >> v41 >= 1u )
        v5 = *(_DWORD *)(v4 + 12) >> v41;
      v6 = *(_DWORD *)(v4 + 16) >> v41;
      if ( v6 < 1 )
        v6 = 1;
      if ( !*(_DWORD *)(v4 + v50) )
        break;
      v49 = *(_DWORD *)(v4 + v50);
      v7 = *(_DWORD *)v3;
      if ( *(_DWORD *)v3 )
      {
        if ( v7 & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v8 = _iob_func();
          fputs(&DstBuf, v8 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v7, 0, 0, 1, dword_100AE9F4);
        }
        *(_DWORD *)v3 = 0;
        *(_DWORD *)(v3 + 4) = 0;
        *(_DWORD *)(v3 + 8) = 0;
      }
      v50 += 4;
      *(_DWORD *)(v3 - 20) = v6;
      *(_DWORD *)(v3 - 4) = v49;
      *(_DWORD *)(v3 - 24) = v5;
      *(_DWORD *)(v3 - 16) = v5;
      *(_DWORD *)(v3 - 12) = v5 * v6;
      *(_DWORD *)(v3 - 8) = 15;
      v3 += 36;
      if ( (unsigned int)++v41 >= *(_DWORD *)(*(_DWORD *)(a1 + 96) + 20) )
      {
        v2 = 0;
        goto LABEL_18;
      }
    }
    result = 0;
  }
  else
  {
LABEL_19:
    v9 = *(_DWORD *)(a1 + 96);
    switch ( *(_DWORD *)(v9 + 24) )
    {
      case 3:
        v42 = 0;
        goto LABEL_25;
      case 4:
        v42 = 2;
        goto LABEL_25;
      case 5:
        v42 = 4;
        goto LABEL_25;
      case 6:
        v42 = 6;
LABEL_25:
        v45 = 0;
        if ( *(_DWORD *)(v9 + 8) > 0u )
        {
          v11 = (int *)(a1 + 132);
          v48 = a1 + 132;
          do
          {
            v12 = 0;
            if ( *(_DWORD *)(*(_DWORD *)(v1 + 96) + 20) > 0u )
            {
              do
              {
                v52 = 0;
                v53 = 0;
                v54 = 0;
                v55 = 0;
                v56 = 15;
                v57 = 0;
                v58 = 0;
                v59 = 0;
                v60 = 0;
                v63 = 0;
                sub_10033C70((int)&v52, (int)(v11 - 8));
                v63 = -1;
                sub_1007B4C0((int)&v52, v42);
                v13 = v53;
                v14 = v54;
                *(v11 - 8) = v52;
                v15 = v55;
                *(v11 - 7) = v13;
                v16 = v56;
                *(v11 - 6) = v14;
                v17 = v57;
                *(v11 - 5) = v15;
                *(v11 - 4) = v16;
                v18 = v58;
                *(v11 - 3) = v17;
                v19 = *(v11 - 2);
                v20 = v59;
                *(v11 - 2) = v18;
                v21 = v60;
                *(v11 - 1) = v20;
                *v11 = v21;
                if ( v19 )
                {
                  if ( v19 & 7 )
                  {
                    sprintf_s(
                      &DstBuf,
                      0x200u,
                      "%s(%u): Assertion failed: \"%s\"\n",
                      "crn_mem.cpp",
                      216,
                      "crnlib_free: bad ptr");
                    OutputDebugStringA(&DstBuf);
                    v22 = _iob_func();
                    fputs(&DstBuf, v22 + 2);
                    if ( IsDebuggerPresent() )
                      DebugBreak();
                  }
                  else
                  {
                    off_100AD9F4(v19, 0, 0, 1, dword_100AE9F4);
                  }
                }
                ++v12;
                v11 += 9;
                v2 = 0;
              }
              while ( v12 < *(_DWORD *)(*(_DWORD *)(a1 + 96) + 20) );
              v1 = a1;
            }
            v11 = (int *)(v48 + 576);
            ++v45;
            v48 += 576;
          }
          while ( v45 < *(_DWORD *)(*(_DWORD *)(v1 + 96) + 8) );
        }
        break;
      default:
        break;
    }
    v23 = *(_DWORD *)(v1 + 4068);
    v24 = (_DWORD *)(v1 + 4068);
    if ( v23 )
    {
      if ( v23 & 7 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_free: bad ptr");
        OutputDebugStringA(&OutputString);
        v25 = _iob_func();
        fputs(&OutputString, v25 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v23, 0, 0, 1, dword_100AE9F4);
      }
      *v24 = 0;
      *(_DWORD *)(v1 + 4072) = 0;
      *(_DWORD *)(v1 + 4076) = 0;
    }
    v26 = *(_DWORD *)(*(_DWORD *)(v1 + 96) + 20);
    v27 = *(_DWORD *)(v1 + 4072);
    if ( v26 != v27 )
    {
      if ( v26 >= v27 )
      {
        if ( v26 > *(_DWORD *)(v1 + 4076) )
          sub_100943C0(v26, (void (__cdecl *)(int, _DWORD, _DWORD))sub_1004AAB0, v1 + 4068, v26 == v27 + 1, 8u, v2);
        v28 = *(_DWORD *)(v1 + 4072);
        v29 = *v24 + 8 * v28;
        for ( i = v29 + 8 * (v26 - v28); v29 != i; v29 += 8 )
        {
          if ( v29 )
          {
            *(_DWORD *)v29 = 0;
            *(_DWORD *)(v29 + 4) = 0;
          }
        }
      }
      v24 = (_DWORD *)(v1 + 4068);
      *(_DWORD *)(v1 + 4072) = v26;
    }
    memset((void *)(v1 + 3556), 0, 0x200u);
    v31 = 0;
    v43 = 0;
    if ( *(_DWORD *)(*(_DWORD *)(v1 + 96) + 20) > 0u )
    {
      v32 = v1 + 3560;
      do
      {
        v33 = *(_DWORD *)(v1 + 96);
        if ( *(_DWORD *)(v33 + 12) >> v31 >= 1u )
        {
          v34 = *(_DWORD *)(v33 + 12) >> v31;
          v46 = *(_DWORD *)(v33 + 12) >> v31;
        }
        else
        {
          v34 = 1;
          v46 = 1;
        }
        v35 = *(_DWORD *)(v33 + 16) >> v31;
        if ( v35 < 1 )
          v35 = 1;
        v36 = *(_DWORD *)(v33 + 8);
        v37 = v35;
        *(_DWORD *)(*v24 + 8 * v31) = v43;
        v38 = (v35 + 7) >> 3;
        v39 = (unsigned int)(v34 + 7) >> 3;
        v40 = v39 * v38 * v36;
        *(_DWORD *)(*(_DWORD *)(a1 + 4068) + 8 * v31 + 4) += v40;
        v24 = (_DWORD *)(a1 + 4068);
        *(_DWORD *)(v32 + 4) = v39;
        *(_DWORD *)(v32 - 4) = v46;
        *(_DWORD *)(v32 + 20) = v43;
        *(_DWORD *)(v32 + 16) = v40;
        *(_DWORD *)v32 = v37;
        v1 = a1;
        *(_DWORD *)(v32 + 12) = v31;
        *(_DWORD *)(v32 + 8) = v38;
        *(_DWORD *)(v32 + 24) = 0;
        ++v31;
        v32 += 32;
        v43 += v40;
      }
      while ( v31 < *(_DWORD *)(*(_DWORD *)(a1 + 96) + 20) );
    }
    *(_DWORD *)(v1 + 4168) = v43;
    result = 1;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10076260) --------------------------------------------------------
char __usercall sub_10076260@<al>(int a1@<edi>)
{
  int v1; // eax@1
  char result; // al@2
  unsigned int v3; // ebp@3
  unsigned int *v4; // esi@3
  int v5; // eax@11
  int v6; // edx@11
  int v7; // ecx@11
  int v8; // eax@11
  int v9; // eax@11
  char v10; // [sp+8h] [bp-78h]@1
  int v11; // [sp+30h] [bp-50h]@1
  int v12; // [sp+34h] [bp-4Ch]@1
  int v13; // [sp+38h] [bp-48h]@1
  int v14; // [sp+3Ch] [bp-44h]@1
  int v15; // [sp+40h] [bp-40h]@1
  int v16; // [sp+44h] [bp-3Ch]@1
  int v17; // [sp+48h] [bp-38h]@1
  int v18; // [sp+4Ch] [bp-34h]@1
  int v19; // [sp+50h] [bp-30h]@1
  char v20; // [sp+58h] [bp-28h]@9
  int v21; // [sp+70h] [bp-10h]@11
  int v22; // [sp+7Ch] [bp-4h]@1

  v11 = 0;
  v12 = 0;
  v13 = 0;
  v22 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  LOBYTE(v22) = 2;
  sub_1005BFA0((int)&v10);
  v22 = 3;
  sub_1005C8A0((int)&v10, 0x100000u);
  v1 = sub_1005CCA0((int)&v10, (unsigned int *)(a1 + 4820), (int)&v10);
  if ( v1 )
  {
    v3 = 0;
    v4 = (unsigned int *)(a1 + 4976);
    do
    {
      if ( *(v4 - 24) )
      {
        v1 = sub_1005CCA0(v1, v4 - 24, (int)&v10);
        if ( !v1 )
        {
          v22 = -1;
          sub_10036930((int)&v10);
          return 0;
        }
      }
      if ( *v4 )
      {
        v1 = sub_1005CCA0((int)&v10, v4, (int)&v10);
        if ( !v1 )
        {
          v22 = -1;
          sub_10036930((int)&v10);
          return 0;
        }
      }
      ++v3;
      v4 += 9;
    }
    while ( v3 < 2 );
    sub_1005CC00((int)&v10);
    if ( !v20 )
      sub_1005D260((int)&v10);
    v5 = *(_DWORD *)(a1 + 5240);
    v6 = v12;
    *(_DWORD *)(a1 + 5240) = v11;
    v7 = v13;
    v11 = v5;
    v8 = *(_DWORD *)(a1 + 5244);
    *(_DWORD *)(a1 + 5244) = v6;
    v12 = v8;
    v9 = *(_DWORD *)(a1 + 5248);
    v21 = 0;
    *(_DWORD *)(a1 + 5248) = v7;
    v13 = v9;
    v22 = -1;
    sub_10036930((int)&v10);
    result = 1;
  }
  else
  {
    v22 = -1;
    sub_10036930((int)&v10);
    result = 0;
  }
  return result;
}

//----- (10076420) --------------------------------------------------------
char __stdcall sub_10076420(int a1, int a2, _DWORD *a3, int a4, int a5, int a6, int a7)
{
  int v7; // edi@1
  int v8; // ebx@1
  unsigned int v9; // esi@2
  unsigned int *v10; // ebp@4
  unsigned int *v11; // ebx@4
  unsigned int v12; // esi@5
  int v13; // eax@8
  signed int v15; // [sp+14h] [bp-84h]@4
  char v16; // [sp+18h] [bp-80h]@2
  int v17; // [sp+40h] [bp-58h]@2
  int v18; // [sp+44h] [bp-54h]@2
  int v19; // [sp+48h] [bp-50h]@2
  int v20; // [sp+4Ch] [bp-4Ch]@2
  int v21; // [sp+50h] [bp-48h]@2
  int v22; // [sp+54h] [bp-44h]@2
  int v23; // [sp+58h] [bp-40h]@2
  int v24; // [sp+5Ch] [bp-3Ch]@2
  int v25; // [sp+60h] [bp-38h]@2
  int v26; // [sp+64h] [bp-34h]@15
  char v27; // [sp+68h] [bp-30h]@2
  int v28; // [sp+80h] [bp-18h]@15
  int v29; // [sp+94h] [bp-4h]@2

  v7 = a1;
  v8 = 0;
  if ( !sub_10075010(0, a1, a2, 1, 0, a4, a5, a6, a7) )
    return 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v29 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  LOBYTE(v29) = 2;
  sub_1005BFA0((int)&v16);
  v29 = 3;
  sub_1005C8A0((int)&v16, 0x200000u);
  v9 = *(_DWORD *)(a1 + 4812);
  v27 = 1;
  if ( v9 )
    v8 = *(_DWORD *)(a1 + 4808);
  sub_1005C930(v9, a1 + 4820, v8, 0x10u);
  v10 = (unsigned int *)(a1 + 4976);
  v11 = (unsigned int *)(a1 + 4956);
  v15 = 2;
  do
  {
    v12 = *(v11 - 24);
    if ( v12 )
    {
      sub_1005C930(v12, (int)(v10 - 24), *(v11 - 25), 0x10u);
      sub_1005CCA0((int)&v16, v10 - 24, (int)&v16);
      v7 = a1;
    }
    if ( *v11 )
    {
      LOBYTE(v13) = sub_1005C930(*v11, (int)v10, *(v11 - 1), 0x10u);
      sub_1005CCA0(v13, v10, (int)&v16);
    }
    v11 += 3;
    v10 += 9;
    --v15;
  }
  while ( v15 );
  if ( !sub_10075010(0, v7, a2, 0, (int)&v16, a4, a5, a6, a7) )
  {
    v29 = -1;
    sub_10036930((int)&v16);
    return 0;
  }
  sub_1005CC00((int)&v16);
  if ( !v27 )
    sub_1005D260((int)&v16);
  v28 = 0;
  *a3 = v26;
  v29 = -1;
  sub_10036930((int)&v16);
  return 1;
}

//----- (10076610) --------------------------------------------------------
char __thiscall sub_10076610(_DWORD *this, int a2, int a3, int a4, int a5, int a6)
{
  unsigned int v6; // esi@1
  _DWORD *v7; // ebx@1
  unsigned int v8; // esi@1
  int v9; // edi@2
  int v10; // ecx@3
  char *v11; // eax@3
  int v12; // esi@4
  int v13; // ebx@4
  unsigned int v14; // ecx@4
  void *v15; // edi@9
  int v16; // edx@9
  signed int v17; // ebp@9
  unsigned int v18; // ebx@10
  int v19; // ecx@11
  int v20; // esi@12
  unsigned int v21; // eax@14
  int v22; // ecx@17
  int v23; // eax@17
  int v24; // ecx@17
  unsigned int v25; // ecx@19
  unsigned int v26; // eax@20
  FILE *v27; // eax@35
  FILE *v28; // eax@40
  FILE *v29; // eax@45
  char result; // al@46
  unsigned int v31; // ebp@50
  unsigned int v32; // edx@51
  int v33; // eax@52
  int v34; // ecx@52
  int v35; // esi@52
  int v36; // eax@56
  int v37; // ecx@57
  int v38; // eax@62
  unsigned int v39; // eax@62
  int v40; // edx@62
  FILE *v41; // eax@64
  FILE *v42; // eax@69
  FILE *v43; // eax@74
  void *v44; // [sp+14h] [bp-2ECh]@4
  unsigned int v45; // [sp+18h] [bp-2E8h]@4
  unsigned int v46; // [sp+1Ch] [bp-2E4h]@4
  unsigned int v47; // [sp+20h] [bp-2E0h]@6
  int v48; // [sp+24h] [bp-2DCh]@54
  int v49; // [sp+28h] [bp-2D8h]@4
  unsigned int v50; // [sp+2Ch] [bp-2D4h]@4
  int v51; // [sp+30h] [bp-2D0h]@4
  void *v52; // [sp+34h] [bp-2CCh]@1
  int v53; // [sp+38h] [bp-2C8h]@1
  int v54; // [sp+3Ch] [bp-2C4h]@1
  int v55; // [sp+40h] [bp-2C0h]@10
  int v56; // [sp+44h] [bp-2BCh]@8
  int v57; // [sp+48h] [bp-2B8h]@8
  int v58; // [sp+4Ch] [bp-2B4h]@8
  int v59; // [sp+50h] [bp-2B0h]@8
  char v60; // [sp+54h] [bp-2ACh]@22
  int v61; // [sp+70h] [bp-290h]@22
  int v62; // [sp+74h] [bp-28Ch]@22
  int v63; // [sp+78h] [bp-288h]@22
  int v64; // [sp+7Ch] [bp-284h]@22
  unsigned int v65; // [sp+80h] [bp-280h]@22
  int v66; // [sp+84h] [bp-27Ch]@22
  int v67; // [sp+88h] [bp-278h]@22
  unsigned int v68; // [sp+8Ch] [bp-274h]@22
  int v69; // [sp+90h] [bp-270h]@22
  int v70; // [sp+94h] [bp-26Ch]@22
  unsigned int v71; // [sp+98h] [bp-268h]@22
  unsigned int v72; // [sp+9Ch] [bp-264h]@22
  int v73; // [sp+A0h] [bp-260h]@22
  char v74; // [sp+A4h] [bp-25Ch]@53
  int v75; // [sp+A8h] [bp-258h]@32
  int v76; // [sp+ACh] [bp-254h]@32
  int v77; // [sp+B0h] [bp-250h]@32
  int v78; // [sp+B4h] [bp-24Ch]@32
  int v79; // [sp+BCh] [bp-244h]@22
  int v80; // [sp+C8h] [bp-238h]@22
  int v81; // [sp+CCh] [bp-234h]@22
  int v82; // [sp+D0h] [bp-230h]@22
  int v83; // [sp+D4h] [bp-22Ch]@22
  int v84; // [sp+D8h] [bp-228h]@22
  int v85; // [sp+DCh] [bp-224h]@22
  int v86; // [sp+E0h] [bp-220h]@22
  int v87; // [sp+E4h] [bp-21Ch]@22
  char v88; // [sp+E8h] [bp-218h]@22
  char DstBuf; // [sp+ECh] [bp-214h]@35
  int v90; // [sp+2FCh] [bp-4h]@1

  v6 = *(_DWORD *)(a4 + 4);
  v7 = this;
  v52 = 0;
  v53 = 0;
  v54 = 0;
  sub_10036C30((int)&v52, v6);
  v8 = 0;
  v90 = 0;
  if ( *(_DWORD *)(a4 + 4) )
  {
    v9 = 0;
    do
    {
      v10 = v9 + *(_DWORD *)a4;
      v11 = (char *)v52 + 16 * *(_DWORD *)(*v7 + 4 * v8++);
      *(_DWORD *)v11 = *(_DWORD *)(*(_DWORD *)a4 + v9);
      *((_DWORD *)v11 + 1) = *(_DWORD *)(v10 + 4);
      *((_DWORD *)v11 + 2) = *(_DWORD *)(v10 + 8);
      *((_DWORD *)v11 + 3) = *(_DWORD *)(v10 + 12);
      v9 += 16;
    }
    while ( v8 < *(_DWORD *)(a4 + 4) );
  }
  v44 = 0;
  v45 = 0;
  v46 = 0;
  LOBYTE(v90) = 1;
  sub_10036310((int)&v44, 8 * *(_DWORD *)(a4 + 4));
  v12 = (2 * a5 + 1) * (2 * a5 + 1);
  v13 = 0;
  v14 = 0;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  if ( v12 )
  {
    if ( v12 )
    {
      LOBYTE(v47) = v12 == 1;
      sub_100943C0((2 * a5 + 1) * (2 * a5 + 1), 0, (int)&v49, v12 == 1, 4u, 0);
      v13 = v49;
      v14 = v50;
    }
    memset((void *)(v13 + 4 * v14), 0, 4 * (v12 - v14));
    v50 = (2 * a5 + 1) * (2 * a5 + 1);
  }
  LOBYTE(v90) = 2;
  v56 = 0;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  v47 = 0;
  if ( *(_DWORD *)(a4 + 4) > 0u )
  {
    v15 = v52;
    v16 = a6;
    v17 = (char *)&v56 - (_BYTE *)v52;
    do
    {
      v18 = 0;
      v55 = 0;
      do
      {
        v19 = *(_BYTE *)(*((_BYTE *)v15 + v18 + v17) + v16);
        if ( v18 & 1 )
        {
          v20 = v55 + (a5 + *(_BYTE *)(*((_BYTE *)v15 + v18) + v16) - v19) * (2 * a5 + 1);
          if ( v45 >= v46 )
          {
            sub_100943C0(v45 + 1, 0, (int)&v44, 1, 4u, 0);
            v16 = a6;
          }
          v21 = v45;
          *((_DWORD *)v44 + v45) = v20;
          v45 = v21 + 1;
          ++*(_DWORD *)(v49 + 4 * v20);
        }
        else
        {
          v55 = a5 + *(_BYTE *)(*((_BYTE *)v15 + v18) + v16) - v19;
        }
        ++v18;
      }
      while ( v18 < 0x10 );
      v22 = *((_DWORD *)v15 + 1);
      v56 = *(_DWORD *)v15;
      v23 = *((_DWORD *)v15 + 2);
      v57 = v22;
      v24 = *((_DWORD *)v15 + 3);
      v58 = v23;
      v59 = v24;
      v15 = (char *)v15 + 16;
      v17 -= 16;
      ++v47;
    }
    while ( v47 < *(_DWORD *)(a4 + 4) );
    v13 = v49;
  }
  v25 = *(_DWORD *)(a3 + 4);
  if ( v25 > 1 )
  {
    v26 = 1;
    do
      ++v26;
    while ( v26 < v25 );
  }
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v84 = 0;
  v85 = 0;
  v86 = 0;
  v87 = 0;
  v88 = 0;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  LOBYTE(v90) = 6;
  sub_1005BFA0((int)&v60);
  LOBYTE(v90) = 7;
  v79 = 1;
  v63 = 0;
  v73 = 0;
  v61 = 0;
  v62 = 32;
  if ( v65 )
  {
    if ( v65 <= 0 )
      memset((void *)(v64 + v65), 0, -v65);
    v65 = 0;
  }
  sub_10032F10((int)&v64, 0x100000u);
  if ( v71 )
    v71 = 0;
  if ( v68 )
  {
    if ( v68 <= 0 )
      memset((void *)(v67 + v68), 0, -v68);
    v68 = 0;
  }
  v75 = 0;
  v76 = 0;
  v77 = -1;
  v78 = 0;
  if ( sub_1005C930(v50, (int)&v80, v50 != 0 ? v13 : 0, 0xFu)
    && sub_1005CCA0((int)&v60, (unsigned int *)&v80, (int)&v60) )
  {
    v31 = 0;
    if ( v45 > 0 )
    {
      v32 = v71;
      do
      {
        v33 = *((_DWORD *)v44 + v31);
        v34 = *(_BYTE *)(v84 + v33);
        v35 = *(_WORD *)(v81 + 2 * v33);
        if ( *(_BYTE *)(v84 + v33) )
        {
          v73 += v34;
          if ( !v74 )
          {
            v48 = (unsigned __int16)v34;
            if ( v32 >= v72 )
            {
              sub_100943C0(v32 + 1, 0, (int)&v70, 1, 8u, 0);
              v32 = v71;
            }
            v36 = v70 + 8 * v32;
            if ( v36 )
            {
              v37 = v48;
              *(_DWORD *)v36 = v35;
              *(_DWORD *)(v36 + 4) = v37;
              v32 = v71;
            }
            v71 = ++v32;
          }
        }
        ++v31;
      }
      while ( v31 < v45 );
    }
    sub_1005CC00((int)&v60);
    if ( !v74 )
      sub_1005D260((int)&v60);
    v38 = *(_DWORD *)a2;
    *(_DWORD *)a2 = v64;
    v64 = v38;
    v39 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = v65;
    v40 = v66;
    v65 = v39;
    v66 = *(_DWORD *)(a2 + 8);
    v79 = 0;
    *(_DWORD *)(a2 + 8) = v40;
    LOBYTE(v90) = 3;
    sub_10036930((int)&v60);
    LOBYTE(v90) = 2;
    sub_1005C5A0(&v80);
    LOBYTE(v90) = 1;
    if ( v13 )
    {
      if ( v13 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v41 = _iob_func();
        fputs(&DstBuf, v41 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v13, 0, 0, 1, dword_100AE9F4);
      }
    }
    LOBYTE(v90) = 0;
    if ( v44 )
    {
      if ( (unsigned __int8)v44 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v42 = _iob_func();
        fputs(&DstBuf, v42 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v44, 0, 0, 1, dword_100AE9F4);
      }
    }
    v90 = -1;
    if ( v52 )
    {
      if ( (unsigned __int8)v52 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v43 = _iob_func();
        fputs(&DstBuf, v43 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v52, 0, 0, 1, dword_100AE9F4);
      }
    }
    result = 1;
  }
  else
  {
    LOBYTE(v90) = 3;
    sub_10036930((int)&v60);
    LOBYTE(v90) = 2;
    sub_1005C5A0(&v80);
    LOBYTE(v90) = 1;
    if ( v13 )
    {
      if ( v13 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v27 = _iob_func();
        fputs(&DstBuf, v27 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v13, 0, 0, 1, dword_100AE9F4);
      }
    }
    LOBYTE(v90) = 0;
    if ( v44 )
    {
      if ( (unsigned __int8)v44 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v28 = _iob_func();
        fputs(&DstBuf, v28 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v44, 0, 0, 1, dword_100AE9F4);
      }
    }
    v90 = -1;
    if ( v52 )
    {
      if ( (unsigned __int8)v52 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v29 = _iob_func();
        fputs(&DstBuf, v29 + 2);
        if ( IsDebuggerPresent() )
        {
          DebugBreak();
          return 0;
        }
      }
      else
      {
        off_100AD9F4(v52, 0, 0, 1, dword_100AE9F4);
      }
    }
    result = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10076E80) --------------------------------------------------------
char __thiscall sub_10076E80(int this, int a2, _DWORD *a3, int a4)
{
  int v4; // ebx@1
  unsigned int v5; // eax@1
  int v6; // ecx@2
  int v7; // edx@2
  unsigned int v8; // ebp@3
  unsigned int v9; // ecx@3
  int v10; // eax@4
  unsigned int v11; // esi@4
  int v12; // edi@5
  unsigned int v13; // ecx@9
  unsigned int v14; // eax@10
  int v15; // eax@22
  void (__cdecl *v16)(const char *, FILE *); // ebp@23
  FILE *(__cdecl *v17)(); // ebx@23
  FILE *v18; // eax@25
  FILE *v19; // eax@30
  FILE *v20; // eax@36
  char result; // al@37
  FILE *v22; // eax@43
  FILE *v23; // eax@48
  unsigned int v24; // ebx@55
  unsigned int v25; // edx@56
  int v26; // eax@57
  int v27; // ecx@57
  int v28; // esi@57
  int v29; // eax@61
  int v30; // ecx@62
  int v31; // eax@67
  unsigned int v32; // eax@67
  int v33; // edx@67
  FILE *v34; // eax@69
  FILE *v35; // eax@74
  FILE *v36; // eax@79
  void *v37; // [sp+14h] [bp-6E4h]@3
  unsigned int v38; // [sp+18h] [bp-6E0h]@3
  unsigned int v39; // [sp+1Ch] [bp-6DCh]@3
  int v40; // [sp+20h] [bp-6D8h]@3
  int v41; // [sp+24h] [bp-6D4h]@3
  void *v42; // [sp+28h] [bp-6D0h]@3
  int v43; // [sp+2Ch] [bp-6CCh]@3
  int v44; // [sp+30h] [bp-6C8h]@3
  unsigned int i; // [sp+34h] [bp-6C4h]@3
  int v46; // [sp+38h] [bp-6C0h]@4
  int v47; // [sp+3Ch] [bp-6BCh]@4
  void *v48; // [sp+40h] [bp-6B8h]@1
  char v49; // [sp+4Ch] [bp-6ACh]@12
  int v50; // [sp+68h] [bp-690h]@12
  int v51; // [sp+6Ch] [bp-68Ch]@12
  int v52; // [sp+70h] [bp-688h]@12
  int v53; // [sp+74h] [bp-684h]@12
  unsigned int v54; // [sp+78h] [bp-680h]@12
  int v55; // [sp+7Ch] [bp-67Ch]@12
  int v56; // [sp+80h] [bp-678h]@12
  unsigned int v57; // [sp+84h] [bp-674h]@12
  int v58; // [sp+88h] [bp-670h]@12
  int v59; // [sp+8Ch] [bp-66Ch]@12
  unsigned int v60; // [sp+90h] [bp-668h]@12
  unsigned int v61; // [sp+94h] [bp-664h]@12
  int v62; // [sp+98h] [bp-660h]@12
  char v63; // [sp+9Ch] [bp-65Ch]@58
  int v64; // [sp+A0h] [bp-658h]@22
  int v65; // [sp+A4h] [bp-654h]@22
  int v66; // [sp+A8h] [bp-650h]@22
  int v67; // [sp+ACh] [bp-64Ch]@22
  int v68; // [sp+B4h] [bp-644h]@12
  int v69; // [sp+C0h] [bp-638h]@12
  int v70; // [sp+C4h] [bp-634h]@12
  int v71; // [sp+C8h] [bp-630h]@12
  int v72; // [sp+CCh] [bp-62Ch]@12
  int v73; // [sp+D0h] [bp-628h]@12
  int v74; // [sp+D4h] [bp-624h]@12
  int v75; // [sp+D8h] [bp-620h]@12
  int v76; // [sp+DCh] [bp-61Ch]@12
  char v77; // [sp+E0h] [bp-618h]@12
  CHAR OutputString; // [sp+E4h] [bp-614h]@30
  char DstBuf; // [sp+2E4h] [bp-414h]@25
  CHAR v80; // [sp+4E4h] [bp-214h]@79
  int v81; // [sp+6F4h] [bp-4h]@1

  v4 = this;
  sub_10036A10(*(_DWORD *)(this + 4644), (int)&v48);
  v81 = 0;
  v5 = 0;
  if ( *(_DWORD *)(v4 + 4644) )
  {
    do
    {
      v6 = *(_DWORD *)(*(_DWORD *)(v4 + 4640) + 4 * v5);
      v7 = *(_DWORD *)(*a3 + 4 * v5++);
      *((_DWORD *)v48 + v7) = v6;
    }
    while ( v5 < *(_DWORD *)(v4 + 4644) );
  }
  v42 = 0;
  v43 = 0;
  v44 = 0;
  LOBYTE(v81) = 1;
  sub_100943C0(0x100u, 0, (int)&v42, 0, 4u, 0);
  memset((char *)v42 + 4 * v43, 0, 4 * (256 - v43));
  v43 = 256;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  LOBYTE(v81) = 2;
  sub_10036310((int)&v37, 6 * *(_DWORD *)(v4 + 4644));
  v8 = v38;
  v9 = 0;
  v40 = 0;
  v41 = 0;
  for ( i = 0; v9 < *(_DWORD *)(v4 + 4644); i = v9 )
  {
    v10 = *((_DWORD *)v48 + v9);
    v46 = (unsigned __int8)*((_DWORD *)v48 + v9);
    v47 = (unsigned __int16)v10 >> 8;
    v11 = 0;
    do
    {
      v12 = (*(int *)((char *)&v46 + v11 * 4) - *(int *)((char *)&v40 + v11 * 4)) & 0xFF;
      ++*((_DWORD *)v42 + v12);
      if ( v8 >= v39 )
      {
        sub_100943C0(v8 + 1, 0, (int)&v37, 1, 4u, 0);
        v8 = v38;
      }
      *((_DWORD *)v37 + v8++) = v12;
      ++v11;
      v38 = v8;
    }
    while ( v11 < 2 );
    v40 = v46;
    v9 = i + 1;
    v41 = v47;
  }
  v13 = *(_DWORD *)(a4 + 4);
  if ( v13 > 1 )
  {
    v14 = 1;
    do
      ++v14;
    while ( v14 < v13 );
  }
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v53 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  v60 = 0;
  v61 = 0;
  LOBYTE(v81) = 6;
  sub_1005BFA0((int)&v49);
  LOBYTE(v81) = 7;
  v68 = 1;
  v52 = 0;
  v62 = 0;
  v50 = 0;
  v51 = 32;
  if ( v54 )
  {
    if ( v54 <= 0 )
      memset((void *)(v53 + v54), 0, -v54);
    v54 = 0;
  }
  sub_10032F10((int)&v53, 0x100000u);
  if ( v60 )
    v60 = 0;
  if ( v57 )
  {
    if ( v57 <= 0 )
      memset((void *)(v56 + v57), 0, -v57);
    v57 = 0;
  }
  v64 = 0;
  v65 = 0;
  v66 = -1;
  v67 = 0;
  LOBYTE(v15) = sub_1005C930(0x100u, (int)&v69, (int)v42, 0xFu);
  if ( !(_BYTE)v15 )
  {
    LOBYTE(v81) = 3;
    sub_10036930((int)&v49);
    LOBYTE(v81) = 2;
    sub_1005C5A0(&v69);
    LOBYTE(v81) = 1;
    v16 = (void (__cdecl *)(const char *, FILE *))fputs;
    v17 = _iob_func;
    if ( v37 )
    {
      if ( (unsigned __int8)v37 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v18 = _iob_func();
        fputs(&DstBuf, v18 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v37, 0, 0, 1, dword_100AE9F4);
      }
    }
    LOBYTE(v81) = 0;
    if ( v42 )
    {
      if ( (unsigned __int8)v42 & 7 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_free: bad ptr");
        OutputDebugStringA(&OutputString);
        v19 = _iob_func();
        fputs(&OutputString, v19 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v42, 0, 0, 1, dword_100AE9F4);
      }
    }
    v81 = -1;
    if ( v48 )
    {
      if ( (unsigned __int8)v48 & 7 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_free: bad ptr");
        OutputDebugStringA(&OutputString);
        goto LABEL_36;
      }
      off_100AD9F4(v48, 0, 0, 1, dword_100AE9F4);
    }
    return 0;
  }
  if ( sub_1005CCA0(v15, (unsigned int *)&v69, (int)&v49) )
  {
    v24 = 0;
    if ( v8 > 0 )
    {
      v25 = v60;
      do
      {
        v26 = *((_DWORD *)v37 + v24);
        v27 = *(_BYTE *)(v73 + v26);
        v28 = *(_WORD *)(v70 + 2 * v26);
        if ( *(_BYTE *)(v73 + v26) )
        {
          v62 += v27;
          if ( !v63 )
          {
            v41 = (unsigned __int16)v27;
            if ( v25 >= v61 )
            {
              sub_100943C0(v25 + 1, 0, (int)&v59, 1, 8u, 0);
              v25 = v60;
            }
            v29 = v59 + 8 * v25;
            if ( v29 )
            {
              v30 = v41;
              *(_DWORD *)v29 = v28;
              *(_DWORD *)(v29 + 4) = v30;
              v25 = v60;
            }
            v60 = ++v25;
          }
        }
        ++v24;
      }
      while ( v24 < v8 );
    }
    sub_1005CC00((int)&v49);
    if ( !v63 )
      sub_1005D260((int)&v49);
    v31 = *(_DWORD *)a2;
    *(_DWORD *)a2 = v53;
    v53 = v31;
    v32 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = v54;
    v33 = v55;
    v54 = v32;
    v55 = *(_DWORD *)(a2 + 8);
    v68 = 0;
    *(_DWORD *)(a2 + 8) = v33;
    LOBYTE(v81) = 3;
    sub_10036930((int)&v49);
    LOBYTE(v81) = 2;
    sub_1005C5A0(&v69);
    LOBYTE(v81) = 1;
    if ( v37 )
    {
      if ( (unsigned __int8)v37 & 7 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_free: bad ptr");
        OutputDebugStringA(&OutputString);
        v34 = _iob_func();
        fputs(&OutputString, v34 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v37, 0, 0, 1, dword_100AE9F4);
      }
    }
    LOBYTE(v81) = 0;
    if ( v42 )
    {
      if ( (unsigned __int8)v42 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v35 = _iob_func();
        fputs(&DstBuf, v35 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v42, 0, 0, 1, dword_100AE9F4);
      }
    }
    v81 = -1;
    if ( v48 )
    {
      if ( (unsigned __int8)v48 & 7 )
      {
        sprintf_s(&v80, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&v80);
        v36 = _iob_func();
        fputs(&v80, v36 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v48, 0, 0, 1, dword_100AE9F4);
      }
    }
    result = 1;
  }
  else
  {
    LOBYTE(v81) = 3;
    sub_10036930((int)&v49);
    LOBYTE(v81) = 2;
    sub_1005C5A0(&v69);
    LOBYTE(v81) = 1;
    v16 = (void (__cdecl *)(const char *, FILE *))fputs;
    v17 = _iob_func;
    if ( v37 )
    {
      if ( (unsigned __int8)v37 & 7 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_free: bad ptr");
        OutputDebugStringA(&OutputString);
        v22 = _iob_func();
        fputs(&OutputString, v22 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v37, 0, 0, 1, dword_100AE9F4);
      }
    }
    LOBYTE(v81) = 0;
    if ( v42 )
    {
      if ( (unsigned __int8)v42 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v23 = _iob_func();
        fputs(&DstBuf, v23 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v42, 0, 0, 1, dword_100AE9F4);
      }
    }
    v81 = -1;
    if ( !v48 )
      return 0;
    if ( (unsigned __int8)v48 & 7 )
    {
      sprintf_s(&OutputString, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&OutputString);
LABEL_36:
      v20 = v17();
      v16(&OutputString, v20 + 2);
      if ( IsDebuggerPresent() )
      {
        DebugBreak();
        return 0;
      }
      return 0;
    }
    off_100AD9F4(v48, 0, 0, 1, dword_100AE9F4);
    result = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10077800) --------------------------------------------------------
char __thiscall sub_10077800(_DWORD *this, int a2, int a3, int a4)
{
  _DWORD *v4; // ebx@1
  unsigned int v5; // eax@1
  int v6; // ecx@2
  int v7; // edx@2
  int v8; // eax@3
  int v9; // ecx@9
  unsigned int v10; // ebp@15
  unsigned int v11; // eax@17
  char v12; // bl@17
  unsigned int v13; // ecx@17
  int v14; // ebx@17
  unsigned int v15; // edx@17
  int *v16; // ebx@17
  int v17; // ebp@17
  unsigned int v18; // edi@18
  int v19; // esi@19
  int v20; // eax@19
  unsigned int v21; // ecx@24
  _DWORD *v22; // ebx@24
  unsigned int v23; // eax@25
  unsigned int *v24; // edi@37
  unsigned int *v25; // ebp@37
  int v26; // eax@39
  unsigned int v27; // esi@44
  unsigned int v28; // edi@45
  int v29; // ecx@46
  int v30; // eax@46
  int v31; // edx@46
  int v32; // ebp@46
  int v33; // eax@50
  int v34; // ecx@51
  int v35; // eax@56
  unsigned int v36; // eax@56
  int v37; // edx@56
  FILE *v38; // eax@58
  FILE *v39; // eax@62
  FILE *v40; // ST14_4@67
  FILE *v42; // eax@74
  FILE *v43; // ST14_4@79
  FILE *v44; // eax@84
  signed int v45; // [sp+14h] [bp-344h]@17
  unsigned int v46; // [sp+14h] [bp-344h]@37
  int v47; // [sp+18h] [bp-340h]@15
  int v48; // [sp+1Ch] [bp-33Ch]@15
  char v49; // [sp+20h] [bp-338h]@17
  char v50; // [sp+21h] [bp-337h]@17
  char v51; // [sp+22h] [bp-336h]@17
  char v52; // [sp+23h] [bp-335h]@16
  int v53; // [sp+24h] [bp-334h]@16
  void *v54; // [sp+28h] [bp-330h]@15
  unsigned int v55; // [sp+2Ch] [bp-32Ch]@15
  unsigned int v56; // [sp+30h] [bp-328h]@15
  unsigned int v57; // [sp+34h] [bp-324h]@15
  int v58; // [sp+38h] [bp-320h]@3
  unsigned int v59; // [sp+3Ch] [bp-31Ch]@3
  unsigned int v60; // [sp+40h] [bp-318h]@5
  int v61; // [sp+44h] [bp-314h]@12
  unsigned int v62; // [sp+48h] [bp-310h]@9
  unsigned int v63; // [sp+4Ch] [bp-30Ch]@11
  unsigned int v64; // [sp+50h] [bp-308h]@17
  void *v65; // [sp+54h] [bp-304h]@1
  unsigned int v66; // [sp+60h] [bp-2F8h]@17
  int v67; // [sp+64h] [bp-2F4h]@17
  unsigned int v68; // [sp+68h] [bp-2F0h]@17
  unsigned int v69; // [sp+6Ch] [bp-2ECh]@17
  unsigned int v70; // [sp+70h] [bp-2E8h]@17
  char v71; // [sp+74h] [bp-2E4h]@27
  int v72; // [sp+90h] [bp-2C8h]@27
  int v73; // [sp+94h] [bp-2C4h]@27
  int v74; // [sp+98h] [bp-2C0h]@27
  int v75; // [sp+9Ch] [bp-2BCh]@27
  unsigned int v76; // [sp+A0h] [bp-2B8h]@27
  int v77; // [sp+A4h] [bp-2B4h]@27
  int v78; // [sp+A8h] [bp-2B0h]@27
  unsigned int v79; // [sp+ACh] [bp-2ACh]@27
  int v80; // [sp+B0h] [bp-2A8h]@27
  int v81; // [sp+B4h] [bp-2A4h]@27
  unsigned int v82; // [sp+B8h] [bp-2A0h]@27
  unsigned int v83; // [sp+BCh] [bp-29Ch]@27
  int v84; // [sp+C0h] [bp-298h]@27
  char v85; // [sp+C4h] [bp-294h]@47
  int v86; // [sp+C8h] [bp-290h]@37
  int v87; // [sp+CCh] [bp-28Ch]@37
  int v88; // [sp+D0h] [bp-288h]@37
  int v89; // [sp+D4h] [bp-284h]@37
  int v90; // [sp+DCh] [bp-27Ch]@27
  int v91; // [sp+E4h] [bp-274h]@3
  int v92; // [sp+E8h] [bp-270h]@3
  int v93; // [sp+ECh] [bp-26Ch]@3
  int v94; // [sp+F0h] [bp-268h]@3
  int v95; // [sp+F4h] [bp-264h]@3
  int v96; // [sp+F8h] [bp-260h]@3
  char v97[16]; // [sp+FCh] [bp-25Ch]@27
  int v98[14]; // [sp+10Ch] [bp-24Ch]@46
  char DstBuf; // [sp+144h] [bp-214h]@58
  int v100; // [sp+354h] [bp-4h]@1

  v4 = this;
  sub_10036A10(*(_DWORD *)(a2 + 4632), (int)&v65);
  v100 = 0;
  v5 = 0;
  if ( *(_DWORD *)(a2 + 4632) )
  {
    do
    {
      v6 = *(_DWORD *)(*(_DWORD *)(a2 + 4628) + 4 * v5);
      v7 = *(_DWORD *)(*v4 + 4 * v5++);
      *((_DWORD *)v65 + v7) = v6;
    }
    while ( v5 < *(_DWORD *)(a2 + 4632) );
  }
  v91 = 31;
  v93 = 31;
  v94 = 31;
  v96 = 31;
  v92 = 63;
  v95 = 63;
  `eh vector constructor iterator'(&v58, 0xCu, 2, (int)unknown_libname_2, sub_10038C00);
  LOBYTE(v100) = 1;
  v8 = v59;
  if ( v59 != 32 )
  {
    if ( v59 <= 0x20 )
    {
      if ( v60 < 0x20 )
      {
        sub_100943C0(0x20u, 0, (int)&v58, v59 == 31, 4u, 0);
        v8 = v59;
      }
      memset((void *)(v58 + 4 * v8), 0, 4 * (32 - v8));
    }
    v59 = 32;
  }
  v9 = v62;
  if ( v62 != 64 )
  {
    if ( v62 <= 0x40 )
    {
      if ( v63 < 0x40 )
      {
        sub_100943C0(0x40u, 0, (int)&v61, v62 == 63, 4u, 0);
        v9 = v62;
      }
      memset((void *)(v61 + 4 * v9), 0, 4 * (64 - v9));
    }
    v62 = 64;
  }
  v54 = 0;
  v55 = 0;
  v56 = 0;
  LOBYTE(v100) = 2;
  sub_10036310((int)&v54, 6 * *(_DWORD *)(a2 + 4632));
  v10 = *(_DWORD *)(a2 + 4632);
  v47 = 0;
  v48 = 0;
  v57 = 0;
  if ( v10 > 0 )
  {
    v52 = -1;
    BYTE3(v53) = -1;
    do
    {
      v11 = (unsigned __int16)*((_DWORD *)v65 + v57);
      v12 = *((_DWORD *)v65 + v57);
      v13 = *((_DWORD *)v65 + v57) >> 16;
      v64 = v11 >> 11;
      v49 = v11 >> 11;
      v69 = (v11 >> 5) & 0x3F;
      v50 = (v11 >> 5) & 0x3F;
      v14 = v12 & 0x1F;
      v67 = v14;
      v51 = v14;
      v68 = v13 & 0x1F;
      BYTE2(v53) = v13 & 0x1F;
      v15 = v55;
      v66 = (v13 >> 5) & 0x3F;
      v70 = v13 >> 11;
      LOBYTE(v53) = v13 >> 11;
      BYTE1(v53) = (v13 >> 5) & 0x3F;
      v16 = &v91;
      v17 = 0;
      v45 = 2;
      do
      {
        v18 = 0;
        do
        {
          v19 = ((unsigned __int8)*(&v49 + v18 + v17) - *((_BYTE *)&v47 + v18 + v17)) & *v16;
          v20 = *(&v58 + 3 * (v18 == 1));
          ++*(_DWORD *)(v20 + 4 * v19);
          if ( v15 >= v56 )
          {
            sub_100943C0(v55 + 1, 0, (int)&v54, 1, 4u, 0);
            v15 = v55;
          }
          *((_DWORD *)v54 + v15++) = v19;
          ++v18;
          ++v16;
          v55 = v15;
        }
        while ( v18 < 3 );
        v17 += 4;
        --v45;
      }
      while ( v45 );
      BYTE2(v47) = v67;
      LOBYTE(v47) = v64;
      BYTE2(v48) = v68;
      BYTE1(v47) = v69;
      LOBYTE(v48) = v70;
      BYTE3(v47) = -1;
      BYTE1(v48) = v66;
      BYTE3(v48) = -1;
      ++v57;
    }
    while ( v57 < *(_DWORD *)(a2 + 4632) );
  }
  v21 = *(_DWORD *)(a4 + 4);
  v22 = v54;
  if ( v21 > 1 )
  {
    v23 = 1;
    do
      ++v23;
    while ( v23 < v21 );
  }
  `eh vector constructor iterator'(v97, 0x24u, 2, (int)sub_1005C080, sub_1005C5A0);
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  LOBYTE(v100) = 6;
  sub_1005BFA0((int)&v71);
  LOBYTE(v100) = 7;
  v90 = 1;
  v74 = 0;
  v84 = 0;
  v72 = 0;
  v73 = 32;
  if ( v76 )
  {
    if ( v76 <= 0 )
      memset((void *)(v75 + v76), 0, -v76);
    v76 = 0;
  }
  sub_10032F10((int)&v75, 0x100000u);
  if ( v82 )
    v82 = 0;
  if ( v79 )
  {
    if ( v79 <= 0 )
      memset((void *)(v78 + v79), 0, -v79);
    v79 = 0;
  }
  v86 = 0;
  v87 = 0;
  v88 = -1;
  v89 = 0;
  v46 = 0;
  v24 = (unsigned int *)v97;
  v25 = &v59;
  do
  {
    if ( *v25 )
      v26 = *(v25 - 1);
    else
      v26 = 0;
    if ( !sub_1005C930(*v25, (int)v24, v26, 0xFu) )
    {
      LOBYTE(v100) = 3;
      sub_10036930((int)&v71);
      LOBYTE(v100) = 2;
      `eh vector destructor iterator'(v97, 0x24u, 2, sub_1005C5A0);
      LOBYTE(v100) = 1;
      if ( v22 )
      {
        if ( (unsigned __int8)v22 & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v39 = _iob_func();
          fputs(&DstBuf, v39 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v22, 0, 0, 1, dword_100AE9F4);
        }
      }
      LOBYTE(v100) = 0;
      `eh vector destructor iterator'(&v58, 0xCu, 2, sub_10038C00);
      v100 = -1;
      if ( v65 )
      {
        if ( (unsigned __int8)v65 & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v40 = _iob_func() + 2;
          fputs(&DstBuf, v40);
          goto LABEL_68;
        }
        off_100AD9F4(v65, 0, 0, 1, dword_100AE9F4);
      }
      return 0;
    }
    if ( !sub_1005CCA0((int)&v71, v24, (int)&v71) )
    {
      LOBYTE(v100) = 3;
      sub_10036930((int)&v71);
      LOBYTE(v100) = 2;
      `eh vector destructor iterator'(v97, 0x24u, 2, sub_1005C5A0);
      LOBYTE(v100) = 1;
      if ( v22 )
      {
        if ( (unsigned __int8)v22 & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v42 = _iob_func();
          fputs(&DstBuf, v42 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v22, 0, 0, 1, dword_100AE9F4);
        }
      }
      LOBYTE(v100) = 0;
      `eh vector destructor iterator'(&v58, 0xCu, 2, sub_10038C00);
      v100 = -1;
      if ( v65 )
      {
        if ( (unsigned __int8)v65 & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v43 = _iob_func() + 2;
          fputs(&DstBuf, v43);
LABEL_68:
          if ( IsDebuggerPresent() )
          {
            DebugBreak();
            return 0;
          }
          return 0;
        }
        off_100AD9F4(v65, 0, 0, 1, dword_100AE9F4);
      }
      return 0;
    }
    v25 += 3;
    v24 += 9;
    ++v46;
  }
  while ( v46 < 2 );
  v27 = 0;
  if ( v55 )
  {
    v28 = v82;
    do
    {
      v29 = v22[v27];
      v30 = -9 * (v27 % 3 != 1) + 9;
      v31 = *(_BYTE *)(v98[v30] + v29);
      v32 = *(_WORD *)(*(_DWORD *)&v97[4 * v30 + 4] + 2 * v29);
      if ( *(_BYTE *)(v98[v30] + v29) )
      {
        v84 += v31;
        if ( !v85 )
        {
          v53 = (unsigned __int16)v31;
          if ( v28 >= v83 )
          {
            sub_100943C0(v28 + 1, 0, (int)&v81, 1, 8u, 0);
            v28 = v82;
          }
          v33 = v81 + 8 * v28;
          if ( v33 )
          {
            v34 = v53;
            *(_DWORD *)v33 = v32;
            *(_DWORD *)(v33 + 4) = v34;
            v28 = v82;
          }
          v82 = ++v28;
        }
      }
      ++v27;
    }
    while ( v27 < v55 );
  }
  sub_1005CC00((int)&v71);
  if ( !v85 )
    sub_1005D260((int)&v71);
  v35 = *(_DWORD *)a3;
  *(_DWORD *)a3 = v75;
  v75 = v35;
  v36 = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a3 + 4) = v76;
  v37 = v77;
  v76 = v36;
  v77 = *(_DWORD *)(a3 + 8);
  v90 = 0;
  *(_DWORD *)(a3 + 8) = v37;
  LOBYTE(v100) = 3;
  sub_10036930((int)&v71);
  LOBYTE(v100) = 2;
  `eh vector destructor iterator'(v97, 0x24u, 2, sub_1005C5A0);
  LOBYTE(v100) = 1;
  if ( v22 )
  {
    if ( (unsigned __int8)v22 & 7 )
    {
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v38 = _iob_func();
      fputs(&DstBuf, v38 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(v22, 0, 0, 1, dword_100AE9F4);
    }
  }
  LOBYTE(v100) = 0;
  `eh vector destructor iterator'(&v58, 0xCu, 2, sub_10038C00);
  v100 = -1;
  if ( v65 )
  {
    if ( (unsigned __int8)v65 & 7 )
    {
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v44 = _iob_func();
      fputs(&DstBuf, v44 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(v65, 0, 0, 1, dword_100AE9F4);
    }
  }
  return 1;
}
// 10036920: using guessed type int unknown_libname_2();
// 1005C080: using guessed type int sub_1005C080();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 10077800: using guessed type char var_25C[16];
// 10077800: using guessed type int var_24C[14];

//----- (10078240) --------------------------------------------------------
char __thiscall sub_10078240(int this, int a2)
{
  unsigned int v2; // edi@1
  int v3; // esi@1
  unsigned int v4; // eax@1
  _DWORD *v5; // ebx@2
  _DWORD *v6; // ebx@7
  int v7; // ecx@11
  unsigned int v8; // edi@11
  unsigned int v9; // eax@11
  int v10; // ebx@14
  unsigned int v11; // eax@18
  char v12; // al@20
  bool v13; // zf@20
  void *v14; // eax@20
  FILE *v15; // ST18_4@23
  FILE *v17; // eax@30
  CHAR *v18; // edx@30
  int v19; // eax@32
  struct _SINGLE_LIST_ENTRY *v20; // ebx@34
  FILE *v21; // eax@35
  unsigned int v22; // ecx@38
  char *v23; // edx@38
  int v24; // ST18_4@38
  int v25; // eax@38
  struct _SINGLE_LIST_ENTRY *v26; // edi@38
  FILE *v27; // eax@40
  int v28; // eax@42
  PSINGLE_LIST_ENTRY v29; // eax@43
  FILE *v30; // eax@46
  FILE *v31; // eax@53
  char *v32; // edi@58
  int v33; // eax@59
  int v34; // edx@63
  void *v35; // eax@64
  int v36; // ecx@64
  int v37; // ecx@64
  int v38; // edx@64
  int v39; // edx@64
  int v40; // edx@64
  int v41; // ecx@64
  FILE *v42; // eax@70
  FILE *v43; // eax@82
  FILE *v44; // ST18_4@87
  void *v45; // [sp+Ch] [bp-87Ch]@1
  unsigned int v46; // [sp+10h] [bp-878h]@1
  unsigned int v47; // [sp+14h] [bp-874h]@1
  char *v48; // [sp+18h] [bp-870h]@31
  PSLIST_HEADER ListHead; // [sp+1Ch] [bp-86Ch]@32
  int v50; // [sp+20h] [bp-868h]@38
  int v51; // [sp+24h] [bp-864h]@44
  unsigned int v52; // [sp+28h] [bp-860h]@14
  unsigned int v53; // [sp+2Ch] [bp-85Ch]@31
  void *v54; // [sp+30h] [bp-858h]@61
  int v55; // [sp+34h] [bp-854h]@61
  int v56; // [sp+38h] [bp-850h]@61
  struct _SINGLE_LIST_ENTRY *v57; // [sp+44h] [bp-844h]@51
  char v58; // [sp+48h] [bp-840h]@31
  CHAR v59; // [sp+78h] [bp-810h]@53
  char DstBuf; // [sp+278h] [bp-610h]@23
  CHAR v61; // [sp+478h] [bp-410h]@46
  CHAR OutputString; // [sp+678h] [bp-210h]@40
  int v63; // [sp+884h] [bp-4h]@1

  v2 = 0;
  v3 = this;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  v63 = 0;
  sub_10036310((int)&v45, *(_DWORD *)(this + 4148) + *(_DWORD *)(this + 4160));
  v4 = v46;
  if ( *(_DWORD *)(v3 + 4148) > 0u )
  {
    do
    {
      v5 = (_DWORD *)(*(_DWORD *)(v3 + 4144) + 4 * v2);
      if ( v4 >= v47 )
      {
        sub_100943C0(v4 + 1, 0, (int)&v45, 1, 4u, 0);
        v4 = v46;
      }
      *((_DWORD *)v45 + v4) = *v5;
      v4 = v46 + 1;
      ++v2;
      ++v46;
    }
    while ( v2 < *(_DWORD *)(v3 + 4148) );
    v2 = 0;
  }
  if ( *(_DWORD *)(v3 + 4160) > 0u )
  {
    do
    {
      v6 = (_DWORD *)(*(_DWORD *)(v3 + 4156) + 4 * v2);
      if ( v4 >= v47 )
      {
        sub_100943C0(v4 + 1, 0, (int)&v45, 1, 4u, 0);
        v4 = v46;
      }
      *((_DWORD *)v45 + v4) = *v6;
      v4 = v46 + 1;
      ++v2;
      ++v46;
    }
    while ( v2 < *(_DWORD *)(v3 + 4160) );
  }
  if ( !(*(_BYTE *)(*(_DWORD *)(v3 + 96) + 28) & 4) )
  {
    v52 = -1;
    `eh vector constructor iterator'(&v58, 0xCu, 4, (int)unknown_libname_3, sub_10038C00);
    LOBYTE(v63) = 1;
    v53 = 0;
    v48 = &v58;
    do
    {
      ListHead = (PSLIST_HEADER)16;
      v19 = off_100AD9F4(0, 16, &ListHead, 1, dword_100AE9F4);
      if ( v19 && (unsigned int)ListHead >= 0x10 )
      {
        v20 = (struct _SINGLE_LIST_ENTRY *)v19;
      }
      else
      {
        sprintf_s(
          &DstBuf,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_malloc: out of memory");
        OutputDebugStringA(&DstBuf);
        v21 = _iob_func();
        fputs(&DstBuf, v21 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
        v20 = 0;
      }
      v22 = v53;
      v23 = v48;
      v20->Next = (struct _SINGLE_LIST_ENTRY *)&v45;
      v24 = dword_100AE9F4;
      v20[2].Next = (struct _SINGLE_LIST_ENTRY *)v22;
      v20[3].Next = (struct _SINGLE_LIST_ENTRY *)3;
      v20[1].Next = (struct _SINGLE_LIST_ENTRY *)v23;
      v50 = 16;
      v25 = off_100AD9F4(0, 16, &v50, 1, v24);
      v26 = (struct _SINGLE_LIST_ENTRY *)v25;
      if ( v25 && (unsigned int)v50 >= 0x10 )
      {
        *(_DWORD *)v25 = &off_100A4F34;
        *(_DWORD *)(v25 + 4) = v3;
        *(_DWORD *)(v25 + 8) = sub_10073FE0;
        *(_DWORD *)(v25 + 12) = 1;
        InterlockedIncrement((LPLONG)(v3 + 84));
        v28 = *(_DWORD *)(v3 + 4);
        v13 = *(_BYTE *)(v28 + 16) == 0;
        ListHead = *(PSLIST_HEADER *)(v3 + 4);
        if ( !v13 )
        {
          v29 = InterlockedPopEntrySList((PSLIST_HEADER)(v28 + 8));
          if ( v29 )
            goto LABEL_92;
        }
        v51 = 32;
        v29 = (PSINGLE_LIST_ENTRY)off_100AD9F4(0, 32, &v51, 1, dword_100AE9F4);
        if ( !v29 || (unsigned int)v51 < 0x20 )
        {
          sprintf_s(
            &v61,
            0x200u,
            "%s(%u): Assertion failed: \"%s\"\n",
            "crn_mem.cpp",
            216,
            "crnlib_malloc: out of memory");
          OutputDebugStringA(&v61);
          v30 = _iob_func();
          fputs(&v61, v30 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
          v29 = 0;
        }
        if ( v29 )
        {
LABEL_92:
          if ( v29 != (PSINGLE_LIST_ENTRY)-8 )
          {
            v29[2].Next = 0;
            v29[3].Next = 0;
            v29[4].Next = v20;
            v29[5].Next = v26;
            v29[6].Next = (struct _SINGLE_LIST_ENTRY *)1;
            v29[7].Next = v57;
          }
          InterlockedPushEntrySList(ListHead, v29);
          if ( !ReleaseSemaphore(*(HANDLE *)(v3 + 76), 1, 0) )
          {
            sprintf_s(
              &v59,
              0x200u,
              "%s(%u): Failure: \"%s\"\n",
              "crn_threading_win32.cpp",
              198,
              "\"semaphore: ReleaseSemaphore() failed\"");
            OutputDebugStringA(&v59);
            v31 = _iob_func();
            fputs(&v59, v31 + 2);
            if ( IsDebuggerPresent() )
              DebugBreak();
            if ( !byte_100AE9F8 )
              exit(1);
            RaiseException(0x100u, 0, 0, 0);
          }
        }
        else
        {
          InterlockedIncrement((LPLONG)(v3 + 88));
        }
      }
      else
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_malloc: out of memory");
        OutputDebugStringA(&OutputString);
        v27 = _iob_func();
        fputs(&OutputString, v27 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      v48 += 12;
      ++v53;
    }
    while ( v53 <= 3 );
    sub_10091500(v3 + 4);
    v48 = 0;
    v32 = &v58;
    while ( 1 )
    {
      v33 = *(_DWORD *)(v3 + 96);
      if ( *(_DWORD *)(v33 + 476) )
      {
        if ( (*(int (__cdecl **)(signed int, signed int, char *, signed int, _DWORD))(v33 + 476))(
               23,
               25,
               v48,
               4,
               *(_DWORD *)(v33 + 480)) == 0 )
          break;
      }
      v54 = 0;
      v55 = 0;
      v56 = 0;
      LOBYTE(v63) = 2;
      if ( !sub_10076610(v32, (int)&v54, (int)&v45, v3 + 4592, 7, (int)byte_1009F8AC)
        || !sub_10076420(v3, *(_DWORD *)(v3 + 4168), &v51, 0, 0, 0, (int)v32) )
      {
        LOBYTE(v63) = 1;
        if ( v54 )
        {
          if ( (unsigned __int8)v54 & 7 )
          {
            sprintf_s(&v59, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
            OutputDebugStringA(&v59);
            v43 = _iob_func();
            fputs(&v59, v43 + 2);
            if ( IsDebuggerPresent() )
              DebugBreak();
          }
          else
          {
            off_100AD9F4(v54, 0, 0, 1, dword_100AE9F4);
          }
        }
        break;
      }
      v34 = v55;
      v50 = v51 + 8 * v55;
      if ( v50 >= v52 )
      {
        v35 = v54;
      }
      else
      {
        v35 = *(void **)(v3 + 5288);
        *(_DWORD *)(v3 + 5288) = v54;
        v36 = *(_DWORD *)(v3 + 5292);
        *(_DWORD *)(v3 + 5292) = v34;
        v55 = v36;
        v37 = *(_DWORD *)(v3 + 5296);
        *(_DWORD *)(v3 + 5296) = v56;
        v38 = *(_DWORD *)v32;
        v56 = v37;
        *(_DWORD *)v32 = *(_DWORD *)a2;
        *(_DWORD *)a2 = v38;
        v39 = *((_DWORD *)v32 + 1);
        *((_DWORD *)v32 + 1) = *(_DWORD *)(a2 + 4);
        *(_DWORD *)(a2 + 4) = v39;
        v40 = *((_DWORD *)v32 + 2);
        *((_DWORD *)v32 + 2) = *(_DWORD *)(a2 + 8);
        v41 = v50;
        *(_DWORD *)(a2 + 8) = v40;
        v52 = v41;
      }
      LOBYTE(v63) = 1;
      if ( v35 )
      {
        if ( (unsigned __int8)v35 & 7 )
        {
          sprintf_s(&v59, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&v59);
          v42 = _iob_func();
          fputs(&v59, v42 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v35, 0, 0, 1, dword_100AE9F4);
        }
      }
      v32 += 12;
      if ( (unsigned int)++v48 > 3 )
      {
        LOBYTE(v63) = 0;
        `eh vector destructor iterator'(&v58, 0xCu, 4, sub_10038C00);
        v63 = -1;
        v14 = v45;
        if ( !v45 )
          return 1;
        if ( (unsigned __int8)v45 & 7 )
        {
          sprintf_s(&v59, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&v59);
          v17 = _iob_func();
          v18 = &v59;
          goto LABEL_77;
        }
        goto LABEL_88;
      }
    }
    LOBYTE(v63) = 0;
    `eh vector destructor iterator'(&v58, 0xCu, 4, sub_10038C00);
    v63 = -1;
    if ( !v45 )
      return 0;
    if ( !((unsigned __int8)v45 & 7) )
    {
      off_100AD9F4(v45, 0, 0, 1, dword_100AE9F4);
      return 0;
    }
    sprintf_s(&v59, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
    OutputDebugStringA(&v59);
    v44 = _iob_func() + 2;
    fputs(&v59, v44);
LABEL_24:
    if ( IsDebuggerPresent() )
    {
      DebugBreak();
      return 0;
    }
    return 0;
  }
  v7 = a2;
  v8 = *(_DWORD *)(v3 + 4596);
  v9 = *(_DWORD *)(a2 + 4);
  if ( v8 != v9 )
  {
    if ( v8 >= v9 )
    {
      if ( v8 <= *(_DWORD *)(a2 + 8) )
      {
        v10 = a2;
      }
      else
      {
        v10 = a2;
        LOBYTE(v52) = v8 == v9 + 1;
        sub_100943C0(v8, 0, a2, v8 == v9 + 1, 4u, 0);
      }
      memset((void *)(*(_DWORD *)v10 + 4 * *(_DWORD *)(v10 + 4)), 0, 4 * (v8 - *(_DWORD *)(v10 + 4)));
      v7 = a2;
    }
    *(_DWORD *)(v7 + 4) = v8;
  }
  v11 = 0;
  if ( *(_DWORD *)(v3 + 4596) )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)v7 + 4 * v11) = v11;
      ++v11;
    }
    while ( v11 < *(_DWORD *)(v3 + 4596) );
  }
  v12 = sub_10076610((_DWORD *)a2, v3 + 5288, (int)&v45, v3 + 4592, 7, (int)byte_1009F8AC);
  v63 = -1;
  v13 = v12 == 0;
  v14 = v45;
  if ( v13 )
  {
    if ( v45 )
    {
      if ( (unsigned __int8)v45 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v15 = _iob_func() + 2;
        fputs(&DstBuf, v15);
        goto LABEL_24;
      }
      off_100AD9F4(v45, 0, 0, 1, dword_100AE9F4);
    }
    return 0;
  }
  if ( v45 )
  {
    if ( (unsigned __int8)v45 & 7 )
    {
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v17 = _iob_func();
      v18 = &DstBuf;
LABEL_77:
      fputs(v18, v17 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
LABEL_88:
      off_100AD9F4(v14, 0, 0, 1, dword_100AE9F4);
    }
  }
  return 1;
}
// 1003F6D0: using guessed type int unknown_libname_3();
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (10078C00) --------------------------------------------------------
char __userpurge sub_10078C00@<al>(int a1@<esi>, int a2)
{
  unsigned int v2; // edi@1
  unsigned int v3; // eax@1
  _DWORD *v4; // ebx@2
  _DWORD *v5; // ebx@7
  int v6; // ecx@11
  unsigned int v7; // edi@11
  unsigned int v8; // eax@11
  int v9; // ebx@14
  unsigned int v10; // eax@18
  char v11; // al@20
  bool v12; // zf@20
  void *v13; // eax@20
  FILE *v14; // ST18_4@23
  FILE *v16; // ST18_4@30
  int v17; // eax@33
  struct _SINGLE_LIST_ENTRY *v18; // ebx@35
  FILE *v19; // eax@36
  unsigned int v20; // edx@39
  char *v21; // eax@39
  int v22; // ST18_4@39
  int v23; // edi@39
  FILE *v24; // eax@41
  int v25; // eax@43
  PSINGLE_LIST_ENTRY v26; // eax@44
  FILE *v27; // eax@47
  FILE *v28; // eax@54
  char *v29; // edi@59
  int v30; // eax@60
  int v31; // edx@64
  void *v32; // eax@65
  int v33; // ecx@65
  int v34; // ecx@65
  int v35; // edx@65
  int v36; // edx@65
  int v37; // edx@65
  int v38; // ecx@65
  FILE *v39; // eax@71
  FILE *v40; // ST18_4@77
  FILE *v41; // eax@82
  FILE *v42; // ST18_4@87
  void *v43; // [sp+Ch] [bp-87Ch]@1
  unsigned int v44; // [sp+10h] [bp-878h]@1
  unsigned int v45; // [sp+14h] [bp-874h]@1
  char *v46; // [sp+18h] [bp-870h]@32
  PSLIST_HEADER ListHead; // [sp+1Ch] [bp-86Ch]@33
  int v48; // [sp+20h] [bp-868h]@39
  int v49; // [sp+24h] [bp-864h]@45
  unsigned int v50; // [sp+28h] [bp-860h]@14
  unsigned int v51; // [sp+2Ch] [bp-85Ch]@32
  void *v52; // [sp+30h] [bp-858h]@62
  int v53; // [sp+34h] [bp-854h]@62
  int v54; // [sp+38h] [bp-850h]@62
  struct _SINGLE_LIST_ENTRY *v55; // [sp+44h] [bp-844h]@52
  char v56; // [sp+48h] [bp-840h]@32
  CHAR v57; // [sp+78h] [bp-810h]@54
  char DstBuf; // [sp+278h] [bp-610h]@23
  CHAR v59; // [sp+478h] [bp-410h]@47
  CHAR OutputString; // [sp+678h] [bp-210h]@41
  int v61; // [sp+884h] [bp-4h]@1

  v2 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v61 = 0;
  sub_10036310((int)&v43, *(_DWORD *)(a1 + 4112) + *(_DWORD *)(a1 + 4124));
  v3 = v44;
  if ( *(_DWORD *)(a1 + 4112) > 0u )
  {
    do
    {
      v4 = (_DWORD *)(*(_DWORD *)(a1 + 4108) + 4 * v2);
      if ( v3 >= v45 )
      {
        sub_100943C0(v3 + 1, 0, (int)&v43, 1, 4u, 0);
        v3 = v44;
      }
      *((_DWORD *)v43 + v3) = *v4;
      v3 = v44 + 1;
      ++v2;
      ++v44;
    }
    while ( v2 < *(_DWORD *)(a1 + 4112) );
    v2 = 0;
  }
  if ( *(_DWORD *)(a1 + 4124) > 0u )
  {
    do
    {
      v5 = (_DWORD *)(*(_DWORD *)(a1 + 4120) + 4 * v2);
      if ( v3 >= v45 )
      {
        sub_100943C0(v3 + 1, 0, (int)&v43, 1, 4u, 0);
        v3 = v44;
      }
      *((_DWORD *)v43 + v3) = *v5;
      v3 = v44 + 1;
      ++v2;
      ++v44;
    }
    while ( v2 < *(_DWORD *)(a1 + 4124) );
  }
  if ( !(*(_BYTE *)(*(_DWORD *)(a1 + 96) + 28) & 4) )
  {
    v50 = -1;
    `eh vector constructor iterator'(&v56, 0xCu, 4, (int)unknown_libname_3, sub_10038C00);
    LOBYTE(v61) = 1;
    v51 = 0;
    v46 = &v56;
    do
    {
      ListHead = (PSLIST_HEADER)16;
      v17 = off_100AD9F4(0, 16, &ListHead, 1, dword_100AE9F4);
      if ( v17 && (unsigned int)ListHead >= 0x10 )
      {
        v18 = (struct _SINGLE_LIST_ENTRY *)v17;
      }
      else
      {
        sprintf_s(
          &DstBuf,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_malloc: out of memory");
        OutputDebugStringA(&DstBuf);
        v19 = _iob_func();
        fputs(&DstBuf, v19 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
        v18 = 0;
      }
      v20 = v51;
      v21 = v46;
      v18->Next = (struct _SINGLE_LIST_ENTRY *)&v43;
      v22 = dword_100AE9F4;
      v18[2].Next = (struct _SINGLE_LIST_ENTRY *)v20;
      v18[3].Next = (struct _SINGLE_LIST_ENTRY *)3;
      v18[1].Next = (struct _SINGLE_LIST_ENTRY *)v21;
      v48 = 16;
      v23 = off_100AD9F4(0, 16, &v48, 1, v22);
      if ( v23 && (unsigned int)v48 >= 0x10 )
      {
        *(_DWORD *)v23 = &off_100A4F34;
        *(_DWORD *)(v23 + 4) = a1;
        *(_DWORD *)(v23 + 8) = sub_10074080;
        *(_DWORD *)(v23 + 12) = 1;
        InterlockedIncrement((LPLONG)(a1 + 84));
        v25 = *(_DWORD *)(a1 + 4);
        v12 = *(_BYTE *)(v25 + 16) == 0;
        ListHead = *(PSLIST_HEADER *)(a1 + 4);
        if ( !v12 )
        {
          v26 = InterlockedPopEntrySList((PSLIST_HEADER)(v25 + 8));
          if ( v26 )
            goto LABEL_92;
        }
        v49 = 32;
        v26 = (PSINGLE_LIST_ENTRY)off_100AD9F4(0, 32, &v49, 1, dword_100AE9F4);
        if ( !v26 || (unsigned int)v49 < 0x20 )
        {
          sprintf_s(
            &v59,
            0x200u,
            "%s(%u): Assertion failed: \"%s\"\n",
            "crn_mem.cpp",
            216,
            "crnlib_malloc: out of memory");
          OutputDebugStringA(&v59);
          v27 = _iob_func();
          fputs(&v59, v27 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
          v26 = 0;
        }
        if ( v26 )
        {
LABEL_92:
          if ( v26 != (PSINGLE_LIST_ENTRY)-8 )
          {
            v26[2].Next = 0;
            v26[3].Next = 0;
            v26[4].Next = v18;
            v26[5].Next = (struct _SINGLE_LIST_ENTRY *)v23;
            v26[6].Next = (struct _SINGLE_LIST_ENTRY *)1;
            v26[7].Next = v55;
          }
          InterlockedPushEntrySList(ListHead, v26);
          if ( !ReleaseSemaphore(*(HANDLE *)(a1 + 76), 1, 0) )
          {
            sprintf_s(
              &v57,
              0x200u,
              "%s(%u): Failure: \"%s\"\n",
              "crn_threading_win32.cpp",
              198,
              "\"semaphore: ReleaseSemaphore() failed\"");
            OutputDebugStringA(&v57);
            v28 = _iob_func();
            fputs(&v57, v28 + 2);
            if ( IsDebuggerPresent() )
              DebugBreak();
            if ( !byte_100AE9F8 )
              exit(1);
            RaiseException(0x100u, 0, 0, 0);
          }
        }
        else
        {
          InterlockedIncrement((LPLONG)(a1 + 88));
        }
      }
      else
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_malloc: out of memory");
        OutputDebugStringA(&OutputString);
        v24 = _iob_func();
        fputs(&OutputString, v24 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      v46 += 12;
      ++v51;
    }
    while ( v51 <= 3 );
    sub_10091500(a1 + 4);
    v46 = 0;
    v29 = &v56;
    while ( 1 )
    {
      v30 = *(_DWORD *)(a1 + 96);
      if ( *(_DWORD *)(v30 + 476) )
      {
        if ( (*(int (__cdecl **)(signed int, signed int, char *, signed int, _DWORD))(v30 + 476))(
               22,
               25,
               v46,
               4,
               *(_DWORD *)(v30 + 480)) == 0 )
          break;
      }
      v52 = 0;
      v53 = 0;
      v54 = 0;
      LOBYTE(v61) = 2;
      if ( !sub_10076E80(a1, (int)&v52, v29, (int)&v43)
        || !sub_10076420(a1, *(_DWORD *)(a1 + 4168), &v49, 0, 0, (int)v29, 0) )
      {
        LOBYTE(v61) = 1;
        if ( v52 )
        {
          if ( (unsigned __int8)v52 & 7 )
          {
            sprintf_s(&v57, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
            OutputDebugStringA(&v57);
            v41 = _iob_func();
            fputs(&v57, v41 + 2);
            if ( IsDebuggerPresent() )
              DebugBreak();
          }
          else
          {
            off_100AD9F4(v52, 0, 0, 1, dword_100AE9F4);
          }
        }
        break;
      }
      v31 = v53;
      v48 = v49 + 8 * v53;
      if ( v48 >= v50 )
      {
        v32 = v52;
      }
      else
      {
        v32 = *(void **)(a1 + 5276);
        *(_DWORD *)(a1 + 5276) = v52;
        v33 = *(_DWORD *)(a1 + 5280);
        *(_DWORD *)(a1 + 5280) = v31;
        v53 = v33;
        v34 = *(_DWORD *)(a1 + 5284);
        *(_DWORD *)(a1 + 5284) = v54;
        v35 = *(_DWORD *)v29;
        v54 = v34;
        *(_DWORD *)v29 = *(_DWORD *)a2;
        *(_DWORD *)a2 = v35;
        v36 = *((_DWORD *)v29 + 1);
        *((_DWORD *)v29 + 1) = *(_DWORD *)(a2 + 4);
        *(_DWORD *)(a2 + 4) = v36;
        v37 = *((_DWORD *)v29 + 2);
        *((_DWORD *)v29 + 2) = *(_DWORD *)(a2 + 8);
        v38 = v48;
        *(_DWORD *)(a2 + 8) = v37;
        v50 = v38;
      }
      LOBYTE(v61) = 1;
      if ( v32 )
      {
        if ( (unsigned __int8)v32 & 7 )
        {
          sprintf_s(&v57, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&v57);
          v39 = _iob_func();
          fputs(&v57, v39 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v32, 0, 0, 1, dword_100AE9F4);
        }
      }
      v29 += 12;
      if ( (unsigned int)++v46 > 3 )
      {
        LOBYTE(v61) = 0;
        `eh vector destructor iterator'(&v56, 0xCu, 4, sub_10038C00);
        v61 = -1;
        if ( !v43 )
          return 1;
        if ( (unsigned __int8)v43 & 7 )
        {
          sprintf_s(&v57, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&v57);
          v40 = _iob_func() + 2;
          fputs(&v57, v40);
          goto LABEL_78;
        }
        off_100AD9F4(v43, 0, 0, 1, dword_100AE9F4);
        return 1;
      }
    }
    LOBYTE(v61) = 0;
    `eh vector destructor iterator'(&v56, 0xCu, 4, sub_10038C00);
    v61 = -1;
    v13 = v43;
    if ( !v43 )
      return 0;
    if ( (unsigned __int8)v43 & 7 )
    {
      sprintf_s(&v57, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&v57);
      v42 = _iob_func() + 2;
      fputs(&v57, v42);
      goto LABEL_24;
    }
    goto LABEL_26;
  }
  v6 = a2;
  v7 = *(_DWORD *)(a1 + 4644);
  v8 = *(_DWORD *)(a2 + 4);
  if ( v7 != v8 )
  {
    if ( v7 >= v8 )
    {
      if ( v7 <= *(_DWORD *)(a2 + 8) )
      {
        v9 = a2;
      }
      else
      {
        v9 = a2;
        LOBYTE(v50) = v7 == v8 + 1;
        sub_100943C0(v7, 0, a2, v7 == v8 + 1, 4u, 0);
      }
      memset((void *)(*(_DWORD *)v9 + 4 * *(_DWORD *)(v9 + 4)), 0, 4 * (v7 - *(_DWORD *)(v9 + 4)));
      v6 = a2;
    }
    *(_DWORD *)(v6 + 4) = v7;
  }
  v10 = 0;
  if ( *(_DWORD *)(a1 + 4644) )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)v6 + 4 * v10) = v10;
      ++v10;
    }
    while ( v10 < *(_DWORD *)(a1 + 4644) );
  }
  v11 = sub_10076E80(a1, a1 + 5276, (_DWORD *)a2, (int)&v43);
  v61 = -1;
  v12 = v11 == 0;
  v13 = v43;
  if ( v12 )
  {
    if ( !v43 )
      return 0;
    if ( (unsigned __int8)v43 & 7 )
    {
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v14 = _iob_func() + 2;
      fputs(&DstBuf, v14);
LABEL_24:
      if ( IsDebuggerPresent() )
      {
        DebugBreak();
        return 0;
      }
      return 0;
    }
LABEL_26:
    off_100AD9F4(v13, 0, 0, 1, dword_100AE9F4);
    return 0;
  }
  if ( v43 )
  {
    if ( (unsigned __int8)v43 & 7 )
    {
      sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&DstBuf);
      v16 = _iob_func() + 2;
      fputs(&DstBuf, v16);
LABEL_78:
      if ( IsDebuggerPresent() )
      {
        DebugBreak();
        return 1;
      }
    }
    else
    {
      off_100AD9F4(v43, 0, 0, 1, dword_100AE9F4);
    }
  }
  return 1;
}
// 1003F6D0: using guessed type int unknown_libname_3();
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (100795B0) --------------------------------------------------------
bool __usercall sub_100795B0@<al>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  int v4; // edi@1
  unsigned int v5; // eax@2
  bool result; // al@4
  int v7; // eax@6
  int v8; // esi@8
  int v9; // ST18_4@10
  int v10; // eax@10
  char *v11; // esi@15
  int v12; // ecx@16
  unsigned int v13; // edx@20
  void *v14; // eax@21
  int v15; // ecx@21
  int v16; // ecx@21
  int v17; // eax@21
  int v18; // ecx@21
  int v19; // ecx@21
  int v20; // ecx@21
  unsigned int v21; // [sp+0h] [bp-60h]@5
  char *v22; // [sp+4h] [bp-5Ch]@5
  int v23; // [sp+4h] [bp-5Ch]@15
  int v24; // [sp+8h] [bp-58h]@6
  int v25; // [sp+Ch] [bp-54h]@10
  unsigned int v26; // [sp+10h] [bp-50h]@5
  void *v27; // [sp+14h] [bp-4Ch]@18
  int v28; // [sp+18h] [bp-48h]@18
  int v29; // [sp+1Ch] [bp-44h]@18
  char v30; // [sp+20h] [bp-40h]@5
  int v31; // [sp+54h] [bp-Ch]@1
  int (__thiscall *v32)(void *); // [sp+58h] [bp-8h]@1
  int v33; // [sp+5Ch] [bp-4h]@1

  v33 = -1;
  v32 = sub_100970E9;
  v31 = a1;
  v3 = a2;
  v4 = a3;
  if ( *(_BYTE *)(*(_DWORD *)(a2 + 96) + 28) & 4 )
  {
    sub_100366C0(a3, *(_DWORD *)(a2 + 4584));
    v5 = 0;
    if ( *(_DWORD *)(v3 + 4584) )
    {
      do
      {
        *(_DWORD *)(*(_DWORD *)v4 + 4 * v5) = v5;
        ++v5;
      }
      while ( v5 < *(_DWORD *)(v3 + 4584) );
    }
    result = sub_10076610((_DWORD *)v4, v3 + 5264, v3 + 4132, v3 + 4580, 3, (int)byte_1009F8C0) != 0;
  }
  else
  {
    v26 = -1;
    `eh vector constructor iterator'(&v30, 0xCu, 4, (int)unknown_libname_3, sub_10038C00);
    v33 = 0;
    v21 = 0;
    v22 = &v30;
    do
    {
      v24 = 12;
      v7 = off_100AD9F4(0, 12, &v24, 1, dword_100AE9F4);
      if ( v7 && (unsigned int)v24 >= 0xC )
      {
        v8 = v7;
      }
      else
      {
        sub_100927E0((int)"crnlib_malloc: out of memory");
        v8 = 0;
      }
      v9 = dword_100AE9F4;
      *(_DWORD *)(v8 + 4) = v21;
      *(_DWORD *)(v8 + 8) = 3;
      *(_DWORD *)v8 = v22;
      v25 = 16;
      v10 = off_100AD9F4(0, 16, &v25, 1, v9);
      if ( v10 && (unsigned int)v25 >= 0x10 )
      {
        *(_DWORD *)v10 = &off_100A4F34;
        *(_DWORD *)(v10 + 4) = v3;
        *(_DWORD *)(v10 + 8) = sub_10074140;
        *(_DWORD *)(v10 + 12) = 1;
        sub_100916A0(v10, v3 + 4, 0, 0, v8);
      }
      else
      {
        sub_100927E0((int)"crnlib_malloc: out of memory");
      }
      v22 += 12;
      ++v21;
    }
    while ( v21 <= 3 );
    sub_10091500(v3 + 4);
    v23 = 0;
    v11 = &v30;
    while ( 1 )
    {
      v12 = *(_DWORD *)(v3 + 96);
      if ( *(_DWORD *)(v12 + 476) )
      {
        if ( (*(int (__cdecl **)(signed int, signed int, int, signed int, _DWORD))(*(_DWORD *)(v3 + 96) + 476))(
               21,
               25,
               v23,
               4,
               *(_DWORD *)(v12 + 480)) == 0 )
          break;
      }
      v27 = 0;
      v28 = 0;
      v29 = 0;
      LOBYTE(v33) = 1;
      if ( !sub_10076610(v11, (int)&v27, v3 + 4132, v3 + 4580, 3, (int)byte_1009F8C0)
        || !sub_10076420(v3, *(_DWORD *)(v3 + 4168), &v25, 0, (int)v11, 0, 0) )
      {
        LOBYTE(v33) = 0;
        if ( v27 )
        {
          if ( (unsigned __int8)v27 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v27, 0, 0, 1, dword_100AE9F4);
        }
        break;
      }
      v13 = v25 + 8 * v28;
      if ( v13 < v26 )
      {
        v14 = *(void **)(v3 + 5264);
        *(_DWORD *)(v3 + 5264) = v27;
        v15 = *(_DWORD *)(v3 + 5268);
        v27 = v14;
        *(_DWORD *)(v3 + 5268) = v28;
        v28 = v15;
        v16 = *(_DWORD *)(v3 + 5272);
        *(_DWORD *)(v3 + 5272) = v29;
        v17 = *(_DWORD *)v11;
        v29 = v16;
        v18 = *(_DWORD *)v4;
        *(_DWORD *)v4 = v17;
        *(_DWORD *)v11 = v18;
        v19 = *(_DWORD *)(v4 + 4);
        *(_DWORD *)(v4 + 4) = *((_DWORD *)v11 + 1);
        *((_DWORD *)v11 + 1) = v19;
        v20 = *(_DWORD *)(v4 + 8);
        *(_DWORD *)(v4 + 8) = *((_DWORD *)v11 + 2);
        *((_DWORD *)v11 + 2) = v20;
        v26 = v13;
      }
      LOBYTE(v33) = 0;
      if ( v27 )
      {
        if ( (unsigned __int8)v27 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v27, 0, 0, 1, dword_100AE9F4);
      }
      v11 += 12;
      if ( (unsigned int)++v23 > 3 )
      {
        v33 = -1;
        `eh vector destructor iterator'(&v30, 0xCu, 4, sub_10038C00);
        return 1;
      }
    }
    v33 = -1;
    `eh vector destructor iterator'(&v30, 0xCu, 4, sub_10038C00);
    result = 0;
  }
  return result;
}
// 1003F6D0: using guessed type int unknown_libname_3();
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10079940) --------------------------------------------------------
bool __usercall sub_10079940@<al>(int a1@<ecx>, int a2@<ebx>)
{
  int v2; // edi@1
  unsigned int v3; // eax@2
  bool result; // al@4
  int v5; // eax@6
  int v6; // esi@8
  int v7; // ST18_4@10
  int v8; // eax@10
  char *v9; // esi@15
  int v10; // ecx@16
  unsigned int v11; // edx@20
  void *v12; // eax@21
  int v13; // ecx@21
  int v14; // ecx@21
  int v15; // eax@21
  int v16; // ecx@21
  int v17; // ecx@21
  int v18; // ecx@21
  unsigned int v19; // [sp+8h] [bp-60h]@5
  char *v20; // [sp+Ch] [bp-5Ch]@5
  int v21; // [sp+Ch] [bp-5Ch]@15
  int v22; // [sp+10h] [bp-58h]@6
  int v23; // [sp+14h] [bp-54h]@10
  unsigned int v24; // [sp+18h] [bp-50h]@5
  void *v25; // [sp+1Ch] [bp-4Ch]@18
  int v26; // [sp+20h] [bp-48h]@18
  int v27; // [sp+24h] [bp-44h]@18
  char v28; // [sp+28h] [bp-40h]@5
  int v29; // [sp+64h] [bp-4h]@5

  v2 = a1;
  if ( *(_BYTE *)(*(_DWORD *)(a2 + 96) + 28) & 4 )
  {
    sub_100366C0(a1, *(_DWORD *)(a2 + 4632));
    v3 = 0;
    if ( *(_DWORD *)(a2 + 4632) )
    {
      do
      {
        *(_DWORD *)(*(_DWORD *)v2 + 4 * v3) = v3;
        ++v3;
      }
      while ( v3 < *(_DWORD *)(a2 + 4632) );
    }
    result = sub_10077800((_DWORD *)v2, a2, a2 + 5252, a2 + 4096) != 0;
  }
  else
  {
    v24 = -1;
    `eh vector constructor iterator'(&v28, 0xCu, 4, (int)unknown_libname_3, sub_10038C00);
    v29 = 0;
    v19 = 0;
    v20 = &v28;
    do
    {
      v22 = 12;
      v5 = off_100AD9F4(0, 12, &v22, 1, dword_100AE9F4);
      if ( v5 && (unsigned int)v22 >= 0xC )
      {
        v6 = v5;
      }
      else
      {
        sub_100927E0((int)"crnlib_malloc: out of memory");
        v6 = 0;
      }
      v7 = dword_100AE9F4;
      *(_DWORD *)(v6 + 4) = v19;
      *(_DWORD *)(v6 + 8) = 3;
      *(_DWORD *)v6 = v20;
      v23 = 16;
      v8 = off_100AD9F4(0, 16, &v23, 1, v7);
      if ( v8 && (unsigned int)v23 >= 0x10 )
      {
        *(_DWORD *)v8 = &off_100A4F34;
        *(_DWORD *)(v8 + 4) = a2;
        *(_DWORD *)(v8 + 8) = sub_10074200;
        *(_DWORD *)(v8 + 12) = 1;
        sub_100916A0(v8, a2 + 4, 0, 0, v6);
      }
      else
      {
        sub_100927E0((int)"crnlib_malloc: out of memory");
      }
      v20 += 12;
      ++v19;
    }
    while ( v19 <= 3 );
    sub_10091500(a2 + 4);
    v21 = 0;
    v9 = &v28;
    while ( 1 )
    {
      v10 = *(_DWORD *)(a2 + 96);
      if ( *(_DWORD *)(v10 + 476) )
      {
        if ( (*(int (__cdecl **)(signed int, signed int, int, signed int, _DWORD))(*(_DWORD *)(a2 + 96) + 476))(
               20,
               25,
               v21,
               4,
               *(_DWORD *)(v10 + 480)) == 0 )
          break;
      }
      v25 = 0;
      v26 = 0;
      v27 = 0;
      LOBYTE(v29) = 1;
      if ( !sub_10077800(v9, a2, (int)&v25, a2 + 4096)
        || !sub_10076420(a2, *(_DWORD *)(a2 + 4168), &v23, (int)v9, 0, 0, 0) )
      {
        LOBYTE(v29) = 0;
        if ( v25 )
        {
          if ( (unsigned __int8)v25 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v25, 0, 0, 1, dword_100AE9F4);
        }
        break;
      }
      v11 = v23 + 8 * v26;
      if ( v11 < v24 )
      {
        v12 = *(void **)(a2 + 5252);
        *(_DWORD *)(a2 + 5252) = v25;
        v13 = *(_DWORD *)(a2 + 5256);
        v25 = v12;
        *(_DWORD *)(a2 + 5256) = v26;
        v26 = v13;
        v14 = *(_DWORD *)(a2 + 5260);
        *(_DWORD *)(a2 + 5260) = v27;
        v15 = *(_DWORD *)v9;
        v27 = v14;
        v16 = *(_DWORD *)v2;
        *(_DWORD *)v2 = v15;
        *(_DWORD *)v9 = v16;
        v17 = *(_DWORD *)(v2 + 4);
        *(_DWORD *)(v2 + 4) = *((_DWORD *)v9 + 1);
        *((_DWORD *)v9 + 1) = v17;
        v18 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 8) = *((_DWORD *)v9 + 2);
        *((_DWORD *)v9 + 2) = v18;
        v24 = v11;
      }
      LOBYTE(v29) = 0;
      if ( v25 )
      {
        if ( (unsigned __int8)v25 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v25, 0, 0, 1, dword_100AE9F4);
      }
      v9 += 12;
      if ( (unsigned int)++v21 > 3 )
      {
        v29 = -1;
        `eh vector destructor iterator'(&v28, 0xCu, 4, sub_10038C00);
        return 1;
      }
    }
    v29 = -1;
    `eh vector destructor iterator'(&v28, 0xCu, 4, sub_10038C00);
    result = 0;
  }
  return result;
}
// 1003F6D0: using guessed type int unknown_libname_3();
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10079CA0) --------------------------------------------------------
bool __usercall sub_10079CA0@<al>(int a1@<eax>)
{
  int v1; // edi@1
  int v2; // ecx@1
  int v3; // eax@1
  signed int v4; // eax@2
  signed int v5; // esi@2
  signed int v6; // eax@6
  signed int v7; // eax@10
  signed int v8; // ebx@11
  signed int v9; // ecx@14
  unsigned int v10; // esi@17
  float v11; // ST3C_4@21
  double v12; // st6@21
  double v13; // st7@22
  int v14; // ecx@24
  float v15; // ST3C_4@30
  float v16; // ST3C_4@30
  float v17; // ST48_4@30
  float v18; // ST3C_4@30
  float v19; // ST3C_4@30
  float v20; // ST48_4@30
  float v21; // ST48_4@30
  float v22; // ST30_4@34
  float v23; // ST30_4@34
  float v24; // ST30_4@38
  float v25; // ST30_4@38
  float v26; // ST48_4@38
  float v27; // ST30_4@38
  float v28; // ST30_4@38
  float v29; // ST30_4@38
  float v30; // ST30_4@38
  float v31; // ST30_4@41
  float v32; // ST30_4@41
  int v33; // eax@47
  signed int v35; // ecx@50
  int v36; // ecx@58
  unsigned int v37; // eax@58
  unsigned int v38; // esi@59
  int v39; // ecx@59
  int v40; // ebx@61
  int v41; // esi@61
  int v42; // ST54_4@61
  bool v43; // al@61
  float v44; // [sp+10h] [bp-E0h]@30
  signed __int64 v45; // [sp+10h] [bp-E0h]@34
  signed __int64 v46; // [sp+10h] [bp-E0h]@38
  signed __int64 v47; // [sp+10h] [bp-E0h]@41
  float v48; // [sp+18h] [bp-D8h]@24
  float v49; // [sp+1Ch] [bp-D4h]@30
  float v50; // [sp+20h] [bp-D0h]@23
  float v51; // [sp+24h] [bp-CCh]@24
  float v52; // [sp+24h] [bp-CCh]@38
  signed __int64 v53; // [sp+28h] [bp-C8h]@30
  int v54; // [sp+34h] [bp-BCh]@1
  char ArgList[4]; // [sp+38h] [bp-B8h]@1
  char v56[4]; // [sp+3Ch] [bp-B4h]@7
  int v57; // [sp+40h] [bp-B0h]@14
  int v58; // [sp+44h] [bp-ACh]@45
  float v59; // [sp+48h] [bp-A8h]@1
  float v60; // [sp+4Ch] [bp-A4h]@1
  float v61; // [sp+50h] [bp-A0h]@51
  int v62; // [sp+54h] [bp-9Ch]@54
  int v63; // [sp+58h] [bp-98h]@53
  int v64; // [sp+5Ch] [bp-94h]@60
  int v65[31]; // [sp+60h] [bp-90h]@60
  int v66; // [sp+DCh] [bp-14h]@58
  int v67; // [sp+E0h] [bp-10h]@48
  char v68; // [sp+E4h] [bp-Ch]@47
  char v69; // [sp+E5h] [bp-Bh]@47
  char v70; // [sp+E6h] [bp-Ah]@58
  int v71; // [sp+E8h] [bp-8h]@47
  int v72; // [sp+ECh] [bp-4h]@47

  v1 = a1;
  sub_10036840((int)ArgList);
  v2 = *(_DWORD *)(v1 + 96);
  v3 = *(_DWORD *)(v2 + 28);
  v60 = *(float *)(v2 + 444);
  v54 = v3;
  v59 = *(float *)(v2 + 440);
  if ( !(v3 & 0x40) )
  {
    v10 = ((unsigned int)(*(_DWORD *)(v2 + 12) + 3) >> 2) * ((unsigned int)(*(_DWORD *)(v2 + 16) + 3) >> 2);
    v8 = 8;
    if ( v10 >= 8 )
    {
      if ( v10 > 0x2000 )
        v10 = 0x2000;
    }
    else
    {
      v10 = 8;
    }
    v11 = (double)*(unsigned int *)(v2 + 420) / 255.0;
    v12 = v11;
    if ( v11 >= 0.0 )
    {
      v13 = 1.0;
      if ( v12 > 1.0 )
      {
        v50 = 1.0;
LABEL_24:
        v14 = *(_DWORD *)(v2 + 24);
        v48 = v13;
        v51 = v13;
        if ( v14 == 3 )
        {
          v48 = 3.5;
          v51 = 0.34999999;
          v59 = 5.0;
        }
        else if ( v14 == 2 )
        {
          v48 = 0.75;
        }
        v15 = v48 * 1.799999952316284;
        v16 = pow(v50, v15);
        v17 = v16;
        v18 = v48 * 1.649999976158142;
        v19 = pow(v50, v18);
        v44 = v19;
        v49 = (double)v10;
        v20 = (v49 - 64.0) * v17 + 64.0;
        v21 = v20 + 0.5;
        v53 = (signed __int64)v21;
        if ( (unsigned int)v53 >= 8 )
        {
          *(_DWORD *)ArgList = 0x2000;
          if ( (unsigned int)v53 <= 0x2000 )
            *(_DWORD *)ArgList = v53;
        }
        else
        {
          *(_DWORD *)ArgList = 8;
        }
        v22 = (v49 - 96.0) * v44 + 96.0;
        v23 = v22 + 0.5;
        v45 = (signed __int64)v23;
        if ( (unsigned int)v45 >= 8 )
        {
          *(_DWORD *)v56 = 0x2000;
          if ( (unsigned int)v45 <= 0x2000 )
            *(_DWORD *)v56 = v45;
        }
        else
        {
          *(_DWORD *)v56 = 8;
        }
        v24 = v51 * 2.099999904632568;
        v25 = pow(v50, v24);
        v26 = v25;
        v27 = v51 * 1.649999976158142;
        v28 = pow(v50, v27);
        v52 = v28;
        v29 = (v49 - 24.0) * v26 + 24.0;
        v30 = v29 + 0.5;
        v46 = (signed __int64)v30;
        if ( (unsigned int)v46 >= 8 )
        {
          v8 = 0x2000;
          if ( (unsigned int)v46 <= 0x2000 )
            v8 = v46;
        }
        v57 = v8;
        v31 = (v49 - 48.0) * v52 + 48.0;
        v32 = v31 + 0.5;
        v47 = (signed __int64)v32;
        v5 = v47;
        if ( (unsigned int)v47 < 8 )
        {
          v5 = 8;
          goto LABEL_45;
        }
        if ( (unsigned int)v47 > 0x2000 )
          goto LABEL_44;
        goto LABEL_45;
      }
    }
    else
    {
      v12 = 0.0;
      v13 = 1.0;
    }
    v50 = v12;
    goto LABEL_24;
  }
  v4 = *(_DWORD *)(v2 + 448);
  v5 = 8;
  if ( v4 >= 8 )
  {
    *(_DWORD *)ArgList = 0x2000;
    if ( v4 <= 0x2000 )
      *(_DWORD *)ArgList = v4;
  }
  else
  {
    *(_DWORD *)ArgList = 8;
  }
  v6 = *(_DWORD *)(v2 + 452);
  if ( v6 >= 8 )
  {
    *(_DWORD *)v56 = 0x2000;
    if ( v6 <= 0x2000 )
      *(_DWORD *)v56 = v6;
  }
  else
  {
    *(_DWORD *)v56 = 8;
  }
  v7 = *(_DWORD *)(v2 + 456);
  if ( v7 >= 8 )
  {
    v8 = 0x2000;
    if ( v7 <= 0x2000 )
      v8 = *(_DWORD *)(v2 + 456);
  }
  else
  {
    v8 = 8;
  }
  v9 = *(_DWORD *)(v2 + 460);
  v57 = v8;
  if ( v9 >= 8 )
  {
    if ( v9 <= 0x2000 )
    {
      v5 = v9;
      goto LABEL_45;
    }
LABEL_44:
    v5 = 0x2000;
  }
LABEL_45:
  v58 = v5;
  if ( v54 & 0x80000000 )
  {
    sub_10094360("Color endpoints: %u", *(_DWORD *)ArgList);
    sub_10094360("Color selectors: %u", *(_DWORD *)v56);
    sub_10094360("Alpha endpoints: %u", v8);
    sub_10094360("Alpha selectors: %u", v5);
  }
  v33 = *(_DWORD *)(v1 + 96);
  v68 = (*(_DWORD *)(v33 + 28) >> 1) & 1;
  v69 = *(_BYTE *)(v33 + 28) & 1;
  v71 = *(_DWORD *)(v33 + 476);
  v72 = *(_DWORD *)(v33 + 480);
  switch ( *(_DWORD *)(v33 + 24) )
  {
    case 0:
      v67 = 0;
      *(_BYTE *)(v1 + 4080) = 1;
      goto LABEL_58;
    case 1:
      *(_BYTE *)(v1 + 4081) = 1;
      return 0;
    case 2:
      v35 = *(_DWORD *)(v33 + 436);
      v67 = 3;
      *(_WORD *)(v1 + 4080) = 257;
      goto LABEL_57;
    case 3:
      v35 = 3;
      v61 = 1.5;
      v67 = 3;
      *(_WORD *)(v1 + 4080) = 257;
      goto LABEL_56;
    case 4:
    case 5:
    case 6:
      v35 = 3;
      v67 = 3;
      *(_WORD *)(v1 + 4080) = 257;
      goto LABEL_56;
    case 7:
      v35 = 0;
      v67 = 5;
      v63 = 1;
      *(_WORD *)(v1 + 4081) = 257;
      v69 = 0;
      goto LABEL_57;
    case 8:
      v67 = 6;
      v62 = 1;
      v63 = 0;
      *(_WORD *)(v1 + 4081) = 257;
      v69 = 0;
      goto LABEL_58;
    case 9:
      v35 = *(_DWORD *)(v33 + 436);
      v67 = 4;
      *(_BYTE *)(v1 + 4081) = 1;
LABEL_56:
      v69 = 0;
LABEL_57:
      v62 = v35;
LABEL_58:
      v70 = (*(_DWORD *)(v33 + 28) >> 31) & 1;
      v36 = *(_DWORD *)(v33 + 20);
      v37 = 0;
      v66 = v36;
      if ( v36 )
      {
        v38 = *(_DWORD *)(*(_DWORD *)(v1 + 96) + 20);
        v39 = v1 + 3576;
        do
        {
          *(&v64 + 2 * v37) = *(_DWORD *)(v39 + 4);
          v65[2 * v37++] = *(_DWORD *)v39;
          v39 += 32;
        }
        while ( v37 < v38 );
      }
      v40 = *(_DWORD *)(v1 + 4172);
      v41 = v1 + 4272;
      v42 = *(_DWORD *)(v1 + 4168);
      *(_DWORD *)(v1 + 4796) = v1 + 4;
      *(_DWORD *)(v41 + 512) = GetCurrentThreadId();
      *(_DWORD *)(v41 + 516) = 0;
      v43 = sub_10065A10(v42, v1 + 4272, ArgList, v40);
      *(_DWORD *)(v41 + 524) = 0;
      return v43 != 0;
    case 0xA:
      sub_10094340("crn_comp::quantize_chunks: This class does not support ETC1");
      break;
    default:
      return 0;
  }
  return 0;
}
// 10079CA0: using guessed type int var_90[31];

//----- (1007A2D0) --------------------------------------------------------
char __stdcall sub_1007A2D0(int a1)
{
  char v2; // bl@4
  int v3; // eax@5
  int v4; // esi@14
  int v5; // eax@15
  int v6; // eax@20
  unsigned int v7; // eax@26
  int v8; // edi@27
  int v9; // eax@39
  int v10; // ecx@39
  int v11; // eax@46
  int v12; // ecx@46
  unsigned int v13; // ecx@46
  int v14; // ecx@46
  unsigned int v15; // esi@50
  int v16; // eax@51
  unsigned int *v17; // edi@53
  unsigned int v18; // esi@54
  int v19; // edx@67
  int v20; // [sp+4h] [bp-B8h]@14
  unsigned int v21; // [sp+4h] [bp-B8h]@26
  signed int v22; // [sp+8h] [bp-B4h]@14
  int v23; // [sp+8h] [bp-B4h]@53
  int v24; // [sp+Ch] [bp-B0h]@28
  signed int v25; // [sp+Ch] [bp-B0h]@53
  char v26; // [sp+10h] [bp-ACh]@40
  char v27; // [sp+14h] [bp-A8h]@4
  char v28; // [sp+20h] [bp-9Ch]@12
  char v29; // [sp+2Ch] [bp-90h]@4
  char v30; // [sp+38h] [bp-84h]@11
  char v31; // [sp+44h] [bp-78h]@28
  int v32; // [sp+60h] [bp-5Ch]@29
  int v33; // [sp+64h] [bp-58h]@29
  int v34; // [sp+68h] [bp-54h]@29
  int v35; // [sp+6Ch] [bp-50h]@29
  unsigned int v36; // [sp+70h] [bp-4Ch]@29
  int v37; // [sp+74h] [bp-48h]@29
  int v38; // [sp+78h] [bp-44h]@29
  unsigned int v39; // [sp+7Ch] [bp-40h]@29
  int v40; // [sp+80h] [bp-3Ch]@29
  int v41; // [sp+84h] [bp-38h]@29
  int v42; // [sp+88h] [bp-34h]@29
  int v43; // [sp+8Ch] [bp-30h]@29
  int v44; // [sp+90h] [bp-2Ch]@29
  char v45; // [sp+94h] [bp-28h]@43
  int v46; // [sp+98h] [bp-24h]@39
  int v47; // [sp+9Ch] [bp-20h]@39
  int v48; // [sp+A0h] [bp-1Ch]@39
  int v49; // [sp+A4h] [bp-18h]@39
  int v50; // [sp+ACh] [bp-10h]@29
  int v51; // [sp+B8h] [bp-4h]@4

  if ( !sub_10075CE0(a1) )
    return 0;
  sub_10074F00(a1);
  if ( !sub_10079CA0(a1) )
    return 0;
  sub_100742C0(a1);
  `eh vector constructor iterator'(&v29, 0xCu, 2, (int)unknown_libname_3, sub_10038C00);
  v2 = 0;
  v51 = 0;
  `eh vector constructor iterator'(&v27, 0xCu, 2, (int)unknown_libname_3, sub_10038C00);
  LOBYTE(v51) = 1;
  if ( *(_BYTE *)(a1 + 4080) )
  {
    LOBYTE(v3) = sub_10079940((int)&v29, a1);
    if ( !(_BYTE)v3 )
    {
      LOBYTE(v51) = 0;
      `eh vector destructor iterator'(&v27, 0xCu, 2, sub_10038C00);
      v51 = -1;
      `eh vector destructor iterator'(&v29, 0xCu, 2, sub_10038C00);
      return 0;
    }
    if ( !sub_100795B0(v3, a1, (int)&v27) )
    {
      LOBYTE(v51) = 0;
      `eh vector destructor iterator'(&v27, 0xCu, 2, sub_10038C00);
      v51 = -1;
      `eh vector destructor iterator'(&v29, 0xCu, 2, sub_10038C00);
      return 0;
    }
    v2 = 0;
  }
  if ( *(_BYTE *)(a1 + 4081) != v2 && (!sub_10078C00(a1, (int)&v30) || !sub_10078240(a1, (int)&v28)) )
  {
    LOBYTE(v51) = v2;
    `eh vector destructor iterator'(&v27, 0xCu, 2, sub_10038C00);
    v51 = -1;
    `eh vector destructor iterator'(&v29, 0xCu, 2, sub_10038C00);
    return 0;
  }
  sub_1003C8F0(a1 + 4808);
  v20 = a1 + 4976;
  v4 = a1 + 4864;
  v22 = 2;
  do
  {
    v5 = *(_DWORD *)(v4 - 8);
    if ( v5 )
    {
      if ( v5 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
      *(_DWORD *)(v4 - 8) = 0;
      *(_DWORD *)(v4 - 4) = 0;
      *(_DWORD *)v4 = 0;
    }
    sub_1005C4E0(v20 - 96);
    v6 = *(_DWORD *)(v4 + 88);
    if ( v6 )
    {
      if ( v6 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v6, 0, 0, 1, dword_100AE9F4);
      *(_DWORD *)(v4 + 88) = 0;
      *(_DWORD *)(v4 + 92) = 0;
      *(_DWORD *)(v4 + 96) = 0;
    }
    sub_1005C4E0(v20);
    v20 += 36;
    v4 += 12;
    --v22;
  }
  while ( v22 );
  v7 = 0;
  v21 = 0;
  do
  {
    v8 = 0;
    if ( *(_DWORD *)(a1 + 4072) > 0u )
    {
      v24 = v7 != 0 ? (unsigned int)&v31 : 0;
      while ( 1 )
      {
        v35 = 0;
        v36 = 0;
        v37 = 0;
        v38 = 0;
        v39 = 0;
        v40 = 0;
        v41 = 0;
        v42 = 0;
        v43 = 0;
        LOBYTE(v51) = 4;
        sub_1005BFA0((int)&v31);
        LOBYTE(v51) = 5;
        v50 = 1;
        v34 = 0;
        v44 = 0;
        v32 = 0;
        v33 = 32;
        if ( v36 )
        {
          if ( v36 <= 0 )
            memset((void *)(v35 + v36), 0, -v36);
          v36 = 0;
        }
        sub_10032F10((int)&v35, 0x200000u);
        if ( v42 )
          v42 = 0;
        if ( v39 )
        {
          if ( v39 <= 0 )
            memset((void *)(v38 + v39), 0, -v39);
          v39 = 0;
        }
        v9 = *(_BYTE *)(a1 + 4081) != 0 ? (unsigned int)&v28 : 0;
        v10 = *(_BYTE *)(a1 + 4081) != 0 ? (unsigned int)&v30 : 0;
        v46 = 0;
        v47 = 0;
        v48 = -1;
        v49 = 0;
        if ( v21 || (v26 = 1, v8) )
          v26 = v2;
        if ( !sub_10075010(
                *(_DWORD *)(*(_DWORD *)(a1 + 4068) + 8 * v8),
                a1,
                *(_DWORD *)(*(_DWORD *)(a1 + 4068) + 8 * v8 + 4),
                v26,
                v24,
                *(_BYTE *)(a1 + 4080) != 0 ? (unsigned int)&v29 : 0,
                *(_BYTE *)(a1 + 4080) != 0 ? (unsigned int)&v27 : 0,
                v10,
                v9) )
          break;
        sub_1005CC00((int)&v31);
        if ( v45 == v2 )
          sub_1005D260((int)&v31);
        v50 = 0;
        if ( v21 )
        {
          v11 = a1 + 12 * v8 + 5048;
          v12 = *(_DWORD *)v11;
          *(_DWORD *)v11 = v35;
          v35 = v12;
          v13 = *(_DWORD *)(a1 + 12 * v8 + 5052);
          *(_DWORD *)(v11 + 4) = v36;
          v36 = v13;
          v14 = *(_DWORD *)(a1 + 12 * v8 + 5056);
          *(_DWORD *)(v11 + 8) = v37;
          v37 = v14;
        }
        LOBYTE(v51) = 1;
        sub_10036930((int)&v31);
        if ( (unsigned int)++v8 >= *(_DWORD *)(a1 + 4072) )
        {
          v7 = v21;
          goto LABEL_49;
        }
      }
      LOBYTE(v51) = 1;
      sub_10036930((int)&v31);
      goto LABEL_64;
    }
LABEL_49:
    if ( !v7 )
    {
      v15 = *(_DWORD *)(a1 + 4812);
      if ( v15 )
        v16 = *(_DWORD *)(a1 + 4808);
      else
        v16 = 0;
      sub_1005C930(v15, a1 + 4820, v16, 0x10u);
      v23 = a1 + 4976;
      v17 = (unsigned int *)(a1 + 4956);
      v25 = 2;
      do
      {
        v18 = *(v17 - 24);
        if ( v18 )
          sub_1005C930(v18, v23 - 96, *(v17 - 25), 0x10u);
        if ( *v17 )
          sub_1005C930(*v17, v23, *(v17 - 1), 0x10u);
        v23 += 36;
        v17 += 3;
        --v25;
      }
      while ( v25 );
      v7 = v21;
    }
    v21 = ++v7;
  }
  while ( v7 < 2 );
  if ( !sub_10076260(a1) )
  {
    LOBYTE(v51) = v2;
    `eh vector destructor iterator'(&v27, 0xCu, 2, sub_10038C00);
    v51 = -1;
    `eh vector destructor iterator'(&v29, 0xCu, 2, sub_10038C00);
    return 0;
  }
  if ( !sub_100739F0(a1) )
  {
    LOBYTE(v51) = v2;
    `eh vector destructor iterator'(&v27, 0xCu, 2, sub_10038C00);
    v51 = -1;
    `eh vector destructor iterator'(&v29, 0xCu, 2, sub_10038C00);
    return 0;
  }
  v19 = *(_DWORD *)(a1 + 96);
  if ( *(_DWORD *)(v19 + 476)
    && (*(int (__cdecl **)(signed int, signed int, signed int, signed int, _DWORD))(v19 + 476))(
         24,
         25,
         1,
         1,
         *(_DWORD *)(v19 + 480)) == 0 )
  {
LABEL_64:
    LOBYTE(v51) = v2;
    `eh vector destructor iterator'(&v27, 0xCu, 2, sub_10038C00);
    v51 = -1;
    `eh vector destructor iterator'(&v29, 0xCu, 2, sub_10038C00);
    return 0;
  }
  LOBYTE(v51) = 0;
  `eh vector destructor iterator'(&v27, 0xCu, 2, sub_10038C00);
  v51 = -1;
  `eh vector destructor iterator'(&v29, 0xCu, 2, sub_10038C00);
  return 1;
}
// 1003F6D0: using guessed type int unknown_libname_3();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1007A960) --------------------------------------------------------
char __thiscall sub_1007A960(void *this, int a2, float *a3)
{
  int v3; // ebp@1
  float *v4; // ebx@1
  unsigned int v5; // ecx@3
  unsigned int v6; // eax@3
  unsigned int v7; // esi@3
  char result; // al@9
  int v9; // eax@12
  unsigned int v10; // edx@12
  int v11; // edi@13
  int v12; // esi@13
  int v13; // ecx@15
  int v14; // eax@15
  int v15; // [sp+Ch] [bp-8h]@13
  int v16; // [sp+10h] [bp-4h]@13
  char v17; // [sp+18h] [bp+4h]@10

  v3 = (int)this;
  sub_100744C0((int)this);
  v4 = a3;
  if ( a3 )
    *a3 = 0.0;
  *(_DWORD *)(v3 + 96) = a2;
  v5 = *(_DWORD *)(a2 + 12);
  v6 = *(_DWORD *)(a2 + 16);
  v7 = v5;
  if ( v5 >= v6 )
    v7 = *(_DWORD *)(a2 + 16);
  if ( v7 < 1 )
    goto LABEL_24;
  if ( v5 > v6 )
    v6 = *(_DWORD *)(a2 + 12);
  if ( v6 > 0x1000 )
  {
LABEL_24:
    result = 0;
  }
  else
  {
    result = sub_100917D0(*(_DWORD *)(a2 + 464), v3 + 4);
    if ( result )
    {
      v17 = sub_1007A2D0(v3);
      sub_10091720(v3 + 4);
      if ( v17 && a3 )
      {
        v9 = *(_DWORD *)(v3 + 96);
        v10 = 0;
        if ( *(_DWORD *)(v9 + 8) )
        {
          v11 = *(_DWORD *)(v3 + 96);
          v16 = *(_DWORD *)(v9 + 20);
          v12 = v3 + 100;
          v15 = *(_DWORD *)(v11 + 8);
          do
          {
            if ( v16 )
            {
              v13 = *(_DWORD *)(v11 + 20);
              v14 = v12;
              do
              {
                v10 += *(_DWORD *)v14 * *(_DWORD *)(v14 + 4);
                v14 += 36;
                --v13;
              }
              while ( v13 );
              v4 = a3;
            }
            v12 += 576;
            --v15;
          }
          while ( v15 );
        }
        *v4 = (double)*(unsigned int *)(v3 + 4264) * 8.0 / (double)v10;
      }
      result = v17;
    }
  }
  return result;
}

//----- (1007AA80) --------------------------------------------------------
int *__usercall sub_1007AA80@<eax>(int *result@<eax>, int *a2@<ecx>)
{
  int v2; // edx@1
  int v3; // esi@1
  int v4; // ebx@2
  int v5; // edi@6

  v2 = *result;
  v3 = *a2;
  *result = 1;
  if ( v2 >= 2 )
  {
    v4 = *result;
    do
      v4 *= 2;
    while ( 2 * v4 <= v2 );
    *result = v4;
  }
  *a2 = 1;
  if ( v3 >= 2 )
  {
    v5 = *a2;
    do
    {
      result = (int *)v5;
      v5 *= 2;
    }
    while ( 2 * v5 <= v3 );
    *a2 = v5;
  }
  return result;
}

//----- (1007AAD0) --------------------------------------------------------
unsigned int __fastcall sub_1007AAD0(int *a1, unsigned int *a2)
{
  int v2; // eax@1
  unsigned int v3; // eax@3
  unsigned int v4; // eax@3
  unsigned int result; // eax@4
  unsigned int v6; // eax@6

  v2 = *a1;
  if ( !*a1 || (v2 - 1) & v2 )
  {
    v3 = ((((unsigned int)(v2 - 1) >> 16) | (v2 - 1)) >> 8) | ((unsigned int)(v2 - 1) >> 16) | (v2 - 1);
    v4 = (((v3 >> 4) | v3) >> 2) | (v3 >> 4) | v3;
    *a1 = (v4 | (v4 >> 1)) + 1;
  }
  result = *a2;
  if ( !*a2 || (result - 1) & result )
  {
    v6 = ((((result - 1) >> 16) | (result - 1)) >> 8) | ((result - 1) >> 16) | (result - 1);
    result = (((v6 >> 4) | v6) >> 2) | (v6 >> 4) | v6;
    *a2 = (result | (result >> 1)) + 1;
  }
  return result;
}

//----- (1007AC30) --------------------------------------------------------
char __stdcall sub_1007AC30(int a1, int a2, int a3, int a4, unsigned int a5)
{
  int v5; // esi@1
  int v6; // edi@1
  unsigned int v7; // ebp@5
  int v8; // ebx@5
  unsigned int v9; // eax@5
  int v10; // edx@7
  int v11; // eax@7
  _BYTE *v12; // ecx@7
  int v13; // edi@7
  unsigned int v14; // ebx@8
  unsigned int v15; // esi@8
  int v16; // ebx@9
  __int64 v17; // rax@10
  __int64 v18; // rax@10
  __int64 v19; // rax@10
  __int64 v20; // rax@10
  _BYTE *v21; // ecx@13
  int v22; // ebp@13
  int v23; // ebx@13
  __int64 v24; // rax@14
  bool v25; // zf@16
  long double v26; // st7@19
  double v27; // st6@19
  double v28; // st5@19
  unsigned int v29; // ecx@19
  char *v30; // edx@19
  int v31; // edi@21
  double v32; // st4@23
  double v33; // st2@23
  int v34; // edi@25
  double v35; // st4@27
  double v36; // st2@27
  unsigned int v37; // eax@29
  double v38; // st4@31
  double v39; // st2@31
  int v40; // edi@33
  double v41; // st4@35
  double v42; // st2@35
  unsigned int v43; // eax@37
  double v44; // st4@41
  double v45; // rt0@41
  double v46; // st4@41
  double v47; // st6@41
  long double v48; // st6@45
  double v49; // st7@48
  char result; // al@49
  long double v51; // st7@50
  double v52; // st6@50
  unsigned int v53; // [sp+14h] [bp-81Ch]@5
  int v54; // [sp+18h] [bp-818h]@1
  unsigned int v55; // [sp+1Ch] [bp-814h]@3
  int v56; // [sp+20h] [bp-810h]@7
  int v57; // [sp+24h] [bp-80Ch]@7
  int v58; // [sp+28h] [bp-808h]@7
  int v59; // [sp+2Ch] [bp-804h]@7
  double v60; // [sp+30h] [bp-800h]@5
  char v61; // [sp+38h] [bp-7F8h]@19

  v5 = a3;
  v6 = a2;
  v54 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 >= *(_DWORD *)a3 )
    v54 = *(_DWORD *)a3;
  v55 = *(_DWORD *)(a2 + 4);
  if ( v55 >= *(_DWORD *)(a3 + 4) )
    v55 = *(_DWORD *)(a3 + 4);
  memset(&v60, 0, 0x800u);
  v7 = v55;
  v8 = v54;
  v9 = 0;
  v53 = 0;
  if ( v55 )
  {
    do
    {
      if ( v8 )
      {
        v10 = *(_DWORD *)(v5 + 20) + 4 * v9 * *(_DWORD *)(v5 + 8);
        v11 = *(_DWORD *)(v6 + 20) + 4 * v9 * *(_DWORD *)(v6 + 8);
        v12 = (_BYTE *)(v11 + a4);
        v56 = v10;
        v57 = v11;
        v59 = v11 + a4;
        v13 = v10 + a4 + 2;
        v58 = v8;
        do
        {
          v14 = a5;
          v15 = 0;
          if ( (signed int)a5 >= 4 )
          {
            v16 = v10 - v11;
            do
            {
              v17 = *v12 - v12[v16];
              LODWORD(v17) = (HIDWORD(v17) ^ v17) - HIDWORD(v17);
              HIDWORD(v17) = *(_BYTE *)(v13 + v15 - 1);
              v15 += 4;
              v12 += 4;
              *(&v60 + (unsigned int)v17) = *(&v60 + (unsigned int)v17) + 1.0;
              v18 = *(v12 - 3) - HIDWORD(v17);
              LODWORD(v18) = (HIDWORD(v18) ^ v18) - HIDWORD(v18);
              HIDWORD(v18) = *(_BYTE *)(v13 + v15 - 4);
              *(&v60 + (unsigned int)v18) = *(&v60 + (unsigned int)v18) + 1.0;
              v19 = *(v12 - 2) - HIDWORD(v18);
              LODWORD(v19) = (HIDWORD(v19) ^ v19) - HIDWORD(v19);
              HIDWORD(v19) = *(_BYTE *)(v13 + v15 - 3);
              *(&v60 + (unsigned int)v19) = *(&v60 + (unsigned int)v19) + 1.0;
              v20 = *(v12 - 1) - HIDWORD(v19);
              *(&v60 + (HIDWORD(v20) ^ (unsigned int)v20) - HIDWORD(v20)) = *(&v60
                                                                            + (HIDWORD(v20) ^ (unsigned int)v20)
                                                                            - HIDWORD(v20))
                                                                          + 1.0;
            }
            while ( v15 < a5 - 3 );
            v14 = a5;
            v10 = v56;
            v11 = v57;
          }
          if ( v15 < v14 )
          {
            v21 = (_BYTE *)(a4 + v11 + v15);
            v22 = v10 - v11;
            v23 = v14 - v15;
            do
            {
              v24 = *v21 - v21[v22];
              ++v21;
              --v23;
              *(&v60 + (HIDWORD(v24) ^ (unsigned int)v24) - HIDWORD(v24)) = *(&v60
                                                                            + (HIDWORD(v24) ^ (unsigned int)v24)
                                                                            - HIDWORD(v24))
                                                                          + 1.0;
            }
            while ( v23 );
            v10 = v56;
            v11 = v57;
          }
          v11 += 4;
          v12 = (_BYTE *)(v59 + 4);
          v10 += 4;
          v13 += 4;
          v25 = v58-- == 1;
          v57 = v11;
          v59 += 4;
          v56 = v10;
        }
        while ( !v25 );
        v9 = v53;
        v5 = a3;
        v6 = a2;
        v8 = v54;
        v7 = v55;
      }
      v53 = ++v9;
    }
    while ( v9 < v7 );
  }
  v26 = 0.0;
  v27 = 0.0;
  *(_DWORD *)a1 = 0;
  v28 = 0.0;
  v29 = 2;
  v30 = &v61;
  do
  {
    if ( 0.0 != *((double *)v30 - 1) )
    {
      v31 = *(_DWORD *)a1;
      if ( *(_DWORD *)a1 <= v29 - 2 )
        v31 = v29 - 2;
      v32 = (double)(v29 - 2);
      *(_DWORD *)a1 = v31;
      v33 = *((double *)v30 - 1) * v32;
      v27 = v27 + v33;
      v28 = v28 + v32 * v33;
    }
    if ( 0.0 != *(double *)v30 )
    {
      v34 = *(_DWORD *)a1;
      if ( *(_DWORD *)a1 <= v29 - 1 )
        v34 = v29 - 1;
      v35 = (double)(v29 - 1);
      *(_DWORD *)a1 = v34;
      v36 = *(double *)v30 * v35;
      v27 = v27 + v36;
      v28 = v28 + v35 * v36;
    }
    if ( 0.0 != *((double *)v30 + 1) )
    {
      v37 = *(_DWORD *)a1;
      if ( *(_DWORD *)a1 <= v29 )
        v37 = v29;
      *(_DWORD *)a1 = v37;
      v38 = (double)v29;
      v39 = v38 * *((double *)v30 + 1);
      v27 = v27 + v39;
      v28 = v28 + v38 * v39;
    }
    if ( 0.0 != *((double *)v30 + 2) )
    {
      v40 = *(_DWORD *)a1;
      if ( *(_DWORD *)a1 <= v29 + 1 )
        v40 = v29 + 1;
      v41 = (double)(v29 + 1);
      *(_DWORD *)a1 = v40;
      v42 = *((double *)v30 + 2) * v41;
      v27 = v27 + v42;
      v28 = v28 + v41 * v42;
    }
    v29 += 4;
    v30 += 32;
  }
  while ( v29 - 2 < 0x100 );
  v43 = a5;
  if ( a5 >= 1 )
  {
    if ( a5 > 4 )
      v43 = 4;
  }
  else
  {
    v43 = 1;
  }
  v44 = (double)(v8 * v7) * (double)v43;
  v45 = v44;
  v46 = v27 / v44;
  v47 = v45;
  if ( v46 >= 0.0 )
  {
    if ( v46 > 255.0 )
      v46 = 255.0;
  }
  else
  {
    v46 = 0.0;
  }
  *(double *)(a1 + 8) = v46;
  v48 = v28 / v47;
  if ( v48 >= 0.0 )
  {
    v26 = v48;
    if ( v48 > 65025.0 )
      v26 = 65025.0;
  }
  *(long double *)(a1 + 16) = v26;
  v49 = sqrt(v26);
  *(double *)(a1 + 24) = v49;
  if ( 0.0 == v49 )
  {
    result = 1;
    *(double *)(a1 + 32) = 999999.0;
  }
  else
  {
    v51 = log10(255.0 / v49) * 20.0;
    v52 = 0.0;
    if ( v51 >= 0.0 && (v52 = 500.0, v51 <= 500.0) )
    {
      *(long double *)(a1 + 32) = v51;
      result = 1;
    }
    else
    {
      result = 1;
      *(double *)(a1 + 32) = v52;
    }
  }
  return result;
}

//----- (1007B080) --------------------------------------------------------
signed int __usercall sub_1007B080@<eax>(unsigned int a1@<eax>, unsigned int a2@<ecx>)
{
  double v2; // st4@2
  double v3; // st5@2
  double v4; // st4@4
  double v5; // rtt@6
  double v6; // st6@7
  double v7; // st7@7
  double v8; // st6@9
  float v9; // ST04_4@11
  float v10; // ST04_4@11
  float v11; // ST00_4@11
  double v12; // st7@11
  double v13; // st7@12
  float v14; // ST00_4@18
  signed int result; // eax@18
  float v16; // [sp+0h] [bp-8h]@2
  float v17; // [sp+4h] [bp-4h]@1
  float v18; // [sp+4h] [bp-4h]@7
  float v19; // [sp+4h] [bp-4h]@8
  float v20; // [sp+4h] [bp-4h]@9

  v17 = ((double)a1 - 128.0) / 127.0;
  if ( v17 >= -1.0 )
  {
    if ( v17 <= 1.0 )
    {
      v4 = 1.0;
      v16 = ((double)a1 - 128.0) / 127.0;
    }
    else
    {
      v4 = 1.0;
      v16 = 1.0;
    }
    v5 = v4;
    v2 = -1.0;
    v3 = v5;
  }
  else
  {
    v2 = -1.0;
    v3 = 1.0;
    v16 = -1.0;
  }
  v6 = v2;
  v7 = v3;
  v18 = ((double)a2 - 128.0) / 127.0;
  if ( v18 < v2 || (v6 = v18, v18 <= v3) )
    v19 = v6;
  else
    v19 = v3;
  v20 = 1.0 - v16 * v16 - v19 * v19;
  v8 = 0.0;
  if ( v20 < 0.0 || (v8 = v20, v20 <= v3) )
    v7 = v8;
  v9 = v7;
  v10 = sqrt(v9);
  v11 = v10 * 127.0 + 128.0;
  v12 = v11;
  if ( v11 >= 128.0 )
    v13 = v12 + 0.5;
  else
    v13 = v12 - 0.5;
  v14 = v13;
  result = (signed int)v14;
  if ( result >= 0 )
  {
    if ( result > 255 )
      result = 255;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1007B1D0) --------------------------------------------------------
void __usercall sub_1007B1D0(int a1@<ebx>)
{
  double v1; // st7@2
  double v2; // st6@2
  unsigned int v3; // eax@3
  int v4; // edx@4
  int v5; // ecx@4
  unsigned __int8 v6; // al@4
  int v7; // esi@4
  signed int v8; // ecx@7
  int v9; // edx@7
  float v10; // ST20_4@7
  float v11; // ST20_4@7
  float v12; // ST20_4@7
  float v13; // ST20_4@7
  double v14; // st6@7
  signed int v15; // eax@8
  float v16; // ST20_4@11
  float v17; // ST20_4@11
  unsigned int v18; // edi@14
  float v19; // ST20_4@15
  double v20; // st7@15
  float v21; // ST20_4@18
  float v22; // [sp+20h] [bp-28h]@15
  unsigned int v23; // [sp+24h] [bp-24h]@1
  unsigned int v24; // [sp+28h] [bp-20h]@3
  float v25; // [sp+30h] [bp-18h]@7
  float v26; // [sp+34h] [bp-14h]@7
  float v27; // [sp+38h] [bp-10h]@7
  int v28; // [sp+3Ch] [bp-Ch]@7
  int v29; // [sp+40h] [bp-8h]@7
  int v30; // [sp+44h] [bp-4h]@7

  v23 = 0;
  if ( *(_DWORD *)(a1 + 4) )
  {
    v1 = 0.003921568859368563;
    v2 = 2.0;
    do
    {
      v3 = 0;
      v24 = 0;
      if ( *(_DWORD *)a1 )
      {
        do
        {
          v4 = *(_DWORD *)(a1 + 20);
          v5 = v3 + v23 * *(_DWORD *)(a1 + 8);
          v6 = *(_BYTE *)(v4 + 4 * v5);
          v7 = v4 + 4 * v5;
          if ( v6 != -128 || *(_BYTE *)(v7 + 1) != v6 || *(_BYTE *)(v7 + 2) != v6 )
          {
            v8 = *(_BYTE *)(v7 + 1);
            v9 = *(_BYTE *)(v7 + 2);
            v28 = 1065353216;
            v29 = 1065353216;
            v30 = 1065353216;
            v25 = (double)v6;
            v26 = (double)v8;
            v27 = (double)v9;
            v25 = v25 * v1;
            v26 = v26 * v1;
            v27 = v1 * v27;
            v25 = v25 * v2;
            v26 = v26 * v2;
            v27 = v2 * v27;
            v25 = v25 - 1.0;
            v26 = v26 - 1.0;
            v27 = v27 - 1.0;
            sub_100365F0((int)&v25, v9, -1.0, 1.0);
            v10 = v25 * v25;
            v11 = v26 * v26 + v10;
            v12 = v27 * v27 + v11;
            v13 = sqrt(v12);
            v14 = v13;
            if ( v13 >= 0.077 )
            {
              v16 = v14 - 1.0;
              v17 = fabs(v16);
              if ( v17 > 0.077 )
              {
                if ( 0.0 != v14 )
                {
                  v25 = v25 / v14;
                  v26 = v26 / v14;
                  v27 = v27 / v14;
                }
                v18 = 0;
                do
                {
                  v19 = (*(&v25 + v18) + 1.0) * 0.5 * 255.0 + 0.5;
                  v22 = floor(v19);
                  v20 = 0.0;
                  if ( v22 >= 0.0 )
                  {
                    v20 = v22;
                    if ( v22 > 255.0 )
                      v20 = 255.0;
                  }
                  v21 = v20;
                  *(_BYTE *)(++v18 + v7 - 1) = (signed int)v21;
                }
                while ( v18 < 3 );
                if ( *(_BYTE *)v7 == -128 && *(_BYTE *)(v7 + 1) == -128 )
                  *(_BYTE *)(v7 + 2) = *(_BYTE *)(v7 + 2) < 0x80u ? 0 : -1;
              }
            }
            else
            {
              v15 = *(_BYTE *)(v7 + 3);
              *(_WORD *)v7 = -32640;
              *(_BYTE *)(v7 + 2) = -128;
              if ( v15 & 0xFFFFFF00 )
                LOBYTE(v15) = ~(v15 >> 31);
              *(_BYTE *)(v7 + 3) = v15;
            }
          }
          v1 = 0.003921568859368563;
          v2 = 2.0;
          v3 = v24 + 1;
          v24 = v3;
        }
        while ( v3 < *(_DWORD *)a1 );
      }
      ++v23;
    }
    while ( v23 < *(_DWORD *)(a1 + 4) );
  }
}

//----- (1007B4C0) --------------------------------------------------------
unsigned int __cdecl sub_1007B4C0(int a1, unsigned int a2)
{
  unsigned int result; // eax@1
  bool v3; // zf@12
  int v4; // ecx@14
  int v5; // edx@14
  unsigned int v6; // eax@14
  char v7; // bl@14
  int v8; // edi@14
  char v9; // dl@14
  char v10; // cl@14
  char v11; // al@29
  char v12; // dl@29
  char v13; // cl@29
  unsigned int v14; // eax@29
  char v15; // [sp+14h] [bp-10h]@15
  char v16; // [sp+15h] [bp-Fh]@18
  char v17; // [sp+16h] [bp-Eh]@17
  char v18; // [sp+17h] [bp-Dh]@17
  char v19; // [sp+18h] [bp-Ch]@14
  char v20; // [sp+19h] [bp-Bh]@14
  char v21; // [sp+1Ah] [bp-Ah]@14
  char v22; // [sp+1Bh] [bp-9h]@14
  unsigned int v23; // [sp+1Ch] [bp-8h]@13
  unsigned int v24; // [sp+20h] [bp-4h]@12

  result = a2;
  switch ( a2 )
  {
    case 0u:
      *(_DWORD *)(a1 + 16) = 75;
      goto LABEL_12;
    case 1u:
      *(_DWORD *)(a1 + 16) = 7;
      goto LABEL_12;
    case 2u:
      *(_DWORD *)(a1 + 16) = 42;
      goto LABEL_12;
    case 3u:
    case 5u:
    case 8u:
      *(_DWORD *)(a1 + 16) = 39;
      goto LABEL_12;
    case 4u:
      *(_DWORD *)(a1 + 16) = 46;
      goto LABEL_12;
    case 6u:
    case 7u:
      *(_DWORD *)(a1 + 16) = 47;
      goto LABEL_12;
    case 9u:
      *(_DWORD *)(a1 + 16) |= 8u;
      goto LABEL_12;
    case 0xAu:
      *(_DWORD *)(a1 + 16) = 15;
      goto LABEL_12;
    case 0xBu:
      result = 8 * ((*(_DWORD *)(a1 + 16) >> 3) & 1) | 0x17;
      *(_DWORD *)(a1 + 16) = result;
      goto LABEL_12;
    case 0xCu:
      *(_DWORD *)(a1 + 16) |= 0x10u;
LABEL_12:
      v3 = *(_DWORD *)(a1 + 4) == 0;
      v24 = 0;
      if ( !v3 )
      {
        do
        {
          v3 = *(_DWORD *)a1 == 0;
          v23 = 0;
          if ( !v3 )
          {
            do
            {
              v4 = v23 + v24 * *(_DWORD *)(a1 + 8);
              v5 = *(_DWORD *)(a1 + 20);
              LOBYTE(v6) = *(_BYTE *)(v5 + 4 * v4 + 1);
              v7 = *(_BYTE *)(v5 + 4 * v4 + 3);
              v8 = v5 + 4 * v4;
              v9 = *(_BYTE *)v8;
              v10 = *(_BYTE *)(v8 + 2);
              v19 = *(_BYTE *)v8;
              v20 = v6;
              v21 = v10;
              v22 = v7;
              switch ( a2 )
              {
                case 0u:
                  sub_10036480((int)&v19, (int)&v15);
                  break;
                case 1u:
                  sub_10036540((int)&v19, (int)&v15);
                  break;
                case 2u:
                  v15 = 0;
                  v17 = 0;
                  v18 = v9;
                  goto LABEL_28;
                case 3u:
                  v16 = v6;
                  v15 = v7;
                  v17 = sub_1007B080((unsigned __int8)v7, (unsigned __int8)v6);
                  v18 = -1;
                  break;
                case 4u:
                  v15 = 0;
                  v18 = v9;
                  goto LABEL_27;
                case 5u:
                  v15 = v7;
                  v18 = -1;
                  goto LABEL_27;
                case 6u:
                  v16 = v6;
                  v15 = v7;
                  v17 = v21;
                  v18 = v9;
                  break;
                case 7u:
                  v10 = v21;
                  v15 = v7;
                  v18 = v9;
LABEL_27:
                  v17 = v10;
                  goto LABEL_28;
                case 8u:
                  v16 = v6;
                  v15 = v9;
                  v17 = sub_1007B080((unsigned __int8)v9, (unsigned __int8)v6);
                  v18 = -1;
                  break;
                case 9u:
                  v17 = v10;
                  v15 = v9;
                  v16 = v6;
                  v18 = (7471 * (unsigned __int8)v10
                       + 19595 * (unsigned __int8)v9
                       + 38470 * (unsigned int)(unsigned __int8)v6
                       + 0x8000) >> 16;
                  break;
                case 0xAu:
                  v15 = v7;
                  v16 = v7;
                  v17 = v7;
                  v18 = v7;
                  break;
                case 0xBu:
                case 0xCu:
                  v6 = (7471 * (unsigned __int8)v10
                      + 19595 * (unsigned __int8)v9
                      + 38470 * (unsigned int)(unsigned __int8)v6
                      + 0x8000) >> 16;
                  v15 = v6;
                  v17 = v6;
                  v18 = v7;
LABEL_28:
                  v16 = v6;
                  break;
              }
              v11 = v17;
              v12 = v16;
              *(_BYTE *)v8 = v15;
              v13 = v18;
              *(_BYTE *)(v8 + 2) = v11;
              v14 = v23 + 1;
              *(_BYTE *)(v8 + 1) = v12;
              *(_BYTE *)(v8 + 3) = v13;
              v23 = v14;
            }
            while ( v14 < *(_DWORD *)a1 );
          }
          result = v24 + 1;
          v24 = result;
        }
        while ( result < *(_DWORD *)(a1 + 4) );
      }
      break;
    default:
      return result;
  }
  return result;
}

//----- (1007B7A0) --------------------------------------------------------
char __cdecl sub_1007B7A0(int a1, int a2, int a3)
{
  float v3; // esi@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@1
  char result; // al@4
  signed int v7; // eax@5
  float v8; // eax@7
  unsigned int v9; // ecx@7
  unsigned int v10; // edx@7
  unsigned int v11; // edx@10
  char v12; // bl@16
  signed int v13; // esi@17
  signed int v14; // esi@20
  signed int v15; // eax@21
  double v16; // st7@26
  bool v17; // zf@26
  unsigned int v18; // eax@26
  float *v19; // edi@39
  int v20; // esi@39
  int v21; // ebx@40
  unsigned int v22; // ecx@41
  int v23; // eax@42
  unsigned __int8 v24; // dl@42
  double v25; // st6@44
  int v26; // esi@58
  unsigned int v27; // edx@58
  unsigned int v28; // eax@58
  int v29; // edx@63
  int v30; // eax@63
  unsigned int v31; // ebx@65
  unsigned int v32; // esi@65
  int v33; // edi@66
  signed int v34; // eax@69
  char v35; // dl@79
  float v36; // eax@79
  char v37; // cl@79
  char v38; // dl@79
  char *v39; // [sp-4h] [bp-252Ch]@31
  int v40; // [sp+10h] [bp-2518h]@1
  float v41; // [sp+14h] [bp-2514h]@18
  char *v42; // [sp+18h] [bp-2510h]@16
  int v43; // [sp+1Ch] [bp-250Ch]@17
  float v44; // [sp+20h] [bp-2508h]@1
  unsigned int v45; // [sp+24h] [bp-2504h]@37
  int v46; // [sp+28h] [bp-2500h]@19
  int v47; // [sp+2Ch] [bp-24FCh]@26
  unsigned int v48; // [sp+30h] [bp-24F8h]@7
  float v49; // [sp+34h] [bp-24F4h]@7
  void *v50; // [sp+38h] [bp-24F0h]@29
  int v51; // [sp+3Ch] [bp-24ECh]@29
  int v52; // [sp+40h] [bp-24E8h]@29
  void *v53; // [sp+44h] [bp-24E4h]@29
  int v54; // [sp+48h] [bp-24E0h]@29
  int v55; // [sp+4Ch] [bp-24DCh]@29
  float v56; // [sp+50h] [bp-24D8h]@67
  int v57; // [sp+54h] [bp-24D4h]@37
  char *v58; // [sp+58h] [bp-24D0h]@26
  int v59; // [sp+5Ch] [bp-24CCh]@26
  int v60; // [sp+60h] [bp-24C8h]@26
  int v61; // [sp+64h] [bp-24C4h]@26
  int v62; // [sp+68h] [bp-24C0h]@26
  int v63; // [sp+6Ch] [bp-24BCh]@26
  int v64; // [sp+70h] [bp-24B8h]@26
  int v65; // [sp+74h] [bp-24B4h]@26
  int v66; // [sp+78h] [bp-24B0h]@26
  void *v67; // [sp+7Ch] [bp-24ACh]@37
  int v68; // [sp+80h] [bp-24A8h]@26
  float v69; // [sp+84h] [bp-24A4h]@26
  int v70; // [sp+88h] [bp-24A0h]@37
  void *v71; // [sp+8Ch] [bp-249Ch]@37
  float v72; // [sp+90h] [bp-2498h]@26
  unsigned int v73; // [sp+94h] [bp-2494h]@26
  int v74; // [sp+98h] [bp-2490h]@37
  int v75; // [sp+9Ch] [bp-248Ch]@26
  float v76; // [sp+A0h] [bp-2488h]@26
  float v77; // [sp+A4h] [bp-2484h]@26
  int v78; // [sp+A8h] [bp-2480h]@26
  float v79; // [sp+ACh] [bp-247Ch]@26
  float v80; // [sp+B0h] [bp-2478h]@26
  char v81; // [sp+B4h] [bp-2474h]@26
  float v82; // [sp+110h] [bp-2418h]@18
  float v83[256]; // [sp+114h] [bp-2414h]@44
  char v84[8200]; // [sp+514h] [bp-2014h]@25
  int v85; // [sp+2524h] [bp-4h]@26

  v3 = *(float *)(a1 + 4);
  v4 = *(_DWORD *)a1;
  v40 = v4;
  v44 = v3;
  v5 = v4;
  if ( v4 <= LODWORD(v3) )
    v5 = LODWORD(v3);
  if ( v5 > 0x4000 )
  {
    printf("Image is too large!\n");
    return 1;
  }
  v7 = *(_DWORD *)(a3 + 24);
  if ( v7 < 1 || v7 > 4 )
    return 0;
  v8 = *(float *)a3;
  v9 = *(_DWORD *)(a3 + 4);
  v49 = v8;
  v48 = v9;
  v10 = LODWORD(v8);
  if ( LODWORD(v8) >= v9 )
    v10 = v9;
  if ( v10 < 1 )
    goto LABEL_93;
  v11 = LODWORD(v8);
  if ( LODWORD(v8) <= v9 )
    v11 = v9;
  if ( v11 > 0x4000 )
  {
LABEL_93:
    printf("Image is too large!\n");
    result = 1;
  }
  else
  {
    if ( v4 == LODWORD(v8) && LODWORD(v3) == v9 )
    {
      sub_10033C70(a2, a1);
      return 1;
    }
    sub_10034290(a2);
    v12 = *(_BYTE *)(a3 + 16);
    v42 = *(char **)(a3 + 28);
    if ( v12 )
    {
      v13 = 0;
      v43 = 0;
      do
      {
        v41 = (double)v43 / 255.0;
        v41 = pow(v41, *(float *)&v42);
        *(&v82 + ++v13) = v41;
        v43 = v13;
      }
      while ( v13 < 256 );
    }
    *(float *)&v46 = 1.0 / *(float *)&v42;
    if ( v12 )
    {
      v14 = 0;
      v43 = 0;
      do
      {
        v41 = (double)v43 * 0.0001220703125;
        v41 = pow(v41, *(float *)&v46);
        v15 = (signed int)(v41 * 255.0 + 0.5);
        if ( v15 >= 0 )
        {
          if ( v15 > 255 )
            LOBYTE(v15) = -1;
        }
        else
        {
          LOBYTE(v15) = 0;
        }
        v84[v14++] = v15;
        v43 = v14;
      }
      while ( v14 < 0x2000 );
    }
    sub_10091840((int)&v81);
    v85 = 0;
    sub_100917D0(dword_100AD974 - 1, (int)&v81);
    v58 = &v81;
    v59 = 0;
    v60 = 0;
    v61 = 0;
    v62 = 0;
    v63 = 0;
    v64 = 0;
    v65 = 0;
    memset(&v66, 0, 0x3Cu);
    v76 = 0.0;
    v77 = 1.0;
    v16 = *(float *)(a3 + 12);
    v68 = v40;
    v79 = v16;
    v80 = *(float *)(a3 + 12);
    v17 = *(_BYTE *)(a3 + 17) == 0;
    v69 = v44;
    v78 = *(_DWORD *)(a3 + 8);
    v18 = *(_DWORD *)(a3 + 24);
    v72 = v49;
    v73 = v48;
    v47 = 4;
    v75 = !v17 ? 0 : 2;
    if ( v18 == 1 )
    {
      v66 = 0;
      v47 = 1;
    }
    else
    {
      v66 = (v18 > 3) + 1;
    }
    *(float *)&v53 = 0.0;
    v54 = 0;
    v55 = 0;
    v50 = 0;
    v51 = 0;
    v52 = 0;
    LOBYTE(v85) = 3;
    if ( !sub_10036710((int)&v53, v40 * LODWORD(v44) * v47) )
    {
      LOBYTE(v85) = 2;
      sub_10038C00(&v50);
      LOBYTE(v85) = 1;
      sub_10038C00(&v53);
LABEL_31:
      LOBYTE(v85) = 0;
      sub_10093050((int)&v58);
      v85 = -1;
      v39 = &v81;
LABEL_32:
      sub_100918E0((int)v39);
      return 0;
    }
    if ( !sub_10036710((int)&v50, LODWORD(v49) * v48 * v47) )
    {
      LOBYTE(v85) = 2;
      sub_10038C00(&v50);
      LOBYTE(v85) = 1;
      sub_10038C00(&v53);
      LOBYTE(v85) = 0;
      sub_10093050((int)&v58);
      v85 = -1;
      v39 = &v81;
      goto LABEL_32;
    }
    v46 = 4 * v40 * v47;
    v70 = 4 * v40 * v47;
    v67 = v53;
    v71 = v50;
    v57 = 4 * LODWORD(v49) * v47;
    v74 = 4 * LODWORD(v49) * v47;
    v45 = 0;
    if ( v44 != 0.0 )
    {
      v42 = (char *)v53;
      do
      {
        v19 = (float *)v42;
        v20 = *(_DWORD *)(a1 + 20) + 4 * v45 * *(_DWORD *)(a1 + 8);
        if ( v40 )
        {
          v21 = v40;
          v43 = 4 * v47;
          do
          {
            v22 = 0;
            if ( *(_DWORD *)(a3 + 24) )
            {
              do
              {
                v23 = v22 + *(_DWORD *)(a3 + 20);
                v24 = *(_BYTE *)(v23 + v20);
                if ( *(_BYTE *)(a3 + 16) && v23 != 3 )
                {
                  v25 = v83[v24];
                }
                else
                {
                  LODWORD(v41) = v24;
                  v25 = (double)v24 * 0.003921568859368563;
                }
                v19[v22++] = v25;
              }
              while ( v22 < *(_DWORD *)(a3 + 24) );
            }
            v19 = (float *)((char *)v19 + v43);
            v20 += 4;
            --v21;
          }
          while ( v21 );
        }
        v42 += v46;
        ++v45;
      }
      while ( v45 < LODWORD(v44) );
    }
    if ( !sub_100935B0((int)&v66, (int)&v58) )
    {
      LOBYTE(v85) = 2;
      if ( v50 )
      {
        if ( (unsigned __int8)v50 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v50, 0, 0, 1, dword_100AE9F4);
      }
      LOBYTE(v85) = 1;
      if ( *(float *)&v53 != 0.0 )
      {
        if ( (unsigned __int8)v53 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v53, 0, 0, 1, dword_100AE9F4);
      }
      goto LABEL_31;
    }
    sub_1003C8F0((int)&v53);
    v26 = a2;
    v39 = (char *)-16777216;
    v27 = *(_DWORD *)(a3 + 4);
    v28 = *(_DWORD *)a3;
    v41 = COERCE_FLOAT(&v39);
    if ( !sub_10034090(a2, v28, v27, -16777216) )
    {
      LOBYTE(v85) = 2;
      sub_10038C00(&v50);
      LOBYTE(v85) = 1;
      sub_10038C00(&v53);
      LOBYTE(v85) = 0;
      sub_10093050((int)&v58);
      v85 = -1;
      v39 = &v81;
      goto LABEL_32;
    }
    v45 = 0;
    if ( v48 )
    {
      v44 = *(float *)&v50;
      while ( 1 )
      {
        v29 = v45 * *(_DWORD *)(v26 + 8);
        v30 = *(_DWORD *)(v26 + 20);
        *(float *)&v42 = v44;
        v46 = v30 + 4 * v29;
        if ( v49 != 0.0 )
        {
          v43 = 4 * v47;
          v41 = v49;
          do
          {
            v31 = *(_DWORD *)(a3 + 24);
            v32 = 0;
            v40 = -16777216;
            if ( v31 )
            {
              v33 = *(_DWORD *)(a3 + 20);
              do
              {
                v17 = *(_BYTE *)(a3 + 16) == 0;
                v56 = *(float *)&v42[4 * v32];
                if ( v17 || v33 == 3 )
                {
                  v34 = (signed int)(v56 * 255.0 + 0.5);
                  if ( v34 >= 0 )
                  {
                    if ( v34 > 255 )
                      LOBYTE(v34) = -1;
                  }
                  else
                  {
                    LOBYTE(v34) = 0;
                  }
                }
                else
                {
                  v34 = (signed int)(v56 * 8192.0 + 0.5);
                  if ( v34 >= 0 )
                  {
                    if ( v34 >= 0x2000 )
                      v34 = 0x1FFF;
                    LOBYTE(v34) = v84[v34];
                  }
                  else
                  {
                    LOBYTE(v34) = v84[0];
                  }
                }
                *((_BYTE *)&v40 + v33) = v34;
                ++v32;
                ++v33;
              }
              while ( v32 < v31 );
            }
            v35 = BYTE1(v40);
            v36 = *(float *)&v46;
            v46 += 4;
            *(_BYTE *)LODWORD(v36) = v40;
            v37 = BYTE2(v40);
            *(_BYTE *)(LODWORD(v36) + 1) = v35;
            v38 = BYTE3(v40);
            *(_BYTE *)(LODWORD(v36) + 2) = v37;
            *(_BYTE *)(LODWORD(v36) + 3) = v38;
            v42 += v43;
            --LODWORD(v41);
          }
          while ( v41 != 0.0 );
        }
        LODWORD(v44) += v57;
        if ( ++v45 >= v48 )
          break;
        v26 = a2;
      }
    }
    LOBYTE(v85) = 2;
    if ( v50 )
    {
      if ( (unsigned __int8)v50 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v50, 0, 0, 1, dword_100AE9F4);
    }
    LOBYTE(v85) = 1;
    if ( *(float *)&v53 != 0.0 )
    {
      if ( (unsigned __int8)v53 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v53, 0, 0, 1, dword_100AE9F4);
    }
    LOBYTE(v85) = 0;
    sub_10093050((int)&v58);
    v85 = -1;
    sub_100918E0((int)&v81);
    result = 1;
  }
  return result;
}
// 100AD974: using guessed type int dword_100AD974;
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 1007B7A0: using guessed type char var_2014[8200];
// 1007B7A0: using guessed type float var_2414[256];

//----- (1007BF30) --------------------------------------------------------
char __cdecl sub_1007BF30(int a1, int a2, int a3)
{
  unsigned int v3; // ebp@1
  unsigned int v4; // esi@1
  unsigned int v5; // eax@1
  char result; // al@4
  signed int v7; // eax@5
  unsigned int v8; // eax@7
  unsigned int v9; // ecx@7
  unsigned int v10; // edx@7
  unsigned int v11; // edx@10
  unsigned int v12; // ecx@16
  unsigned int v13; // edx@16
  char v14; // bl@16
  signed int v15; // esi@17
  signed int v16; // esi@20
  signed int v17; // eax@21
  void *v18; // ebp@26
  unsigned int v19; // edi@27
  char *v20; // esi@27
  int v21; // edx@29
  bool v22; // zf@29
  int v23; // eax@29
  int v24; // ecx@33
  int v25; // edx@33
  double v26; // st7@37
  unsigned int v27; // ebx@38
  int v28; // ebp@38
  unsigned int v29; // ecx@39
  char *v30; // esi@40
  int v31; // eax@41
  unsigned __int8 v32; // dl@41
  double v33; // st6@43
  unsigned int v34; // edi@47
  const void **v35; // ebp@48
  unsigned int v36; // ebx@52
  int v37; // edi@54
  int v38; // ebp@54
  unsigned int v39; // esi@58
  _BYTE *v40; // edi@59
  double v41; // st4@60
  signed int v42; // eax@61
  int v43; // ebx@77
  FILE *v44; // eax@79
  int v45; // ebx@82
  FILE *v46; // eax@84
  const char *v47; // [sp-4h] [bp-249Ch]@16
  float v48; // [sp+14h] [bp-2484h]@17
  float v49; // [sp+18h] [bp-2480h]@16
  char v50; // [sp+1Fh] [bp-2479h]@56
  signed int v51; // [sp+20h] [bp-2478h]@26
  float v52; // [sp+24h] [bp-2474h]@16
  unsigned int v53; // [sp+28h] [bp-2470h]@1
  unsigned int v54; // [sp+2Ch] [bp-246Ch]@1
  unsigned int v55; // [sp+30h] [bp-2468h]@7
  float v56; // [sp+34h] [bp-2464h]@26
  int v57; // [sp+38h] [bp-2460h]@26
  unsigned int v58; // [sp+3Ch] [bp-245Ch]@7
  int v59; // [sp+40h] [bp-2458h]@29
  void *v60; // [sp+44h] [bp-2454h]@26
  char v61; // [sp+54h] [bp-2444h]@26
  char v62; // [sp+64h] [bp-2434h]@27
  float v63; // [sp+80h] [bp-2418h]@18
  float DstBuf[256]; // [sp+84h] [bp-2414h]@43
  char v65[8200]; // [sp+484h] [bp-2014h]@25
  int v66; // [sp+2494h] [bp-4h]@26

  v3 = *(_DWORD *)a1;
  v4 = *(_DWORD *)(a1 + 4);
  v53 = v3;
  v54 = v4;
  v5 = v3;
  if ( v3 <= v4 )
    v5 = v4;
  if ( v5 > 0x4000 )
  {
    printf("Image is too large!\n");
    return 1;
  }
  v7 = *(_DWORD *)(a3 + 24);
  if ( v7 < 1 || v7 > 4 )
    return 0;
  v8 = *(_DWORD *)a3;
  v9 = *(_DWORD *)(a3 + 4);
  v55 = v8;
  v58 = v9;
  v10 = v8;
  if ( v8 >= v9 )
    v10 = v9;
  if ( v10 < 1 )
    goto LABEL_97;
  v11 = v8;
  if ( v8 <= v9 )
    v11 = v9;
  if ( v11 > 0x4000 )
  {
LABEL_97:
    printf("Image is too large!\n");
    result = 1;
  }
  else
  {
    if ( v3 == v8 && v4 == v9 )
    {
      sub_10033C70(a2, a1);
      return 1;
    }
    sub_10034290(a2);
    v47 = (const char *)-16777216;
    v12 = *(_DWORD *)(a3 + 4);
    v13 = *(_DWORD *)a3;
    v52 = COERCE_FLOAT(&v47);
    sub_10034090(a2, v13, v12, -16777216);
    v14 = *(_BYTE *)(a3 + 16);
    v49 = *(float *)(a3 + 28);
    if ( v14 )
    {
      v15 = 0;
      v48 = 0.0;
      do
      {
        v48 = (double)SLODWORD(v48) / 255.0;
        v48 = pow(v48, v49);
        *(&v63 + ++v15) = v48;
        v48 = *(float *)&v15;
      }
      while ( v15 < 256 );
    }
    v49 = 1.0 / v49;
    if ( v14 )
    {
      v16 = 0;
      v48 = 0.0;
      do
      {
        v48 = (double)SLODWORD(v48) * 0.0001220703125;
        v48 = pow(v48, v49);
        v17 = (signed int)(v48 * 255.0 + 0.5);
        if ( v17 >= 0 )
        {
          if ( v17 > 255 )
            LOBYTE(v17) = -1;
        }
        else
        {
          LOBYTE(v17) = 0;
        }
        v65[v16++] = v17;
        v48 = *(float *)&v16;
      }
      while ( v16 < 0x2000 );
    }
    `eh vector constructor iterator'(&v61, 0xCu, 4, (int)unknown_libname_3, sub_10038C00);
    v66 = 0;
    *(float *)&v51 = 1.0;
    v48 = 0.0;
    v49 = 0.0;
    v56 = 0.0;
    v57 = *(_BYTE *)(a3 + 17) != 0 ? 0 : 2;
    v18 = (void *)sub_10036770(
                    (int *)&v53,
                    (int *)&v54,
                    (int *)&v55,
                    (int *)&v58,
                    &v57,
                    &v56,
                    (float *)&v51,
                    (int *)(a3 + 8),
                    (int *)&v49,
                    (int *)&v48,
                    (float *)(a3 + 12),
                    (float *)(a3 + 12));
    v60 = v18;
    sub_100366C0((int)&v61, v53);
    v51 = 1;
    if ( *(_DWORD *)(a3 + 24) > 1u )
    {
      v19 = v53;
      v48 = 1.0;
      v20 = &v62;
      v49 = 0.0;
      while ( 1 )
      {
        v21 = *((_DWORD *)v18 + 10);
        v56 = *((float *)v18 + 9);
        v22 = *(_BYTE *)(a3 + 17) == 0;
        v57 = v21;
        v59 = !v22 ? 0 : 2;
        *(&v60 + v51) = (void *)sub_10036770(
                                  (int *)&v53,
                                  (int *)&v54,
                                  (int *)&v55,
                                  (int *)&v58,
                                  &v59,
                                  &v49,
                                  &v48,
                                  (int *)(a3 + 8),
                                  (int *)&v56,
                                  &v57,
                                  (float *)(a3 + 12),
                                  (float *)(a3 + 12));
        v23 = *(_DWORD *)v20;
        if ( v19 != *(_DWORD *)v20 )
        {
          if ( v19 >= *(_DWORD *)v20 )
          {
            if ( v19 > *((_DWORD *)v20 + 1) )
            {
              LOBYTE(v52) = v19 == v23 + 1;
              sub_100943C0(v19, 0, (int)(v20 - 4), v19 == v23 + 1, 4u, 0);
            }
            v24 = *(_DWORD *)v20;
            v25 = *((_DWORD *)v20 - 1);
            v47 = (const char *)(4 * (v19 - *(_DWORD *)v20));
            memset((void *)(v25 + 4 * v24), 0, (size_t)v47);
          }
          *(_DWORD *)v20 = v19;
        }
        v20 += 12;
        if ( (unsigned int)++v51 >= *(_DWORD *)(a3 + 24) )
          break;
        v18 = v60;
      }
    }
    v49 = 0.0;
    v48 = 0.0;
    if ( v54 )
    {
      v26 = 0.003921568859368563;
      while ( 1 )
      {
        v27 = 0;
        v28 = *(_DWORD *)(a1 + 20) + 4 * LODWORD(v48) * *(_DWORD *)(a1 + 8);
        if ( v53 )
        {
          do
          {
            v29 = 0;
            if ( *(_DWORD *)(a3 + 24) )
            {
              v30 = &v61;
              do
              {
                v31 = v29 + *(_DWORD *)(a3 + 20);
                v32 = *(_BYTE *)(v31 + v28);
                if ( *(_BYTE *)(a3 + 16) && v31 != 3 )
                {
                  v33 = DstBuf[v32];
                }
                else
                {
                  v52 = (double)v32 * v26;
                  v33 = v52;
                }
                ++v29;
                *(float *)(*(_DWORD *)v30 + 4 * v27) = v33;
                v30 += 12;
              }
              while ( v29 < *(_DWORD *)(a3 + 24) );
            }
            ++v27;
            v28 += 4;
          }
          while ( v27 < v53 );
        }
        v34 = 0;
        if ( *(_DWORD *)(a3 + 24) )
          break;
LABEL_52:
        v36 = v55;
        while ( 1 )
        {
          v22 = *(_DWORD *)(a3 + 24) == 0;
          *(float *)&v51 = 0.0;
          if ( !v22 )
          {
            do
            {
              v37 = v51 + *(_DWORD *)(a3 + 20);
              v38 = sub_100663E0((int)*(&v60 + v51));
              if ( !v38 )
                break;
              if ( *(_BYTE *)(a3 + 16) )
              {
                v50 = 0;
                if ( v37 != 3 )
                  continue;
              }
              v50 = 1;
              v39 = 0;
              if ( v36 )
              {
                v40 = (_BYTE *)(*(_DWORD *)(a2 + 20) + 4 * LODWORD(v49) * *(_DWORD *)(a2 + 8) + v37);
                do
                {
                  v41 = *(float *)(v38 + 4 * v39);
                  if ( v50 )
                  {
                    v42 = (signed int)(v41 * 255.0 + 0.5);
                    if ( v42 >= 0 )
                    {
                      if ( v42 > 255 )
                        LOBYTE(v42) = -1;
                    }
                    else
                    {
                      LOBYTE(v42) = 0;
                    }
                  }
                  else
                  {
                    v42 = (signed int)(v41 * 8192.0 + 0.5);
                    if ( v42 >= 0 )
                    {
                      if ( v42 >= 0x2000 )
                        v42 = 0x1FFF;
                    }
                    else
                    {
                      v42 = 0;
                    }
                    LOBYTE(v42) = v65[v42];
                  }
                  *v40 = v42;
                  ++v39;
                  v40 += 4;
                }
                while ( v39 < v36 );
              }
              ++v51;
            }
            while ( (unsigned int)v51 < *(_DWORD *)(a3 + 24) );
            v26 = 0.003921568859368563;
          }
          if ( (unsigned int)v51 < *(_DWORD *)(a3 + 24) )
            break;
          ++LODWORD(v49);
        }
        if ( ++LODWORD(v48) >= v54 )
          goto LABEL_76;
      }
      v35 = (const void **)&v61;
      while ( sub_100661C0(*v35, (int)*(&v60 + v34)) )
      {
        ++v34;
        v35 += 3;
        if ( v34 >= *(_DWORD *)(a3 + 24) )
        {
          v26 = 0.003921568859368563;
          goto LABEL_52;
        }
      }
      v22 = *(_DWORD *)(a3 + 24) == 0;
      v48 = 0.0;
      if ( !v22 )
      {
        do
        {
          v45 = (int)*(&v60 + LODWORD(v48));
          if ( v45 )
          {
            sub_10065FB0((int)*(&v60 + LODWORD(v48)));
            if ( v45 & 7 )
            {
              v47 = "crnlib_free: bad ptr";
              sprintf_s(
                (char *)DstBuf,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_free: bad ptr");
              OutputDebugStringA((LPCSTR)DstBuf);
              v46 = _iob_func();
              fputs((const char *)DstBuf, v46 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v45, 0, 0, 1, dword_100AE9F4);
            }
          }
          ++LODWORD(v48);
        }
        while ( LODWORD(v48) < *(_DWORD *)(a3 + 24) );
      }
      v66 = -1;
      `eh vector destructor iterator'(&v61, 0xCu, 4, sub_10038C00);
      return 0;
    }
LABEL_76:
    v22 = *(_DWORD *)(a3 + 24) == 0;
    v48 = 0.0;
    if ( !v22 )
    {
      do
      {
        v43 = (int)*(&v60 + LODWORD(v48));
        if ( v43 )
        {
          sub_10065FB0((int)*(&v60 + LODWORD(v48)));
          if ( v43 & 7 )
          {
            v47 = "crnlib_free: bad ptr";
            sprintf_s(
              (char *)DstBuf,
              0x200u,
              "%s(%u): Assertion failed: \"%s\"\n",
              "crn_mem.cpp",
              216,
              "crnlib_free: bad ptr");
            OutputDebugStringA((LPCSTR)DstBuf);
            v44 = _iob_func();
            fputs((const char *)DstBuf, v44 + 2);
            if ( IsDebuggerPresent() )
              DebugBreak();
          }
          else
          {
            off_100AD9F4(v43, 0, 0, 1, dword_100AE9F4);
          }
        }
        ++LODWORD(v48);
      }
      while ( LODWORD(v48) < *(_DWORD *)(a3 + 24) );
    }
    v66 = -1;
    `eh vector destructor iterator'(&v61, 0xCu, 4, sub_10038C00);
    result = 1;
  }
  return result;
}
// 1003F6D0: using guessed type int unknown_libname_3();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 1007BF30: using guessed type char var_2014[8200];

//----- (1007C770) --------------------------------------------------------
void __usercall sub_1007C770(int a1@<edi>)
{
  unsigned int v1; // esi@2
  int v2; // eax@3
  int v3; // eax@8

  if ( *(_DWORD *)a1 )
  {
    v1 = 0;
    if ( *(_DWORD *)a1 )
    {
      do
      {
        v2 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v1);
        if ( v2 )
        {
          if ( v2 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
        }
        ++v1;
      }
      while ( v1 < *(_DWORD *)a1 );
    }
    v3 = *(_DWORD *)(a1 + 4);
    if ( v3 )
    {
      if ( v3 & 7 )
      {
        sub_100927E0((int)"crnlib_free: bad ptr");
        *(_DWORD *)(a1 + 4) = 0;
        *(_DWORD *)a1 = 0;
        return;
      }
      off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)a1 = 0;
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1007C810) --------------------------------------------------------
void __thiscall sub_1007C810(int this, unsigned int a2)
{
  unsigned int v2; // eax@1
  int *v3; // edi@1
  int v4; // ebx@2
  size_t v5; // ebp@2
  unsigned int v6; // edx@2
  unsigned int v7; // esi@2
  void *v8; // eax@4
  int v9; // esi@6
  unsigned int v10; // ecx@9
  unsigned int v11; // eax@11
  unsigned int v12; // [sp+10h] [bp-18h]@2
  int v13; // [sp+14h] [bp-14h]@2
  int v14; // [sp+24h] [bp-4h]@2

  v2 = a2;
  v3 = (int *)this;
  if ( !a2 )
    goto LABEL_16;
  v14 = 0;
  v4 = *(_DWORD *)(this + 4);
  v5 = 4 * a2;
  *(_DWORD *)(this + 4) = 0;
  v6 = *(_DWORD *)this;
  v7 = (4 * v2 + 3) & 0xFFFFFFFC;
  v13 = v4;
  v12 = v6;
  *(_DWORD *)this = v2;
  if ( !v7 )
  {
    v7 = 4;
LABEL_4:
    a2 = v7;
    v8 = (void *)off_100AD9F4(0, v7, &a2, 1, dword_100AE9F4);
    if ( v8 && a2 >= v7 )
    {
      v9 = (int)v8;
      memset(v8, 0, v5);
    }
    else
    {
      sub_100927E0((int)"crnlib_malloc: out of memory");
      v9 = 0;
    }
    goto LABEL_7;
  }
  if ( v7 <= 0x7FFF0000 )
    goto LABEL_4;
  sub_100927E0((int)"crnlib_malloc: size too big");
  v9 = 0;
LABEL_7:
  v3[1] = v9;
  if ( !v9 )
    sub_10090F60((int)"m_ppGroups", (int)"crn_sparse_bit_array.cpp", 301);
  v10 = v12;
  if ( v12 >= *v3 )
    v10 = *v3;
  v11 = 0;
  if ( v10 )
  {
    do
    {
      if ( *(_DWORD *)(v4 + 4 * v11) )
      {
        *(_DWORD *)(v3[1] + 4 * v11) = *(_DWORD *)(v4 + 4 * v11);
        *(_DWORD *)(v4 + 4 * v11) = 0;
      }
      ++v11;
    }
    while ( v11 < v10 );
  }
  v14 = -1;
  v3 = (int *)&v12;
LABEL_16:
  sub_1007C770((int)v3);
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1007C9D0) --------------------------------------------------------
int __stdcall sub_1007C9D0(int a1, int a2, int a3, int a4)
{
  _DWORD *v4; // eax@1
  double v5; // st6@1
  signed int v6; // ebx@1
  double v7; // st5@1
  double v8; // st4@1
  double v9; // st3@1
  unsigned int v10; // ebp@1
  double v11; // st7@1
  int v12; // edx@2
  int v13; // eax@2
  int v14; // ecx@2
  unsigned int v15; // esi@2
  unsigned int v16; // edi@3
  double v17; // st2@4
  double v18; // st6@4
  double v19; // st5@4
  double v20; // st4@4
  double v21; // st3@4
  double v22; // st7@4
  double v23; // st2@4
  double v24; // st2@7
  double v25; // st6@7
  double v26; // st5@7
  double v27; // st4@7
  double v28; // st3@7
  double v29; // st7@7
  double v30; // st2@7
  double v31; // st2@9
  unsigned int v32; // edi@9
  double v33; // st2@10
  double v34; // st6@10
  double v35; // st5@10
  double v36; // st4@10
  double v37; // st3@10
  double v38; // st7@10
  double v39; // st2@10
  unsigned int v40; // edi@12
  double v41; // st2@13
  double v42; // st2@13
  int v43; // eax@18
  unsigned int *v44; // ecx@18
  int v45; // ebx@18
  double v46; // st2@20
  double v47; // st2@20
  double v48; // st2@24
  unsigned int v49; // ecx@24
  double v50; // st1@26
  long double v51; // rt2@26
  double v52; // st1@26
  double v53; // st3@26
  long double v54; // st6@26
  long double v55; // st2@26
  long double v56; // st1@26
  long double v57; // st1@31
  double v58; // st1@32
  double v59; // st3@32
  double v60; // rt0@32
  double v61; // st1@32
  double v62; // st6@32
  double v63; // rt1@32
  long double v64; // st1@32
  double v65; // st2@32
  long double v66; // st7@33
  double v67; // rt2@33
  double v68; // st2@33
  double v69; // st3@33
  double v70; // st2@34
  double v71; // rt2@37
  long double v72; // st2@37
  double v73; // st6@37
  long double v74; // rtt@37
  double v75; // st2@37
  double v76; // st3@37
  long double v77; // st1@37
  double v78; // st2@37
  long double v79; // rt2@37
  long double v80; // st1@37
  double v81; // st7@37
  long double v82; // st2@37
  long double v83; // st1@37
  long double v84; // st1@42
  double v85; // st1@43
  double v86; // st3@43
  double v87; // rt2@43
  double v88; // st1@43
  double v89; // st7@43
  double v90; // rtt@43
  long double v91; // st1@43
  double v92; // st2@43
  long double v93; // st6@44
  double v94; // rt0@44
  double v95; // st2@44
  double v96; // st3@44
  double v97; // st2@45
  double v98; // rt0@48
  long double v99; // st2@48
  double v100; // st7@48
  long double v101; // rt1@48
  double v102; // st2@48
  double v103; // st3@48
  long double v104; // st1@48
  double v105; // st2@48
  long double v106; // rt0@48
  long double v107; // st1@48
  double v108; // st6@48
  long double v109; // st2@48
  long double v110; // st1@48
  long double v111; // st1@53
  double v112; // st1@54
  double v113; // st3@54
  double v114; // rt0@54
  double v115; // st1@54
  double v116; // rt1@54
  long double v117; // st1@54
  double v118; // st2@54
  double v119; // rt2@55
  double v120; // st2@55
  double v121; // st2@56
  double v122; // rt2@59
  long double v123; // st2@59
  double v124; // st6@59
  long double v125; // rtt@59
  double v126; // st2@59
  double v127; // st3@59
  long double v128; // st1@59
  double v129; // st2@59
  long double v130; // rt2@59
  long double v131; // st1@59
  double v132; // st7@59
  long double v133; // st2@59
  long double v134; // st1@59
  long double v135; // st1@64
  double v136; // st1@65
  double v137; // st3@65
  double v138; // rt2@65
  double v139; // st1@65
  double v140; // rtt@65
  long double v141; // st1@65
  double v142; // st2@65
  double v143; // rt0@66
  double v144; // st2@66
  double v145; // st2@67
  double v146; // st1@67
  double v147; // st0@67
  double v148; // st0@69
  double v149; // rtt@69
  double v150; // st0@69
  double v151; // st5@71
  double v152; // st5@72
  double v153; // st5@73
  double v154; // rt0@73
  double v155; // rt1@74
  long double v156; // st5@74
  long double v157; // rtt@74
  long double v158; // st7@75
  int result; // eax@76
  long double v160; // st7@78
  float v161; // [sp+4h] [bp-74h]@3
  float v162; // [sp+4h] [bp-74h]@6
  float v163; // [sp+4h] [bp-74h]@9
  float v164; // [sp+4h] [bp-74h]@12
  float v165; // [sp+4h] [bp-74h]@19
  double v166; // [sp+4h] [bp-74h]@26
  double v167; // [sp+4h] [bp-74h]@32
  double v168; // [sp+4h] [bp-74h]@37
  double v169; // [sp+4h] [bp-74h]@43
  double v170; // [sp+4h] [bp-74h]@48
  double v171; // [sp+4h] [bp-74h]@54
  double v172; // [sp+4h] [bp-74h]@59
  double v173; // [sp+4h] [bp-74h]@65
  float v174; // [sp+Ch] [bp-6Ch]@3
  float v175; // [sp+Ch] [bp-6Ch]@6
  float v176; // [sp+Ch] [bp-6Ch]@9
  float v177; // [sp+Ch] [bp-6Ch]@12
  float v178; // [sp+Ch] [bp-6Ch]@19
  double v179; // [sp+Ch] [bp-6Ch]@26
  double v180; // [sp+Ch] [bp-6Ch]@32
  double v181; // [sp+Ch] [bp-6Ch]@37
  double v182; // [sp+Ch] [bp-6Ch]@43
  double v183; // [sp+Ch] [bp-6Ch]@48
  double v184; // [sp+Ch] [bp-6Ch]@54
  double v185; // [sp+Ch] [bp-6Ch]@59
  double v186; // [sp+Ch] [bp-6Ch]@65
  float v187; // [sp+14h] [bp-64h]@3
  float v188; // [sp+14h] [bp-64h]@6
  float v189; // [sp+14h] [bp-64h]@9
  float v190; // [sp+14h] [bp-64h]@12
  float v191; // [sp+14h] [bp-64h]@19
  double v192; // [sp+14h] [bp-64h]@24
  double v193; // [sp+14h] [bp-64h]@32
  double v194; // [sp+14h] [bp-64h]@43
  double v195; // [sp+14h] [bp-64h]@54
  double v196; // [sp+1Ch] [bp-5Ch]@24
  double v197; // [sp+1Ch] [bp-5Ch]@32
  double v198; // [sp+1Ch] [bp-5Ch]@43
  double v199; // [sp+1Ch] [bp-5Ch]@54
  double v200; // [sp+24h] [bp-54h]@24
  double v201; // [sp+24h] [bp-54h]@32
  double v202; // [sp+24h] [bp-54h]@43
  double v203; // [sp+24h] [bp-54h]@54
  double v204; // [sp+2Ch] [bp-4Ch]@26
  double v205; // [sp+34h] [bp-44h]@26
  double v206; // [sp+3Ch] [bp-3Ch]@26
  double v207; // [sp+44h] [bp-34h]@1
  double v208; // [sp+5Ch] [bp-1Ch]@1
  double v209; // [sp+64h] [bp-14h]@1
  double v210; // [sp+6Ch] [bp-Ch]@1
  double v211; // [sp+6Ch] [bp-Ch]@6
  double v212; // [sp+6Ch] [bp-Ch]@9
  double v213; // [sp+6Ch] [bp-Ch]@12

  v4 = (_DWORD *)a3;
  v5 = 0.0;
  v6 = *(_DWORD *)(a3 + 4);
  v207 = 0.0;
  v7 = 0.0;
  v8 = 0.0;
  v9 = 0.0;
  v10 = 0;
  v208 = 0.0;
  v209 = 0.0;
  v11 = 0.0;
  v210 = 0.0;
  if ( v6 >= 4 )
  {
    v12 = *(_DWORD *)a3 + 8;
    v13 = *(_DWORD *)(a1 + 44) + 12;
    v14 = *(_DWORD *)a3 + 20;
    v15 = ((unsigned int)(v6 - 4) >> 2) + 1;
    v10 = 4 * v15;
    do
    {
      v16 = *(_DWORD *)(v13 - 8);
      v174 = *(float *)(v12 - 8);
      v161 = *(float *)(v12 - 4);
      v187 = *(float *)v12;
      if ( v16 <= 1 )
      {
        v18 = v5 + v174 * v174;
        v19 = v7 + v161 * v174;
        v20 = v8 + v174 * v187;
        v21 = v9 + v161 * v161;
        v22 = v11 + v187 * v161;
        v23 = v187 * v187;
      }
      else
      {
        v17 = (double)v16;
        v18 = v5 + v174 * v174 * v17;
        v19 = v7 + v161 * v174 * v17;
        v20 = v8 + v187 * v174 * v17;
        v21 = v9 + v161 * v161 * v17;
        v22 = v11 + v187 * v161 * v17;
        v23 = v17 * (v187 * v187);
      }
      v211 = v23 + v210;
      v175 = *(float *)(v12 + 4);
      v162 = *(float *)(v14 - 4);
      v188 = *(float *)v14;
      if ( *(_DWORD *)v13 <= 1u )
      {
        v25 = v18 + v175 * v175;
        v26 = v19 + v162 * v175;
        v27 = v20 + v175 * v188;
        v28 = v21 + v162 * v162;
        v29 = v22 + v188 * v162;
        v30 = v188 * v188;
      }
      else
      {
        v24 = (double)*(unsigned int *)v13;
        v25 = v18 + v175 * v175 * v24;
        v26 = v19 + v162 * v175 * v24;
        v27 = v20 + v188 * v175 * v24;
        v28 = v21 + v162 * v162 * v24;
        v29 = v22 + v188 * v162 * v24;
        v30 = v24 * (v188 * v188);
      }
      v31 = v30 + v211;
      v32 = *(_DWORD *)(v13 + 8);
      v212 = v31;
      v176 = *(float *)(v12 + 16);
      v163 = *(float *)(v14 + 8);
      v189 = *(float *)(v14 + 12);
      if ( v32 <= 1 )
      {
        v34 = v25 + v176 * v176;
        v35 = v26 + v163 * v176;
        v36 = v27 + v189 * v176;
        v37 = v28 + v163 * v163;
        v38 = v29 + v189 * v163;
        v39 = v31 + v189 * v189;
      }
      else
      {
        v33 = (double)v32;
        v34 = v25 + v176 * v176 * v33;
        v35 = v26 + v163 * v176 * v33;
        v36 = v27 + v189 * v176 * v33;
        v37 = v28 + v163 * v163 * v33;
        v38 = v29 + v189 * v163 * v33;
        v39 = v33 * (v189 * v189) + v212;
      }
      v40 = *(_DWORD *)(v13 + 16);
      v213 = v39;
      v177 = *(float *)(v12 + 28);
      v164 = *(float *)(v14 + 20);
      v190 = *(float *)(v14 + 24);
      if ( v40 <= 1 )
      {
        v5 = v34 + v177 * v177;
        v7 = v35 + v164 * v177;
        v8 = v36 + v177 * v190;
        v9 = v37 + v164 * v164;
        v11 = v38 + v190 * v164;
        v42 = v190 * v190;
      }
      else
      {
        v41 = (double)v40;
        v5 = v34 + v177 * v177 * v41;
        v7 = v35 + v164 * v177 * v41;
        v8 = v36 + v190 * v177 * v41;
        v9 = v37 + v164 * v164 * v41;
        v11 = v38 + v190 * v164 * v41;
        v42 = v41 * (v190 * v190);
      }
      v12 += 48;
      v14 += 48;
      v13 += 32;
      --v15;
      v210 = v42 + v213;
    }
    while ( v15 );
    v4 = (_DWORD *)a3;
    v209 = v11;
    v208 = v9;
    v207 = v5;
  }
  if ( v10 < v6 )
  {
    v43 = *v4 + 12 * v10;
    v44 = (unsigned int *)(*(_DWORD *)(a1 + 44) + 8 * v10 + 4);
    v45 = v6 - v10;
    do
    {
      v178 = *(float *)v43;
      v165 = *(float *)(v43 + 4);
      v191 = *(float *)(v43 + 8);
      if ( *v44 <= 1 )
      {
        v5 = v5 + v178 * v178;
        v7 = v7 + v165 * v178;
        v8 = v8 + v178 * v191;
        v9 = v9 + v165 * v165;
        v11 = v11 + v191 * v165;
        v47 = v191 * v191;
      }
      else
      {
        v46 = (double)*v44;
        v5 = v5 + v178 * v178 * v46;
        v7 = v7 + v165 * v178 * v46;
        v8 = v8 + v191 * v178 * v46;
        v9 = v9 + v165 * v165 * v46;
        v11 = v11 + v191 * v165 * v46;
        v47 = v46 * (v191 * v191);
      }
      v43 += 12;
      v44 += 2;
      --v45;
      v210 = v47 + v210;
    }
    while ( v45 );
    v209 = v11;
    v208 = v9;
    v207 = v5;
  }
  v48 = 0.8999999761581421;
  v49 = 2;
  v192 = 0.8999999761581421;
  v196 = 1.0;
  v200 = 0.699999988079071;
  while ( 1 )
  {
    v50 = v5 * v48 + v196 * v7 + v200 * v8;
    v204 = v50;
    v51 = v50;
    v52 = v9 * v196 + v48 * v7 + v200 * v11;
    v53 = v51;
    v205 = v52;
    v54 = v52;
    v55 = v196 * v11 + v48 * v8 + v200 * v210;
    v206 = v55;
    v56 = fabs(v51);
    v179 = fabs(v54);
    v166 = fabs(v55);
    if ( v179 >= v56 )
      v56 = v179;
    if ( v166 >= v56 )
      v56 = v166;
    if ( v56 > 1.0e-10 )
    {
      v57 = 1.0 / v56;
      v204 = v53 * v57;
      v205 = v54 * v57;
      v55 = v55 * v57;
      v206 = v55;
      v54 = v205;
      v53 = v204;
    }
    v180 = v196 - v54;
    v167 = v200 - v55;
    v58 = v53;
    v59 = v192 - v53;
    v193 = v58;
    v60 = v58;
    v61 = v54;
    v62 = v60;
    v197 = v61;
    v63 = v61;
    v64 = v55;
    v65 = v63;
    v201 = v64;
    if ( v49 - 2 <= 2 )
    {
      v69 = v65;
      v70 = v11;
      v66 = v64;
    }
    else
    {
      v66 = v64;
      v67 = v65;
      v68 = v59 * v59 + v180 * v180 + v167 * v167;
      v69 = v67;
      if ( v68 < 0.00000001 )
        goto LABEL_72;
      v70 = v209;
    }
    v71 = v70;
    v72 = v69 * v7 + v62 * v207 + v66 * v8;
    v73 = v71;
    v204 = v72;
    v74 = v72;
    v75 = v69;
    v76 = v74;
    v77 = v75 * v208 + v193 * v7 + v66 * v71;
    v205 = v77;
    v78 = v197 * v71 + v193 * v8;
    v79 = v77;
    v80 = v66;
    v81 = v79;
    v82 = v78 + v80 * v210;
    v206 = v82;
    v83 = fabs(v74);
    v181 = fabs(v79);
    v168 = fabs(v82);
    if ( v181 >= v83 )
      v83 = v181;
    if ( v168 >= v83 )
      v83 = v168;
    if ( v83 > 1.0e-10 )
    {
      v84 = 1.0 / v83;
      v204 = v76 * v84;
      v205 = v81 * v84;
      v82 = v82 * v84;
      v206 = v82;
      v81 = v205;
      v76 = v204;
    }
    v182 = v197 - v81;
    v169 = v201 - v82;
    v85 = v76;
    v86 = v193 - v76;
    v194 = v85;
    v87 = v85;
    v88 = v81;
    v89 = v87;
    v198 = v88;
    v90 = v88;
    v91 = v82;
    v92 = v90;
    v202 = v91;
    if ( v49 - 1 <= 2 )
    {
      v96 = v92;
      v97 = v73;
      v93 = v91;
    }
    else
    {
      v93 = v91;
      v94 = v92;
      v95 = v86 * v86 + v182 * v182 + v169 * v169;
      v96 = v94;
      if ( v95 < 0.00000001 )
        goto LABEL_73;
      v97 = v209;
    }
    v98 = v97;
    v99 = v96 * v7 + v89 * v207 + v93 * v8;
    v100 = v98;
    v204 = v99;
    v101 = v99;
    v102 = v96;
    v103 = v101;
    v104 = v102 * v208 + v194 * v7 + v93 * v98;
    v205 = v104;
    v105 = v198 * v98 + v194 * v8;
    v106 = v104;
    v107 = v93;
    v108 = v106;
    v109 = v105 + v107 * v210;
    v206 = v109;
    v110 = fabs(v101);
    v183 = fabs(v106);
    v170 = fabs(v109);
    if ( v183 >= v110 )
      v110 = v183;
    if ( v170 >= v110 )
      v110 = v170;
    if ( v110 > 1.0e-10 )
    {
      v111 = 1.0 / v110;
      v204 = v103 * v111;
      v205 = v108 * v111;
      v109 = v109 * v111;
      v206 = v109;
      v108 = v205;
      v103 = v204;
    }
    v184 = v198 - v108;
    v171 = v202 - v109;
    v112 = v103;
    v113 = v194 - v103;
    v195 = v112;
    v114 = v112;
    v115 = v108;
    v62 = v114;
    v199 = v115;
    v116 = v115;
    v117 = v109;
    v118 = v116;
    v203 = v117;
    if ( v49 <= 2 )
    {
      v69 = v118;
      v121 = v100;
      v66 = v117;
    }
    else
    {
      v66 = v117;
      v119 = v118;
      v120 = v113 * v113 + v184 * v184 + v171 * v171;
      v69 = v119;
      if ( v120 < 0.00000001 )
      {
LABEL_72:
        v152 = v69;
        goto LABEL_74;
      }
      v121 = v209;
    }
    v122 = v121;
    v123 = v69 * v7 + v62 * v207 + v66 * v8;
    v124 = v122;
    v204 = v123;
    v125 = v123;
    v126 = v69;
    v127 = v125;
    v128 = v126 * v208 + v195 * v7 + v66 * v122;
    v205 = v128;
    v129 = v199 * v122 + v195 * v8;
    v130 = v128;
    v131 = v66;
    v132 = v130;
    v133 = v129 + v131 * v210;
    v206 = v133;
    v134 = fabs(v125);
    v185 = fabs(v130);
    v172 = fabs(v133);
    if ( v185 >= v134 )
      v134 = v185;
    if ( v172 >= v134 )
      v134 = v172;
    if ( v134 > 1.0e-10 )
    {
      v135 = 1.0 / v134;
      v204 = v127 * v135;
      v205 = v132 * v135;
      v133 = v133 * v135;
      v206 = v133;
      v132 = v205;
      v127 = v204;
    }
    v186 = v199 - v132;
    v173 = v203 - v133;
    v136 = v127;
    v137 = v195 - v127;
    v192 = v136;
    v138 = v136;
    v139 = v132;
    v89 = v138;
    v196 = v139;
    v140 = v139;
    v141 = v133;
    v142 = v140;
    v200 = v141;
    if ( v49 + 1 > 2 )
      break;
    v148 = v124;
    v93 = v141;
    v149 = v148;
    v150 = v142;
    v145 = v149;
    v96 = v150;
    v147 = v207;
    v146 = v208;
LABEL_70:
    v49 += 4;
    if ( v49 - 2 >= 8 )
    {
      v151 = v96;
      goto LABEL_75;
    }
    v5 = v147;
    v9 = v146;
    v11 = v145;
    v48 = v192;
  }
  v93 = v141;
  v143 = v142;
  v144 = v137 * v137 + v186 * v186 + v173 * v173;
  v96 = v143;
  if ( v144 >= 0.00000001 )
  {
    v145 = v209;
    v146 = v208;
    v147 = v207;
    goto LABEL_70;
  }
LABEL_73:
  v153 = v89;
  v66 = v93;
  v154 = v153;
  v152 = v96;
  v62 = v154;
LABEL_74:
  v155 = v152;
  v156 = v66;
  v89 = v62;
  v157 = v156;
  v151 = v155;
  v93 = v157;
LABEL_75:
  v158 = v89 * v89 + v151 * v151 + v93 * v93;
  if ( v158 >= 1.0e-10 )
  {
    v160 = 1.0 / sqrt(v158);
    result = a2;
    *(float *)a2 = v204 * v160;
    *(float *)(a2 + 4) = v205 * v160;
    *(float *)(a2 + 8) = v160 * v206;
  }
  else
  {
    result = a4;
    if ( a2 != a4 )
    {
      *(float *)a2 = *(float *)a4;
      *(float *)(a2 + 4) = *(float *)(a4 + 4);
      *(float *)(a2 + 8) = *(float *)(a4 + 8);
    }
  }
  return result;
}

//----- (1007D390) --------------------------------------------------------
int __userpurge sub_1007D390@<eax>(int a1@<edi>, int a2@<esi>, int a3, float a4, int a5)
{
  int v5; // ebp@1
  double v6; // st7@2
  signed int v7; // eax@4
  float v8; // ST08_4@4
  double v9; // st7@4
  double v10; // st6@4
  signed int v11; // eax@4
  signed int v12; // eax@8
  char v13; // bl@9
  signed int v14; // eax@13
  int v16; // [sp+10h] [bp+4h]@4
  int v17; // [sp+10h] [bp+4h]@4
  char v18; // [sp+10h] [bp+4h]@5
  float v19; // [sp+14h] [bp+8h]@8
  float v20; // [sp+14h] [bp+8h]@13
  int v21; // [sp+18h] [bp+Ch]@4
  int v22; // [sp+18h] [bp+Ch]@8
  int v23; // [sp+18h] [bp+Ch]@8
  int v24; // [sp+18h] [bp+Ch]@13
  int v25; // [sp+18h] [bp+Ch]@13

  v5 = a3;
  if ( a5 )
    v6 = 1.0;
  else
    v6 = 0.0;
  v7 = *(_BYTE *)a3;
  *(float *)&v16 = v6;
  v8 = (double)v7;
  v9 = a4;
  *(float *)&v21 = v8 + ((double)*(_BYTE *)a1 - v8) * a4;
  v10 = *(float *)&v16;
  *(float *)&v17 = *(float *)&v21 + *(float *)&v16;
  v11 = (signed int)*(float *)&v17;
  if ( v11 >= 0 )
  {
    v18 = -1;
    if ( v11 <= 255 )
      v18 = v11;
  }
  else
  {
    v18 = 0;
  }
  v19 = (double)*(_BYTE *)(v5 + 1);
  *(float *)&v22 = ((double)*(_BYTE *)(a1 + 1) - v19) * v9 + v19;
  *(float *)&v23 = *(float *)&v22 + v10;
  v12 = (signed int)*(float *)&v23;
  if ( v12 >= 0 )
  {
    if ( v12 <= 255 )
      v13 = (signed int)*(float *)&v23;
    else
      v13 = -1;
  }
  else
  {
    v13 = 0;
  }
  v20 = (double)*(_BYTE *)(v5 + 2);
  *(float *)&v24 = v9 * ((double)*(_BYTE *)(a1 + 2) - v20) + v20;
  *(float *)&v25 = v10 + *(float *)&v24;
  v14 = (signed int)*(float *)&v25;
  if ( v14 >= 0 )
  {
    if ( v14 > 255 )
      LOBYTE(v14) = -1;
  }
  else
  {
    LOBYTE(v14) = 0;
  }
  *(_BYTE *)(a2 + 1) = v13;
  *(_BYTE *)(a2 + 2) = v14;
  *(_BYTE *)a2 = v18;
  *(_BYTE *)(a2 + 3) = -1;
  *(_DWORD *)(a2 + 4) = 1;
  return a2;
}

//----- (1007D4E0) --------------------------------------------------------
int __userpurge sub_1007D4E0@<eax>(int a1@<ebx>, unsigned int a2, int a3)
{
  unsigned __int16 v3; // ax@1
  unsigned __int16 v4; // si@1
  bool v5; // cl@2
  int v6; // edi@5
  int v7; // edx@6
  unsigned int v8; // ecx@10
  int v9; // esi@10
  char v10; // al@10
  unsigned int *v11; // edx@13
  char *v12; // ebp@13
  _DWORD *v13; // edi@15
  unsigned int v14; // eax@15
  unsigned int v15; // edi@17
  char v16; // al@17
  unsigned int v17; // edi@18
  int result; // eax@22
  char v19; // [sp+Fh] [bp-19h]@16
  _BYTE *v20; // [sp+10h] [bp-18h]@7
  unsigned int v21; // [sp+14h] [bp-14h]@11
  unsigned int v22; // [sp+18h] [bp-10h]@16
  unsigned int v23; // [sp+1Ch] [bp-Ch]@18
  unsigned int *v24; // [sp+20h] [bp-8h]@17
  char *v25; // [sp+24h] [bp-4h]@16

  v3 = *(_WORD *)a1;
  v4 = *(_WORD *)(a1 + 2);
  if ( *(_BYTE *)(a1 + 24) )
    v5 = v3 > v4;
  else
    v5 = v3 < v4;
  if ( v5 )
  {
    v6 = a3;
    *(_WORD *)(a3 + 8) = v4;
    *(_WORD *)(v6 + 10) = *(_WORD *)a1;
  }
  else
  {
    v7 = a3;
    *(_WORD *)(a3 + 8) = v3;
    *(_WORD *)(v7 + 10) = *(_WORD *)(a1 + 2);
    v6 = v7;
  }
  v20 = &unk_1009B638;
  if ( v5 )
  {
    v20 = &unk_1009B63C;
    if ( !*(_BYTE *)(a1 + 24) )
      v20 = &unk_1009B640;
  }
  v8 = a2;
  v9 = *(_DWORD *)a2;
  v10 = *(_BYTE *)(*(_DWORD *)a2 + 20);
  if ( v10 )
    v21 = *(_DWORD *)(v9 + 12) << 24;
  else
    v21 = 0;
  v11 = *(unsigned int **)(v9 + 4);
  v12 = *(char **)(v6 + 12);
  if ( *(_DWORD *)(a2 + 48) != 1 || v10 )
  {
    v25 = &v12[*(_DWORD *)(v9 + 8)];
    v19 = 0;
    v22 = 0;
    do
    {
      v15 = *v11;
      ++v11;
      v24 = v11;
      v16 = 3;
      if ( v15 >= v21 )
      {
        v17 = v15 | 0xFF000000;
        v23 = v17;
        if ( v17 == v22 )
        {
          v16 = v19;
        }
        else
        {
          v16 = v20[*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v8 + 16) + 12 * sub_100359B0((int *)&v23, v8 + 16) + 4)
                             + *(_DWORD *)(a1 + 4))];
          v8 = a2;
          v11 = v24;
          v22 = v17;
          v19 = v16;
        }
      }
      *v12++ = v16;
    }
    while ( v12 != v25 );
  }
  else
  {
    v13 = (_DWORD *)(a2 + 16);
    a2 = *v11 | 0xFF000000;
    v14 = sub_100359B0((int *)&a2, v8 + 16);
    memset(v12, v20[*(_BYTE *)(*(_DWORD *)(*v13 + 12 * v14 + 4) + *(_DWORD *)(a1 + 4))], *(_DWORD *)(v9 + 8));
  }
  result = a3;
  *(_BYTE *)(a3 + 16) = *(_BYTE *)(a1 + 24);
  *(_DWORD *)result = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(result + 4) = *(_DWORD *)(a1 + 20);
  return result;
}

//----- (1007D660) --------------------------------------------------------
int __userpurge sub_1007D660@<eax>(int a1@<esi>, int a2)
{
  _DWORD *v2; // ebx@1
  unsigned int v3; // ebp@1
  _DWORD *v4; // edi@3
  double v5; // st7@6
  int v6; // eax@7
  signed int v7; // edx@7
  int v8; // eax@7
  unsigned int v9; // eax@7
  int v10; // eax@9
  unsigned int v11; // eax@9
  int v12; // eax@11
  float v13; // ST20_4@11
  float v14; // ST3C_4@11
  float v15; // ST40_4@11
  float v16; // ST44_4@11
  float v17; // ST48_4@11
  float v18; // ST4C_4@11
  float v19; // ST50_4@11
  int result; // eax@12
  unsigned int v21; // edx@14
  int v22; // ecx@15
  int v23; // eax@16
  double v24; // st7@16
  unsigned int v25; // [sp+10h] [bp-34h]@7
  float v26; // [sp+14h] [bp-30h]@7
  float v27; // [sp+18h] [bp-2Ch]@7
  float v28; // [sp+1Ch] [bp-28h]@7
  float v29; // [sp+20h] [bp-24h]@7
  float v30; // [sp+24h] [bp-20h]@7
  float v31; // [sp+28h] [bp-1Ch]@7
  float v32; // [sp+48h] [bp+4h]@13
  float v33; // [sp+48h] [bp+4h]@13

  v2 = (_DWORD *)(a1 + 76);
  v3 = 0;
  if ( *(_DWORD *)(a1 + 80) )
    *(_DWORD *)(a1 + 80) = 0;
  v4 = (_DWORD *)(a1 + 100);
  if ( *(_DWORD *)(a1 + 104) )
    *(_DWORD *)(a1 + 104) = 0;
  *(float *)(a1 + 88) = 0.0;
  *(float *)(a1 + 92) = 0.0;
  *(float *)(a1 + 96) = 0.0;
  *(float *)(a1 + 112) = 0.0;
  *(float *)(a1 + 116) = 0.0;
  *(float *)(a1 + 120) = 0.0;
  if ( *(_DWORD *)(a1 + 48) > 0u )
  {
    v5 = 255.0;
    do
    {
      v6 = *(_DWORD *)(a1 + 44);
      v7 = *(_BYTE *)(v6 + 8 * v3);
      v8 = v6 + 8 * v3;
      v25 = *(_DWORD *)(v8 + 4);
      v26 = (double)v7 / v5;
      v27 = (double)*(_BYTE *)(v8 + 1) / v5;
      v28 = (double)*(_BYTE *)(v8 + 2) / v5;
      v29 = *(float *)a2 * v26;
      v30 = *(float *)(a2 + 4) * v27;
      v9 = *(_DWORD *)(a1 + 80);
      v31 = *(float *)(a2 + 8) * v28;
      if ( v9 >= *(_DWORD *)(a1 + 84) )
      {
        sub_100943C0(v9 + 1, 0, a1 + 76, 1, 0xCu, 0);
        v5 = 255.0;
      }
      v10 = *(_DWORD *)(a1 + 76) + 12 * *(_DWORD *)(a1 + 80);
      *(float *)v10 = v26;
      *(float *)(v10 + 4) = v27;
      *(float *)(v10 + 8) = v28;
      ++*(_DWORD *)(a1 + 80);
      v11 = *(_DWORD *)(a1 + 104);
      if ( v11 >= *(_DWORD *)(a1 + 108) )
      {
        sub_100943C0(v11 + 1, 0, a1 + 100, 1, 0xCu, 0);
        v5 = 255.0;
      }
      v12 = *(_DWORD *)(a1 + 100) + 12 * *(_DWORD *)(a1 + 104);
      *(float *)v12 = v29;
      *(float *)(v12 + 4) = v30;
      *(float *)(v12 + 8) = v31;
      ++*(_DWORD *)(a1 + 104);
      v13 = (double)v25;
      ++v3;
      v14 = v13 * v26;
      v15 = v13 * v27;
      v16 = v13 * v28;
      *(float *)(a1 + 88) = v14 + *(float *)(a1 + 88);
      *(float *)(a1 + 92) = v15 + *(float *)(a1 + 92);
      *(float *)(a1 + 96) = *(float *)(a1 + 96) + v16;
      v17 = v13 * v29;
      v18 = v13 * v30;
      v19 = v13 * v31;
      *(float *)(a1 + 112) = *(float *)(a1 + 112) + v17;
      *(float *)(a1 + 116) = *(float *)(a1 + 116) + v18;
      *(float *)(a1 + 120) = *(float *)(a1 + 120) + v19;
    }
    while ( v3 < *(_DWORD *)(a1 + 48) );
  }
  result = *(_DWORD *)(a1 + 68);
  if ( result )
  {
    v32 = 1.0 / (double)(unsigned int)result;
    *(float *)(a1 + 88) = *(float *)(a1 + 88) * v32;
    *(float *)(a1 + 92) = v32 * *(float *)(a1 + 92);
    *(float *)(a1 + 96) = v32 * *(float *)(a1 + 96);
    v33 = 1.0 / (double)*(unsigned int *)(a1 + 68);
    *(float *)(a1 + 112) = v33 * *(float *)(a1 + 112);
    *(float *)(a1 + 116) = *(float *)(a1 + 116) * v33;
    *(float *)(a1 + 120) = v33 * *(float *)(a1 + 120);
  }
  v21 = 0;
  if ( *(_DWORD *)(a1 + 48) )
  {
    v22 = 0;
    do
    {
      v23 = v22 + *v2;
      ++v21;
      *(float *)v23 = *(float *)(*v2 + v22) - *(float *)(a1 + 88);
      *(float *)(v23 + 4) = *(float *)(v23 + 4) - *(float *)(a1 + 92);
      *(float *)(v23 + 8) = *(float *)(v23 + 8) - *(float *)(a1 + 96);
      result = v22 + *v4;
      v24 = *(float *)(*v4 + v22) - *(float *)(a1 + 112);
      v22 += 12;
      *(float *)result = v24;
      *(float *)(result + 4) = *(float *)(result + 4) - *(float *)(a1 + 116);
      *(float *)(result + 8) = *(float *)(result + 8) - *(float *)(a1 + 120);
    }
    while ( v21 < *(_DWORD *)(a1 + 48) );
  }
  return result;
}

//----- (1007D8F0) --------------------------------------------------------
void __usercall sub_1007D8F0(int a1@<edi>)
{
  bool v1; // cf@1
  bool v2; // zf@1

  v1 = *(_DWORD *)(a1 + 20) < 0x2000u;
  v2 = *(_DWORD *)(a1 + 20) == 0x2000;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  if ( v1 || v2 )
  {
    if ( *(_DWORD *)(a1 + 36) )
    {
      memset(*(void **)(a1 + 16), 0, 12 * *(_DWORD *)(a1 + 20));
      *(_DWORD *)(a1 + 36) = 0;
    }
  }
  else
  {
    sub_10033060(a1 + 16);
  }
  if ( *(_DWORD *)(a1 + 308) > 0x2000u )
    sub_10033060(a1 + 304);
  if ( *(_DWORD *)(a1 + 48) )
    *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  if ( *(_DWORD *)(a1 + 80) )
    *(_DWORD *)(a1 + 80) = 0;
  *(float *)(a1 + 88) = 0.0;
  *(float *)(a1 + 92) = 0.0;
  *(float *)(a1 + 96) = 0.0;
  if ( *(_DWORD *)(a1 + 104) )
    *(_DWORD *)(a1 + 104) = 0;
  *(float *)(a1 + 112) = 0.0;
  *(float *)(a1 + 116) = 0.0;
  *(float *)(a1 + 120) = 0.0;
  *(float *)(a1 + 124) = 0.0;
  *(float *)(a1 + 128) = 0.0;
  *(float *)(a1 + 132) = 0.0;
  *(_DWORD *)(a1 + 232) = 0;
  *(_BYTE *)(a1 + 136) = 0;
  *(_WORD *)(a1 + 12) = 0;
}

//----- (1007D9A0) --------------------------------------------------------
char __stdcall sub_1007D9A0(unsigned int a1)
{
  unsigned int v1; // ebp@1
  int v2; // eax@1
  unsigned int v3; // esi@4
  unsigned int *v4; // ebx@4
  _DWORD *v5; // edi@4
  unsigned int v6; // eax@4
  unsigned int v7; // esi@9
  unsigned int v8; // eax@10
  int v9; // ecx@18
  unsigned int v10; // eax@21
  int v12; // [sp+10h] [bp-20h]@1
  unsigned int v13; // [sp+14h] [bp-1Ch]@2
  unsigned int v14; // [sp+18h] [bp-18h]@16
  unsigned int *v15; // [sp+1Ch] [bp-14h]@10
  unsigned int *v16; // [sp+20h] [bp-10h]@4
  _DWORD *v17; // [sp+24h] [bp-Ch]@16
  int v18; // [sp+28h] [bp-8h]@18
  char v19; // [sp+2Ch] [bp-4h]@16

  v1 = a1;
  v2 = *(_DWORD *)a1;
  *(_BYTE *)(a1 + 72) = 0;
  v12 = 0;
  if ( *(_BYTE *)(v2 + 20) )
    v13 = *(_DWORD *)(v2 + 12) << 24;
  else
    v13 = 0;
  v3 = *(_DWORD *)(v2 + 8);
  v4 = *(unsigned int **)(v2 + 4);
  v5 = (_DWORD *)(v1 + 44);
  v16 = &v4[v3];
  v6 = *(_DWORD *)(v1 + 48);
  if ( v3 != v6 )
  {
    if ( v3 >= v6 && v3 > *(_DWORD *)(v1 + 52) )
    {
      LOBYTE(a1) = v3 == v6 + 1;
      sub_100943C0(v3, 0, v1 + 44, v3 == v6 + 1, 8u, 0);
    }
    *(_DWORD *)(v1 + 48) = v3;
  }
  v7 = 0;
  a1 = 0;
  *(_BYTE *)(v1 + 136) = 1;
  do
  {
    v8 = *v4;
    ++v4;
    v15 = v4;
    if ( v8 >= v13 )
    {
      if ( *(_BYTE *)(v1 + 136)
        && ((unsigned __int8)v8 != (unsigned __int16)v8 >> 8 || (unsigned __int8)v8 != ((v8 >> 16) & 0xFF)) )
      {
        *(_BYTE *)(v1 + 136) = 0;
      }
      v14 = v8 | 0xFF000000;
      sub_100352F0((int)&v17, v1 + 16, (int *)&v14, &a1);
      v7 = a1;
      if ( v19 )
      {
        *(_DWORD *)(*v5 + 8 * a1) = v14;
        *(_DWORD *)(*v5 + 8 * v7++ + 4) = 1;
        a1 = v7;
      }
      else
      {
        v9 = *(_DWORD *)(*v17 + 12 * v18 + 4);
        ++*(_DWORD *)(*v5 + 8 * v9 + 4);
      }
      ++v12;
      v4 = v15;
    }
    else
    {
      *(_BYTE *)(v1 + 72) = 1;
    }
  }
  while ( v4 != v16 );
  v10 = *(_DWORD *)(v1 + 48);
  if ( v7 == v10 )
  {
    LOBYTE(v10) = v12;
    *(_DWORD *)(v1 + 68) = v12;
  }
  else
  {
    if ( v7 >= v10 && v7 > *(_DWORD *)(v1 + 52) )
    {
      LOBYTE(a1) = v7 == v10 + 1;
      LOBYTE(v10) = sub_100943C0(v7, 0, v1 + 44, v7 == v10 + 1, 8u, 0);
    }
    *(_DWORD *)(v1 + 48) = v7;
    *(_DWORD *)(v1 + 68) = v12;
  }
  return v10;
}

//----- (1007DB20) --------------------------------------------------------
int __stdcall sub_1007DB20(int a1)
{
  int v1; // ecx@1

  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 32;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_BYTE *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 148) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 156) = 0;
  *(_DWORD *)(a1 + 160) = 0;
  v1 = a1 + 164;
  *(_DWORD *)v1 = 0;
  *(_DWORD *)(v1 + 4) = 0;
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 180) = 0;
  *(_DWORD *)(a1 + 184) = 0;
  *(_WORD *)(a1 + 188) = 0;
  *(_WORD *)(a1 + 190) = 0;
  *(_WORD *)(a1 + 192) = 0;
  *(_WORD *)(a1 + 194) = 0;
  *(_WORD *)(a1 + 196) = 0;
  *(_WORD *)(a1 + 198) = 0;
  *(_WORD *)(a1 + 200) = 0;
  *(_WORD *)(a1 + 202) = 0;
  *(_DWORD *)(a1 + 208) = 0;
  *(_DWORD *)(a1 + 212) = 0;
  *(_DWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 220) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 228) = 0;
  *(_WORD *)(a1 + 240) = 0;
  *(_WORD *)(a1 + 242) = 0;
  *(_DWORD *)(a1 + 244) = 0;
  *(_DWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 252) = 0;
  *(_DWORD *)(a1 + 256) = -1;
  *(_DWORD *)(a1 + 260) = -1;
  *(_WORD *)(a1 + 264) = 0;
  *(_WORD *)(a1 + 272) = 0;
  *(_WORD *)(a1 + 274) = 0;
  *(_DWORD *)(a1 + 276) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 284) = 0;
  *(_DWORD *)(a1 + 288) = -1;
  *(_DWORD *)(a1 + 292) = -1;
  *(_WORD *)(a1 + 296) = 0;
  *(_DWORD *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 308) = 0;
  *(_DWORD *)(a1 + 312) = 0;
  *(_DWORD *)(a1 + 316) = 32;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  sub_10035540(a1 + 164);
  sub_10035540(a1 + 176);
  sub_10035440(a1 + 44);
  sub_10035440(a1 + 56);
  sub_10035640(a1 + 140, 0x200u);
  sub_10035540(a1 + 76);
  sub_10035540(a1 + 100);
  sub_10035740(a1 + 208);
  sub_10035740(a1 + 220);
  return a1;
}

//----- (1007DD40) --------------------------------------------------------
char __userpurge sub_1007DD40@<al>(_DWORD *a1@<eax>, int a2, int a3, char a4, int a5, unsigned __int8 a6)
{
  int v6; // ecx@1
  int v7; // ebp@1
  _DWORD *v8; // edi@1
  unsigned int v9; // esi@1
  unsigned int v10; // eax@1
  signed int v11; // eax@9
  int v12; // eax@11
  unsigned int v13; // esi@16
  unsigned int v14; // eax@16
  unsigned int v15; // esi@22
  int v16; // ecx@22
  unsigned int v17; // eax@22
  unsigned int v18; // edi@22
  int v19; // ST48_4@22
  unsigned int v20; // edi@22
  int v21; // eax@22
  int v22; // esi@22
  int v23; // eax@22
  int v24; // ebx@22
  int v25; // edx@22
  int v26; // esi@22
  int v27; // edi@22
  int v28; // ecx@22
  bool v29; // zf@22
  int v30; // esi@25
  unsigned int v31; // edx@28
  int v32; // eax@28
  int v33; // ecx@28
  int v34; // edi@28
  int v35; // ebx@29
  int v36; // eax@29
  int v37; // eax@35
  int v38; // ebx@37
  int v39; // ecx@41
  int v40; // ebx@41
  int v41; // eax@41
  int v42; // eax@41
  int v43; // ebx@41
  int v44; // edi@42
  int v45; // eax@42
  int v46; // kr04_4@45
  void *v47; // eax@49
  __int16 v48; // si@59
  __int16 v49; // ax@59
  char v50; // dl@61
  unsigned int v51; // eax@63
  char result; // al@67
  int v53; // [sp+10h] [bp-58h]@22
  int v54; // [sp+14h] [bp-54h]@22
  unsigned int v55; // [sp+18h] [bp-50h]@22
  int v56; // [sp+1Ch] [bp-4Ch]@22
  int v57; // [sp+20h] [bp-48h]@22
  unsigned int v58; // [sp+24h] [bp-44h]@11
  unsigned int v59; // [sp+28h] [bp-40h]@11
  int v60; // [sp+2Ch] [bp-3Ch]@22
  int v61; // [sp+30h] [bp-38h]@22
  int v62; // [sp+34h] [bp-34h]@22
  int i; // [sp+38h] [bp-30h]@28
  int v64; // [sp+3Ch] [bp-2Ch]@28
  int v65; // [sp+3Ch] [bp-2Ch]@41
  unsigned __int64 v66; // [sp+40h] [bp-28h]@27
  char v67; // [sp+48h] [bp-20h]@22
  char v68; // [sp+49h] [bp-1Fh]@22
  char v69; // [sp+4Ah] [bp-1Eh]@22
  char v70; // [sp+4Bh] [bp-1Dh]@22
  char v71; // [sp+4Ch] [bp-1Ch]@22
  char v72; // [sp+4Dh] [bp-1Bh]@22
  char v73; // [sp+4Eh] [bp-1Ah]@22
  char v74; // [sp+4Fh] [bp-19h]@22
  unsigned __int8 v75; // [sp+50h] [bp-18h]@28
  unsigned __int8 v76; // [sp+51h] [bp-17h]@28
  unsigned __int8 v77; // [sp+52h] [bp-16h]@28
  char v78; // [sp+53h] [bp-15h]@27
  unsigned __int8 v79; // [sp+54h] [bp-14h]@28
  unsigned __int8 v80; // [sp+55h] [bp-13h]@28
  unsigned __int8 v81; // [sp+56h] [bp-12h]@28
  char v82; // [sp+57h] [bp-11h]@28
  int v83; // [sp+58h] [bp-10h]@24
  unsigned int v84; // [sp+5Ch] [bp-Ch]@24
  int v85; // [sp+6Ch] [bp+4h]@22
  unsigned int v86; // [sp+74h] [bp+Ch]@22
  char v87; // [sp+74h] [bp+Ch]@30
  unsigned __int8 v88; // [sp+74h] [bp+Ch]@43
  int v89; // [sp+7Ch] [bp+14h]@28
  int v90; // [sp+7Ch] [bp+14h]@41

  v6 = a3;
  v7 = a2;
  v8 = a1;
  *(_DWORD *)a3 = *a1;
  v9 = *(_DWORD *)(a2 + 48);
  v10 = *(_DWORD *)(a3 + 8);
  if ( v9 != v10 )
  {
    if ( v9 >= v10 )
    {
      if ( v9 > *(_DWORD *)(a3 + 12) )
        sub_100943C0(v9, 0, a3 + 4, v9 == v10 + 1, 1u, 0);
      memset((void *)(*(_DWORD *)(a3 + 8) + *(_DWORD *)(a3 + 4)), 0, v9 - *(_DWORD *)(a3 + 8));
      v6 = a3;
    }
    *(_DWORD *)(a3 + 8) = v9;
  }
  if ( a5 && a4 )
  {
    *(_DWORD *)(v6 + 16) = *(_DWORD *)(a5 + 16);
    v11 = *(_DWORD *)(a5 + 20);
  }
  else
  {
    v11 = -1;
    *(_DWORD *)(v6 + 16) = -1;
  }
  *(_DWORD *)(v6 + 20) = v11;
  *(_WORD *)(v6 + 24) = 0;
  v12 = *(_DWORD *)a2;
  v58 = 0;
  v59 = 1;
  if ( *(_BYTE *)(*(_DWORD *)a2 + 20) || *(_BYTE *)(v12 + 26) )
  {
    v58 = 1;
  }
  else if ( !*(_BYTE *)(v12 + 21) )
  {
    v59 = 0;
  }
  v13 = *(_DWORD *)(a2 + 48);
  v14 = *(_DWORD *)(a2 + 156);
  if ( v13 != v14 )
  {
    if ( v13 >= v14 )
    {
      if ( v13 > *(_DWORD *)(a2 + 160) )
        sub_100943C0(v13, 0, a2 + 152, v13 == v14 + 1, 1u, 0);
      memset((void *)(*(_DWORD *)(a2 + 156) + *(_DWORD *)(a2 + 152)), 0, v13 - *(_DWORD *)(a2 + 156));
    }
    *(_DWORD *)(a2 + 156) = v13;
  }
  v15 = *(_WORD *)v8 & 0x1F;
  LOBYTE(v24) = 4 * (((unsigned int)*(_WORD *)v8 >> 5) & 0x3F) | ((((unsigned int)*(_WORD *)v8 >> 5) & 0x3F) >> 4);
  LOBYTE(v16) = 8 * ((unsigned int)*(_WORD *)v8 >> 11) | ((unsigned int)*(_WORD *)v8 >> 13);
  v17 = *((_WORD *)v8 + 1);
  v18 = *((_WORD *)v8 + 1) & 0x1F;
  LOBYTE(v25) = 8 * v15 | (v15 >> 2);
  v19 = 8 * v18 | (v18 >> 2);
  v20 = 4 * ((v17 >> 5) & 0x3F) | (((v17 >> 5) & 0x3F) >> 4);
  v21 = 8 * (v17 >> 11) | (v17 >> 13);
  v22 = (unsigned __int8)v21;
  v86 = v20;
  v20 = (unsigned __int8)v20;
  v71 = v21;
  v72 = v86;
  v67 = v16;
  v16 = (unsigned __int8)v16;
  v73 = v19;
  v23 = (unsigned __int8)v19;
  v68 = v24;
  v69 = v25;
  v24 = (unsigned __int8)v24;
  v25 = (unsigned __int8)v25;
  v57 = v16;
  v56 = v22;
  v26 = v22 - (unsigned __int8)v16;
  v55 = v20;
  v27 = (unsigned __int8)v20 - (unsigned __int8)v24;
  v28 = (unsigned __int8)v19 - (unsigned __int8)v25;
  v29 = *(_BYTE *)(a2 + 12) == 0;
  v70 = -1;
  v74 = -1;
  v53 = v26;
  v62 = (unsigned __int8)v24;
  v85 = v27;
  v60 = (unsigned __int8)v25;
  v61 = v23;
  v54 = v28;
  if ( !v29 )
  {
    v53 = 8 * v26;
    v85 = 24 * v27;
    v27 *= 24;
  }
  v83 = v53 * v57 + v27 * (unsigned __int8)v24 + v28 * (unsigned __int8)v25;
  v84 = v53 * v56 + v27 * v55 + v28 * v23;
  if ( v58 <= v59 )
  {
    v30 = a6;
    while ( 1 )
    {
      v66 = 0i64;
      v78 = -1;
      if ( !v58 )
        break;
      v39 = v24 + v55;
      v40 = *(_DWORD *)(v7 + 48);
      v41 = (v30 + v25 + v23) >> 1;
      v77 = v41;
      v76 = (v30 + v39) >> 1;
      v75 = (v30 + v57 + v56) >> 1;
      v42 = v53 * v75 + v27 * v76 + v54 * (unsigned __int8)v41;
      v43 = v40 - 1;
      v90 = v42 + v83;
      v65 = v84 + v42;
      if ( v43 < 0 )
        goto LABEL_35;
      while ( 1 )
      {
        v44 = *(_DWORD *)(v7 + 44) + 8 * v43;
        v45 = 2 * v53 * *(_BYTE *)v44 + 2 * v85 * *(_BYTE *)(v44 + 1) + 2 * v54 * *(_BYTE *)(v44 + 2);
        v88 = v45 >= v90 ? (v45 < v65) + 1 : 0;
        v46 = *(_DWORD *)(v44 + 4) * sub_10035010(v44, v7, (int)(&v67 + 4 * v88), *(_BYTE *)(v7 + 12));
        v37 = a3;
        v66 += (unsigned int)v46;
        if ( v66 >= *(_QWORD *)(a3 + 16) )
          break;
        *(_BYTE *)(--v43 + *(_DWORD *)(v7 + 152) + 1) = v88;
        if ( v43 < 0 )
        {
          v37 = a3;
          break;
        }
      }
      v27 = v85;
LABEL_36:
      if ( v66 < *(_QWORD *)(v37 + 16) )
      {
        *(_DWORD *)(v37 + 20) = HIDWORD(v66);
        *(_BYTE *)(v37 + 24) = v58 != 0;
        v38 = v37 + 4;
        *(_DWORD *)(v37 + 16) = v66;
        if ( v37 + 4 != v7 + 152 )
        {
          if ( *(_DWORD *)(v37 + 12) < *(_DWORD *)(v7 + 156) )
          {
            v47 = *(void **)v38;
            if ( *(_DWORD *)v38 )
            {
              if ( (unsigned __int8)v47 & 7 )
                sub_100927E0((int)"crnlib_free: bad ptr");
              else
                off_100AD9F4(v47, 0, 0, 1, dword_100AE9F4);
              *(_DWORD *)v38 = 0;
              *(_DWORD *)(v38 + 4) = 0;
              *(_DWORD *)(v38 + 8) = 0;
            }
            sub_100943C0(*(_DWORD *)(v7 + 156), 0, v38, 0, 1u, 0);
          }
          else if ( *(_DWORD *)(v37 + 8) )
          {
            *(_DWORD *)(v37 + 8) = 0;
          }
          memcpy(*(void **)v38, *(const void **)(v7 + 152), *(_DWORD *)(v7 + 156));
          v37 = a3;
          *(_DWORD *)(v38 + 4) = *(_DWORD *)(v7 + 156);
        }
        *(_BYTE *)(v37 + 25) = 1;
      }
      if ( ++v58 > v59 )
        goto LABEL_58;
      v23 = v61;
      v24 = v62;
      v25 = v60;
    }
    v31 = (unsigned __int64)(1431655766i64 * (v30 + v23 + 2 * v25)) >> 32;
    v75 = ((unsigned __int64)(1431655766i64 * (v30 + v56 + 2 * v57)) >> 32)
        + ((unsigned int)((unsigned __int64)(1431655766i64 * (v30 + v56 + 2 * v57)) >> 32) >> 31);
    v77 = v31 + (v31 >> 31);
    v80 = (signed int)(v30 + v62 + 2 * v55) / 3;
    v76 = ((unsigned __int64)(1431655766i64 * (signed int)(v30 + v55 + 2 * v24)) >> 32)
        + ((unsigned int)((unsigned __int64)(1431655766i64 * (signed int)(v30 + v55 + 2 * v24)) >> 32) >> 31);
    v79 = ((unsigned __int64)(1431655766i64 * (v30 + v57 + 2 * v56)) >> 32)
        + ((unsigned int)((unsigned __int64)(1431655766i64 * (v30 + v57 + 2 * v56)) >> 32) >> 31);
    v81 = (v30 + v60 + 2 * v61) / 3;
    v32 = v53 * v75 + v54 * v77 + v85 * v76;
    v82 = -1;
    v33 = v53 * v79 + v54 * v81 + v85 * v80;
    v34 = *(_DWORD *)(v7 + 48) - 1;
    v64 = v33 + v84;
    v89 = v32 + v33;
    for ( i = v83 + v32; v34 >= 0; *(_BYTE *)(--v34 + *(_DWORD *)(v7 + 152) + 1) = v87 )
    {
      v35 = *(_DWORD *)(v7 + 44) + 8 * v34;
      v36 = 2 * v53 * *(_BYTE *)v35 + 2 * v85 * *(_BYTE *)(v35 + 1) + 2 * v54 * *(_BYTE *)(v35 + 2);
      if ( v36 >= v89 )
      {
        LOBYTE(v36) = v36 < v64;
        v36 = 2 * v36 + 1;
        v87 = v36;
      }
      else
      {
        LOBYTE(v36) = v36 < i ? 0 : 2;
        v87 = v36;
      }
      v66 += (unsigned int)(*(_DWORD *)(v35 + 4)
                          * sub_10035010(v35, v7, (int)(&v67 + 4 * (unsigned __int8)v36), *(_BYTE *)(v7 + 12)));
      if ( v66 >= *(_QWORD *)(a3 + 16) )
        break;
    }
    v27 = v85;
LABEL_35:
    v37 = a3;
    goto LABEL_36;
  }
LABEL_58:
  if ( !*(_BYTE *)(a3 + 24) )
  {
    v48 = *(_WORD *)(a3 + 2);
    v49 = *(_WORD *)a3;
    if ( *(_WORD *)a3 == v48 )
    {
      if ( (v49 & 0x1F) == 31 )
      {
        *(_WORD *)(a3 + 2) = v48 - 1;
        v50 = 0;
      }
      else
      {
        *(_WORD *)a3 = v49 + 1;
        v50 = 1;
      }
      v51 = 0;
      if ( *(_DWORD *)(v7 + 48) )
      {
        do
          *(_BYTE *)(v51++ + *(_DWORD *)(a3 + 4)) = v50;
        while ( v51 < *(_DWORD *)(v7 + 48) );
      }
    }
  }
  if ( a5 && *(_QWORD *)(a3 + 16) < *(_QWORD *)(a5 + 16) )
  {
    sub_10034F80(a5, a3);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1007E440) --------------------------------------------------------
char __stdcall sub_1007E440(int a1, int a2, int a3, char a4, int a5, unsigned __int8 a6)
{
  int v6; // ecx@1
  int v7; // esi@1
  unsigned int v8; // eax@1
  unsigned int v9; // edi@1
  int v10; // eax@11
  unsigned int v11; // edi@16
  unsigned int v12; // eax@16
  unsigned int v13; // ebx@22
  unsigned int v14; // edx@22
  unsigned int v15; // eax@22
  char v16; // di@22
  int v17; // ebp@26
  int v18; // ebx@26
  int v19; // edi@26
  int v20; // ecx@26
  bool v21; // zf@26
  int v22; // eax@26
  int v23; // eax@27
  int v24; // edx@30
  int v25; // esi@30
  int v26; // edx@30
  int v27; // eax@30
  int v28; // edi@30
  int v29; // ecx@30
  int v30; // ebp@30
  unsigned int v31; // ST5C_4@30
  int v32; // ecx@30
  unsigned int v33; // edx@30
  int v34; // ecx@32
  char v35; // bl@33
  int v36; // esi@35
  int v37; // edi@35
  int v38; // ebp@41
  unsigned int v39; // edi@41
  char v40; // bl@41
  unsigned int v41; // eax@41
  unsigned int v42; // eax@43
  unsigned int v43; // eax@45
  int v44; // ebp@50
  int v45; // ebx@50
  int v46; // eax@50
  int v47; // eax@51
  int v48; // ecx@54
  int v49; // edx@54
  int v50; // edi@54
  int v51; // eax@54
  int v52; // edi@54
  unsigned int v53; // ebp@54
  unsigned int v54; // eax@54
  char v55; // bl@54
  unsigned int v56; // eax@56
  int v57; // eax@61
  int v58; // ebp@64
  unsigned int v59; // edi@64
  char v60; // bl@64
  unsigned int v61; // eax@64
  unsigned int v62; // eax@66
  void **v63; // edi@73
  void *v64; // eax@77
  __int16 v65; // di@87
  __int16 v66; // ax@87
  char v67; // dl@89
  unsigned int v68; // eax@91
  char result; // al@95
  int v70; // [sp+14h] [bp-78h]@22
  int v71; // [sp+18h] [bp-74h]@50
  int i; // [sp+24h] [bp-68h]@40
  unsigned int v73; // [sp+28h] [bp-64h]@22
  unsigned int v74; // [sp+2Ch] [bp-60h]@22
  unsigned int v75; // [sp+30h] [bp-5Ch]@11
  int v76; // [sp+30h] [bp-5Ch]@50
  int v77; // [sp+30h] [bp-5Ch]@61
  unsigned int v78; // [sp+34h] [bp-58h]@11
  unsigned __int8 v79; // [sp+38h] [bp-54h]@22
  unsigned __int8 v80; // [sp+3Ch] [bp-50h]@22
  int v81; // [sp+40h] [bp-4Ch]@26
  int v82; // [sp+44h] [bp-48h]@26
  char v83; // [sp+44h] [bp-48h]@30
  int v84; // [sp+48h] [bp-44h]@26
  int v85; // [sp+4Ch] [bp-40h]@27
  int v86; // [sp+4Ch] [bp-40h]@51
  unsigned int v87; // [sp+50h] [bp-3Ch]@22
  unsigned int v88; // [sp+54h] [bp-38h]@22
  int v89; // [sp+58h] [bp-34h]@28
  int v90; // [sp+5Ch] [bp-30h]@28
  int v91; // [sp+60h] [bp-2Ch]@28
  int v92; // [sp+64h] [bp-28h]@28
  int v93; // [sp+68h] [bp-24h]@28
  int v94; // [sp+6Ch] [bp-20h]@30
  int v95; // [sp+6Ch] [bp-20h]@54
  unsigned __int64 v96; // [sp+70h] [bp-1Ch]@25
  char v97; // [sp+78h] [bp-14h]@22
  char v98; // [sp+79h] [bp-13h]@22
  char v99; // [sp+7Ah] [bp-12h]@22
  char v100; // [sp+7Bh] [bp-11h]@22
  char v101; // [sp+7Ch] [bp-10h]@22
  char v102; // [sp+7Dh] [bp-Fh]@22
  char v103; // [sp+7Eh] [bp-Eh]@22
  char v104; // [sp+7Fh] [bp-Dh]@22
  unsigned __int8 v105; // [sp+80h] [bp-Ch]@26
  char v106; // [sp+81h] [bp-Bh]@26
  char v107; // [sp+82h] [bp-Ah]@26
  char v108; // [sp+83h] [bp-9h]@26
  char v109; // [sp+84h] [bp-8h]@26
  char v110; // [sp+85h] [bp-7h]@26
  char v111; // [sp+86h] [bp-6h]@26
  char v112; // [sp+87h] [bp-5h]@26

  v6 = a5;
  v7 = a1;
  *(_DWORD *)a2 = *(_DWORD *)a3;
  v8 = *(_DWORD *)(a2 + 8);
  v9 = *(_DWORD *)(a1 + 48);
  if ( v9 != v8 )
  {
    if ( v9 >= v8 )
    {
      if ( v9 > *(_DWORD *)(a2 + 12) )
        sub_100943C0(v9, 0, a2 + 4, v9 == v8 + 1, 1u, 0);
      memset((void *)(*(_DWORD *)(a2 + 8) + *(_DWORD *)(a2 + 4)), 0, v9 - *(_DWORD *)(a2 + 8));
      v6 = a5;
    }
    *(_DWORD *)(a2 + 8) = v9;
  }
  if ( v6 && a4 )
  {
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(v6 + 16);
    *(_DWORD *)(a2 + 20) = *(_DWORD *)(v6 + 20);
  }
  else
  {
    *(_DWORD *)(a2 + 16) = -1;
    *(_DWORD *)(a2 + 20) = -1;
  }
  *(_WORD *)(a2 + 24) = 0;
  v10 = *(_DWORD *)a1;
  v75 = 0;
  v78 = 1;
  if ( *(_BYTE *)(*(_DWORD *)a1 + 20) || *(_BYTE *)(v10 + 26) )
  {
    v75 = 1;
  }
  else if ( !*(_BYTE *)(v10 + 21) )
  {
    v78 = 0;
  }
  v11 = *(_DWORD *)(a1 + 48);
  v12 = *(_DWORD *)(a1 + 156);
  if ( v11 != v12 )
  {
    if ( v11 >= v12 )
    {
      if ( v11 > *(_DWORD *)(a1 + 160) )
        sub_100943C0(v11, 0, a1 + 152, v11 == v12 + 1, 1u, 0);
      memset((void *)(*(_DWORD *)(a1 + 156) + *(_DWORD *)(a1 + 152)), 0, v11 - *(_DWORD *)(a1 + 156));
    }
    *(_DWORD *)(a1 + 156) = v11;
  }
  v13 = 8 * (*(_WORD *)a3 & 0x1F) | ((*(_WORD *)a3 & 0x1Fu) >> 2);
  v14 = 4 * (((unsigned int)*(_WORD *)a3 >> 5) & 0x3F) | ((((unsigned int)*(_WORD *)a3 >> 5) & 0x3F) >> 4);
  v15 = *(_WORD *)(a3 + 2);
  v16 = *(_WORD *)(a3 + 2);
  v88 = 8 * ((unsigned int)*(_WORD *)a3 >> 11) | ((unsigned int)*(_WORD *)a3 >> 13);
  v97 = 8 * ((unsigned int)*(_WORD *)a3 >> 11) | ((unsigned int)*(_WORD *)a3 >> 13);
  v74 = 8 * (v16 & 0x1F) | ((v16 & 0x1Fu) >> 2);
  v87 = 4 * ((v15 >> 5) & 0x3F) | (((v15 >> 5) & 0x3F) >> 4);
  v102 = 4 * ((v15 >> 5) & 0x3F) | (((v15 >> 5) & 0x3F) >> 4);
  v103 = 8 * (v16 & 0x1F) | ((unsigned __int8)(v16 & 0x1F) >> 2);
  v79 = v13;
  v80 = v14;
  v98 = v14;
  v99 = v13;
  v100 = -1;
  v70 = 8 * (v15 >> 11) | (v15 >> 13);
  v101 = 8 * (v15 >> 11) | (v15 >> 13);
  v104 = -1;
  v73 = v75;
  if ( v75 <= v78 )
  {
    while ( 1 )
    {
      v96 = 0i64;
      if ( v73 )
      {
        v44 = (unsigned __int8)v13;
        v45 = (unsigned __int8)v14;
        v21 = *(_BYTE *)(v7 + 12) == 0;
        v107 = (v44 + a6 + (unsigned __int8)v74) >> 1;
        v46 = *(_DWORD *)(v7 + 48);
        v71 = v44;
        v76 = (unsigned __int8)v14;
        v105 = ((unsigned __int8)v88 + a6 + (unsigned __int8)v70) >> 1;
        v106 = ((unsigned __int8)v14 + (unsigned __int8)v87 + a6) >> 1;
        v108 = -1;
        if ( v21 )
        {
          v57 = v46 - 1;
          v77 = v57;
          if ( v57 >= 0 )
          {
            while ( 1 )
            {
              v58 = *(_DWORD *)(v7 + 44) + 8 * v57;
              v59 = sub_10035010(v58, v7, (int)&v97, 0);
              v60 = 0;
              v61 = sub_10035010(v58, v7, (int)&v101, 0);
              if ( v61 < v59 )
              {
                v59 = v61;
                v60 = 1;
              }
              v62 = sub_10035010(v58, v7, (int)&v105, 0);
              if ( v62 < v59 )
              {
                v59 = v62;
                v60 = 2;
              }
              v96 += v59 * *(_DWORD *)(v58 + 4);
              if ( v96 >= *(_QWORD *)(a2 + 16) )
                break;
              *(_BYTE *)(v77-- + *(_DWORD *)(v7 + 152)) = v60;
              if ( v77 < 0 )
                break;
              v57 = v77;
            }
          }
        }
        else
        {
          v47 = v46 - 1;
          v86 = v47;
          if ( v47 >= 0 )
          {
            while ( 1 )
            {
              v48 = *(_DWORD *)(v7 + 44);
              v49 = *(_BYTE *)(v48 + 8 * v47 + 1);
              v50 = v48 + 8 * v47;
              v51 = *(_BYTE *)v50;
              v95 = v50;
              v52 = *(_BYTE *)(v50 + 2);
              v53 = (v52 - v44) * (v52 - v44)
                  + 25 * (v49 - v45) * (v49 - v45)
                  + 8 * (v51 - (unsigned __int8)v88) * (v51 - (unsigned __int8)v88);
              v54 = (v52 - (unsigned __int8)v74) * (v52 - (unsigned __int8)v74)
                  + 25 * (v49 - (unsigned __int8)v87) * (v49 - (unsigned __int8)v87)
                  + 8 * (v51 - (unsigned __int8)v70) * (v51 - (unsigned __int8)v70);
              v55 = 0;
              if ( v54 < v53 )
              {
                v53 = v54;
                v55 = 1;
              }
              v7 = a1;
              v56 = sub_10035010(v95, a1, (int)&v105, 1);
              if ( v56 < v53 )
              {
                v53 = v56;
                v55 = 2;
              }
              v96 += v53 * *(_DWORD *)(v95 + 4);
              if ( v96 >= *(_QWORD *)(a2 + 16) )
                break;
              *(_BYTE *)(v86 + *(_DWORD *)(a1 + 152)) = v55;
              v47 = v86 - 1;
              v86 = v47;
              if ( v47 < 0 )
                break;
              v45 = v76;
              v44 = v71;
            }
          }
        }
      }
      else
      {
        v17 = v80;
        v18 = ((unsigned __int8)v74 + a6 + 2 * v79) / 3;
        v81 = ((unsigned __int8)v87 + a6 + 2 * v80) / 3;
        v19 = (unsigned __int8)v88;
        v105 = ((unsigned __int64)(1431655766i64 * ((unsigned __int8)v70 + a6 + 2 * (unsigned __int8)v88)) >> 32)
             + ((unsigned int)((unsigned __int64)(1431655766i64 * ((unsigned __int8)v70 + a6 + 2 * (unsigned __int8)v88)) >> 32) >> 31);
        v106 = v81;
        v84 = (v79 + a6 + 2 * (unsigned __int8)v74) / 3;
        v82 = (v80 + a6 + 2 * (unsigned __int8)v87) / 3;
        v20 = ((unsigned __int8)v88 + a6 + 2 * (unsigned __int8)v70) / 3;
        v21 = *(_BYTE *)(v7 + 12) == 0;
        v111 = v84;
        v22 = *(_DWORD *)(v7 + 48);
        v107 = v18;
        v108 = 0;
        v109 = v20;
        v110 = v82;
        v112 = 0;
        if ( v21 )
        {
          for ( i = v22 - 1; i >= 0; *(_BYTE *)(i-- + *(_DWORD *)(v7 + 152)) = v40 )
          {
            v38 = *(_DWORD *)(v7 + 44) + 8 * i;
            v39 = sub_10035010(v38, v7, (int)&v97, 0);
            v40 = 0;
            v41 = sub_10035010(v38, v7, (int)&v101, 0);
            if ( v41 < v39 )
            {
              v39 = v41;
              v40 = 1;
            }
            v42 = sub_10035010(v38, v7, (int)&v105, 0);
            if ( v42 < v39 )
            {
              v39 = v42;
              v40 = 2;
            }
            v43 = sub_10035010(v38, v7, (int)&v109, 0);
            if ( v43 < v39 )
            {
              v39 = v43;
              v40 = 3;
            }
            v96 += v39 * *(_DWORD *)(v38 + 4);
            if ( v96 >= *(_QWORD *)(a2 + 16) )
              break;
          }
        }
        else
        {
          v23 = v22 - 1;
          v85 = v23;
          if ( v23 >= 0 )
          {
            v89 = v105;
            v81 = (unsigned __int8)v81;
            v90 = (unsigned __int8)v18;
            v91 = (unsigned __int8)v20;
            v92 = (unsigned __int8)v82;
            v93 = (unsigned __int8)v84;
            while ( 1 )
            {
              v24 = *(_DWORD *)(v7 + 44);
              v25 = *(_BYTE *)(v24 + 8 * v23);
              v26 = v24 + 8 * v23;
              v27 = v25 - v19;
              v28 = *(_BYTE *)(v26 + 1);
              v29 = v28 - v17;
              v30 = *(_BYTE *)(v26 + 2);
              v94 = v26;
              v83 = 0;
              v31 = (v30 - v79) * (v30 - v79) + 25 * v29 * v29 + 8 * v27 * v27;
              v32 = (v30 - (unsigned __int8)v74) * (v30 - (unsigned __int8)v74)
                  + 25 * (v28 - (unsigned __int8)v87) * (v28 - (unsigned __int8)v87);
              v33 = v31;
              if ( v32 + 8 * (v25 - (unsigned __int8)v70) * (v25 - (unsigned int)(unsigned __int8)v70) < v31 )
              {
                v33 = v32 + 8 * (v25 - (unsigned __int8)v70) * (v25 - (unsigned __int8)v70);
                v83 = 1;
              }
              v34 = (v30 - v90) * (v30 - v90) + 25 * (v28 - v81) * (v28 - v81);
              if ( v34 + 8 * (v25 - v89) * (v25 - v89) >= v33 )
              {
                v35 = v83;
              }
              else
              {
                v33 = v34 + 8 * (v25 - v89) * (v25 - v89);
                v35 = 2;
              }
              v36 = (v25 - v91) * (v25 - v91);
              v37 = (v30 - v93) * (v30 - v93) + 25 * (v28 - v92) * (v28 - v92);
              if ( v37 + 8 * v36 < v33 )
              {
                v33 = v37 + 8 * v36;
                v35 = 3;
              }
              v96 += v33 * *(_DWORD *)(v94 + 4);
              if ( v96 >= *(_QWORD *)(a2 + 16) )
                break;
              v7 = a1;
              *(_BYTE *)(v85 + *(_DWORD *)(a1 + 152)) = v35;
              v23 = v85 - 1;
              v85 = v23;
              if ( v23 < 0 )
                goto LABEL_72;
              v17 = v80;
              v19 = (unsigned __int8)v88;
            }
            v7 = a1;
          }
        }
      }
LABEL_72:
      if ( v96 < *(_QWORD *)(a2 + 16) )
      {
        v63 = (void **)(a2 + 4);
        *(_QWORD *)(a2 + 16) = v96;
        *(_BYTE *)(a2 + 24) = v73 != 0;
        if ( a2 + 4 != v7 + 152 )
        {
          if ( *(_DWORD *)(a2 + 12) < *(_DWORD *)(v7 + 156) )
          {
            v64 = *v63;
            if ( *v63 )
            {
              if ( (unsigned __int8)v64 & 7 )
                sub_100927E0((int)"crnlib_free: bad ptr");
              else
                off_100AD9F4(v64, 0, 0, 1, dword_100AE9F4);
              *v63 = 0;
              *(_DWORD *)(a2 + 8) = 0;
              *(_DWORD *)(a2 + 12) = 0;
            }
            sub_100943C0(*(_DWORD *)(v7 + 156), 0, a2 + 4, 0, 1u, 0);
          }
          else if ( *(_DWORD *)(a2 + 8) )
          {
            *(_DWORD *)(a2 + 8) = 0;
          }
          memcpy(*v63, *(const void **)(v7 + 152), *(_DWORD *)(v7 + 156));
          *(_DWORD *)(a2 + 8) = *(_DWORD *)(v7 + 156);
        }
        *(_BYTE *)(a2 + 25) = 1;
      }
      if ( ++v73 > v78 )
        break;
      LOBYTE(v13) = v79;
      LOBYTE(v14) = v80;
    }
  }
  if ( !*(_BYTE *)(a2 + 24) )
  {
    v65 = *(_WORD *)(a2 + 2);
    v66 = *(_WORD *)a2;
    if ( *(_WORD *)a2 == v65 )
    {
      if ( (v66 & 0x1F) == 31 )
      {
        *(_WORD *)(a2 + 2) = v65 - 1;
        v67 = 0;
      }
      else
      {
        *(_WORD *)a2 = v66 + 1;
        v67 = 1;
      }
      v68 = 0;
      if ( *(_DWORD *)(v7 + 48) )
      {
        do
          *(_BYTE *)(v68++ + *(_DWORD *)(a2 + 4)) = v67;
        while ( v68 < *(_DWORD *)(v7 + 48) );
      }
    }
  }
  if ( a5 && *(_QWORD *)(a2 + 16) < *(_QWORD *)(a5 + 16) )
  {
    sub_10034F80(a5, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1007ED40) --------------------------------------------------------
char __userpurge sub_1007ED40@<al>(_DWORD *a1@<eax>, char a2@<dl>, unsigned __int8 a3@<cl>, unsigned int a4, int a5)
{
  int v5; // ebx@3
  char result; // al@5

  ++*(_DWORD *)(a4 + 232);
  if ( !*(_DWORD *)(a4 + 8) || a3 )
  {
    if ( *(_DWORD *)(*(_DWORD *)a4 + 16) < 3 )
      result = sub_1007DD40(a1, a4, a4 + 240, a2, a5, a3);
    else
      result = sub_1007E440(a4, a4 + 240, (int)a1, a2, a5, a3);
  }
  else
  {
    sub_1007E440(a4, a4 + 240, (int)a1, 0, 0, 0);
    sub_10035930(*(_DWORD *)(a4 + 8), *(_DWORD *)(*(_DWORD *)(a4 + 8) + 4) + 1);
    v5 = **(_DWORD **)(a4 + 8) + 40 * *(_DWORD *)(*(_DWORD *)(a4 + 8) + 4) - 40;
    sub_10033010(v5 + 24, *(_DWORD *)(*(_DWORD *)a4 + 8));
    *(_DWORD *)(v5 + 12) = *(_DWORD *)(v5 + 24);
    sub_1007D4E0(a4 + 240, a4, v5);
    if ( a5 && *(_QWORD *)(a4 + 256) < *(_QWORD *)(a4 + 288) )
    {
      sub_10034F80(a5, a4 + 240);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (1007EE30) --------------------------------------------------------
char __thiscall sub_1007EE30(void *this, unsigned int a2)
{
  double v2; // st6@1
  unsigned int v3; // ebp@1
  double v4; // st5@1
  unsigned int v5; // edx@1
  double v6; // st7@1
  void *v7; // ebx@1
  double v8; // st4@1
  unsigned int v9; // esi@2
  double v10; // st3@2
  int v11; // ecx@2
  int v12; // edi@2
  double v13; // st2@3
  double v14; // st1@3
  int v15; // eax@3
  double v16; // st0@3
  int v17; // eax@3
  int v18; // ebp@3
  double v19; // st0@3
  double v20; // rtt@3
  long double v21; // st2@3
  bool v22; // c3@7
  long double v23; // st3@7
  long double v24; // st2@9
  signed int v25; // eax@9
  signed int v26; // edi@14
  signed int v27; // eax@14
  int v28; // edi@18
  signed int v29; // eax@18
  unsigned __int16 v30; // di@22
  signed int v31; // eax@22
  signed int v32; // esi@26
  signed int v33; // eax@26
  int v34; // esi@30
  signed int v35; // eax@30
  unsigned __int16 v36; // ax@34
  signed int v38; // eax@42
  signed int v39; // eax@46
  signed int v40; // eax@50
  signed int v41; // eax@54
  signed int v42; // eax@58
  char *v43; // edi@62
  signed int v44; // ebx@63
  int v45; // eax@66
  int v46; // eax@70
  int v47; // eax@74
  signed int v48; // eax@78
  signed int v49; // edx@78
  signed int v50; // ecx@78
  signed int v51; // esi@84
  int v52; // eax@84
  signed int v53; // edx@84
  int v54; // eax@84
  signed int v55; // ecx@84
  int v56; // ecx@90
  __int16 v57; // dx@91
  unsigned int v58; // ebx@95
  int v59; // ebp@95
  int v60; // ebx@95
  unsigned int v61; // edi@95
  unsigned int v62; // eax@95
  _DWORD *v63; // esi@95
  char v64; // al@103
  bool v65; // zf@112
  signed int v66; // eax@118
  signed int v67; // eax@122
  char v68; // bl@123
  signed int v69; // eax@126
  signed int v70; // eax@130
  signed int v71; // eax@134
  int v72; // edx@139
  int v73; // eax@141
  char v74; // cl@148
  int v75; // eax@151
  int v76; // edi@157
  int v77; // eax@158
  int v78; // eax@162
  int v79; // eax@166
  signed int v80; // eax@170
  signed int v81; // edx@170
  signed int v82; // ecx@170
  signed int v83; // esi@176
  int v84; // eax@176
  signed int v85; // edx@176
  int v86; // eax@176
  signed int v87; // ecx@176
  int v88; // ecx@182
  unsigned int v89; // ebx@185
  _DWORD *v90; // ebp@185
  int v91; // ebx@185
  unsigned int v92; // edi@185
  unsigned int v93; // eax@185
  _DWORD *v94; // esi@185
  _DWORD *v95; // ebx@193
  int v96; // edi@193
  void *v97; // eax@197
  FILE *v98; // eax@199
  unsigned int v99; // esi@203
  void *v100; // ecx@204
  int v101; // eax@204
  FILE *v102; // eax@205
  CHAR *v103; // ecx@205
  int v104; // ebx@208
  int v105; // eax@214
  FILE *v106; // eax@215
  unsigned int v107; // eax@219
  char v108; // al@223
  int v109; // [sp-Ch] [bp-998h]@105
  char v110; // [sp+13h] [bp-979h]@9
  double v111; // [sp+14h] [bp-978h]@1
  int v112; // [sp+20h] [bp-96Ch]@34
  double v113; // [sp+24h] [bp-968h]@3
  _DWORD *v114; // [sp+2Ch] [bp-960h]@84
  int v115; // [sp+30h] [bp-95Ch]@3
  long double v116; // [sp+34h] [bp-958h]@1
  double *v117; // [sp+3Ch] [bp-950h]@62
  int v118; // [sp+40h] [bp-94Ch]@64
  int v119; // [sp+44h] [bp-948h]@63
  int v120; // [sp+48h] [bp-944h]@62
  double v121; // [sp+4Ch] [bp-940h]@1
  double v122; // [sp+54h] [bp-938h]@1
  double v123; // [sp+5Ch] [bp-930h]@3
  double v124; // [sp+64h] [bp-928h]@1
  int v125; // [sp+70h] [bp-91Ch]@155
  int v126; // [sp+74h] [bp-918h]@141
  int v127; // [sp+78h] [bp-914h]@139
  double v128; // [sp+7Ch] [bp-910h]@3
  int v129; // [sp+88h] [bp-904h]@141
  char DstBuf; // [sp+8Ch] [bp-900h]@199
  CHAR OutputString; // [sp+28Ch] [bp-700h]@205
  CHAR v132; // [sp+48Ch] [bp-500h]@210
  CHAR v133; // [sp+68Ch] [bp-300h]@215
  char v134; // [sp+88Ch] [bp-100h]@215

  v2 = 0.0;
  v3 = a2;
  v4 = 0.0;
  v5 = 0;
  v6 = 0.0;
  v122 = 0.0;
  v7 = this;
  v116 = 0.0;
  v8 = 0.0;
  v124 = 0.0;
  v121 = 0.0;
  v111 = 0.0;
  if ( *(_DWORD *)(a2 + 48) )
  {
    v9 = *(_DWORD *)(a2 + 48);
    v10 = 0.0;
    v11 = *(_DWORD *)(a2 + 44);
    v12 = *(_DWORD *)(a2 + 276);
    do
    {
      v13 = (double)*(unsigned int *)(v11 + 4);
      v115 = *(_BYTE *)v11;
      v14 = (double)v115;
      v115 = *(_BYTE *)(v11 + 1);
      v15 = *(_BYTE *)(v11 + 2);
      v128 = v14 * v13;
      ++v5;
      v16 = (double)v115;
      v115 = v15;
      v17 = *(_BYTE *)(v12 + v5 - 1) ^ 1;
      v18 = dword_100A4F38[v17];
      v113 = v16 * v13;
      v11 += 8;
      v19 = (double)v115;
      v115 = v18;
      v123 = v19 * v13;
      v2 = v2 + (double)dword_100A4F48[v17] * v13;
      v4 = v4 + (double)dword_100A504C[v17] * v13;
      v6 = v6 + v13 * (double)dword_100A4F58[v17];
      v20 = (double)v18;
      v8 = v8 + v128 * v20;
      v116 = v113 * v20 + v116;
      v122 = v20 * v123 + v122;
      v111 = v128 + v111;
      v121 = v113 + v121;
      v21 = v116;
      v124 = v123 + v124;
    }
    while ( v5 < v9 );
    v3 = a2;
  }
  else
  {
    v21 = 0.0;
    v10 = 0.0;
  }
  v111 = v111 * 3.0 - v8;
  v121 = v121 * 3.0 - v21;
  v124 = 3.0 * v124 - v122;
  v116 = v6 * v4 - v2 * v2;
  if ( v10 == v4 )
    return 0;
  v22 = v6 == v10;
  v23 = v21;
  if ( v22 || fabs(v116) < 0.00001249999968422344 )
    return 0;
  v24 = 0.364705890417099 / v116;
  v110 = 0;
  v123 = 2.032258033752441 * (0.364705890417099 / v116);
  v25 = (signed int)((v8 * v4 - v111 * v2) * (0.364705890417099 / v116) + 0.5);
  if ( !v7 )
  {
    if ( v25 >= 0 )
    {
      if ( v25 > 31 )
        v25 = 31;
    }
    else
    {
      v25 = 0;
    }
    v26 = v25 << 11;
    v27 = (signed int)((v23 * v4 - v121 * v2) * v123 + 0.5);
    if ( v27 >= 0 )
    {
      if ( v27 > 63 )
        v27 = 63;
    }
    else
    {
      v27 = 0;
    }
    v28 = 32 * v27 | v26;
    v29 = (signed int)((v4 * v122 - v124 * v2) * v24 + 0.5);
    if ( v29 >= 0 )
    {
      if ( v29 > 31 )
        LOWORD(v29) = 31;
    }
    else
    {
      LOWORD(v29) = 0;
    }
    v30 = v29 | v28;
    v31 = (signed int)((v111 * v6 - v8 * v2) * v24 + 0.5);
    if ( v31 >= 0 )
    {
      if ( v31 > 31 )
        v31 = 31;
    }
    else
    {
      v31 = 0;
    }
    v32 = v31 << 11;
    v33 = (signed int)((v121 * v6 - v23 * v2) * v123 + 0.5);
    if ( v33 >= 0 )
    {
      if ( v33 > 63 )
        v33 = 63;
    }
    else
    {
      v33 = 0;
    }
    v34 = 32 * v33 | v32;
    v35 = (signed int)((v6 * v124 - v2 * v122) * v24 + 0.5);
    if ( v35 >= 0 )
    {
      if ( v35 > 31 )
        LOWORD(v35) = 31;
    }
    else
    {
      LOWORD(v35) = 0;
    }
    v36 = v34 | v35;
    LOWORD(v112) = v36;
    HIWORD(v112) = v30;
    if ( v36 < v30 )
    {
      LOWORD(v112) = v30;
      HIWORD(v112) = v36;
    }
    return sub_1007ED40(&v112, 1, 0, v3, v3 + 272);
  }
  if ( v7 != (void *)1 )
  {
    if ( v25 >= 0 )
    {
      LOBYTE(v116) = 31;
      if ( v25 <= 31 )
        LOBYTE(v116) = v25;
    }
    else
    {
      LOBYTE(v116) = 0;
    }
    v66 = (signed int)((v23 * v4 - v121 * v2) * v123 + 0.5);
    if ( v66 >= 0 )
    {
      BYTE1(v116) = 63;
      if ( v66 <= 63 )
        BYTE1(v116) = (signed int)((v23 * v4 - v121 * v2) * v123 + 0.5);
    }
    else
    {
      BYTE1(v116) = 0;
    }
    v67 = (signed int)((v4 * v122 - v124 * v2) * v24 + 0.5);
    if ( v67 >= 0 )
    {
      v68 = 31;
      if ( v67 <= 31 )
        v68 = (signed int)((v4 * v122 - v124 * v2) * v24 + 0.5);
    }
    else
    {
      v68 = 0;
    }
    v69 = (signed int)((v111 * v6 - v8 * v2) * v24 + 0.5);
    if ( v69 >= 0 )
    {
      BYTE4(v116) = 31;
      if ( v69 <= 31 )
        BYTE4(v116) = (signed int)((v111 * v6 - v8 * v2) * v24 + 0.5);
    }
    else
    {
      BYTE4(v116) = 0;
    }
    v70 = (signed int)((v121 * v6 - v23 * v2) * v123 + 0.5);
    if ( v70 >= 0 )
    {
      BYTE5(v116) = 63;
      if ( v70 <= 63 )
        BYTE5(v116) = (signed int)((v121 * v6 - v23 * v2) * v123 + 0.5);
    }
    else
    {
      BYTE5(v116) = 0;
    }
    v71 = (signed int)((v6 * v124 - v2 * v122) * v24 + 0.5);
    if ( v71 >= 0 )
    {
      BYTE6(v116) = 31;
      if ( v71 <= 31 )
        BYTE6(v116) = (signed int)((v6 * v124 - v2 * v122) * v24 + 0.5);
    }
    else
    {
      BYTE6(v116) = 0;
    }
    v119 = -1;
    LODWORD(v128) = (unsigned __int8)v68;
    v114 = (_DWORD *)(v3 + 272);
    while ( 1 )
    {
      v72 = LOBYTE(v116) + v119;
      v120 = -1;
      v127 = LOBYTE(v116) + v119;
      while ( 2 )
      {
        v73 = v120 + BYTE1(v116);
        v126 = -1;
        v129 = v120 + BYTE1(v116);
        while ( 2 )
        {
          WORD2(v111) = WORD2(v116);
          BYTE6(v111) = BYTE6(v116);
          if ( v72 >= 0 )
          {
            if ( v72 > 31 )
              LOBYTE(v72) = 31;
          }
          else
          {
            LOBYTE(v72) = 0;
          }
          if ( v73 >= 0 )
          {
            v74 = 63;
            if ( v73 <= 63 )
              v74 = v73;
          }
          else
          {
            v74 = 0;
          }
          v75 = v126 + LODWORD(v128);
          if ( v126 + LODWORD(v128) >= 0 )
          {
            if ( v75 > 31 )
              LOBYTE(v75) = 31;
          }
          else
          {
            LOBYTE(v75) = 0;
          }
          LODWORD(v123) = (unsigned __int8)v72;
          v125 = -1;
          LODWORD(v124) = (unsigned __int8)v74;
          LODWORD(v122) = (unsigned __int8)v75;
          do
          {
            v118 = -1;
            do
            {
              v76 = a2;
              v117 = (double *)-1;
              do
              {
                v77 = v125 + BYTE4(v111);
                if ( v77 >= 0 )
                {
                  BYTE4(v111) = 31;
                  if ( v77 <= 31 )
                    BYTE4(v111) = v77;
                }
                else
                {
                  BYTE4(v111) = 0;
                }
                v78 = v118 + BYTE5(v111);
                if ( v78 >= 0 )
                {
                  BYTE5(v111) = 63;
                  if ( v78 <= 63 )
                    BYTE5(v111) = v78;
                }
                else
                {
                  BYTE5(v111) = 0;
                }
                v79 = (int)v117 + BYTE6(v111);
                if ( v79 >= 0 )
                {
                  BYTE6(v111) = 31;
                  if ( v79 <= 31 )
                    BYTE6(v111) = v79;
                }
                else
                {
                  BYTE6(v111) = 0;
                }
                v80 = LODWORD(v123);
                v81 = LODWORD(v124);
                v82 = LODWORD(v122);
                if ( LODWORD(v123) >= 0x1F )
                  v80 = 31;
                if ( LODWORD(v124) >= 0x3F )
                  v81 = 63;
                if ( LODWORD(v122) >= 0x1F )
                  v82 = 31;
                v83 = BYTE5(v111);
                v84 = v81 | (v80 << 6);
                v85 = BYTE6(v111);
                v86 = v82 | 32 * v84;
                v87 = BYTE4(v111);
                LOWORD(v112) = v86;
                if ( BYTE4(v111) >= 0x1Fu )
                  v87 = 31;
                if ( BYTE5(v111) >= 0x3Fu )
                  v83 = 63;
                if ( BYTE6(v111) >= 0x1Fu )
                  v85 = 31;
                v88 = v85 | 32 * (v83 | (v87 << 6));
                HIWORD(v112) = v88;
                if ( (unsigned __int16)v86 < (unsigned __int16)v88 )
                {
                  LOWORD(v112) = v88;
                  HIWORD(v112) = v86;
                }
                ++*(_DWORD *)(v76 + 232);
                if ( *(_DWORD *)(v76 + 8) )
                {
                  v89 = a2;
                  v90 = (_DWORD *)(a2 + 240);
                  sub_1007E440(a2, a2 + 240, (int)&v112, 0, 0, 0);
                  sub_10035930(*(_DWORD *)(v89 + 8), *(_DWORD *)(*(_DWORD *)(v89 + 8) + 4) + 1);
                  v91 = **(_DWORD **)(v89 + 8) + 40 * *(_DWORD *)(*(_DWORD *)(v89 + 8) + 4) - 40;
                  v92 = *(_DWORD *)(*(_DWORD *)a2 + 8);
                  v93 = *(_DWORD *)(v91 + 28);
                  v94 = (_DWORD *)(v91 + 24);
                  if ( v92 != v93 )
                  {
                    if ( v92 >= v93 )
                    {
                      if ( v92 > *(_DWORD *)(v91 + 32) )
                      {
                        LOBYTE(v121) = v92 == v93 + 1;
                        sub_100943C0(v92, 0, v91 + 24, v92 == v93 + 1, 1u, 0);
                      }
                      memset((void *)(*(_DWORD *)(v91 + 28) + *v94), 0, v92 - *(_DWORD *)(v91 + 28));
                    }
                    *(_DWORD *)(v91 + 28) = v92;
                  }
                  *(_DWORD *)(v91 + 12) = *v94;
                  sub_1007D4E0((int)v90, a2, v91);
                  if ( v114 && *(_QWORD *)(a2 + 256) < *(_QWORD *)(a2 + 288) )
                  {
                    v95 = v114;
                    *v114 = *v90;
                    v96 = (int)(v95 + 1);
                    if ( v95 + 1 != (_DWORD *)(a2 + 244) )
                    {
                      if ( v95[3] >= *(_DWORD *)(a2 + 248) )
                      {
                        if ( v95[2] )
                          v95[2] = 0;
                        goto LABEL_222;
                      }
                      v97 = *(void **)v96;
                      if ( *(_DWORD *)v96 )
                      {
                        if ( (unsigned __int8)v97 & 7 )
                        {
                          sprintf_s(
                            &DstBuf,
                            0x200u,
                            "%s(%u): Assertion failed: \"%s\"\n",
                            "crn_mem.cpp",
                            216,
                            "crnlib_free: bad ptr");
                          OutputDebugStringA(&DstBuf);
                          v98 = _iob_func();
                          fputs(&DstBuf, v98 + 2);
                          if ( IsDebuggerPresent() )
                            DebugBreak();
                        }
                        else
                        {
                          off_100AD9F4(v97, 0, 0, 1, dword_100AE9F4);
                        }
                        *(_DWORD *)v96 = 0;
                        v95[2] = 0;
                        v95[3] = 0;
                      }
                      v99 = *(_DWORD *)(a2 + 248);
                      if ( v95[3] < v99 )
                      {
                        v100 = *(void **)v96;
                        v101 = *(_DWORD *)(a2 + 248);
                        if ( *(_DWORD *)v96 & 7 )
                        {
                          sprintf_s(
                            &OutputString,
                            0x200u,
                            "%s(%u): Assertion failed: \"%s\"\n",
                            "crn_mem.cpp",
                            216,
                            "crnlib_realloc: bad ptr");
                          OutputDebugStringA(&OutputString);
                          v102 = _iob_func();
                          v103 = &OutputString;
                          goto LABEL_206;
                        }
                        if ( v99 <= 0x7FFF0000 )
                        {
                          if ( v99 && v99 < 4 )
                            v101 = 4;
                          v115 = v101;
                          v105 = off_100AD9F4(v100, v101, &v115, 1, dword_100AE9F4);
                          LODWORD(v113) = v115;
                          v104 = v105;
                          if ( !v105 )
                            goto LABEL_215;
                        }
                        else
                        {
                          sprintf_s(
                            &v132,
                            0x200u,
                            "%s(%u): Assertion failed: \"%s\"\n",
                            "crn_mem.cpp",
                            216,
                            "crnlib_malloc: size too big");
                          OutputDebugStringA(&v132);
                          v102 = _iob_func();
                          v103 = &v132;
LABEL_206:
                          fputs(v103, v102 + 2);
                          if ( IsDebuggerPresent() )
                            DebugBreak();
                          v104 = 0;
LABEL_215:
                          sprintf_s(&v134, 0x100u, "vector: crnlib_realloc() failed allocating %u bytes", v99);
                          sprintf_s(&v133, 0x200u, "%s(%u): Failure: \"%s\"\n", "crn_vector.cpp", 46, "buf");
                          OutputDebugStringA(&v133);
                          v106 = _iob_func();
                          fputs(&v133, v106 + 2);
                          if ( IsDebuggerPresent() )
                            DebugBreak();
                          if ( !byte_100AE9F8 )
                            exit(1);
                          RaiseException(0x100u, 0, 0, 0);
                        }
                        v107 = LODWORD(v113);
                        *(_DWORD *)v96 = v104;
                        v95 = v114;
                        if ( v107 <= v99 )
                          *(_DWORD *)(v96 + 8) = v99;
                        else
                          *(_DWORD *)(v96 + 8) = v107;
                      }
LABEL_222:
                      memcpy(*(void **)v96, *(const void **)(a2 + 244), *(_DWORD *)(a2 + 248));
                      *(_DWORD *)(v96 + 4) = *(_DWORD *)(a2 + 248);
                    }
                    v76 = a2;
                    v95[4] = *(_DWORD *)(a2 + 256);
                    v95[5] = *(_DWORD *)(a2 + 260);
                    *((_BYTE *)v95 + 24) = *(_BYTE *)(a2 + 264);
                    *((_BYTE *)v95 + 25) = *(_BYTE *)(a2 + 265);
                    v108 = 1;
                    goto LABEL_228;
                  }
                  v108 = 0;
                  v76 = a2;
                }
                else if ( *(_DWORD *)(*(_DWORD *)v76 + 16) < 3 )
                {
                  v108 = sub_1007DD40(&v112, v76, v76 + 240, 1, (int)v114, 0);
                }
                else
                {
                  v108 = sub_1007E440(v76, v76 + 240, (int)&v112, 1, (int)v114, 0);
                }
LABEL_228:
                v110 |= v108;
                v117 = (double *)((char *)v117 + 1);
              }
              while ( (signed int)v117 <= 1 );
              ++v118;
            }
            while ( v118 <= 1 );
            ++v125;
          }
          while ( v125 <= 1 );
          if ( ++v126 <= 1 )
          {
            v72 = v127;
            v73 = v129;
            continue;
          }
          break;
        }
        if ( ++v120 <= 1 )
        {
          v72 = v127;
          continue;
        }
        break;
      }
      if ( ++v119 > 1 )
        return v110;
    }
  }
  if ( v25 >= 0 )
  {
    LOBYTE(v113) = 31;
    if ( v25 <= 31 )
      LOBYTE(v113) = (signed int)((v8 * v4 - v111 * v2) * (0.364705890417099 / v116) + 0.5);
  }
  else
  {
    LOBYTE(v113) = 0;
  }
  v38 = (signed int)((v23 * v4 - v121 * v2) * v123 + 0.5);
  if ( v38 >= 0 )
  {
    BYTE1(v113) = 63;
    if ( v38 <= 63 )
      BYTE1(v113) = (signed int)((v23 * v4 - v121 * v2) * v123 + 0.5);
  }
  else
  {
    BYTE1(v113) = 0;
  }
  v39 = (signed int)((v4 * v122 - v124 * v2) * v24 + 0.5);
  if ( v39 >= 0 )
  {
    BYTE2(v113) = 31;
    if ( v39 <= 31 )
      BYTE2(v113) = (signed int)((v4 * v122 - v124 * v2) * v24 + 0.5);
  }
  else
  {
    BYTE2(v113) = 0;
  }
  v40 = (signed int)((v111 * v6 - v8 * v2) * v24 + 0.5);
  if ( v40 >= 0 )
  {
    BYTE4(v113) = 31;
    if ( v40 <= 31 )
      BYTE4(v113) = (signed int)((v111 * v6 - v8 * v2) * v24 + 0.5);
  }
  else
  {
    BYTE4(v113) = 0;
  }
  v41 = (signed int)((v121 * v6 - v23 * v2) * v123 + 0.5);
  if ( v41 >= 0 )
  {
    BYTE5(v113) = 63;
    if ( v41 <= 63 )
      BYTE5(v113) = (signed int)((v121 * v6 - v23 * v2) * v123 + 0.5);
  }
  else
  {
    BYTE5(v113) = 0;
  }
  v42 = (signed int)((v6 * v124 - v2 * v122) * v24 + 0.5);
  if ( v42 >= 0 )
  {
    BYTE6(v113) = 31;
    if ( v42 <= 31 )
      BYTE6(v113) = (signed int)((v6 * v124 - v2 * v122) * v24 + 0.5);
  }
  else
  {
    BYTE6(v113) = 0;
  }
  v43 = (char *)&v111 + 1;
  v117 = (double *)((char *)&v111 + 1);
  v120 = 2;
  do
  {
    v44 = -1;
    v119 = -1;
    do
    {
      v118 = -1;
      do
      {
        v112 = -1;
        do
        {
          LOBYTE(v111) = LOBYTE(v113);
          *(_WORD *)((char *)&v111 + 1) = *(_WORD *)((char *)&v113 + 1);
          BYTE3(v111) = 0;
          BYTE4(v111) = BYTE4(v113);
          *(_WORD *)((char *)&v111 + 5) = *(_WORD *)((char *)&v113 + 5);
          BYTE7(v111) = 0;
          v45 = v44 + (unsigned __int8)*(v43 - 1);
          if ( v45 >= 0 )
          {
            if ( v45 > 31 )
              LOBYTE(v45) = 31;
          }
          else
          {
            LOBYTE(v45) = 0;
          }
          *(v43 - 1) = v45;
          v46 = v118 + (unsigned __int8)*v43;
          if ( v46 >= 0 )
          {
            if ( v46 > 63 )
              LOBYTE(v46) = 63;
          }
          else
          {
            LOBYTE(v46) = 0;
          }
          *v43 = v46;
          v47 = v112 + (unsigned __int8)v43[1];
          if ( v47 >= 0 )
          {
            if ( v47 > 31 )
              LOBYTE(v47) = 31;
          }
          else
          {
            LOBYTE(v47) = 0;
          }
          v43[1] = v47;
          v48 = LOBYTE(v111);
          v49 = BYTE1(v111);
          v50 = BYTE2(v111);
          if ( LOBYTE(v111) >= 0x1Fu )
            v48 = 31;
          if ( BYTE1(v111) >= 0x3Fu )
            v49 = 63;
          if ( BYTE2(v111) >= 0x1Fu )
            v50 = 31;
          v51 = BYTE5(v111);
          v52 = v49 | (v48 << 6);
          v53 = BYTE6(v111);
          v54 = v50 | 32 * v52;
          v55 = BYTE4(v111);
          LOWORD(v114) = v54;
          if ( BYTE4(v111) >= 0x1Fu )
            v55 = 31;
          if ( BYTE5(v111) >= 0x3Fu )
            v51 = 63;
          if ( BYTE6(v111) >= 0x1Fu )
            v53 = 31;
          v56 = v53 | 32 * (v51 | (v55 << 6));
          HIWORD(v114) = v56;
          if ( (unsigned __int16)v54 < (unsigned __int16)v56 )
          {
            v57 = v54;
            LOWORD(v54) = v56;
            LOWORD(v56) = v57;
            LOWORD(v114) = v54;
            HIWORD(v114) = v57;
          }
          if ( (_WORD)v54 != *(_WORD *)(v3 + 272) || (_WORD)v56 != *(_WORD *)(v3 + 274) )
          {
            ++*(_DWORD *)(v3 + 232);
            if ( *(_DWORD *)(v3 + 8) )
            {
              v58 = a2;
              v59 = a2 + 240;
              sub_1007E440(a2, a2 + 240, (int)&v114, 0, 0, 0);
              sub_10035930(*(_DWORD *)(v58 + 8), *(_DWORD *)(*(_DWORD *)(v58 + 8) + 4) + 1);
              v60 = **(_DWORD **)(v58 + 8) + 40 * *(_DWORD *)(*(_DWORD *)(v58 + 8) + 4) - 40;
              v61 = *(_DWORD *)(*(_DWORD *)a2 + 8);
              v62 = *(_DWORD *)(v60 + 28);
              v63 = (_DWORD *)(v60 + 24);
              if ( v61 != v62 )
              {
                if ( v61 >= v62 )
                {
                  if ( v61 > *(_DWORD *)(v60 + 32) )
                  {
                    LOBYTE(v115) = v61 == v62 + 1;
                    sub_100943C0(v61, 0, v60 + 24, v61 == v62 + 1, 1u, 0);
                  }
                  memset((void *)(*(_DWORD *)(v60 + 28) + *v63), 0, v61 - *(_DWORD *)(v60 + 28));
                }
                *(_DWORD *)(v60 + 28) = v61;
              }
              *(_DWORD *)(v60 + 12) = *v63;
              sub_1007D4E0(v59, a2, v60);
              if ( a2 == -272 || *(_QWORD *)(a2 + 256) >= *(_QWORD *)(a2 + 288) )
              {
                v43 = (char *)v117;
                v64 = 0;
                v3 = a2;
              }
              else
              {
                sub_10034F80(a2 + 272, v59);
                v43 = (char *)v117;
                v64 = 1;
                v3 = a2;
              }
            }
            else
            {
              v109 = v3 + 272;
              if ( *(_DWORD *)(*(_DWORD *)v3 + 16) < 3 )
                v64 = sub_1007DD40(&v114, v3, v3 + 240, 1, v109, 0);
              else
                v64 = sub_1007E440(v3, v3 + 240, (int)&v114, 1, v109, 0);
            }
            v110 |= v64;
            v44 = v119;
          }
          ++v112;
        }
        while ( v112 <= 1 );
        ++v118;
      }
      while ( v118 <= 1 );
      v119 = ++v44;
    }
    while ( v44 <= 1 );
    v43 += 4;
    v65 = v120-- == 1;
    v117 = (double *)v43;
  }
  while ( !v65 );
  return v110;
}
// 100A4F38: using guessed type int dword_100A4F38[];
// 100A4F48: using guessed type int dword_100A4F48[];
// 100A4F58: using guessed type int dword_100A4F58[];
// 100A504C: using guessed type int dword_100A504C[];
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (1007FCF0) --------------------------------------------------------
void __stdcall sub_1007FCF0(unsigned int a1)
{
  unsigned int v1; // edx@3
  unsigned int v2; // ecx@3
  unsigned int v3; // eax@3
  unsigned int v4; // edi@3
  char v5; // dl@3
  char v6; // cl@3
  char v7; // al@3
  int v8; // esi@4
  unsigned __int8 v9; // cl@10
  unsigned __int8 v10; // dl@12
  char v11; // cl@14
  unsigned __int8 v12; // cl@16
  unsigned __int8 v13; // dl@18
  unsigned __int8 v14; // cl@18
  unsigned __int8 v15; // bl@20
  unsigned __int8 v16; // cl@20
  unsigned int v17; // eax@24
  int v18; // ecx@25
  int v19; // esi@25
  int v20; // eax@26
  unsigned int v21; // edx@26
  int v22; // ecx@26
  _DWORD *v23; // ecx@26
  int v24; // edx@28
  int v25; // esi@28
  int v26; // eax@28
  char v27; // cl@40
  unsigned int v28; // eax@40
  unsigned int v29; // ebx@43
  int v30; // eax@45
  unsigned int v31; // edi@46
  unsigned int v32; // edx@46
  unsigned int v33; // eax@47
  unsigned int v34; // esi@47
  int v35; // ecx@47
  unsigned int v36; // esi@49
  unsigned int v37; // eax@54
  bool v38; // cf@54
  bool v39; // zf@54
  unsigned int v40; // eax@56
  unsigned int v41; // eax@58
  int v42; // ecx@62
  unsigned int v43; // edx@64
  unsigned int v44; // esi@64
  _DWORD *v45; // ecx@65
  int v46; // eax@66
  unsigned int v47; // eax@69
  char v48; // dl@69
  unsigned int v49; // ecx@69
  unsigned int v50; // eax@69
  unsigned __int8 v51; // dl@69
  int v52; // ecx@69
  int v53; // eax@69
  unsigned int v54; // edi@69
  unsigned int v55; // edx@69
  signed __int16 v56; // ax@69
  signed __int16 v57; // cx@75
  unsigned int v58; // edi@82
  int v59; // ebx@82
  unsigned int v60; // eax@82
  _DWORD *v61; // esi@82
  int v62; // ST24_4@88
  int v63; // ebx@88
  int v64; // esi@88
  int *v65; // edi@90
  int v66; // eax@94
  void (*v67)(char *, size_t, const char *, ...); // esi@96
  FILE *(__cdecl *v68)(); // ebx@96
  FILE *v69; // eax@96
  void (__cdecl *v70)(const char *, FILE *); // edi@96
  unsigned int v71; // eax@101
  int v72; // ecx@102
  FILE *v73; // eax@103
  FILE *v74; // eax@107
  int v75; // eax@112
  FILE *v76; // eax@113
  unsigned int v77; // edx@117
  char v78; // al@123
  unsigned int v79; // edx@127
  unsigned int v80; // esi@128
  int v81; // edi@128
  _DWORD *v82; // ecx@128
  int v83; // eax@129
  int v84; // [sp-8h] [bp-9A0h]@122
  __int16 v85; // [sp+14h] [bp-984h]@3
  __int16 v86; // [sp+16h] [bp-982h]@3
  unsigned int v87; // [sp+18h] [bp-980h]@8
  int v88; // [sp+1Ch] [bp-97Ch]@24
  int v89; // [sp+20h] [bp-978h]@3
  unsigned int v90; // [sp+24h] [bp-974h]@25
  unsigned int v91; // [sp+28h] [bp-970h]@25
  unsigned int v92; // [sp+30h] [bp-968h]@75
  unsigned __int8 v93; // [sp+34h] [bp-964h]@69
  unsigned __int8 v94; // [sp+35h] [bp-963h]@69
  unsigned __int8 v95; // [sp+36h] [bp-962h]@69
  unsigned int v96; // [sp+38h] [bp-960h]@75
  unsigned __int8 v97; // [sp+3Ch] [bp-95Ch]@69
  unsigned __int8 v98; // [sp+3Dh] [bp-95Bh]@69
  unsigned __int8 v99; // [sp+3Eh] [bp-95Ah]@69
  char v100; // [sp+40h] [bp-958h]@3
  char v101; // [sp+41h] [bp-957h]@3
  char v102; // [sp+42h] [bp-956h]@3
  char v103; // [sp+43h] [bp-955h]@3
  __int16 v104; // [sp+44h] [bp-954h]@81
  __int16 v105; // [sp+46h] [bp-952h]@81
  int v106; // [sp+48h] [bp-950h]@16
  char v107; // [sp+4Ch] [bp-94Ch]@3
  char v108; // [sp+4Dh] [bp-94Bh]@3
  char v109; // [sp+4Eh] [bp-94Ah]@3
  char v110; // [sp+4Fh] [bp-949h]@3
  unsigned int v111; // [sp+50h] [bp-948h]@26
  unsigned int v112; // [sp+54h] [bp-944h]@26
  int v113; // [sp+58h] [bp-940h]@112
  unsigned int v114; // [sp+5Ch] [bp-93Ch]@35
  unsigned int v115; // [sp+60h] [bp-938h]@38
  unsigned int v116; // [sp+64h] [bp-934h]@45
  int v117; // [sp+68h] [bp-930h]@64
  unsigned int v118; // [sp+6Ch] [bp-92Ch]@64
  unsigned int v119; // [sp+70h] [bp-928h]@64
  unsigned int v120; // [sp+74h] [bp-924h]@40
  int v121; // [sp+78h] [bp-920h]@46
  int v122; // [sp+7Ch] [bp-91Ch]@85
  unsigned int v123; // [sp+80h] [bp-918h]@46
  unsigned int v124; // [sp+84h] [bp-914h]@112
  int v125; // [sp+88h] [bp-910h]@25
  int v126; // [sp+8Ch] [bp-90Ch]@25
  unsigned int v127; // [sp+90h] [bp-908h]@25
  unsigned int v128; // [sp+94h] [bp-904h]@25
  CHAR OutputString; // [sp+98h] [bp-900h]@103
  char DstBuf; // [sp+298h] [bp-700h]@96
  CHAR v131; // [sp+498h] [bp-500h]@113
  CHAR v132; // [sp+698h] [bp-300h]@107
  char v133; // [sp+898h] [bp-100h]@113

  if ( !*(_BYTE *)(a1 + 296) && *(_QWORD *)(a1 + 288) )
  {
    v1 = *(_WORD *)(a1 + 272) & 0x1F;
    v2 = ((unsigned int)*(_WORD *)(a1 + 272) >> 5) & 0x3F;
    v3 = *(_WORD *)(a1 + 274);
    v100 = 8 * ((unsigned int)*(_WORD *)(a1 + 272) >> 11) | ((unsigned int)*(_WORD *)(a1 + 272) >> 13);
    v101 = 4 * v2 | (v2 >> 4);
    v102 = 8 * v1 | (v1 >> 2);
    v107 = 8 * (v3 >> 11) | (v3 >> 13);
    v108 = 4 * ((v3 >> 5) & 0x3F) | (((v3 >> 5) & 0x3F) >> 4);
    v109 = 8 * (v3 & 0x1F) | ((unsigned __int8)(v3 & 0x1F) >> 2);
    v4 = 0;
    v5 = -1;
    v6 = -1;
    v7 = 0;
    v103 = -1;
    v110 = -1;
    v85 = -1;
    v86 = -1;
    v89 = 0;
    if ( *(_DWORD *)(a1 + 48) )
    {
      v8 = *(_DWORD *)(a1 + 44);
      v4 = *(_DWORD *)(a1 + 48);
      while ( 1 )
      {
        if ( (unsigned __int8)v5 >= *(_BYTE *)v8 )
          v5 = *(_BYTE *)v8;
        LOBYTE(v87) = v5;
        if ( (unsigned __int8)v6 >= *(_BYTE *)(v8 + 1) )
          v6 = *(_BYTE *)(v8 + 1);
        BYTE1(v87) = v6;
        v9 = *(_BYTE *)(v8 + 2);
        if ( (unsigned __int8)v86 < v9 )
          v9 = v86;
        v10 = *(_BYTE *)(v8 + 3);
        if ( HIBYTE(v86) < v10 )
          v10 = HIBYTE(v86);
        v85 = v87;
        LOBYTE(v86) = v9;
        v11 = *(_BYTE *)v8;
        HIBYTE(v86) = v10;
        if ( (unsigned __int8)v7 <= (unsigned __int8)v11 )
          v7 = v11;
        v12 = *(_BYTE *)(v8 + 1);
        LOBYTE(v106) = v7;
        if ( BYTE1(v89) > v12 )
          v12 = BYTE1(v89);
        v13 = v12;
        v14 = *(_BYTE *)(v8 + 2);
        if ( BYTE2(v89) > v14 )
          v14 = BYTE2(v89);
        v15 = v14;
        v16 = *(_BYTE *)(v8 + 3);
        if ( BYTE3(v89) > v16 )
          v16 = BYTE3(v89);
        v7 = v106;
        v8 += 8;
        --v4;
        BYTE1(v89) = v13;
        BYTE2(v89) = v15;
        BYTE3(v89) = v16;
        if ( !v4 )
          break;
        v6 = HIBYTE(v85);
        v5 = v85;
      }
      LOBYTE(v89) = v106;
    }
    v17 = 0;
    v88 = 0;
    while ( 1 )
    {
      v18 = (unsigned __int8)*(&v100 + v17);
      v19 = (unsigned __int8)*(&v107 + v17);
      v125 = (unsigned __int8)*(&v100 + v17);
      v127 = (v19 + 2 * v18) / 3u;
      v39 = *(_DWORD *)(a1 + 48) == 0;
      v126 = v19;
      v128 = (v18 + 2 * v19) / 3u;
      v90 = v4;
      v87 = v4;
      v91 = v4;
      if ( !v39 )
      {
        v20 = v88;
        v21 = *((_BYTE *)&v85 + v88);
        v112 = *((_BYTE *)&v89 + v88);
        v22 = *(_DWORD *)(a1 + 44);
        v111 = v21;
        v23 = (_DWORD *)(v22 + 4);
        while ( 1 )
        {
          v24 = *((_BYTE *)v23 + v20 - 4);
          v25 = *v23;
          v26 = *(&v125 + *(_BYTE *)(*(_DWORD *)(a1 + 276) + v4)) - v24;
          v90 += *v23 * v26 * v26;
          if ( v24 == v111 )
            v87 += v25;
          if ( v24 == v112 )
            v91 += v25;
          ++v4;
          v23 += 2;
          if ( v4 >= *(_DWORD *)(a1 + 48) )
            break;
          v20 = v88;
        }
        if ( v90 )
          break;
      }
LABEL_133:
      v17 = v88 + 1;
      v88 = v17;
      if ( v17 >= 3 )
        return;
      v4 = 0;
    }
    if ( v87 )
      v114 = (v87 + v90 - 1) / v87;
    else
      v114 = 0;
    if ( v91 )
      v115 = (v91 + v90 - 1) / v91;
    else
      v115 = 0;
    v27 = 3 - (v88 != 1);
    v120 = v88 != 1 ? 31 : 63;
    v28 = 0;
    v106 = 3 - (v88 != 1);
    v87 = 0;
LABEL_42:
    if ( v88 == 1 )
      v29 = 4 * v28 | (v28 >> 4);
    else
      v29 = 8 * v28 | (v28 >> 2);
    v116 = v29;
    v30 = 0;
    while ( 1 )
    {
      v31 = v30 << v27;
      v121 = v30 + 1;
      v32 = ((v30 + 1) << v27) - 1;
      v123 = ((v30 + 1) << v27) - 1;
      if ( v88 == 1 )
      {
        v33 = 4 * v31 | (v31 >> 4);
        v34 = v32 >> 4;
        v35 = 4 * v32;
      }
      else
      {
        v33 = 8 * v31 | (v31 >> 2);
        v34 = v32 >> 2;
        v35 = 8 * v32;
      }
      v36 = v35 | v34;
      if ( v33 >= v29 )
        v33 = v29;
      if ( v36 <= v29 )
        v36 = v29;
      if ( v112 >= v33 )
      {
        if ( v111 <= v36 )
          goto LABEL_58;
        v40 = (v112 - v36) * (v112 - v36);
        v38 = v40 < v115;
        v39 = v40 == v115;
      }
      else
      {
        v37 = (v33 - v111) * (v33 - v111);
        v38 = v37 < v114;
        v39 = v37 == v114;
      }
      if ( v38 || v39 )
      {
LABEL_58:
        v41 = v31;
        v91 = v31;
        if ( v31 <= v32 )
        {
          while ( 1 )
          {
            if ( v88 == 1 )
              v42 = 4 * v41 | (v41 >> 4);
            else
              v42 = 8 * v41 | (v41 >> 2);
            v117 = v42;
            v118 = (v42 + 2 * v29) / 3;
            v119 = (v29 + 2 * v42) / 3;
            v43 = 0;
            v44 = 0;
            if ( *(_DWORD *)(a1 + 48) )
            {
              v45 = (_DWORD *)(*(_DWORD *)(a1 + 44) + 4);
              do
              {
                v46 = *(&v116 + *(_BYTE *)(*(_DWORD *)(a1 + 276) + v43)) - *((_BYTE *)v45 + v88 - 4);
                v44 += v46 * v46 * *v45;
                if ( v44 >= v90 )
                  goto LABEL_130;
                ++v43;
                v45 += 2;
              }
              while ( v43 < *(_DWORD *)(a1 + 48) );
            }
            if ( v44 >= v90 )
              goto LABEL_130;
            v47 = *(_WORD *)(a1 + 272);
            v48 = *(_WORD *)(a1 + 272);
            v49 = v47;
            v97 = v47 >> 11;
            v50 = *(_WORD *)(a1 + 274);
            v98 = (v49 >> 5) & 0x3F;
            v99 = v48 & 0x1F;
            v51 = v50 & 0x1F;
            v52 = (v50 >> 5) & 0x3F;
            v93 = v50 >> 11;
            v53 = v88;
            v94 = v52;
            LOBYTE(v52) = v87;
            v95 = v51;
            *(&v93 + v88) = v91;
            v54 = v94;
            v55 = v95;
            *(&v97 + v53) = v52;
            v56 = v93;
            if ( v93 >= 0x1Fu )
              v56 = 31;
            if ( v54 >= 0x3F )
              LOWORD(v54) = 63;
            if ( v55 >= 0x1F )
              LOWORD(v55) = 31;
            v57 = v97;
            v96 = v98;
            v92 = v99;
            if ( v97 >= 0x1Fu )
              v57 = 31;
            if ( v96 >= 0x3F )
              v96 = 63;
            if ( v92 >= 0x1F )
              v92 = 31;
            ++*(_DWORD *)(a1 + 232);
            v39 = *(_DWORD *)(a1 + 8) == 0;
            v105 = v55 | 32 * (v54 | (v56 << 6));
            v104 = v92 | 32 * (v96 | (v57 << 6));
            if ( v39 )
            {
              v84 = a1 + 272;
              if ( *(_DWORD *)(*(_DWORD *)a1 + 16) < 3 )
                v78 = sub_1007DD40(&v104, a1, a1 + 240, 1, v84, 0);
              else
                v78 = sub_1007E440(a1, a1 + 240, (int)&v104, 1, v84, 0);
              if ( !v78 )
                goto LABEL_130;
              goto LABEL_126;
            }
            sub_1007E440(a1, a1 + 240, (int)&v104, 0, 0, 0);
            sub_10035930(*(_DWORD *)(a1 + 8), *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) + 1);
            v58 = *(_DWORD *)(*(_DWORD *)a1 + 8);
            v59 = **(_DWORD **)(a1 + 8) + 40 * *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) - 40;
            v60 = *(_DWORD *)(v59 + 28);
            v61 = (_DWORD *)(v59 + 24);
            if ( v58 != v60 )
            {
              if ( v58 >= v60 )
              {
                if ( v58 > *(_DWORD *)(v59 + 32) )
                {
                  LOBYTE(v122) = v58 == v60 + 1;
                  sub_100943C0(v58, 0, v59 + 24, v58 == v60 + 1, 1u, 0);
                }
                memset((void *)(*(_DWORD *)(v59 + 28) + *v61), 0, v58 - *(_DWORD *)(v59 + 28));
              }
              *(_DWORD *)(v59 + 28) = v58;
            }
            v62 = v59;
            *(_DWORD *)(v59 + 12) = *v61;
            v63 = a1 + 240;
            sub_1007D4E0(a1 + 240, a1, v62);
            v64 = a1 + 272;
            if ( a1 == -272 || *(_QWORD *)(a1 + 256) >= *(_QWORD *)(a1 + 288) )
              goto LABEL_130;
            *(_DWORD *)v64 = *(_DWORD *)v63;
            v65 = (int *)(a1 + 276);
            if ( a1 + 276 != a1 + 244 )
              break;
LABEL_121:
            *(_DWORD *)(v64 + 16) = *(_DWORD *)(v63 + 16);
            *(_DWORD *)(v64 + 20) = *(_DWORD *)(v63 + 20);
            *(_BYTE *)(v64 + 24) = *(_BYTE *)(v63 + 24);
            *(_BYTE *)(v64 + 25) = *(_BYTE *)(v63 + 25);
LABEL_126:
            if ( !*(_QWORD *)(a1 + 288) )
              return;
            v79 = 0;
            v90 = 0;
            if ( *(_DWORD *)(a1 + 48) )
            {
              v80 = *(_DWORD *)(a1 + 48);
              v81 = *(_DWORD *)(a1 + 276);
              v82 = (_DWORD *)(*(_DWORD *)(a1 + 44) + 4);
              do
              {
                v83 = *(&v116 + *(_BYTE *)(v81 + v79)) - *((_BYTE *)v82 + v88 - 4);
                v90 += *v82 * v83 * v83;
                ++v79;
                v82 += 2;
              }
              while ( v79 < v80 );
            }
LABEL_130:
            v29 = v116;
            if ( ++v91 > v123 )
              goto LABEL_131;
            v41 = v91;
          }
          if ( *(_DWORD *)(a1 + 284) >= *(_DWORD *)(a1 + 248) )
          {
            if ( *(_DWORD *)(a1 + 280) )
              *(_DWORD *)(a1 + 280) = 0;
            goto LABEL_120;
          }
          v66 = *v65;
          if ( *v65 )
          {
            if ( v66 & 7 )
            {
              v67 = (void (*)(char *, size_t, const char *, ...))sprintf_s;
              sprintf_s(
                &DstBuf,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_free: bad ptr");
              OutputDebugStringA(&DstBuf);
              v68 = _iob_func;
              v69 = _iob_func();
              v70 = (void (__cdecl *)(const char *, FILE *))fputs;
              fputs(&DstBuf, v69 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v66, 0, 0, 1, dword_100AE9F4);
              v67 = (void (*)(char *, size_t, const char *, ...))sprintf_s;
              v70 = (void (__cdecl *)(const char *, FILE *))fputs;
              v68 = _iob_func;
            }
            *(_DWORD *)(a1 + 276) = 0;
            *(_DWORD *)(a1 + 280) = 0;
            *(_DWORD *)(a1 + 284) = 0;
          }
          else
          {
            v67 = (void (*)(char *, size_t, const char *, ...))sprintf_s;
            v70 = (void (__cdecl *)(const char *, FILE *))fputs;
            v68 = _iob_func;
          }
          v71 = *(_DWORD *)(a1 + 248);
          v96 = v71;
          if ( *(_DWORD *)(a1 + 284) >= v71 )
            goto LABEL_120;
          v72 = *(_DWORD *)(a1 + 276);
          if ( v72 & 7 )
          {
            v67(
              &OutputString,
              0x200u,
              "%s(%u): Assertion failed: \"%s\"\n",
              "crn_mem.cpp",
              216,
              "crnlib_realloc: bad ptr");
            OutputDebugStringA(&OutputString);
            v73 = v68();
            v70(&OutputString, v73 + 2);
            if ( IsDebuggerPresent() )
              DebugBreak();
LABEL_105:
            v92 = 0;
            goto LABEL_113;
          }
          if ( v71 <= 0x7FFF0000 )
          {
            if ( v71 && v71 < 4 )
              v71 = 4;
            v113 = v71;
            v75 = off_100AD9F4(v72, v71, &v113, 1, dword_100AE9F4);
            v124 = v113;
            v92 = v75;
            if ( !v75 )
              goto LABEL_113;
          }
          else
          {
            v67(&v132, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_malloc: size too big");
            OutputDebugStringA(&v132);
            v74 = v68();
            v70(&v132, v74 + 2);
            if ( !IsDebuggerPresent() )
              goto LABEL_105;
            DebugBreak();
            v92 = 0;
LABEL_113:
            v67(&v133, 0x100u, "vector: crnlib_realloc() failed allocating %u bytes", v96);
            v67(&v131, 0x200u, "%s(%u): Failure: \"%s\"\n", "crn_vector.cpp", 46, "buf");
            OutputDebugStringA(&v131);
            v76 = v68();
            v70(&v131, v76 + 2);
            if ( IsDebuggerPresent() )
              DebugBreak();
            if ( !byte_100AE9F8 )
              exit(1);
            RaiseException(0x100u, 0, 0, 0);
          }
          v77 = v96;
          *(_DWORD *)(a1 + 276) = v92;
          if ( v124 <= v77 )
            *(_DWORD *)(a1 + 284) = v77;
          else
            *(_DWORD *)(a1 + 284) = v124;
LABEL_120:
          v63 = a1 + 240;
          v64 = a1 + 272;
          memcpy(*(void **)(a1 + 276), *(const void **)(a1 + 244), *(_DWORD *)(a1 + 248));
          *(_DWORD *)(a1 + 280) = *(_DWORD *)(a1 + 248);
          goto LABEL_121;
        }
      }
LABEL_131:
      v30 = v121;
      v27 = v106;
      if ( (unsigned int)v121 >= 8 )
      {
        if ( ++v87 > v120 )
          goto LABEL_133;
        v28 = v87;
        goto LABEL_42;
      }
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (10080720) --------------------------------------------------------
char __usercall sub_10080720@<al>(unsigned int a1@<esi>)
{
  int v1; // eax@1
  int v2; // ebx@1
  int v3; // ebp@1
  int v4; // edi@1
  __int16 v5; // cx@1
  __int16 v6; // dx@1
  __int16 v7; // ax@3
  __int16 v8; // cx@3
  __int16 v10; // [sp+Ch] [bp-8h]@1
  __int16 v11; // [sp+Eh] [bp-6h]@1
  int v12; // [sp+10h] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 44);
  v2 = *(_BYTE *)(v1 + 2);
  v3 = *(_BYTE *)(v1 + 1);
  v4 = *(_BYTE *)v1;
  v5 = (unsigned __int8)byte_100AF021[2 * v3];
  v6 = (unsigned __int8)byte_100AF221[2 * v2];
  v10 = (unsigned __int8)byte_100AF220[2 * v2] | (unsigned __int16)(32
                                                                  * ((unsigned __int8)byte_100AF020[2 * v3] | (unsigned __int16)((unsigned __int8)byte_100AF220[2 * v4] << 6)));
  v11 = v6 | 32 * (v5 | ((unsigned __int8)byte_100AF221[2 * v4] << 6));
  v12 = a1 + 272;
  sub_1007ED40(&v10, 0, 0, a1, a1 + 272);
  if ( *(_BYTE *)(*(_DWORD *)a1 + 21) && *(_QWORD *)(a1 + 288) )
  {
    v7 = (unsigned __int8)byte_100AEC21[2 * v3];
    v8 = (unsigned __int8)byte_100AEE21[2 * v2];
    v10 = (unsigned __int8)byte_100AEE20[2 * v2] | (unsigned __int16)(32
                                                                    * ((unsigned __int8)byte_100AEC20[2 * v3] | (unsigned __int16)((unsigned __int8)byte_100AEE20[2 * v4] << 6)));
    v11 = v8 | 32 * (v7 | ((unsigned __int8)byte_100AEE21[2 * v4] << 6));
    sub_1007ED40(&v10, 1, 0, a1, v12);
  }
  sub_1007D4E0(v12, a1, *(_DWORD *)(a1 + 4));
  return 1;
}

//----- (10080840) --------------------------------------------------------
char __stdcall sub_10080840(unsigned int a1)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // esi@1
  unsigned int v3; // edx@1
  unsigned int v4; // ebx@1
  int v5; // eax@2
  int v6; // ecx@3
  unsigned int v7; // et0@3
  int v8; // et0@3
  unsigned __int64 v9; // rax@5
  int v10; // edi@5
  int v11; // esi@5
  __int16 v12; // cx@5
  bool v13; // zf@5
  int v14; // ebx@5
  unsigned int v15; // edi@6
  int v16; // eax@6
  unsigned int v17; // ecx@6
  int v18; // esi@6
  char v19; // al@17
  __int16 v20; // dx@22
  __int16 v21; // ax@22
  char v22; // al@22
  unsigned int v23; // eax@24
  int v24; // edx@25
  int v25; // esi@25
  int v26; // edi@25
  int v27; // eax@25
  __int16 v28; // dx@28
  __int16 v29; // ax@28
  __int16 v30; // cx@28
  __int16 v31; // dx@28
  __int16 v32; // cx@28
  unsigned int v33; // edi@29
  int v34; // eax@29
  unsigned int v35; // ecx@29
  int v36; // esi@29
  char v37; // al@37
  __int16 v38; // ax@44
  __int16 v39; // cx@44
  __int16 v40; // dx@44
  unsigned int v41; // edi@45
  int v42; // eax@45
  unsigned int v43; // ecx@45
  int v44; // esi@45
  char v45; // al@53
  int v47; // [sp-8h] [bp-58h]@16
  int v48; // [sp-8h] [bp-58h]@39
  int v49; // [sp-8h] [bp-58h]@55
  int v50; // [sp+14h] [bp-3Ch]@5
  __int16 v51; // [sp+18h] [bp-38h]@28
  __int16 v52; // [sp+1Ah] [bp-36h]@28
  __int16 v53; // [sp+1Ch] [bp-34h]@22
  __int16 v54; // [sp+1Eh] [bp-32h]@22
  int v55; // [sp+20h] [bp-30h]@5
  int v56; // [sp+24h] [bp-2Ch]@5
  int v57; // [sp+28h] [bp-28h]@25
  int v58; // [sp+2Ch] [bp-24h]@25
  int v59; // [sp+30h] [bp-20h]@6
  int v60; // [sp+34h] [bp-1Ch]@32
  int v61; // [sp+38h] [bp-18h]@29
  unsigned int v62; // [sp+3Ch] [bp-14h]@1
  __int64 v63; // [sp+40h] [bp-10h]@1
  __int64 v64; // [sp+48h] [bp-8h]@1

  v1 = a1;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v62 = 0;
  v63 = 0i64;
  v64 = 0i64;
  if ( *(_DWORD *)(a1 + 48) )
  {
    v5 = *(_DWORD *)(a1 + 44);
    a1 = *(_DWORD *)(a1 + 48);
    do
    {
      v6 = *(_DWORD *)(v5 + 4);
      v4 += v6;
      v7 = (v6 * (unsigned int)*(_BYTE *)v5 + __PAIR__(v62, v3)) >> 32;
      v3 += v6 * *(_BYTE *)v5;
      v62 = v7;
      v8 = (v6 * (unsigned int)*(_BYTE *)(v5 + 1) + __PAIR__(HIDWORD(v63), v2)) >> 32;
      v2 += v6 * *(_BYTE *)(v5 + 1);
      HIDWORD(v63) = v8;
      v64 += v6 * (unsigned int)*(_BYTE *)(v5 + 2);
      v5 += 8;
      --a1;
    }
    while ( a1 );
    LODWORD(v63) = v2;
  }
  v50 = (v3 + __PAIR__(v62, v4 >> 1)) / v4;
  v55 = (v63 + (unsigned __int64)(v4 >> 1)) / v4;
  v9 = (v64 + (unsigned __int64)(v4 >> 1)) / v4;
  v10 = v50;
  v11 = v9;
  WORD2(v9) = (unsigned __int8)byte_100AF021[2 * v55];
  LOWORD(v9) = (unsigned __int8)byte_100AF221[2 * (signed int)v9];
  LOWORD(a1) = (unsigned __int8)byte_100AF220[2 * v11] | (unsigned __int16)(32
                                                                          * ((unsigned __int8)byte_100AF020[2 * v55] | (unsigned __int16)((unsigned __int8)byte_100AF220[2 * v50] << 6)));
  v12 = (unsigned __int8)byte_100AF221[2 * v50];
  ++*(_DWORD *)(v1 + 232);
  v13 = *(_DWORD *)(v1 + 8) == 0;
  v56 = v11;
  HIWORD(a1) = v9 | 32 * (WORD2(v9) | (v12 << 6));
  v14 = v1 + 240;
  if ( v13 )
  {
    v47 = v1 + 272;
    if ( *(_DWORD *)(*(_DWORD *)v1 + 16) < 3 )
      v19 = sub_1007DD40(&a1, v1, v1 + 240, 1, v47, 0);
    else
      v19 = sub_1007E440(v1, v1 + 240, (int)&a1, 1, v47, 0);
    LOBYTE(a1) = v19;
  }
  else
  {
    sub_1007E440(v1, v1 + 240, (int)&a1, 0, 0, 0);
    sub_10035930(*(_DWORD *)(v1 + 8), *(_DWORD *)(*(_DWORD *)(v1 + 8) + 4) + 1);
    v15 = *(_DWORD *)(*(_DWORD *)v1 + 8);
    v16 = **(_DWORD **)(v1 + 8) + 40 * *(_DWORD *)(*(_DWORD *)(v1 + 8) + 4) - 40;
    v17 = *(_DWORD *)(v16 + 28);
    v18 = v16 + 24;
    v59 = **(_DWORD **)(v1 + 8) + 40 * *(_DWORD *)(*(_DWORD *)(v1 + 8) + 4) - 40;
    if ( v15 != v17 )
    {
      if ( v15 >= v17 )
      {
        if ( v15 > *(_DWORD *)(v16 + 32) )
        {
          LOBYTE(a1) = v15 == v17 + 1;
          sub_100943C0(v15, 0, v16 + 24, v15 == v17 + 1, 1u, 0);
        }
        memset((void *)(*(_DWORD *)(v18 + 4) + *(_DWORD *)v18), 0, v15 - *(_DWORD *)(v18 + 4));
        v16 = v59;
      }
      *(_DWORD *)(v18 + 4) = v15;
    }
    *(_DWORD *)(v16 + 12) = *(_DWORD *)v18;
    sub_1007D4E0(v14, v1, v16);
    if ( v1 == -272 || *(_QWORD *)(v1 + 256) >= *(_QWORD *)(v1 + 288) )
    {
      v11 = v56;
      v10 = v50;
      LOBYTE(a1) = 0;
    }
    else
    {
      sub_10034F80(v1 + 272, v1 + 240);
      v11 = v56;
      v10 = v50;
      LOBYTE(a1) = 1;
    }
  }
  if ( *(_BYTE *)(*(_DWORD *)v1 + 21) && *(_QWORD *)(v1 + 288) )
  {
    v20 = (unsigned __int8)byte_100AEC21[2 * v55];
    v21 = (unsigned __int8)byte_100AEE21[2 * v11];
    v53 = (unsigned __int8)byte_100AEE20[2 * v11] | (unsigned __int16)(32
                                                                     * ((unsigned __int8)byte_100AEC20[2 * v55] | (unsigned __int16)((unsigned __int8)byte_100AEE20[2 * v10] << 6)));
    v54 = v21 | 32 * (v20 | ((unsigned __int8)byte_100AEE21[2 * v10] << 6));
    v22 = sub_1007ED40(&v53, 1, 0, v1, v1 + 272);
    LOBYTE(a1) = v22 | a1;
  }
  if ( *(_DWORD *)(*(_DWORD *)v1 + 16) == 4 )
  {
    v23 = 0;
    v59 = 0;
    if ( *(_DWORD *)(v1 + 48) )
    {
      do
      {
        v24 = *(_DWORD *)(v1 + 44);
        v25 = *(_BYTE *)(v24 + 8 * v23);
        v26 = *(_BYTE *)(v24 + 8 * v23 + 1);
        v27 = *(_BYTE *)(v24 + 8 * v23 + 2);
        v58 = v25;
        v57 = v26;
        LODWORD(v63) = v27;
        if ( v25 != v50 || v26 != v55 || v27 != v56 )
        {
          v28 = (unsigned __int8)byte_100AF220[2 * v27];
          v29 = (unsigned __int8)byte_100AF221[2 * v27];
          v30 = v28 | 32
                    * ((unsigned __int8)byte_100AF020[2 * v26] | (unsigned __int16)((unsigned __int8)byte_100AF220[2 * v25] << 6));
          v31 = (unsigned __int8)byte_100AF021[2 * v26];
          v51 = v30;
          v32 = (unsigned __int8)byte_100AF221[2 * v25];
          ++*(_DWORD *)(v1 + 232);
          v13 = *(_DWORD *)(v1 + 8) == 0;
          v52 = v29 | 32 * (v31 | (v32 << 6));
          if ( v13 )
          {
            v48 = v1 + 272;
            if ( *(_DWORD *)(*(_DWORD *)v1 + 16) < 3 )
              v37 = sub_1007DD40(&v51, v1, v1 + 240, 1, v48, 0);
            else
              v37 = sub_1007E440(v1, v1 + 240, (int)&v51, 1, v48, 0);
          }
          else
          {
            sub_1007E440(v1, v1 + 240, (int)&v51, 0, 0, 0);
            sub_10035930(*(_DWORD *)(v1 + 8), *(_DWORD *)(*(_DWORD *)(v1 + 8) + 4) + 1);
            v33 = *(_DWORD *)(*(_DWORD *)v1 + 8);
            v34 = **(_DWORD **)(v1 + 8) + 40 * *(_DWORD *)(*(_DWORD *)(v1 + 8) + 4) - 40;
            v35 = *(_DWORD *)(v34 + 28);
            v36 = v34 + 24;
            v61 = **(_DWORD **)(v1 + 8) + 40 * *(_DWORD *)(*(_DWORD *)(v1 + 8) + 4) - 40;
            if ( v33 != v35 )
            {
              if ( v33 >= v35 )
              {
                if ( v33 > *(_DWORD *)(v34 + 32) )
                {
                  LOBYTE(v60) = v33 == v35 + 1;
                  sub_100943C0(v33, 0, v34 + 24, v33 == v35 + 1, 1u, 0);
                }
                memset((void *)(*(_DWORD *)(v36 + 4) + *(_DWORD *)v36), 0, v33 - *(_DWORD *)(v36 + 4));
                v34 = v61;
              }
              *(_DWORD *)(v36 + 4) = v33;
            }
            *(_DWORD *)(v34 + 12) = *(_DWORD *)v36;
            sub_1007D4E0(v14, v1, v34);
            if ( v1 == -272 || *(_QWORD *)(v1 + 256) >= *(_QWORD *)(v1 + 288) )
            {
              v26 = v57;
              v25 = v58;
              v37 = 0;
            }
            else
            {
              sub_10034F80(v1 + 272, v1 + 240);
              v26 = v57;
              v25 = v58;
              v37 = 1;
            }
          }
          LOBYTE(a1) = v37 | a1;
          if ( *(_BYTE *)(*(_DWORD *)v1 + 21) && *(_QWORD *)(v1 + 288) )
          {
            v38 = (unsigned __int8)byte_100AEE21[2 * (signed int)v63];
            v39 = (unsigned __int8)byte_100AEC21[2 * v26];
            v53 = (unsigned __int8)byte_100AEE20[2 * (signed int)v63] | (unsigned __int16)(32
                                                                                         * ((unsigned __int8)byte_100AEC20[2 * v26] | (unsigned __int16)((unsigned __int8)byte_100AEE20[2 * v25] << 6)));
            v40 = (unsigned __int8)byte_100AEE21[2 * v25];
            ++*(_DWORD *)(v1 + 232);
            v13 = *(_DWORD *)(v1 + 8) == 0;
            v54 = v38 | 32 * (v39 | (v40 << 6));
            if ( v13 )
            {
              v49 = v1 + 272;
              if ( *(_DWORD *)(*(_DWORD *)v1 + 16) < 3 )
                v45 = sub_1007DD40(&v53, v1, v1 + 240, 1, v49, 0);
              else
                v45 = sub_1007E440(v1, v1 + 240, (int)&v53, 1, v49, 0);
            }
            else
            {
              sub_1007E440(v1, v1 + 240, (int)&v53, 0, 0, 0);
              sub_10035930(*(_DWORD *)(v1 + 8), *(_DWORD *)(*(_DWORD *)(v1 + 8) + 4) + 1);
              v41 = *(_DWORD *)(*(_DWORD *)v1 + 8);
              v42 = **(_DWORD **)(v1 + 8) + 40 * *(_DWORD *)(*(_DWORD *)(v1 + 8) + 4) - 40;
              v43 = *(_DWORD *)(v42 + 28);
              v44 = v42 + 24;
              LODWORD(v63) = **(_DWORD **)(v1 + 8) + 40 * *(_DWORD *)(*(_DWORD *)(v1 + 8) + 4) - 40;
              if ( v41 != v43 )
              {
                if ( v41 >= v43 )
                {
                  if ( v41 > *(_DWORD *)(v42 + 32) )
                  {
                    LOBYTE(v64) = v41 == v43 + 1;
                    sub_100943C0(v41, 0, v42 + 24, v41 == v43 + 1, 1u, 0);
                  }
                  memset((void *)(*(_DWORD *)(v44 + 4) + *(_DWORD *)v44), 0, v41 - *(_DWORD *)(v44 + 4));
                  v42 = v63;
                }
                *(_DWORD *)(v44 + 4) = v41;
              }
              *(_DWORD *)(v42 + 12) = *(_DWORD *)v44;
              sub_1007D4E0(v14, v1, v42);
              if ( v1 == -272 || *(_QWORD *)(v1 + 256) >= *(_QWORD *)(v1 + 288) )
              {
                v45 = 0;
              }
              else
              {
                sub_10034F80(v1 + 272, v1 + 240);
                v45 = 1;
              }
            }
            LOBYTE(a1) = v45 | a1;
          }
        }
        v23 = v59 + 1;
        v59 = v23;
      }
      while ( v23 < *(_DWORD *)(v1 + 48) );
    }
  }
  return a1;
}

//----- (10080E70) --------------------------------------------------------
char __stdcall sub_10080E70(unsigned int a1)
{
  unsigned int v1; // eax@1
  _DWORD *v2; // ebp@3
  int v3; // eax@3
  int v4; // ebx@6
  int v5; // esi@6
  unsigned int v6; // eax@6
  int v7; // eax@8
  int v8; // esi@10
  unsigned int v9; // eax@10
  int v10; // eax@12
  int v11; // esi@14
  unsigned int v12; // eax@14
  int v13; // eax@16
  int v14; // esi@18
  unsigned int v15; // eax@18
  int v16; // eax@20
  int v17; // esi@22
  unsigned int v18; // eax@22
  int v19; // eax@24
  int v20; // esi@26
  unsigned int v21; // eax@26
  int v22; // eax@28
  int v23; // esi@30
  unsigned int v24; // eax@30
  int v25; // eax@32
  int v26; // esi@34
  unsigned int v27; // eax@34
  int v28; // eax@36
  int v29; // esi@38
  unsigned int v30; // eax@38
  int v31; // eax@40
  int v32; // esi@42
  unsigned int v33; // eax@42
  int v34; // eax@44
  int v35; // eax@46
  unsigned int v36; // eax@50
  unsigned int v37; // ebx@51
  int v38; // esi@53
  unsigned int v39; // eax@53
  int v40; // eax@55
  int v41; // esi@57
  unsigned int v42; // eax@57
  int v43; // eax@59
  int v44; // esi@61
  unsigned int v45; // eax@61
  int v46; // eax@63
  int v47; // esi@65
  unsigned int v48; // eax@65
  int v49; // eax@67
  int v50; // eax@72
  _DWORD *v51; // ebx@72
  _WORD *v52; // eax@74
  unsigned int v53; // ecx@77
  unsigned int v54; // esi@77
  unsigned int v55; // edx@77
  _WORD *v56; // eax@83
  __int16 v57; // si@83
  int v58; // ecx@83
  unsigned int v59; // eax@87
  unsigned int v60; // ecx@92
  unsigned int v61; // ebp@93
  unsigned int v62; // esi@94
  int v63; // ecx@98
  __int16 v64; // ax@100
  void **v65; // esi@107
  unsigned int v66; // eax@109
  void *v67; // eax@113
  FILE *v68; // eax@115
  unsigned int v70; // [sp+1Ch] [bp-25Ch]@4
  int v71; // [sp+1Ch] [bp-25Ch]@50
  unsigned int i; // [sp+1Ch] [bp-25Ch]@76
  int v73; // [sp+1Ch] [bp-25Ch]@92
  int v74; // [sp+20h] [bp-258h]@5
  bool v75; // [sp+27h] [bp-251h]@96
  unsigned int v76; // [sp+28h] [bp-250h]@6
  char v77; // [sp+30h] [bp-248h]@30
  char v78; // [sp+38h] [bp-240h]@34
  char v79; // [sp+40h] [bp-238h]@42
  char v80; // [sp+48h] [bp-230h]@38
  char v81; // [sp+50h] [bp-228h]@18
  char v82; // [sp+58h] [bp-220h]@22
  char v83; // [sp+60h] [bp-218h]@14
  char v84; // [sp+68h] [bp-210h]@26
  char v85; // [sp+70h] [bp-208h]@10
  char DstBuf; // [sp+78h] [bp-200h]@115

  v1 = *(_DWORD *)(a1 + 48);
  if ( v1 >= 2 && v1 <= 4 )
  {
    v2 = (_DWORD *)(a1 + 56);
    sub_100353E0(a1 + 56, a1 + 44);
    v3 = *(_DWORD *)(a1 + 60);
    if ( v3 == 2 )
    {
      v70 = 0;
      do
      {
        v74 = 0;
        do
        {
          v4 = v74 ^ 1;
          v5 = sub_1007D390(*v2 + 8 * (v74 ^ 1), (int)&v76, *v2 + 8 * v74, 2.0, v70);
          v6 = *(_DWORD *)(a1 + 60);
          if ( v6 >= *(_DWORD *)(a1 + 64) )
            sub_100943C0(v6 + 1, 0, (int)v2, 1, 8u, 0);
          v7 = *(_DWORD *)(a1 + 56) + 8 * *(_DWORD *)(a1 + 60);
          if ( v7 )
          {
            *(_BYTE *)v7 = *(_BYTE *)v5;
            *(_BYTE *)(v7 + 1) = *(_BYTE *)(v5 + 1);
            *(_BYTE *)(v7 + 2) = *(_BYTE *)(v5 + 2);
            *(_BYTE *)(v7 + 3) = *(_BYTE *)(v5 + 3);
            *(_DWORD *)(v7 + 4) = *(_DWORD *)(v5 + 4);
          }
          ++*(_DWORD *)(a1 + 60);
          v8 = sub_1007D390(*v2 + 8 * v4, (int)&v85, *v2 + 8 * v74, 3.0, v70);
          v9 = *(_DWORD *)(a1 + 60);
          if ( v9 >= *(_DWORD *)(a1 + 64) )
            sub_100943C0(v9 + 1, 0, (int)v2, 1, 8u, 0);
          v10 = *(_DWORD *)(a1 + 56) + 8 * *(_DWORD *)(a1 + 60);
          if ( v10 )
          {
            *(_BYTE *)v10 = *(_BYTE *)v8;
            *(_BYTE *)(v10 + 1) = *(_BYTE *)(v8 + 1);
            *(_BYTE *)(v10 + 2) = *(_BYTE *)(v8 + 2);
            *(_BYTE *)(v10 + 3) = *(_BYTE *)(v8 + 3);
            *(_DWORD *)(v10 + 4) = *(_DWORD *)(v8 + 4);
          }
          ++*(_DWORD *)(a1 + 60);
          v11 = sub_1007D390(*v2 + 8 * v4, (int)&v83, *v2 + 8 * v74, 0.5, v70);
          v12 = *(_DWORD *)(a1 + 60);
          if ( v12 >= *(_DWORD *)(a1 + 64) )
            sub_100943C0(v12 + 1, 0, (int)v2, 1, 8u, 0);
          v13 = *(_DWORD *)(a1 + 56) + 8 * *(_DWORD *)(a1 + 60);
          if ( v13 )
          {
            *(_BYTE *)v13 = *(_BYTE *)v11;
            *(_BYTE *)(v13 + 1) = *(_BYTE *)(v11 + 1);
            *(_BYTE *)(v13 + 2) = *(_BYTE *)(v11 + 2);
            *(_BYTE *)(v13 + 3) = *(_BYTE *)(v11 + 3);
            *(_DWORD *)(v13 + 4) = *(_DWORD *)(v11 + 4);
          }
          ++*(_DWORD *)(a1 + 60);
          v14 = sub_1007D390(*v2 + 8 * v4, (int)&v81, *v2 + 8 * v74, 1.5, v70);
          v15 = *(_DWORD *)(a1 + 60);
          if ( v15 >= *(_DWORD *)(a1 + 64) )
            sub_100943C0(v15 + 1, 0, (int)v2, 1, 8u, 0);
          v16 = *(_DWORD *)(a1 + 56) + 8 * *(_DWORD *)(a1 + 60);
          if ( v16 )
          {
            *(_BYTE *)v16 = *(_BYTE *)v14;
            *(_BYTE *)(v16 + 1) = *(_BYTE *)(v14 + 1);
            *(_BYTE *)(v16 + 2) = *(_BYTE *)(v14 + 2);
            *(_BYTE *)(v16 + 3) = *(_BYTE *)(v14 + 3);
            *(_DWORD *)(v16 + 4) = *(_DWORD *)(v14 + 4);
          }
          ++*(_DWORD *)(a1 + 60);
          v17 = sub_1007D390(*v2 + 8 * v4, (int)&v82, *v2 + 8 * v74, -1.0, v70);
          v18 = *(_DWORD *)(a1 + 60);
          if ( v18 >= *(_DWORD *)(a1 + 64) )
            sub_100943C0(v18 + 1, 0, (int)v2, 1, 8u, 0);
          v19 = *(_DWORD *)(a1 + 56) + 8 * *(_DWORD *)(a1 + 60);
          if ( v19 )
          {
            *(_BYTE *)v19 = *(_BYTE *)v17;
            *(_BYTE *)(v19 + 1) = *(_BYTE *)(v17 + 1);
            *(_BYTE *)(v19 + 2) = *(_BYTE *)(v17 + 2);
            *(_BYTE *)(v19 + 3) = *(_BYTE *)(v17 + 3);
            *(_DWORD *)(v19 + 4) = *(_DWORD *)(v17 + 4);
          }
          ++*(_DWORD *)(a1 + 60);
          v20 = sub_1007D390(*v2 + 8 * v4, (int)&v84, *v2 + 8 * v74, 2.0, v70);
          v21 = *(_DWORD *)(a1 + 60);
          if ( v21 >= *(_DWORD *)(a1 + 64) )
            sub_100943C0(v21 + 1, 0, (int)v2, 1, 8u, 0);
          v22 = *(_DWORD *)(a1 + 56) + 8 * *(_DWORD *)(a1 + 60);
          if ( v22 )
          {
            *(_BYTE *)v22 = *(_BYTE *)v20;
            *(_BYTE *)(v22 + 1) = *(_BYTE *)(v20 + 1);
            *(_BYTE *)(v22 + 2) = *(_BYTE *)(v20 + 2);
            *(_BYTE *)(v22 + 3) = *(_BYTE *)(v20 + 3);
            *(_DWORD *)(v22 + 4) = *(_DWORD *)(v20 + 4);
          }
          ++*(_DWORD *)(a1 + 60);
          v23 = sub_1007D390(*v2 + 8 * v4, (int)&v77, *v2 + 8 * v74, -0.5, v70);
          v24 = *(_DWORD *)(a1 + 60);
          if ( v24 >= *(_DWORD *)(a1 + 64) )
            sub_100943C0(v24 + 1, 0, (int)v2, 1, 8u, 0);
          v25 = *(_DWORD *)(a1 + 56) + 8 * *(_DWORD *)(a1 + 60);
          if ( v25 )
          {
            *(_BYTE *)v25 = *(_BYTE *)v23;
            *(_BYTE *)(v25 + 1) = *(_BYTE *)(v23 + 1);
            *(_BYTE *)(v25 + 2) = *(_BYTE *)(v23 + 2);
            *(_BYTE *)(v25 + 3) = *(_BYTE *)(v23 + 3);
            *(_DWORD *)(v25 + 4) = *(_DWORD *)(v23 + 4);
          }
          ++*(_DWORD *)(a1 + 60);
          v26 = sub_1007D390(*v2 + 8 * v4, (int)&v78, *v2 + 8 * v74, 0.5, v70);
          v27 = *(_DWORD *)(a1 + 60);
          if ( v27 >= *(_DWORD *)(a1 + 64) )
            sub_100943C0(v27 + 1, 0, (int)v2, 1, 8u, 0);
          v28 = *(_DWORD *)(a1 + 56) + 8 * *(_DWORD *)(a1 + 60);
          if ( v28 )
          {
            *(_BYTE *)v28 = *(_BYTE *)v26;
            *(_BYTE *)(v28 + 1) = *(_BYTE *)(v26 + 1);
            *(_BYTE *)(v28 + 2) = *(_BYTE *)(v26 + 2);
            *(_BYTE *)(v28 + 3) = *(_BYTE *)(v26 + 3);
            *(_DWORD *)(v28 + 4) = *(_DWORD *)(v26 + 4);
          }
          ++*(_DWORD *)(a1 + 60);
          v29 = sub_1007D390(*v2 + 8 * v4, (int)&v80, *v2 + 8 * v74, -2.0, v70);
          v30 = *(_DWORD *)(a1 + 60);
          if ( v30 >= *(_DWORD *)(a1 + 64) )
            sub_100943C0(v30 + 1, 0, (int)v2, 1, 8u, 0);
          v31 = *(_DWORD *)(a1 + 56) + 8 * *(_DWORD *)(a1 + 60);
          if ( v31 )
          {
            *(_BYTE *)v31 = *(_BYTE *)v29;
            *(_BYTE *)(v31 + 1) = *(_BYTE *)(v29 + 1);
            *(_BYTE *)(v31 + 2) = *(_BYTE *)(v29 + 2);
            *(_BYTE *)(v31 + 3) = *(_BYTE *)(v29 + 3);
            *(_DWORD *)(v31 + 4) = *(_DWORD *)(v29 + 4);
          }
          ++*(_DWORD *)(a1 + 60);
          v32 = sub_1007D390(*v2 + 8 * v4, (int)&v79, *v2 + 8 * v74, -1.0, v70);
          v33 = *(_DWORD *)(a1 + 60);
          if ( v33 >= *(_DWORD *)(a1 + 64) )
            sub_100943C0(v33 + 1, 0, (int)v2, 1, 8u, 0);
          v34 = *(_DWORD *)(a1 + 56) + 8 * *(_DWORD *)(a1 + 60);
          if ( v34 )
          {
            *(_BYTE *)v34 = *(_BYTE *)v32;
            *(_BYTE *)(v34 + 1) = *(_BYTE *)(v32 + 1);
            *(_BYTE *)(v34 + 2) = *(_BYTE *)(v32 + 2);
            *(_BYTE *)(v34 + 3) = *(_BYTE *)(v32 + 3);
            *(_DWORD *)(v34 + 4) = *(_DWORD *)(v32 + 4);
          }
          v35 = v74;
          ++*(_DWORD *)(a1 + 60);
          v74 = v35 + 1;
        }
        while ( (unsigned int)(v35 + 1) < 2 );
        ++v70;
      }
      while ( v70 < 2 );
    }
    else if ( v3 == 3 )
    {
      v36 = 0;
      v71 = 0;
      do
      {
        v37 = 0;
        do
        {
          if ( v36 != v37 )
          {
            v38 = sub_1007D390(*v2 + 8 * v37, (int)&v79, *v2 + 8 * v71, 1.5, 1);
            v39 = *(_DWORD *)(a1 + 60);
            if ( v39 >= *(_DWORD *)(a1 + 64) )
              sub_100943C0(v39 + 1, 0, (int)v2, 1, 8u, 0);
            v40 = *(_DWORD *)(a1 + 56) + 8 * *(_DWORD *)(a1 + 60);
            if ( v40 )
            {
              *(_BYTE *)v40 = *(_BYTE *)v38;
              *(_BYTE *)(v40 + 1) = *(_BYTE *)(v38 + 1);
              *(_BYTE *)(v40 + 2) = *(_BYTE *)(v38 + 2);
              *(_BYTE *)(v40 + 3) = *(_BYTE *)(v38 + 3);
              *(_DWORD *)(v40 + 4) = *(_DWORD *)(v38 + 4);
            }
            ++*(_DWORD *)(a1 + 60);
            v41 = sub_1007D390(*v2 + 8 * v37, (int)&v80, *v2 + 8 * v71, 0.66666669, 1);
            v42 = *(_DWORD *)(a1 + 60);
            if ( v42 >= *(_DWORD *)(a1 + 64) )
              sub_100943C0(v42 + 1, 0, (int)v2, 1, 8u, 0);
            v43 = *(_DWORD *)(a1 + 56) + 8 * *(_DWORD *)(a1 + 60);
            if ( v43 )
            {
              *(_BYTE *)v43 = *(_BYTE *)v41;
              *(_BYTE *)(v43 + 1) = *(_BYTE *)(v41 + 1);
              *(_BYTE *)(v43 + 2) = *(_BYTE *)(v41 + 2);
              *(_BYTE *)(v43 + 3) = *(_BYTE *)(v41 + 3);
              *(_DWORD *)(v43 + 4) = *(_DWORD *)(v41 + 4);
            }
            ++*(_DWORD *)(a1 + 60);
            v44 = sub_1007D390(*v2 + 8 * v37, (int)&v78, *v2 + 8 * v71, 0.33333334, 1);
            v45 = *(_DWORD *)(a1 + 60);
            if ( v45 >= *(_DWORD *)(a1 + 64) )
              sub_100943C0(v45 + 1, 0, (int)v2, 1, 8u, 0);
            v46 = *(_DWORD *)(a1 + 56) + 8 * *(_DWORD *)(a1 + 60);
            if ( v46 )
            {
              *(_BYTE *)v46 = *(_BYTE *)v44;
              *(_BYTE *)(v46 + 1) = *(_BYTE *)(v44 + 1);
              *(_BYTE *)(v46 + 2) = *(_BYTE *)(v44 + 2);
              *(_BYTE *)(v46 + 3) = *(_BYTE *)(v44 + 3);
              *(_DWORD *)(v46 + 4) = *(_DWORD *)(v44 + 4);
            }
            ++*(_DWORD *)(a1 + 60);
            v47 = sub_1007D390(*v2 + 8 * v37, (int)&v77, *v2 + 8 * v71, -0.5, 1);
            v48 = *(_DWORD *)(a1 + 60);
            if ( v48 >= *(_DWORD *)(a1 + 64) )
              sub_100943C0(v48 + 1, 0, (int)v2, 1, 8u, 0);
            v49 = *(_DWORD *)(a1 + 56) + 8 * *(_DWORD *)(a1 + 60);
            if ( v49 )
            {
              *(_BYTE *)v49 = *(_BYTE *)v47;
              *(_BYTE *)(v49 + 1) = *(_BYTE *)(v47 + 1);
              *(_BYTE *)(v49 + 2) = *(_BYTE *)(v47 + 2);
              *(_BYTE *)(v49 + 3) = *(_BYTE *)(v47 + 3);
              *(_DWORD *)(v49 + 4) = *(_DWORD *)(v47 + 4);
            }
            ++*(_DWORD *)(a1 + 60);
            v36 = v71;
          }
          ++v37;
        }
        while ( v37 <= 2 );
        v71 = ++v36;
      }
      while ( v36 <= 2 );
    }
    v50 = *(_DWORD *)(a1 + 144);
    v51 = (_DWORD *)(a1 + 140);
    if ( v50 )
    {
      if ( !v50 )
        v52 = (_WORD *)*v51;
      *(_DWORD *)(a1 + 144) = 0;
    }
    for ( i = 0; i < *(_DWORD *)(a1 + 60); ++i )
    {
      v53 = (31 * (unsigned int)*(_BYTE *)(*v2 + 8 * i) + 127) / 0xFF;
      v54 = (63 * (unsigned int)*(_BYTE *)(*v2 + 8 * i + 1) + 127) / 0xFF;
      v55 = (31 * (unsigned int)*(_BYTE *)(*v2 + 8 * i + 2) + 127) / 0xFF;
      if ( v53 >= 0x1F )
        LOWORD(v53) = 31;
      if ( v54 >= 0x3F )
        LOWORD(v54) = 63;
      if ( v55 >= 0x1F )
        LOWORD(v55) = 31;
      v56 = (_WORD *)*v51;
      v57 = v55 | 32 * (v54 | ((_WORD)v53 << 6));
      v58 = *(_DWORD *)(a1 + 140) + 2 * *(_DWORD *)(a1 + 144);
      if ( *v51 != v58 )
      {
        do
        {
          if ( *v56 == v57 )
            break;
          ++v56;
        }
        while ( v56 != (_WORD *)v58 );
        if ( v56 != (_WORD *)v58 )
          continue;
      }
      v59 = *(_DWORD *)(a1 + 144);
      if ( v59 >= *(_DWORD *)(a1 + 148) )
        sub_100943C0(v59 + 1, 0, (int)v51, 1, 2u, 0);
      *(_WORD *)(*(_DWORD *)(a1 + 140) + 2 * (*(_DWORD *)(a1 + 144))++) = v57;
    }
    v1 = *(_DWORD *)(a1 + 144);
    if ( v1 >= 2 )
    {
      v60 = 0;
      v73 = 0;
      while ( 1 )
      {
        v61 = 0;
        if ( v1 != 1 )
          break;
LABEL_104:
        v73 = ++v60;
        if ( v60 >= 2 )
          return v1;
      }
      v62 = 1;
      v76 = 1;
      while ( v62 >= v1 )
      {
LABEL_103:
        v1 = *(_DWORD *)(a1 + 144);
        ++v61;
        v76 = ++v62;
        if ( v61 >= v1 - 1 )
          goto LABEL_104;
      }
      v75 = v60 != 0;
      while ( 1 )
      {
        v63 = v60 ? 0 : a1 + 272;
        v64 = *(_WORD *)(*v51 + 2 * v62);
        LOWORD(v74) = *(_WORD *)(*v51 + 2 * v61);
        HIWORD(v74) = v64;
        LOBYTE(v1) = sub_1007ED40(&v74, 1, v75, a1, v63);
        if ( !*(_QWORD *)(a1 + 256) )
          break;
        v60 = v73;
        if ( ++v62 >= *(_DWORD *)(a1 + 144) )
        {
          v62 = v76;
          goto LABEL_103;
        }
      }
      if ( v73 )
      {
        v65 = (void **)(a1 + 276);
        *(_DWORD *)(a1 + 272) = *(_DWORD *)(a1 + 240);
        if ( a1 + 276 != a1 + 244 )
        {
          if ( *(_DWORD *)(a1 + 284) < *(_DWORD *)(a1 + 248) )
          {
            v67 = *v65;
            if ( *v65 )
            {
              if ( (unsigned __int8)v67 & 7 )
              {
                sprintf_s(
                  &DstBuf,
                  0x200u,
                  "%s(%u): Assertion failed: \"%s\"\n",
                  "crn_mem.cpp",
                  216,
                  "crnlib_free: bad ptr");
                OutputDebugStringA(&DstBuf);
                v68 = _iob_func();
                fputs(&DstBuf, v68 + 2);
                if ( IsDebuggerPresent() )
                  DebugBreak();
              }
              else
              {
                off_100AD9F4(v67, 0, 0, 1, dword_100AE9F4);
              }
              *v65 = 0;
              *(_DWORD *)(a1 + 280) = 0;
              *(_DWORD *)(a1 + 284) = 0;
            }
            sub_100943C0(*(_DWORD *)(a1 + 248), 0, a1 + 276, 0, 1u, 0);
          }
          else
          {
            v66 = *(_DWORD *)(a1 + 280);
            if ( v66 )
            {
              if ( v66 <= 0 )
                memset((char *)*v65 + v66, 0, -v66);
              *(_DWORD *)(a1 + 280) = 0;
            }
          }
          memcpy(*v65, *(const void **)(a1 + 244), *(_DWORD *)(a1 + 248));
          *(_DWORD *)(a1 + 280) = *(_DWORD *)(a1 + 248);
        }
        *(_DWORD *)(a1 + 288) = *(_DWORD *)(a1 + 256);
        *(_DWORD *)(a1 + 292) = *(_DWORD *)(a1 + 260);
        *(_BYTE *)(a1 + 296) = *(_BYTE *)(a1 + 264);
        LOBYTE(v1) = *(_BYTE *)(a1 + 265);
        *(_BYTE *)(a1 + 297) = v1;
      }
    }
  }
  return v1;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10081850) --------------------------------------------------------
char __userpurge sub_10081850@<al>(int a1@<eax>, int a2@<ecx>, unsigned int a3)
{
  int v3; // edi@2
  unsigned int v4; // edx@2
  int v5; // esi@2
  float *v6; // eax@2
  unsigned int v7; // ecx@3
  int v8; // ecx@5
  int v9; // ebx@6
  int v10; // ecx@6
  double v11; // st7@9
  double v12; // st6@9
  double v13; // st4@9
  double v14; // st3@9
  double v15; // st4@9
  double v16; // st3@9
  double v17; // st0@9
  double v18; // rt1@9
  double v19; // st7@10
  double v20; // st7@11
  int v21; // ecx@11
  double v22; // st6@11
  int v23; // edi@11
  double v24; // st5@11
  signed int *v25; // esi@11
  signed int v26; // edx@12
  float v27; // ST28_4@12
  float v28; // ST28_4@12
  float v29; // ST28_4@12
  double v30; // st3@12
  float v31; // ST28_4@12
  float v32; // ST28_4@12
  float v33; // ST28_4@14
  float v34; // ST28_4@14
  float v35; // ST28_4@16
  float v36; // ST28_4@16
  signed int v37; // eax@18
  double v38; // st3@18
  double v39; // st3@20
  char *v40; // eax@20
  char v41; // di@22
  char v42; // bl@22
  unsigned int v43; // ecx@22
  float *v44; // esi@22
  char *v45; // edx@22
  int v46; // ebx@34
  float *v47; // ecx@34
  float *v48; // edi@34
  float *v49; // eax@36
  int v50; // eax@38
  float *v51; // edi@43
  signed int v52; // eax@44
  signed int v53; // eax@48
  signed int v54; // eax@52
  signed int v55; // ebx@52
  signed int v56; // eax@54
  signed int v57; // ecx@56
  signed int v58; // edx@56
  signed int v59; // esi@62
  int v60; // ecx@62
  signed int v61; // edx@62
  int v62; // ecx@62
  signed int v63; // eax@62
  int v64; // eax@68
  unsigned int v65; // edi@71
  int v66; // ebx@71
  unsigned int v67; // eax@71
  _DWORD *v68; // esi@71
  void **v69; // esi@79
  void *v70; // eax@83
  char v71; // al@90
  bool v72; // zf@95
  char v73; // al@97
  int v75; // [sp+0h] [bp-F0h]@92
  float v76; // [sp+18h] [bp-D8h]@12
  float v77; // [sp+18h] [bp-D8h]@14
  float v78; // [sp+18h] [bp-D8h]@16
  float *v79; // [sp+18h] [bp-D8h]@43
  float v80; // [sp+1Ch] [bp-D4h]@12
  signed int v81; // [sp+20h] [bp-D0h]@12
  float v82; // [sp+24h] [bp-CCh]@9
  char v83; // [sp+2Bh] [bp-C5h]@41
  signed int v84; // [sp+2Ch] [bp-C4h]@44
  signed int v85; // [sp+30h] [bp-C0h]@20
  float v86; // [sp+34h] [bp-BCh]@9
  float v87; // [sp+38h] [bp-B8h]@9
  float v88; // [sp+3Ch] [bp-B4h]@9
  float *v89; // [sp+40h] [bp-B0h]@10
  float *v90; // [sp+44h] [bp-ACh]@9
  float *v91; // [sp+48h] [bp-A8h]@9
  signed int v92; // [sp+4Ch] [bp-A4h]@44
  float v93; // [sp+50h] [bp-A0h]@9
  float v94; // [sp+54h] [bp-9Ch]@9
  float v95; // [sp+58h] [bp-98h]@9
  float v96; // [sp+5Ch] [bp-94h]@20
  float v97; // [sp+60h] [bp-90h]@20
  float v98; // [sp+64h] [bp-8Ch]@20
  int v99; // [sp+68h] [bp-88h]@43
  int v100; // [sp+6Ch] [bp-84h]@74
  int v101; // [sp+70h] [bp-80h]@10
  int v102; // [sp+74h] [bp-7Ch]@10
  int v103; // [sp+78h] [bp-78h]@10
  int v104; // [sp+7Ch] [bp-74h]@10
  float v105; // [sp+80h] [bp-70h]@2
  float v106; // [sp+84h] [bp-6Ch]@9
  float v107; // [sp+88h] [bp-68h]@9
  float v108; // [sp+8Ch] [bp-64h]@9
  float v109; // [sp+90h] [bp-60h]@9
  float v110; // [sp+94h] [bp-5Ch]@9
  float v111; // [sp+98h] [bp-58h]@9
  float v112; // [sp+9Ch] [bp-54h]@9
  float v113; // [sp+A0h] [bp-50h]@9
  float v114; // [sp+A4h] [bp-4Ch]@9
  float v115; // [sp+A8h] [bp-48h]@9
  float v116; // [sp+ACh] [bp-44h]@9
  float v117; // [sp+B0h] [bp-40h]@50
  char v118; // [sp+B4h] [bp-3Ch]@38
  char v119[4]; // [sp+C0h] [bp-30h]@10
  char v120; // [sp+C4h] [bp-2Ch]@22

  if ( *(_DWORD *)(a3 + 48) > 4u )
  {
    v86 = *(float *)a2 - *(float *)(a3 + 88);
    v87 = *(float *)(a2 + 4) - *(float *)(a3 + 92);
    v88 = *(float *)(a2 + 8) - *(float *)(a3 + 96);
    v11 = v86;
    v105 = v86;
    v12 = v87;
    v106 = v87;
    v107 = v88;
    v93 = *(float *)a1 - *(float *)(a3 + 88);
    v94 = *(float *)(a1 + 4) - *(float *)(a3 + 92);
    v95 = *(float *)(a1 + 8) - *(float *)(a3 + 96);
    v13 = v93;
    v93 = -1.4606504e-12;
    v114 = v13;
    v14 = v94;
    v94 = 1.5759718e-24;
    v115 = v14;
    v116 = v95;
    v15 = v13 - v86;
    v86 = v15 * 0.3333333432674408 + v86;
    v16 = v14 - v87;
    v87 = v16 * 0.3333333432674408 + v87;
    v17 = v88;
    v18 = v95 - v88;
    v88 = 0.3333333432674408 * v18 + v88;
    v108 = v86;
    v109 = v87;
    v110 = v88;
    v86 = v11 + v15 * 0.6666666865348816;
    v87 = v12 + v16 * 0.6666666865348816;
    v88 = v17 + 0.6666666865348816 * v18;
    v111 = v86;
    v112 = v87;
    v113 = v88;
    *(float *)&v91 = 9.9999999e36;
    v82 = 0.0;
    v90 = 0;
    do
    {
      memset(v119, 0, 0x30u);
      v19 = 0.0;
      *(float *)&v89 = 0.0;
      v101 = 0;
      v102 = 0;
      v103 = 0;
      v104 = 0;
      if ( *(_DWORD *)(a3 + 48) )
      {
        v20 = v110;
        v21 = *(_DWORD *)(a3 + 76);
        v22 = v109;
        v23 = *(_DWORD *)(a3 + 48);
        v24 = v108;
        v25 = (signed int *)(*(_DWORD *)(a3 + 44) + 4);
        do
        {
          v26 = 0;
          v80 = v105 - *(float *)v21;
          v27 = v80 * v80 + 0.0;
          v80 = v106 - *(float *)(v21 + 4);
          v28 = v80 * v80 + v27;
          v80 = v107 - *(float *)(v21 + 8);
          v29 = v80 * v80 + v28;
          v30 = v29;
          v80 = v29;
          *(float *)&v81 = v24 - *(float *)v21;
          v31 = *(float *)&v81 * *(float *)&v81 + 0.0;
          *(float *)&v81 = v22 - *(float *)(v21 + 4);
          v32 = *(float *)&v81 * *(float *)&v81 + v31;
          *(float *)&v81 = v20 - *(float *)(v21 + 8);
          v76 = *(float *)&v81 * *(float *)&v81 + v32;
          if ( v76 < v30 )
          {
            v80 = v76;
            v26 = 1;
          }
          *(float *)&v81 = v111 - *(float *)v21;
          v33 = *(float *)&v81 * *(float *)&v81 + 0.0;
          *(float *)&v81 = v112 - *(float *)(v21 + 4);
          v34 = *(float *)&v81 * *(float *)&v81 + v33;
          *(float *)&v81 = v113 - *(float *)(v21 + 8);
          v77 = *(float *)&v81 * *(float *)&v81 + v34;
          if ( v80 > (double)v77 )
          {
            v80 = v77;
            v26 = 2;
          }
          *(float *)&v81 = v114 - *(float *)v21;
          v35 = *(float *)&v81 * *(float *)&v81 + 0.0;
          *(float *)&v81 = v115 - *(float *)(v21 + 4);
          v36 = *(float *)&v81 * *(float *)&v81 + v35;
          *(float *)&v81 = v116 - *(float *)(v21 + 8);
          v78 = *(float *)&v81 * *(float *)&v81 + v36;
          if ( v80 > (double)v78 )
          {
            v80 = v78;
            v26 = 3;
          }
          v37 = *v25;
          *(float *)&v89 = v80 + *(float *)&v89;
          v38 = (double)*v25;
          if ( v37 < 0 )
            v38 = v38 + 4294967300.0;
          *(float *)&v85 = v38;
          v39 = *(float *)&v85;
          v40 = &v119[12 * v26];
          v21 += 12;
          v25 += 2;
          --v23;
          v96 = *(float *)&v85 * *(float *)(v21 - 12);
          v97 = *(float *)&v85 * *(float *)(v21 - 8);
          v98 = *(float *)&v85 * *(float *)(v21 - 4);
          *(float *)v40 = *(float *)v40 + v96;
          *((float *)v40 + 1) = *((float *)v40 + 1) + v97;
          *((float *)v40 + 2) = v98 + *((float *)v40 + 2);
          *((float *)&v101 + v26) = v39 + *((float *)&v101 + v26);
        }
        while ( v23 );
        v19 = 0.0;
      }
      v41 = 0;
      v80 = v19;
      v42 = 0;
      v43 = 0;
      v44 = &v105;
      v45 = &v120;
      do
      {
        if ( v19 >= *((float *)&v101 + v43) )
        {
          v42 = 1;
        }
        else
        {
          v85 = *(&v101 + v43);
          v86 = *((float *)v45 - 1) / *(float *)&v85;
          v87 = *(float *)v45 / *(float *)&v85;
          v88 = *((float *)v45 + 1) / *(float *)&v85;
          if ( v44 != &v86 )
          {
            *v44 = v86;
            v44[1] = v87;
            v44[2] = v88;
          }
          if ( v80 < (double)*((float *)&v101 + v43) )
          {
            v41 = v43;
            v80 = *((float *)&v101 + v43);
          }
        }
        ++v43;
        v45 += 12;
        v44 += 3;
      }
      while ( v43 < 4 );
      if ( v42 )
      {
        *(float *)&v91 = 9.9999999e36;
        if ( v90 != (float *)7 )
        {
          v46 = (v41 + LOBYTE(v82)) & 3;
          v47 = 0;
          ++LODWORD(v82);
          *(float *)&v89 = 0.0;
          v48 = &v107;
          do
          {
            if ( v19 == *((float *)&v101 + (_DWORD)v47) )
            {
              v49 = &v105 + 3 * v46;
              if ( v48 - 2 != v49 )
              {
                *(v48 - 2) = *v49;
                *(v48 - 1) = v49[1];
                *v48 = v49[2];
              }
              v50 = sub_10035120((int)&v93, (int)&v118, -0.00196, 0.00196);
              v47 = v89;
              *(v48 - 2) = *(v48 - 2) + *(float *)v50;
              *(v48 - 1) = *(float *)(v50 + 4) + *(v48 - 1);
              *v48 = *(float *)(v50 + 8) + *v48;
              v19 = 0.0;
            }
            v47 = (float *)((char *)v47 + 1);
            v48 += 3;
            v89 = v47;
          }
          while ( (unsigned int)v47 < 4 );
        }
      }
      else
      {
        *(float *)&v85 = *(float *)&v89 - *(float *)&v91;
        *(float *)&v85 = fabs(*(float *)&v85);
        if ( *(float *)&v85 < 0.0000099999997 )
          break;
        v91 = v89;
      }
      v90 = (float *)((char *)v90 + 1);
    }
    while ( (unsigned int)v90 < 8 );
  }
  else
  {
    v3 = *(_DWORD *)(a3 + 76);
    v4 = 0;
    v5 = *(_DWORD *)(a3 + 80) - 1;
    v6 = &v105;
    do
    {
      v7 = v5;
      if ( v5 >= (signed int)v4 )
        v7 = v4;
      v8 = v3 + 12 * v7;
      if ( v6 != (float *)v8 )
      {
        *v6 = *(float *)v8;
        v9 = *(_DWORD *)(v8 + 4);
        v10 = *(_DWORD *)(v8 + 8);
        *((_DWORD *)v6 + 1) = v9;
        *((_DWORD *)v6 + 2) = v10;
      }
      ++v4;
      v6 += 3;
    }
    while ( v4 < 4 );
  }
  v83 = 0;
  v81 = 1;
  v90 = &v109;
  *(float *)&v91 = COERCE_FLOAT(&v106);
  v85 = 3;
  do
  {
    if ( (unsigned int)v81 < 4 )
    {
      v79 = v90;
      v99 = 4 - v81;
      v51 = v90;
      do
      {
        v86 = *(v91 - 1) + *(float *)(a3 + 88);
        v87 = *v91 + *(float *)(a3 + 92);
        v88 = *(float *)(a3 + 96) + v91[1];
        v96 = *(v51 - 1) + *(float *)(a3 + 88);
        v97 = *(float *)(a3 + 92) + *v51;
        v98 = v51[1] + *(float *)(a3 + 96);
        *(float *)&v84 = v98 * 31.0 + 0.5;
        *(float *)&v84 = floor(*(float *)&v84);
        v82 = *(float *)&v84;
        *(float *)&v84 = v97 * 63.0 + 0.5;
        *(float *)&v84 = floor(*(float *)&v84);
        v92 = v84;
        *(float *)&v84 = v96 * 31.0 + 0.5;
        *(float *)&v84 = floor(*(float *)&v84);
        v52 = (signed int)*(float *)&v84;
        v89 = (float *)(signed int)*(float *)&v84;
        if ( v52 & 0xFFFFFF00 )
          v89 = (float *)(unsigned __int8)~(v52 >> 31);
        v92 = (signed int)*(float *)&v92;
        if ( v92 & 0xFFFFFF00 )
          v92 = (unsigned __int8)~(v92 >> 31);
        v53 = (signed int)v82;
        v84 = (signed int)v82;
        if ( v53 & 0xFFFFFF00 )
          v84 = (unsigned __int8)~(v53 >> 31);
        v82 = v88 * 31.0 + 0.5;
        v82 = floor(v82);
        v93 = v82;
        v82 = v87 * 63.0 + 0.5;
        v82 = floor(v82);
        v117 = v82;
        v82 = v86 * 31.0 + 0.5;
        v82 = floor(v82);
        LODWORD(v82) = (signed int)v82;
        if ( LODWORD(v82) & 0xFFFFFF00 )
          LODWORD(v82) = (unsigned __int8)~(SLODWORD(v82) >> 31);
        v54 = (signed int)v117;
        v55 = (signed int)v117;
        if ( v54 & 0xFFFFFF00 )
          LOBYTE(v55) = ~(v54 >> 31);
        v56 = (signed int)v93;
        if ( v56 & 0xFFFFFF00 )
          LOBYTE(v56) = ~(v56 >> 31);
        v57 = LOBYTE(v82);
        v58 = (unsigned __int8)v55;
        v56 = (unsigned __int8)v56;
        if ( LOBYTE(v82) >= 0x1Fu )
          v57 = 31;
        if ( (unsigned __int8)v55 >= 0x3Fu )
          v58 = 63;
        if ( (unsigned int)v56 >= 0x1F )
          v56 = 31;
        v59 = (unsigned __int8)v92;
        v60 = v58 | (v57 << 6);
        v61 = (unsigned __int8)v84;
        v62 = v56 | 32 * v60;
        v63 = (unsigned __int8)v89;
        LOWORD(v80) = v62;
        if ( (unsigned __int8)v89 >= 0x1Fu )
          v63 = 31;
        if ( (unsigned __int8)v92 >= 0x3Fu )
          v59 = 63;
        if ( (unsigned __int8)v84 >= 0x1Fu )
          v61 = 31;
        v64 = v61 | 32 * (v59 | (v63 << 6));
        HIWORD(v80) = v64;
        if ( (unsigned __int16)v62 < (unsigned __int16)v64 )
        {
          LOWORD(v80) = v64;
          HIWORD(v80) = v62;
        }
        ++*(_DWORD *)(a3 + 232);
        if ( *(_DWORD *)(a3 + 8) )
        {
          sub_1007E440(a3, a3 + 240, (int)&v80, 0, 0, 0);
          sub_10035930(*(_DWORD *)(a3 + 8), *(_DWORD *)(*(_DWORD *)(a3 + 8) + 4) + 1);
          v65 = *(_DWORD *)(*(_DWORD *)a3 + 8);
          v66 = **(_DWORD **)(a3 + 8) + 40 * *(_DWORD *)(*(_DWORD *)(a3 + 8) + 4) - 40;
          v67 = *(_DWORD *)(v66 + 28);
          v68 = (_DWORD *)(v66 + 24);
          if ( v65 != v67 )
          {
            if ( v65 >= v67 )
            {
              if ( v65 > *(_DWORD *)(v66 + 32) )
              {
                LOBYTE(v100) = v65 == v67 + 1;
                sub_100943C0(v65, 0, v66 + 24, v65 == v67 + 1, 1u, 0);
              }
              memset((void *)(*(_DWORD *)(v66 + 28) + *v68), 0, v65 - *(_DWORD *)(v66 + 28));
            }
            *(_DWORD *)(v66 + 28) = v65;
          }
          *(_DWORD *)(v66 + 12) = *v68;
          sub_1007D4E0(a3 + 240, a3, v66);
          if ( a3 == -272 || *(_QWORD *)(a3 + 256) >= *(_QWORD *)(a3 + 288) )
          {
            v51 = v79;
            v71 = 0;
          }
          else
          {
            v69 = (void **)(a3 + 276);
            *(_DWORD *)(a3 + 272) = *(_DWORD *)(a3 + 240);
            if ( a3 + 276 != a3 + 244 )
            {
              if ( *(_DWORD *)(a3 + 284) < *(_DWORD *)(a3 + 248) )
              {
                v70 = *v69;
                if ( *v69 )
                {
                  if ( (unsigned __int8)v70 & 7 )
                    sub_100927E0((int)"crnlib_free: bad ptr");
                  else
                    off_100AD9F4(v70, 0, 0, 1, dword_100AE9F4);
                  *v69 = 0;
                  *(_DWORD *)(a3 + 280) = 0;
                  *(_DWORD *)(a3 + 284) = 0;
                }
                sub_100943C0(*(_DWORD *)(a3 + 248), 0, a3 + 276, 0, 1u, 0);
              }
              else if ( *(_DWORD *)(a3 + 280) )
              {
                *(_DWORD *)(a3 + 280) = 0;
              }
              memcpy(*v69, *(const void **)(a3 + 244), *(_DWORD *)(a3 + 248));
              *(_DWORD *)(a3 + 280) = *(_DWORD *)(a3 + 248);
            }
            *(_DWORD *)(a3 + 288) = *(_DWORD *)(a3 + 256);
            *(_DWORD *)(a3 + 292) = *(_DWORD *)(a3 + 260);
            *(_BYTE *)(a3 + 296) = *(_BYTE *)(a3 + 264);
            *(_BYTE *)(a3 + 297) = *(_BYTE *)(a3 + 265);
            v51 = v79;
            v71 = 1;
          }
        }
        else
        {
          v75 = a3 + 272;
          if ( *(_DWORD *)(*(_DWORD *)a3 + 16) < 3 )
            v71 = sub_1007DD40(&v80, a3, a3 + 240, 1, v75, 0);
          else
            v71 = sub_1007E440(a3, a3 + 240, (int)&v80, 1, v75, 0);
        }
        v83 |= v71;
        v51 += 3;
        v72 = v99-- == 1;
        v79 = v51;
      }
      while ( !v72 );
    }
    ++v81;
    v90 += 3;
    v91 += 3;
    --v85;
  }
  while ( *(float *)&v85 != 0.0 );
  v73 = sub_1007EE30((void *)(*(_DWORD *)(*(_DWORD *)a3 + 16) == 4), a3);
  return v83 | v73;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 10081850: using guessed type char var_30[4];

//----- (10082300) --------------------------------------------------------
char __stdcall sub_10082300(unsigned int a1, int a2, int a3)
{
  double v3; // st7@1
  int v4; // eax@1
  int v5; // eax@3
  unsigned int v6; // eax@14
  int v7; // esi@17
  unsigned int v8; // edi@17
  double v10; // st4@26
  double v11; // st5@26
  double v12; // st3@32
  double v13; // st4@32
  double v14; // rt1@47
  double v15; // st5@47
  double v16; // st6@47
  double v17; // st6@50
  double v18; // rtt@52
  double v19; // st7@54
  bool v20; // zf@55
  char v21; // dl@57
  unsigned int v22; // ecx@57
  double v23; // st7@57
  double v24; // st7@57
  float v25; // ecx@58
  float v26; // edx@58
  char v27; // dl@59
  unsigned int v28; // ecx@59
  double v29; // st7@59
  double v30; // st7@59
  float v31; // ecx@60
  float v32; // edx@60
  int v33; // ecx@61
  double v34; // st7@62
  double v35; // st7@62
  int v36; // eax@62
  signed int v37; // ebx@67
  signed int v38; // eax@69
  signed int v39; // esi@70
  signed int v40; // eax@73
  signed int v41; // edi@74
  signed int v42; // eax@77
  int v43; // esi@81
  int v44; // eax@82
  double v45; // st7@85
  signed int v46; // ebx@86
  signed int v47; // eax@88
  signed int v48; // esi@89
  signed int v49; // eax@92
  signed int v50; // edi@93
  signed int v51; // eax@96
  int v52; // esi@100
  float v53; // eax@101
  __int16 v54; // ax@107
  __int16 v55; // cx@107
  unsigned int v56; // edi@111
  int v57; // ebx@111
  unsigned int v58; // eax@111
  _DWORD *v59; // esi@111
  void **v60; // esi@119
  void *v61; // eax@123
  FILE *v62; // eax@125
  unsigned int v63; // eax@138
  unsigned __int8 v64; // dl@138
  int v65; // ecx@138
  signed int v66; // eax@140
  signed int v67; // ecx@141
  signed int v68; // esi@142
  unsigned __int8 v69; // bl@147
  unsigned int v70; // edx@149
  signed int v71; // ecx@149
  int v72; // eax@155
  unsigned __int16 v73; // cx@155
  __int16 v74; // dx@156
  unsigned int v75; // edi@159
  int v76; // ebx@159
  unsigned int v77; // eax@159
  _DWORD *v78; // esi@159
  unsigned int v79; // eax@173
  int v80; // ecx@173
  int v81; // eax@177
  signed int v82; // eax@179
  signed int v83; // edx@179
  signed int v84; // ecx@179
  int v85; // eax@185
  unsigned __int16 v86; // cx@185
  __int16 v87; // dx@186
  unsigned int v88; // edi@189
  int v89; // ebx@189
  unsigned int v90; // eax@189
  _DWORD *v91; // esi@189
  int v92; // eax@201
  void (*v93)(char *, size_t, const char *, ...); // edi@203
  FILE *v94; // eax@203
  void (__cdecl *v95)(const char *, FILE *); // ebx@203
  unsigned int v96; // esi@208
  int v97; // ecx@209
  int v98; // eax@209
  FILE *v99; // eax@210
  FILE *v100; // eax@214
  float v101; // eax@219
  FILE *v102; // eax@220
  unsigned int v103; // eax@234
  unsigned __int8 v104; // dl@234
  int v105; // ecx@234
  signed int v106; // eax@236
  signed int v107; // ecx@237
  signed int v108; // esi@238
  unsigned int v109; // edx@243
  signed int v110; // esi@245
  unsigned __int16 v111; // cx@251
  int v112; // eax@251
  __int16 v113; // dx@252
  unsigned int v114; // edi@255
  int v115; // ebx@255
  unsigned int v116; // eax@255
  _DWORD *v117; // esi@255
  void **v118; // esi@263
  void *v119; // eax@267
  unsigned int v120; // eax@280
  int v121; // ecx@280
  int v122; // eax@284
  signed int v123; // eax@286
  signed int v124; // esi@286
  signed int v125; // edx@286
  unsigned __int16 v126; // cx@292
  int v127; // eax@292
  unsigned __int16 v128; // dx@293
  int v129; // esi@299
  unsigned int v130; // edx@308
  signed int v131; // eax@309
  int v132; // [sp+0h] [bp-C60h]@132
  int v133; // [sp+0h] [bp-C60h]@168
  int v134; // [sp+0h] [bp-C60h]@229
  int v135; // [sp+0h] [bp-C60h]@275
  char v136; // [sp+1Fh] [bp-C41h]@18
  float v137; // [sp+20h] [bp-C40h]@57
  float *v138; // [sp+24h] [bp-C3Ch]@5
  float v139; // [sp+28h] [bp-C38h]@26
  float v140; // [sp+2Ch] [bp-C34h]@68
  int v141; // [sp+30h] [bp-C30h]@62
  int v142; // [sp+34h] [bp-C2Ch]@18
  float v143; // [sp+38h] [bp-C28h]@88
  int v144; // [sp+3Ch] [bp-C24h]@62
  unsigned int v145; // [sp+40h] [bp-C20h]@6
  unsigned __int8 v146; // [sp+44h] [bp-C1Ch]@177
  unsigned __int8 v147; // [sp+45h] [bp-C1Bh]@177
  unsigned __int8 v148; // [sp+46h] [bp-C1Ah]@177
  char v149; // [sp+47h] [bp-C19h]@177
  unsigned __int8 v150; // [sp+48h] [bp-C18h]@284
  unsigned __int8 v151; // [sp+49h] [bp-C17h]@284
  unsigned __int8 v152; // [sp+4Ah] [bp-C16h]@284
  char v153; // [sp+4Bh] [bp-C15h]@284
  _WORD *v154; // [sp+4Ch] [bp-C14h]@6
  __int16 v155; // [sp+50h] [bp-C10h]@155
  __int16 v156; // [sp+52h] [bp-C0Eh]@155
  unsigned int v157; // [sp+54h] [bp-C0Ch]@6
  __int16 v158; // [sp+58h] [bp-C08h]@185
  __int16 v159; // [sp+5Ah] [bp-C06h]@185
  __int16 v160; // [sp+5Ch] [bp-C04h]@107
  __int16 v161; // [sp+5Eh] [bp-C02h]@107
  unsigned __int16 v162; // [sp+60h] [bp-C00h]@251
  __int16 v163; // [sp+62h] [bp-BFEh]@251
  float v164; // [sp+64h] [bp-BFCh]@25
  float v165; // [sp+68h] [bp-BF8h]@25
  float v166; // [sp+6Ch] [bp-BF4h]@25
  int v167; // [sp+70h] [bp-BF0h]@175
  int v168; // [sp+74h] [bp-BECh]@55
  int v169; // [sp+78h] [bp-BE8h]@62
  int v170; // [sp+7Ch] [bp-BE4h]@62
  float v171; // [sp+80h] [bp-BE0h]@1
  float v172; // [sp+84h] [bp-BDCh]@1
  float v173; // [sp+88h] [bp-BD8h]@1
  float v174; // [sp+8Ch] [bp-BD4h]@1
  float v175; // [sp+90h] [bp-BD0h]@1
  float v176; // [sp+94h] [bp-BCCh]@1
  float v177; // [sp+98h] [bp-BC8h]@18
  float v178; // [sp+9Ch] [bp-BC4h]@88
  float v179; // [sp+A0h] [bp-BC0h]@18
  float v180; // [sp+A4h] [bp-BBCh]@57
  float v181; // [sp+A8h] [bp-BB8h]@57
  float v182; // [sp+ACh] [bp-BB4h]@57
  int v183; // [sp+B0h] [bp-BB0h]@258
  float v184; // [sp+B4h] [bp-BACh]@69
  float v185; // [sp+B8h] [bp-BA8h]@69
  float v186; // [sp+BCh] [bp-BA4h]@69
  unsigned int v187; // [sp+C0h] [bp-BA0h]@219
  int v188; // [sp+C4h] [bp-B9Ch]@192
  int v189; // [sp+C8h] [bp-B98h]@85
  int v190; // [sp+CCh] [bp-B94h]@85
  int v191; // [sp+D0h] [bp-B90h]@85
  float v192; // [sp+D4h] [bp-B8Ch]@69
  float v193; // [sp+D8h] [bp-B88h]@69
  float v194; // [sp+DCh] [bp-B84h]@69
  int v195; // [sp+E0h] [bp-B80h]@162
  int v196; // [sp+E4h] [bp-B7Ch]@62
  int v197; // [sp+E8h] [bp-B78h]@62
  int v198; // [sp+ECh] [bp-B74h]@62
  int v199; // [sp+F0h] [bp-B70h]@114
  float v200; // [sp+F4h] [bp-B6Ch]@62
  float v201; // [sp+F8h] [bp-B68h]@62
  float v202; // [sp+FCh] [bp-B64h]@62
  int v203; // [sp+100h] [bp-B60h]@61
  int v204; // [sp+104h] [bp-B5Ch]@61
  float v205; // [sp+10Ch] [bp-B54h]@25
  float v206; // [sp+110h] [bp-B50h]@25
  float v207; // [sp+114h] [bp-B4Ch]@25
  float v208; // [sp+118h] [bp-B48h]@25
  float v209; // [sp+11Ch] [bp-B44h]@25
  float v210; // [sp+120h] [bp-B40h]@25
  char v211; // [sp+124h] [bp-B3Ch]@157
  char v212; // [sp+12Ch] [bp-B34h]@157
  char v213; // [sp+130h] [bp-B30h]@253
  char v214; // [sp+138h] [bp-B28h]@253
  char v215; // [sp+13Ch] [bp-B24h]@294
  char v216; // [sp+144h] [bp-B1Ch]@294
  char v217; // [sp+148h] [bp-B18h]@187
  char v218; // [sp+150h] [bp-B10h]@187
  char v219; // [sp+154h] [bp-B0Ch]@109
  char v220; // [sp+15Ch] [bp-B04h]@109
  int v221[32]; // [sp+160h] [bp-B00h]@101
  int v222[32]; // [sp+1E0h] [bp-A80h]@82
  char DstBuf; // [sp+260h] [bp-A00h]@125
  CHAR OutputString; // [sp+460h] [bp-800h]@203
  CHAR v225; // [sp+660h] [bp-600h]@214
  CHAR v226; // [sp+860h] [bp-400h]@210
  CHAR v227; // [sp+A60h] [bp-200h]@220

  v174 = *(float *)a2;
  v175 = *(float *)(a2 + 4);
  v176 = *(float *)(a2 + 8);
  v171 = *(float *)a3;
  v172 = *(float *)(a3 + 4);
  v3 = *(float *)(a3 + 8);
  *(_DWORD *)(a1 + 240) = 0;
  v173 = v3;
  v4 = *(_DWORD *)(a1 + 248);
  if ( v4 )
  {
    if ( !v4 )
      v5 = *(_DWORD *)(a1 + 244);
    *(_DWORD *)(a1 + 248) = 0;
  }
  *(_DWORD *)(a1 + 256) = -1;
  *(float *)&v138 = 0.015625;
  *(_DWORD *)(a1 + 260) = -1;
  *(_WORD *)(a1 + 264) = 0;
  switch ( *(_DWORD *)(*(_DWORD *)a1 + 16) )
  {
    case 0:
      v154 = &unk_1009B5F0;
      *(float *)&v138 = 0.027063293;
      v145 = 4;
      v157 = 1;
      break;
    case 1:
      v154 = &unk_1009B5F0;
      *(float *)&v138 = 0.027063293;
      v145 = 4;
      v157 = 2;
      break;
    case 2:
      v154 = &unk_1009B5F8;
      *(float *)&v138 = 0.027063293;
      v145 = 5;
      v157 = 2;
      break;
    case 3:
      v154 = &unk_1009B604;
      v145 = 10;
      v157 = 2;
      break;
    default:
      v154 = &unk_1009B618;
      v145 = 15;
      v157 = 4;
      break;
  }
  if ( *(_DWORD *)(a1 + 324) )
  {
    memset(*(void **)(a1 + 304), 0, 12 * *(_DWORD *)(a1 + 308));
    *(_DWORD *)(a1 + 324) = 0;
  }
  if ( *(_BYTE *)(*(_DWORD *)a1 + 24) )
  {
    v6 = *(_DWORD *)(a1 + 204);
    if ( v6 > 4 )
      v6 = 4;
    if ( v6 > 0 )
    {
      v7 = a1 + 188;
      v8 = v6;
      do
      {
        v142 = *(_WORD *)v7 | (*(_WORD *)(v7 + 2) << 16);
        v136 = 0;
        sub_10035840((int)&v177, a1 + 304, &v142, &v136);
        if ( LOBYTE(v179) )
          sub_1007ED40((_DWORD *)v7, 1, 0, a1, a1 + 272);
        v7 += 4;
        --v8;
      }
      while ( v8 );
    }
    if ( !*(_QWORD *)(a1 + 288) )
    {
      sub_1007D4E0(a1 + 272, a1, *(_DWORD *)(a1 + 4));
      return 1;
    }
  }
  if ( *(_DWORD *)(*(_DWORD *)a1 + 16) >= 3 )
    sub_10081850((int)&v171, (int)&v174, a1);
  v164 = *(float *)(a1 + 124) * *(float *)&v138;
  v165 = *(float *)(a1 + 128) * *(float *)&v138;
  v166 = *(float *)&v138 * *(float *)(a1 + 132);
  v208 = v164 * 31.0;
  v209 = v165 * 63.0;
  v210 = v166 * 31.0;
  v164 = -v208;
  v165 = -v209;
  v166 = -v210;
  v205 = v164;
  v206 = v165;
  v207 = v166;
  *(float *)&v142 = *(float *)a2 * 31.0;
  if ( *(float *)&v142 >= 0.0 )
  {
    if ( *(float *)&v142 <= 31.0 )
      v139 = *(float *)&v142;
    else
      v139 = 31.0;
    v10 = 0.0;
    v11 = 31.0;
  }
  else
  {
    v10 = 0.0;
    v11 = 31.0;
    v139 = 0.0;
  }
  *(float *)a2 = v139;
  *(float *)&v142 = *(float *)(a2 + 4) * 63.0;
  if ( *(float *)&v142 >= v10 )
  {
    if ( *(float *)&v142 <= 63.0 )
      v139 = *(float *)&v142;
    else
      v139 = 63.0;
    v12 = v10;
    v13 = 63.0;
  }
  else
  {
    v12 = v10;
    v13 = 63.0;
    v139 = v12;
  }
  *(float *)(a2 + 4) = v139;
  *(float *)&v142 = *(float *)(a2 + 8) * 31.0;
  if ( *(float *)&v142 >= v12 )
  {
    if ( *(float *)&v142 <= 31.0 )
      v139 = *(float *)&v142;
    else
      v139 = v11;
  }
  else
  {
    v139 = v12;
  }
  *(float *)(a2 + 8) = v139;
  *(float *)&v142 = *(float *)a3 * 31.0;
  if ( *(float *)&v142 >= v12 )
  {
    if ( *(float *)&v142 <= 31.0 )
      v139 = *(float *)&v142;
    else
      v139 = v11;
  }
  else
  {
    v139 = v12;
  }
  *(float *)a3 = v139;
  *(float *)&v142 = *(float *)(a3 + 4) * 63.0;
  if ( *(float *)&v142 >= v12 )
  {
    if ( *(float *)&v142 <= 63.0 )
    {
      v13 = *(float *)&v142;
      v17 = v12;
    }
    else
    {
      v17 = v12;
    }
    v139 = v13;
    v18 = v11;
    v15 = v17;
    v16 = v18;
  }
  else
  {
    v14 = v11;
    v15 = v12;
    v16 = v14;
    v139 = v12;
  }
  *(float *)(a3 + 4) = v139;
  *(float *)&v142 = *(float *)(a3 + 8) * 31.0;
  if ( *(float *)&v142 >= v15 )
  {
    v19 = *(float *)&v142;
    if ( *(float *)&v142 > 31.0 )
      v19 = v16;
  }
  else
  {
    v19 = v15;
  }
  v20 = v157 == 0;
  v139 = v19;
  v168 = 0;
  *(float *)(a3 + 8) = v139;
  if ( v20 )
    goto LABEL_305;
  do
  {
    if ( v168 )
    {
      v21 = *(_WORD *)(a1 + 272);
      v22 = *(_WORD *)(a1 + 272);
      LODWORD(v137) = (unsigned __int8)(v22 >> 11);
      v23 = (double)SLODWORD(v137);
      LODWORD(v137) = (v22 >> 5) & 0x3F;
      v180 = v23;
      v24 = (double)SLODWORD(v137);
      LODWORD(v137) = v21 & 0x1F;
      v181 = v24;
      v182 = (double)SLODWORD(v137);
      if ( (float *)a2 != &v180 )
      {
        v25 = v181;
        *(float *)a2 = v180;
        v26 = v182;
        *(float *)(a2 + 4) = v25;
        *(float *)(a2 + 8) = v26;
      }
      v27 = *(_WORD *)(a1 + 274);
      v28 = *(_WORD *)(a1 + 274);
      LODWORD(v137) = (unsigned __int8)(v28 >> 11);
      v29 = (double)SLODWORD(v137);
      LODWORD(v137) = (v28 >> 5) & 0x3F;
      v164 = v29;
      v30 = (double)SLODWORD(v137);
      LODWORD(v137) = v27 & 0x1F;
      v165 = v30;
      v166 = (double)SLODWORD(v137);
      if ( (float *)a3 != &v164 )
      {
        v31 = v165;
        *(float *)a3 = v164;
        v32 = v166;
        *(float *)(a3 + 4) = v31;
        *(float *)(a3 + 8) = v32;
      }
    }
    v33 = *(_DWORD *)(a1 + 292);
    v203 = *(_DWORD *)(a1 + 288);
    v204 = v33;
    if ( !(v33 | v203) )
      break;
    v169 = -1;
    v170 = -1;
    v196 = 1056964608;
    v197 = 1056964608;
    v198 = 1056964608;
    v34 = *(float *)a2 + 0.5;
    v144 = 0;
    v200 = v34;
    v201 = *(float *)(a2 + 4) + 0.5;
    v35 = *(float *)(a2 + 8) + 0.5;
    v36 = 0;
    v141 = 0;
    v202 = v35;
    if ( v145 )
    {
      while ( 1 )
      {
        v37 = v36 == 0;
        LODWORD(v137) = v154[v36];
        if ( v37 < 2 )
        {
          v138 = &v206 + 3 * v37;
          v140 = (double)SLODWORD(v137);
          do
          {
            v192 = *(v138 - 1) * v140;
            v193 = *v138 * v140;
            v194 = v140 * v138[1];
            v184 = v192 + v200;
            v185 = v193 + v201;
            v186 = v194 + v202;
            v137 = floor(v184);
            v38 = (signed int)v137;
            if ( v38 >= 0 )
            {
              v39 = 31;
              if ( v38 <= 31 )
                v39 = (signed int)v137;
            }
            else
            {
              v39 = 0;
            }
            v137 = floor(v185);
            v40 = (signed int)v137;
            if ( v40 >= 0 )
            {
              v41 = 63;
              if ( v40 <= 63 )
                v41 = (signed int)v137;
            }
            else
            {
              v41 = 0;
            }
            v137 = floor(v186);
            v42 = (signed int)v137;
            if ( v42 >= 0 )
            {
              if ( v42 > 31 )
                v42 = 31;
            }
            else
            {
              v42 = 0;
            }
            v43 = v42 | 32 * (v41 | (v39 << 6));
            if ( v43 != *(&v169 + v37) )
            {
              v44 = v144;
              v222[v144] = v43;
              v144 = v44 + 1;
              *(&v169 + v37) = v43;
            }
            v138 += 3;
            ++v37;
          }
          while ( v37 < 2 );
        }
        if ( ++v141 >= v145 )
          break;
        v36 = v141;
      }
    }
    v169 = -1;
    v170 = -1;
    v189 = 1056964608;
    v190 = 1056964608;
    v191 = 1056964608;
    v45 = *(float *)a3 + 0.5;
    *(float *)&v138 = 0.0;
    v140 = 0.0;
    v174 = v45;
    v175 = *(float *)(a3 + 4) + 0.5;
    v176 = *(float *)(a3 + 8) + 0.5;
    if ( v145 )
    {
      do
      {
        v46 = LODWORD(v140) == 0;
        LODWORD(v137) = v154[LODWORD(v140)];
        if ( v46 < 2 )
        {
          v141 = (int)(&v206 + 3 * v46);
          v137 = (double)SLODWORD(v137);
          do
          {
            v177 = *(float *)(v141 - 4) * v137;
            v178 = v137 * *(float *)v141;
            v179 = v137 * *(float *)(v141 + 4);
            v171 = v174 + v177;
            v172 = v178 + v175;
            v173 = v179 + v176;
            v143 = floor(v171);
            v47 = (signed int)v143;
            if ( v47 >= 0 )
            {
              v48 = 31;
              if ( v47 <= 31 )
                v48 = (signed int)v143;
            }
            else
            {
              v48 = 0;
            }
            v143 = floor(v172);
            v49 = (signed int)v143;
            if ( v49 >= 0 )
            {
              v50 = 63;
              if ( v49 <= 63 )
                v50 = (signed int)v143;
            }
            else
            {
              v50 = 0;
            }
            v143 = floor(v173);
            v51 = (signed int)v143;
            if ( v51 >= 0 )
            {
              if ( v51 > 31 )
                v51 = 31;
            }
            else
            {
              v51 = 0;
            }
            v52 = v51 | 32 * (v50 | (v48 << 6));
            if ( v52 != *(&v169 + v46) )
            {
              v53 = *(float *)&v138;
              v221[(signed int)v138] = v52;
              v138 = (float *)(LODWORD(v53) + 1);
              *(&v169 + v46) = v52;
            }
            v141 += 12;
            ++v46;
          }
          while ( v46 < 2 );
        }
        ++LODWORD(v140);
      }
      while ( LODWORD(v140) < v145 );
    }
    v141 = 0;
    if ( v144 )
    {
      do
      {
        v140 = 0.0;
        if ( *(float *)&v138 != 0.0 )
        {
          LODWORD(v143) = LOWORD(v222[v141]);
          do
          {
            v54 = LOWORD(v143);
            v55 = v221[LODWORD(v140)];
            v160 = LOWORD(v143);
            v161 = v55;
            if ( LOWORD(v143) < (unsigned __int16)v55 )
            {
              v54 = v55;
              v55 = LOWORD(v143);
              v160 = v54;
              v161 = LOWORD(v143);
            }
            v136 = 0;
            LODWORD(v137) = (unsigned __int16)v54 | ((unsigned __int16)v55 << 16);
            sub_10035840((int)&v219, a1 + 304, (int *)&v137, &v136);
            if ( v220 )
            {
              ++*(_DWORD *)(a1 + 232);
              if ( *(_DWORD *)(a1 + 8) )
              {
                sub_1007E440(a1, a1 + 240, (int)&v160, 0, 0, 0);
                sub_10035930(*(_DWORD *)(a1 + 8), *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) + 1);
                v56 = *(_DWORD *)(*(_DWORD *)a1 + 8);
                v57 = **(_DWORD **)(a1 + 8) + 40 * *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) - 40;
                v58 = *(_DWORD *)(v57 + 28);
                v59 = (_DWORD *)(v57 + 24);
                if ( v56 != v58 )
                {
                  if ( v56 >= v58 )
                  {
                    if ( v56 > *(_DWORD *)(v57 + 32) )
                    {
                      LOBYTE(v199) = v56 == v58 + 1;
                      sub_100943C0(v56, 0, v57 + 24, v56 == v58 + 1, 1u, 0);
                    }
                    memset((void *)(*(_DWORD *)(v57 + 28) + *v59), 0, v56 - *(_DWORD *)(v57 + 28));
                  }
                  *(_DWORD *)(v57 + 28) = v56;
                }
                *(_DWORD *)(v57 + 12) = *v59;
                sub_1007D4E0(a1 + 240, a1, v57);
                if ( a1 != -272 && *(_QWORD *)(a1 + 256) < *(_QWORD *)(a1 + 288) )
                {
                  *(_DWORD *)(a1 + 272) = *(_DWORD *)(a1 + 240);
                  v60 = (void **)(a1 + 276);
                  if ( a1 + 276 != a1 + 244 )
                  {
                    if ( *(_DWORD *)(a1 + 284) < *(_DWORD *)(a1 + 248) )
                    {
                      v61 = *v60;
                      if ( *v60 )
                      {
                        if ( (unsigned __int8)v61 & 7 )
                        {
                          sprintf_s(
                            &DstBuf,
                            0x200u,
                            "%s(%u): Assertion failed: \"%s\"\n",
                            "crn_mem.cpp",
                            216,
                            "crnlib_free: bad ptr");
                          OutputDebugStringA(&DstBuf);
                          v62 = _iob_func();
                          fputs(&DstBuf, v62 + 2);
                          if ( IsDebuggerPresent() )
                            DebugBreak();
                        }
                        else
                        {
                          off_100AD9F4(v61, 0, 0, 1, dword_100AE9F4);
                        }
                        *v60 = 0;
                        *(_DWORD *)(a1 + 280) = 0;
                        *(_DWORD *)(a1 + 284) = 0;
                      }
                      sub_100943C0(*(_DWORD *)(a1 + 248), 0, a1 + 276, 0, 1u, 0);
                    }
                    else if ( *(_DWORD *)(a1 + 280) )
                    {
                      *(_DWORD *)(a1 + 280) = 0;
                    }
                    memcpy(*v60, *(const void **)(a1 + 244), *(_DWORD *)(a1 + 248));
                    *(_DWORD *)(a1 + 280) = *(_DWORD *)(a1 + 248);
                  }
                  *(_DWORD *)(a1 + 288) = *(_DWORD *)(a1 + 256);
                  *(_DWORD *)(a1 + 292) = *(_DWORD *)(a1 + 260);
                  *(_BYTE *)(a1 + 296) = *(_BYTE *)(a1 + 264);
                  *(_BYTE *)(a1 + 297) = *(_BYTE *)(a1 + 265);
                }
              }
              else
              {
                v132 = a1 + 272;
                if ( *(_DWORD *)(*(_DWORD *)a1 + 16) < 3 )
                  sub_1007DD40(&v160, a1, a1 + 240, 1, v132, 0);
                else
                  sub_1007E440(a1, a1 + 240, (int)&v160, 1, v132, 0);
              }
            }
            ++LODWORD(v140);
          }
          while ( LODWORD(v140) < (unsigned int)v138 );
        }
        ++v141;
      }
      while ( v141 < (unsigned int)v144 );
    }
    if ( *(_DWORD *)(*(_DWORD *)a1 + 16) < 2 )
      goto LABEL_298;
    v63 = *(_WORD *)(a1 + 272);
    v64 = *(_WORD *)(a1 + 272) & 0x1F;
    v65 = (v63 >> 5) & 0x3F;
    LODWORD(v143) = v64;
    LODWORD(v137) = (v63 >> 5) & 0x3F;
    LODWORD(v140) = (unsigned __int8)(v63 >> 11);
    *(float *)&v138 = COERCE_FLOAT(&unk_1009B649);
    while ( 1 )
    {
      v66 = LODWORD(v140) + *((_BYTE *)v138 - 1);
      if ( (unsigned int)v66 <= 0x1F )
      {
        v67 = *(_BYTE *)v138 + (unsigned __int8)v65;
        if ( (unsigned int)v67 <= 0x3F )
        {
          v68 = v64 + *((_BYTE *)v138 + 1);
          if ( (unsigned int)v68 <= 0x1F )
          {
            if ( v66 & 0xFFFFFF00 )
              LOBYTE(v66) = ~(v66 >> 31);
            if ( v67 & 0xFFFFFF00 )
              LOBYTE(v67) = ~(v67 >> 31);
            v69 = v64 + *((_BYTE *)v138 + 1);
            if ( v68 & 0xFFFFFF00 )
              v69 = ~(v68 >> 31);
            v66 = (unsigned __int8)v66;
            v70 = (unsigned __int8)v67;
            v71 = v69;
            if ( (unsigned __int8)v66 >= 0x1Fu )
              v66 = 31;
            if ( v70 >= 0x3F )
              v70 = 63;
            if ( v69 >= 0x1Fu )
              v71 = 31;
            v72 = v71 | 32 * (v70 | (v66 << 6));
            v73 = *(_WORD *)(a1 + 274);
            v155 = v72;
            v156 = v73;
            if ( (unsigned __int16)v72 < v73 )
            {
              v74 = v72;
              LOWORD(v72) = v73;
              v73 = v74;
              v155 = v72;
              v156 = v74;
            }
            v141 = (unsigned __int16)v72 | (v73 << 16);
            v136 = 0;
            sub_10035840((int)&v211, a1 + 304, &v141, &v136);
            if ( v212 )
            {
              ++*(_DWORD *)(a1 + 232);
              if ( *(_DWORD *)(a1 + 8) )
              {
                sub_1007E440(a1, a1 + 240, (int)&v155, 0, 0, 0);
                sub_10035930(*(_DWORD *)(a1 + 8), *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) + 1);
                v75 = *(_DWORD *)(*(_DWORD *)a1 + 8);
                v76 = **(_DWORD **)(a1 + 8) + 40 * *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) - 40;
                v77 = *(_DWORD *)(v76 + 28);
                v78 = (_DWORD *)(v76 + 24);
                if ( v75 != v77 )
                {
                  if ( v75 >= v77 )
                  {
                    if ( v75 > *(_DWORD *)(v76 + 32) )
                    {
                      LOBYTE(v195) = v75 == v77 + 1;
                      sub_100943C0(v75, 0, v76 + 24, v75 == v77 + 1, 1u, 0);
                    }
                    memset((void *)(*(_DWORD *)(v76 + 28) + *v78), 0, v75 - *(_DWORD *)(v76 + 28));
                  }
                  *(_DWORD *)(v76 + 28) = v75;
                }
                *(_DWORD *)(v76 + 12) = *v78;
                sub_1007D4E0(a1 + 240, a1, v76);
                if ( a1 != -272 && *(_QWORD *)(a1 + 256) < *(_QWORD *)(a1 + 288) )
                  sub_10034F80(a1 + 272, a1 + 240);
              }
              else
              {
                v133 = a1 + 272;
                if ( *(_DWORD *)(*(_DWORD *)a1 + 16) < 3 )
                  sub_1007DD40(&v155, a1, a1 + 240, 1, v133, 0);
                else
                  sub_1007E440(a1, a1 + 240, (int)&v155, 1, v133, 0);
              }
            }
          }
        }
      }
      v138 = (float *)((char *)v138 + 3);
      if ( (signed int)v138 >= (signed int)&unk_1009B697 )
        break;
      v64 = LOBYTE(v143);
      LOBYTE(v65) = LOBYTE(v137);
    }
    if ( *(_DWORD *)(*(_DWORD *)a1 + 16) != 4 )
      goto LABEL_234;
    v79 = *(_WORD *)(a1 + 272);
    v138 = (float *)(*(_WORD *)(a1 + 272) & 0x1F);
    v80 = (v79 >> 5) & 0x3F;
    LODWORD(v137) = (v79 >> 5) & 0x3F;
    LODWORD(v143) = v79 >> 11;
    v144 = 0;
    while ( 2 )
    {
      v167 = v144 != 1 ? 31 : 63;
      v141 = -2;
      while ( 1 )
      {
        v147 = v80;
        v148 = (unsigned __int8)v138;
        v146 = LOBYTE(v143);
        v149 = -1;
        v81 = v141 + *(&v146 + v144);
        if ( v81 >= 0 && v81 <= v167 )
        {
          *(&v146 + v144) = v81;
          v82 = v146;
          v83 = v147;
          v84 = v148;
          if ( v146 >= 0x1Fu )
            v82 = 31;
          if ( v147 >= 0x3Fu )
            v83 = 63;
          if ( v148 >= 0x1Fu )
            v84 = 31;
          v85 = v84 | 32 * (v83 | (v82 << 6));
          v86 = *(_WORD *)(a1 + 274);
          v158 = v85;
          v159 = v86;
          if ( (unsigned __int16)v85 < v86 )
          {
            v87 = v85;
            LOWORD(v85) = v86;
            v86 = v87;
            v158 = v85;
            v159 = v87;
          }
          v136 = 0;
          LODWORD(v140) = (unsigned __int16)v85 | (v86 << 16);
          sub_10035840((int)&v217, a1 + 304, (int *)&v140, &v136);
          if ( v218 )
          {
            ++*(_DWORD *)(a1 + 232);
            if ( *(_DWORD *)(a1 + 8) )
            {
              sub_1007E440(a1, a1 + 240, (int)&v158, 0, 0, 0);
              sub_10035930(*(_DWORD *)(a1 + 8), *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) + 1);
              v88 = *(_DWORD *)(*(_DWORD *)a1 + 8);
              v89 = **(_DWORD **)(a1 + 8) + 40 * *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) - 40;
              v90 = *(_DWORD *)(v89 + 28);
              v91 = (_DWORD *)(v89 + 24);
              if ( v88 != v90 )
              {
                if ( v88 >= v90 )
                {
                  if ( v88 > *(_DWORD *)(v89 + 32) )
                  {
                    LOBYTE(v188) = v88 == v90 + 1;
                    sub_100943C0(v88, 0, v89 + 24, v88 == v90 + 1, 1u, 0);
                  }
                  memset((void *)(*(_DWORD *)(v89 + 28) + *v91), 0, v88 - *(_DWORD *)(v89 + 28));
                }
                *(_DWORD *)(v89 + 28) = v88;
              }
              *(_DWORD *)(v89 + 12) = *v91;
              sub_1007D4E0(a1 + 240, a1, v89);
              if ( a1 != -272 && *(_QWORD *)(a1 + 256) < *(_QWORD *)(a1 + 288) )
              {
                *(_DWORD *)(a1 + 272) = *(_DWORD *)(a1 + 240);
                if ( a1 + 276 != a1 + 244 )
                {
                  if ( *(_DWORD *)(a1 + 284) >= *(_DWORD *)(a1 + 248) )
                  {
                    if ( *(_DWORD *)(a1 + 280) )
                      *(_DWORD *)(a1 + 280) = 0;
                    goto LABEL_227;
                  }
                  v92 = *(_DWORD *)(a1 + 276);
                  if ( v92 )
                  {
                    if ( v92 & 7 )
                    {
                      v93 = (void (*)(char *, size_t, const char *, ...))sprintf_s;
                      sprintf_s(
                        &OutputString,
                        0x200u,
                        "%s(%u): Assertion failed: \"%s\"\n",
                        "crn_mem.cpp",
                        216,
                        "crnlib_free: bad ptr");
                      OutputDebugStringA(&OutputString);
                      v94 = _iob_func();
                      v95 = (void (__cdecl *)(const char *, FILE *))fputs;
                      fputs(&OutputString, v94 + 2);
                      if ( IsDebuggerPresent() )
                        DebugBreak();
                    }
                    else
                    {
                      off_100AD9F4(v92, 0, 0, 1, dword_100AE9F4);
                      v93 = (void (*)(char *, size_t, const char *, ...))sprintf_s;
                      v95 = (void (__cdecl *)(const char *, FILE *))fputs;
                    }
                    *(_DWORD *)(a1 + 276) = 0;
                    *(_DWORD *)(a1 + 280) = 0;
                    *(_DWORD *)(a1 + 284) = 0;
                  }
                  else
                  {
                    v93 = (void (*)(char *, size_t, const char *, ...))sprintf_s;
                    v95 = (void (__cdecl *)(const char *, FILE *))fputs;
                  }
                  v96 = *(_DWORD *)(a1 + 248);
                  if ( *(_DWORD *)(a1 + 284) < v96 )
                  {
                    v97 = *(_DWORD *)(a1 + 276);
                    v98 = *(int *)(a1 + 248);
                    if ( v97 & 7 )
                    {
                      v93(
                        &v226,
                        0x200u,
                        "%s(%u): Assertion failed: \"%s\"\n",
                        "crn_mem.cpp",
                        216,
                        "crnlib_realloc: bad ptr");
                      OutputDebugStringA(&v226);
                      v99 = _iob_func();
                      v95(&v226, v99 + 2);
                      if ( IsDebuggerPresent() )
                        DebugBreak();
LABEL_212:
                      v140 = 0.0;
                      goto LABEL_220;
                    }
                    if ( v96 <= 0x7FFF0000 )
                    {
                      if ( v96 && v96 < 4 )
                        v98 = 4;
                      v142 = v98;
                      v101 = COERCE_FLOAT(off_100AD9F4(v97, v98, &v142, 1, dword_100AE9F4));
                      v187 = v142;
                      v140 = v101;
                      if ( v101 == 0.0 )
                        goto LABEL_220;
                    }
                    else
                    {
                      v93(
                        &v225,
                        0x200u,
                        "%s(%u): Assertion failed: \"%s\"\n",
                        "crn_mem.cpp",
                        216,
                        "crnlib_malloc: size too big");
                      OutputDebugStringA(&v225);
                      v100 = _iob_func();
                      v95(&v225, v100 + 2);
                      if ( !IsDebuggerPresent() )
                        goto LABEL_212;
                      DebugBreak();
                      v140 = 0.0;
LABEL_220:
                      v93(&DstBuf, 0x100u, "vector: crnlib_realloc() failed allocating %u bytes", v96);
                      v93(&v227, 0x200u, "%s(%u): Failure: \"%s\"\n", "crn_vector.cpp", 46, "buf");
                      OutputDebugStringA(&v227);
                      v102 = _iob_func();
                      v95(&v227, v102 + 2);
                      if ( IsDebuggerPresent() )
                        DebugBreak();
                      if ( !byte_100AE9F8 )
                        exit(1);
                      RaiseException(0x100u, 0, 0, 0);
                    }
                    *(float *)(a1 + 276) = v140;
                    if ( v187 <= v96 )
                      *(_DWORD *)(a1 + 284) = v96;
                    else
                      *(_DWORD *)(a1 + 284) = v187;
                  }
LABEL_227:
                  memcpy(*(void **)(a1 + 276), *(const void **)(a1 + 244), *(_DWORD *)(a1 + 248));
                  *(_DWORD *)(a1 + 280) = *(_DWORD *)(a1 + 248);
                }
                *(_DWORD *)(a1 + 288) = *(_DWORD *)(a1 + 256);
                *(_DWORD *)(a1 + 292) = *(_DWORD *)(a1 + 260);
                *(_BYTE *)(a1 + 296) = *(_BYTE *)(a1 + 264);
                *(_BYTE *)(a1 + 297) = *(_BYTE *)(a1 + 265);
                goto LABEL_232;
              }
            }
            else
            {
              v134 = a1 + 272;
              if ( *(_DWORD *)(*(_DWORD *)a1 + 16) < 3 )
                sub_1007DD40(&v158, a1, a1 + 240, 1, v134, 0);
              else
                sub_1007E440(a1, a1 + 240, (int)&v158, 1, v134, 0);
            }
          }
        }
LABEL_232:
        v141 += 4;
        if ( v141 > 2 )
          break;
        LOBYTE(v80) = LOBYTE(v137);
      }
      if ( ++v144 < 3 )
      {
        LOBYTE(v80) = LOBYTE(v137);
        continue;
      }
      break;
    }
LABEL_234:
    v103 = *(_WORD *)(a1 + 274);
    v104 = *(_WORD *)(a1 + 274) & 0x1F;
    v105 = (v103 >> 5) & 0x3F;
    v167 = v104;
    LODWORD(v143) = (v103 >> 5) & 0x3F;
    LODWORD(v137) = (unsigned __int8)(v103 >> 11);
    *(float *)&v138 = COERCE_FLOAT(&unk_1009B649);
    while ( 1 )
    {
      v106 = LODWORD(v137) + *((_BYTE *)v138 - 1);
      if ( (unsigned int)v106 <= 0x1F )
      {
        v107 = *(_BYTE *)v138 + (unsigned __int8)v105;
        if ( (unsigned int)v107 <= 0x3F )
        {
          v108 = v104 + *((_BYTE *)v138 + 1);
          if ( (unsigned int)v108 <= 0x1F )
          {
            if ( v106 & 0xFFFFFF00 )
              LOBYTE(v106) = ~(v106 >> 31);
            if ( v107 & 0xFFFFFF00 )
              LOBYTE(v107) = ~(v107 >> 31);
            LOBYTE(v109) = v104 + *((_BYTE *)v138 + 1);
            if ( v108 & 0xFFFFFF00 )
              LOBYTE(v109) = ~(v108 >> 31);
            v106 = (unsigned __int8)v106;
            v110 = (unsigned __int8)v107;
            v109 = (unsigned __int8)v109;
            if ( (unsigned __int8)v106 >= 0x1Fu )
              v106 = 31;
            if ( (unsigned __int8)v107 >= 0x3Fu )
              v110 = 63;
            if ( v109 >= 0x1F )
              v109 = 31;
            v111 = *(_WORD *)(a1 + 272);
            v112 = v109 | 32 * (v110 | (v106 << 6));
            v162 = v111;
            v163 = v112;
            if ( v111 < (unsigned __int16)v112 )
            {
              v113 = v111;
              v111 = v112;
              LOWORD(v112) = v113;
              v162 = v111;
              v163 = v113;
            }
            LODWORD(v140) = v111 | ((unsigned __int16)v112 << 16);
            v136 = 0;
            sub_10035840((int)&v213, a1 + 304, (int *)&v140, &v136);
            if ( v214 )
            {
              ++*(_DWORD *)(a1 + 232);
              if ( *(_DWORD *)(a1 + 8) )
              {
                sub_1007E440(a1, a1 + 240, (int)&v162, 0, 0, 0);
                sub_10035930(*(_DWORD *)(a1 + 8), *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) + 1);
                v114 = *(_DWORD *)(*(_DWORD *)a1 + 8);
                v115 = **(_DWORD **)(a1 + 8) + 40 * *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) - 40;
                v116 = *(_DWORD *)(v115 + 28);
                v117 = (_DWORD *)(v115 + 24);
                if ( v114 != v116 )
                {
                  if ( v114 >= v116 )
                  {
                    if ( v114 > *(_DWORD *)(v115 + 32) )
                    {
                      LOBYTE(v183) = v114 == v116 + 1;
                      sub_100943C0(v114, 0, v115 + 24, v114 == v116 + 1, 1u, 0);
                    }
                    memset((void *)(*(_DWORD *)(v115 + 28) + *v117), 0, v114 - *(_DWORD *)(v115 + 28));
                  }
                  *(_DWORD *)(v115 + 28) = v114;
                }
                *(_DWORD *)(v115 + 12) = *v117;
                sub_1007D4E0(a1 + 240, a1, v115);
                if ( a1 != -272 && *(_QWORD *)(a1 + 256) < *(_QWORD *)(a1 + 288) )
                {
                  *(_DWORD *)(a1 + 272) = *(_DWORD *)(a1 + 240);
                  v118 = (void **)(a1 + 276);
                  if ( a1 + 276 != a1 + 244 )
                  {
                    if ( *(_DWORD *)(a1 + 284) < *(_DWORD *)(a1 + 248) )
                    {
                      v119 = *v118;
                      if ( *v118 )
                      {
                        if ( (unsigned __int8)v119 & 7 )
                          sub_100927E0((int)"crnlib_free: bad ptr");
                        else
                          off_100AD9F4(v119, 0, 0, 1, dword_100AE9F4);
                        *v118 = 0;
                        *(_DWORD *)(a1 + 280) = 0;
                        *(_DWORD *)(a1 + 284) = 0;
                      }
                      sub_100943C0(*(_DWORD *)(a1 + 248), 0, a1 + 276, 0, 1u, 0);
                    }
                    else if ( *(_DWORD *)(a1 + 280) )
                    {
                      *(_DWORD *)(a1 + 280) = 0;
                    }
                    memcpy(*v118, *(const void **)(a1 + 244), *(_DWORD *)(a1 + 248));
                    *(_DWORD *)(a1 + 280) = *(_DWORD *)(a1 + 248);
                  }
                  *(_DWORD *)(a1 + 288) = *(_DWORD *)(a1 + 256);
                  *(_DWORD *)(a1 + 292) = *(_DWORD *)(a1 + 260);
                  *(_BYTE *)(a1 + 296) = *(_BYTE *)(a1 + 264);
                  *(_BYTE *)(a1 + 297) = *(_BYTE *)(a1 + 265);
                }
              }
              else
              {
                v135 = a1 + 272;
                if ( *(_DWORD *)(*(_DWORD *)a1 + 16) < 3 )
                  sub_1007DD40(&v162, a1, a1 + 240, 1, v135, 0);
                else
                  sub_1007E440(a1, a1 + 240, (int)&v162, 1, v135, 0);
              }
            }
          }
        }
      }
      v138 = (float *)((char *)v138 + 3);
      if ( (signed int)v138 >= (signed int)&unk_1009B697 )
        break;
      v104 = v167;
      LOBYTE(v105) = LOBYTE(v143);
    }
    if ( *(_DWORD *)(*(_DWORD *)a1 + 16) == 4 )
    {
      v120 = *(_WORD *)(a1 + 274);
      LODWORD(v143) = *(_WORD *)(a1 + 274) & 0x1F;
      v121 = (v120 >> 5) & 0x3F;
      LODWORD(v137) = (v120 >> 5) & 0x3F;
      v167 = v120 >> 11;
      v144 = 0;
      while ( 1 )
      {
        v141 = v144 != 1 ? 31 : 63;
        v140 = -6.8056465e38/*NaN*/;
        while ( 1 )
        {
          v151 = v121;
          v152 = LOBYTE(v143);
          v150 = v167;
          v153 = -1;
          v122 = LODWORD(v140) + *(&v150 + v144);
          if ( v122 >= 0 && v122 <= v141 )
          {
            *(&v150 + v144) = v122;
            v123 = v150;
            v124 = v151;
            v125 = v152;
            if ( v150 >= 0x1Fu )
              v123 = 31;
            if ( v151 >= 0x3Fu )
              v124 = 63;
            if ( v152 >= 0x1Fu )
              v125 = 31;
            v126 = *(_WORD *)(a1 + 272);
            v127 = v125 | 32 * (v124 | (v123 << 6));
            LOWORD(v139) = v126;
            HIWORD(v139) = v127;
            if ( v126 < (unsigned __int16)v127 )
            {
              v128 = v126;
              v126 = v127;
              LOWORD(v127) = v128;
              LOWORD(v139) = v126;
              HIWORD(v139) = v128;
            }
            v136 = 0;
            v138 = (float *)(v126 | ((unsigned __int16)v127 << 16));
            sub_10035840((int)&v215, a1 + 304, (int *)&v138, &v136);
            if ( v216 )
              sub_1007ED40(&v139, 1, 0, a1, a1 + 272);
          }
          LODWORD(v140) += 4;
          if ( SLODWORD(v140) > 2 )
            break;
          LOBYTE(v121) = LOBYTE(v137);
        }
        if ( ++v144 >= 3 )
          break;
        LOBYTE(v121) = LOBYTE(v137);
      }
    }
LABEL_298:
    if ( !*(_QWORD *)(a1 + 288) )
      break;
    v129 = v168;
    if ( v168 )
    {
      if ( *(_DWORD *)(a1 + 288) == v203 && *(_DWORD *)(a1 + 292) == v204 )
        break;
    }
    if ( *(_DWORD *)(*(_DWORD *)a1 + 16) >= 4 )
      sub_1007EE30((void *)1, a1);
    v168 = v129 + 1;
  }
  while ( v129 + 1 < v157 );
LABEL_305:
  if ( *(_DWORD *)(*(_DWORD *)a1 + 16) >= 2 )
  {
    if ( *(_QWORD *)(a1 + 288) && !*(_BYTE *)(*(_DWORD *)a1 + 20) )
    {
      v130 = *(_DWORD *)(a1 + 280);
      if ( !v130 )
        goto LABEL_313;
      v131 = 1;
      if ( v130 <= 1 )
      {
LABEL_312:
        if ( !sub_10080840(a1) )
          goto LABEL_313;
      }
      else
      {
        while ( *(_BYTE *)(v131 + *(_DWORD *)(a1 + 276)) == **(_BYTE **)(a1 + 276) )
        {
          if ( ++v131 >= v130 )
            goto LABEL_312;
        }
LABEL_313:
        if ( *(_DWORD *)(*(_DWORD *)a1 + 16) == 4 )
          sub_1007FCF0(a1);
      }
    }
    if ( *(_DWORD *)(*(_DWORD *)a1 + 16) == 4 && *(_QWORD *)(a1 + 288) )
      sub_10080E70(a1);
  }
  sub_1007D4E0(a1 + 272, a1, *(_DWORD *)(a1 + 4));
  if ( *(_BYTE *)(*(_DWORD *)a1 + 24) )
    *(_DWORD *)(a1 + 4 * ((*(_DWORD *)(a1 + 204))++ & 3) + 188) = *(_DWORD *)(a1 + 272);
  return 1;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100AE9F8: using guessed type char byte_100AE9F8;
// 10082300: using guessed type int var_A80[32];
// 10082300: using guessed type int var_B00[32];

//----- (10083D40) --------------------------------------------------------
bool __usercall sub_10083D40@<al>(unsigned int a1@<eax>)
{
  double v1; // st7@1
  unsigned int v2; // esi@1
  double v3; // st6@1
  unsigned int v4; // ebx@1
  signed int v5; // ebp@2
  float v6; // eax@2
  int v7; // edx@3
  int v8; // eax@3
  int v9; // edx@3
  unsigned int v10; // ebp@3
  float v11; // ST30_4@6
  int v12; // ecx@4
  float v13; // ST30_4@6
  float v14; // ST30_4@8
  signed int v15; // ecx@6
  float v16; // ST30_4@8
  float v17; // ST30_4@10
  signed int v18; // ecx@8
  float v19; // ST30_4@10
  double v20; // st5@10
  float v21; // ST30_4@12
  signed int v22; // ecx@10
  float v23; // ST30_4@12
  int v24; // edx@15
  int v25; // ebp@15
  signed int v26; // eax@16
  float v27; // ST30_4@18
  double v28; // st6@20
  double v29; // st7@20
  double v30; // st5@22
  float v31; // ST30_4@24
  float v32; // ST30_4@25
  double v33; // st6@25
  unsigned int v34; // ebp@31
  float *v35; // edi@32
  long double v36; // st7@33
  double v37; // st7@34
  double v38; // st7@37
  signed int v39; // ebx@43
  unsigned int v40; // ebp@43
  double v41; // st5@43
  double v42; // st4@43
  int v43; // edx@44
  int v44; // ecx@44
  unsigned int v45; // edi@44
  float v46; // ST20_4@45
  float v47; // ST20_4@49
  float v48; // ST20_4@53
  float v49; // ST20_4@57
  int v50; // ecx@63
  int v51; // ebx@63
  float v52; // ST20_4@64
  int v53; // ecx@69
  double v54; // rt2@70
  double v55; // rtt@72
  double v56; // st6@72
  double v57; // st7@72
  double v58; // rt0@75
  int v59; // ecx@79
  double v60; // rt1@80
  double v61; // st6@80
  double v62; // st7@80
  double v63; // rt2@81
  double v64; // rtt@84
  int v66; // [sp+8h] [bp-7Ch]@4
  int v67; // [sp+8h] [bp-7Ch]@6
  int v68; // [sp+8h] [bp-7Ch]@8
  int v69; // [sp+8h] [bp-7Ch]@10
  int v70; // [sp+8h] [bp-7Ch]@16
  float v71; // [sp+8h] [bp-7Ch]@45
  float v72; // [sp+8h] [bp-7Ch]@49
  float v73; // [sp+8h] [bp-7Ch]@53
  float v74; // [sp+8h] [bp-7Ch]@57
  float v75; // [sp+8h] [bp-7Ch]@64
  float v76; // [sp+Ch] [bp-78h]@2
  float v77; // [sp+Ch] [bp-78h]@4
  float v78; // [sp+Ch] [bp-78h]@6
  float v79; // [sp+Ch] [bp-78h]@8
  float v80; // [sp+Ch] [bp-78h]@20
  float v81; // [sp+10h] [bp-74h]@2
  float v82; // [sp+10h] [bp-74h]@6
  float v83; // [sp+10h] [bp-74h]@8
  float v84; // [sp+10h] [bp-74h]@10
  float v85; // [sp+10h] [bp-74h]@19
  float v86; // [sp+14h] [bp-70h]@2
  float v87; // [sp+14h] [bp-70h]@6
  float v88; // [sp+14h] [bp-70h]@8
  float v89; // [sp+14h] [bp-70h]@10
  float v90; // [sp+14h] [bp-70h]@19
  float v91; // [sp+18h] [bp-6Ch]@16
  signed int v92; // [sp+1Ch] [bp-68h]@10
  signed int v93; // [sp+20h] [bp-64h]@10
  signed int v94; // [sp+24h] [bp-60h]@2
  signed int v95; // [sp+24h] [bp-60h]@16
  float v96; // [sp+28h] [bp-5Ch]@3
  float v97; // [sp+2Ch] [bp-58h]@1
  float v98; // [sp+30h] [bp-54h]@1
  float v99; // [sp+34h] [bp-50h]@1
  float v100; // [sp+38h] [bp-4Ch]@29
  float v101; // [sp+3Ch] [bp-48h]@29
  float v102; // [sp+40h] [bp-44h]@29
  float v103; // [sp+44h] [bp-40h]@32
  float v104; // [sp+48h] [bp-3Ch]@32
  float v105; // [sp+4Ch] [bp-38h]@32
  float v106; // [sp+50h] [bp-34h]@76
  float v107; // [sp+54h] [bp-30h]@76
  float v108; // [sp+58h] [bp-2Ch]@76
  float v109; // [sp+5Ch] [bp-28h]@76
  float v110; // [sp+60h] [bp-24h]@76
  float v111; // [sp+64h] [bp-20h]@76
  float v112; // [sp+68h] [bp-1Ch]@76
  float v113; // [sp+6Ch] [bp-18h]@76
  float v114; // [sp+70h] [bp-14h]@76
  float v115; // [sp+74h] [bp-10h]@76
  float v116; // [sp+78h] [bp-Ch]@76
  float v117; // [sp+7Ch] [bp-8h]@76

  v1 = 1.0;
  v97 = 1.0;
  v98 = 1.0;
  v2 = a1;
  v99 = 1.0;
  v3 = 0.0;
  v4 = 1;
  if ( *(_BYTE *)(a1 + 12) )
  {
    v5 = *(_DWORD *)(a1 + 48);
    v81 = 0.0;
    v6 = 0.0;
    v86 = 0.0;
    v76 = 0.0;
    v94 = v5;
    if ( v5 >= 4 )
    {
      v7 = *(_DWORD *)(v2 + 44);
      v8 = v7 + 2;
      v9 = v7 + 10;
      v10 = ((unsigned int)(v5 - 4) >> 2) + 1;
      LODWORD(v96) = 4 * v10;
      do
      {
        v12 = 85 * (*(_BYTE *)(v8 - 2) + *(_BYTE *)v8 + *(_BYTE *)(v8 - 1));
        v66 = (v12 + 128 + ((v12 + 128) >> 8)) >> 8;
        v77 = (double)v66 + v76;
        if ( v66 < 1 )
          v66 = 1;
        v11 = (double)*(unsigned int *)(v8 + 2);
        v13 = v11 / (double)v66;
        v82 = (double)*(_BYTE *)(v8 - 2) * v13 + v81;
        v87 = v13 * (double)*(_BYTE *)v8 + v86;
        v15 = 85 * (*(_BYTE *)v9 + *(_BYTE *)(v8 + 6) + *(_BYTE *)(v9 - 1)) + 128;
        v67 = (v15 + (v15 >> 8)) >> 8;
        v78 = (double)v67 + v77;
        if ( v67 < 1 )
          v67 = 1;
        v14 = (double)*(unsigned int *)(v8 + 10);
        v16 = v14 / (double)v67;
        v83 = (double)*(_BYTE *)(v8 + 6) * v16 + v82;
        v88 = v16 * (double)*(_BYTE *)v9 + v87;
        v18 = 85 * (*(_BYTE *)(v9 + 8) + *(_BYTE *)(v8 + 14) + *(_BYTE *)(v9 + 7)) + 128;
        v68 = (v18 + (v18 >> 8)) >> 8;
        v79 = (double)v68 + v78;
        if ( v68 < 1 )
          v68 = 1;
        v17 = (double)*(unsigned int *)(v8 + 18);
        v19 = v17 / (double)v68;
        v84 = (double)*(_BYTE *)(v8 + 14) * v19 + v83;
        v89 = v19 * (double)*(_BYTE *)(v9 + 8) + v88;
        v20 = (double)*(unsigned int *)(v8 + 26);
        v92 = *(_BYTE *)(v9 + 16);
        v22 = 85 * (v92 + *(_BYTE *)(v8 + 22) + *(_BYTE *)(v9 + 15)) + 128;
        v69 = (v22 + (v22 >> 8)) >> 8;
        v93 = *(_BYTE *)(v8 + 22);
        v76 = (double)v69 + v79;
        if ( v69 < 1 )
          v69 = 1;
        v8 += 32;
        v9 += 32;
        --v10;
        v21 = v20;
        v23 = v21 / (double)v69;
        v81 = (double)v93 * v23 + v84;
        v86 = v23 * (double)v92 + v89;
      }
      while ( v10 );
      v5 = v94;
      v6 = v96;
    }
    if ( LODWORD(v6) < v5 )
    {
      v24 = *(_DWORD *)(v2 + 44) + 8 * LODWORD(v6);
      v25 = v5 - LODWORD(v6);
      do
      {
        v91 = (double)*(unsigned int *)(v24 + 4);
        v95 = *(_BYTE *)(v24 + 2);
        v26 = 85 * (v95 + *(_BYTE *)v24 + *(_BYTE *)(v24 + 1)) + 128;
        v70 = (v26 + (v26 >> 8)) >> 8;
        LODWORD(v96) = *(_BYTE *)v24;
        v76 = (double)v70 + v76;
        if ( v70 < 1 )
          v70 = 1;
        v24 += 8;
        --v25;
        v27 = v91 / (double)v70;
        v81 = (double)SLODWORD(v96) * v27 + v81;
        v86 = v27 * (double)v95 + v86;
      }
      while ( v25 );
    }
    v96 = (double)*(unsigned int *)(v2 + 68);
    v85 = v81 / v96;
    v90 = v86 / v96;
    v96 = v76 / v96;
    v96 = v96 * 16.0 / 255.0;
    if ( v96 <= 1.0 )
    {
      v80 = v96;
      v28 = 1.0;
      v29 = 0.0;
    }
    else
    {
      v28 = 1.0;
      v29 = 0.0;
      v80 = 1.0;
    }
    v30 = v85;
    if ( v90 >= (double)v85 )
      v30 = v90;
    v31 = v30;
    v96 = v31 / 3.0;
    if ( v96 >= v29 )
    {
      v29 = v96;
      if ( v28 < v96 )
        v29 = v28;
    }
    v32 = v29;
    v96 = pow(v32, 2.75);
    v96 = v96 * v80;
    v1 = 1.0;
    v33 = v96;
    if ( v96 < 1.0 )
    {
      v4 = 2;
      v100 = 0.7880000025033951 * v33 + 0.2119999974966049;
      v101 = 0.2799999713897705 * v33 + 0.7200000286102295;
      v102 = v33 * 0.9280000030994415 + 0.07199999690055847;
      v97 = v100;
      v98 = v101;
      v99 = v102;
    }
    else
    {
      v4 = 1;
    }
    v3 = 0.0;
  }
  v34 = 0;
  if ( v4 )
  {
    v35 = (float *)(v2 + 124);
    v103 = 0.28371489;
    v104 = 0.95406312;
    v105 = 0.096277453;
    do
    {
      sub_1007D660(v2, (int)&v97);
      sub_1007C9D0(v2, v2 + 124, v2 + 100, (int)&v103);
      *v35 = *v35 / v97;
      *(float *)(v2 + 128) = *(float *)(v2 + 128) / v98;
      *(float *)(v2 + 132) = *(float *)(v2 + 132) / v99;
      v36 = *(float *)(v2 + 124) * *(float *)(v2 + 124)
          + *(float *)(v2 + 128) * *(float *)(v2 + 128)
          + *(float *)(v2 + 132) * *(float *)(v2 + 132);
      if ( 0.0 != v36 )
      {
        v96 = 1.0 / sqrt(v36);
        v37 = v96;
        *v35 = *v35 * v96;
        *(float *)(v2 + 128) = *(float *)(v2 + 128) * v37;
        *(float *)(v2 + 132) = v37 * *(float *)(v2 + 132);
      }
      if ( v4 > 1 )
      {
        v96 = fabs(*v35);
        if ( v96 < 0.7950000166893005 )
        {
          v96 = fabs(*(float *)(v2 + 132));
          if ( v96 < 0.7950000166893005 )
            break;
          v38 = 0.212;
          v97 = 0.212;
          v98 = 0.60000002;
        }
        else
        {
          v97 = 0.42399999;
          v98 = 0.60000002;
          v38 = 0.071999997;
        }
        v99 = v38;
      }
      ++v34;
    }
    while ( v34 < v4 );
    v1 = 1.0;
    v3 = 0.0;
  }
  v39 = *(_DWORD *)(v2 + 80);
  v40 = 0;
  v41 = (float)1000000000.0;
  v42 = (float)-1000000000.0;
  if ( v39 >= 4 )
  {
    v43 = *(_DWORD *)(v2 + 76);
    v44 = v43 + 20;
    v45 = ((unsigned int)(v39 - 4) >> 2) + 1;
    v40 = 4 * v45;
    do
    {
      v46 = *(float *)(v2 + 124) * *(float *)v43;
      v96 = *(float *)(v43 + 4) * *(float *)(v2 + 128) + v46;
      v71 = v96 + *(float *)(v43 + 8) * *(float *)(v2 + 132);
      if ( v71 <= v41 )
        v41 = v71;
      if ( v71 >= v42 )
        v42 = v71;
      v47 = *(float *)(v43 + 12) * *(float *)(v2 + 124);
      v96 = *(float *)(v44 - 4) * *(float *)(v2 + 128) + v47;
      v72 = v96 + *(float *)(v2 + 132) * *(float *)v44;
      if ( v72 <= v41 )
        v41 = v72;
      if ( v72 >= v42 )
        v42 = v72;
      v48 = *(float *)(v43 + 24) * *(float *)(v2 + 124);
      v96 = *(float *)(v44 + 8) * *(float *)(v2 + 128) + v48;
      v73 = v96 + *(float *)(v44 + 12) * *(float *)(v2 + 132);
      if ( v73 <= v41 )
        v41 = v73;
      if ( v73 >= v42 )
        v42 = v73;
      v49 = *(float *)(v43 + 36) * *(float *)(v2 + 124);
      v96 = *(float *)(v44 + 20) * *(float *)(v2 + 128) + v49;
      v74 = v96 + *(float *)(v44 + 24) * *(float *)(v2 + 132);
      if ( v74 <= v41 )
        v41 = v74;
      if ( v74 >= v42 )
        v42 = v74;
      v43 += 48;
      v44 += 48;
      --v45;
    }
    while ( v45 );
  }
  if ( v40 < v39 )
  {
    v50 = *(_DWORD *)(v2 + 76) + 12 * v40;
    v51 = v39 - v40;
    do
    {
      v52 = *(float *)(v2 + 124) * *(float *)v50;
      v96 = *(float *)(v50 + 4) * *(float *)(v2 + 128) + v52;
      v75 = v96 + *(float *)(v50 + 8) * *(float *)(v2 + 132);
      if ( v75 <= v41 )
        v41 = v75;
      if ( v75 >= v42 )
        v42 = v75;
      v50 += 12;
      --v51;
    }
    while ( v51 );
  }
  v53 = 0;
  v97 = *(float *)(v2 + 124) * v41;
  v98 = *(float *)(v2 + 128) * v41;
  v99 = v41 * *(float *)(v2 + 132);
  v100 = v97 + *(float *)(v2 + 88);
  v101 = v98 + *(float *)(v2 + 92);
  v102 = v99 + *(float *)(v2 + 96);
  v103 = *(float *)(v2 + 124) * v42;
  v104 = *(float *)(v2 + 128) * v42;
  v105 = v42 * *(float *)(v2 + 132);
  v97 = v103 + *(float *)(v2 + 88);
  v98 = *(float *)(v2 + 92) + v104;
  v99 = v105 + *(float *)(v2 + 96);
  while ( v3 <= *(&v100 + v53) )
  {
    v55 = v3;
    v56 = v1;
    v57 = v55;
    if ( v56 < *(&v100 + v53) )
    {
      v58 = v56;
      v3 = v57;
      v1 = v58;
      break;
    }
    if ( (unsigned int)++v53 >= 3 )
      goto LABEL_79;
    v54 = v56;
    v3 = v57;
    v1 = v54;
  }
  v106 = v3;
  v107 = v3;
  v108 = v3;
  v109 = v1;
  v110 = v1;
  v111 = v1;
  v112 = v100;
  v113 = v101;
  v114 = v102;
  v115 = *(float *)(v2 + 124);
  v116 = *(float *)(v2 + 128);
  v117 = *(float *)(v2 + 132);
  if ( sub_10035FE0((int)&v112, (int)&v106, (int)&v103, &v96) == 1 )
  {
    v100 = v103;
    v101 = v104;
    v102 = v105;
  }
  v57 = 0.0;
  v56 = 1.0;
LABEL_79:
  v59 = 0;
  while ( 1 )
  {
    v60 = v56;
    v61 = v57;
    v62 = v60;
    if ( v61 > *(&v97 + v59) )
      break;
    v63 = v61;
    v56 = v62;
    v57 = v63;
    if ( v56 < *(&v97 + v59) )
    {
      v64 = v56;
      v61 = v57;
      v62 = v64;
      break;
    }
    if ( (unsigned int)++v59 >= 3 )
      return sub_10082300(v2, (int)&v100, (int)&v97) != 0;
  }
  v112 = v61;
  v113 = v61;
  v114 = v61;
  v115 = v62;
  v116 = v62;
  v117 = v62;
  v103 = -*(float *)(v2 + 124);
  v104 = -*(float *)(v2 + 128);
  v105 = -*(float *)(v2 + 132);
  v106 = v97;
  v107 = v98;
  v108 = v99;
  v109 = v103;
  v110 = v104;
  v111 = v105;
  if ( sub_10035FE0((int)&v106, (int)&v112, (int)&v103, &v96) == 1 )
  {
    v97 = v103;
    v98 = v104;
    v99 = v105;
  }
  return sub_10082300(v2, (int)&v100, (int)&v97) != 0;
}

//----- (10084780) --------------------------------------------------------
char __userpurge sub_10084780@<al>(int a1@<eax>, int a2, int a3)
{
  unsigned int v3; // esi@1
  bool v4; // al@4
  bool v5; // al@9
  unsigned int v6; // eax@11
  int v7; // eax@15
  char result; // al@16

  v3 = a1;
  sub_1007D8F0(a1);
  *(_DWORD *)v3 = a2;
  *(_DWORD *)(v3 + 4) = a3;
  *(_DWORD *)(v3 + 8) = 0;
  v4 = *(_DWORD *)(a2 + 28) != 1 || *(_DWORD *)(a2 + 32) != 1 || *(_DWORD *)(a2 + 36) != 1;
  *(_BYTE *)(v3 + 13) = v4;
  v5 = *(_BYTE *)(a2 + 22) && !v4 && !*(_BYTE *)(a2 + 23);
  *(_BYTE *)(v3 + 12) = v5;
  sub_1007D9A0(v3);
  *(_DWORD *)(v3 + 272) = 0;
  v6 = *(_DWORD *)(v3 + 280);
  if ( v6 )
  {
    if ( v6 <= 0 )
      memset((void *)(v6 + *(_DWORD *)(v3 + 276)), 0, -v6);
    *(_DWORD *)(v3 + 280) = 0;
  }
  *(_DWORD *)(v3 + 288) = -1;
  *(_DWORD *)(v3 + 292) = -1;
  *(_WORD *)(v3 + 296) = 0;
  v7 = *(_DWORD *)(v3 + 48);
  if ( v7 )
  {
    if ( v7 != 1 || *(_BYTE *)(v3 + 72) )
      result = sub_10083D40(v3) != 0;
    else
      result = sub_10080720(v3);
  }
  else
  {
    *(_WORD *)(*(_DWORD *)(v3 + 4) + 8) = 0;
    *(_WORD *)(*(_DWORD *)(v3 + 4) + 10) = 0;
    *(_BYTE *)(*(_DWORD *)(v3 + 4) + 16) = 1;
    memset(*(void **)(*(_DWORD *)(v3 + 4) + 12), 3, *(_DWORD *)(*(_DWORD *)v3 + 8));
    result = 1;
  }
  return result;
}

//----- (10084890) --------------------------------------------------------
char __stdcall sub_10084890(int a1)
{
  unsigned int v1; // edx@1
  int v2; // esi@1
  unsigned int v3; // ecx@1
  int v4; // eax@2
  const void *v5; // eax@10
  char *v6; // ecx@10
  unsigned int v7; // edi@10
  unsigned int v8; // esi@10
  const void *v9; // ebx@10
  size_t v10; // esi@11
  int v11; // ebx@12
  int v12; // eax@13
  unsigned int v13; // ecx@13
  const void *v14; // ecx@19
  unsigned int v15; // esi@19
  unsigned int v16; // ecx@19
  unsigned int v18; // eax@33
  unsigned int v19; // ebp@33
  unsigned int v20; // esi@33
  void *v21; // edi@34
  int v22; // eax@35
  unsigned int v23; // et0@35
  int v24; // esi@37
  void *v25; // eax@38
  FILE *v26; // eax@43
  FILE *v27; // eax@48
  void *v28; // [sp+14h] [bp-48Ch]@10
  unsigned int v29; // [sp+18h] [bp-488h]@10
  int v30; // [sp+1Ch] [bp-484h]@10
  int v31; // [sp+20h] [bp-480h]@21
  int v32; // [sp+24h] [bp-47Ch]@19
  unsigned int v33; // [sp+28h] [bp-478h]@19
  int v34; // [sp+2Ch] [bp-474h]@19
  int v35; // [sp+38h] [bp-468h]@1
  char v36; // [sp+3Ch] [bp-464h]@23
  int v37; // [sp+44h] [bp-45Ch]@33
  void *v38; // [sp+48h] [bp-458h]@19
  char v39[16]; // [sp+54h] [bp-44Ch]@33
  char v40; // [sp+64h] [bp-43Ch]@10
  char *v41; // [sp+68h] [bp-438h]@12
  char v42; // [sp+78h] [bp-428h]@12
  char DstBuf; // [sp+8Ch] [bp-414h]@43
  CHAR OutputString; // [sp+28Ch] [bp-214h]@48
  int v45; // [sp+49Ch] [bp-4h]@10

  v1 = *(_DWORD *)(a1 + 48);
  v2 = 0;
  v3 = 0;
  v35 = *(_DWORD *)(a1 + 4);
  if ( !v1 )
    return 1;
  v4 = *(_DWORD *)(a1 + 44);
  do
  {
    if ( *(_BYTE *)v4 <= 4u && *(_BYTE *)(v4 + 1) <= 4u && *(_BYTE *)(v4 + 2) <= 4u )
      ++v2;
    ++v3;
    v4 += 8;
  }
  while ( v3 < v1 );
  if ( !v2 || v2 == v1 )
    return 1;
  v5 = *(const void **)a1;
  qmemcpy(&v40, *(const void **)a1, 0x28u);
  v6 = 0;
  v7 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v45 = 0;
  v8 = *((_DWORD *)v5 + 2);
  v9 = (const void *)*((_DWORD *)v5 + 1);
  if ( v8 )
  {
    sub_100943C0(v8, 0, (int)&v28, 1, 4u, 0);
    v29 = v8;
    v10 = 4 * v8;
    memmove((char *)v28 + v10, v28, 0);
    memcpy(v28, v9, v10);
    v6 = (char *)v28;
    v7 = v29;
  }
  v11 = 0;
  v41 = v6;
  v42 = 1;
  if ( v7 )
  {
    v12 = (int)(v6 + 2);
    v13 = v7;
    do
    {
      if ( *(_BYTE *)(v12 - 2) <= 4u && *(_BYTE *)(v12 - 1) <= 4u && *(_BYTE *)v12 <= 4u )
        *(_BYTE *)(v12 + 1) = 0;
      v12 += 4;
      --v13;
    }
    while ( v13 );
  }
  v14 = *(const void **)a1;
  v38 = 0;
  v15 = *((_DWORD *)v14 + 2);
  v16 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  if ( v15 )
  {
    if ( v15 > 0 )
    {
      LOBYTE(v31) = v15 == 1;
      sub_100943C0(v15, 0, (int)&v32, v15 == 1, 1u, 0);
      v16 = v33;
      v11 = v32;
    }
    memset((void *)(v11 + v16), 0, v15 - v16);
    v33 = v15;
  }
  LOBYTE(v45) = 1;
  v38 = (void *)v11;
  if ( sub_10084780(a1, (int)&v40, (int)&v36) )
  {
    sub_10092630((int)v39, v37, HIWORD(v37));
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v33 = 0;
    if ( v7 )
    {
      v21 = v28;
      LOBYTE(v31) = *(_BYTE *)(a1 + 12);
      do
      {
        v22 = sub_10035010((int)v21, a1, (int)&v39[4 * *(_BYTE *)(v11 + v20)], v31);
        v23 = ((unsigned int)v22 + __PAIR__(v33, v19)) >> 32;
        v19 += v22;
        v33 = v23;
        ++v20;
        v21 = (char *)v21 + 4;
      }
      while ( v20 < v29 );
      v18 = v33;
    }
    v24 = v35;
    if ( __PAIR__(v18, v19) < *(_QWORD *)v35 )
    {
      *(_DWORD *)(v35 + 4) = v18;
      v25 = *(void **)(v24 + 12);
      *(_DWORD *)v24 = v19;
      *(_WORD *)(v24 + 8) = v37;
      *(_WORD *)(v24 + 10) = HIWORD(v37);
      if ( v25 )
        memcpy(v25, v38, *(_DWORD *)(*(_DWORD *)a1 + 8));
      *(_BYTE *)(v24 + 16) = 1;
    }
    LOBYTE(v45) = 0;
    if ( v11 )
    {
      if ( v11 & 7 )
      {
        sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&DstBuf);
        v26 = _iob_func();
        fputs(&DstBuf, v26 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v11, 0, 0, 1, dword_100AE9F4);
      }
    }
    v45 = -1;
    if ( v28 )
    {
      if ( (unsigned __int8)v28 & 7 )
      {
        sprintf_s(
          &OutputString,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_free: bad ptr");
        OutputDebugStringA(&OutputString);
        v27 = _iob_func();
        fputs(&OutputString, v27 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v28, 0, 0, 1, dword_100AE9F4);
      }
    }
    return 1;
  }
  LOBYTE(v45) = 0;
  if ( v11 )
  {
    if ( v11 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v11, 0, 0, 1, dword_100AE9F4);
  }
  v45 = -1;
  if ( v28 )
  {
    if ( (unsigned __int8)v28 & 7 )
    {
      sub_100927E0((int)"crnlib_free: bad ptr");
      return 0;
    }
    off_100AD9F4(v28, 0, 0, 1, dword_100AE9F4);
  }
  return 0;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 10084890: using guessed type char var_44C[16];

//----- (10084D30) --------------------------------------------------------
char __usercall sub_10084D30@<al>(int a1@<eax>)
{
  int v1; // ecx@1
  unsigned int v3; // ecx@4
  unsigned int v4; // ebp@4
  int v5; // edi@5
  int v6; // esi@7
  unsigned int v7; // eax@8
  unsigned int v8; // [sp+10h] [bp-4h]@4

  v1 = *(_DWORD *)(a1 + 60);
  if ( v1 )
  {
    if ( (unsigned int)(v1 - 1) <= 3 )
      return 1;
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 36);
    v4 = 0;
    v8 = v3;
    if ( v3 )
    {
      v5 = *(_DWORD *)(a1 + 12);
      while ( (*(_BYTE *)v5 | ((unsigned int)*(_BYTE *)(v5 + 1) << 8)) > (*(_BYTE *)(v5 + 2) | ((unsigned int)*(_BYTE *)(v5 + 3) << 8)) )
      {
LABEL_13:
        ++v4;
        v5 += 8;
        if ( v4 >= v3 )
          return 0;
      }
      v6 = 0;
LABEL_8:
      v7 = 0;
      while ( ((*(_BYTE *)(v5 + v6 + 4) >> v7) & 3) != 3 )
      {
        v7 += 2;
        if ( v7 >= 8 )
        {
          if ( (unsigned int)++v6 < 4 )
            goto LABEL_8;
          v3 = v8;
          goto LABEL_13;
        }
      }
      return 1;
    }
  }
  return 0;
}

//----- (10084DC0) --------------------------------------------------------
unsigned int __userpurge sub_10084DC0@<eax>(int a1@<esi>, int a2)
{
  unsigned int result; // eax@1
  unsigned int v3; // edx@2
  unsigned int v4; // ebp@3
  int v5; // eax@5
  int v6; // ecx@5
  int v7; // ebx@5
  int v8; // eax@5
  int v9; // edx@5
  int v10; // eax@5
  int v11; // edi@5
  int v12; // edx@5
  int *v13; // edi@5
  int v14; // ecx@13
  int v15; // ecx@13
  int v16; // eax@13
  unsigned int v17; // [sp+Ch] [bp-24h]@1
  int *v18; // [sp+10h] [bp-20h]@4
  signed int v19; // [sp+14h] [bp-1Ch]@5
  int v20; // [sp+18h] [bp-18h]@1
  int v21; // [sp+1Ch] [bp-14h]@5
  int v22; // [sp+20h] [bp-10h]@5
  int v23; // [sp+24h] [bp-Ch]@5
  int v24; // [sp+28h] [bp-8h]@5
  int v25; // [sp+2Ch] [bp-4h]@5

  result = *(_DWORD *)(a1 + 28) - a2 - 1;
  v20 = *(_DWORD *)(a1 + 28) - a2 - 1;
  v17 = 0;
  if ( *(_DWORD *)(a1 + 24) )
  {
    v3 = *(_DWORD *)(a1 + 40);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        v18 = (int *)(a1 + 52);
        do
        {
          v5 = *(_DWORD *)(a1 + 24);
          v6 = *(_DWORD *)(a1 + 12);
          v7 = v6 + 8 * (v4 + v3 * (v17 + a2 * v5));
          v8 = v4 + v3 * (v17 + v20 * v5);
          v9 = *(_DWORD *)(v6 + 8 * v8);
          v10 = *(_DWORD *)(v6 + 8 * v8 + 4);
          v22 = *(_DWORD *)v7;
          v11 = *(_DWORD *)(v7 + 4);
          v24 = v9;
          v12 = *v18;
          v23 = v11;
          v25 = v10;
          v21 = v12;
          v13 = &v22;
          v19 = 2;
          do
          {
            switch ( v21 )
            {
              case 1:
                sub_10034890((int)v13, v12, 4u);
                break;
              case 2:
                sub_10034B30((int)v13, 4u);
                break;
              case 3:
                sub_10034D70((int)v13, 4u);
                break;
            }
            v13 += 2;
            --v19;
          }
          while ( v19 );
          v14 = v25;
          *(_DWORD *)v7 = v24;
          *(_DWORD *)(v7 + 4) = v14;
          v15 = *(_DWORD *)(a1 + 12);
          ++v18;
          v16 = v4 + *(_DWORD *)(a1 + 40) * (v17 + v20 * *(_DWORD *)(a1 + 24));
          *(_DWORD *)(v15 + 8 * v16) = v22;
          *(_DWORD *)(v15 + 8 * v16 + 4) = v23;
          v3 = *(_DWORD *)(a1 + 40);
          ++v4;
        }
        while ( v4 < v3 );
      }
      result = v17 + 1;
      v17 = result;
    }
    while ( result < *(_DWORD *)(a1 + 24) );
  }
  return result;
}

//----- (10084EF0) --------------------------------------------------------
unsigned int __userpurge sub_10084EF0@<eax>(int a1@<ebx>, int a2)
{
  unsigned int result; // eax@1
  unsigned int v3; // edx@2
  unsigned int v4; // edi@3
  int v5; // eax@5
  int v6; // ecx@5
  int v7; // ebp@5
  int v8; // eax@5
  int v9; // edx@5
  int v10; // eax@5
  int v11; // esi@5
  int v12; // edx@5
  int *v13; // esi@5
  int v14; // ecx@13
  int v15; // ecx@13
  int v16; // eax@13
  unsigned int v17; // [sp+10h] [bp-28h]@1
  int *v18; // [sp+14h] [bp-24h]@4
  signed int v19; // [sp+18h] [bp-20h]@5
  int v20; // [sp+1Ch] [bp-1Ch]@1
  unsigned int v21; // [sp+20h] [bp-18h]@3
  int v22; // [sp+24h] [bp-14h]@5
  int v23; // [sp+28h] [bp-10h]@5
  int v24; // [sp+2Ch] [bp-Ch]@5
  int v25; // [sp+30h] [bp-8h]@5
  int v26; // [sp+34h] [bp-4h]@5

  result = *(_DWORD *)(a1 + 24) - a2 - 1;
  v20 = *(_DWORD *)(a1 + 24) - a2 - 1;
  v17 = 0;
  if ( *(_DWORD *)(a1 + 28) )
  {
    v3 = *(_DWORD *)(a1 + 40);
    do
    {
      v4 = 0;
      v21 = 0;
      if ( v3 )
      {
        v18 = (int *)(a1 + 52);
        do
        {
          v5 = v17 * *(_DWORD *)(a1 + 24);
          v6 = *(_DWORD *)(a1 + 12);
          v7 = v6 + 8 * (v4 + v3 * (v5 + a2));
          v8 = v4 + v3 * (v20 + v5);
          v9 = *(_DWORD *)(v6 + 8 * v8);
          v10 = *(_DWORD *)(v6 + 8 * v8 + 4);
          v23 = *(_DWORD *)v7;
          v11 = *(_DWORD *)(v7 + 4);
          v25 = v9;
          v12 = *v18;
          v24 = v11;
          v26 = v10;
          v22 = v12;
          v13 = &v23;
          v19 = 2;
          do
          {
            switch ( v22 )
            {
              case 1:
                sub_100346C0((int)v13, 4u);
                break;
              case 2:
                sub_100349A0((int)v13, 4u);
                break;
              case 3:
                sub_10034C20((int)v13, 4u);
                v4 = v21;
                break;
            }
            v13 += 2;
            --v19;
          }
          while ( v19 );
          v14 = v26;
          *(_DWORD *)v7 = v25;
          *(_DWORD *)(v7 + 4) = v14;
          v15 = *(_DWORD *)(a1 + 12);
          ++v18;
          v16 = v4 + *(_DWORD *)(a1 + 40) * (v20 + v17 * *(_DWORD *)(a1 + 24));
          *(_DWORD *)(v15 + 8 * v16) = v23;
          *(_DWORD *)(v15 + 8 * v16 + 4) = v24;
          v3 = *(_DWORD *)(a1 + 40);
          v21 = ++v4;
        }
        while ( v4 < v3 );
      }
      result = v17 + 1;
      v17 = result;
    }
    while ( result < *(_DWORD *)(a1 + 28) );
  }
  return result;
}

//----- (10085020) --------------------------------------------------------
int __usercall sub_10085020@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int result; // eax@6

  v1 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
  }
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 60) = -1;
  result = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_WORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10085090) --------------------------------------------------------
int __usercall sub_10085090@<eax>(int result@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  unsigned int v3; // eax@3
  unsigned int v4; // ebx@3

  v2 = result;
  if ( result != a2 )
  {
    sub_10085020(result);
    *(_DWORD *)(v2 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(v2 + 20) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(v2 + 24) = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(v2 + 28) = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(v2 + 40) = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(v2 + 44) = *(_DWORD *)(a2 + 44);
    *(_DWORD *)(v2 + 60) = *(_DWORD *)(a2 + 60);
    *(_DWORD *)(v2 + 32) = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(v2 + 36) = *(_DWORD *)(a2 + 36);
    *(_DWORD *)(v2 + 12) = 0;
    *(_DWORD *)(v2 + 52) = *(_DWORD *)(a2 + 52);
    *(_DWORD *)(v2 + 56) = *(_DWORD *)(a2 + 56);
    *(_WORD *)(v2 + 48) = *(_WORD *)(a2 + 48);
    if ( *(_DWORD *)(a2 + 12) )
    {
      v3 = *(_DWORD *)(v2 + 4);
      v4 = *(_DWORD *)(v2 + 36);
      if ( v4 != v3 )
      {
        if ( v4 >= v3 && v4 > *(_DWORD *)(v2 + 8) )
          sub_100943C0(v4, 0, v2, v4 == v3 + 1, 8u, 0);
        *(_DWORD *)(v2 + 4) = v4;
      }
      memcpy(*(void **)v2, *(const void **)(a2 + 12), 8 * *(_DWORD *)(v2 + 36));
      *(_DWORD *)(v2 + 12) = *(_DWORD *)v2;
    }
    result = v2;
  }
  return result;
}

//----- (100851E0) --------------------------------------------------------
char __usercall sub_100851E0@<al>(int a1@<eax>)
{
  int v1; // esi@1
  char result; // al@2
  unsigned int v3; // eax@3
  unsigned int v4; // edi@6
  unsigned int v5; // ebx@6
  unsigned int v6; // edi@11
  unsigned int v7; // eax@12
  unsigned int v8; // ebp@13
  int v9; // edx@15
  int v10; // eax@15
  int v11; // edx@15
  int v12; // ecx@15
  int v13; // ebx@15
  bool v14; // zf@15
  int v15; // eax@15
  int v16; // edx@15
  int v17; // eax@16
  int v18; // edx@21
  unsigned int v19; // [sp+10h] [bp-1Ch]@9
  _DWORD *v20; // [sp+14h] [bp-18h]@14
  unsigned int v21; // [sp+18h] [bp-14h]@11
  unsigned int v22; // [sp+1Ch] [bp-10h]@6
  int v23; // [sp+20h] [bp-Ch]@15
  int v24; // [sp+24h] [bp-8h]@15

  v1 = a1;
  if ( *(_DWORD *)(a1 + 60) == 7 || (v3 = *(_DWORD *)(a1 + 20), v3 & 3) && v3 > 4 )
  {
    result = 0;
  }
  else
  {
    if ( v3 != 1 )
    {
      v4 = *(_DWORD *)(v1 + 28) >> 1;
      v22 = v4;
      v5 = 0;
      if ( v4 )
      {
        do
          sub_10084DC0(v1, v5++);
        while ( v5 < v4 );
      }
      if ( *(_BYTE *)(v1 + 28) & 1 )
      {
        v19 = *(_DWORD *)(v1 + 20);
        if ( v19 >= 4 )
          v19 = 4;
        v6 = 0;
        v21 = 0;
        if ( *(_DWORD *)(v1 + 24) )
        {
          v7 = *(_DWORD *)(v1 + 40);
          do
          {
            v8 = 0;
            if ( v7 )
            {
              v20 = (_DWORD *)(v1 + 52);
              do
              {
                v9 = v7 * (v6 + v22 * *(_DWORD *)(v1 + 24));
                v10 = *(_DWORD *)(v1 + 12);
                v11 = v8 + v9;
                v12 = *(_DWORD *)(v10 + 8 * v11);
                v13 = v10 + 8 * v11;
                v15 = *v20 - 1;
                v14 = *v20 == 1;
                v16 = *(_DWORD *)(v13 + 4);
                v23 = v12;
                v24 = v16;
                if ( v14 )
                {
                  sub_10034890((int)&v23, v16, v19);
                }
                else
                {
                  v17 = v15 - 1;
                  if ( v17 )
                  {
                    if ( v17 == 1 )
                    {
                      sub_10034D70((int)&v23, v19);
                      v6 = v21;
                    }
                  }
                  else
                  {
                    sub_10034B30((int)&v23, v19);
                  }
                }
                v18 = v24;
                ++v20;
                *(_DWORD *)v13 = v23;
                *(_DWORD *)(v13 + 4) = v18;
                v7 = *(_DWORD *)(v1 + 40);
                ++v8;
              }
              while ( v8 < v7 );
            }
            v21 = ++v6;
          }
          while ( v6 < *(_DWORD *)(v1 + 24) );
        }
      }
    }
    result = 1;
  }
  return result;
}

//----- (10085310) --------------------------------------------------------
char __stdcall sub_10085310(int a1)
{
  int v1; // ebp@1
  char result; // al@2
  unsigned int v3; // eax@3
  unsigned int v4; // edi@6
  unsigned int v5; // esi@6
  unsigned int v6; // esi@9
  unsigned int v7; // eax@13
  unsigned int v8; // edi@14
  int v9; // edx@16
  int v10; // eax@16
  int v11; // edx@16
  int v12; // ecx@16
  int v13; // ebx@16
  bool v14; // zf@16
  int v15; // eax@16
  int v16; // edx@16
  int v17; // eax@17
  int v18; // eax@22
  _DWORD *v19; // [sp+10h] [bp-18h]@15
  unsigned int v20; // [sp+14h] [bp-14h]@12
  unsigned int v21; // [sp+18h] [bp-10h]@14
  unsigned int v22; // [sp+1Ch] [bp-Ch]@6
  int v23; // [sp+20h] [bp-8h]@16
  int v24; // [sp+24h] [bp-4h]@16
  signed int v25; // [sp+2Ch] [bp+4h]@10

  v1 = a1;
  if ( *(_DWORD *)(a1 + 60) == 7 || (v3 = *(_DWORD *)(a1 + 16), v3 & 3) && v3 > 4 )
  {
    result = 0;
  }
  else
  {
    if ( v3 != 1 )
    {
      v4 = *(_DWORD *)(a1 + 24) >> 1;
      v22 = v4;
      v5 = 0;
      if ( v4 )
      {
        do
          sub_10084EF0(a1, v5++);
        while ( v5 < v4 );
      }
      if ( *(_BYTE *)(a1 + 24) & 1 )
      {
        v6 = *(_DWORD *)(a1 + 16);
        if ( v6 >= 4 )
        {
          v25 = 4;
          v6 = 4;
        }
        else
        {
          v25 = *(_DWORD *)(a1 + 16);
        }
        v20 = 0;
        if ( *(_DWORD *)(v1 + 28) )
        {
          v7 = *(_DWORD *)(v1 + 40);
          do
          {
            v8 = 0;
            v21 = 0;
            if ( v7 )
            {
              v19 = (_DWORD *)(v1 + 52);
              do
              {
                v9 = v7 * (v22 + v20 * *(_DWORD *)(v1 + 24));
                v10 = *(_DWORD *)(v1 + 12);
                v11 = v8 + v9;
                v12 = *(_DWORD *)(v10 + 8 * v11);
                v13 = v10 + 8 * v11;
                v15 = *v19 - 1;
                v14 = *v19 == 1;
                v16 = *(_DWORD *)(v13 + 4);
                v23 = v12;
                v24 = v16;
                if ( v14 )
                {
                  sub_100346C0((int)&v23, v6);
                }
                else
                {
                  v17 = v15 - 1;
                  if ( v17 )
                  {
                    if ( v17 == 1 )
                    {
                      sub_10034C20((int)&v23, v6);
                      v6 = v25;
                      v8 = v21;
                    }
                  }
                  else
                  {
                    sub_100349A0((int)&v23, v6);
                    v6 = v25;
                  }
                }
                v18 = v24;
                ++v19;
                *(_DWORD *)v13 = v23;
                *(_DWORD *)(v13 + 4) = v18;
                v7 = *(_DWORD *)(v1 + 40);
                v21 = ++v8;
              }
              while ( v8 < v7 );
            }
            ++v20;
          }
          while ( v20 < *(_DWORD *)(v1 + 28) );
        }
      }
    }
    result = 1;
  }
  return result;
}

//----- (10085450) --------------------------------------------------------
char __userpurge sub_10085450@<al>(int a1@<eax>, int a2@<ecx>, int a3@<edi>, int a4)
{
  int v4; // esi@1
  int v5; // ebx@1
  unsigned int v6; // edx@1
  unsigned int v7; // ecx@1
  char result; // al@1
  int v9; // ecx@6
  int v10; // edx@6

  v4 = a2;
  v5 = a1;
  sub_10085020(a2);
  *(_DWORD *)(v4 + 20) = v5;
  *(_DWORD *)(v4 + 16) = a4;
  v6 = (unsigned int)(a4 + 3) >> 2;
  v7 = (unsigned int)(v5 + 3) >> 2;
  *(_DWORD *)(v4 + 24) = v6;
  *(_DWORD *)(v4 + 28) = v7;
  *(_DWORD *)(v4 + 40) = 2;
  result = 1;
  if ( !a3 || a3 == 1 || a3 == 4 || a3 == 7 )
    *(_DWORD *)(v4 + 40) = 1;
  v9 = v6 * v7;
  v10 = *(_DWORD *)(v4 + 40);
  *(_DWORD *)(v4 + 32) = v9;
  *(_DWORD *)(v4 + 36) = v10 * v9;
  *(_DWORD *)(v4 + 44) = 8 * v10;
  *(_DWORD *)(v4 + 60) = a3;
  switch ( a3 )
  {
    case 0:
    case 1:
      *(_DWORD *)(v4 + 52) = 1;
      *(_BYTE *)(v4 + 48) = -1;
      break;
    case 2:
      *(_DWORD *)(v4 + 52) = 2;
      *(_DWORD *)(v4 + 56) = 1;
      *(_WORD *)(v4 + 48) = -253;
      break;
    case 3:
      *(_DWORD *)(v4 + 52) = 3;
      *(_DWORD *)(v4 + 56) = 1;
      *(_WORD *)(v4 + 48) = -253;
      break;
    case 4:
      *(_DWORD *)(v4 + 52) = 3;
      *(_BYTE *)(v4 + 48) = 3;
      break;
    case 5:
      *(_DWORD *)(v4 + 52) = 3;
      *(_DWORD *)(v4 + 56) = 3;
      *(_WORD *)(v4 + 48) = 256;
      break;
    case 6:
      *(_DWORD *)(v4 + 52) = 3;
      *(_DWORD *)(v4 + 56) = 3;
      *(_WORD *)(v4 + 48) = 1;
      break;
    case 7:
      *(_DWORD *)(v4 + 52) = 4;
      *(_BYTE *)(v4 + 48) = -1;
      break;
    default:
      sub_10085020(v4);
      result = 0;
      break;
  }
  return result;
}

//----- (100855F0) --------------------------------------------------------
char __stdcall sub_100855F0(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  unsigned int v5; // eax@1
  int v6; // ebp@1
  unsigned int v7; // edx@1
  unsigned __int16 v8; // cx@6
  unsigned int v9; // ebx@9
  int v10; // eax@9
  unsigned int v11; // esi@10
  char v12; // cl@10
  char v13; // dl@10
  unsigned int v14; // edx@12
  unsigned int v15; // edx@14
  unsigned int v16; // edx@16
  unsigned int v17; // ecx@20
  unsigned int v18; // edi@20
  signed int v19; // eax@23
  _BYTE *v20; // edi@23
  unsigned int v21; // esi@24
  unsigned int v22; // edx@24
  int v23; // ecx@24
  unsigned int v24; // esi@26
  unsigned int v25; // edx@26
  int v26; // ecx@26
  unsigned int v27; // esi@28
  unsigned int v28; // edx@28
  unsigned int v29; // edx@30
  unsigned int v30; // esi@30
  unsigned int v31; // ecx@30
  int v32; // esi@34
  unsigned int v33; // edx@34
  _BYTE *v34; // esi@34
  unsigned int v35; // eax@35
  char result; // al@39
  unsigned __int16 v37; // [sp-8h] [bp-50h]@6
  char v38; // [sp+Fh] [bp-39h]@1
  unsigned int v39; // [sp+10h] [bp-38h]@1
  _DWORD *v40; // [sp+14h] [bp-34h]@2
  char v41; // [sp+18h] [bp-30h]@7
  char v42; // [sp+19h] [bp-2Fh]@10
  char v43; // [sp+1Ah] [bp-2Eh]@10
  char v44[13]; // [sp+1Bh] [bp-2Dh]@11
  char v45[32]; // [sp+28h] [bp-20h]@21

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 40);
  v6 = *(_DWORD *)(a1 + 12) + 8 * v5 * (a2 + a3 * *(_DWORD *)(a1 + 24));
  v7 = 0;
  v38 = 1;
  v39 = 0;
  if ( v5 )
  {
    v40 = (_DWORD *)(a1 + 52);
    do
    {
      switch ( *v40 )
      {
        case 4:
          if ( !sub_1008EAC0(
                  a4,
                  *(_DWORD *)(v4 + 12) + 8 * (v7 + v5 * (a2 + a3 * *(_DWORD *)(v4 + 24))),
                  *(_DWORD *)(v4 + 60) != 7) )
            v38 = 0;
          break;
        case 1:
          v8 = *(_BYTE *)v6 | (unsigned __int16)(*(_BYTE *)(v6 + 1) << 8);
          v37 = *(_BYTE *)(v6 + 2) | (unsigned __int16)(*(_BYTE *)(v6 + 3) << 8);
          if ( v8 <= v37 )
            sub_10092630((int)&v41, v8, v37);
          else
            sub_100924B0(v8, (int)&v41, v37);
          v9 = 0;
          v10 = a4 + 2;
          do
          {
            v11 = ((unsigned int)*(_BYTE *)((v9 >> 2) + v6 + 4) >> 2 * (v9 & 3)) & 3;
            v12 = *(&v42 + 4 * v11);
            *(_BYTE *)(v10 - 2) = *(&v41 + 4 * v11);
            v13 = *(&v43 + 4 * v11);
            *(_BYTE *)(v10 - 1) = v12;
            *(_BYTE *)v10 = v13;
            if ( *(_DWORD *)(a1 + 60) <= 1 )
              *(_BYTE *)(v10 + 1) = v44[4 * v11];
            v14 = ((unsigned int)*(_BYTE *)(((v9 + 1) >> 2) + v6 + 4) >> 2 * ((v9 + 1) & 3)) & 3;
            *(_BYTE *)(v10 + 2) = *(&v41 + 4 * v14);
            *(_BYTE *)(v10 + 3) = *(&v42 + 4 * v14);
            *(_BYTE *)(v10 + 4) = *(&v43 + 4 * v14);
            if ( *(_DWORD *)(a1 + 60) <= 1 )
              *(_BYTE *)(v10 + 5) = v44[4 * v14];
            v15 = ((unsigned int)*(_BYTE *)(((v9 + 2) >> 2) + v6 + 4) >> 2 * ((v9 - 2) & 3)) & 3;
            *(_BYTE *)(v10 + 6) = *(&v41 + 4 * v15);
            *(_BYTE *)(v10 + 7) = *(&v42 + 4 * v15);
            *(_BYTE *)(v10 + 8) = *(&v43 + 4 * v15);
            if ( *(_DWORD *)(a1 + 60) <= 1 )
              *(_BYTE *)(v10 + 9) = v44[4 * v15];
            v16 = ((unsigned int)*(_BYTE *)(((v9 + 3) >> 2) + v6 + 4) >> 2 * ((v9 - 1) & 3)) & 3;
            *(_BYTE *)(v10 + 10) = *(&v41 + 4 * v16);
            *(_BYTE *)(v10 + 11) = *(&v42 + 4 * v16);
            *(_BYTE *)(v10 + 12) = *(&v43 + 4 * v16);
            if ( *(_DWORD *)(a1 + 60) <= 1 )
              *(_BYTE *)(v10 + 13) = v44[4 * v16];
            v9 += 4;
            v10 += 16;
          }
          while ( v9 < 0x10 );
          v4 = a1;
          break;
        case 3:
          v17 = *(_BYTE *)(v6 + 1);
          v18 = *(_BYTE *)v6;
          if ( v18 <= v17 )
            sub_10092230((int)v45, v18, *(_BYTE *)(v6 + 1));
          else
            sub_10092180(v17, (int)v45, *(_BYTE *)v6);
          v19 = 1;
          v20 = (_BYTE *)(*(_BYTE *)(v39 + v4 + 48) + a4 + 8);
          do
          {
            v21 = (unsigned int)(3 * (v19 - 1)) >> 3;
            v22 = *(_BYTE *)(v21 + v6 + 2);
            v23 = 3 * (v19 - 1) & 7;
            if ( v21 < 5 )
              v22 |= *(_BYTE *)(v21 + v6 + 3) << 8;
            *(v20 - 8) = v45[4 * ((v22 >> v23) & 7)];
            v24 = (unsigned int)(3 * v19) >> 3;
            v25 = *(_BYTE *)(v24 + v6 + 2);
            v26 = 3 * v19 & 7;
            if ( v24 < 5 )
              v25 |= *(_BYTE *)(v24 + v6 + 3) << 8;
            *(v20 - 4) = v45[4 * ((v25 >> v26) & 7)];
            v27 = (unsigned int)(3 * (v19 + 1)) >> 3;
            v28 = *(_BYTE *)(v27 + v6 + 2);
            if ( v27 < 5 )
              v28 |= *(_BYTE *)(v27 + v6 + 3) << 8;
            *v20 = v45[4 * ((v28 >> (3 * (v19 + 1) & 7)) & 7)];
            v29 = 3 * ((((_BYTE)v19 - 2) & 3) + 4 * ((unsigned int)(v19 + 2) >> 2)) >> 3;
            v30 = *(_BYTE *)(v29 + v6 + 2);
            v31 = 3 * ((((_BYTE)v19 - 2) & 3) + 4 * ((unsigned int)(v19 + 2) >> 2)) & 7;
            if ( v29 < 5 )
              v30 |= *(_BYTE *)(v29 + v6 + 3) << 8;
            v19 += 4;
            v20 += 16;
            *(v20 - 12) = v45[4 * ((v30 >> v31) & 7)];
          }
          while ( (unsigned int)(v19 - 1) < 0x10 );
          break;
        case 2:
          v32 = *(_BYTE *)(v7 + v4 + 48);
          v33 = 0;
          v34 = (_BYTE *)(a4 + v32);
          do
          {
            v35 = *(_BYTE *)(((v33 & 3) >> 1) + v6 + ((v33 >> 1) & 0x7FFFFFFE));
            if ( v33 & 1 )
              v35 >>= 4;
            *v34 = 16 * (v35 & 0xF) | v35 & 0xF;
            ++v33;
            v34 += 4;
          }
          while ( v33 < 0x10 );
          break;
        default:
          break;
      }
      v5 = *(_DWORD *)(v4 + 40);
      ++v40;
      v7 = v39 + 1;
      v6 += 8;
      v39 = v7;
    }
    while ( v7 < v5 );
    result = v38;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100855F0: using guessed type char var_2D[13];
// 100855F0: using guessed type char var_20[32];

//----- (100859B0) --------------------------------------------------------
char __userpurge sub_100859B0@<al>(int a1@<edi>, int a2)
{
  int v2; // esi@1
  char result; // al@2
  char *v4; // eax@3
  unsigned int v5; // ecx@3
  unsigned int v6; // ebx@9
  unsigned int v7; // edx@15
  unsigned int v8; // ebp@17
  char *v9; // eax@18
  unsigned int v10; // esi@19
  int v11; // ecx@20
  _BYTE *v12; // edx@30
  char v13; // [sp+Fh] [bp-59h]@5
  unsigned int v14; // [sp+10h] [bp-58h]@12
  int v15; // [sp+14h] [bp-54h]@6
  unsigned int v16; // [sp+18h] [bp-50h]@11
  int v17; // [sp+1Ch] [bp-4Ch]@5
  int v18; // [sp+20h] [bp-48h]@9
  char *v19; // [sp+24h] [bp-44h]@18
  char v20; // [sp+28h] [bp-40h]@13
  char v21; // [sp+2Ah] [bp-3Eh]@3

  v2 = a2;
  if ( *(_DWORD *)(a2 + 36) )
  {
    sub_10034090(a1, *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 20), -16777216);
    v4 = &v21;
    v5 = 16;
    do
    {
      *(_DWORD *)(v4 - 2) = -16777216;
      v4 += 4;
      --v5;
    }
    while ( v5 );
    v13 = 1;
    v17 = 0;
    if ( *(_DWORD *)(a2 + 28) > 0u )
    {
      v15 = 0;
      while ( 1 )
      {
        if ( (unsigned int)(*(_DWORD *)(a1 + 4) - v15) <= 4 )
        {
          v6 = *(_DWORD *)(a1 + 4) - v15;
          v18 = *(_DWORD *)(a1 + 4) - v15;
        }
        else
        {
          v6 = 4;
          v18 = 4;
        }
        v16 = v5;
        if ( *(_DWORD *)(v2 + 24) > v5 )
        {
          v14 = v5;
          do
          {
            if ( !sub_100855F0(v2, v16, v17, (int)&v20) )
              v13 = 0;
            v7 = *(_DWORD *)a1 - v14;
            if ( v7 > 4 )
              v7 = 4;
            v8 = 0;
            if ( v6 )
            {
              v9 = &v21;
              v19 = &v21;
              do
              {
                v10 = 0;
                if ( v7 )
                {
                  do
                  {
                    v9 += 4;
                    v11 = *(_DWORD *)(a1 + 20) + 4 * (v10 + v14 + *(_DWORD *)(a1 + 8) * (v8 + v15));
                    *(_BYTE *)v11 = *(v9 - 6);
                    *(_BYTE *)(v11 + 1) = *(v9 - 5);
                    *(_BYTE *)(v11 + 2) = *(v9 - 4);
                    ++v10;
                    *(_BYTE *)(v11 + 3) = *(v9 - 3);
                  }
                  while ( v10 < v7 );
                  v6 = v18;
                }
                ++v8;
                v9 = v19 + 16;
                v19 += 16;
              }
              while ( v8 < v6 );
              v2 = a2;
            }
            v14 += 4;
            ++v16;
          }
          while ( v16 < *(_DWORD *)(v2 + 24) );
        }
        v15 += 4;
        if ( (unsigned int)++v17 >= *(_DWORD *)(v2 + 28) )
          break;
        v5 = 0;
      }
      if ( !v13 )
        sub_10094320("dxt_image::unpack: One or more invalid blocks encountered!");
      v5 = 0;
    }
    *(_DWORD *)(a1 + 16) = 15;
    *(_DWORD *)(a1 + 16) &= 0xFFFFFFF8;
    if ( *(_DWORD *)(v2 + 40) > v5 )
    {
      v12 = (_BYTE *)(v2 + 48);
      do
      {
        if ( *v12 >= 0 )
        {
          *(_DWORD *)(a1 + 16) |= 1 << *v12;
        }
        else
        {
          *(_DWORD *)(a1 + 16) |= 1u;
          *(_DWORD *)(a1 + 16) |= 2u;
          *(_DWORD *)(a1 + 16) |= 4u;
        }
        ++v12;
      }
      while ( (unsigned int)&v12[-48 - v2] < *(_DWORD *)(v2 + 40) );
    }
    if ( (unsigned int)(*(_DWORD *)(v2 + 60) - 1) > 3 )
    {
      *(_DWORD *)(a1 + 16) &= 0xFFFFFFF7;
      result = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 16) |= 8u;
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10085BA0) --------------------------------------------------------
char __stdcall sub_10085BA0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ebx@1
  unsigned int v7; // eax@1
  int v8; // ebp@1
  int v9; // esi@1
  signed int v10; // eax@2
  int *v11; // ecx@2
  int v12; // edi@7
  int v13; // ecx@7
  unsigned int v14; // ecx@11
  int v15; // eax@11
  int *v16; // ebx@12
  unsigned int v17; // ebp@23
  unsigned int v18; // edi@29
  _BYTE *v19; // ebx@29
  unsigned int v20; // ebp@30
  unsigned int v21; // ebp@30
  unsigned int v22; // edx@30
  unsigned int v23; // ebp@30
  int *v24; // ecx@35
  int v25; // eax@40
  int v26; // ecx@40
  char v27; // dl@40
  char v28; // dl@41
  int v29; // eax@41
  unsigned int v30; // ebp@41
  char v31; // cl@43
  unsigned int v32; // eax@43
  int v33; // ebx@43
  char v34; // cl@43
  int v35; // edx@45
  unsigned int v36; // eax@47
  int v37; // ebx@47
  int v38; // ecx@47
  int v39; // edx@49
  unsigned int v40; // eax@51
  int v41; // ebx@51
  int v42; // ecx@51
  int v43; // edx@53
  unsigned int v44; // eax@55
  int v45; // ebx@55
  int v46; // ecx@57
  int v47; // edx@57
  unsigned int v48; // edi@61
  _BYTE *v49; // ebx@61
  unsigned int v50; // ebp@62
  unsigned int v51; // ebp@62
  unsigned int v52; // edx@62
  unsigned int v53; // ebp@62
  char v54; // al@64
  unsigned int v55; // eax@65
  _BYTE *v56; // ecx@65
  int v57; // ecx@70
  char v58; // al@70
  int v59; // edx@70
  char v60; // al@70
  int v61; // edx@70
  int v62; // eax@70
  int v63; // edx@70
  int v64; // edx@70
  int v65; // eax@75
  char v66; // ah@79
  char v67; // ah@79
  unsigned int v68; // ebp@79
  signed int v69; // edi@79
  char v70; // bl@80
  char v71; // dl@80
  char v72; // bl@80
  unsigned int v73; // eax@80
  char v74; // dl@80
  char v75; // bl@80
  char v76; // cl@80
  int v78; // [sp+14h] [bp-98h]@41
  unsigned int v79; // [sp+18h] [bp-94h]@23
  unsigned int v80; // [sp+18h] [bp-94h]@41
  _DWORD *v81; // [sp+1Ch] [bp-90h]@24
  unsigned int v82; // [sp+1Ch] [bp-90h]@41
  char *v83; // [sp+20h] [bp-8Ch]@11
  _DWORD *v84; // [sp+20h] [bp-8Ch]@36
  int *v85; // [sp+28h] [bp-84h]@6
  char v86; // [sp+2Ch] [bp-80h]@6
  int v87; // [sp+30h] [bp-7Ch]@11
  int v88; // [sp+34h] [bp-78h]@40
  int v89; // [sp+38h] [bp-74h]@40
  int v90; // [sp+3Ch] [bp-70h]@40
  int v91; // [sp+40h] [bp-6Ch]@40
  char v92; // [sp+44h] [bp-68h]@40
  char v93; // [sp+45h] [bp-67h]@70
  char v94; // [sp+46h] [bp-66h]@70
  char v95; // [sp+47h] [bp-65h]@70
  char v96; // [sp+48h] [bp-64h]@70
  char v97; // [sp+49h] [bp-63h]@70
  char v98; // [sp+4Ah] [bp-62h]@70
  int v99; // [sp+4Ch] [bp-60h]@70
  int v100; // [sp+50h] [bp-5Ch]@70
  int v101; // [sp+54h] [bp-58h]@70
  char *v102; // [sp+70h] [bp-3Ch]@40
  int v103; // [sp+78h] [bp-34h]@79
  char *v104; // [sp+7Ch] [bp-30h]@70
  char v105; // [sp+80h] [bp-2Ch]@41
  char v106; // [sp+81h] [bp-2Bh]@41
  char v107; // [sp+87h] [bp-25h]@45
  char v108[16]; // [sp+88h] [bp-24h]@40
  char v109[16]; // [sp+97h] [bp-15h]@80
  char v110[4]; // [sp+98h] [bp-14h]@70
  char v111; // [sp+9Ch] [bp-10h]@80
  char v112[15]; // [sp+9Dh] [bp-Fh]@80

  v6 = a1;
  v7 = *(_DWORD *)(a1 + 40);
  v8 = *(_DWORD *)(a1 + 60);
  v9 = *(_DWORD *)(a1 + 12) + 8 * v7 * (a2 + a3 * *(_DWORD *)(a1 + 24));
  if ( v8 == 7 )
  {
    v10 = *(_DWORD *)(a5 + 8);
    v11 = (int *)2;
    if ( v10 > 1 )
    {
      if ( v10 <= 2 )
        v11 = (int *)1;
    }
    else
    {
      v11 = 0;
    }
    v86 = *(_BYTE *)(a5 + 17);
    v85 = v11;
    LOBYTE(v7) = sub_1008E180((int)&v85, (int *)a4, v9);
    return v7;
  }
  v12 = a5;
  v13 = *(_DWORD *)(a5 + 12);
  if ( v13 == 2 && (!v8 || v8 == 3 || v8 == 4) )
  {
    v85 = (int *)((char *)&v87 + -a4 + 1);
    v14 = 0;
    v15 = a4 + 1;
    v83 = (char *)&v87 + -a4 + 2;
    do
    {
      v16 = v85;
      *((_BYTE *)&v87 + 4 * v14) = *(_BYTE *)(v15 + 1);
      *((_BYTE *)&v87 + v15 - a4) = *(_BYTE *)v15;
      *((_BYTE *)v16 + v15) = *(_BYTE *)(v15 - 1);
      if ( v8 )
        v83[v15] = *(_BYTE *)(v15 + 2);
      else
        v83[v15] = -1;
      ++v14;
      v15 += 4;
    }
    while ( v14 < 0x10 );
    if ( v8 == 4 )
    {
      LOBYTE(v7) = sub_1008F630((int)&v87, v9);
    }
    else
    {
      if ( v8 == 3 )
      {
        sub_1008F630((int)&v87, v9);
        v9 += 8;
      }
      LOBYTE(v7) = sub_10090D20(v9, (int)&v87);
    }
    return v7;
  }
  if ( v13 != 1 || v8 == 1 )
  {
    v24 = 0;
    v85 = 0;
    if ( !v7 )
      return v7;
    v84 = (_DWORD *)(a1 + 52);
    while ( 1 )
    {
      if ( *v84 == 1 )
      {
        v54 = 0;
        if ( *(_DWORD *)(v6 + 60) == 1 )
        {
          v55 = 0;
          v56 = (_BYTE *)(a4 + 3);
          while ( (unsigned int)*v56 >= *(_DWORD *)v12 )
          {
            ++v55;
            v56 += 4;
            if ( v55 >= 0x10 )
            {
              v54 = 0;
              goto LABEL_70;
            }
          }
          v54 = 1;
        }
LABEL_70:
        v57 = a2 + a3 * *(_DWORD *)(v6 + 24);
        v92 = v54;
        v58 = *(_BYTE *)(v12 + 19);
        v104 = v110;
        v59 = *(_DWORD *)(v12 + 8);
        v87 = v57;
        LOBYTE(v57) = *(_BYTE *)(v12 + 16);
        v91 = v59;
        LOBYTE(v59) = *(_BYTE *)(v12 + 18);
        v93 = v58;
        v60 = *(_BYTE *)(v12 + 20);
        v95 = v59;
        v61 = *(_DWORD *)v12;
        v94 = v57;
        LOBYTE(v57) = *(_BYTE *)(v12 + 21);
        v96 = v60;
        v62 = *(_DWORD *)(v12 + 48);
        v90 = v61;
        v63 = *(_DWORD *)(v12 + 44);
        v100 = v62;
        v7 = *(_DWORD *)(v6 + 60);
        v97 = v57;
        v99 = v63;
        v64 = *(_DWORD *)(v12 + 52);
        v98 = 0;
        v88 = a4;
        v89 = 16;
        v101 = v64;
        if ( v7 && v7 != 1 )
          v93 = 0;
        if ( !a4 )
          goto LABEL_82;
        LOBYTE(v7) = sub_10084780(a6, (int)&v87, (int)&v102);
        if ( !(_BYTE)v7 )
          goto LABEL_82;
        v65 = *(_DWORD *)a6;
        if ( *(_BYTE *)(*(_DWORD *)a6 + 21) )
        {
          if ( *(_BYTE *)(v65 + 25) )
          {
            if ( !*(_BYTE *)(v65 + 20) )
            {
              LOBYTE(v7) = sub_10084890(a6);
              if ( !(_BYTE)v7 )
                goto LABEL_82;
            }
          }
        }
        v66 = BYTE1(v103);
        *(_BYTE *)v9 = v103;
        *(_BYTE *)(v9 + 1) = v66;
        v67 = BYTE3(v103);
        *(_BYTE *)(v9 + 2) = BYTE2(v103);
        *(_BYTE *)(v9 + 3) = v67;
        v68 = 1;
        v69 = -2;
        do
        {
          v70 = v110[v68];
          *(_BYTE *)(v9 + ((unsigned int)(v69 + 2) >> 2) + 4) = (v109[v68] << 2 * ((v69 + 2) & 3)) | *(_BYTE *)(v9 + ((unsigned int)(v69 + 2) >> 2) + 4) & ~(3 << 2 * ((v69 + 2) & 3));
          v71 = (v70 << 2 * (v68 & 3)) | *(_BYTE *)(v9 + (v68 >> 2) + 4) & ~(3 << 2 * (v68 & 3));
          v72 = *(&v111 + v69);
          *(_BYTE *)(v9 + (v68 >> 2) + 4) = v71;
          v73 = (unsigned int)(v69 + 4) >> 2;
          v74 = (v72 << 2 * (v69 & 3)) | *(_BYTE *)(v9 + v73 + 4) & ~(3 << 2 * (v69 & 3));
          v75 = v112[v69];
          *(_BYTE *)(v9 + v73 + 4) = v74;
          v76 = 2 * ((v69 + 1) & 3);
          v7 = v69 + 5;
          v69 += 4;
          v68 += 4;
          *(_BYTE *)(v9 + (v7 >> 2) + 4) = (v75 << v76) | *(_BYTE *)(v9 + (v7 >> 2) + 4) & ~(3 << v76);
          LOBYTE(v7) = v69 + 2;
        }
        while ( (unsigned int)(v69 + 2) < 0x10 );
      }
      else if ( *v84 == 2 )
      {
        v48 = 1;
        v49 = (_BYTE *)(*((_BYTE *)v24 + v6 + 48) + a4 + 8);
        do
        {
          *(_BYTE *)(((((_BYTE)v48 - 1) & 3u) >> 1) + (((v48 - 1) >> 1) & 0x7FFFFFFE) + v9) = ((unsigned __int8)((15 * (unsigned int)*(v49 - 8) + 128) / 0xFF) << 4 * ((v48 - 1) & 1)) | *(_BYTE *)(((((_BYTE)v48 - 1) & 3u) >> 1) + (((v48 - 1) >> 1) & 0x7FFFFFFE) + v9) & ~(15 << 4 * ((v48 - 1) & 1));
          v50 = ((v48 & 3) >> 1) + ((v48 >> 1) & 0x7FFFFFFE);
          *(_BYTE *)(v9 + v50) = ((unsigned __int8)((15 * (unsigned int)*(v49 - 4) + 128) / 0xFF) << 4 * (v48 & 1)) | *(_BYTE *)(v9 + v50) & ~(15 << 4 * (v48 & 1));
          v51 = ((((_BYTE)v48 + 1) & 3u) >> 1) + (((v48 + 1) >> 1) & 0x7FFFFFFE);
          v52 = (15 * (unsigned int)*v49 + 128) / 0xFF;
          v49 += 16;
          *(_BYTE *)(v9 + v51) = ((_BYTE)v52 << 4 * ((v48 + 1) & 1)) | *(_BYTE *)(v9 + v51) & ~(15 << 4 * ((v48 + 1) & 1));
          v53 = ((((_BYTE)v48 - 2) & 3u) >> 1) + (((v48 + 2) >> 1) & 0x7FFFFFFE);
          LOBYTE(v7) = 15 << 4 * ((v48 - 2) & 1);
          LOBYTE(v52) = (unsigned __int8)((15 * (unsigned int)*(v49 - 12) + 128) / 0xFF) << 4 * ((v48 - 2) & 1);
          v48 += 4;
          LOBYTE(v7) = v52 | *(_BYTE *)(v9 + v53) & ~(_BYTE)v7;
          *(_BYTE *)(v9 + v53) = v7;
        }
        while ( v48 - 1 < 0x10 );
      }
      else
      {
        v7 = *v84 - 3;
        if ( *v84 != 3 )
          goto LABEL_82;
        v87 = a2 + a3 * *(_DWORD *)(v6 + 24);
        v25 = *((_BYTE *)v24 + v6 + 48);
        v26 = *(_DWORD *)(v12 + 8);
        v90 = v25;
        v102 = v108;
        v91 = v26;
        v88 = a4;
        v27 = *(_BYTE *)(v12 + 19);
        v89 = 16;
        v92 = v27;
        LOBYTE(v7) = sub_10093A30(a6 + 336, (int)&v87, (int)&v102);
        if ( !(_BYTE)v7 )
          goto LABEL_82;
        v28 = v105;
        *(_BYTE *)(v9 + 1) = v106;
        v29 = 0;
        *(_BYTE *)v9 = v28;
        v78 = 0;
        v82 = 3;
        v80 = 2;
        v30 = 1;
        while ( 1 )
        {
          v31 = 3 * v29;
          v32 = (unsigned int)(3 * v29) >> 3;
          v33 = *(_BYTE *)(v32 + v9 + 2);
          v34 = v31 & 7;
          if ( v32 < 5 )
            v33 |= *(_BYTE *)(v32 + v9 + 3) << 8;
          v35 = ((unsigned __int8)*(&v107 + v30) << v34) | v33 & ~(7 << v34);
          *(_BYTE *)(v32 + v9 + 2) = v35;
          if ( v32 < 5 )
            *(_BYTE *)(v32 + v9 + 3) = BYTE1(v35);
          v36 = 3 * v30 >> 3;
          v37 = *(_BYTE *)(v36 + v9 + 2);
          v38 = 3 * v30 & 7;
          if ( v36 < 5 )
            v37 |= *(_BYTE *)(v36 + v9 + 3) << 8;
          v39 = ((unsigned __int8)v108[v30] << v38) | v37 & ~(7 << v38);
          *(_BYTE *)(v36 + v9 + 2) = v39;
          if ( v36 < 5 )
            *(_BYTE *)(v36 + v9 + 3) = BYTE1(v39);
          v40 = 3 * ((((_BYTE)v82 - 1) & 3) + 4 * (v80 >> 2)) >> 3;
          v41 = *(_BYTE *)(v40 + v9 + 2);
          v42 = 3 * ((((_BYTE)v82 - 1) & 3) + 4 * (v80 >> 2)) & 7;
          if ( v40 < 5 )
            v41 |= *(_BYTE *)(v40 + v9 + 3) << 8;
          v43 = ((unsigned __int8)v108[v80] << v42) | v41 & ~(7 << v42);
          *(_BYTE *)(v40 + v9 + 2) = v43;
          if ( v40 < 5 )
            *(_BYTE *)(v40 + v9 + 3) = BYTE1(v43);
          v44 = 3 * ((((_BYTE)v78 - 1) & 3) + 4 * (v82 >> 2)) >> 3;
          v45 = *(_BYTE *)(v44 + v9 + 2);
          if ( v44 < 5 )
            v45 |= *(_BYTE *)(v44 + v9 + 3) << 8;
          v46 = 3 * ((((_BYTE)v78 - 1) & 3) + 4 * (v82 >> 2)) & 7;
          v47 = ((unsigned __int8)v108[v82] << v46) | v45 & ~(7 << v46);
          *(_BYTE *)(v44 + v9 + 2) = v47;
          if ( v44 < 5 )
            *(_BYTE *)(v44 + v9 + 3) = BYTE1(v47);
          LOBYTE(v7) = 4;
          v78 += 4;
          v80 += 4;
          v82 += 4;
          v30 += 4;
          if ( v30 >= 0x11 )
            break;
          v29 = v78;
        }
      }
      v12 = a5;
      v6 = a1;
LABEL_82:
      ++v84;
      v24 = (int *)((char *)v85 + 1);
      v9 += 8;
      v85 = v24;
      if ( (unsigned int)v24 >= *(_DWORD *)(v6 + 40) )
        return v7;
    }
  }
  v17 = 0;
  v79 = 0;
  if ( v7 )
  {
    v81 = (_DWORD *)(a1 + 52);
    do
    {
      if ( *v81 == 1 )
      {
        LOBYTE(v7) = sub_1006B1B0(*(_DWORD *)(v12 + 8) >= 2, a4, v9);
      }
      else if ( *v81 == 2 )
      {
        v18 = 1;
        v19 = (_BYTE *)(*(_BYTE *)(v6 + v17 + 48) + a4 + 8);
        do
        {
          *(_BYTE *)(((((_BYTE)v18 - 1) & 3u) >> 1) + (((v18 - 1) >> 1) & 0x7FFFFFFE) + v9) = ((unsigned __int8)((15 * (unsigned int)*(v19 - 8) + 128) / 0xFF) << 4 * ((v18 - 1) & 1)) | *(_BYTE *)(((((_BYTE)v18 - 1) & 3u) >> 1) + (((v18 - 1) >> 1) & 0x7FFFFFFE) + v9) & ~(15 << 4 * ((v18 - 1) & 1));
          v20 = ((v18 & 3) >> 1) + ((v18 >> 1) & 0x7FFFFFFE);
          *(_BYTE *)(v9 + v20) = ((unsigned __int8)((15 * (unsigned int)*(v19 - 4) + 128) / 0xFF) << 4 * (v18 & 1)) | *(_BYTE *)(v9 + v20) & ~(15 << 4 * (v18 & 1));
          v21 = ((((_BYTE)v18 + 1) & 3u) >> 1) + (((v18 + 1) >> 1) & 0x7FFFFFFE);
          v22 = (15 * (unsigned int)*v19 + 128) / 0xFF;
          v19 += 16;
          *(_BYTE *)(v9 + v21) = ((_BYTE)v22 << 4 * ((v18 + 1) & 1)) | *(_BYTE *)(v9 + v21) & ~(15 << 4 * ((v18 + 1) & 1));
          v23 = ((((_BYTE)v18 - 2) & 3u) >> 1) + (((v18 + 2) >> 1) & 0x7FFFFFFE);
          LOBYTE(v7) = 15 << 4 * ((v18 - 2) & 1);
          LOBYTE(v22) = (unsigned __int8)((15 * (unsigned int)*(v19 - 12) + 128) / 0xFF) << 4 * ((v18 - 2) & 1);
          v18 += 4;
          LOBYTE(v7) = v22 | *(_BYTE *)(v9 + v23) & ~(_BYTE)v7;
          *(_BYTE *)(v9 + v23) = v7;
        }
        while ( v18 - 1 < 0x10 );
        v17 = v79;
        v12 = a5;
        v6 = a1;
      }
      else
      {
        v7 = *v81 - 3;
        if ( *v81 == 3 )
          LOBYTE(v7) = sub_10069B00(v9, a4, *(_BYTE *)(v6 + v17 + 48));
      }
      ++v81;
      ++v17;
      v9 += 8;
      v79 = v17;
    }
    while ( v17 < *(_DWORD *)(v6 + 40) );
  }
  return v7;
}
// 10085BA0: using guessed type char var_24[16];
// 10085BA0: using guessed type char var_14[4];
// 10085BA0: using guessed type char var_F[15];

//----- (100864E0) --------------------------------------------------------
void __thiscall sub_100864E0(_DWORD *this, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // edi@1
  _DWORD *v6; // ebx@1
  unsigned int v7; // eax@14
  int v8; // eax@16
  int v9; // eax@18
  int v10; // ebx@18
  int v11; // edx@18
  int v12; // edi@18
  unsigned int v13; // edx@18
  unsigned int v14; // ebx@18
  unsigned int v15; // ecx@18
  char *v16; // eax@18
  unsigned int v17; // esi@20
  int v18; // edx@22
  int v19; // ecx@24
  int v20; // esi@24
  int v21; // edx@24
  int v22; // esi@26
  unsigned int v23; // edx@26
  int v24; // esi@28
  int v25; // edx@28
  int v26; // ecx@30
  char v27; // dl@30
  int v28; // ecx@30
  char *v29; // [sp-4h] [bp-6F4h]@6
  char v30; // [sp+13h] [bp-6DDh]@2
  unsigned int v31; // [sp+14h] [bp-6DCh]@9
  unsigned int v32; // [sp+18h] [bp-6D8h]@4
  int v33; // [sp+1Ch] [bp-6D4h]@4
  int v34; // [sp+20h] [bp-6D0h]@18
  int v35; // [sp+24h] [bp-6CCh]@8
  signed int v36; // [sp+28h] [bp-6C8h]@18
  int v37; // [sp+2Ch] [bp-6C4h]@1
  unsigned int v38; // [sp+30h] [bp-6C0h]@4
  int v39; // [sp+34h] [bp-6BCh]@1
  int v40; // [sp+38h] [bp-6B8h]@18
  int v41; // [sp+3Ch] [bp-6B4h]@1
  unsigned int v42; // [sp+40h] [bp-6B0h]@18
  int v43; // [sp+44h] [bp-6ACh]@18
  char v44; // [sp+48h] [bp-6A8h]@31
  char v45; // [sp+4Ah] [bp-6A6h]@18
  char v46; // [sp+88h] [bp-668h]@4
  char v47; // [sp+1D8h] [bp-518h]@6
  char v48; // [sp+618h] [bp-D8h]@5
  int v49; // [sp+6ECh] [bp-4h]@4

  v4 = *(_DWORD *)(a4 + 8);
  v5 = *(_DWORD *)(a4 + 4);
  v6 = this;
  v37 = (int)this;
  v41 = *(_DWORD *)(a4 + 4);
  v39 = *(_DWORD *)(a4 + 8);
  if ( GetCurrentThreadId() != *(_DWORD *)(a4 + 16) || (v30 = 1, 0 != *(_DWORD *)(a4 + 20)) )
    v30 = 0;
  v32 = 0;
  sub_10032780((int)&v46);
  v49 = 0;
  v38 = -1;
  v33 = 0;
  if ( v6[7] )
  {
    while ( 1 )
    {
      v35 = 0;
      if ( v6[6] > 0u )
        break;
LABEL_33:
      if ( (unsigned int)++v33 >= v6[7] )
        goto LABEL_5;
    }
    v31 = 2;
    while ( 1 )
    {
      if ( *(_DWORD *)(a4 + 24) )
      {
        v49 = 2;
        sub_10032D20((int)&v48);
        LOBYTE(v49) = 1;
        sub_10032BC0((int)&v47);
        v29 = &v46;
        goto LABEL_7;
      }
      if ( *(_DWORD *)(v4 + 24) )
      {
        if ( v30 )
        {
          if ( (v32 & 0x3F) == 63 )
          {
            v7 = *(_DWORD *)(v4 + 32)
               + (((unsigned int)(v6[6] * v6[7]) >> 1) + v32 * *(_DWORD *)(v4 + 36)) / (v6[6] * v6[7]);
            if ( v7 != v38 )
            {
              v38 = *(_DWORD *)(v4 + 32)
                  + (((unsigned int)(v6[6] * v6[7]) >> 1) + v32 * *(_DWORD *)(v4 + 36)) / (v6[6] * v6[7]);
              if ( !(unsigned __int8)(*(int (__cdecl **)(unsigned int, _DWORD))(v4 + 24))(v7, *(_DWORD *)(v4 + 28)) )
                break;
            }
          }
        }
      }
      v8 = *(_DWORD *)(v4 + 4);
      if ( !v8 || v32 % (v8 + 1) == a2 )
      {
        v9 = *(_DWORD *)(v5 + 8);
        v10 = *(_DWORD *)v5;
        v11 = *(_DWORD *)(v5 + 4);
        v12 = *(_DWORD *)(v5 + 20);
        v40 = v9;
        v13 = v11 - 1;
        v43 = v10;
        v14 = v10 - 1;
        v15 = 4 * v33;
        v42 = v13;
        v34 = 4 * v33;
        v16 = &v45;
        v36 = 4;
        while ( 1 )
        {
          v17 = v15;
          if ( v15 >= v13 )
            v17 = v13;
          v18 = v31 - 2;
          if ( v31 - 2 >= v14 )
            v18 = v14;
          v19 = v17 * v40;
          v20 = v12 + 4 * (v17 * v40 + v18);
          *(v16 - 2) = *(_BYTE *)v20;
          *(v16 - 1) = *(_BYTE *)(v20 + 1);
          *v16 = *(_BYTE *)(v20 + 2);
          v16[1] = *(_BYTE *)(v20 + 3);
          v21 = v31 - 1;
          if ( v31 - 1 >= v14 )
            v21 = v14;
          v22 = v12 + 4 * (v19 + v21);
          v16[2] = *(_BYTE *)v22;
          v16[3] = *(_BYTE *)(v22 + 1);
          v16[4] = *(_BYTE *)(v22 + 2);
          v16[5] = *(_BYTE *)(v22 + 3);
          v23 = v31;
          if ( v31 >= v14 )
            v23 = v14;
          v24 = v12 + 4 * (v19 + v23);
          v16[6] = *(_BYTE *)v24;
          v16[7] = *(_BYTE *)(v24 + 1);
          v16[8] = *(_BYTE *)(v24 + 2);
          v16[9] = *(_BYTE *)(v24 + 3);
          v25 = v43 - 1;
          if ( v31 + 1 < v43 - 1 )
            v25 = v31 + 1;
          v26 = v25 + v19;
          v27 = *(_BYTE *)(v12 + 4 * v26);
          v28 = v12 + 4 * v26;
          v16[10] = v27;
          v16[11] = *(_BYTE *)(v28 + 1);
          v16[12] = *(_BYTE *)(v28 + 2);
          v16[13] = *(_BYTE *)(v28 + 3);
          ++v34;
          v16 += 16;
          if ( !--v36 )
            break;
          v13 = v42;
          v15 = v34;
        }
        sub_10085BA0(v37, v35, v33, (int)&v44, v39, (int)&v46);
        v6 = (_DWORD *)v37;
        v4 = v39;
        v5 = v41;
      }
      v31 += 4;
      ++v32;
      if ( (unsigned int)++v35 >= v6[6] )
        goto LABEL_33;
    }
    InterlockedExchange((LPLONG)(a4 + 24), 1);
    v49 = 4;
    sub_10032D20((int)&v48);
    LOBYTE(v49) = 3;
  }
  else
  {
LABEL_5:
    v49 = 6;
    sub_10032D20((int)&v48);
    LOBYTE(v49) = 5;
  }
  sub_10032BC0((int)&v47);
  v29 = &v46;
LABEL_7:
  v49 = -1;
  sub_100328F0((int)v29);
}

//----- (10086840) --------------------------------------------------------
char __userpurge sub_10086840@<al>(int a1@<eax>, int a2, int a3, int a4, int a5)
{
  unsigned int v5; // esi@2
  unsigned int v6; // eax@2
  char *v7; // ebx@7
  char result; // al@10
  unsigned int v9; // esi@12
  int v10; // eax@13
  int v11; // [sp+0h] [bp-98h]@13
  int v12; // [sp+4h] [bp-94h]@5
  int v13; // [sp+8h] [bp-90h]@12
  int v14; // [sp+Ch] [bp-8Ch]@12
  int v15; // [sp+10h] [bp-88h]@12
  DWORD v16; // [sp+18h] [bp-80h]@12
  int v17; // [sp+1Ch] [bp-7Ch]@12
  int v18; // [sp+20h] [bp-78h]@12
  char v19; // [sp+28h] [bp-70h]@7
  int v20; // [sp+8Ch] [bp-Ch]@1
  int (__thiscall *v21)(void *); // [sp+90h] [bp-8h]@1
  int v22; // [sp+94h] [bp-4h]@1

  v22 = -1;
  v21 = sub_100972F0;
  v20 = a1;
  if ( !sub_10085450(*(_DWORD *)(a4 + 4), a2, a3, *(_DWORD *)a4) )
    return 0;
  v5 = *(_DWORD *)(a2 + 36);
  v6 = *(_DWORD *)(a2 + 4);
  if ( v5 != v6 )
  {
    if ( v5 >= v6 && v5 > *(_DWORD *)(a2 + 8) )
    {
      LOBYTE(v12) = v5 == v6 + 1;
      sub_100943C0(v5, 0, a2, v5 == v6 + 1, 8u, 0);
    }
    *(_DWORD *)(a2 + 4) = v5;
  }
  *(_DWORD *)(a2 + 12) = *(_DWORD *)a2;
  v7 = *(char **)(a5 + 40);
  sub_10091840((int)&v19);
  v22 = 0;
  if ( !v7 )
  {
    if ( !sub_100917D0(*(_DWORD *)(a5 + 4), (int)&v19) )
    {
      v22 = -1;
      sub_100918E0((int)&v19);
      return 0;
    }
    v7 = &v19;
  }
  v13 = a3;
  v14 = a4;
  v15 = a5;
  v16 = GetCurrentThreadId();
  v17 = 0;
  v18 = 0;
  v9 = 0;
  do
  {
    v11 = 16;
    v10 = off_100AD9F4(0, 16, &v11, 1, dword_100AE9F4);
    if ( v10 && (unsigned int)v11 >= 0x10 )
    {
      *(_DWORD *)v10 = &off_100A4F34;
      *(_DWORD *)(v10 + 4) = a2;
      *(_DWORD *)(v10 + 8) = sub_100864E0;
      *(_DWORD *)(v10 + 12) = 1;
      sub_100916A0(v10, (int)v7, v9, 0, (int)&v13);
    }
    else
    {
      sub_100927E0((int)"crnlib_malloc: out of memory");
    }
    ++v9;
  }
  while ( v9 <= *(_DWORD *)(a5 + 4) );
  sub_10091500((int)v7);
  v22 = -1;
  if ( v18 )
  {
    sub_100918E0((int)&v19);
    result = 0;
  }
  else
  {
    sub_100918E0((int)&v19);
    result = 1;
  }
  return result;
}
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10086A20) --------------------------------------------------------
char __usercall sub_10086A20@<al>(int a1@<eax>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@1
  int v3; // esi@2
  unsigned int v4; // edx@3
  unsigned int v5; // eax@3
  int v6; // ecx@4
  char result; // al@8

  v1 = *(_DWORD *)(a1 + 28);
  v2 = 0;
  if ( v1 )
  {
    v3 = *(_DWORD *)(a1 + 24);
    while ( 1 )
    {
      v4 = *(_DWORD *)(v3 + 4);
      v5 = 0;
      if ( v4 )
        break;
LABEL_7:
      ++v2;
      v3 += 12;
      if ( v2 >= v1 )
        goto LABEL_8;
    }
    v6 = *(_DWORD *)v3;
    while ( !(*(_BYTE *)(*(_DWORD *)v6 + 24) & 3) )
    {
      ++v5;
      v6 += 4;
      if ( v5 >= v4 )
        goto LABEL_7;
    }
    result = 1;
  }
  else
  {
LABEL_8:
    result = 0;
  }
  return result;
}

//----- (10086A70) --------------------------------------------------------
int __fastcall sub_10086A70(int a1, int a2)
{
  int result; // eax@1
  int v3; // ebp@2
  signed int v4; // esi@3
  int v5; // edi@3
  int v6; // ebx@3
  unsigned int v7; // ecx@3
  int v8; // ecx@4
  unsigned int v9; // esi@4
  bool v10; // zf@9
  int v11; // [sp+0h] [bp-Ch]@1
  int v12; // [sp+4h] [bp-8h]@2
  int v13; // [sp+8h] [bp-4h]@4

  result = 0;
  v11 = 0;
  if ( *(_DWORD *)(a2 + 28) )
  {
    v3 = *(_DWORD *)(a2 + 24);
    v12 = *(_DWORD *)(a2 + 28);
    do
    {
      v4 = *(_DWORD *)(v3 + 4);
      v5 = 0;
      v6 = 0;
      v7 = 0;
      if ( v4 >= 2 )
      {
        v8 = *(_DWORD *)v3;
        v9 = ((unsigned int)(v4 - 2) >> 1) + 1;
        v13 = 2 * v9;
        do
        {
          v5 += **(_DWORD **)v8 * *(_DWORD *)(*(_DWORD *)v8 + 4);
          v6 += **(_DWORD **)(v8 + 4) * *(_DWORD *)(*(_DWORD *)(v8 + 4) + 4);
          v8 += 8;
          --v9;
        }
        while ( v9 );
        result = v11;
        v7 = v13;
      }
      if ( v7 < *(_DWORD *)(v3 + 4) )
        result += **(_DWORD **)(*(_DWORD *)v3 + 4 * v7) * *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v3 + 4 * v7) + 4);
      result += v5 + v6;
      v3 += 12;
      v10 = v12-- == 1;
      v11 = result;
    }
    while ( !v10 );
  }
  return result;
}

//----- (10086B50) --------------------------------------------------------
char __usercall sub_10086B50@<al>(int a1@<eax>)
{
  int v1; // esi@1
  unsigned int v2; // ebx@1
  int v4; // edi@3
  int v5; // edi@5
  unsigned int v6; // esi@6

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 28);
  if ( !v2 )
    return 0;
  v4 = *(_DWORD *)(a1 + 20);
  if ( !sub_10033810(*(_DWORD *)(a1 + 20)) )
  {
    if ( v4 != 827611204 )
      return 0;
    v5 = *(_DWORD *)(v1 + 24);
    if ( !*(_DWORD *)(**(_DWORD **)v5 + 20) )
      return 0;
    v6 = 0;
    if ( !v2 )
      return 0;
    while ( !sub_10084D30(*(_DWORD *)(**(_DWORD **)v5 + 20)) )
    {
      ++v6;
      v5 += 12;
      if ( v6 >= v2 )
        return 0;
    }
  }
  return 1;
}

//----- (10086BE0) --------------------------------------------------------
char __usercall sub_10086BE0@<al>(int a1@<eax>)
{
  unsigned int v1; // edx@1
  char result; // al@2
  int v3; // eax@3
  unsigned int v4; // ebp@7
  unsigned int v5; // esi@7
  int v6; // edi@8
  int v7; // eax@9
  int v8; // ecx@11
  int v9; // eax@12
  char v10; // bl@12
  unsigned int v11; // edx@14
  unsigned int v12; // ecx@19
  unsigned int v13; // [sp+0h] [bp-Ch]@5
  int v14; // [sp+4h] [bp-8h]@6
  unsigned int v15; // [sp+8h] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 28);
  v15 = v1;
  if ( v1 )
  {
    v3 = *(_DWORD *)(a1 + 24);
    if ( *(_DWORD *)(**(_DWORD **)v3 + 20) != 0 )
    {
      v13 = 0;
      if ( v1 )
      {
        v14 = v3;
        while ( 1 )
        {
          v4 = *(_DWORD *)(v3 + 4);
          v5 = 0;
          if ( v4 )
            break;
LABEL_24:
          v3 += 12;
          ++v13;
          v14 = v3;
          if ( v13 >= v1 )
            goto LABEL_25;
        }
        v6 = *(_DWORD *)v3;
        while ( 1 )
        {
          v7 = *(_DWORD *)v6;
          if ( !*(_DWORD *)(*(_DWORD *)v6 + 16) && !*(_DWORD *)(v7 + 20) )
            break;
          v8 = *(_DWORD *)(v7 + 20);
          if ( v8 )
          {
            v9 = *(_DWORD *)(v7 + 24);
            v10 = 1;
            if ( v9 & 1 )
            {
              if ( *(_DWORD *)(v8 + 60) == 7 || (v11 = *(_DWORD *)(v8 + 16), v11 & 3) && v11 > 4 )
                v10 = 0;
            }
            if ( v9 & 2 )
            {
              if ( *(_DWORD *)(v8 + 60) == 7 )
                break;
              v12 = *(_DWORD *)(v8 + 20);
              if ( v12 & 3 )
              {
                if ( v12 > 4 )
                  break;
              }
            }
            if ( !v10 )
              break;
          }
          ++v5;
          v6 += 4;
          if ( v5 >= v4 )
          {
            v3 = v14;
            v1 = v15;
            goto LABEL_24;
          }
        }
        result = 0;
      }
      else
      {
LABEL_25:
        result = 1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10086CC0) --------------------------------------------------------
int __usercall sub_10086CC0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int result; // eax@1
  int v3; // eax@3
  int v4; // eax@4

  result = *(_DWORD *)(a1 + 12);
  if ( result <= 1383614328 )
  {
    if ( result == 1383614328 )
      return sub_1007B4C0(a2, 3u);
    v3 = result - 843666497;
    if ( v3 )
    {
      v4 = v3 - 536408832;
      if ( v4 )
      {
        result = v4 - 55;
        if ( !result )
          result = sub_1007B4C0(a2, 5u);
      }
      else
      {
        result = sub_1007B4C0(a2, 7u);
      }
      return result;
    }
    return sub_1007B4C0(a2, 8u);
  }
  if ( result == 1498952257 )
    return sub_1007B4C0(a2, 8u);
  if ( result == 1501053763 )
    result = sub_1007B4C0(a2, 1u);
  return result;
}

//----- (10086E20) --------------------------------------------------------
void __stdcall sub_10086E20(int a1)
{
  int v1; // edx@1
  int v2; // ebp@1
  int v3; // eax@2
  unsigned int v4; // ecx@2
  int v5; // eax@2
  unsigned int v6; // esi@3
  int v7; // eax@4
  int v8; // ebx@5
  int v9; // eax@6
  int *v10; // ebx@14
  int v11; // eax@15
  FILE *v12; // eax@24
  int v13; // esi@28
  unsigned int v14; // eax@28
  int v15; // esi@28
  int v16; // [sp+4h] [bp-20Ch]@4
  unsigned int v17; // [sp+8h] [bp-208h]@1
  char DstBuf; // [sp+10h] [bp-200h]@24

  v1 = a1;
  v2 = 0;
  v17 = 0;
  if ( *(_DWORD *)(a1 + 28) )
  {
    do
    {
      v3 = *(_DWORD *)(v1 + 24);
      v4 = *(_DWORD *)(v3 + v2 + 4);
      v5 = v2 + v3;
      if ( v4 > 1 )
      {
        v6 = 1;
        do
        {
          v7 = *(_DWORD *)(*(_DWORD *)v5 + 4 * v6);
          v16 = v7;
          if ( v7 )
          {
            v8 = *(_DWORD *)(v7 + 16);
            if ( v8 )
            {
              v9 = *(_DWORD *)(v8 + 24);
              if ( v9 )
              {
                if ( v9 & 7 )
                  sub_100927E0((int)"crnlib_free: bad ptr");
                else
                  off_100AD9F4(v9, 0, 0, 1, dword_100AE9F4);
              }
              if ( v8 & 7 )
                sub_100927E0((int)"crnlib_free: bad ptr");
              else
                off_100AD9F4(v8, 0, 0, 1, dword_100AE9F4);
              v7 = v16;
            }
            v10 = *(int **)(v7 + 20);
            if ( v10 )
            {
              v11 = *v10;
              if ( *v10 )
              {
                if ( v11 & 7 )
                  sub_100927E0((int)"crnlib_free: bad ptr");
                else
                  off_100AD9F4(v11, 0, 0, 1, dword_100AE9F4);
              }
              if ( (unsigned __int8)v10 & 7 )
                sub_100927E0((int)"crnlib_free: bad ptr");
              else
                off_100AD9F4(v10, 0, 0, 1, dword_100AE9F4);
              v7 = v16;
            }
            if ( v7 & 7 )
            {
              sprintf_s(
                &DstBuf,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_free: bad ptr");
              OutputDebugStringA(&DstBuf);
              v12 = _iob_func();
              fputs(&DstBuf, v12 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v7, 0, 0, 1, dword_100AE9F4);
            }
          }
          v1 = a1;
          ++v6;
          v5 = v2 + *(_DWORD *)(a1 + 24);
        }
        while ( v6 < *(_DWORD *)(v5 + 4) );
        v13 = *(_DWORD *)(a1 + 24);
        v14 = *(_DWORD *)(v13 + v2 + 4);
        v15 = v2 + v13;
        if ( v14 != 1 )
        {
          if ( v14 <= 1 )
          {
            if ( *(_DWORD *)(v15 + 8) < 1u )
              sub_100943C0(1u, 0, v15, v14 == 0, 4u, 0);
            memset((void *)(4 * *(_DWORD *)(v15 + 4) + *(_DWORD *)v15), 0, 4 - 4 * *(_DWORD *)(v15 + 4));
          }
          v1 = a1;
          *(_DWORD *)(v15 + 4) = 1;
        }
      }
      v2 += 12;
      ++v17;
    }
    while ( v17 < *(_DWORD *)(v1 + 28) );
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10087040) --------------------------------------------------------
void __usercall sub_10087040(int a1@<edi>)
{
  int v1; // ecx@1
  unsigned int v2; // esi@3
  int v3; // eax@3
  int v4; // eax@4
  int v5; // ebx@5
  int v6; // eax@6
  int *v7; // ebx@14
  int v8; // eax@15
  FILE *v9; // eax@24
  int *v10; // ecx@29
  int v11; // eax@30
  int v12; // [sp+4h] [bp-20Ch]@4
  unsigned int v13; // [sp+8h] [bp-208h]@1
  int v14; // [sp+Ch] [bp-204h]@2
  char DstBuf; // [sp+10h] [bp-200h]@24

  v1 = 0;
  v13 = 0;
  if ( *(_DWORD *)(a1 + 28) )
  {
    v14 = 0;
    do
    {
      v2 = 0;
      v3 = v1 + *(_DWORD *)(a1 + 24);
      if ( *(_DWORD *)(v3 + 4) )
      {
        do
        {
          v4 = *(_DWORD *)(*(_DWORD *)v3 + 4 * v2);
          v12 = v4;
          if ( v4 )
          {
            v5 = *(_DWORD *)(v4 + 16);
            if ( v5 )
            {
              v6 = *(_DWORD *)(v5 + 24);
              if ( v6 )
              {
                if ( v6 & 7 )
                  sub_100927E0((int)"crnlib_free: bad ptr");
                else
                  off_100AD9F4(v6, 0, 0, 1, dword_100AE9F4);
              }
              if ( v5 & 7 )
                sub_100927E0((int)"crnlib_free: bad ptr");
              else
                off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
              v4 = v12;
            }
            v7 = *(int **)(v4 + 20);
            if ( v7 )
            {
              v8 = *v7;
              if ( *v7 )
              {
                if ( v8 & 7 )
                  sub_100927E0((int)"crnlib_free: bad ptr");
                else
                  off_100AD9F4(v8, 0, 0, 1, dword_100AE9F4);
              }
              if ( (unsigned __int8)v7 & 7 )
                sub_100927E0((int)"crnlib_free: bad ptr");
              else
                off_100AD9F4(v7, 0, 0, 1, dword_100AE9F4);
              v4 = v12;
            }
            if ( v4 & 7 )
            {
              sprintf_s(
                &DstBuf,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_free: bad ptr");
              OutputDebugStringA(&DstBuf);
              v9 = _iob_func();
              fputs(&DstBuf, v9 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
            }
          }
          v1 = v14;
          ++v2;
          v3 = v14 + *(_DWORD *)(a1 + 24);
        }
        while ( v2 < *(_DWORD *)(v3 + 4) );
      }
      v1 += 12;
      ++v13;
      v14 = v1;
    }
    while ( v13 < *(_DWORD *)(a1 + 28) );
  }
  v10 = *(int **)(a1 + 24);
  if ( v10 )
  {
    sub_1003E4E0(*(_DWORD *)(a1 + 28), v10);
    v11 = *(_DWORD *)(a1 + 24);
    if ( v11 )
    {
      if ( v11 & 7 )
      {
        sub_100927E0((int)"crnlib_free: bad ptr");
        *(_DWORD *)(a1 + 24) = 0;
        *(_DWORD *)(a1 + 28) = 0;
        *(_DWORD *)(a1 + 32) = 0;
        return;
      }
      off_100AD9F4(v11, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10087290) --------------------------------------------------------
void __stdcall sub_10087290(int a1)
{
  int v1; // eax@1
  int v2; // ecx@2
  int *v3; // ecx@7
  int v4; // eax@8
  int v5; // edi@12
  int v6; // eax@13

  sub_10087040(a1);
  v1 = *(_DWORD *)(a1 + 44);
  if ( v1 )
  {
    v2 = v1 - 8;
    if ( *(_DWORD *)(v1 - 4) == ~*(_DWORD *)(v1 - 8) && v1 != 8 )
    {
      if ( v2 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    }
  }
  v3 = *(int **)(a1 + 24);
  if ( v3 )
  {
    sub_1003E4E0(*(_DWORD *)(a1 + 28), v3);
    v4 = *(_DWORD *)(a1 + 24);
    if ( v4 )
    {
      if ( v4 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
    }
  }
  v5 = *(_DWORD *)(a1 + 4);
  if ( v5 )
  {
    v6 = v5 - 8;
    if ( *(_DWORD *)(v5 - 4) == ~*(_DWORD *)(v5 - 8) && v5 != 8 )
    {
      if ( v6 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v6, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100873F0) --------------------------------------------------------
signed int __userpurge sub_100873F0@<eax>(int a1@<eax>, int a2@<esi>, signed int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  int *v6; // ebx@3
  signed int v7; // eax@5
  signed int result; // eax@7

  v4 = *(_DWORD *)(a2 + 16);
  v5 = a1;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 15;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  if ( v4 )
  {
    sub_10034460(v4);
    *(_DWORD *)(a2 + 16) = 0;
  }
  v6 = *(int **)(a2 + 20);
  if ( v6 )
  {
    sub_100344C0(v6);
    *(_DWORD *)(a2 + 20) = 0;
  }
  *(_DWORD *)(a2 + 20) = v5;
  *(_DWORD *)a2 = *(_DWORD *)(v5 + 16);
  v7 = a3;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(v5 + 20);
  *(_DWORD *)(a2 + 24) = a4;
  if ( a3 )
  {
LABEL_16:
    *(_DWORD *)(a2 + 12) = v7;
    result = sub_1008B7D0(v7);
    *(_DWORD *)(a2 + 8) = result;
  }
  else
  {
    switch ( *(_DWORD *)(v5 + 60) )
    {
      case 0:
        *(_DWORD *)(a2 + 12) = 827611204;
        result = sub_1008B7D0(827611204);
        *(_DWORD *)(a2 + 8) = result;
        break;
      case 1:
        *(_DWORD *)(a2 + 12) = 1093752900;
        result = sub_1008B7D0(1093752900);
        *(_DWORD *)(a2 + 8) = result;
        break;
      case 2:
        *(_DWORD *)(a2 + 12) = 861165636;
        result = sub_1008B7D0(861165636);
        *(_DWORD *)(a2 + 8) = result;
        break;
      case 3:
        *(_DWORD *)(a2 + 12) = 894720068;
        result = sub_1008B7D0(894720068);
        *(_DWORD *)(a2 + 8) = result;
        break;
      case 5:
        *(_DWORD *)(a2 + 12) = 1498952257;
        result = sub_1008B7D0(1498952257);
        *(_DWORD *)(a2 + 8) = result;
        break;
      case 6:
        *(_DWORD *)(a2 + 12) = 843666497;
        result = sub_1008B7D0(843666497);
        *(_DWORD *)(a2 + 8) = result;
        break;
      case 4:
        *(_DWORD *)(a2 + 12) = 826889281;
        result = sub_1008B7D0(826889281);
        *(_DWORD *)(a2 + 8) = result;
        break;
      case 7:
        *(_DWORD *)(a2 + 12) = 826496069;
        result = sub_1008B7D0(826496069);
        *(_DWORD *)(a2 + 8) = result;
        break;
      default:
        v7 = 0;
        goto LABEL_16;
    }
  }
  return result;
}

//----- (10087550) --------------------------------------------------------
char __userpurge sub_10087550@<al>(int a1@<edi>, int a2@<esi>, int a3, int a4)
{
  int v4; // ebx@1
  int *v5; // ebx@3
  int v6; // eax@6
  unsigned int v7; // ecx@7

  v4 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 15;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  if ( v4 )
  {
    sub_10034460(v4);
    *(_DWORD *)(a2 + 16) = 0;
  }
  v5 = *(int **)(a2 + 20);
  if ( v5 )
  {
    sub_100344C0(v5);
    *(_DWORD *)(a2 + 20) = 0;
  }
  *(_DWORD *)(a2 + 16) = a1;
  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + 24) = a4;
  if ( a3 )
  {
    *(_DWORD *)(a2 + 12) = a3;
    v6 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a2 + 8) = v6;
  }
  else
  {
    v7 = *(_DWORD *)(a1 + 16);
    LOBYTE(v6) = (v7 >> 3) & 1;
    if ( (v7 >> 4) & 1 )
    {
      *(_DWORD *)(a2 + 12) = ((v7 >> 3) & 1) != 0 ? 1098414156 : 2021161036;
      v6 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a2 + 8) = v6;
    }
    else
    {
      *(_DWORD *)(a2 + 12) = ((v7 >> 3) & 1) != 0 ? 1094862674 : 2017609554;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 16);
    }
  }
  return v6;
}

//----- (10087610) --------------------------------------------------------
void *__stdcall sub_10087610(int a1, int a2, int a3, int a4, int a5, int a6, void *a7)
{
  int v7; // ebp@1
  int v8; // edx@1
  void *result; // eax@3
  int v10; // esi@5
  int v11; // eax@13
  void (*v12)(char *, size_t, const char *, ...); // edi@15
  FILE *(__cdecl *v13)(); // ebp@15
  FILE *v14; // eax@15
  void (__cdecl *v15)(const char *, FILE *); // esi@15
  char v16; // cl@18
  int v17; // eax@23
  FILE *v18; // eax@25
  int v19; // esi@27
  int v20; // ST14_4@28
  int v21; // eax@28
  unsigned int v22; // edi@29
  unsigned int v23; // eax@29
  size_t v24; // ST14_4@34
  void *v25; // ST0C_4@34
  int v26; // eax@38
  int v27; // esi@40
  FILE *v28; // eax@41
  int v29; // ebp@45
  unsigned int v30; // ecx@45
  unsigned int v31; // edi@45
  int v32; // edx@49
  int v33; // ebp@49
  unsigned int v34; // ecx@49
  _DWORD *v35; // eax@50
  int v36; // [sp+10h] [bp-638h]@13
  int v37; // [sp+14h] [bp-634h]@4
  void *v38; // [sp+18h] [bp-630h]@11
  unsigned int v39; // [sp+1Ch] [bp-62Ch]@18
  int v40; // [sp+20h] [bp-628h]@23
  int v41; // [sp+24h] [bp-624h]@4
  int v42; // [sp+28h] [bp-620h]@38
  int v43; // [sp+2Ch] [bp-61Ch]@32
  int v44; // [sp+30h] [bp-618h]@47
  int v45; // [sp+34h] [bp-614h]@8
  int v46; // [sp+38h] [bp-610h]@12
  char DstBuf; // [sp+3Ch] [bp-60Ch]@15
  CHAR OutputString; // [sp+23Ch] [bp-40Ch]@25
  CHAR v49; // [sp+43Ch] [bp-20Ch]@41
  int v50; // [sp+644h] [bp-4h]@44

  v7 = a1;
  sub_10087040(a1);
  sub_10091CF0(a1);
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 15;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 36) = -1;
  sub_10091CF0(a1 + 40);
  *(_DWORD *)(a1 + 12) = a3;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 16) = sub_1008B7D0(a6);
  *(_DWORD *)(a1 + 20) = v8;
  if ( a7 )
    sub_10092080(a1, a7);
  sub_10033720(a1 + 24, a5);
  result = (void *)a5;
  if ( (unsigned int)a5 > 0 )
  {
    v37 = 0;
    v41 = a5;
    do
    {
      v10 = v37 + *(_DWORD *)(v7 + 24);
      result = *(void **)(v10 + 4);
      if ( (void *)a4 != result )
      {
        if ( a4 >= (unsigned int)result )
        {
          if ( (unsigned int)a4 > *(_DWORD *)(v10 + 8) )
          {
            LOBYTE(v45) = a4 == (_DWORD)result + 1;
            sub_100943C0(a4, 0, v10, a4 == (_DWORD)result + 1, 4u, 0);
          }
          result = memset((void *)(*(_DWORD *)v10 + 4 * *(_DWORD *)(v10 + 4)), 0, 4 * (a4 - *(_DWORD *)(v10 + 4)));
        }
        *(_DWORD *)(v10 + 4) = a4;
      }
      v38 = 0;
      if ( (unsigned int)a4 > 0 )
      {
        v46 = sub_10033890(a6);
        do
        {
          v36 = 28;
          v11 = off_100AD9F4(0, 28, &v36, 1, dword_100AE9F4);
          if ( v11 && (unsigned int)v36 >= 0x1C )
          {
            v12 = (void (*)(char *, size_t, const char *, ...))sprintf_s;
            v15 = (void (__cdecl *)(const char *, FILE *))fputs;
            v13 = _iob_func;
            *(_DWORD *)v11 = 0;
            *(_DWORD *)(v11 + 4) = 0;
            *(_DWORD *)(v11 + 8) = 15;
            *(_DWORD *)(v11 + 12) = 0;
            *(_DWORD *)(v11 + 16) = 0;
            *(_DWORD *)(v11 + 20) = 0;
            *(_DWORD *)(v11 + 24) = 0;
          }
          else
          {
            v12 = (void (*)(char *, size_t, const char *, ...))sprintf_s;
            sprintf_s(
              &DstBuf,
              0x200u,
              "%s(%u): Assertion failed: \"%s\"\n",
              "crn_mem.cpp",
              216,
              "crnlib_malloc: out of memory");
            OutputDebugStringA(&DstBuf);
            v13 = _iob_func;
            v14 = _iob_func();
            v15 = (void (__cdecl *)(const char *, FILE *))fputs;
            fputs(&DstBuf, v14 + 2);
            if ( IsDebuggerPresent() )
              DebugBreak();
            v11 = 0;
          }
          v16 = (char)v38;
          *(_DWORD *)(*(_DWORD *)(v37 + *(_DWORD *)(a1 + 24)) + 4 * (_DWORD)v38) = v11;
          v39 = 1;
          if ( (unsigned int)a2 >> v16 >= 1 )
            v39 = (unsigned int)a2 >> v16;
          v36 = 1;
          if ( (unsigned int)a3 >> v16 >= 1 )
            v36 = (unsigned int)a3 >> v16;
          if ( v46 )
          {
            v40 = 64;
            v17 = off_100AD9F4(0, 64, &v40, 1, dword_100AE9F4);
            if ( v17 && (unsigned int)v40 >= 0x40 )
            {
              *(_DWORD *)v17 = 0;
              *(_DWORD *)(v17 + 4) = 0;
              *(_DWORD *)(v17 + 8) = 0;
              *(_DWORD *)(v17 + 12) = 0;
              *(_DWORD *)(v17 + 16) = 0;
              *(_DWORD *)(v17 + 20) = 0;
              *(_DWORD *)(v17 + 24) = 0;
              *(_DWORD *)(v17 + 28) = 0;
              *(_DWORD *)(v17 + 32) = 0;
              *(_DWORD *)(v17 + 36) = 0;
              *(_DWORD *)(v17 + 40) = 0;
              *(_DWORD *)(v17 + 44) = 0;
              *(_DWORD *)(v17 + 60) = -1;
              *(_DWORD *)(v17 + 52) = 0;
              *(_DWORD *)(v17 + 56) = 0;
              *(_WORD *)(v17 + 48) = 0;
              v19 = v17;
            }
            else
            {
              v12(
                &OutputString,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_malloc: out of memory");
              OutputDebugStringA(&OutputString);
              v18 = v13();
              v15(&OutputString, v18 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
              v19 = 0;
            }
            v20 = v39;
            v21 = sub_100321D0(a6);
            if ( sub_10085450(v36, v19, v21, v20) )
            {
              v22 = *(_DWORD *)(v19 + 36);
              v23 = *(_DWORD *)(v19 + 4);
              if ( v22 != v23 )
              {
                if ( v22 >= v23 && v22 > *(_DWORD *)(v19 + 8) )
                {
                  LOBYTE(v43) = v22 == v23 + 1;
                  sub_100943C0(v22, 0, v19, v22 == v23 + 1, 8u, 0);
                }
                *(_DWORD *)(v19 + 4) = v22;
              }
              v24 = 8 * *(_DWORD *)(v19 + 36);
              v25 = *(void **)v19;
              *(_DWORD *)(v19 + 12) = *(_DWORD *)v19;
              memset(v25, 0, v24);
            }
            sub_100873F0(
              v19,
              *(_DWORD *)(*(_DWORD *)(v37 + *(_DWORD *)(a1 + 24)) + 4 * (_DWORD)v38),
              *(_DWORD *)(a1 + 20),
              0);
          }
          else
          {
            v42 = 36;
            v26 = off_100AD9F4(0, 36, &v42, 1, dword_100AE9F4);
            if ( v26 && (unsigned int)v42 >= 0x24 )
            {
              v27 = v26;
            }
            else
            {
              v12(
                &v49,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_malloc: out of memory");
              OutputDebugStringA(&v49);
              v28 = v13();
              v15(&v49, v28 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
              v27 = 0;
            }
            v40 = v27;
            v50 = 0;
            if ( v27 )
            {
              v29 = v27 + 24;
              *(_DWORD *)(v27 + 16) = 15;
              *(_DWORD *)v29 = 0;
              *(_DWORD *)(v29 + 4) = 0;
              *(_DWORD *)(v29 + 8) = 0;
              v30 = v39;
              LOBYTE(v50) = 1;
              v31 = v39 * v36;
              if ( v39 * v36 )
              {
                if ( v31 > 0 )
                {
                  LOBYTE(v44) = v31 == 1;
                  sub_100943C0(v39 * v36, 0, v27 + 24, v31 == 1, 4u, 0);
                  v30 = v39;
                }
                *(_DWORD *)(v27 + 28) = v31;
              }
              v32 = v36;
              v33 = *(_DWORD *)v29;
              *(_DWORD *)v27 = v30;
              *(_DWORD *)(v27 + 8) = v30;
              v34 = 0;
              *(_DWORD *)(v27 + 4) = v32;
              *(_DWORD *)(v27 + 12) = v31;
              for ( *(_DWORD *)(v27 + 20) = v33; v34 < *(_DWORD *)(v27 + 12); *v35 = -16777216 )
                v35 = (_DWORD *)(*(_DWORD *)(v27 + 20) + 4 * v34++);
            }
            else
            {
              v27 = 0;
            }
            v50 = -1;
            *(_DWORD *)(v27 + 16) = *(_DWORD *)(a1 + 16);
            sub_10087550(
              v27,
              *(_DWORD *)(*(_DWORD *)(v37 + *(_DWORD *)(a1 + 24)) + 4 * (_DWORD)v38),
              *(_DWORD *)(a1 + 20),
              0);
          }
          result = (char *)v38 + 1;
          v38 = result;
        }
        while ( (unsigned int)result < a4 );
        v7 = a1;
      }
      v37 += 12;
      --v41;
    }
    while ( v41 );
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10087B40) --------------------------------------------------------
int __usercall sub_10087B40@<eax>(int result@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  int v3; // eax@2
  int v4; // eax@2
  int v5; // eax@2

  v2 = result;
  if ( *(_DWORD *)(a2 + 4) )
  {
    sub_10087040(result);
    v3 = ***(_DWORD ***)a2;
    *(_DWORD *)(v2 + 8) = *(_DWORD *)v3;
    *(_DWORD *)(v2 + 12) = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v2 + 16) = *(_DWORD *)(v3 + 8);
    *(_DWORD *)(v2 + 20) = *(_DWORD *)(v3 + 12);
    v4 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v2 + 24) = *(_DWORD *)a2;
    *(_DWORD *)a2 = v4;
    v5 = *(_DWORD *)(v2 + 28);
    *(_DWORD *)(v2 + 28) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = v5;
    result = *(_DWORD *)(v2 + 32);
    *(_DWORD *)(v2 + 32) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a2 + 8) = result;
  }
  return result;
}

//----- (10087B90) --------------------------------------------------------
int __usercall sub_10087B90@<eax>(int a1@<ecx>, int a2@<esi>)
{
  int v2; // ebx@1
  int v3; // edi@1
  int *v4; // ebx@3
  int v5; // edi@7
  int v6; // eax@8
  int v7; // ebx@8

  v2 = *(_DWORD *)(a2 + 16);
  v3 = a1;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 15;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  if ( v2 )
  {
    sub_10034460(v2);
    *(_DWORD *)(a2 + 16) = 0;
  }
  v4 = *(int **)(a2 + 20);
  if ( v4 )
  {
    sub_100344C0(v4);
    *(_DWORD *)(a2 + 20) = 0;
  }
  *(_DWORD *)a2 = *(_DWORD *)v3;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(v3 + 4);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 8);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(v3 + 12);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(v3 + 24);
  if ( *(_DWORD *)(v3 + 16) )
    *(_DWORD *)(a2 + 16) = sub_100343F0(*(_DWORD *)(v3 + 16));
  v5 = *(_DWORD *)(v3 + 20);
  if ( v5 )
  {
    v6 = sub_10092A80(64);
    v7 = v6;
    if ( v6 )
    {
      *(_DWORD *)v6 = 0;
      *(_DWORD *)(v6 + 4) = 0;
      *(_DWORD *)(v6 + 8) = 0;
      *(_DWORD *)(v6 + 12) = 0;
      sub_10085090(v6, v5);
    }
    else
    {
      v7 = 0;
    }
    *(_DWORD *)(a2 + 20) = v7;
  }
  return a2;
}

//----- (10087C90) --------------------------------------------------------
int __stdcall sub_10087C90(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // ebp@1
  bool v4; // zf@2
  int v5; // ebp@3
  int v6; // esi@5
  unsigned int v7; // ebx@5
  unsigned int v8; // eax@5
  int v9; // esi@5
  unsigned int v10; // ebx@11
  int v11; // eax@11
  int v12; // eax@12
  int v13; // esi@14
  FILE *v14; // eax@15
  int v15; // ecx@19
  int v17; // [sp+8h] [bp-21Ch]@12
  int v18; // [sp+Ch] [bp-218h]@2
  int v19; // [sp+10h] [bp-214h]@8
  int v20; // [sp+14h] [bp-210h]@12
  char DstBuf; // [sp+18h] [bp-20Ch]@15
  int v22; // [sp+220h] [bp-4h]@18

  v2 = a2;
  v3 = a1;
  if ( a1 != a2 )
  {
    sub_10087040(a1);
    sub_10091CF0(a1);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 16) = 15;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 36) = -1;
    sub_10091CF0(a1 + 40);
    sub_10091FD0(a1, a2);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
    sub_10033720(a1 + 24, *(_DWORD *)(a2 + 28));
    v4 = *(_DWORD *)(a1 + 28) == 0;
    v18 = 0;
    if ( !v4 )
    {
      v5 = 0;
      while ( 1 )
      {
        v6 = *(_DWORD *)(a1 + 24);
        v7 = *(_DWORD *)(*(_DWORD *)(v2 + 24) + v5 + 4);
        v8 = *(_DWORD *)(v6 + v5 + 4);
        v9 = v5 + v6;
        if ( v7 != v8 )
        {
          if ( v7 >= v8 )
          {
            if ( v7 > *(_DWORD *)(v9 + 8) )
            {
              LOBYTE(v19) = v7 == v8 + 1;
              sub_100943C0(v7, 0, v9, v7 == v8 + 1, 4u, 0);
            }
            memset((void *)(*(_DWORD *)v9 + 4 * *(_DWORD *)(v9 + 4)), 0, 4 * (v7 - *(_DWORD *)(v9 + 4)));
          }
          *(_DWORD *)(v9 + 4) = v7;
        }
        v10 = 0;
        v11 = v5 + *(_DWORD *)(a2 + 24);
        if ( *(_DWORD *)(v11 + 4) )
        {
          do
          {
            v20 = *(_DWORD *)(*(_DWORD *)v11 + 4 * v10);
            v17 = 28;
            v12 = off_100AD9F4(0, 28, &v17, 1, dword_100AE9F4);
            if ( v12 && (unsigned int)v17 >= 0x1C )
            {
              v13 = v12;
            }
            else
            {
              sprintf_s(
                &DstBuf,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_malloc: out of memory");
              OutputDebugStringA(&DstBuf);
              v14 = _iob_func();
              fputs(&DstBuf, v14 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
              v13 = 0;
            }
            v22 = 0;
            if ( v13 )
            {
              v15 = v20;
              *(_DWORD *)v13 = 0;
              *(_DWORD *)(v13 + 4) = 0;
              *(_DWORD *)(v13 + 8) = 15;
              *(_DWORD *)(v13 + 12) = 0;
              *(_DWORD *)(v13 + 16) = 0;
              *(_DWORD *)(v13 + 20) = 0;
              *(_DWORD *)(v13 + 24) = 0;
              sub_10087B90(v15, v13);
            }
            else
            {
              v13 = 0;
            }
            v22 = -1;
            *(_DWORD *)(4 * v10++ + *(_DWORD *)(*(_DWORD *)(a1 + 24) + v5)) = v13;
            v11 = v5 + *(_DWORD *)(a2 + 24);
          }
          while ( v10 < *(_DWORD *)(v11 + 4) );
        }
        v5 += 12;
        if ( (unsigned int)++v18 >= *(_DWORD *)(a1 + 28) )
          break;
        v2 = a2;
      }
      v3 = a1;
    }
  }
  return v3;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10087F90) --------------------------------------------------------
char __stdcall sub_10087F90(int a1, int a2, int a3, int a4, const void *a5, signed int a6)
{
  signed int v6; // edx@1
  char v7; // bl@1
  bool v9; // zf@21
  char v10; // cl@28
  unsigned int v11; // esi@28
  int v12; // edi@28
  int v13; // eax@29
  int v14; // eax@31
  void *v15; // edi@34
  int v16; // edx@37
  int v17; // esi@44
  int *v18; // eax@44
  int v19; // esi@49
  unsigned int v20; // ebx@49
  unsigned int v21; // ebp@49
  unsigned int v22; // ecx@49
  unsigned int v23; // eax@49
  int v24; // ecx@54
  int v25; // eax@54
  int v26; // ecx@54
  int v27; // ecx@54
  int v28; // ecx@54
  int v29; // ebp@56
  int v30; // edi@56
  int v31; // esi@57
  int v32; // ecx@58
  int v33; // eax@58
  int v34; // edx@58
  int v35; // eax@66
  unsigned int v36; // eax@68
  bool v37; // cf@68
  FILE *v38; // eax@73
  FILE *v39; // eax@78
  unsigned int v40; // [sp+10h] [bp-484h]@49
  unsigned int v41; // [sp+10h] [bp-484h]@55
  int v42; // [sp+14h] [bp-480h]@36
  unsigned int v43; // [sp+14h] [bp-480h]@41
  int v44; // [sp+18h] [bp-47Ch]@42
  unsigned int v45; // [sp+1Ch] [bp-478h]@54
  unsigned int v46; // [sp+20h] [bp-474h]@43
  signed int v47; // [sp+24h] [bp-470h]@57
  int v48; // [sp+28h] [bp-46Ch]@56
  signed int v49; // [sp+2Ch] [bp-468h]@56
  unsigned int v50; // [sp+34h] [bp-460h]@49
  unsigned int v51; // [sp+38h] [bp-45Ch]@49
  int v52; // [sp+3Ch] [bp-458h]@49
  int v53; // [sp+40h] [bp-454h]@49
  int v54; // [sp+44h] [bp-450h]@49
  int v55; // [sp+48h] [bp-44Ch]@49
  int v56; // [sp+4Ch] [bp-448h]@49
  int v57; // [sp+50h] [bp-444h]@49
  void *v58; // [sp+54h] [bp-440h]@49
  int v59; // [sp+58h] [bp-43Ch]@49
  int v60; // [sp+5Ch] [bp-438h]@49
  int v61; // [sp+60h] [bp-434h]@44
  int v62; // [sp+64h] [bp-430h]@44
  int v63; // [sp+68h] [bp-42Ch]@44
  int v64; // [sp+6Ch] [bp-428h]@44
  int v65; // [sp+70h] [bp-424h]@44
  int v66; // [sp+74h] [bp-420h]@44
  void *v67; // [sp+78h] [bp-41Ch]@44
  int v68; // [sp+7Ch] [bp-418h]@44
  int v69; // [sp+80h] [bp-414h]@44
  char DstBuf; // [sp+84h] [bp-410h]@73
  CHAR OutputString; // [sp+284h] [bp-210h]@78
  int v72; // [sp+490h] [bp-4h]@44

  v6 = a6;
  v7 = 0;
  if ( !*(_DWORD *)(a1 + 28) )
    return 0;
  qmemcpy((void *)(a2 + 15668), (const void *)a4, 0x624u);
  qmemcpy((void *)(a2 + 17240), a5, 0x628u);
  qmemcpy((void *)(a2 + 18816), a5, 0x628u);
  *(_WORD *)(a2 + 20392) = 0;
  *(_BYTE *)(a2 + 20394) = 0;
  if ( a6 > 1093752900 )
  {
    if ( a6 > 1383614328 )
    {
      if ( a6 == 1498952257 )
      {
        *(_DWORD *)(a2 + 18808) = 0;
        *(_DWORD *)(a2 + 20384) = 1;
        goto LABEL_27;
      }
      v9 = a6 == 1501053763;
    }
    else
    {
      if ( a6 == 1383614328 || a6 == 1380075329 )
      {
LABEL_25:
        *(_WORD *)(a2 + 20392) = 257;
        *(_WORD *)(a2 + 15680) = 0;
        *(_DWORD *)(a2 + 18808) = 3;
        goto LABEL_28;
      }
      v9 = a6 == 1380075384;
    }
    if ( !v9 )
      return 0;
    goto LABEL_25;
  }
  if ( a6 == 1093752900 )
  {
    *(_BYTE *)(a2 + 20392) = 1;
    *(_BYTE *)(a2 + 15681) = 1;
    goto LABEL_28;
  }
  if ( a6 > 843666497 )
  {
    if ( a6 != 877942852 && a6 != 894720068 )
      return 0;
    *(_WORD *)(a2 + 20392) = 257;
    *(_BYTE *)(a2 + 15681) = 0;
    *(_DWORD *)(a2 + 18808) = 3;
    goto LABEL_28;
  }
  if ( a6 == 843666497 )
  {
    *(_DWORD *)(a2 + 18808) = 1;
    *(_DWORD *)(a2 + 20384) = 0;
LABEL_27:
    *(_WORD *)(a2 + 20393) = 257;
    goto LABEL_28;
  }
  if ( a6 == 826496069 )
  {
    sub_10094340("mipmapped_texture::qdxt_pack_init: This method does not support ETC1");
    return 0;
  }
  if ( a6 != 826889281 )
  {
    if ( a6 == 827611204 )
    {
      *(_BYTE *)(a2 + 20392) = 1;
      goto LABEL_28;
    }
    return 0;
  }
  *(_BYTE *)(a2 + 20393) = 1;
  *(_DWORD *)(a2 + 18808) = 3;
LABEL_28:
  v10 = *(_BYTE *)(a2 + 20394);
  v11 = *(_BYTE *)(a2 + 20394) + *(_BYTE *)(a2 + 20393) + *(_BYTE *)(a2 + 20392);
  v12 = *(_DWORD *)(a4 + 1564);
  if ( *(_BYTE *)(a2 + 20392) )
  {
    *(_DWORD *)(a2 + 17232) = v12;
    v13 = *(_DWORD *)(a4 + 1568) / v11;
    v6 = a6;
    *(_DWORD *)(a2 + 17236) = v13;
    v12 += v13;
  }
  if ( *(_BYTE *)(a2 + 20393) )
  {
    *(_DWORD *)(a2 + 18800) = v12;
    v14 = *(_DWORD *)(a4 + 1568) / v11;
    v6 = a6;
    *(_DWORD *)(a2 + 18804) = v14;
    v12 += v14;
  }
  if ( v10 )
  {
    *(_DWORD *)(a2 + 20376) = v12;
    *(_DWORD *)(a2 + 20380) = *(_DWORD *)(a4 + 1568) - v12;
  }
  *(_DWORD *)a2 = v6;
  v15 = *(void **)(a1 + 4);
  if ( !v15 )
    v15 = &unk_100996C3;
  v42 = *(_DWORD *)(a1 + 28);
  if ( v42 )
    v16 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4);
  else
    v16 = 0;
  sub_10087610(a3, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), v16, v42, a6, v15);
  if ( *(_DWORD *)(a2 + 15660) )
    *(_DWORD *)(a2 + 15660) = 0;
  *(_DWORD *)(a2 + 15684) = 0;
  *(_DWORD *)(a2 + 17252) = 0;
  *(_DWORD *)(a2 + 18828) = 0;
  v43 = 0;
  if ( *(_DWORD *)(a1 + 28) > 0u )
  {
    v44 = 0;
    do
    {
      v46 = 0;
      if ( sub_100323E0(a1) )
      {
        do
        {
          v17 = *(_DWORD *)(*(_DWORD *)(v44 + *(_DWORD *)(a1 + 24)) + 4 * v46);
          *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a3 + 24) + v44) + 4 * v46) + 24) = *(_DWORD *)(v17 + 24);
          v61 = 0;
          v62 = 0;
          v63 = 0;
          v64 = 0;
          v65 = 15;
          v66 = 0;
          v67 = 0;
          v68 = 0;
          v69 = 0;
          v72 = 0;
          v18 = *(int **)(v17 + 16);
          if ( v18 || *(_DWORD *)(v17 + 20) )
          {
            if ( *(_DWORD *)(v17 + 20) )
            {
              sub_100859B0((int)&v61, *(_DWORD *)(v17 + 20));
              v65 = *(_DWORD *)(v17 + 8);
              sub_10086CC0(v17, (int)&v61);
              v18 = &v61;
            }
          }
          else
          {
            v18 = 0;
          }
          v52 = 0;
          v53 = 0;
          v54 = 0;
          v55 = 0;
          v56 = 15;
          v57 = 0;
          v58 = 0;
          v59 = 0;
          v60 = 0;
          LOBYTE(v72) = 1;
          sub_10033C70((int)&v52, (int)v18);
          LOBYTE(v72) = 2;
          v19 = *(_DWORD *)(a2 + 15660);
          v20 = (unsigned int)(v53 + 3) >> 2;
          v21 = (unsigned int)(v52 + 3) >> 2;
          v22 = v19 + v21 * v20;
          v23 = *(_DWORD *)(a2 + 15660);
          v50 = (unsigned int)(v52 + 3) >> 2;
          v51 = (unsigned int)(v53 + 3) >> 2;
          v40 = v22;
          if ( v22 != v23 )
          {
            if ( v22 >= v23 && v22 > *(_DWORD *)(a2 + 15664) )
            {
              sub_100943C0(v22, 0, a2 + 15656, v22 == v23 + 1, 0x40u, 0);
              v22 = v40;
            }
            *(_DWORD *)(a2 + 15660) = v22;
          }
          v24 = a2 + 12 * *(_DWORD *)(a2 + 15684) + 15688;
          v25 = *(_DWORD *)(a2 + 15656) + (v19 << 6);
          *(_DWORD *)v24 = v19;
          *(_DWORD *)(v24 + 4) = v21;
          *(_DWORD *)(v24 + 8) = v20;
          ++*(_DWORD *)(a2 + 15684);
          v26 = a2 + 4 * (3 * *(_DWORD *)(a2 + 17252) + 4314);
          *(_DWORD *)v26 = v19;
          *(_DWORD *)(v26 + 4) = v21;
          *(_DWORD *)(v26 + 8) = v20;
          v27 = *(_DWORD *)(a2 + 18828);
          ++*(_DWORD *)(a2 + 17252);
          v28 = a2 + 12 * v27 + 18832;
          *(_DWORD *)v28 = v19;
          *(_DWORD *)(v28 + 4) = v21;
          *(_DWORD *)(v28 + 8) = v20;
          ++*(_DWORD *)(a2 + 18828);
          v45 = 0;
          if ( v20 )
          {
            do
            {
              v41 = 0;
              if ( v21 )
              {
                do
                {
                  v29 = v25;
                  v48 = v25 + 64;
                  v30 = 4 * v45;
                  v49 = 4;
                  do
                  {
                    v31 = 4 * v41;
                    v47 = 4;
                    do
                    {
                      v32 = v29;
                      v29 += 4;
                      v33 = v30;
                      v34 = v31;
                      if ( v31 >= 0 )
                      {
                        if ( v31 > v52 - 1 )
                          v34 = v52 - 1;
                      }
                      else
                      {
                        v34 = 0;
                      }
                      if ( v30 >= 0 )
                      {
                        if ( v30 > v53 - 1 )
                          v33 = v53 - 1;
                      }
                      else
                      {
                        v33 = 0;
                      }
                      v35 = v57 + 4 * (v34 + v33 * v54);
                      *(_BYTE *)v32 = *(_BYTE *)v35;
                      *(_BYTE *)(v32 + 1) = *(_BYTE *)(v35 + 1);
                      *(_BYTE *)(v32 + 2) = *(_BYTE *)(v35 + 2);
                      *(_BYTE *)(v32 + 3) = *(_BYTE *)(v35 + 3);
                      ++v31;
                      --v47;
                    }
                    while ( v47 );
                    ++v30;
                    --v49;
                  }
                  while ( v49 );
                  v21 = v50;
                  v36 = v41 + 1;
                  v41 = v36;
                  v37 = v36 < v50;
                  v25 = v48;
                }
                while ( v37 );
                v20 = v51;
              }
              ++v45;
            }
            while ( v45 < v20 );
          }
          LOBYTE(v72) = 0;
          if ( v58 )
          {
            if ( (unsigned __int8)v58 & 7 )
            {
              sprintf_s(
                &DstBuf,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_free: bad ptr");
              OutputDebugStringA(&DstBuf);
              v38 = _iob_func();
              fputs(&DstBuf, v38 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v58, 0, 0, 1, dword_100AE9F4);
            }
          }
          v72 = -1;
          if ( v67 )
          {
            if ( (unsigned __int8)v67 & 7 )
            {
              sprintf_s(
                &OutputString,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_free: bad ptr");
              OutputDebugStringA(&OutputString);
              v39 = _iob_func();
              fputs(&OutputString, v39 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v67, 0, 0, 1, dword_100AE9F4);
            }
          }
          ++v46;
          v7 = 0;
        }
        while ( v46 < sub_100323E0(a1) );
      }
      v44 += 12;
      ++v43;
    }
    while ( v43 < *(_DWORD *)(a1 + 28) );
  }
  if ( *(_BYTE *)(a2 + 20392) != v7
    && !sub_1006F060(a2 + 8, *(_DWORD *)(a2 + 15660), *(_DWORD *)(a2 + 15656), (const void *)(a2 + 15668))
    || *(_BYTE *)(a2 + 20393) != v7
    && !sub_1006C8E0(*(void **)(a2 + 15660), a2 + 5224, *(_DWORD *)(a2 + 15656), (const void *)(a2 + 17240))
    || *(_BYTE *)(a2 + 20394) != v7
    && !sub_1006C8E0(*(void **)(a2 + 15660), a2 + 10440, *(_DWORD *)(a2 + 15656), (const void *)(a2 + 18816)) )
  {
    return 0;
  }
  return 1;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10088740) --------------------------------------------------------
char __stdcall sub_10088740(int a1, int a2, int a3, unsigned int a4, char *a5)
{
  unsigned int v5; // eax@1
  int v6; // ebp@5
  int v7; // ebp@18
  int **v9; // edi@21
  int *v10; // esi@21
  int *v11; // [sp+10h] [bp-40h]@7
  int **v12; // [sp+14h] [bp-3Ch]@21
  int v13; // [sp+18h] [bp-38h]@21
  int v14; // [sp+1Ch] [bp-34h]@21
  int v15; // [sp+20h] [bp-30h]@5
  int v16; // [sp+24h] [bp-2Ch]@5
  int v17; // [sp+28h] [bp-28h]@5
  int v18; // [sp+2Ch] [bp-24h]@5
  int v19; // [sp+30h] [bp-20h]@5
  int v20; // [sp+34h] [bp-1Ch]@5
  int v21; // [sp+38h] [bp-18h]@5
  int v22; // [sp+3Ch] [bp-14h]@5
  int v23; // [sp+40h] [bp-10h]@5
  int v24; // [sp+4Ch] [bp-4h]@5

  v5 = *(_DWORD *)(a1 + 28);
  if ( !v5 || v5 > 1 || a4 < 1 || (unsigned int)a5 < 1 )
    return 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 15;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v6 = ***(_DWORD ***)(a1 + 24);
  if ( !*(_DWORD *)(v6 + 16) && !*(_DWORD *)(v6 + 20) )
  {
    v11 = 0;
    goto LABEL_18;
  }
  if ( *(_DWORD *)(v6 + 20) )
  {
    sub_100859B0((int)&v15, *(_DWORD *)(v6 + 20));
    v19 = *(_DWORD *)(v6 + 8);
    sub_10086CC0(v6, (int)&v15);
  }
  else
  {
    if ( !(*(_BYTE *)(v6 + 24) & 3) )
    {
      v11 = *(int **)(v6 + 16);
      goto LABEL_18;
    }
    sub_10033C70((int)&v15, *(_DWORD *)(v6 + 16));
  }
  if ( *(_BYTE *)(v6 + 24) & 1 )
    sub_10033D30((int)&v15);
  if ( *(_BYTE *)(v6 + 24) & 2 )
    sub_10033E00((int)&v15);
  v11 = &v15;
LABEL_18:
  v7 = sub_10034570((int *)&a4, (int *)&a5);
  if ( !sub_10033F70(a5, (int)v11, *(void **)(v7 + 20), a2, a3, a4) )
  {
    v24 = -1;
    sub_100336C0(&v15);
    return 0;
  }
  v12 = 0;
  v13 = 0;
  v14 = 0;
  sub_10033720((int)&v12, 1u);
  LOBYTE(v24) = 1;
  v9 = v12;
  sub_100366C0((int)v12, 1u);
  v10 = *v9;
  *v10 = sub_100337E0();
  *(_DWORD *)(v7 + 16) = v11[4];
  sub_10087550(v7, **v9, 0, 0);
  sub_10087B40(a1, (int)&v12);
  LOBYTE(v24) = 0;
  sub_10041BD0((int)&v12);
  v24 = -1;
  sub_100336C0(&v15);
  return 1;
}

//----- (10088920) --------------------------------------------------------
char __stdcall sub_10088920(int a1, int a2)
{
  int v2; // esi@1
  unsigned int v3; // eax@2
  unsigned int v4; // ecx@2
  unsigned int v5; // edx@2
  unsigned int v6; // ebx@2
  unsigned int v7; // eax@6
  unsigned int v8; // esi@13
  int v9; // eax@14
  char *v10; // esi@18
  int v11; // eax@19
  unsigned int v12; // edi@25
  int v13; // eax@26
  FILE *v14; // eax@28
  void *v15; // edx@35
  int *v16; // ecx@35
  int v17; // esi@35
  int *v18; // eax@35
  signed int v19; // edi@43
  signed int v20; // esi@45
  int v21; // eax@47
  FILE *v22; // eax@49
  int v23; // ebx@51
  unsigned int v24; // edx@55
  bool v25; // zf@55
  int v26; // edx@55
  char v27; // al@55
  char v28; // al@57
  int v29; // ecx@63
  int v30; // esi@63
  int v31; // ebx@63
  int v32; // eax@64
  FILE *v33; // eax@69
  int *v34; // ebx@73
  int v35; // eax@74
  FILE *v36; // eax@79
  int v37; // ecx@83
  int v38; // eax@83
  FILE *v39; // eax@90
  void *v40; // ecx@95
  int v41; // eax@95
  int v42; // edx@95
  void *v43; // eax@95
  unsigned int v44; // eax@95
  void *v45; // ebx@96
  int v46; // eax@100
  int v47; // eax@109
  int v48; // ebx@110
  int v49; // eax@111
  FILE *v50; // eax@113
  FILE *v51; // eax@117
  int *v52; // ebx@120
  int v53; // eax@121
  FILE *v54; // eax@123
  FILE *v55; // eax@127
  FILE *v56; // eax@131
  FILE *v57; // eax@138
  void *v58; // ecx@141
  char *v59; // edi@142
  char *v60; // esi@142
  int v61; // eax@143
  FILE *v62; // eax@145
  FILE *v63; // eax@151
  unsigned int v65; // [sp+14h] [bp-1088h]@18
  int v66; // [sp+14h] [bp-1088h]@34
  unsigned int v67; // [sp+14h] [bp-1088h]@108
  int v68; // [sp+18h] [bp-1084h]@42
  char *v69; // [sp+18h] [bp-1084h]@107
  void *v70; // [sp+1Ch] [bp-1080h]@17
  unsigned int v71; // [sp+20h] [bp-107Ch]@17
  int v72; // [sp+24h] [bp-1078h]@17
  int *v73; // [sp+28h] [bp-1074h]@37
  void *v74; // [sp+2Ch] [bp-1070h]@22
  int v75; // [sp+30h] [bp-106Ch]@47
  int v76; // [sp+34h] [bp-1068h]@52
  unsigned int v77; // [sp+38h] [bp-1064h]@6
  int v78; // [sp+3Ch] [bp-1060h]@26
  int v79; // [sp+40h] [bp-105Ch]@63
  int v80; // [sp+44h] [bp-1058h]@35
  int v81; // [sp+48h] [bp-1054h]@35
  int v82; // [sp+4Ch] [bp-1050h]@35
  int v83; // [sp+50h] [bp-104Ch]@35
  int v84; // [sp+54h] [bp-1048h]@35
  int v85; // [sp+58h] [bp-1044h]@35
  void *v86; // [sp+5Ch] [bp-1040h]@35
  int v87; // [sp+60h] [bp-103Ch]@35
  int v88; // [sp+64h] [bp-1038h]@35
  int v89; // [sp+68h] [bp-1034h]@55
  int v90; // [sp+6Ch] [bp-1030h]@55
  int v91; // [sp+70h] [bp-102Ch]@55
  float v92; // [sp+74h] [bp-1028h]@55
  char v93; // [sp+78h] [bp-1024h]@55
  char v94; // [sp+79h] [bp-1023h]@55
  int v95; // [sp+7Ch] [bp-1020h]@55
  int v96; // [sp+80h] [bp-101Ch]@55
  float v97; // [sp+84h] [bp-1018h]@55
  char v98; // [sp+88h] [bp-1014h]@55
  CHAR v99; // [sp+8Ch] [bp-1010h]@79
  CHAR v100; // [sp+28Ch] [bp-E10h]@69
  char DstBuf; // [sp+48Ch] [bp-C10h]@28
  CHAR v102; // [sp+68Ch] [bp-A10h]@145
  CHAR OutputString; // [sp+88Ch] [bp-810h]@49
  CHAR v104; // [sp+A8Ch] [bp-610h]@90
  CHAR v105; // [sp+C8Ch] [bp-410h]@138
  CHAR v106; // [sp+E8Ch] [bp-210h]@131
  int v107; // [sp+1098h] [bp-4h]@17

  v2 = *(_DWORD *)(a1 + 28);
  if ( !v2 )
    return 0;
  v3 = *(_DWORD *)(a1 + 8);
  v4 = *(_DWORD *)(a1 + 12);
  v5 = *(_DWORD *)(a2 + 20);
  v6 = 1;
  while ( v3 > v5 || v4 > v5 )
  {
    v3 >>= 1;
    v4 >>= 1;
    ++v6;
  }
  v7 = *(_DWORD *)(a2 + 24);
  v77 = v6;
  if ( v7 && v6 > v7 )
  {
    v6 = v7;
    v77 = v7;
  }
  if ( v2 && *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4) > 1u && v2 )
    sub_10086E20(a1);
  v8 = *(_DWORD *)(a1 + 28);
  if ( v8 )
    v9 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4);
  else
    v9 = 0;
  if ( v6 == v9 )
    return 1;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  sub_10033720((int)&v70, v8);
  v107 = 0;
  if ( v71 )
  {
    v10 = (char *)v70 + 4;
    v65 = v71;
    do
    {
      v11 = *(_DWORD *)v10;
      if ( v6 != *(_DWORD *)v10 )
      {
        if ( v6 >= *(_DWORD *)v10 )
        {
          if ( v6 > *((_DWORD *)v10 + 1) )
          {
            LOBYTE(v74) = v6 == v11 + 1;
            sub_100943C0(v6, 0, (int)(v10 - 4), v6 == v11 + 1, 4u, 0);
          }
          memset((void *)(*((_DWORD *)v10 - 1) + 4 * *(_DWORD *)v10), 0, 4 * (v6 - *(_DWORD *)v10));
        }
        *(_DWORD *)v10 = v6;
      }
      v12 = 0;
      if ( v6 )
      {
        do
        {
          v78 = 28;
          v13 = off_100AD9F4(0, 28, &v78, 1, dword_100AE9F4);
          if ( v13 && (unsigned int)v78 >= 0x1C )
          {
            *(_DWORD *)v13 = 0;
            *(_DWORD *)(v13 + 4) = 0;
            *(_DWORD *)(v13 + 8) = 15;
            *(_DWORD *)(v13 + 12) = 0;
            *(_DWORD *)(v13 + 16) = 0;
            *(_DWORD *)(v13 + 20) = 0;
            *(_DWORD *)(v13 + 24) = 0;
          }
          else
          {
            sprintf_s(
              &DstBuf,
              0x200u,
              "%s(%u): Assertion failed: \"%s\"\n",
              "crn_mem.cpp",
              216,
              "crnlib_malloc: out of memory");
            OutputDebugStringA(&DstBuf);
            v14 = _iob_func();
            fputs(&DstBuf, v14 + 2);
            if ( IsDebuggerPresent() )
              DebugBreak();
            v13 = 0;
          }
          *(_DWORD *)(*((_DWORD *)v10 - 1) + 4 * v12++) = v13;
        }
        while ( v12 < v6 );
      }
      v10 += 12;
      --v65;
    }
    while ( v65 );
  }
  v74 = 0;
  if ( !v71 )
  {
LABEL_94:
    if ( v71 )
    {
      sub_10087040(a1);
      v40 = v70;
      v41 = **(_DWORD **)v70;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)v41;
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(v41 + 4);
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(v41 + 8);
      v42 = v72;
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(v41 + 12);
      v43 = *(void **)(a1 + 24);
      *(_DWORD *)(a1 + 24) = v40;
      v70 = v43;
      v44 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(a1 + 28) = v71;
      v71 = v44;
      *(_DWORD *)(a1 + 32) = v42;
    }
    v45 = v70;
    v107 = -1;
    if ( v70 )
    {
      sub_1003E4E0(v71, (int *)v70);
      if ( (unsigned __int8)v45 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v45, 0, 0, 1, dword_100AE9F4);
    }
    return 1;
  }
  v66 = 0;
  while ( 1 )
  {
    v15 = 0;
    v80 = 0;
    v81 = 0;
    v82 = 0;
    v83 = 0;
    v84 = 15;
    v85 = 0;
    v86 = 0;
    v87 = 0;
    v88 = 0;
    LOBYTE(v107) = 1;
    v16 = *(int **)(v66 + *(_DWORD *)(a1 + 24));
    v17 = *v16;
    v18 = *(int **)(*v16 + 16);
    if ( v18 || *(_DWORD *)(v17 + 20) )
    {
      if ( *(_DWORD *)(v17 + 20) )
      {
        sub_100859B0((int)&v80, *(_DWORD *)(v17 + 20));
        v84 = *(_DWORD *)(v17 + 8);
        sub_10086CC0(v17, (int)&v80);
        v15 = v86;
        v18 = &v80;
      }
      v73 = v18;
    }
    else
    {
      v73 = 0;
    }
    v68 = 0;
    if ( v77 > 0 )
      break;
LABEL_88:
    LOBYTE(v107) = 0;
    if ( v15 )
    {
      if ( (unsigned __int8)v15 & 7 )
      {
        sprintf_s(&v104, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&v104);
        v39 = _iob_func();
        fputs(&v104, v39 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v15, 0, 0, 1, dword_100AE9F4);
      }
    }
    v66 += 12;
    v74 = (char *)v74 + 1;
    if ( (unsigned int)v74 >= v71 )
      goto LABEL_94;
  }
  while ( 1 )
  {
    v19 = 1;
    if ( *(_DWORD *)(a1 + 8) >> v68 >= 1u )
      v19 = *(_DWORD *)(a1 + 8) >> v68;
    v20 = 1;
    if ( *(_DWORD *)(a1 + 12) >> v68 >= 1u )
      v20 = *(_DWORD *)(a1 + 12) >> v68;
    v75 = 36;
    v21 = off_100AD9F4(0, 36, &v75, 1, dword_100AE9F4);
    if ( v21 && (unsigned int)v75 >= 0x24 )
    {
      *(_DWORD *)v21 = 0;
      *(_DWORD *)(v21 + 4) = 0;
      *(_DWORD *)(v21 + 8) = 0;
      *(_DWORD *)(v21 + 12) = 0;
      *(_DWORD *)(v21 + 16) = 15;
      *(_DWORD *)(v21 + 20) = 0;
      *(_DWORD *)(v21 + 24) = 0;
      *(_DWORD *)(v21 + 28) = 0;
      *(_DWORD *)(v21 + 32) = 0;
      v23 = v21;
    }
    else
    {
      sprintf_s(
        &OutputString,
        0x200u,
        "%s(%u): Assertion failed: \"%s\"\n",
        "crn_mem.cpp",
        216,
        "crnlib_malloc: out of memory");
      OutputDebugStringA(&OutputString);
      v22 = _iob_func();
      fputs(&OutputString, v22 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
      v23 = 0;
    }
    v76 = v23;
    if ( v68 )
      break;
    sub_10033C70(v23, (int)v73);
LABEL_63:
    v29 = *(_DWORD *)((char *)v70 + v66);
    v79 = *(_DWORD *)(**(_DWORD **)(v66 + *(_DWORD *)(a1 + 24)) + 24);
    v30 = *(_DWORD *)(v29 + 4 * v68);
    v31 = *(_DWORD *)(v30 + 16);
    *(_DWORD *)v30 = 0;
    *(_DWORD *)(v30 + 4) = 0;
    *(_DWORD *)(v30 + 8) = 15;
    *(_DWORD *)(v30 + 12) = 0;
    *(_DWORD *)(v30 + 24) = 0;
    if ( v31 )
    {
      v32 = *(_DWORD *)(v31 + 24);
      if ( v32 )
      {
        if ( v32 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v32, 0, 0, 1, dword_100AE9F4);
      }
      if ( v31 & 7 )
      {
        sprintf_s(&v100, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&v100);
        v33 = _iob_func();
        fputs(&v100, v33 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v31, 0, 0, 1, dword_100AE9F4);
      }
      *(_DWORD *)(v30 + 16) = 0;
    }
    v34 = *(int **)(v30 + 20);
    if ( v34 )
    {
      v35 = *v34;
      if ( *v34 )
      {
        if ( v35 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v35, 0, 0, 1, dword_100AE9F4);
      }
      if ( (unsigned __int8)v34 & 7 )
      {
        sprintf_s(&v99, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&v99);
        v36 = _iob_func();
        fputs(&v99, v36 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v34, 0, 0, 1, dword_100AE9F4);
      }
      *(_DWORD *)(v30 + 20) = 0;
    }
    v37 = v76;
    *(_DWORD *)(v30 + 16) = v76;
    *(_DWORD *)v30 = *(_DWORD *)v37;
    v38 = v79;
    *(_DWORD *)(v30 + 4) = *(_DWORD *)(v37 + 4);
    *(_DWORD *)(v30 + 24) = v38;
    if ( (*(_DWORD *)(v37 + 16) >> 4) & 1 )
      *(_DWORD *)(v30 + 12) = ((*(_DWORD *)(v37 + 16) >> 3) & 1) != 0 ? 1098414156 : 2021161036;
    else
      *(_DWORD *)(v30 + 12) = ((*(_DWORD *)(v37 + 16) >> 3) & 1) != 0 ? 1094862674 : 2017609554;
    *(_DWORD *)(v30 + 8) = *(_DWORD *)(v37 + 16);
    if ( ++v68 >= v77 )
    {
      v15 = v86;
      goto LABEL_88;
    }
  }
  v95 = 0;
  v97 = 2.2;
  v24 = v73[4];
  v92 = *(float *)(a2 + 8);
  v25 = ((v24 >> 3) & 1) == 0;
  v93 = *(_BYTE *)(a2 + 5);
  v26 = *(_DWORD *)a2;
  v89 = v19;
  v90 = v20;
  v91 = v26;
  v96 = !v25 + 3;
  v27 = *(_BYTE *)(a2 + 16);
  v94 = *(_BYTE *)(a2 + 4);
  v98 = v27;
  if ( v27 && (unsigned int)dword_100AD974 > 1 )
    v28 = sub_1007B7A0((int)v73, v23, (int)&v89);
  else
    v28 = sub_1007BF30((int)v73, v23, (int)&v89);
  if ( v28 )
  {
    if ( *(_BYTE *)(a2 + 6) )
    {
      v23 = v76;
      sub_1007B1D0(v76);
    }
    *(_DWORD *)(v23 + 16) = v73[4];
    goto LABEL_63;
  }
  if ( v23 )
  {
    v46 = *(_DWORD *)(v23 + 24);
    if ( v46 )
    {
      if ( v46 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v46, 0, 0, 1, dword_100AE9F4);
    }
    if ( v23 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v23, 0, 0, 1, dword_100AE9F4);
  }
  v69 = (char *)v70 + 4;
  v75 = v71;
  do
  {
    v67 = 0;
    if ( *(_DWORD *)v69 )
    {
      do
      {
        v47 = *(_DWORD *)(*((_DWORD *)v69 - 1) + 4 * v67);
        v74 = (void *)v47;
        if ( v47 )
        {
          v48 = *(_DWORD *)(v47 + 16);
          if ( v48 )
          {
            v49 = *(_DWORD *)(v48 + 24);
            if ( v49 )
            {
              if ( v49 & 7 )
              {
                sprintf_s(
                  &v99,
                  0x200u,
                  "%s(%u): Assertion failed: \"%s\"\n",
                  "crn_mem.cpp",
                  216,
                  "crnlib_free: bad ptr");
                OutputDebugStringA(&v99);
                v50 = _iob_func();
                fputs(&v99, v50 + 2);
                if ( IsDebuggerPresent() )
                  DebugBreak();
              }
              else
              {
                off_100AD9F4(v49, 0, 0, 1, dword_100AE9F4);
              }
            }
            if ( v48 & 7 )
            {
              sprintf_s(&v100, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
              OutputDebugStringA(&v100);
              v51 = _iob_func();
              fputs(&v100, v51 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v48, 0, 0, 1, dword_100AE9F4);
            }
          }
          v52 = (int *)*((_DWORD *)v74 + 5);
          if ( v52 )
          {
            v53 = *v52;
            if ( *v52 )
            {
              if ( v53 & 7 )
              {
                sprintf_s(
                  &OutputString,
                  0x200u,
                  "%s(%u): Assertion failed: \"%s\"\n",
                  "crn_mem.cpp",
                  216,
                  "crnlib_free: bad ptr");
                OutputDebugStringA(&OutputString);
                v54 = _iob_func();
                fputs(&OutputString, v54 + 2);
                if ( IsDebuggerPresent() )
                  DebugBreak();
              }
              else
              {
                off_100AD9F4(v53, 0, 0, 1, dword_100AE9F4);
              }
            }
            if ( (unsigned __int8)v52 & 7 )
            {
              sprintf_s(
                &DstBuf,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_free: bad ptr");
              OutputDebugStringA(&DstBuf);
              v55 = _iob_func();
              fputs(&DstBuf, v55 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v52, 0, 0, 1, dword_100AE9F4);
            }
          }
          if ( (unsigned __int8)v74 & 7 )
          {
            sprintf_s(&v106, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
            OutputDebugStringA(&v106);
            v56 = _iob_func();
            fputs(&v106, v56 + 2);
            if ( IsDebuggerPresent() )
              DebugBreak();
          }
          else
          {
            off_100AD9F4(v74, 0, 0, 1, dword_100AE9F4);
          }
        }
        ++v67;
      }
      while ( v67 < *(_DWORD *)v69 );
    }
    v69 += 12;
    --v75;
  }
  while ( v75 );
  LOBYTE(v107) = 0;
  if ( v86 )
  {
    if ( (unsigned __int8)v86 & 7 )
    {
      sprintf_s(&v105, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&v105);
      v57 = _iob_func();
      fputs(&v105, v57 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(v86, 0, 0, 1, dword_100AE9F4);
    }
  }
  v107 = -1;
  v58 = v70;
  if ( v70 )
  {
    v59 = (char *)v70 + 12 * v71;
    v60 = (char *)v70;
    if ( v70 != v59 )
    {
      do
      {
        v61 = *(_DWORD *)v60;
        if ( *(_DWORD *)v60 )
        {
          if ( v61 & 7 )
          {
            sprintf_s(&v102, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
            OutputDebugStringA(&v102);
            v62 = _iob_func();
            fputs(&v102, v62 + 2);
            if ( IsDebuggerPresent() )
              DebugBreak();
          }
          else
          {
            off_100AD9F4(v61, 0, 0, 1, dword_100AE9F4);
          }
        }
        v60 += 12;
      }
      while ( v60 != v59 );
      v58 = v70;
    }
    if ( (unsigned __int8)v58 & 7 )
    {
      sprintf_s(&v102, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&v102);
      v63 = _iob_func();
      fputs(&v102, v63 + 2);
      if ( IsDebuggerPresent() )
      {
        DebugBreak();
        return 0;
      }
    }
    else
    {
      off_100AD9F4(v58, 0, 0, 1, dword_100AE9F4);
    }
  }
  return 0;
}
// 100AD974: using guessed type int dword_100AD974;
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10089610) --------------------------------------------------------
char __userpurge sub_10089610@<al>(int a1@<eax>, int a2, int a3, int a4, int a5)
{
  void *v5; // esp@1
  unsigned int v6; // esi@1
  char *v7; // esi@3
  int v8; // edi@3
  int v9; // eax@10
  int *v10; // ecx@13
  int v11; // esi@14
  void (__cdecl *v12)(const char *, FILE *); // ebx@14
  int *v13; // edx@16
  int v14; // esi@16
  int v15; // eax@23
  void (__stdcall *v16)(LPCSTR); // esi@25
  FILE *(__cdecl *v17)(); // edi@25
  FILE *v18; // eax@25
  int v19; // ecx@28
  double v20; // st7@28
  char v21; // al@28
  char v22; // al@30
  void *v23; // ecx@43
  int v24; // eax@43
  void *v25; // eax@43
  int v26; // eax@43
  FILE *v27; // eax@46
  int v28; // eax@49
  int v29; // eax@58
  int v30; // eax@59
  int v31; // eax@60
  FILE *v32; // eax@62
  FILE *v33; // eax@66
  _DWORD *v34; // eax@69
  int v35; // eax@70
  FILE *v36; // eax@72
  FILE *v37; // eax@76
  FILE *v38; // eax@80
  FILE *v39; // eax@87
  char v40; // cl@90
  int v41; // eax@92
  FILE *v42; // eax@94
  FILE *v43; // eax@100
  void *v45; // [sp+0h] [bp-107Ch]@15
  _DWORD *v46; // [sp+0h] [bp-107Ch]@58
  char *v47; // [sp+0h] [bp-107Ch]@91
  int v48; // [sp+4h] [bp-1078h]@27
  void *v49; // [sp+4h] [bp-1078h]@57
  int *v50; // [sp+8h] [bp-1074h]@18
  char *v51; // [sp+8h] [bp-1074h]@56
  void *v52; // [sp+Ch] [bp-1070h]@14
  void *v53; // [sp+Ch] [bp-1070h]@59
  void *v54; // [sp+Ch] [bp-1070h]@69
  char *v55; // [sp+Ch] [bp-1070h]@91
  void *v56; // [sp+10h] [bp-106Ch]@2
  unsigned int v57; // [sp+14h] [bp-1068h]@2
  int v58; // [sp+18h] [bp-1064h]@2
  int v59; // [sp+1Ch] [bp-1060h]@23
  int v60; // [sp+20h] [bp-105Ch]@10
  int v61; // [sp+24h] [bp-1058h]@16
  int v62; // [sp+28h] [bp-1054h]@16
  int v63; // [sp+2Ch] [bp-1050h]@16
  int v64; // [sp+30h] [bp-104Ch]@16
  int v65; // [sp+34h] [bp-1048h]@16
  int v66; // [sp+38h] [bp-1044h]@16
  void *v67; // [sp+3Ch] [bp-1040h]@16
  int v68; // [sp+40h] [bp-103Ch]@16
  int v69; // [sp+44h] [bp-1038h]@16
  int v70; // [sp+48h] [bp-1034h]@28
  int v71; // [sp+4Ch] [bp-1030h]@28
  int v72; // [sp+50h] [bp-102Ch]@28
  float v73; // [sp+54h] [bp-1028h]@28
  char v74; // [sp+58h] [bp-1024h]@28
  char v75; // [sp+59h] [bp-1023h]@28
  int v76; // [sp+5Ch] [bp-1020h]@28
  int v77; // [sp+60h] [bp-101Ch]@28
  float v78; // [sp+64h] [bp-1018h]@28
  char v79; // [sp+68h] [bp-1014h]@28
  CHAR v80; // [sp+6Ch] [bp-1010h]@94
  char DstBuf; // [sp+26Ch] [bp-E10h]@25
  CHAR v82; // [sp+46Ch] [bp-C10h]@76
  CHAR v83; // [sp+66Ch] [bp-A10h]@87
  CHAR v84; // [sp+86Ch] [bp-810h]@66
  CHAR v85; // [sp+A6Ch] [bp-610h]@72
  CHAR v86; // [sp+C6Ch] [bp-410h]@80
  CHAR OutputString; // [sp+E6Ch] [bp-210h]@46
  int v88; // [sp+1070h] [bp-Ch]@1
  int (__thiscall *v89)(void *); // [sp+1074h] [bp-8h]@1
  int v90; // [sp+1078h] [bp-4h]@1

  v90 = -1;
  v89 = sub_100971B3;
  v88 = a1;
  v5 = alloca(4208);
  v6 = *(_DWORD *)(a2 + 28);
  if ( !v6 )
    return 0;
  v56 = 0;
  v57 = 0;
  v58 = 0;
  sub_10033720((int)&v56, v6);
  v90 = 0;
  if ( v57 > 0 )
  {
    v7 = (char *)v56 + 4;
    v8 = v57;
    do
    {
      if ( *(_DWORD *)v7 != 1 )
      {
        if ( *(_DWORD *)v7 <= 1u )
        {
          if ( *((_DWORD *)v7 + 1) < 1u )
            sub_100943C0(1u, 0, (int)(v7 - 4), *(_DWORD *)v7 == 0, 4u, 0);
          memset((void *)(*((_DWORD *)v7 - 1) + 4 * *(_DWORD *)v7), 0, 4 * (1 - *(_DWORD *)v7));
        }
        *(_DWORD *)v7 = 1;
      }
      v60 = 28;
      v9 = off_100AD9F4(0, 28, &v60, 1, dword_100AE9F4);
      if ( v9 && (unsigned int)v60 >= 0x1C )
      {
        *(_DWORD *)v9 = 0;
        *(_DWORD *)(v9 + 4) = 0;
        *(_DWORD *)(v9 + 8) = 15;
        *(_DWORD *)(v9 + 12) = 0;
        *(_DWORD *)(v9 + 16) = 0;
        *(_DWORD *)(v9 + 20) = 0;
        *(_DWORD *)(v9 + 24) = 0;
      }
      else
      {
        sub_100927E0((int)"crnlib_malloc: out of memory");
        v9 = 0;
      }
      v10 = (int *)*((_DWORD *)v7 - 1);
      v7 += 12;
      --v8;
      *v10 = v9;
    }
    while ( v8 );
  }
  v11 = v57;
  v12 = (void (__cdecl *)(const char *, FILE *))fputs;
  v52 = 0;
  if ( v57 )
  {
    v45 = 0;
    while ( 1 )
    {
      v61 = 0;
      v62 = 0;
      v63 = 0;
      v64 = 0;
      v65 = 15;
      v66 = 0;
      v67 = 0;
      v68 = 0;
      v69 = 0;
      LOBYTE(v90) = 1;
      v13 = *(int **)((char *)v45 + *(_DWORD *)(a2 + 24));
      v14 = *v13;
      if ( *(_DWORD *)(*v13 + 16) || *(_DWORD *)(v14 + 20) )
      {
        if ( *(_DWORD *)(v14 + 20) )
        {
          sub_100859B0((int)&v61, *(_DWORD *)(v14 + 20));
          v65 = *(_DWORD *)(v14 + 8);
          sub_10086CC0(v14, (int)&v61);
          v50 = &v61;
        }
        else
        {
          v50 = *(int **)(*v13 + 16);
        }
      }
      else
      {
        v50 = 0;
      }
      v59 = 36;
      v15 = off_100AD9F4(0, 36, &v59, 1, dword_100AE9F4);
      if ( v15 && (unsigned int)v59 >= 0x24 )
      {
        v17 = _iob_func;
        v16 = OutputDebugStringA;
        *(_DWORD *)v15 = 0;
        *(_DWORD *)(v15 + 4) = 0;
        *(_DWORD *)(v15 + 8) = 0;
        *(_DWORD *)(v15 + 12) = 0;
        *(_DWORD *)(v15 + 16) = 15;
        *(_DWORD *)(v15 + 20) = 0;
        *(_DWORD *)(v15 + 24) = 0;
        *(_DWORD *)(v15 + 28) = 0;
        *(_DWORD *)(v15 + 32) = 0;
        v48 = v15;
      }
      else
      {
        sprintf_s(
          &DstBuf,
          0x200u,
          "%s(%u): Assertion failed: \"%s\"\n",
          "crn_mem.cpp",
          216,
          "crnlib_malloc: out of memory");
        v16 = OutputDebugStringA;
        OutputDebugStringA(&DstBuf);
        v17 = _iob_func;
        v18 = _iob_func();
        v12(&DstBuf, v18 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
        v48 = 0;
      }
      v78 = 2.2;
      v76 = 0;
      v70 = a3;
      v19 = (((unsigned int)v50[4] >> 3) & 1) != 0;
      v71 = a4;
      v20 = *(float *)(a5 + 8);
      v74 = *(_BYTE *)(a5 + 5);
      v73 = v20;
      v72 = *(_DWORD *)a5;
      v77 = v19 + 3;
      v21 = *(_BYTE *)(a5 + 16);
      v75 = *(_BYTE *)(a5 + 4);
      v79 = v21;
      if ( v21 && (unsigned int)dword_100AD974 > 1 )
        v22 = sub_1007B7A0((int)v50, v48, (int)&v70);
      else
        v22 = sub_1007BF30((int)v50, v48, (int)&v70);
      if ( !v22 )
        break;
      if ( *(_BYTE *)(a5 + 6) )
      {
        sub_1007B1D0(v48);
        v12 = (void (__cdecl *)(const char *, FILE *))fputs;
      }
      *(_DWORD *)(v48 + 16) = v50[4];
      sub_10087550(
        v48,
        **(_DWORD **)((char *)v56 + (_DWORD)v45),
        0,
        *(_DWORD *)(**(_DWORD **)((char *)v45 + *(_DWORD *)(a2 + 24)) + 24));
      LOBYTE(v90) = 0;
      if ( v67 )
      {
        if ( (unsigned __int8)v67 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v67, 0, 0, 1, dword_100AE9F4);
      }
      v45 = (char *)v45 + 12;
      v52 = (char *)v52 + 1;
      if ( (unsigned int)v52 >= v57 )
      {
        v11 = v57;
        goto LABEL_42;
      }
    }
    if ( v48 )
    {
      v28 = *(_DWORD *)(v48 + 24);
      if ( v28 )
      {
        if ( v28 & 7 )
          sub_100927E0((int)"crnlib_free: bad ptr");
        else
          off_100AD9F4(v28, 0, 0, 1, dword_100AE9F4);
      }
      if ( v48 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v48, 0, 0, 1, dword_100AE9F4);
    }
    v51 = (char *)v56 + 4;
    v59 = v57;
    do
    {
      v49 = 0;
      if ( *(_DWORD *)v51 )
      {
        do
        {
          v29 = *(_DWORD *)(*((_DWORD *)v51 - 1) + 4 * (_DWORD)v49);
          v46 = (_DWORD *)v29;
          if ( v29 )
          {
            v30 = *(_DWORD *)(v29 + 16);
            v53 = (void *)v30;
            if ( v30 )
            {
              v31 = *(_DWORD *)(v30 + 24);
              if ( v31 )
              {
                if ( v31 & 7 )
                {
                  sprintf_s(
                    &DstBuf,
                    0x200u,
                    "%s(%u): Assertion failed: \"%s\"\n",
                    "crn_mem.cpp",
                    216,
                    "crnlib_free: bad ptr");
                  v16(&DstBuf);
                  v32 = v17();
                  v12(&DstBuf, v32 + 2);
                  if ( IsDebuggerPresent() )
                    DebugBreak();
                }
                else
                {
                  off_100AD9F4(v31, 0, 0, 1, dword_100AE9F4);
                }
              }
              if ( (unsigned __int8)v53 & 7 )
              {
                sprintf_s(
                  &v84,
                  0x200u,
                  "%s(%u): Assertion failed: \"%s\"\n",
                  "crn_mem.cpp",
                  216,
                  "crnlib_free: bad ptr");
                v16(&v84);
                v33 = v17();
                v12(&v84, v33 + 2);
                if ( IsDebuggerPresent() )
                  DebugBreak();
              }
              else
              {
                off_100AD9F4(v53, 0, 0, 1, dword_100AE9F4);
              }
            }
            v34 = (_DWORD *)v46[5];
            v54 = v34;
            if ( v34 )
            {
              v35 = *v34;
              if ( v35 )
              {
                if ( v35 & 7 )
                {
                  sprintf_s(
                    &v85,
                    0x200u,
                    "%s(%u): Assertion failed: \"%s\"\n",
                    "crn_mem.cpp",
                    216,
                    "crnlib_free: bad ptr");
                  v16(&v85);
                  v36 = v17();
                  v12(&v85, v36 + 2);
                  if ( IsDebuggerPresent() )
                    DebugBreak();
                }
                else
                {
                  off_100AD9F4(v35, 0, 0, 1, dword_100AE9F4);
                }
              }
              if ( (unsigned __int8)v54 & 7 )
              {
                sprintf_s(
                  &v82,
                  0x200u,
                  "%s(%u): Assertion failed: \"%s\"\n",
                  "crn_mem.cpp",
                  216,
                  "crnlib_free: bad ptr");
                v16(&v82);
                v37 = v17();
                v12(&v82, v37 + 2);
                if ( IsDebuggerPresent() )
                  DebugBreak();
              }
              else
              {
                off_100AD9F4(v54, 0, 0, 1, dword_100AE9F4);
              }
            }
            if ( (unsigned __int8)v46 & 7 )
            {
              sprintf_s(&v86, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
              v16(&v86);
              v38 = v17();
              v12(&v86, v38 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v46, 0, 0, 1, dword_100AE9F4);
            }
          }
          v49 = (char *)v49 + 1;
        }
        while ( (unsigned int)v49 < *(_DWORD *)v51 );
      }
      v51 += 12;
      --v59;
    }
    while ( v59 );
    LOBYTE(v90) = 0;
    if ( v67 )
    {
      if ( (unsigned __int8)v67 & 7 )
      {
        sprintf_s(&v83, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        v16(&v83);
        v39 = v17();
        v12(&v83, v39 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v67, 0, 0, 1, dword_100AE9F4);
      }
    }
    v90 = -1;
    v40 = (char)v56;
    if ( v56 )
    {
      v47 = (char *)v56;
      v55 = (char *)v56 + 12 * v57;
      if ( v56 != v55 )
      {
        do
        {
          v41 = *(_DWORD *)v47;
          if ( *(_DWORD *)v47 )
          {
            if ( v41 & 7 )
            {
              sprintf_s(&v80, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
              v16(&v80);
              v42 = v17();
              v12(&v80, v42 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v41, 0, 0, 1, dword_100AE9F4);
            }
          }
          v47 += 12;
        }
        while ( v47 != v55 );
        v40 = (char)v56;
      }
      if ( v40 & 7 )
      {
        sprintf_s(&v80, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        v16(&v80);
        v43 = v17();
        v12(&v80, v43 + 2);
        if ( IsDebuggerPresent() )
        {
          DebugBreak();
          return 0;
        }
      }
      else
      {
        off_100AD9F4(v56, 0, 0, 1, dword_100AE9F4);
      }
    }
    return 0;
  }
LABEL_42:
  if ( v11 )
  {
    sub_10087040(a2);
    v23 = v56;
    v24 = **(_DWORD **)v56;
    *(_DWORD *)(a2 + 8) = *(_DWORD *)v24;
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(v24 + 4);
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(v24 + 8);
    *(_DWORD *)(a2 + 20) = *(_DWORD *)(v24 + 12);
    v25 = *(void **)(a2 + 24);
    *(_DWORD *)(a2 + 24) = v23;
    v56 = v25;
    v26 = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a2 + 28) = v11;
    v11 = v26;
    *(_DWORD *)(a2 + 32) = v58;
  }
  v90 = -1;
  if ( v56 )
  {
    sub_1003E4E0(v11, (int *)v56);
    if ( (unsigned __int8)v56 & 7 )
    {
      sprintf_s(&OutputString, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
      OutputDebugStringA(&OutputString);
      v27 = _iob_func();
      v12(&OutputString, v27 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
    }
    else
    {
      off_100AD9F4(v56, 0, 0, 1, dword_100AE9F4);
    }
  }
  return 1;
}
// 100AD974: using guessed type int dword_100AD974;
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1008A020) --------------------------------------------------------
char __userpurge sub_1008A020@<al>(int a1@<eax>, int a2, int a3)
{
  int v3; // eax@1
  unsigned int v5; // eax@5
  int v6; // esi@5
  int v7; // ebx@5
  signed int v8; // ebp@5
  int v9; // edx@6
  signed int v10; // edi@10
  signed int v11; // eax@33
  int v12; // ecx@42
  void *v13; // ebx@43
  int v14; // esi@43
  int v15; // ebp@52
  int v16; // ebx@52
  int *v17; // edi@53
  unsigned int v18; // ebp@62
  int v19; // eax@66
  unsigned int v20; // eax@71
  int v21; // esi@71
  int v22; // eax@71
  unsigned int v23; // ebp@85
  unsigned int v24; // esi@85
  int v25; // edi@91
  int v26; // ecx@91
  int v27; // ebx@91
  signed int v28; // edx@92
  unsigned int v29; // eax@92
  unsigned int v30; // eax@96
  int v31; // edx@96
  int v32; // eax@97
  void *v33; // ebx@110
  unsigned int v34; // esi@118
  int v35; // [sp+0h] [bp-120h]@70
  char v36; // [sp+16h] [bp-10Ah]@10
  char v37; // [sp+17h] [bp-109h]@43
  void *v38; // [sp+18h] [bp-108h]@43
  unsigned int v39; // [sp+1Ch] [bp-104h]@43
  unsigned int v40; // [sp+20h] [bp-100h]@43
  int *v41; // [sp+24h] [bp-FCh]@71
  int v42; // [sp+28h] [bp-F8h]@89
  int v43; // [sp+2Ch] [bp-F4h]@49
  int v44; // [sp+30h] [bp-F0h]@51
  unsigned int v45; // [sp+34h] [bp-ECh]@71
  int v46; // [sp+38h] [bp-E8h]@48
  int v47; // [sp+3Ch] [bp-E4h]@71
  int v48; // [sp+40h] [bp-E0h]@53
  int v49; // [sp+44h] [bp-DCh]@53
  int v50; // [sp+48h] [bp-D8h]@53
  int v51; // [sp+4Ch] [bp-D4h]@53
  int v52; // [sp+50h] [bp-D0h]@53
  int v53; // [sp+54h] [bp-CCh]@53
  void *v54; // [sp+58h] [bp-C8h]@53
  int v55; // [sp+5Ch] [bp-C4h]@53
  int v56; // [sp+60h] [bp-C0h]@53
  int v57; // [sp+64h] [bp-BCh]@53
  int v58; // [sp+68h] [bp-B8h]@53
  int v59; // [sp+6Ch] [bp-B4h]@53
  __int16 v60; // [sp+70h] [bp-B0h]@53
  int v61; // [sp+74h] [bp-ACh]@53
  int v62; // [sp+78h] [bp-A8h]@53
  int v63; // [sp+7Ch] [bp-A4h]@53
  int v64; // [sp+80h] [bp-A0h]@5
  int v65; // [sp+84h] [bp-9Ch]@5
  int v66; // [sp+88h] [bp-98h]@5
  int v67; // [sp+8Ch] [bp-94h]@5
  unsigned int v68; // [sp+90h] [bp-90h]@28
  int v69; // [sp+98h] [bp-88h]@7
  int v70; // [sp+C8h] [bp-58h]@5
  int v71; // [sp+CCh] [bp-54h]@11
  int v72; // [sp+D0h] [bp-50h]@17
  unsigned int v73; // [sp+D4h] [bp-4Ch]@16
  int v74; // [sp+D8h] [bp-48h]@33
  int v75; // [sp+DCh] [bp-44h]@40
  int v76; // [sp+E0h] [bp-40h]@40
  int v77; // [sp+E4h] [bp-3Ch]@33
  int v78; // [sp+E8h] [bp-38h]@5
  int v79; // [sp+ECh] [bp-34h]@9
  char *v80; // [sp+104h] [bp-1Ch]@90
  int v81; // [sp+108h] [bp-18h]@64
  int v82; // [sp+10Ch] [bp-14h]@87
  int v83; // [sp+110h] [bp-10h]@4
  int v84; // [sp+114h] [bp-Ch]@1
  int (__thiscall *v85)(void *); // [sp+118h] [bp-8h]@1
  int v86; // [sp+11Ch] [bp-4h]@1

  v86 = -1;
  v85 = sub_100971DE;
  v84 = a1;
  v3 = a2 + 40;
  if ( !*(_DWORD *)(a2 + 8) )
  {
    sub_10092080(v3, "Nothing to write");
    return 0;
  }
  v83 = a2 + 40;
  sub_10092080(v3, "write_dds() failed");
  if ( (*(int (__stdcall **)(const char *, signed int))(**(_DWORD **)a3 + 20))("DDS ", 4) != 4 )
    return 0;
  memset(&v64, 0, 0x7Cu);
  v5 = *(_DWORD *)(a2 + 28);
  v6 = *(_DWORD *)(a2 + 8);
  v7 = *(_DWORD *)(a2 + 12);
  v8 = 4103;
  v64 = 124;
  v65 = 4103;
  v67 = v6;
  v66 = v7;
  v78 = 4096;
  v70 = 32;
  if ( v5 )
  {
    v9 = *(_DWORD *)(a2 + 24);
    if ( *(_DWORD *)(v9 + 4) > 1u )
    {
      v69 = *(_DWORD *)(v9 + 4);
      v8 = 135175;
      v78 = 4198408;
    }
  }
  if ( v5 > 1 )
  {
    v78 |= 8u;
    v79 |= 0xFE00u;
  }
  v10 = *(_DWORD *)(a2 + 20);
  v36 = 0;
  if ( sub_10033890(v10) )
  {
    v71 |= 4u;
    v36 = 1;
    if ( v10 <= 1380075384 )
    {
      if ( v10 == 1380075384 )
      {
        v73 = 1380075384;
        goto LABEL_27;
      }
      if ( v10 == 826496069 )
      {
        v72 = 826496069;
        v73 = 0;
      }
      else
      {
        if ( v10 != 1093752900 )
        {
          if ( v10 == 1380075329 )
          {
            v73 = 1380075329;
LABEL_27:
            v72 = 894720068;
            goto LABEL_28;
          }
LABEL_23:
          v72 = v10;
          v73 = 0;
          goto LABEL_28;
        }
        v72 = 827611204;
        v73 = 0;
      }
LABEL_28:
      v68 = sub_10033900(v10) * ((v6 + 3) & 0xFFFFFFFC) * ((v7 + 3) & 0xFFFFFFFC) >> 3;
      goto LABEL_42;
    }
    if ( v10 == 1383614328 )
    {
      v73 = 1383614328;
      goto LABEL_27;
    }
    if ( v10 == 1498952257 )
    {
      v72 = 843666497;
      v73 = 1498952257;
      goto LABEL_28;
    }
    if ( v10 == 1501053763 )
    {
      v73 = 1501053763;
      goto LABEL_27;
    }
    goto LABEL_23;
  }
  if ( v10 > 1098414200 )
  {
    if ( v10 != 2017609554 )
    {
      if ( v10 != 2021161036 )
        return 0;
      v71 |= 0x20000u;
      v11 = 8;
      v74 = 255;
      goto LABEL_41;
    }
    v71 |= 0x40u;
    v11 = 24;
    goto LABEL_40;
  }
  if ( v10 != 1098414200 )
  {
    if ( v10 != 1094862674 )
    {
      if ( v10 != 1098414156 )
        return 0;
      v71 |= 0x20001u;
      v11 = 16;
      v74 = 255;
      v77 = 65280;
      goto LABEL_41;
    }
    v71 |= 0x41u;
    v11 = 32;
    v77 = -16777216;
LABEL_40:
    v76 = 255;
    v75 = 65280;
    v74 = 16711680;
    goto LABEL_41;
  }
  v71 |= 2u;
  v11 = 8;
  v77 = 255;
LABEL_41:
  v73 = v11;
  v68 = (unsigned int)(v6 * v11) >> 3;
LABEL_42:
  v12 = *(_DWORD *)a3;
  v65 = v8 | 0x80000;
  if ( (*(int (__stdcall **)(int *, signed int))(*(_DWORD *)v12 + 20))(&v64, 124) != 124 )
    return 0;
  v13 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v14 = a2;
  v86 = 0;
  v37 = sub_10086BE0(a2);
  if ( *(_DWORD *)(a2 + 28) > 0u && *(_DWORD *)(***(_DWORD ***)(a2 + 24) + 20) && sub_10086A20(a2) && !sub_10086BE0(a2) )
    sub_10094340("mipmapped_texture::write_dds: One or more faces/miplevels cannot be unflipped without unpacking. Writing flipped .DDS texture.");
  v46 = 0;
  if ( *(_DWORD *)(a2 + 28) > 0u )
  {
    v43 = 0;
    while ( 1 )
    {
      v44 = 0;
      if ( !sub_100323E0(v14) )
        goto LABEL_120;
      do
      {
        v15 = *(_DWORD *)(*(_DWORD *)(v43 + *(_DWORD *)(a2 + 24)) + 4 * v44);
        v16 = 0;
        if ( !v36 )
        {
          v20 = *(_DWORD *)(v15 + 4);
          v21 = *(_DWORD *)(v15 + 16);
          v47 = *(_DWORD *)v15;
          v45 = v20;
          v41 = (int *)v21;
          v48 = 0;
          v49 = 0;
          v50 = 0;
          v51 = 0;
          v52 = 15;
          v53 = 0;
          v54 = 0;
          v55 = 0;
          v56 = 0;
          LOBYTE(v86) = 2;
          v22 = *(_DWORD *)(v15 + 24);
          if ( !(v22 & 3) )
            goto LABEL_85;
          if ( !v21 && !*(_DWORD *)(v15 + 20) )
          {
            v41 = 0;
            goto LABEL_85;
          }
          if ( *(_DWORD *)(v15 + 20) )
          {
            sub_100859B0((int)&v48, *(_DWORD *)(v15 + 20));
            v52 = *(_DWORD *)(v15 + 8);
            goto LABEL_79;
          }
          if ( v22 & 3 )
          {
            sub_10033C70((int)&v48, v21);
LABEL_79:
            if ( *(_BYTE *)(v15 + 24) & 1 )
              sub_10033D30((int)&v48);
            if ( *(_BYTE *)(v15 + 24) & 2 )
              sub_10033E00((int)&v48);
            v16 = (int)v54;
            v41 = &v48;
          }
          else
          {
            v41 = (int *)v21;
          }
LABEL_85:
          v23 = v73 >> 3;
          v24 = v47 * (v73 >> 3);
          if ( v39 < v24 )
          {
            if ( v24 > v40 )
            {
              LOBYTE(v82) = v24 == v39 + 1;
              sub_100943C0(v47 * (v73 >> 3), 0, (int)&v38, v24 == v39 + 1, 1u, 0);
            }
            memset((char *)v38 + v39, 0, v24 - v39);
            v39 = v24;
          }
          v42 = 0;
          if ( !v45 )
          {
LABEL_113:
            LOBYTE(v86) = 0;
            if ( !v16 )
              goto LABEL_118;
            if ( v16 & 7 )
            {
              sub_100927E0((int)"crnlib_free: bad ptr");
              goto LABEL_118;
            }
            v35 = dword_100AE9F4;
            goto LABEL_117;
          }
          v80 = (char *)v38 + 2;
          while ( 2 )
          {
            v25 = (int)v80;
            v26 = v41[5] + 4 * v42 * v41[2];
            v27 = v26 + 4 * v47;
LABEL_92:
            v28 = *(_DWORD *)(a2 + 20);
            v29 = 0;
            if ( v28 > 1098414200 )
            {
              if ( v28 != 2017609554 )
              {
                if ( v28 == 2021161036 )
                  v29 = (38470 * *(_BYTE *)(v26 + 1)
                       + 7471 * *(_BYTE *)(v26 + 2)
                       + 19595 * (unsigned int)*(_BYTE *)v26
                       + 0x8000) >> 16;
                goto LABEL_105;
              }
              v32 = *(_BYTE *)v26;
            }
            else
            {
              if ( v28 == 1098414200 )
              {
                v29 = *(_BYTE *)(v26 + 3);
                goto LABEL_105;
              }
              if ( v28 != 1094862674 )
              {
                if ( v28 == 1098414156 )
                {
                  v30 = (38470 * *(_BYTE *)(v26 + 1)
                       + 7471 * *(_BYTE *)(v26 + 2)
                       + 19595 * (unsigned int)*(_BYTE *)v26
                       + 0x8000) >> 16;
                  v31 = *(_BYTE *)(v26 + 3) << 8;
                  goto LABEL_104;
                }
                goto LABEL_105;
              }
              v32 = *(_BYTE *)v26 | (*(_BYTE *)(v26 + 3) << 8);
            }
            v31 = *(_BYTE *)(v26 + 2);
            v30 = (*(_BYTE *)(v26 + 1) | (v32 << 8)) << 8;
LABEL_104:
            v29 = v31 | v30;
LABEL_105:
            *(_BYTE *)(v25 - 2) = v29;
            if ( v23 > 1 )
            {
              *(_BYTE *)(v25 - 1) = BYTE1(v29);
              if ( v23 > 2 )
              {
                *(_BYTE *)v25 = v29 >> 16;
                if ( v23 > 3 )
                  *(_BYTE *)(v25 + 1) = BYTE3(v29);
              }
            }
            v26 += 4;
            v25 += v23;
            if ( v26 == v27 )
            {
              v33 = v38;
              if ( (*(int (__stdcall **)(void *, unsigned int))(**(_DWORD **)a3 + 20))(v38, v24) == v24 )
              {
                if ( ++v42 >= v45 )
                {
                  v16 = (int)v54;
                  goto LABEL_113;
                }
                continue;
              }
              LOBYTE(v86) = 0;
              if ( v54 )
              {
                if ( (unsigned __int8)v54 & 7 )
                  sub_100927E0((int)"crnlib_free: bad ptr");
                else
                  off_100AD9F4(v54, 0, 0, 1, dword_100AE9F4);
              }
              v86 = -1;
              if ( v33 )
              {
                if ( !((unsigned __int8)v33 & 7) )
                {
                  off_100AD9F4(v33, 0, 0, 1, dword_100AE9F4);
                  return 0;
                }
LABEL_130:
                sub_100927E0((int)"crnlib_free: bad ptr");
                return 0;
              }
              return 0;
            }
            goto LABEL_92;
          }
        }
        v17 = *(int **)(v15 + 20);
        v48 = 0;
        v49 = 0;
        v50 = 0;
        v51 = 0;
        v52 = 0;
        v53 = 0;
        v54 = 0;
        v55 = 0;
        v56 = 0;
        v57 = 0;
        v58 = 0;
        v59 = 0;
        v63 = -1;
        v61 = 0;
        v62 = 0;
        v60 = 0;
        LOBYTE(v86) = 1;
        if ( v37 && *(_BYTE *)(v15 + 24) & 3 )
        {
          sub_10085090((int)&v48, (int)v17);
          if ( *(_BYTE *)(v15 + 24) & 1 && !sub_10085310((int)&v48) )
            sub_10094340("mipmapped_texture::write_dds: Unable to unflip compressed texture on X axis");
          if ( *(_BYTE *)(v15 + 24) & 2 && !sub_100851E0((int)&v48) )
            sub_10094340("mipmapped_texture::write_dds: Unable to unflip compressed texture on Y axis");
          v16 = v48;
          v17 = &v48;
        }
        v18 = 8 * v17[1];
        if ( v39 < v18 )
        {
          if ( v18 > v40 )
          {
            LOBYTE(v81) = v18 == v39 + 1;
            sub_100943C0(v18, 0, (int)&v38, v18 == v39 + 1, 1u, 0);
          }
          memset((char *)v38 + v39, 0, v18 - v39);
          v39 = v18;
        }
        memcpy(v38, (const void *)v17[3], v18);
        v19 = (*(int (__stdcall **)(void *, unsigned int))(**(_DWORD **)a3 + 20))(v38, v18);
        LOBYTE(v86) = 0;
        if ( v19 != v18 )
        {
          if ( v16 )
          {
            if ( v48 & 7 )
              sub_100927E0((int)"crnlib_free: bad ptr");
            else
              off_100AD9F4(v16, 0, 0, 1, dword_100AE9F4);
          }
          v86 = -1;
          if ( v38 )
          {
            if ( (unsigned __int8)v38 & 7 )
              goto LABEL_130;
            off_100AD9F4(v38, 0, 0, 1, dword_100AE9F4);
          }
          return 0;
        }
        if ( v16 )
        {
          if ( v48 & 7 )
          {
            sub_100927E0((int)"crnlib_free: bad ptr");
            goto LABEL_118;
          }
          v35 = dword_100AE9F4;
LABEL_117:
          off_100AD9F4(v16, 0, 0, 1, v35);
        }
LABEL_118:
        v34 = ++v44;
      }
      while ( v34 < sub_100323E0(a2) );
      v13 = v38;
LABEL_120:
      v43 += 12;
      if ( (unsigned int)++v46 >= *(_DWORD *)(a2 + 28) )
        break;
      v14 = a2;
    }
  }
  sub_10091CF0(v83);
  v86 = -1;
  if ( v13 )
  {
    if ( (unsigned __int8)v13 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v13, 0, 0, 1, dword_100AE9F4);
  }
  return 1;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1008A9C0) --------------------------------------------------------
char __userpurge sub_1008A9C0@<al>(int a1@<eax>, int a2, int a3, signed int a4, const void *a5, int a6)
{
  bool v6; // zf@6
  int v7; // eax@11
  int v8; // ebx@14
  int *v9; // ebx@16
  int v10; // ebx@22
  int v11; // ebx@23
  int *v12; // ebx@25
  int v14; // [sp+0h] [bp-6Ch]@14
  int v15; // [sp+4h] [bp-68h]@14
  int v16; // [sp+8h] [bp-64h]@14
  int v17; // [sp+Ch] [bp-60h]@14
  unsigned int v18; // [sp+10h] [bp-5Ch]@14
  int v19; // [sp+14h] [bp-58h]@14
  void *v20; // [sp+18h] [bp-54h]@14
  int v21; // [sp+1Ch] [bp-50h]@14
  int v22; // [sp+20h] [bp-4Ch]@14
  char v23; // [sp+24h] [bp-48h]@2
  char v24; // [sp+34h] [bp-38h]@13
  int v25; // [sp+60h] [bp-Ch]@1
  int (__thiscall *v26)(void *); // [sp+64h] [bp-8h]@1
  int v27; // [sp+68h] [bp-4h]@1
  int v28; // [sp+74h] [bp+8h]@22

  v27 = -1;
  v26 = sub_1009730A;
  v25 = a1;
  if ( !sub_10033890(a4) )
    return 0;
  qmemcpy(&v23, a5, 0x38u);
  if ( a4 > 1380075384 )
  {
    if ( a4 == 1383614328 || a4 == 1498952257 )
      goto LABEL_13;
    v6 = a4 == 1501053763;
  }
  else
  {
    if ( a4 == 1380075384 || a4 == 826889281 || a4 == 843666497 )
      goto LABEL_13;
    v6 = a4 == 1380075329;
  }
  if ( v6 || (v7 = *(_DWORD *)(a3 + 16), v7 & 0x20) || v7 & 0x40 )
LABEL_13:
    v24 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 15;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v27 = 0;
  sub_10033C70((int)&v14, a3);
  v27 = 1;
  v8 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 15;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  if ( v8 )
  {
    sub_10034460(v8);
    *(_DWORD *)(a2 + 16) = 0;
  }
  v9 = *(int **)(a2 + 20);
  if ( v9 )
  {
    sub_100344C0(v9);
    *(_DWORD *)(a2 + 20) = 0;
  }
  *(_DWORD *)(a2 + 12) = a4;
  if ( (a4 == 826889281 || a4 == 1098414200) && !((v18 >> 3) & 1) )
    sub_10033EE0((int)&v14);
  v28 = sub_100321D0(a4);
  v10 = sub_10034520();
  if ( !sub_10086840((int)&v23, v10, v28, (int)&v14, (int)&v23) )
  {
    v11 = *(_DWORD *)(a2 + 16);
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 8) = 15;
    *(_DWORD *)(a2 + 12) = 0;
    *(_DWORD *)(a2 + 24) = 0;
    if ( v11 )
    {
      sub_10034460(v11);
      *(_DWORD *)(a2 + 16) = 0;
    }
    v12 = *(int **)(a2 + 20);
    if ( v12 )
    {
      sub_100344C0(v12);
      *(_DWORD *)(a2 + 20) = 0;
    }
    v27 = -1;
    if ( v20 )
    {
      if ( (unsigned __int8)v20 & 7 )
      {
        sub_100927E0((int)"crnlib_free: bad ptr");
        return 0;
      }
      off_100AD9F4(v20, 0, 0, 1, dword_100AE9F4);
    }
    return 0;
  }
  sub_100873F0(v10, a2, a4, a6);
  v27 = -1;
  if ( v20 )
  {
    if ( (unsigned __int8)v20 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v20, 0, 0, 1, dword_100AE9F4);
  }
  return 1;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1008AC40) --------------------------------------------------------
char __userpurge sub_1008AC40@<al>(int a1@<ecx>, int a2@<esi>, int a3, int a4, int a5)
{
  unsigned __int8 v5; // bl@2
  int v6; // eax@2
  int v7; // edi@2
  unsigned int v8; // ecx@2
  unsigned int v9; // ett@3
  unsigned int v10; // ett@5
  unsigned int v11; // edi@9
  double v12; // st7@14
  unsigned int v14; // ebp@24
  unsigned int v15; // edi@26
  unsigned int v16; // eax@26
  int *v17; // ebx@26
  int v18; // eax@31
  int v19; // ebx@35
  unsigned int v20; // edi@37
  int v21; // ecx@38
  int v22; // ebp@38
  int v23; // eax@38
  unsigned int v24; // ebx@38
  int v25; // ecx@39
  int v26; // edx@41
  int v27; // edx@43
  int v28; // edi@45
  bool v29; // zf@46
  int (__cdecl *v30)(int, _DWORD); // ecx@50
  int v31; // [sp+10h] [bp-44h]@36
  unsigned int v32; // [sp+14h] [bp-40h]@39
  unsigned int v33; // [sp+18h] [bp-3Ch]@37
  unsigned int v34; // [sp+1Ch] [bp-38h]@35
  void *v35; // [sp+20h] [bp-34h]@8
  unsigned int v36; // [sp+24h] [bp-30h]@8
  int v37; // [sp+28h] [bp-2Ch]@8
  int v38; // [sp+2Ch] [bp-28h]@24
  int v39[2]; // [sp+30h] [bp-24h]@26
  int v40; // [sp+38h] [bp-1Ch]@43
  int v41; // [sp+50h] [bp-4h]@8
  float v42; // [sp+60h] [bp+Ch]@13
  int v43; // [sp+60h] [bp+Ch]@35

  if ( !*(_DWORD *)(a1 + 28) )
    return 0;
  v5 = *(_BYTE *)(a2 + 20392);
  *(_DWORD *)(a2 + 15668) = *(_DWORD *)a4;
  *(_DWORD *)(a2 + 17224) = *(_DWORD *)(a4 + 1556);
  *(_DWORD *)(a2 + 17228) = *(_DWORD *)(a4 + 1560);
  *(_DWORD *)(a2 + 17240) = *(_DWORD *)a5;
  *(_DWORD *)(a2 + 18792) = *(_DWORD *)(a5 + 1552);
  *(_DWORD *)(a2 + 18796) = *(_DWORD *)(a5 + 1556);
  *(_DWORD *)(a2 + 18816) = *(_DWORD *)a5;
  *(_DWORD *)(a2 + 20368) = *(_DWORD *)(a5 + 1552);
  v6 = *(_BYTE *)(a2 + 20394);
  *(_DWORD *)(a2 + 20372) = *(_DWORD *)(a5 + 1556);
  v7 = *(_DWORD *)(a4 + 1564);
  v8 = v6 + *(_BYTE *)(a2 + 20393) + v5;
  if ( v5 )
  {
    *(_DWORD *)(a2 + 17232) = v7;
    v9 = *(_DWORD *)(a4 + 1568);
    *(_DWORD *)(a2 + 17236) = v9 / v8;
    v7 += v9 / v8;
  }
  if ( *(_BYTE *)(a2 + 20393) )
  {
    *(_DWORD *)(a2 + 18800) = v7;
    v10 = *(_DWORD *)(a4 + 1568);
    *(_DWORD *)(a2 + 18804) = v10 / v8;
    v7 += v10 / v8;
  }
  if ( *(_BYTE *)(a2 + 20394) )
  {
    *(_DWORD *)(a2 + 20376) = v7;
    *(_DWORD *)(a2 + 20380) = *(_DWORD *)(a4 + 1568) - v7;
  }
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v41 = 0;
  if ( v5 )
  {
    v11 = *(_DWORD *)(a2 + 15660);
    if ( v11 )
    {
      if ( v11 > 0 )
        sub_100943C0(v11, 0, (int)&v35, v11 == 1, 8u, 0);
      v36 = v11;
    }
    v42 = 1.0;
    if ( *(_DWORD *)a2 == 1501053763 )
    {
      v12 = 1.5;
    }
    else
    {
      if ( *(_DWORD *)a2 != 894720068 )
        goto LABEL_18;
      v12 = 0.75;
    }
    v42 = v12;
LABEL_18:
    if ( !sub_10070950(a2 + 8, (int)v35, a2 + 15668, v42) )
    {
LABEL_19:
      v41 = -1;
      if ( v35 )
      {
        if ( (unsigned __int8)v35 & 7 )
        {
          sub_100927E0((int)"crnlib_free: bad ptr");
          return 0;
        }
        off_100AD9F4(v35, 0, 0, 1, dword_100AE9F4);
      }
      return 0;
    }
  }
  `eh vector constructor iterator'(&v38, 0xCu, 2, (int)unknown_libname_3, sub_10038C00);
  LOBYTE(v41) = 1;
  v14 = 0;
  do
  {
    if ( *(_BYTE *)(a2 + v14 + 20393) )
    {
      v15 = *(_DWORD *)(a2 + 15660);
      v16 = v39[3 * v14];
      v17 = &v38 + 3 * v14;
      if ( v15 != v16 )
      {
        if ( v15 >= v16 && v15 > v17[2] )
          sub_100943C0(v15, 0, (int)(&v38 + 3 * v14), v15 == v16 + 1, 8u, 0);
        v17[1] = v15;
      }
      v18 = a2 + 10440;
      if ( !v14 )
        v18 = a2 + 5224;
      if ( !sub_1006DA30(v18, *v17, (const void *)(1576 * v14 + a2 + 17240)) )
      {
        LOBYTE(v41) = 0;
        `eh vector destructor iterator'(&v38, 0xCu, 2, sub_10038C00);
        goto LABEL_19;
      }
    }
    ++v14;
  }
  while ( v14 < 2 );
  v19 = a3;
  v43 = 0;
  v34 = 0;
  if ( *(_DWORD *)(a3 + 28) )
  {
    v31 = 0;
    do
    {
      v20 = 0;
      v33 = 0;
      if ( sub_100323E0(v19) )
      {
        do
        {
          v21 = *(_DWORD *)(*(_DWORD *)(v31 + *(_DWORD *)(v19 + 24)) + 4 * v20);
          v22 = *(_DWORD *)(v21 + 20);
          v23 = *(_DWORD *)(v22 + 12);
          v24 = ((unsigned int)(*(_DWORD *)v21 + 3) >> 2) * ((unsigned int)(*(_DWORD *)(v21 + 4) + 3) >> 2);
          if ( v24 )
          {
            v25 = 8 * v43;
            v32 = v24;
            do
            {
              if ( *(_BYTE *)(a2 + 20393) )
              {
                v26 = v38;
                *(_DWORD *)v23 = *(_DWORD *)(v25 + v38);
                *(_DWORD *)(v23 + 4) = *(_DWORD *)(v25 + v26 + 4);
              }
              if ( *(_BYTE *)(a2 + 20394) )
              {
                v27 = v40;
                *(_DWORD *)(v23 + 8) = *(_DWORD *)(v25 + v40);
                *(_DWORD *)(v23 + 12) = *(_DWORD *)(v25 + v27 + 4);
              }
              if ( *(_BYTE *)(a2 + 20392) )
              {
                v28 = *(_BYTE *)(a2 + 20393);
                *(_DWORD *)(v23 + 8 * v28) = *(_DWORD *)((char *)v35 + v25);
                *(_DWORD *)(v23 + 8 * v28 + 4) = *(_DWORD *)((char *)v35 + v25 + 4);
              }
              v25 += 8;
              v29 = v32-- == 1;
              v23 += 8 * *(_DWORD *)(v22 + 40);
            }
            while ( !v29 );
            v20 = v33;
          }
          v43 += v24;
          v33 = ++v20;
          v19 = a3;
        }
        while ( v20 < sub_100323E0(a3) );
      }
      v31 += 12;
      ++v34;
    }
    while ( v34 < *(_DWORD *)(v19 + 28) );
  }
  v30 = *(int (__cdecl **)(int, _DWORD))(a4 + 1556);
  if ( v30 && !(unsigned __int8)v30(*(_DWORD *)(a4 + 1564) + *(_DWORD *)(a4 + 1568), *(_DWORD *)(a4 + 1560)) )
  {
    LOBYTE(v41) = 0;
    `eh vector destructor iterator'(&v38, 0xCu, 2, sub_10038C00);
    goto LABEL_19;
  }
  LOBYTE(v41) = 0;
  `eh vector destructor iterator'(&v38, 0xCu, 2, sub_10038C00);
  v41 = -1;
  if ( v35 )
  {
    if ( (unsigned __int8)v35 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v35, 0, 0, 1, dword_100AE9F4);
  }
  return 1;
}
// 1003F6D0: using guessed type int unknown_libname_3();
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 1008AC40: using guessed type int var_24[2];

//----- (1008B0C0) --------------------------------------------------------
char __userpurge sub_1008B0C0@<al>(int a1@<esi>, signed int a2, const void *a3)
{
  char result; // al@2
  int v4; // ebx@3
  int *v5; // eax@3
  int v6; // [sp+Ch] [bp-30h]@3
  int v7; // [sp+10h] [bp-2Ch]@3
  int v8; // [sp+14h] [bp-28h]@3
  int v9; // [sp+18h] [bp-24h]@3
  int v10; // [sp+1Ch] [bp-20h]@3
  int v11; // [sp+20h] [bp-1Ch]@3
  int v12; // [sp+24h] [bp-18h]@3
  int v13; // [sp+28h] [bp-14h]@3
  int v14; // [sp+2Ch] [bp-10h]@3
  int v15; // [sp+38h] [bp-4h]@3
  char v16; // [sp+40h] [bp+4h]@8

  if ( sub_10033890(a2) )
  {
    v4 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 15;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v5 = *(int **)(a1 + 16);
    if ( v5 || *(_DWORD *)(a1 + 20) )
    {
      if ( *(_DWORD *)(a1 + 20) )
      {
        sub_100859B0((int)&v6, *(_DWORD *)(a1 + 20));
        v10 = *(_DWORD *)(a1 + 8);
        sub_10086CC0(a1, (int)&v6);
        v4 = v12;
        v5 = &v6;
      }
    }
    else
    {
      v5 = 0;
    }
    v16 = sub_1008A9C0((int)v5, a1, (int)v5, a2, a3, *(_DWORD *)(a1 + 24));
    v15 = -1;
    if ( v4 )
    {
      if ( v4 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v4, 0, 0, 1, dword_100AE9F4);
    }
    result = v16;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1008B1D0) --------------------------------------------------------
char __stdcall sub_1008B1D0(int a1, signed int a2, const void *a3)
{
  char result; // al@2
  int v4; // ebp@3
  int *v5; // edi@3
  int v6; // eax@8
  int v7; // esi@9
  int v8; // eax@17
  unsigned int v9; // eax@18
  unsigned int v10; // ebp@19
  int v11; // ecx@21
  int v12; // eax@21
  unsigned int v13; // edx@21
  unsigned __int8 v14; // bl@21
  int v15; // ecx@21
  unsigned __int8 v16; // al@21
  int v17; // ecx@28
  char v18; // dl@28
  signed int v19; // [sp-4h] [bp-54h]@11
  int v20; // [sp+14h] [bp-3Ch]@9
  unsigned int v21; // [sp+18h] [bp-38h]@17
  char v22; // [sp+1Fh] [bp-31h]@21
  int v23; // [sp+20h] [bp-30h]@3
  int v24; // [sp+24h] [bp-2Ch]@3
  int v25; // [sp+28h] [bp-28h]@3
  int v26; // [sp+2Ch] [bp-24h]@3
  int v27; // [sp+30h] [bp-20h]@3
  int v28; // [sp+34h] [bp-1Ch]@3
  void *v29; // [sp+38h] [bp-18h]@3
  int v30; // [sp+3Ch] [bp-14h]@3
  int v31; // [sp+40h] [bp-10h]@3
  int v32; // [sp+4Ch] [bp-4h]@3
  bool v33; // [sp+5Ch] [bp+Ch]@20

  if ( sub_10033890(a2) )
    return sub_1008B0C0(a1, a2, a3);
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 15;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v4 = a1;
  v32 = 0;
  v5 = *(int **)(a1 + 16);
  if ( v5 || *(_DWORD *)(a1 + 20) )
  {
    if ( *(_DWORD *)(a1 + 20) )
    {
      v5 = &v23;
      sub_100859B0((int)&v23, *(_DWORD *)(a1 + 20));
      v27 = *(_DWORD *)(a1 + 8);
      sub_10086CC0(a1, (int)&v23);
    }
  }
  else
  {
    v5 = 0;
  }
  v6 = sub_10092A80(36);
  if ( v6 )
  {
    *(_DWORD *)(v6 + 16) = 15;
    *(_DWORD *)v6 = 0;
    *(_DWORD *)(v6 + 4) = 0;
    *(_DWORD *)(v6 + 8) = 0;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 20) = 0;
    *(_DWORD *)(v6 + 24) = 0;
    *(_DWORD *)(v6 + 28) = 0;
    *(_DWORD *)(v6 + 32) = 0;
    v7 = v6;
    v20 = v6;
  }
  else
  {
    v7 = 0;
    v20 = 0;
  }
  *(_DWORD *)(v7 + 16) = sub_1008B7D0(a2);
  v19 = -16777216;
  if ( sub_10034090(v7, *v5, v5[1], -16777216) )
  {
    v8 = v5[1];
    v21 = 0;
    if ( v8 )
    {
      v9 = *v5;
      do
      {
        v10 = 0;
        if ( v9 )
        {
          v33 = sub_10033870(a2);
          do
          {
            v11 = v5[5];
            v12 = v10 + v21 * v5[2];
            LOBYTE(v13) = *(_BYTE *)(v11 + 4 * v12);
            v14 = *(_BYTE *)(v11 + 4 * v12 + 1);
            v15 = v11 + 4 * v12;
            v16 = *(_BYTE *)(v15 + 2);
            v22 = *(_BYTE *)(v15 + 3);
            if ( !v33 || ((unsigned int)v5[4] >> 3) & 1 )
            {
              if ( (*(_DWORD *)(v7 + 16) >> 4) & 1 )
              {
                v13 = (7471 * v16 + 19595 * (unsigned __int8)v13 + 38470 * (unsigned int)v14 + 0x8000) >> 16;
                v14 = v13;
                v16 = v13;
              }
              if ( !((*(_DWORD *)(v7 + 16) >> 3) & 1) )
                v22 = -1;
            }
            else
            {
              v7 = v20;
              v22 = (7471 * v16 + 19595 * (unsigned __int8)v13 + 38470 * (unsigned int)v14 + 0x8000) >> 16;
            }
            v17 = *(_DWORD *)(v20 + 20) + 4 * (v10 + v21 * *(_DWORD *)(v7 + 8));
            v7 = v20;
            *(_BYTE *)v17 = v13;
            v18 = v22;
            *(_BYTE *)(v17 + 1) = v14;
            *(_BYTE *)(v17 + 2) = v16;
            *(_BYTE *)(v17 + 3) = v18;
            v9 = *v5;
            ++v10;
          }
          while ( v10 < *v5 );
        }
        ++v21;
      }
      while ( v21 < v5[1] );
      v4 = a1;
    }
    sub_10087550(v7, v4, a2, *(_DWORD *)(v4 + 24));
    v32 = -1;
    if ( v29 )
    {
      if ( (unsigned __int8)v29 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v29, 0, 0, 1, dword_100AE9F4);
    }
    result = 1;
  }
  else
  {
    v32 = -1;
    if ( v29 )
    {
      if ( (unsigned __int8)v29 & 7 )
      {
        sub_100927E0((int)"crnlib_free: bad ptr");
        return 0;
      }
      off_100AD9F4(v29, 0, 0, 1, dword_100AE9F4);
    }
    result = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1008B4D0) --------------------------------------------------------
char __stdcall sub_1008B4D0(int a1, signed int a2, int a3)
{
  int v3; // eax@1
  int v4; // ecx@1
  unsigned int v5; // edi@3
  int v6; // ebx@4
  _DWORD *v7; // ecx@4
  int v8; // ecx@6
  int v9; // edx@6
  int v10; // esi@6
  bool v11; // zf@8
  int v12; // esi@10
  unsigned int v13; // ebx@13
  int v14; // eax@13
  int v15; // ebp@13
  unsigned int v16; // eax@13
  int v17; // edx@13
  unsigned int v18; // ebx@15
  bool v19; // cf@18
  int v20; // ecx@20
  int (__cdecl *v21)(int, _DWORD); // eax@20
  char result; // al@22
  int v23; // eax@23
  int v24; // ecx@24
  int v25; // ecx@30
  int v26; // eax@31
  int v27; // [sp+14h] [bp-54h]@11
  int v28; // [sp+18h] [bp-50h]@4
  int v29; // [sp+18h] [bp-50h]@12
  unsigned int v30; // [sp+1Ch] [bp-4Ch]@3
  int v31; // [sp+1Ch] [bp-4Ch]@4
  unsigned int v32; // [sp+20h] [bp-48h]@10
  int v33; // [sp+24h] [bp-44h]@10
  int v34; // [sp+28h] [bp-40h]@10
  int *v35; // [sp+2Ch] [bp-3Ch]@13
  char v36; // [sp+30h] [bp-38h]@13
  int v37; // [sp+50h] [bp-18h]@15
  unsigned int v38; // [sp+54h] [bp-14h]@17

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 28);
  if ( !v4 )
    return 0;
  if ( a2 == *(_DWORD *)(a1 + 20) )
    return 1;
  v5 = 0;
  v30 = 0;
  if ( v4 )
  {
    v6 = 0;
    v7 = (_DWORD *)(*(_DWORD *)(a1 + 24) + 4);
    v31 = *(_DWORD *)(a1 + 24) + 4;
    v28 = *(_DWORD *)(a1 + 28);
    do
    {
      if ( *v7 )
      {
        v8 = *(_DWORD *)(a1 + 24);
        v9 = *(_DWORD *)(v6 + v8);
        v10 = *(_DWORD *)(v6 + v8 + 4);
        do
        {
          v5 += **(_DWORD **)v9 * *(_DWORD *)(*(_DWORD *)v9 + 4);
          v9 += 4;
          --v10;
        }
        while ( v10 );
      }
      v7 = (_DWORD *)(v31 + 12);
      v6 += 12;
      v11 = v28-- == 1;
      v31 += 12;
    }
    while ( !v11 );
    v30 = v5;
  }
  v12 = a3;
  v33 = 0;
  v32 = *(_DWORD *)(a3 + 32);
  v34 = 0;
  if ( !*(_DWORD *)(a1 + 28) )
  {
LABEL_20:
    v20 = *(_DWORD *)(v3 + 24);
    *(_DWORD *)(v3 + 20) = *(_DWORD *)(**(_DWORD **)v20 + 12);
    *(_DWORD *)(v3 + 16) = *(_DWORD *)(**(_DWORD **)v20 + 8);
    v21 = *(int (__cdecl **)(int, _DWORD))(v12 + 24);
    if ( v21 && !(unsigned __int8)v21(*(_DWORD *)(v12 + 32) + *(_DWORD *)(v12 + 36), *(_DWORD *)(v12 + 28)) )
      return 0;
    return 1;
  }
  v27 = 0;
  while ( 1 )
  {
    v29 = 0;
    if ( *(_DWORD *)(v27 + *(_DWORD *)(v3 + 24) + 4) )
      break;
LABEL_19:
    v27 += 12;
    if ( (unsigned int)++v34 >= *(_DWORD *)(v3 + 28) )
      goto LABEL_20;
  }
  while ( 1 )
  {
    v13 = *(_DWORD *)(v12 + 36);
    v14 = *(_DWORD *)(v27 + *(_DWORD *)(v3 + 24)) + 4 * v29;
    v35 = (int *)v14;
    v15 = **(_DWORD **)v14 * *(_DWORD *)(*(_DWORD *)v14 + 4);
    v16 = v15 * v13 / v5;
    qmemcpy(&v36, (const void *)v12, 0x38u);
    v17 = v13;
    if ( v32 <= v13 )
      v17 = v32;
    v18 = v13 - v17;
    v37 = v17;
    if ( v16 > v18 )
      v16 = v18;
    v32 += v16;
    v38 = v16;
    if ( !sub_1008B1D0(*v35, a2, &v36) )
      break;
    v33 += v15;
    v5 = v30;
    v12 = a3;
    v19 = (unsigned int)(v29++ + 1) < *(_DWORD *)(v27 + *(_DWORD *)(a1 + 24) + 4);
    v3 = a1;
    if ( !v19 )
      goto LABEL_19;
  }
  sub_10087040(a1);
  v23 = *(_DWORD *)(a1 + 4);
  if ( v23 )
  {
    v24 = v23 - 8;
    if ( *(_DWORD *)(v23 - 4) == ~*(_DWORD *)(v23 - 8) && v23 != 8 )
    {
      if ( v24 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v24, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)a1 = 0;
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 15;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 36) = -1;
  v25 = *(_DWORD *)(a1 + 44);
  if ( v25 )
  {
    v26 = v25 - 8;
    if ( *(_DWORD *)(v25 - 4) == ~*(_DWORD *)(v25 - 8) && v25 != 8 )
    {
      if ( v26 & 7 )
      {
        sub_100927E0((int)"crnlib_free: bad ptr");
        result = 0;
        *(_DWORD *)(a1 + 44) = 0;
        *(_DWORD *)(a1 + 40) = 0;
        return result;
      }
      off_100AD9F4(v26, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 44) = 0;
    *(_DWORD *)(a1 + 40) = 0;
  }
  return 0;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (1008B750) --------------------------------------------------------
signed int __usercall sub_1008B750@<eax>(int a1@<eax>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 827611204;
      break;
    case 1:
      result = 861165636;
      break;
    case 2:
      result = 894720068;
      break;
    case 3:
      result = 1501053763;
      break;
    case 4:
      result = 1383614328;
      break;
    case 5:
      result = 1380075384;
      break;
    case 6:
      result = 1380075329;
      break;
    case 7:
      result = 1498952257;
      break;
    case 8:
      result = 843666497;
      break;
    case 9:
      result = 826889281;
      break;
    case 10:
      result = 826496069;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (1008B7D0) --------------------------------------------------------
signed int __fastcall sub_1008B7D0(signed int a1)
{
  signed int result; // eax@1
  int v2; // ecx@24

  result = 31;
  if ( a1 > 1094862674 )
  {
    if ( a1 > 1383614328 )
    {
      if ( a1 > 2017609554 )
      {
        if ( a1 == 2021161036 )
          result = 23;
        return result;
      }
      if ( a1 == 2017609554 )
        return 7;
      if ( a1 != 1498952257 )
      {
        if ( a1 == 1501053763 )
          result = 71;
        return result;
      }
    }
    else if ( a1 != 1383614328 )
    {
      if ( a1 <= 1380075329 )
      {
        if ( a1 == 1380075329 )
        {
          result = 47;
        }
        else
        {
          v2 = a1 - 1098414156;
          if ( v2 && v2 == 44 )
            result = 8;
        }
        return result;
      }
      if ( a1 != 1380075384 )
        return result;
    }
    return 39;
  }
  if ( a1 == 1094862674 )
    return 15;
  if ( a1 > 844388420 )
  {
    if ( a1 > 894720068 )
    {
      if ( a1 != 1093752900 )
        return result;
    }
    else if ( a1 != 894720068 && a1 != 861165636 && a1 != 877942852 )
    {
      return result;
    }
    return 15;
  }
  if ( a1 == 844388420 )
    return 15;
  if ( a1 <= 827611204 )
  {
    if ( a1 != 827611204 && a1 != 826496069 )
    {
      if ( a1 == 826889281 )
        result = 8;
      return result;
    }
    return 7;
  }
  if ( a1 == 843666497 )
    result = 39;
  return result;
}

//----- (1008B8C0) --------------------------------------------------------
int __usercall sub_1008B8C0@<eax>(char *a1@<eax>, int a2)
{
  char *v2; // ebx@1
  int v3; // ecx@1
  int result; // eax@1
  char v5; // dl@2
  char v6; // dl@2
  unsigned __int8 v7; // dl@2
  unsigned __int8 v8; // dl@2
  unsigned __int8 v9; // dl@2
  unsigned __int8 v10; // dl@2
  unsigned __int8 v11; // dl@2
  unsigned __int8 v12; // dl@2
  unsigned __int8 v13; // dl@2
  unsigned __int8 v14; // dl@2
  unsigned __int8 v15; // dl@2
  int v16; // edx@2
  int v17; // edx@2
  int v18; // edx@2
  int v19; // edx@2
  bool v20; // zf@2
  signed int v21; // [sp+14h] [bp-28h]@1
  int v22; // [sp+1Ch] [bp-20h]@2
  int v23; // [sp+20h] [bp-1Ch]@2
  int v24; // [sp+24h] [bp-18h]@2
  int v25; // [sp+28h] [bp-14h]@2
  int v26; // [sp+2Ch] [bp-10h]@2
  int v27; // [sp+30h] [bp-Ch]@2
  int v28; // [sp+34h] [bp-8h]@2
  int v29; // [sp+38h] [bp-4h]@2

  v2 = a1;
  memset(a1, 255, 0x40u);
  v3 = (int)(v2 + 12);
  result = a2 + 4;
  v21 = 3;
  do
  {
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v5 = byte_100BF488[*(_BYTE *)(result - 4)];
    *(_BYTE *)(v3 - 12) = v5;
    v22 = *(_BYTE *)(result - 4) - (unsigned __int8)v5;
    v6 = *(&byte_100BF488[(v26 + 5 * v27 + 7 * v22 + 3 * v28) >> 4] + *(_BYTE *)result);
    *(&v2[result] - a2) = v6;
    v23 = *(_BYTE *)result - (unsigned __int8)v6;
    v7 = *(&byte_100BF488[(v27 + 5 * v28 + 7 * v23 + 3 * v29) >> 4] + *(_BYTE *)(result + 4));
    *(_BYTE *)(v3 - 4) = v7;
    v24 = *(_BYTE *)(result + 4) - v7;
    v8 = *(&byte_100BF488[(v28 + 7 * v24 + 5 * v29) >> 4] + *(_BYTE *)(result + 8));
    *(_BYTE *)v3 = v8;
    v25 = *(_BYTE *)(result + 8) - v8;
    v9 = *(&byte_100BF488[(3 * v23 + 5 * v22) >> 4] + *(_BYTE *)(result + 12));
    *(_BYTE *)(v3 + 4) = v9;
    v26 = *(_BYTE *)(result + 12) - v9;
    v10 = *(&byte_100BF488[(v22 + 3 * v24 + 5 * v23 + 7 * v26) >> 4] + *(_BYTE *)(result + 16));
    *(_BYTE *)(v3 + 8) = v10;
    v27 = *(_BYTE *)(result + 16) - v10;
    v11 = *(&byte_100BF488[(v23 + 5 * v24 + 7 * v27 + 3 * v25) >> 4] + *(_BYTE *)(result + 20));
    *(_BYTE *)(v3 + 12) = v11;
    v28 = *(_BYTE *)(result + 20) - v11;
    v12 = *(&byte_100BF488[(v24 + 7 * v28 + 5 * v25) >> 4] + *(_BYTE *)(result + 24));
    *(_BYTE *)(v3 + 16) = v12;
    v29 = *(_BYTE *)(result + 24) - v12;
    v13 = *(&byte_100BF488[(3 * v27 + 5 * v26) >> 4] + *(_BYTE *)(result + 28));
    *(_BYTE *)(v3 + 20) = v13;
    v22 = *(_BYTE *)(result + 28) - v13;
    v14 = *(&byte_100BF488[(v26 + 3 * v28 + 5 * v27 + 7 * v22) >> 4] + *(_BYTE *)(result + 32));
    *(_BYTE *)(v3 + 24) = v14;
    v23 = *(_BYTE *)(result + 32) - v14;
    v15 = *(&byte_100BF488[(v27 + 5 * v28 + 7 * v23 + 3 * v29) >> 4] + *(_BYTE *)(result + 36));
    *(_BYTE *)(v3 + 28) = v15;
    v16 = *(_BYTE *)(result + 36) - v15;
    v24 = v16;
    LOBYTE(v16) = *(&byte_100BF488[(v28 + 7 * v16 + 5 * v29) >> 4] + *(_BYTE *)(result + 40));
    *(_BYTE *)(v3 + 32) = v16;
    v25 = *(_BYTE *)(result + 40) - (unsigned __int8)v16;
    LOBYTE(v16) = *(&byte_100BF488[(3 * v23 + 5 * v22) >> 4] + *(_BYTE *)(result + 44));
    *(_BYTE *)(v3 + 36) = v16;
    v17 = *(_BYTE *)(result + 44) - (unsigned __int8)v16;
    v26 = v17;
    LOBYTE(v17) = *(&byte_100BF488[(v22 + 3 * v24 + 5 * v23 + 7 * v17) >> 4] + *(_BYTE *)(result + 48));
    *(_BYTE *)(v3 + 40) = v17;
    v18 = *(_BYTE *)(result + 48) - (unsigned __int8)v17;
    v27 = v18;
    LOBYTE(v18) = *(&byte_100BF488[(v23 + 5 * v24 + 7 * v18 + 3 * v25) >> 4] + *(_BYTE *)(result + 52));
    *(_BYTE *)(v3 + 44) = v18;
    v28 = *(_BYTE *)(result + 52) - (unsigned __int8)v18;
    v19 = *(_BYTE *)(result++ + 56);
    LOBYTE(v19) = *(&byte_100BF488[(v24 + 7 * v28 + 5 * v25) >> 4] + v19);
    *(_BYTE *)(v3++ + 48) = v19;
    v20 = v21-- == 1;
    v29 = *(_BYTE *)(result + 55) - (unsigned __int8)v19;
  }
  while ( !v20 );
  return result;
}

//----- (1008BC80) --------------------------------------------------------
unsigned int __cdecl sub_1008BC80(int a1, int a2)
{
  int v2; // eax@1
  unsigned int v3; // ecx@1
  int v4; // edx@3
  int v5; // eax@3
  int v6; // ecx@3
  char *v7; // ebp@3
  signed int v8; // ebx@14
  char *v9; // ecx@14
  __int16 v10; // si@14
  __int16 v11; // di@14
  unsigned int result; // eax@14
  unsigned int v13; // edx@14
  unsigned int v14; // ecx@14
  unsigned int v15; // ecx@14
  int v16; // ecx@20
  char v17; // bp@20
  int v18; // ecx@20
  unsigned int v19; // [sp+10h] [bp-34h]@1
  signed int v20; // [sp+14h] [bp-30h]@1
  unsigned int v21; // [sp+18h] [bp-2Ch]@1
  char v22; // [sp+1Ch] [bp-28h]@1
  char v23; // [sp+20h] [bp-24h]@1
  unsigned int v24; // [sp+24h] [bp-20h]@1
  signed int v25; // [sp+28h] [bp-1Ch]@3
  int v26; // [sp+2Ch] [bp-18h]@3
  char *v27; // [sp+30h] [bp-14h]@3
  int v28; // [sp+34h] [bp-10h]@3
  int v29; // [sp+38h] [bp-Ch]@3
  int v30; // [sp+3Ch] [bp-8h]@3
  int v31; // [sp+40h] [bp-4h]@13

  v2 = a2;
  v3 = 0;
  v24 = -1;
  v21 = 0;
  v20 = 0;
  v22 = 0;
  v23 = 0;
  v19 = 0;
LABEL_3:
  v29 = *(_BYTE *)(dword_100AE614[v3] + v2);
  v4 = *(_BYTE *)(dword_100AE618[v3] + v2);
  v5 = *(_BYTE *)(v3 + v2);
  v6 = v5 - 1;
  v7 = (char *)&unk_1009C638 + 8 * (3 * v5 - 6);
  v30 = v4;
  v25 = -1;
  v28 = v5;
  v26 = v5 - 1;
  v27 = (char *)&unk_1009C638 + 8 * (3 * v5 - 6);
LABEL_5:
  if ( v6 >= 0 )
  {
    if ( v6 <= 255 )
    {
      if ( !v6 )
      {
        v7 = (char *)&unk_1009C5B0;
        goto LABEL_13;
      }
      if ( v6 != 255 )
        goto LABEL_13;
    }
    else
    {
      v6 = 255;
    }
    v7 = (char *)&unk_1009C5F2;
    goto LABEL_13;
  }
  v6 = 0;
  v7 = (char *)&unk_1009C5B0;
LABEL_13:
  v31 = (v6 - v5) * (v6 - v5);
  while ( 1 )
  {
    v8 = *(_WORD *)v7;
    v9 = (char *)&unk_100B7480 + 512 * (unsigned __int8)*(_WORD *)v7;
    v10 = *(_WORD *)&v9[2 * v29];
    v11 = *(_WORD *)&v9[2 * v30];
    result = v24;
    v13 = (unsigned int)*(_WORD *)&v9[2 * v30] >> 8;
    v14 = (unsigned int)*(_WORD *)&v9[2 * v29] >> 8;
    v15 = v31 + v13 * v13 + v14 * v14;
    v7 += 2;
    if ( v15 < v24 )
    {
      result = v15;
      v24 = v15;
      v20 = v8;
      v22 = v10;
      v23 = v11;
      v21 = v19;
      if ( !v15 )
        break;
    }
    if ( *(_WORD *)v7 == -1 )
    {
      v6 = v26 + 1;
      v7 = v27 + 24;
      ++v25;
      ++v26;
      v27 += 24;
      if ( v25 <= 1 )
      {
        v5 = v28;
        goto LABEL_5;
      }
      v3 = v19 + 1;
      v19 = v3;
      if ( v3 < 3 )
      {
        v2 = a2;
        goto LABEL_3;
      }
      v8 = v20;
      break;
    }
  }
  v16 = (v20 >> 4) & 3;
  *(_BYTE *)(a1 + 3) = 2 * (v8 & 1 | 2 * ((v8 >> 1) & 7 | 8 * ((v8 >> 1) & 7)));
  v17 = byte_1009C5A8[v16];
  *(_WORD *)(a1 + 4) = -((byte_1009C5A8[v16] & 2) != 0);
  *(_WORD *)(a1 + 6) = -((v17 & 1) != 0);
  v18 = (v20 >> 8) & 0xFF;
  if ( v8 & 1 )
  {
    *(_BYTE *)(v21 + a1) = 8 * BYTE1(v20);
    *(_BYTE *)(a1 + dword_100AE614[v21]) = 8 * v22;
    *(_BYTE *)(a1 + dword_100AE618[v21]) = 8 * v23;
  }
  else
  {
    *(_BYTE *)(v21 + a1) = v18 | 16 * v18;
    *(_BYTE *)(a1 + dword_100AE614[v21]) = v22 | 16 * v22;
    *(_BYTE *)(a1 + dword_100AE618[v21]) = v23 | 16 * v23;
  }
  return result;
}
// 100AE614: using guessed type int dword_100AE614[];
// 100AE618: using guessed type int dword_100AE618[];

//----- (1008BF90) --------------------------------------------------------
int __cdecl sub_1008BF90(int a1, int a2, unsigned __int8 a3, int a4)
{
  int v4; // edx@1
  int v5; // esi@1
  unsigned int v6; // ecx@1
  int v7; // edi@1
  int v8; // eax@3
  int v9; // eax@3
  int v10; // esi@3
  int v11; // eax@3
  char *v12; // edi@5
  signed int v13; // ebp@14
  char v14; // cl@14
  int v15; // ecx@14
  int v16; // eax@19
  char *v17; // eax@23
  unsigned int v18; // ebx@23
  int v19; // ecx@25
  int v20; // edx@30
  int v21; // edi@30
  unsigned int v22; // eax@30
  int result; // eax@35
  int v24; // edi@36
  int v25; // eax@36
  char *v26; // [sp+10h] [bp-4Ch]@7
  signed int v27; // [sp+14h] [bp-48h]@5
  char *v28; // [sp+18h] [bp-44h]@3
  unsigned int v29; // [sp+1Ch] [bp-40h]@1
  unsigned int v30; // [sp+20h] [bp-3Ch]@1
  unsigned __int16 v31; // [sp+24h] [bp-38h]@23
  int v32; // [sp+28h] [bp-34h]@3
  signed int v33; // [sp+2Ch] [bp-30h]@3
  int v34; // [sp+30h] [bp-2Ch]@3
  signed int v35; // [sp+34h] [bp-28h]@1
  unsigned int v36; // [sp+38h] [bp-24h]@1
  char v37; // [sp+3Ch] [bp-20h]@1
  char v38; // [sp+40h] [bp-1Ch]@1
  _BYTE *v39; // [sp+48h] [bp-14h]@3
  int v40; // [sp+4Ch] [bp-10h]@3
  int v41; // [sp+50h] [bp-Ch]@3
  int v42; // [sp+54h] [bp-8h]@3
  int v43; // [sp+58h] [bp-4h]@3

  v4 = a4;
  v5 = a2;
  v6 = 0;
  v7 = a2 - a4;
  v30 = -1;
  v36 = 0;
  v35 = 0;
  v37 = 0;
  v38 = 0;
  v29 = 0;
  while ( 2 )
  {
    v8 = dword_100AE624[v6];
    v42 = v8;
    v40 = *(_BYTE *)(v8 + v5);
    v9 = dword_100AE628[v6];
    v43 = v9;
    v41 = *(_BYTE *)(v9 + v5);
    v10 = *(_BYTE *)(v7 + v6 + v4);
    v39 = (_BYTE *)(v6 + v4);
    v11 = v10 - 1;
    v33 = -1;
    v32 = *(_BYTE *)(v7 + v6 + v4);
    v34 = v10 - 1;
    v28 = (char *)&unk_1009C638 + 8 * (3 * v10 - 6);
    while ( 2 )
    {
      if ( v11 < 0 )
      {
        v27 = 0;
        v12 = (char *)&unk_1009C5B0;
        goto LABEL_14;
      }
      if ( v11 <= 255 )
      {
        v27 = v11;
        if ( !v11 )
        {
          v12 = (char *)&unk_1009C5B0;
          goto LABEL_14;
        }
        if ( v11 == 255 )
          v26 = (char *)&unk_1009C5F2;
        else
          v26 = v28;
      }
      else
      {
        v27 = 255;
        v26 = (char *)&unk_1009C5F2;
      }
      while ( 2 )
      {
        v12 = v26;
        while ( 1 )
        {
          while ( 1 )
          {
LABEL_14:
            while ( 1 )
            {
              v13 = *(_WORD *)v12;
              v14 = *(_WORD *)v12;
              v12 += 2;
              v15 = v14 & 1;
              v26 = v12;
              if ( a3 == v15 )
                break;
              if ( *(_WORD *)v12 == -1 )
                goto LABEL_33;
            }
            if ( !v15 )
              break;
            if ( !v4 )
              break;
            v16 = ((unsigned __int16)v13 >> 8) - *v39;
            if ( v16 >= -4 && v16 <= 3 )
              break;
            if ( *(_WORD *)v12 == -1 )
              goto LABEL_33;
          }
          v17 = (char *)&unk_100B7480 + 512 * (unsigned __int8)v13;
          v18 = *(_WORD *)&v17[2 * v40];
          v31 = *(_WORD *)&v17[2 * v41];
          if ( !v15 )
            break;
          if ( !v4 )
            break;
          v19 = (unsigned __int8)v31 - *(_BYTE *)(v43 + v4);
          if ( (unsigned __int8)v18 - (unsigned int)*(_BYTE *)(v42 + v4) + 4 <= 7 && v19 >= -4 && v19 <= 3 )
            break;
          if ( *(_WORD *)v12 == -1 )
            goto LABEL_33;
        }
        v20 = (v27 - v10) * (v27 - v10);
        v21 = (v18 >> 8) * (v18 >> 8);
        v22 = v20 + v21 + ((unsigned int)v31 >> 8) * ((unsigned int)v31 >> 8);
        if ( v22 < v30 )
        {
          v37 = v18;
          v30 = v20 + v21 + ((unsigned int)v31 >> 8) * ((unsigned int)v31 >> 8);
          v35 = v13;
          v38 = v31;
          v36 = v29;
          if ( !v22 )
            goto LABEL_35;
        }
        v10 = v32;
        v4 = a4;
        if ( *(_WORD *)v26 != -1 )
          continue;
        break;
      }
LABEL_33:
      v28 += 24;
      v11 = v34 + 1;
      ++v33;
      ++v34;
      if ( v33 <= 1 )
        continue;
      break;
    }
    v6 = v29 + 1;
    v29 = v6;
    if ( v6 < 3 )
    {
      v7 = a2 - a4;
      v5 = a2;
      continue;
    }
    break;
  }
LABEL_35:
  result = v30;
  if ( v30 != -1 )
  {
    v24 = *(_DWORD *)(a1 + 20);
    *(_BYTE *)(a1 + 24) = ~(_BYTE)v35 & 1;
    *(_DWORD *)(a1 + 12) = (v35 >> 1) & 7;
    v25 = 16843009 * ((v35 >> 4) & 3);
    *(_DWORD *)(a1 + 16) = 8;
    *(_DWORD *)v24 = v25;
    *(_DWORD *)(v24 + 4) = v25;
    *(_BYTE *)(v36 + a1 + 8) = BYTE1(v35);
    *(_BYTE *)(dword_100AE624[v36] + a1 + 8) = v37;
    *(_BYTE *)(dword_100AE628[v36] + a1 + 8) = v38;
    *(_DWORD *)a1 = 8 * v30;
    result = 8 * v30;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return result;
}
// 100AE624: using guessed type int dword_100AE624[];
// 100AE628: using guessed type int dword_100AE628[];

//----- (1008C280) --------------------------------------------------------
char sub_1008C280()
{
  int v0; // ecx@1
  unsigned int v1; // edx@3
  unsigned int v2; // ebp@3
  char *v3; // ecx@3
  unsigned int v4; // eax@5
  unsigned int v5; // ebx@6
  unsigned int v6; // ecx@7
  __int16 v7; // di@7
  unsigned int v8; // esi@7
  int v9; // eax@10
  int v10; // eax@12
  unsigned int v11; // eax@16
  signed int v12; // eax@24
  signed int v13; // ecx@26
  signed int v14; // edx@28
  char result; // al@31
  int i; // [sp+10h] [bp-9Ch]@1
  char *v17; // [sp+14h] [bp-98h]@5
  char *j; // [sp+18h] [bp-94h]@3
  char *v19; // [sp+1Ch] [bp-90h]@6
  unsigned int v20; // [sp+20h] [bp-8Ch]@3
  unsigned int v21; // [sp+24h] [bp-88h]@5
  int v22; // [sp+28h] [bp-84h]@8
  int v23[32]; // [sp+2Ch] [bp-80h]@25

  v0 = 0;
  for ( i = 0; ; v0 = i )
  {
    v1 = 0;
    v2 = v0 != 0 ? 32 : 16;
    v3 = (char *)&unk_100B7480 + 512 * v0;
    v20 = 0;
    for ( j = v3; ; v3 = j )
    {
      v4 = 0;
      v21 = 0;
      v17 = v3;
      do
      {
        v5 = 0;
        v19 = v17;
        do
        {
          v6 = -1;
          v7 = 0;
          v8 = 0;
          if ( v2 )
          {
            v22 = dword_1009C528[v4 + v1];
            do
            {
              if ( i )
                v9 = 8 * v8 | (v8 >> 2);
              else
                v9 = v8 | 16 * v8;
              v10 = v22 + v9;
              if ( v10 >= 0 )
              {
                if ( v10 > 255 )
                  v10 = 255;
              }
              else
              {
                v10 = 0;
              }
              v11 = abs(v10 - v5);
              if ( v11 < v6 )
              {
                v6 = v11;
                v7 = v8;
                if ( !v11 )
                  break;
              }
              ++v8;
            }
            while ( v8 < v2 );
            v4 = v21;
            v1 = v20;
          }
          *(_WORD *)v19 = v7 | ((_WORD)v6 << 8);
          ++v5;
          v19 += 2;
        }
        while ( v5 < 0x100 );
        v17 += 0x2000;
        v21 = ++v4;
      }
      while ( v4 < 4 );
      j += 1024;
      v1 += 4;
      v20 = v1;
      if ( v1 >= 0x20 )
        break;
    }
    if ( (unsigned int)++i >= 2 )
      break;
  }
  v12 = 0;
  do
  {
    v23[v12] = 8 * v12 | (v12 >> 2);
    ++v12;
  }
  while ( v12 < 32 );
  v13 = -8;
  do
  {
    if ( v13 >= 0 )
    {
      v14 = 255;
      if ( v13 <= 255 )
        v14 = v13;
    }
    else
    {
      v14 = 0;
    }
    result = v23[(31 * v14 + 128 + ((31 * v14 + 128) >> 8)) >> 8];
    byte_100BF488[v13++] = result;
  }
  while ( v13 < 264 );
  return result;
}
// 1009C528: using guessed type int dword_1009C528[];
// 1008C280: using guessed type int var_80[32];

//----- (1008C470) --------------------------------------------------------
unsigned int __usercall sub_1008C470@<eax>(unsigned __int16 a1@<ax>, int a2, unsigned __int16 a3)
{
  unsigned int v3; // edi@1
  signed int v4; // esi@1
  int v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@1
  signed int v8; // edx@7
  signed int v9; // ecx@7
  signed int v10; // esi@7
  unsigned int result; // eax@7

  v3 = (unsigned int)a1 >> 3;
  v4 = ((unsigned int)a1 >> 6) & 7;
  v5 = a1 & 7;
  v6 = v3 & 7;
  v7 = v5;
  if ( v4 >= 4 )
    v4 -= 8;
  if ( v6 >= 4 )
    v6 -= 8;
  if ( v5 >= 4 )
    v7 = v5 - 8;
  v8 = v7 + (a3 & 0x1F);
  result = v4 + (((unsigned int)a3 >> 10) & 0x1F);
  v9 = v6 + (((unsigned int)a3 >> 5) & 0x1F);
  v10 = v4 + (((unsigned int)a3 >> 10) & 0x1F);
  LOBYTE(result) = 1;
  if ( (v8 | v9 | (unsigned int)v10) > 0x1F )
  {
    LOBYTE(result) = 0;
    if ( v10 >= 0 )
    {
      if ( v10 > 31 )
        v10 = 31;
    }
    else
    {
      v10 = 0;
    }
    if ( v9 >= 0 )
    {
      if ( v9 > 31 )
        v9 = 31;
    }
    else
    {
      v9 = 0;
    }
    if ( v8 >= 0 )
    {
      if ( v8 > 31 )
        v8 = 31;
    }
    else
    {
      v8 = 0;
    }
  }
  *(_BYTE *)(a2 + 2) = 8 * v8 | (v8 >> 2);
  *(_BYTE *)a2 = 8 * v10 | (v10 >> 2);
  *(_BYTE *)(a2 + 1) = 8 * v9 | (v9 >> 2);
  *(_BYTE *)(a2 + 3) = -1;
  return result;
}

//----- (1008C5B0) --------------------------------------------------------
signed int __usercall sub_1008C5B0@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<esi>)
{
  unsigned int v3; // ecx@1
  int v4; // eax@2
  unsigned __int8 v5; // bl@2
  float v6; // ST2C_4@2
  signed int v7; // ST18_4@2
  float v8; // ST30_4@2
  float v9; // ST34_4@2
  int v10; // ebp@2
  float v11; // ST20_4@3
  float v12; // ST24_4@3
  int v13; // ecx@3
  float v14; // ST28_4@3
  double v15; // st7@3
  float v16; // ST18_4@3
  double v17; // st7@3
  int v18; // eax@3
  int v19; // eax@7
  int v20; // eax@11
  _DWORD *v21; // eax@16
  signed int result; // eax@19
  _WORD *v23; // [sp+0h] [bp-24h]@1
  float v24; // [sp+Ch] [bp-18h]@1
  float v25; // [sp+10h] [bp-14h]@1
  float v26; // [sp+14h] [bp-10h]@1

  *(_DWORD *)a3 = a1;
  *(_DWORD *)(a3 + 4) = a2;
  v24 = 0.0;
  v25 = 0.0;
  v26 = 0.0;
  *(_DWORD *)(a3 + 8) = *(_BYTE *)(a1 + 16) != 0 ? 15 : 31;
  v3 = 0;
  v23 = (_WORD *)(a3 + 36);
  do
  {
    v4 = *(_DWORD *)(*(_DWORD *)a3 + 12);
    v5 = *(_BYTE *)(v4 + 4 * v3 + 1);
    v6 = (double)*(_BYTE *)(v4 + 4 * v3);
    v7 = *(_BYTE *)(v4 + 4 * v3 + 2);
    v8 = (double)v5;
    v9 = (double)v7;
    v24 = v6 + v24;
    *v23 = *(_BYTE *)(v4 + 4 * v3) + v5 + (_WORD)v7;
    v10 = a3 + 52;
    *(_DWORD *)(4 * v3 + a3 + 52) = v3;
    v25 = v8 + v25;
    ++v3;
    ++v23;
    v26 = v9 + v26;
  }
  while ( v3 < 8 );
  v11 = v24 * 0.125;
  *(float *)(a3 + 12) = v11;
  v12 = v25 * 0.125;
  *(float *)(a3 + 16) = v12;
  v13 = *(_DWORD *)(a3 + 8);
  v14 = 0.125 * v26;
  v15 = (double)*(signed int *)(a3 + 8);
  *(float *)(a3 + 20) = v14;
  v16 = v15;
  v17 = v16;
  v18 = (signed __int64)(v16 * *(float *)(a3 + 12) / 255.0 + 0.5);
  if ( v18 >= 0 )
  {
    if ( v18 > v13 )
      v18 = v13;
  }
  else
  {
    v18 = 0;
  }
  *(_DWORD *)(a3 + 24) = v18;
  v19 = (signed __int64)(*(float *)(a3 + 16) * v17 / 255.0 + 0.5);
  if ( v19 >= 0 )
  {
    if ( v19 > v13 )
      v19 = v13;
  }
  else
  {
    v19 = 0;
  }
  *(_DWORD *)(a3 + 28) = v19;
  v20 = (signed __int64)(v17 * *(float *)(a3 + 20) / 255.0 + 0.5);
  if ( v20 >= 0 )
  {
    if ( v20 > v13 )
      v20 = v13;
  }
  else
  {
    v20 = 0;
  }
  *(_DWORD *)(a3 + 32) = v20;
  if ( **(_DWORD **)a3 <= 1 )
  {
    v21 = (_DWORD *)sub_100334F0(a3 + 84, a3 + 36);
    *(_DWORD *)(a3 + 116) = v21;
    *(_DWORD *)(a3 + 120) = v10;
    if ( v21 == (_DWORD *)v10 )
      *(_DWORD *)(a3 + 120) = a3 + 84;
    **(_DWORD **)(a3 + 120) = *(_WORD *)(a3 + 2 * *v21 + 36);
    *(_DWORD *)(*(_DWORD *)(a3 + 120) + 4) = *(_WORD *)(a3 + 2 * *(_DWORD *)(*(_DWORD *)(a3 + 116) + 4) + 36);
    *(_DWORD *)(*(_DWORD *)(a3 + 120) + 8) = *(_WORD *)(a3 + 2 * *(_DWORD *)(*(_DWORD *)(a3 + 116) + 8) + 36);
    *(_DWORD *)(*(_DWORD *)(a3 + 120) + 12) = *(_WORD *)(a3 + 2 * *(_DWORD *)(*(_DWORD *)(a3 + 116) + 12) + 36);
    *(_DWORD *)(*(_DWORD *)(a3 + 120) + 16) = *(_WORD *)(a3 + 2 * *(_DWORD *)(*(_DWORD *)(a3 + 116) + 16) + 36);
    *(_DWORD *)(*(_DWORD *)(a3 + 120) + 20) = *(_WORD *)(a3 + 2 * *(_DWORD *)(*(_DWORD *)(a3 + 116) + 20) + 36);
    *(_DWORD *)(*(_DWORD *)(a3 + 120) + 24) = *(_WORD *)(a3 + 2 * *(_DWORD *)(*(_DWORD *)(a3 + 116) + 24) + 36);
    *(_DWORD *)(*(_DWORD *)(a3 + 120) + 28) = *(_WORD *)(a3 + 2 * *(_DWORD *)(*(_DWORD *)(a3 + 116) + 28) + 36);
  }
  *(_DWORD *)(a3 + 144) = 0;
  *(_DWORD *)(a3 + 148) = 0;
  *(_BYTE *)(a3 + 152) = 0;
  result = -1;
  *(_BYTE *)(a3 + 176) = 0;
  *(_DWORD *)(a3 + 168) = -1;
  *(_DWORD *)(a3 + 172) = -1;
  return result;
}

//----- (1008C960) --------------------------------------------------------
char __stdcall sub_1008C960(int a1, int a2, int a3, int a4)
{
  int v4; // ebp@1
  int v5; // eax@1
  int v6; // edx@2
  int v7; // esi@2
  int v8; // eax@2
  signed int v9; // edi@2
  char result; // al@12
  int v11; // ebx@13
  char *v12; // edi@13
  int v13; // eax@15
  signed int v14; // ecx@15
  signed int v15; // edx@15
  signed int v16; // esi@15
  unsigned __int8 v17; // al@19
  int v18; // eax@21
  signed int v19; // ecx@21
  signed int v20; // esi@21
  signed int v21; // eax@21
  unsigned __int8 v22; // dl@25
  int v23; // edx@27
  int v24; // eax@27
  signed int v25; // ecx@27
  signed int v26; // esi@27
  signed int v27; // edi@27
  unsigned __int8 v28; // bl@29
  unsigned __int8 v29; // al@31
  int v30; // eax@33
  int v31; // esi@33
  signed int v32; // ecx@33
  signed int v33; // edi@33
  char v34; // bl@35
  unsigned __int8 v35; // bl@37
  int v36; // ecx@39
  unsigned int v37; // ebx@39
  int v38; // edx@39
  int v39; // ecx@39
  int v40; // eax@39
  int v41; // ecx@39
  unsigned int v42; // edx@39
  __int64 v43; // rdi@39
  int v44; // ebx@41
  __int16 v45; // dx@42
  int v46; // eax@42
  int v47; // ebx@42
  int v48; // edx@42
  int v49; // ST1C_4@42
  int v50; // edi@42
  int v51; // ST20_4@42
  int v52; // ebp@42
  int v53; // ST14_4@42
  int v54; // edx@42
  unsigned int v55; // esi@42
  int v56; // ebp@42
  int v57; // esi@42
  unsigned __int64 v58; // kr40_8@42
  unsigned int v59; // edx@46
  unsigned __int64 v60; // kr58_8@46
  unsigned __int64 v61; // kr68_8@46
  unsigned int v62; // eax@47
  unsigned int v63; // ebx@48
  unsigned int v64; // eax@48
  int v65; // eax@51
  int v66; // ebp@51
  int *v67; // ebx@51
  int v68; // ebx@51
  int v69; // ebp@51
  int v70; // eax@51
  int v71; // kr2C_4@51
  int v72; // eax@56
  int v73; // ebp@56
  int v74; // ST20_4@56
  int v75; // eax@56
  int v76; // ebp@56
  unsigned int v77; // kr30_4@56
  int v78; // eax@56
  int v79; // ebp@56
  int v80; // ST20_4@56
  int v81; // eax@56
  int v82; // kr34_4@56
  int v83; // eax@58
  int v84; // ebx@58
  int v85; // ST20_4@58
  int v86; // eax@58
  int v87; // ecx@58
  unsigned __int64 v88; // kr88_8@59
  int v89; // eax@61
  int v90; // [sp+10h] [bp-70h]@13
  signed int v91; // [sp+14h] [bp-6Ch]@39
  unsigned int v92; // [sp+18h] [bp-68h]@47
  int v93; // [sp+1Ch] [bp-64h]@39
  unsigned __int8 v94; // [sp+20h] [bp-60h]@35
  unsigned int v95; // [sp+20h] [bp-60h]@47
  int v96; // [sp+24h] [bp-5Ch]@13
  int v97; // [sp+28h] [bp-58h]@13
  char *v98; // [sp+2Ch] [bp-54h]@13
  int v99; // [sp+30h] [bp-50h]@13
  int v100; // [sp+34h] [bp-4Ch]@13
  unsigned int v101; // [sp+38h] [bp-48h]@33
  int v102; // [sp+3Ch] [bp-44h]@51
  __int64 v103; // [sp+40h] [bp-40h]@54
  unsigned __int64 v104; // [sp+48h] [bp-38h]@54
  unsigned int v105; // [sp+54h] [bp-2Ch]@39
  int v106; // [sp+58h] [bp-28h]@39
  unsigned int v107; // [sp+5Ch] [bp-24h]@39
  int v108; // [sp+60h] [bp-20h]@21
  int v109; // [sp+64h] [bp-1Ch]@27
  int v110; // [sp+68h] [bp-18h]@33
  int v111; // [sp+6Ch] [bp-14h]@39
  unsigned int v112; // [sp+70h] [bp-10h]@21
  unsigned int v113; // [sp+7Ch] [bp-4h]@39

  v4 = a1;
  v5 = *(_DWORD *)a1;
  if ( *(_BYTE *)(*(_DWORD *)a1 + 32) )
  {
    v6 = *(_BYTE *)a2 - *(_BYTE *)(v5 + 28);
    v7 = *(_BYTE *)(a2 + 1) - *(_BYTE *)(v5 + 29);
    v8 = *(_BYTE *)(a2 + 2) - *(_BYTE *)(v5 + 30);
    v9 = v6;
    if ( v6 >= v7 )
      v9 = v7;
    if ( v9 >= v8 )
      v9 = v8;
    if ( v9 < -4 )
      goto LABEL_68;
    if ( v6 <= v7 )
      v6 = v7;
    if ( v6 > v8 )
      v8 = v6;
    if ( v8 > 3 )
    {
LABEL_68:
      *(_BYTE *)(a3 + 32) = 0;
      return 0;
    }
  }
  sub_100333F0((int)&v98, a2);
  *(_DWORD *)(a3 + 24) = -1;
  *(_DWORD *)(a3 + 28) = -1;
  v11 = BYTE2(v98);
  v12 = (char *)&unk_1009C5A0;
  v99 = 7;
  v100 = BYTE2(v98);
  v96 = BYTE1(v98);
  v97 = (unsigned __int8)v98;
  BYTE3(v90) = 0;
  v98 = (char *)&unk_1009C5A0;
  while ( 1 )
  {
    v13 = *((_DWORD *)v12 - 2);
    v14 = v13 + v97;
    v15 = v13 + v96;
    v16 = v11 + v13;
    if ( (v13 + v97) & 0xFFFFFF00 )
      LOBYTE(v14) = ~(v14 >> 31);
    LOBYTE(v90) = v14;
    if ( v15 & 0xFFFFFF00 )
      LOBYTE(v15) = ~(v15 >> 31);
    BYTE1(v90) = v15;
    v17 = v11 + v13;
    if ( v16 & 0xFFFFFF00 )
      v17 = ~(v16 >> 31);
    BYTE2(v90) = v17;
    v112 = (unsigned __int8)v14 + (unsigned __int8)v15 + v17;
    v18 = *((_DWORD *)v12 - 1);
    v108 = v90;
    v19 = v18 + v96;
    v20 = v11 + v18;
    v21 = v97 + v18;
    if ( v21 & 0xFFFFFF00 )
      LOBYTE(v21) = ~(v21 >> 31);
    LOBYTE(v90) = v21;
    if ( v19 & 0xFFFFFF00 )
      LOBYTE(v19) = ~(v19 >> 31);
    BYTE1(v90) = v19;
    v22 = v20;
    if ( v20 & 0xFFFFFF00 )
      v22 = ~(v20 >> 31);
    BYTE2(v90) = v22;
    v23 = (unsigned __int8)v21 + (unsigned __int8)v19 + v22;
    v24 = *(_DWORD *)v12;
    v109 = v90;
    v25 = v24 + v97;
    v26 = v24 + v96;
    v27 = v11 + v24;
    if ( (v24 + v97) & 0xFFFFFF00 )
      LOBYTE(v25) = ~(v25 >> 31);
    LOBYTE(v90) = v25;
    v28 = v24 + v96;
    if ( v26 & 0xFFFFFF00 )
      v28 = ~(v26 >> 31);
    BYTE1(v90) = v28;
    v29 = v27;
    if ( v27 & 0xFFFFFF00 )
      v29 = ~(v27 >> 31);
    BYTE2(v90) = v29;
    v110 = v90;
    v30 = (unsigned __int8)v25 + v28 + v29;
    v31 = *((_DWORD *)v98 + 1);
    v101 = v31 + v100;
    v32 = v31 + v97;
    v33 = v31 + v96;
    if ( (v31 + v97) & 0xFFFFFF00 )
      LOBYTE(v32) = ~(v32 >> 31);
    v34 = v31 + v96;
    LOBYTE(v90) = v32;
    v94 = v31 + v96;
    if ( v33 & 0xFFFFFF00 )
    {
      v34 = ~(v33 >> 31);
      v94 = ~(v33 >> 31);
    }
    BYTE1(v90) = v34;
    v35 = v101;
    if ( v101 & 0xFFFFFF00 )
      v35 = ~((signed int)v101 >> 31);
    BYTE2(v90) = v35;
    v32 = (unsigned __int8)v32;
    v111 = v90;
    v91 = v32;
    LODWORD(v43) = v35;
    v36 = v35 + v94 + (unsigned __int8)v32;
    v93 = v94;
    v37 = v23 + v112;
    v38 = v30 + v23;
    v113 = v36;
    v39 = v30 + v36;
    v40 = *(_DWORD *)v4;
    v107 = v39;
    v41 = *(_DWORD *)(v40 + 12);
    v101 = *(_DWORD *)(*(_DWORD *)(v4 + 120) + 28);
    v106 = v38;
    v42 = 0;
    v43 = (unsigned int)v43;
    v105 = v37;
    if ( 2 * v101 < v37 )
    {
      if ( v112 <= v101 || (v44 = a3, (unsigned __int64)abs(v112 - v101) < *(_QWORD *)(a3 + 24)) )
      {
        v45 = v108;
        *(_DWORD *)(v4 + 224) = 0;
        *(_DWORD *)(v4 + 228) = 0;
        v46 = (unsigned __int8)v45;
        v47 = HIBYTE(v45);
        v48 = HIBYTE(v45) - *(_BYTE *)(v41 + 1);
        v49 = BYTE2(v108);
        v50 = BYTE2(v108) - *(_BYTE *)(v41 + 2);
        v51 = v47;
        v52 = *(_BYTE *)(v41 + 10);
        v53 = v47 - *(_BYTE *)(v41 + 9);
        v55 = ((v49 - *(_BYTE *)(v41 + 14)) * (v49 - *(_BYTE *)(v41 + 14))
             + (v46 - *(_BYTE *)(v41 + 12)) * (v46 - *(_BYTE *)(v41 + 12))
             + (v51 - *(_BYTE *)(v41 + 13)) * (v51 - (unsigned int)*(_BYTE *)(v41 + 13))
             + (BYTE2(v108) - *(_BYTE *)(v41 + 6)) * (BYTE2(v108) - *(_BYTE *)(v41 + 6))
             + (v46 - *(_BYTE *)(v41 + 4)) * (v46 - *(_BYTE *)(v41 + 4))
             + (v47 - *(_BYTE *)(v41 + 5)) * (v47 - (unsigned int)*(_BYTE *)(v41 + 5))
             + (unsigned __int64)(v50 * v50 + (v46 - *(_BYTE *)v41) * (v46 - (unsigned int)*(_BYTE *)v41) + v48 * v48)
             + (BYTE2(v108) - v52) * (BYTE2(v108) - v52)
             + (v46 - *(_BYTE *)(v41 + 8)) * (v46 - (unsigned int)*(_BYTE *)(v41 + 8))
             + v53 * v53) >> 32;
        v54 = (v49 - *(_BYTE *)(v41 + 14)) * (v49 - *(_BYTE *)(v41 + 14))
            + (v46 - *(_BYTE *)(v41 + 12)) * (v46 - *(_BYTE *)(v41 + 12))
            + (v51 - *(_BYTE *)(v41 + 13)) * (v51 - *(_BYTE *)(v41 + 13))
            + (BYTE2(v108) - *(_BYTE *)(v41 + 6)) * (BYTE2(v108) - *(_BYTE *)(v41 + 6))
            + (v46 - *(_BYTE *)(v41 + 4)) * (v46 - *(_BYTE *)(v41 + 4))
            + (v47 - *(_BYTE *)(v41 + 5)) * (v47 - *(_BYTE *)(v41 + 5))
            + v50 * v50
            + (v46 - *(_BYTE *)v41) * (v46 - *(_BYTE *)v41)
            + v48 * v48
            + (BYTE2(v108) - v52) * (BYTE2(v108) - v52)
            + (v46 - *(_BYTE *)(v41 + 8)) * (v46 - *(_BYTE *)(v41 + 8))
            + v53 * v53;
        v56 = *(_BYTE *)(v41 + 26);
        v58 = __PAIR__(
                v55,
                (v49 - *(_BYTE *)(v41 + 18)) * (v49 - *(_BYTE *)(v41 + 18))
              + (v46 - *(_BYTE *)(v41 + 16)) * (v46 - *(_BYTE *)(v41 + 16))
              + (v47 - *(_BYTE *)(v41 + 17)) * (v47 - (unsigned int)*(_BYTE *)(v41 + 17)))
            + (unsigned int)v54
            + (BYTE2(v108) - *(_BYTE *)(v41 + 22)) * (BYTE2(v108) - *(_BYTE *)(v41 + 22))
            + (v46 - *(_BYTE *)(v41 + 20)) * (v46 - *(_BYTE *)(v41 + 20))
            + (v47 - *(_BYTE *)(v41 + 21)) * (v47 - (unsigned int)*(_BYTE *)(v41 + 21))
            + (v49 - v56) * (v49 - v56)
            + (v46 - *(_BYTE *)(v41 + 24)) * (v46 - *(_BYTE *)(v41 + 24))
            + (v47 - *(_BYTE *)(v41 + 25)) * (v47 - (unsigned int)*(_BYTE *)(v41 + 25));
        v57 = v58 >> 32;
        v4 = a1;
        v44 = a3;
        LODWORD(v43) = (v49 - *(_BYTE *)(v41 + 30)) * (v49 - *(_BYTE *)(v41 + 30))
                     + (v46 - *(_BYTE *)(v41 + 28)) * (v46 - *(_BYTE *)(v41 + 28))
                     + (v51 - *(_BYTE *)(v41 + 29)) * (v51 - *(_BYTE *)(v41 + 29));
        HIDWORD(v43) = (v43 + (unsigned __int64)(unsigned int)v58) >> 32;
        v42 = v43 + v58;
        goto LABEL_60;
      }
      goto LABEL_62;
    }
    v101 = **(_DWORD **)(v4 + 120);
    if ( 2 * v101 < v107 )
      break;
    if ( v101 <= v113 || (v44 = a3, (unsigned __int64)abs(v101 - v113) < *(_QWORD *)(a3 + 24)) )
    {
      *(_DWORD *)(v4 + 224) = 50529027;
      *(_DWORD *)(v4 + 228) = 50529027;
      HIDWORD(v43) = ((v91 - *(_BYTE *)(v41 + 4)) * (v91 - *(_BYTE *)(v41 + 4))
                    + (v94 - *(_BYTE *)(v41 + 5)) * (v94 - *(_BYTE *)(v41 + 5))
                    + ((_DWORD)v43 - *(_BYTE *)(v41 + 6)) * ((unsigned int)v43 - *(_BYTE *)(v41 + 6))
                    + (unsigned __int64)((v91 - *(_BYTE *)v41) * (v91 - *(_BYTE *)v41)
                                       + (v94 - *(_BYTE *)(v41 + 1)) * (v94 - *(_BYTE *)(v41 + 1))
                                       + ((_DWORD)v43 - *(_BYTE *)(v41 + 2)) * ((unsigned int)v43 - *(_BYTE *)(v41 + 2)))) >> 32;
      v59 = (v91 - *(_BYTE *)(v41 + 4)) * (v91 - *(_BYTE *)(v41 + 4))
          + (v94 - *(_BYTE *)(v41 + 5)) * (v94 - *(_BYTE *)(v41 + 5))
          + (v43 - *(_BYTE *)(v41 + 6)) * (v43 - *(_BYTE *)(v41 + 6))
          + (v91 - *(_BYTE *)v41) * (v91 - *(_BYTE *)v41)
          + (v94 - *(_BYTE *)(v41 + 1)) * (v94 - *(_BYTE *)(v41 + 1))
          + (v43 - *(_BYTE *)(v41 + 2)) * (v43 - *(_BYTE *)(v41 + 2));
      v60 = __PAIR__(
              HIDWORD(v43),
              (v91 - *(_BYTE *)(v41 + 8)) * (v91 - *(_BYTE *)(v41 + 8))
            + (v94 - *(_BYTE *)(v41 + 9)) * (v94 - *(_BYTE *)(v41 + 9))
            + (v43 - *(_BYTE *)(v41 + 10)) * (v43 - *(_BYTE *)(v41 + 10)))
          + v59
          + (v91 - *(_BYTE *)(v41 + 12)) * (v91 - *(_BYTE *)(v41 + 12))
          + (v94 - *(_BYTE *)(v41 + 13)) * (v94 - *(_BYTE *)(v41 + 13))
          + ((_DWORD)v43 - *(_BYTE *)(v41 + 14)) * ((unsigned int)v43 - *(_BYTE *)(v41 + 14))
          + (v91 - *(_BYTE *)(v41 + 16)) * (v91 - *(_BYTE *)(v41 + 16))
          + (v94 - *(_BYTE *)(v41 + 17)) * (v94 - *(_BYTE *)(v41 + 17))
          + ((_DWORD)v43 - *(_BYTE *)(v41 + 18)) * ((unsigned int)v43 - *(_BYTE *)(v41 + 18));
      HIDWORD(v43) = v60 >> 32;
      v61 = __PAIR__(
              HIDWORD(v43),
              (v91 - *(_BYTE *)(v41 + 20)) * (v91 - *(_BYTE *)(v41 + 20))
            + (v94 - *(_BYTE *)(v41 + 21)) * (v94 - *(_BYTE *)(v41 + 21))
            + (v43 - *(_BYTE *)(v41 + 22)) * (v43 - *(_BYTE *)(v41 + 22)))
          + (unsigned int)v60
          + (v91 - *(_BYTE *)(v41 + 24)) * (v91 - *(_BYTE *)(v41 + 24))
          + (v94 - *(_BYTE *)(v41 + 25)) * (v94 - *(_BYTE *)(v41 + 25))
          + ((_DWORD)v43 - *(_BYTE *)(v41 + 26)) * ((unsigned int)v43 - *(_BYTE *)(v41 + 26));
      HIDWORD(v43) = v61 >> 32;
      v4 = a1;
      LODWORD(v43) = (v91 - *(_BYTE *)(v41 + 28)) * (v91 - *(_BYTE *)(v41 + 28))
                   + (v94 - *(_BYTE *)(v41 + 29)) * (v94 - *(_BYTE *)(v41 + 29))
                   + (v43 - *(_BYTE *)(v41 + 30)) * (v43 - *(_BYTE *)(v41 + 30));
      v44 = a3;
      HIDWORD(v43) = (v43 + (unsigned __int64)(unsigned int)v61) >> 32;
      v42 = v43 + v61;
      goto LABEL_60;
    }
LABEL_62:
    --v99;
    v98 -= 16;
    if ( (signed int)v98 < (signed int)&unk_1009C530 )
      goto LABEL_63;
    v12 = v98;
    v11 = v100;
  }
  v62 = 0;
  v95 = 0;
  v92 = 0;
  while ( 1 )
  {
    v63 = v95;
    v64 = 2 * *(_DWORD *)(*(_DWORD *)(v4 + 120) + 4 * v62);
    if ( v64 >= *(&v105 + v95) )
      break;
LABEL_51:
    v65 = *(_DWORD *)(*(_DWORD *)(v4 + 116) + 4 * v92);
    *(_BYTE *)(v65 + v4 + 224) = v95;
    v66 = *(_BYTE *)(v41 + 4 * v65);
    v67 = &v108 + v95;
    v101 = (unsigned int)v67;
    v68 = *(_BYTE *)v67 - v66;
    v69 = *(_BYTE *)(v41 + 4 * v65 + 1);
    v102 = v68;
    v70 = *(_BYTE *)(v101 + 2) - *(_BYTE *)(v41 + 4 * v65 + 2);
    v71 = v102 * v102 + (*(_BYTE *)(v101 + 1) - v69) * (*(_BYTE *)(v101 + 1) - v69) + v70 * v70;
    v4 = a1;
    HIDWORD(v43) = (__PAIR__(HIDWORD(v43), v71) + v42) >> 32;
    v42 += v71;
    v62 = v92 + 1;
    v92 = v62;
    if ( v62 >= 8 )
      goto LABEL_54;
  }
  while ( 1 )
  {
    v95 = ++v63;
    if ( v63 > 2 )
      break;
    if ( v64 < *(&v105 + v63) )
      goto LABEL_51;
  }
  v62 = v92;
LABEL_54:
  v44 = a3;
  v104 = 0i64;
  v103 = 0i64;
  if ( v62 < 8 )
  {
    if ( (signed int)(8 - v62) >= 2 )
    {
      do
      {
        v72 = *(_DWORD *)(*(_DWORD *)(v4 + 116) + 4 * v62);
        *(_BYTE *)(v72 + v4 + 224) = 3;
        v73 = *(_BYTE *)(v41 + 4 * v72 + 1);
        v74 = v91 - *(_BYTE *)(v41 + 4 * v72);
        v75 = v43 - *(_BYTE *)(v41 + 4 * v72 + 2);
        v76 = v74 * v74 + (v93 - v73) * (v93 - v73) + v75 * v75;
        v77 = v104;
        LODWORD(v104) = v76 + v104;
        v78 = *(_DWORD *)(*(_DWORD *)(a1 + 116) + 4 * v92 + 4);
        v104 = __PAIR__(HIDWORD(v104), v76) + v77;
        *(_BYTE *)(a1 + v78 + 224) = 3;
        v79 = *(_BYTE *)(v41 + 4 * v78 + 1);
        v80 = v91 - *(_BYTE *)(v41 + 4 * v78);
        v81 = v43 - *(_BYTE *)(v41 + 4 * v78 + 2);
        v82 = v80 * v80 + (v93 - v79) * (v93 - v79) + v81 * v81;
        v4 = a1;
        v103 += (unsigned int)v82;
        v62 = v92 + 2;
        v92 = v62;
      }
      while ( v62 < 7 );
    }
    v44 = a3;
    if ( v62 < 8 )
    {
      v83 = *(_DWORD *)(*(_DWORD *)(v4 + 116) + 4 * v62);
      *(_BYTE *)(v83 + v4 + 224) = 3;
      v84 = *(_BYTE *)(v41 + 4 * v83);
      v101 = v83;
      v85 = v91 - v84;
      v86 = v93 - *(_BYTE *)(v41 + 4 * v83 + 1);
      v87 = *(_BYTE *)(v41 + 4 * v101 + 2);
      v44 = a3;
      LODWORD(v43) = v85 * v85 + v86 * v86 + (v43 - v87) * (v43 - v87);
      HIDWORD(v43) = (v43 + (unsigned __int64)v42) >> 32;
      v42 += v43;
    }
    v88 = v104 + v103 + __PAIR__(HIDWORD(v43), v42);
    HIDWORD(v43) = v88 >> 32;
    v42 = v88;
  }
LABEL_60:
  if ( __PAIR__(HIDWORD(v43), v42) >= *(_QWORD *)(v44 + 24) )
    goto LABEL_62;
  v89 = v99;
  *(_DWORD *)(v44 + 24) = v42;
  *(_DWORD *)(v44 + 28) = HIDWORD(v43);
  *(_DWORD *)(v44 + 4) = v89;
  *(_DWORD *)(v44 + 12) = *(_DWORD *)(v4 + 224);
  *(_DWORD *)(v44 + 16) = *(_DWORD *)(v4 + 228);
  *(_BYTE *)(v44 + 32) = 1;
  if ( HIDWORD(v43) | v42 )
    goto LABEL_62;
LABEL_63:
  *(_DWORD *)v44 = *(_DWORD *)a2;
  *(_BYTE *)(v44 + 8) = *(_BYTE *)(*(_DWORD *)v4 + 16);
  result = 0;
  if ( a4 )
  {
    if ( *(_QWORD *)(v44 + 24) < *(_QWORD *)(a4 + 24) )
    {
      *(_DWORD *)a4 = *(_DWORD *)v44;
      *(_DWORD *)(a4 + 4) = *(_DWORD *)(v44 + 4);
      *(_BYTE *)(a4 + 8) = *(_BYTE *)(v44 + 8);
      *(_BYTE *)(a4 + 12) = *(_BYTE *)(v44 + 12);
      *(_BYTE *)(a4 + 13) = *(_BYTE *)(v44 + 13);
      *(_BYTE *)(a4 + 14) = *(_BYTE *)(v44 + 14);
      *(_BYTE *)(a4 + 15) = *(_BYTE *)(v44 + 15);
      *(_BYTE *)(a4 + 16) = *(_BYTE *)(v44 + 16);
      *(_BYTE *)(a4 + 17) = *(_BYTE *)(v44 + 17);
      *(_BYTE *)(a4 + 18) = *(_BYTE *)(v44 + 18);
      *(_BYTE *)(a4 + 19) = *(_BYTE *)(v44 + 19);
      *(_DWORD *)(a4 + 24) = *(_DWORD *)(v44 + 24);
      *(_DWORD *)(a4 + 28) = *(_DWORD *)(v44 + 28);
      *(_BYTE *)(a4 + 32) = *(_BYTE *)(v44 + 32);
      result = 1;
    }
  }
  return result;
}

//----- (1008D380) --------------------------------------------------------
char __stdcall sub_1008D380(int a1, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // edx@2
  int v6; // esi@2
  int v7; // eax@2
  signed int v8; // ebp@2
  char result; // al@12
  int v10; // ecx@13
  int v11; // ebp@13
  int v12; // ebx@13
  _DWORD *v13; // edi@13
  int v14; // eax@15
  signed int v15; // esi@15
  signed int v16; // edx@15
  signed int v17; // eax@15
  unsigned __int8 v18; // al@19
  int v19; // eax@21
  signed int v20; // esi@21
  signed int v21; // edx@21
  signed int v22; // eax@21
  unsigned __int8 v23; // al@25
  signed int v24; // esi@27
  signed int v25; // edx@27
  signed int v26; // eax@27
  unsigned __int8 v27; // al@31
  int v28; // eax@33
  signed int v29; // edx@33
  signed int v30; // ecx@33
  signed int v31; // esi@33
  int v32; // eax@39
  int v33; // edx@41
  int v34; // esi@41
  int v35; // ebp@41
  int v36; // ecx@41
  int v37; // edi@41
  int v38; // eax@41
  int v39; // esi@41
  int v40; // ebp@41
  unsigned int v41; // eax@41
  int v42; // edi@41
  int v43; // ebp@43
  int v44; // edx@43
  int v45; // edi@43
  int v46; // esi@43
  char v47; // bl@44
  int v48; // edx@46
  int v49; // ebp@46
  int v50; // esi@46
  int v51; // edx@48
  unsigned __int64 v52; // kr08_8@48
  char v53; // dl@55
  unsigned int v54; // [sp+10h] [bp-6Ch]@13
  int v55; // [sp+14h] [bp-68h]@13
  int v56; // [sp+18h] [bp-64h]@41
  int v57; // [sp+1Ch] [bp-60h]@39
  void *v58; // [sp+20h] [bp-5Ch]@13
  int v59; // [sp+24h] [bp-58h]@13
  int v60; // [sp+28h] [bp-54h]@13
  int v61; // [sp+2Ch] [bp-50h]@13
  int v62; // [sp+30h] [bp-4Ch]@40
  int v63; // [sp+34h] [bp-48h]@39
  int v64; // [sp+38h] [bp-44h]@39
  int v65; // [sp+3Ch] [bp-40h]@39
  int v66; // [sp+40h] [bp-3Ch]@39
  int v67; // [sp+44h] [bp-38h]@39
  int v68; // [sp+48h] [bp-34h]@39
  int v69; // [sp+4Ch] [bp-30h]@39
  int v70; // [sp+50h] [bp-2Ch]@39
  int v71; // [sp+54h] [bp-28h]@39
  int v72; // [sp+58h] [bp-24h]@39
  int v73; // [sp+5Ch] [bp-20h]@39
  char v74[12]; // [sp+60h] [bp-1Ch]@39
  unsigned __int8 v75; // [sp+6Ch] [bp-10h]@17
  unsigned __int8 v76; // [sp+6Dh] [bp-Fh]@19
  unsigned __int8 v77; // [sp+6Eh] [bp-Eh]@21
  unsigned __int8 v78; // [sp+70h] [bp-Ch]@23
  unsigned __int8 v79; // [sp+71h] [bp-Bh]@25
  unsigned __int8 v80; // [sp+72h] [bp-Ah]@27
  unsigned __int8 v81; // [sp+74h] [bp-8h]@29
  unsigned __int8 v82; // [sp+75h] [bp-7h]@31
  unsigned __int8 v83; // [sp+76h] [bp-6h]@33

  *(_BYTE *)(a3 + 32) = 0;
  v4 = *(_DWORD *)a1;
  if ( !*(_BYTE *)(*(_DWORD *)a1 + 32) )
    goto LABEL_61;
  v5 = *(_BYTE *)a2 - *(_BYTE *)(v4 + 28);
  v6 = *(_BYTE *)(a2 + 1) - *(_BYTE *)(v4 + 29);
  v7 = *(_BYTE *)(a2 + 2) - *(_BYTE *)(v4 + 30);
  v8 = v5;
  if ( v5 >= v6 )
    v8 = v6;
  if ( v8 >= v7 )
    v8 = v7;
  if ( v8 < -4 )
    goto LABEL_62;
  if ( v5 <= v6 )
    v5 = v6;
  if ( v5 > v7 )
    v7 = v5;
  if ( v7 > 3 )
  {
LABEL_62:
    result = 0;
  }
  else
  {
LABEL_61:
    sub_100333F0((int)&v55, a2);
    v10 = BYTE2(v55);
    *(_DWORD *)(a3 + 24) = -1;
    *(_DWORD *)(a3 + 28) = -1;
    v54 = 0;
    v11 = BYTE1(v55);
    v12 = (unsigned __int8)v55;
    v13 = &unk_1009C530;
    v59 = v10;
    v60 = BYTE1(v55);
    v61 = (unsigned __int8)v55;
    v58 = &unk_1009C530;
    while ( 2 )
    {
      v14 = *(v13 - 2);
      v15 = v10 + v14;
      v16 = v14 + v11;
      v17 = v12 + v14;
      if ( v17 & 0xFFFFFF00 )
        LOBYTE(v17) = ~(v17 >> 31);
      v75 = v17;
      if ( v16 & 0xFFFFFF00 )
        LOBYTE(v16) = ~(v16 >> 31);
      v76 = v16;
      v18 = v15;
      if ( v15 & 0xFFFFFF00 )
        v18 = ~(v15 >> 31);
      v77 = v18;
      v19 = *(v13 - 1);
      v20 = v10 + v19;
      v21 = v19 + v11;
      v22 = v12 + v19;
      if ( v22 & 0xFFFFFF00 )
        LOBYTE(v22) = ~(v22 >> 31);
      v78 = v22;
      if ( v21 & 0xFFFFFF00 )
        LOBYTE(v21) = ~(v21 >> 31);
      v79 = v21;
      v23 = v20;
      if ( v20 & 0xFFFFFF00 )
        v23 = ~(v20 >> 31);
      v80 = v23;
      v24 = v10 + *v13;
      v25 = *v13 + v11;
      v26 = v12 + *v13;
      if ( v26 & 0xFFFFFF00 )
        LOBYTE(v26) = ~(v26 >> 31);
      v81 = v26;
      if ( v25 & 0xFFFFFF00 )
        LOBYTE(v25) = ~(v25 >> 31);
      v82 = v25;
      v27 = v24;
      if ( v24 & 0xFFFFFF00 )
        v27 = ~(v24 >> 31);
      v83 = v27;
      v28 = v13[1];
      v29 = v10 + v28;
      v30 = v12 + v28;
      v31 = v28 + v11;
      if ( (v12 + v28) & 0xFFFFFF00 )
        LOBYTE(v30) = ~(v30 >> 31);
      v55 = v28 + v11;
      if ( v31 & 0xFFFFFF00 )
        v55 = (unsigned __int8)~(v31 >> 31);
      if ( v29 & 0xFFFFFF00 )
        LOBYTE(v29) = ~(v29 >> 31);
      *(_QWORD *)&v74[4] = 0i64;
      v57 = 0;
      v63 = v75;
      v64 = v76;
      v65 = v77;
      v32 = *(_DWORD *)(*(_DWORD *)a1 + 12);
      v66 = v78;
      v67 = v79;
      v68 = v80;
      v69 = v81;
      v70 = v82;
      v72 = (unsigned __int8)v30;
      v71 = v83;
      v73 = (unsigned __int8)v55;
      *(_QWORD *)v74 = (unsigned __int8)v29;
      while ( 1 )
      {
        v33 = v32;
        v34 = *(_BYTE *)(v32 + 1);
        v35 = *(_BYTE *)(v32 + 2);
        v36 = *(_BYTE *)v32;
        v62 = v32 + 4;
        v56 = v36;
        v37 = v34 - v64;
        v38 = v35 - v65;
        v39 = (v34 - v67) * (v34 - v67);
        v40 = v35 - v68;
        v41 = (v36 - v63) * (v36 - v63) + v37 * v37 + v38 * v38;
        v42 = (v36 - v66) * (v36 - v66);
        v55 = 0;
        if ( v42 + v39 + v40 * v40 < v41 )
        {
          v41 = v42 + v39 + v40 * v40;
          v55 = 1;
        }
        v43 = *(_BYTE *)(v33 + 1);
        v44 = *(_BYTE *)(v33 + 2);
        v45 = (v43 - v70) * (v43 - v70);
        v46 = (v36 - v69) * (v36 - v69);
        if ( v46 + v45 + (v44 - v71) * (v44 - v71) >= v41 )
        {
          v47 = v55;
        }
        else
        {
          v41 = v46 + v45 + (v44 - v71) * (v44 - v71);
          v47 = 2;
        }
        v48 = v44 - *(_DWORD *)v74;
        v49 = (v43 - v73) * (v43 - v73);
        v50 = (v56 - v72) * (v56 - v72);
        if ( v50 + v49 + v48 * v48 < v41 )
        {
          v41 = v50 + v49 + v48 * v48;
          v47 = 3;
        }
        v51 = v57;
        v52 = *(_QWORD *)&v74[4] + v41;
        *(_BYTE *)(a1 + v57 + 224) = v47;
        *(_QWORD *)&v74[4] = v52;
        if ( HIDWORD(v52) > *(_DWORD *)(a3 + 28) )
          break;
        if ( HIDWORD(v52) >= *(_DWORD *)(a3 + 28) && (unsigned int)v52 >= *(_DWORD *)(a3 + 24)
          || (v57 = v51 + 1, (unsigned int)(v51 + 1) >= 8) )
        {
          if ( v52 < *(_QWORD *)(a3 + 24) )
          {
            *(_QWORD *)(a3 + 24) = v52;
            *(_DWORD *)(a3 + 4) = v54;
            *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 224);
            *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 228);
            *(_BYTE *)(a3 + 32) = 1;
          }
          break;
        }
        v32 = v62;
      }
      v13 = (char *)v58 + 16;
      ++v54;
      v58 = (char *)v58 + 16;
      if ( v54 < 8 )
      {
        v10 = v59;
        v11 = v60;
        v12 = v61;
        continue;
      }
      break;
    }
    *(_DWORD *)a3 = *(_DWORD *)a2;
    *(_BYTE *)(a3 + 8) = *(_BYTE *)(*(_DWORD *)a1 + 16);
    v53 = 0;
    if ( a4 )
    {
      if ( *(_QWORD *)(a3 + 24) < *(_QWORD *)(a4 + 24) )
      {
        sub_10033490(a4, a3);
        v53 = 1;
      }
    }
    result = v53;
  }
  return result;
}

//----- (1008D7C0) --------------------------------------------------------
char __stdcall sub_1008D7C0(int a1)
{
  int v1; // ebx@1
  int v2; // edx@1
  int v3; // eax@1
  int v4; // eax@2
  int v5; // ebp@2
  bool v6; // sf@2
  signed int v7; // ebp@2
  int v8; // eax@4
  int v9; // eax@5
  int v10; // edi@5
  signed int v11; // edi@5
  int v12; // eax@7
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // eax@9
  signed int v16; // eax@9
  char v17; // dl@11
  char v18; // al@13
  char v19; // al@15
  bool v20; // zf@17
  char v21; // al@18
  signed int v22; // esi@22
  _BYTE *v23; // ebp@25
  int *v24; // edi@25
  int v25; // ecx@27
  int v26; // eax@27
  int v27; // eax@31
  int v28; // eax@35
  signed int v29; // ecx@43
  double v30; // st7@43
  double v31; // st5@43
  signed int v32; // eax@43
  signed int v33; // edi@47
  double v34; // st5@47
  double v35; // st5@47
  signed int v36; // eax@47
  signed int v37; // edx@51
  double v38; // st5@51
  signed int v39; // eax@51
  _DWORD *v40; // ebp@64
  char v41; // dl@64
  char v42; // cl@66
  char v43; // al@71
  int v44; // eax@80
  char result; // al@81
  int v46; // [sp-8h] [bp-88h]@17
  int v47; // [sp-8h] [bp-88h]@70
  int v48; // [sp-4h] [bp-84h]@17
  int v49; // [sp-4h] [bp-84h]@70
  signed int v50; // [sp+10h] [bp-70h]@25
  signed int v51; // [sp+14h] [bp-6Ch]@25
  signed int v52; // [sp+18h] [bp-68h]@25
  unsigned int v53; // [sp+1Ch] [bp-64h]@1
  signed int v54; // [sp+20h] [bp-60h]@2
  int v55; // [sp+24h] [bp-5Ch]@25
  __int64 v56; // [sp+28h] [bp-58h]@26
  int v57; // [sp+30h] [bp-50h]@5
  int v58; // [sp+34h] [bp-4Ch]@24
  unsigned int v59; // [sp+38h] [bp-48h]@24
  int v60; // [sp+3Ch] [bp-44h]@7
  int v61; // [sp+40h] [bp-40h]@4
  int i; // [sp+44h] [bp-3Ch]@1
  int v63; // [sp+48h] [bp-38h]@5
  int v64; // [sp+4Ch] [bp-34h]@2
  __int64 v65; // [sp+50h] [bp-30h]@43
  __int64 v66; // [sp+58h] [bp-28h]@43
  int v67; // [sp+60h] [bp-20h]@9
  int v68; // [sp+64h] [bp-1Ch]@1
  char v69; // [sp+68h] [bp-18h]@13
  char v70; // [sp+69h] [bp-17h]@15
  char v71; // [sp+6Ah] [bp-16h]@17
  char v72; // [sp+6Bh] [bp-15h]@17
  int v73; // [sp+6Ch] [bp-14h]@17
  char v74; // [sp+70h] [bp-10h]@17
  char v75; // [sp+74h] [bp-Ch]@66
  char v76; // [sp+75h] [bp-Bh]@68
  char v77; // [sp+76h] [bp-Ah]@70
  char v78; // [sp+77h] [bp-9h]@70
  int v79; // [sp+78h] [bp-8h]@70
  char v80; // [sp+7Ch] [bp-4h]@70

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)a1 + 24);
  v3 = 0;
  v53 = *(_DWORD *)(*(_DWORD *)a1 + 8);
  v68 = v2;
  for ( i = 0; v3 < v2; i = v3 )
  {
    v4 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v1 + 20) + 4 * v3);
    v5 = *(_DWORD *)(v1 + 32);
    v6 = v4 + v5 < 0;
    v7 = v4 + v5;
    v64 = v4;
    v54 = v7;
    if ( !v6 )
    {
      if ( v7 > *(_DWORD *)(v1 + 8) )
        break;
      v8 = 0;
      v61 = 0;
      do
      {
        v9 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v1 + 20) + 4 * v8);
        v10 = *(_DWORD *)(v1 + 28);
        v6 = v9 + v10 < 0;
        v11 = v9 + v10;
        v63 = v9;
        v57 = v11;
        if ( !v6 )
        {
          if ( v11 > *(_DWORD *)(v1 + 8) )
            break;
          v12 = 0;
          v60 = 0;
          while ( 1 )
          {
            v13 = *(_DWORD *)v1;
            v14 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v1 + 20) + 4 * v12);
            v15 = *(_DWORD *)(v1 + 24);
            v6 = v14 + v15 < 0;
            v16 = v14 + v15;
            v67 = v16;
            if ( !v6 )
            {
              if ( v16 > *(_DWORD *)(v1 + 8) )
                break;
              v17 = *(_BYTE *)(v13 + 16);
              if ( v16 & 0xFFFFFF00 )
                LOBYTE(v16) = ~(v16 >> 31);
              v69 = v16;
              v18 = v11;
              if ( v11 & 0xFFFFFF00 )
                v18 = ~(v11 >> 31);
              v70 = v18;
              v19 = v7;
              if ( v7 & 0xFFFFFF00 )
                v19 = ~(v7 >> 31);
              v20 = *(_DWORD *)v13 == 2;
              v71 = v19;
              v48 = v1 + 144;
              v72 = -1;
              v73 = 0;
              v74 = v17;
              v46 = v1 + 184;
              if ( v20 )
                v21 = sub_1008D380(v1, (int)&v69, v46, v48);
              else
                v21 = sub_1008C960(v1, (int)&v69, v46, v48);
              if ( v21 )
              {
                v22 = **(_DWORD **)v1 ? ((v64 | v63 | v14) != 0 ? 2 : 4) : 2;
                v59 = v22;
                v58 = 0;
                if ( v22 )
                {
                  while ( 1 )
                  {
                    v23 = (_BYTE *)(v1 + 156);
                    v24 = &dword_1009C528[4 * *(_DWORD *)(v1 + 148)];
                    v52 = 0;
                    v50 = 0;
                    v51 = 0;
                    sub_100333F0((int)&v55, v1 + 144);
                    if ( v53 <= 0 )
                      break;
                    LODWORD(v56) = v53;
                    do
                    {
                      v25 = v24[*v23];
                      v26 = (unsigned __int8)v55 + v25;
                      ++v23;
                      if ( v26 >= 0 )
                      {
                        if ( v26 > 255 )
                          v26 = 255;
                      }
                      else
                      {
                        v26 = 0;
                      }
                      v52 += v26 - (unsigned __int8)v55;
                      v27 = BYTE1(v55) + v25;
                      if ( v27 >= 0 )
                      {
                        if ( v27 > 255 )
                          v27 = 255;
                      }
                      else
                      {
                        v27 = 0;
                      }
                      v50 += v27 - BYTE1(v55);
                      v28 = BYTE2(v55) + v25;
                      if ( v28 >= 0 )
                      {
                        if ( v28 > 255 )
                          v28 = 255;
                      }
                      else
                      {
                        v28 = 0;
                      }
                      v51 += v28 - BYTE2(v55);
                      LODWORD(v56) = v56 - 1;
                    }
                    while ( (_DWORD)v56 );
                    if ( !v52 && !v50 && !v51 )
                    {
                      v1 = a1;
                      break;
                    }
                    *(float *)&v56 = (double)v53;
                    v1 = a1;
                    v29 = *(_DWORD *)(a1 + 8);
                    *(float *)&v65 = (double)v50 / *(float *)&v56;
                    *(float *)&v66 = (double)v51 / *(float *)&v56;
                    v30 = *(float *)(a1 + 12);
                    *(float *)&v56 = (double)v52 / *(float *)&v56;
                    v31 = (v30 - *(float *)&v56) * (double)v29 / 255.0 + 0.5;
                    v56 = (signed __int64)v31;
                    v32 = (signed __int64)v31;
                    if ( v32 >= 0 )
                    {
                      if ( v32 <= v29 )
                        v29 = (signed __int64)v31;
                    }
                    else
                    {
                      v29 = 0;
                    }
                    v33 = *(_DWORD *)(a1 + 8);
                    v34 = *(float *)(a1 + 16) - *(float *)&v65;
                    LODWORD(v56) = *(_DWORD *)(a1 + 8);
                    v35 = v34 * (double)(signed int)v56 / 255.0 + 0.5;
                    v65 = (signed __int64)v35;
                    v36 = (signed __int64)v35;
                    if ( v36 >= 0 )
                    {
                      if ( v36 <= v33 )
                        v33 = (signed __int64)v35;
                    }
                    else
                    {
                      v33 = 0;
                    }
                    v37 = *(_DWORD *)(a1 + 8);
                    v38 = *(float *)(a1 + 20) - *(float *)&v66;
                    LODWORD(v65) = *(_DWORD *)(a1 + 8);
                    v66 = (signed __int64)(v38 * (double)(signed int)v65 / 255.0 + 0.5);
                    v39 = v66;
                    if ( (signed int)v66 >= 0 )
                    {
                      if ( (signed int)v66 > v37 )
                        v39 = v37;
                    }
                    else
                    {
                      v39 = 0;
                    }
                    if ( (v67 != v29 || v57 != v33 || v54 != v39)
                      && (v29 != *(_BYTE *)(a1 + 144) || v33 != *(_BYTE *)(a1 + 145) || v39 != *(_BYTE *)(a1 + 146))
                      && (*(_DWORD *)(a1 + 24) != v29 || *(_DWORD *)(a1 + 28) != v33 || *(_DWORD *)(a1 + 32) != v39) )
                    {
                      v40 = *(_DWORD **)a1;
                      v41 = *(_BYTE *)(*(_DWORD *)a1 + 16);
                      if ( v29 & 0xFFFFFF00 )
                        LOBYTE(v29) = ~(v29 >> 31);
                      v75 = v29;
                      v42 = v33;
                      if ( v33 & 0xFFFFFF00 )
                        v42 = ~(v33 >> 31);
                      v76 = v42;
                      if ( v39 & 0xFFFFFF00 )
                        LOBYTE(v39) = ~(v39 >> 31);
                      v20 = *v40 == 2;
                      v77 = v39;
                      v49 = a1 + 144;
                      v78 = -1;
                      v79 = 0;
                      v80 = v41;
                      v47 = a1 + 184;
                      v43 = v20 ? sub_1008D380(a1, (int)&v75, v47, v49) : sub_1008C960(a1, (int)&v75, v47, v49);
                      if ( v43 )
                      {
                        if ( ++v58 < v59 )
                          continue;
                      }
                    }
                    break;
                  }
                }
              }
            }
            v2 = v68;
            v7 = v54;
            v12 = v60 + 1;
            v60 = v12;
            if ( v12 >= v68 )
              break;
            v11 = v57;
          }
        }
        v8 = v61 + 1;
        v61 = v8;
      }
      while ( v8 < v2 );
    }
    v3 = i + 1;
  }
  v44 = *(_DWORD *)(v1 + 4);
  if ( *(_BYTE *)(v1 + 176) )
  {
    *(_DWORD *)v44 = *(_DWORD *)(v1 + 168);
    *(_DWORD *)(v44 + 4) = *(_DWORD *)(v1 + 172);
    *(_DWORD *)(*(_DWORD *)(v1 + 4) + 8) = *(_DWORD *)(v1 + 144);
    *(_BYTE *)(*(_DWORD *)(v1 + 4) + 24) = *(_BYTE *)(v1 + 152);
    *(_DWORD *)(*(_DWORD *)(v1 + 4) + 12) = *(_DWORD *)(v1 + 148);
    memcpy(*(void **)(*(_DWORD *)(v1 + 4) + 20), (const void *)(v1 + 156), v53);
    *(_DWORD *)(*(_DWORD *)(v1 + 4) + 16) = v53;
    result = 1;
  }
  else
  {
    *(_DWORD *)v44 = -1;
    *(_DWORD *)(v44 + 4) = 0;
    result = 0;
  }
  return result;
}
// 1009C528: using guessed type int dword_1009C528[];

//----- (1008DCE0) --------------------------------------------------------
signed int __usercall sub_1008DCE0@<eax>(int a1@<eax>, int a2@<edx>, unsigned __int16 a3)
{
  int *v3; // esi@1
  unsigned __int8 v4; // bl@1
  int v5; // edi@1
  int v6; // ebp@1
  int v7; // ecx@1
  signed int v8; // eax@1
  signed int v9; // eax@3
  signed int v10; // eax@5
  int v11; // ecx@7
  signed int v12; // eax@7
  signed int v13; // eax@9
  signed int v14; // eax@11
  int v15; // ecx@13
  signed int v16; // eax@13
  signed int v17; // eax@15
  signed int v18; // eax@17
  int v19; // esi@19
  signed int v20; // eax@19
  signed int v21; // eax@21
  signed int result; // eax@23

  v3 = &dword_1009C528[4 * a1];
  v4 = 16 * (a3 & 0xF) | a3 & 0xF;
  v5 = (unsigned __int8)(16 * (HIBYTE(a3) & 0xF) | HIBYTE(a3) & 0xF);
  v6 = (unsigned __int8)(16 * (((unsigned int)a3 >> 4) & 0xF) | ((unsigned int)a3 >> 4) & 0xF);
  v7 = *v3;
  v8 = *v3 + v5;
  if ( v8 & 0xFFFFFF00 )
    LOBYTE(v8) = ~(v8 >> 31);
  *(_BYTE *)a2 = v8;
  v9 = v7 + v6;
  if ( (v7 + v6) & 0xFFFFFF00 )
    LOBYTE(v9) = ~(v9 >> 31);
  *(_BYTE *)(a2 + 1) = v9;
  v10 = v7 + v4;
  if ( (v7 + v4) & 0xFFFFFF00 )
    LOBYTE(v10) = ~(v10 >> 31);
  *(_BYTE *)(a2 + 2) = v10;
  *(_BYTE *)(a2 + 3) = -1;
  v11 = v3[1];
  v12 = v11 + v5;
  if ( (v11 + v5) & 0xFFFFFF00 )
    LOBYTE(v12) = ~(v12 >> 31);
  *(_BYTE *)(a2 + 4) = v12;
  v13 = v11 + v6;
  if ( (v11 + v6) & 0xFFFFFF00 )
    LOBYTE(v13) = ~(v13 >> 31);
  *(_BYTE *)(a2 + 5) = v13;
  v14 = v11 + v4;
  if ( (v11 + v4) & 0xFFFFFF00 )
    LOBYTE(v14) = ~(v14 >> 31);
  *(_BYTE *)(a2 + 6) = v14;
  *(_BYTE *)(a2 + 7) = -1;
  v15 = v3[2];
  v16 = v15 + v5;
  if ( (v15 + v5) & 0xFFFFFF00 )
    LOBYTE(v16) = ~(v16 >> 31);
  *(_BYTE *)(a2 + 8) = v16;
  v17 = v15 + v6;
  if ( (v15 + v6) & 0xFFFFFF00 )
    LOBYTE(v17) = ~(v17 >> 31);
  *(_BYTE *)(a2 + 9) = v17;
  v18 = v15 + v4;
  if ( (v15 + v4) & 0xFFFFFF00 )
    LOBYTE(v18) = ~(v18 >> 31);
  *(_BYTE *)(a2 + 10) = v18;
  *(_BYTE *)(a2 + 11) = -1;
  v19 = v3[3];
  v20 = v19 + v5;
  if ( (v19 + v5) & 0xFFFFFF00 )
    LOBYTE(v20) = ~(v20 >> 31);
  *(_BYTE *)(a2 + 12) = v20;
  v21 = v19 + v6;
  if ( (v19 + v6) & 0xFFFFFF00 )
    LOBYTE(v21) = ~(v21 >> 31);
  *(_BYTE *)(a2 + 13) = v21;
  result = v19 + v4;
  *(_BYTE *)(a2 + 15) = -1;
  if ( (v19 + v4) & 0xFFFFFF00 )
    result = (unsigned __int8)~(result >> 31);
  *(_BYTE *)(a2 + 14) = result;
  return result;
}
// 1009C528: using guessed type int dword_1009C528[];

//----- (1008DE60) --------------------------------------------------------
char __usercall sub_1008DE60@<al>(int a1@<eax>, int a2@<esi>, unsigned __int16 a3, unsigned __int16 a4)
{
  int *v4; // edi@1
  char v5; // al@1
  int v6; // edx@1
  int v7; // ebx@1
  int v8; // ebp@1
  signed int v9; // ecx@1
  int v10; // eax@1
  signed int v11; // ecx@3
  signed int v12; // ecx@5
  int v13; // edx@7
  signed int v14; // ecx@7
  signed int v15; // ecx@9
  signed int v16; // ecx@11
  int v17; // edx@13
  signed int v18; // ecx@13
  signed int v19; // ecx@15
  signed int v20; // ecx@17
  int v21; // edx@19
  signed int v22; // ecx@19
  signed int v23; // ecx@21
  signed int v24; // ecx@23
  char result; // al@25
  char v26; // [sp+Fh] [bp-5h]@1
  int v27; // [sp+10h] [bp-4h]@1

  v4 = &dword_1009C528[4 * a1];
  v5 = sub_1008C470(a4, (int)&v27, a3);
  v6 = *v4;
  v7 = (unsigned __int8)v27;
  v8 = BYTE1(v27);
  v9 = *v4 + (unsigned __int8)v27;
  v26 = v5;
  v10 = BYTE2(v27);
  if ( v9 & 0xFFFFFF00 )
    LOBYTE(v9) = ~(v9 >> 31);
  *(_BYTE *)a2 = v9;
  v11 = v6 + v8;
  if ( (v6 + v8) & 0xFFFFFF00 )
    LOBYTE(v11) = ~(v11 >> 31);
  *(_BYTE *)(a2 + 1) = v11;
  v12 = v6 + v10;
  if ( (v6 + v10) & 0xFFFFFF00 )
    LOBYTE(v12) = ~(v12 >> 31);
  *(_BYTE *)(a2 + 2) = v12;
  *(_BYTE *)(a2 + 3) = -1;
  v13 = v4[1];
  v14 = v13 + v7;
  if ( (v13 + v7) & 0xFFFFFF00 )
    LOBYTE(v14) = ~(v14 >> 31);
  *(_BYTE *)(a2 + 4) = v14;
  v15 = v13 + v8;
  if ( (v13 + v8) & 0xFFFFFF00 )
    LOBYTE(v15) = ~(v15 >> 31);
  *(_BYTE *)(a2 + 5) = v15;
  v16 = v13 + v10;
  if ( (v13 + v10) & 0xFFFFFF00 )
    LOBYTE(v16) = ~(v16 >> 31);
  *(_BYTE *)(a2 + 6) = v16;
  *(_BYTE *)(a2 + 7) = -1;
  v17 = v4[2];
  v18 = v17 + v7;
  if ( (v17 + v7) & 0xFFFFFF00 )
    LOBYTE(v18) = ~(v18 >> 31);
  *(_BYTE *)(a2 + 8) = v18;
  v19 = v17 + v8;
  if ( (v17 + v8) & 0xFFFFFF00 )
    LOBYTE(v19) = ~(v19 >> 31);
  *(_BYTE *)(a2 + 9) = v19;
  v20 = v17 + v10;
  if ( (v17 + v10) & 0xFFFFFF00 )
    LOBYTE(v20) = ~(v20 >> 31);
  *(_BYTE *)(a2 + 10) = v20;
  *(_BYTE *)(a2 + 11) = -1;
  v21 = v4[3];
  v22 = v21 + v7;
  if ( (v21 + v7) & 0xFFFFFF00 )
    LOBYTE(v22) = ~(v22 >> 31);
  *(_BYTE *)(a2 + 12) = v22;
  v23 = v21 + v8;
  if ( (v21 + v8) & 0xFFFFFF00 )
    LOBYTE(v23) = ~(v23 >> 31);
  *(_BYTE *)(a2 + 13) = v23;
  v24 = v21 + v10;
  if ( (v21 + v10) & 0xFFFFFF00 )
    LOBYTE(v24) = ~(v24 >> 31);
  result = v26;
  *(_BYTE *)(a2 + 14) = v24;
  *(_BYTE *)(a2 + 15) = -1;
  return result;
}
// 1009C528: using guessed type int dword_1009C528[];

//----- (1008DFF0) --------------------------------------------------------
signed int __usercall sub_1008DFF0@<eax>(int a1@<eax>, int a2@<edx>, unsigned __int16 a3)
{
  int *v3; // ebp@1
  int v4; // esi@1
  int v5; // ecx@1
  int v6; // edi@1
  int v7; // ebx@1
  signed int v8; // eax@1
  signed int v9; // eax@3
  signed int v10; // eax@5
  int v11; // ecx@7
  signed int v12; // eax@7
  signed int v13; // eax@9
  signed int v14; // eax@11
  int v15; // ecx@13
  signed int v16; // eax@13
  signed int v17; // eax@15
  signed int v18; // eax@17
  int v19; // ebp@19
  signed int v20; // eax@19
  signed int v21; // eax@21
  signed int result; // eax@23

  v3 = &dword_1009C528[4 * a1];
  v4 = (unsigned __int8)(8 * (((unsigned int)a3 >> 10) & 0x1F) | ((((unsigned int)a3 >> 10) & 0x1F) >> 2));
  v5 = *v3;
  v6 = (unsigned __int8)(8 * (((unsigned int)a3 >> 5) & 0x1F) | ((((unsigned int)a3 >> 5) & 0x1F) >> 2));
  v7 = (unsigned __int8)(8 * (a3 & 0x1F) | ((unsigned __int8)(a3 & 0x1F) >> 2));
  v8 = *v3 + v4;
  if ( v8 & 0xFFFFFF00 )
    LOBYTE(v8) = ~(v8 >> 31);
  *(_BYTE *)a2 = v8;
  v9 = v5 + v6;
  if ( (v5 + v6) & 0xFFFFFF00 )
    LOBYTE(v9) = ~(v9 >> 31);
  *(_BYTE *)(a2 + 1) = v9;
  v10 = v5 + v7;
  if ( (v5 + v7) & 0xFFFFFF00 )
    LOBYTE(v10) = ~(v10 >> 31);
  *(_BYTE *)(a2 + 2) = v10;
  *(_BYTE *)(a2 + 3) = -1;
  v11 = v3[1];
  v12 = v11 + v4;
  if ( (v11 + v4) & 0xFFFFFF00 )
    LOBYTE(v12) = ~(v12 >> 31);
  *(_BYTE *)(a2 + 4) = v12;
  v13 = v11 + v6;
  if ( (v11 + v6) & 0xFFFFFF00 )
    LOBYTE(v13) = ~(v13 >> 31);
  *(_BYTE *)(a2 + 5) = v13;
  v14 = v11 + v7;
  if ( (v11 + v7) & 0xFFFFFF00 )
    LOBYTE(v14) = ~(v14 >> 31);
  *(_BYTE *)(a2 + 6) = v14;
  *(_BYTE *)(a2 + 7) = -1;
  v15 = v3[2];
  v16 = v15 + v4;
  if ( (v15 + v4) & 0xFFFFFF00 )
    LOBYTE(v16) = ~(v16 >> 31);
  *(_BYTE *)(a2 + 8) = v16;
  v17 = v15 + v6;
  if ( (v15 + v6) & 0xFFFFFF00 )
    LOBYTE(v17) = ~(v17 >> 31);
  *(_BYTE *)(a2 + 9) = v17;
  v18 = v15 + v7;
  if ( (v15 + v7) & 0xFFFFFF00 )
    LOBYTE(v18) = ~(v18 >> 31);
  *(_BYTE *)(a2 + 10) = v18;
  *(_BYTE *)(a2 + 11) = -1;
  v19 = v3[3];
  v20 = v4 + v19;
  if ( (v4 + v19) & 0xFFFFFF00 )
    LOBYTE(v20) = ~(v20 >> 31);
  *(_BYTE *)(a2 + 12) = v20;
  v21 = v6 + v19;
  if ( (v6 + v19) & 0xFFFFFF00 )
    LOBYTE(v21) = ~(v21 >> 31);
  *(_BYTE *)(a2 + 13) = v21;
  result = v7 + v19;
  *(_BYTE *)(a2 + 15) = -1;
  if ( (v7 + v19) & 0xFFFFFF00 )
    result = (unsigned __int8)~(result >> 31);
  *(_BYTE *)(a2 + 14) = result;
  return result;
}
// 1009C528: using guessed type int dword_1009C528[];

//----- (1008E180) --------------------------------------------------------
unsigned int __usercall sub_1008E180@<eax>(int a1@<eax>, int *a2@<ecx>, int a3)
{
  int v3; // esi@1
  int v4; // ecx@1
  int v5; // edi@1
  signed int v6; // edx@1
  int v7; // eax@1
  unsigned int v8; // ebp@13
  unsigned int result; // eax@14
  int v10; // ecx@17
  int v11; // ebx@17
  int v12; // ecx@17
  int v13; // ecx@21
  int v14; // esi@22
  int v15; // eax@22
  signed int v16; // eax@26
  int *v17; // eax@32
  char *v18; // edi@43
  int v19; // eax@45
  unsigned int v20; // ecx@45
  unsigned int v21; // eax@56
  char v22; // dl@63
  int v23; // ecx@63
  int v24; // eax@63
  char v25; // ah@64
  char v26; // ch@64
  int v27; // edi@64
  char v28; // dl@64
  char v29; // cl@69
  int v30; // eax@69
  int v31; // ecx@72
  char v32; // al@72
  int v33; // edx@72
  unsigned int v34; // eax@72
  bool v35; // zf@72
  char v36; // cl@72
  int v37; // esi@73
  char v38; // dl@73
  unsigned int v39; // eax@73
  int v40; // ecx@73
  unsigned int v41; // ecx@75
  int v42; // esi@75
  unsigned int v43; // edx@75
  unsigned int v44; // eax@75
  unsigned int v45; // ecx@75
  unsigned int v46; // edx@75
  unsigned __int8 v47; // [sp+14h] [bp-25Ch]@60
  unsigned __int8 v48; // [sp+15h] [bp-25Bh]@73
  unsigned __int8 v49; // [sp+16h] [bp-25Ah]@73
  unsigned __int8 v50; // [sp+17h] [bp-259h]@73
  unsigned __int8 v51; // [sp+18h] [bp-258h]@73
  unsigned __int8 v52; // [sp+19h] [bp-257h]@73
  unsigned __int8 v53; // [sp+1Ah] [bp-256h]@73
  unsigned __int8 v54; // [sp+1Bh] [bp-255h]@73
  unsigned __int8 v55; // [sp+1Ch] [bp-254h]@60
  unsigned __int8 v56; // [sp+1Dh] [bp-253h]@73
  unsigned __int8 v57; // [sp+1Eh] [bp-252h]@73
  unsigned __int8 v58; // [sp+1Fh] [bp-251h]@73
  unsigned __int8 v59; // [sp+20h] [bp-250h]@73
  unsigned __int8 v60; // [sp+21h] [bp-24Fh]@73
  unsigned __int8 v61; // [sp+22h] [bp-24Eh]@73
  unsigned __int8 v62; // [sp+23h] [bp-24Dh]@72
  bool i; // [sp+27h] [bp-249h]@17
  char *v64; // [sp+28h] [bp-248h]@1
  int v65; // [sp+2Ch] [bp-244h]@17
  unsigned __int64 v66; // [sp+30h] [bp-240h]@17
  int v67; // [sp+3Ch] [bp-234h]@17
  unsigned __int64 v68; // [sp+40h] [bp-230h]@17
  int v69; // [sp+48h] [bp-228h]@17
  int v70; // [sp+4Ch] [bp-224h]@17
  int v71; // [sp+50h] [bp-220h]@17
  int *v72; // [sp+54h] [bp-21Ch]@17
  bool v73; // [sp+58h] [bp-218h]@17
  float *v74; // [sp+5Ch] [bp-214h]@17
  int v75; // [sp+60h] [bp-210h]@17
  int v76; // [sp+64h] [bp-20Ch]@17
  char v77; // [sp+68h] [bp-208h]@17
  int v78; // [sp+6Ch] [bp-204h]@17
  int v79; // [sp+70h] [bp-200h]@17
  int v80; // [sp+74h] [bp-1FCh]@22
  int v81; // [sp+78h] [bp-1F8h]@22
  int v82; // [sp+7Ch] [bp-1F4h]@22
  int v83; // [sp+80h] [bp-1F0h]@22
  int v84; // [sp+84h] [bp-1ECh]@22
  int v85; // [sp+88h] [bp-1E8h]@22
  int v86; // [sp+8Ch] [bp-1E4h]@22
  char v87[8]; // [sp+90h] [bp-1E0h]@43
  int v88; // [sp+98h] [bp-1D8h]@32
  int v89; // [sp+9Ch] [bp-1D4h]@60
  size_t v90; // [sp+A0h] [bp-1D0h]@17
  void *v91; // [sp+A4h] [bp-1CCh]@17
  int v92; // [sp+B8h] [bp-1B8h]@60
  int v93; // [sp+BCh] [bp-1B4h]@60
  size_t v94; // [sp+C0h] [bp-1B0h]@17
  void *v95; // [sp+C4h] [bp-1ACh]@17
  unsigned __int64 v96; // [sp+D0h] [bp-1A0h]@23
  int v97; // [sp+D8h] [bp-198h]@55
  int v98; // [sp+DCh] [bp-194h]@55
  size_t v99; // [sp+E0h] [bp-190h]@17
  void *v100; // [sp+E4h] [bp-18Ch]@17
  char v101; // [sp+E8h] [bp-188h]@55
  int v102; // [sp+F8h] [bp-178h]@60
  int v103; // [sp+FCh] [bp-174h]@60
  int v104; // [sp+118h] [bp-158h]@60
  int v105; // [sp+11Ch] [bp-154h]@60
  char v106; // [sp+130h] [bp-140h]@17
  char v107; // [sp+138h] [bp-138h]@17
  char v108; // [sp+140h] [bp-130h]@17
  int v109; // [sp+148h] [bp-128h]@17
  int v110; // [sp+14Ch] [bp-124h]@17
  int v111; // [sp+1BCh] [bp-B4h]@17
  int v112; // [sp+1C0h] [bp-B0h]@17
  int v113; // [sp+1D8h] [bp-98h]@17
  int v114; // [sp+1DCh] [bp-94h]@17
  char v115; // [sp+1E0h] [bp-90h]@17
  int v116; // [sp+1F0h] [bp-80h]@17
  int v117; // [sp+1F4h] [bp-7Ch]@17
  char v118; // [sp+1F8h] [bp-78h]@17
  int v119; // [sp+200h] [bp-70h]@17
  int v120; // [sp+204h] [bp-6Ch]@17
  char v121; // [sp+208h] [bp-68h]@17
  int v122; // [sp+218h] [bp-58h]@17
  int v123; // [sp+21Ch] [bp-54h]@17
  char v124; // [sp+220h] [bp-50h]@17
  char v125; // [sp+230h] [bp-40h]@16

  v3 = (int)a2;
  v4 = *a2;
  v5 = a1;
  v64 = (char *)v3;
  v6 = 15;
  v7 = v3 + 52;
  while ( *(_DWORD *)(v7 + 8) == v4 )
  {
    if ( *(_DWORD *)(v7 + 4) != v4 )
    {
      --v6;
      break;
    }
    if ( *(_DWORD *)v7 != v4 )
    {
      v6 -= 2;
      break;
    }
    if ( *(_DWORD *)(v7 - 4) != v4 )
    {
      v6 -= 3;
      break;
    }
    if ( *(_DWORD *)(v7 - 8) != v4 )
    {
      v6 -= 4;
      break;
    }
    v6 -= 5;
    v7 -= 20;
    if ( v6 < 1 )
      break;
  }
  v8 = 0;
  if ( !v6 )
    return 16 * sub_1008BC80(a3, v3);
  if ( *(_BYTE *)(v5 + 4) )
  {
    sub_1008B8C0(&v125, v3);
    v64 = &v125;
  }
  v91 = &v106;
  v95 = &v107;
  v100 = &v108;
  v10 = *(_DWORD *)v5;
  v11 = 0;
  v90 = 8;
  v94 = 8;
  v99 = 8;
  v69 = v10;
  v12 = *(_DWORD *)(v5 + 4);
  v71 = 8;
  v113 = 0;
  v114 = 0;
  v115 = 0;
  v116 = -1;
  v117 = -1;
  v118 = 0;
  v119 = 0;
  v120 = 0;
  v121 = 0;
  v122 = -1;
  v123 = -1;
  v124 = 0;
  v109 = 0;
  v110 = 0;
  v112 = 0;
  v111 = 0;
  v68 = -1i64;
  v78 = 0;
  v67 = 0;
  v70 = v12;
  v73 = 0;
  v74 = &flt_100A4EC8;
  v75 = 1;
  v76 = 0;
  v77 = 0;
  v72 = &v79;
  v65 = 0;
  v66 = 0i64;
  for ( i = 0; ; i = 0 )
  {
    while ( 1 )
    {
      do
      {
        if ( v65 )
        {
          qmemcpy(&v79, &v64[32 * v8], 0x20u);
          v13 = v79;
        }
        else
        {
          v13 = *(_DWORD *)&v64[8 * v8];
          v80 = *(_DWORD *)&v64[8 * v8 + 16];
          v81 = *(_DWORD *)&v64[8 * v8 + 32];
          v82 = *(_DWORD *)&v64[8 * v8 + 48];
          v83 = *(_DWORD *)&v64[8 * v8 + 4];
          v84 = *(_DWORD *)&v64[8 * v8 + 20];
          v14 = *(_DWORD *)&v64[8 * v8 + 36];
          v15 = *(_DWORD *)&v64[8 * v8 + 52];
          v79 = v13;
          v85 = v14;
          v86 = v15;
        }
        v96 = -1i64;
        if ( v69 >= 1 && (v8 || v11) )
        {
          v16 = 7;
          do
          {
            if ( *(&v79 + v16) != v13 )
              break;
            --v16;
          }
          while ( v16 >= 1 );
          if ( !v16 )
          {
            if ( !v8 || v11 )
              v17 = 0;
            else
              v17 = &v88;
            sub_1008BF90((int)&v96, (int)&v79, v11 == 0, (int)v17);
          }
        }
        v73 = i;
        v77 = 0;
        if ( !v11 && v8 )
        {
          v77 = 1;
          v76 = v88;
        }
        if ( v69 == 2 )
        {
          v75 = 9;
          v74 = (float *)&unk_100A4ECC;
        }
        else if ( v69 == 1 )
        {
          v75 = 3;
          v74 = (float *)&unk_100A4EF0;
        }
        else
        {
          v75 = 1;
          v74 = &flt_100A4EC8;
        }
        v18 = &v87[32 * v8];
        sub_1008C5B0((int)&v69, (int)&v87[32 * v8], (int)&v109);
        if ( !sub_1008D7C0((int)&v109) )
        {
LABEL_59:
          if ( v8 < 2 )
            goto LABEL_61;
          break;
        }
        if ( v69 >= 1 )
        {
          v19 = *((_DWORD *)v18 + 1);
          v20 = *(_DWORD *)v18;
          if ( v19 || v20 > 0xBB8 )
          {
            if ( v69 == 1 )
            {
              v75 = 4;
              v74 = (float *)&unk_100A4EFC;
            }
            else if ( v19 || v20 > 0x1770 )
            {
              v75 = 8;
              v74 = (float *)&unk_100A4F14;
            }
            else
            {
              v75 = 2;
              v74 = (float *)&unk_100A4F0C;
            }
            if ( !sub_1008D7C0((int)&v109) )
              goto LABEL_59;
          }
          if ( v96 < *(_QWORD *)v18 )
          {
            *((_DWORD *)v18 + 2) = v97;
            v18[24] = v101;
            *((_DWORD *)v18 + 3) = v98;
            *(_QWORD *)v18 = v96;
            memcpy(*((void **)v18 + 5), v100, v99);
          }
        }
        v21 = (*(_QWORD *)v18 + v66) >> 32;
        LODWORD(v66) = *(_DWORD *)v18 + v66;
        HIDWORD(v66) = v21;
        if ( __PAIR__(v21, (unsigned int)v66) >= v68 )
          goto LABEL_59;
        ++v8;
      }
      while ( v8 < 2 );
      v68 = v66;
      v102 = v88;
      v103 = v89;
      memcpy(&v47, v91, v90);
      v104 = v92;
      v105 = v93;
      memcpy(&v55, v95, v94);
      v78 = v65;
      v67 = v11;
LABEL_61:
      if ( (unsigned int)++v11 >= 2 )
        break;
      v8 = 0;
      v66 = 0i64;
      i = v11 != 0;
    }
    if ( (unsigned int)++v65 >= 2 )
      break;
    v8 = 0;
    v11 = 0;
    v66 = 0i64;
  }
  v22 = BYTE2(v102);
  v23 = (unsigned __int8)v104 - (unsigned __int8)v102;
  v24 = BYTE1(v104) - BYTE1(v102);
  v64 = (char *)(BYTE2(v104) - BYTE2(v102));
  if ( v67 )
  {
    v25 = BYTE1(v102);
    v26 = BYTE1(v104);
    v27 = a3;
    v28 = BYTE2(v104) | 16 * BYTE2(v102);
    *(_BYTE *)a3 = v104 | 16 * v102;
    *(_BYTE *)(a3 + 1) = v26 | 16 * v25;
  }
  else
  {
    if ( v23 < 0 )
      LOBYTE(v23) = v23 + 8;
    v27 = a3;
    *(_BYTE *)a3 = v23 | 8 * v102;
    if ( v24 < 0 )
      LOBYTE(v24) = v24 + 8;
    v29 = v24 | 8 * BYTE1(v102);
    v30 = (int)v64;
    *(_BYTE *)(a3 + 1) = v29;
    if ( v30 < 0 )
      LOBYTE(v30) = v30 + 8;
    v28 = v30 | 8 * v22;
  }
  v31 = v78;
  v32 = 2 * (~(_BYTE)v67 & 1 | 2 * (v105 | 8 * v103));
  *(_BYTE *)(v27 + 2) = v28;
  v33 = v62;
  *(_BYTE *)(v27 + 3) = v31 | v32;
  v34 = (unsigned __int8)byte_1009C5A8[v33];
  v35 = v31 == 0;
  v36 = byte_1009C5A8[v33];
  if ( v35 )
  {
    v37 = 2
        * (2
         * (2
          * (2
           * (2
            * (2
             * (2
              * (2
               * (2
                * (2 * (2 * (2 * (v36 & 1) | byte_1009C5A8[v61] & 1) | byte_1009C5A8[v60] & 1) | byte_1009C5A8[v59] & 1) | byte_1009C5A8[v58] & 1) | byte_1009C5A8[v57] & 1) | byte_1009C5A8[v56] & 1) | byte_1009C5A8[v55] & 1) | byte_1009C5A8[v54] & 1) | byte_1009C5A8[v53] & 1) | byte_1009C5A8[v52] & 1) | byte_1009C5A8[v51] & 1) | byte_1009C5A8[v50] & 1;
    v38 = byte_1009C5A8[v49];
    v39 = 2
        * (2
         * (2
          * (2
           * (2
            * (2
             * (2
              * (2
               * (2
                * (2
                 * (2
                  * (2 * (2 * (v34 >> 1) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v61] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v60] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v59] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v58] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v57] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v56] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v55] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v54] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v53] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v52] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v51] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v50] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v49] >> 1);
    v40 = v48;
  }
  else
  {
    v37 = 2
        * (2
         * (2
          * (2
           * (2
            * (2
             * (2
              * (2
               * (2
                * (2 * (2 * (2 * (v36 & 1) | byte_1009C5A8[v58] & 1) | byte_1009C5A8[v54] & 1) | byte_1009C5A8[v50] & 1) | byte_1009C5A8[v61] & 1) | byte_1009C5A8[v57] & 1) | byte_1009C5A8[v53] & 1) | byte_1009C5A8[v49] & 1) | byte_1009C5A8[v60] & 1) | byte_1009C5A8[v56] & 1) | byte_1009C5A8[v52] & 1) | byte_1009C5A8[v48] & 1) | byte_1009C5A8[v59] & 1;
    v38 = byte_1009C5A8[v55];
    v39 = 2
        * (2
         * (2
          * (2
           * (2
            * (2
             * (2
              * (2
               * (2
                * (2
                 * (2
                  * (2 * (2 * (v34 >> 1) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v58] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v54] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v50] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v61] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v57] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v53] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v49] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v60] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v56] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v52] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v48] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v59] >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v55] >> 1);
    v40 = v51;
  }
  v41 = (unsigned __int8)byte_1009C5A8[v40];
  v42 = 2 * (2 * v37 | v38 & 1) | v41 & 1;
  v43 = 2 * (2 * v39 | (v41 >> 1)) | ((unsigned int)(unsigned __int8)byte_1009C5A8[v47] >> 1);
  v44 = 2 * v42 | byte_1009C5A8[v47] & 1;
  *(_BYTE *)(v27 + 5) = v43;
  v45 = v43 >> 8;
  v46 = v44 >> 8;
  *(_BYTE *)(v27 + 7) = v44;
  result = v68;
  *(_BYTE *)(v27 + 4) = v45;
  *(_BYTE *)(v27 + 6) = v46;
  return result;
}
// 100A4EC8: using guessed type float flt_100A4EC8;
// 1008E180: using guessed type char var_1E0[8];

//----- (1008EAC0) --------------------------------------------------------
char __usercall sub_1008EAC0@<al>(int a1@<eax>, int a2@<edi>, char a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // eax@1
  int v6; // esi@1
  unsigned __int8 v7; // ST19_1@2
  unsigned __int8 v8; // ST1A_1@2
  unsigned __int16 v9; // ST20_2@2
  __int16 v10; // si@2
  unsigned int v11; // edx@6
  int v12; // eax@6
  int v13; // esi@7
  int v14; // esi@7
  char v15; // cl@7
  int *v16; // esi@7
  int v17; // esi@7
  char v18; // cl@7
  int *v19; // esi@7
  unsigned int v20; // esi@7
  int v21; // esi@7
  char v22; // cl@7
  int *v23; // esi@7
  unsigned int v24; // edx@8
  int v25; // eax@8
  int v26; // esi@9
  int v27; // esi@9
  char v28; // cl@9
  int *v29; // esi@9
  int v30; // esi@9
  char v31; // cl@9
  int *v32; // esi@9
  unsigned int v33; // esi@9
  int v34; // esi@9
  char v35; // cl@9
  int *v36; // esi@9
  char result; // al@10
  int v38; // esi@11
  int v39; // esi@11
  char v40; // cl@11
  int *v41; // esi@11
  int v42; // esi@11
  char v43; // cl@11
  int *v44; // esi@11
  char v45; // cl@11
  unsigned int v46; // esi@11
  char v47; // cl@11
  int v48; // esi@11
  char v49; // cl@11
  int *v50; // esi@11
  char v51; // [sp+Ch] [bp-34h]@1
  char v52; // [sp+Fh] [bp-31h]@1
  int v53; // [sp+18h] [bp-28h]@1
  int v54[4]; // [sp+20h] [bp-20h]@2
  int v55[4]; // [sp+30h] [bp-10h]@2
  int v56; // [sp+44h] [bp+4h]@7
  int v57; // [sp+44h] [bp+4h]@9

  v3 = a1;
  v52 = *(_BYTE *)(a2 + 3) & 1;
  v4 = *(_BYTE *)(a2 + 3);
  v5 = v4 >> 5;
  v6 = (v4 >> 2) & 7;
  v53 = (v4 >> 2) & 7;
  v51 = 1;
  if ( (*(_BYTE *)(a2 + 3) >> 1) & 1 )
  {
    v7 = *(_BYTE *)(a2 + 1);
    v8 = *(_BYTE *)(a2 + 2);
    v9 = (v8 >> 3) | 32 * ((v7 >> 3) | 32 * (unsigned __int8)(*(_BYTE *)a2 >> 3));
    v10 = *(_BYTE *)a2 & 7;
    sub_1008DFF0(v5, (int)v54, v9);
    if ( !sub_1008DE60(v53, (int)v55, v9, v8 & 7 | 8 * (v7 & 7 | 8 * v10)) )
      v51 = 0;
  }
  else
  {
    sub_1008DCE0(
      v5,
      (int)v54,
      (unsigned __int8)(*(_BYTE *)(a2 + 2) >> 4) | (unsigned __int16)(16
                                                                    * ((unsigned __int8)(*(_BYTE *)(a2 + 1) >> 4) | (unsigned __int16)(16 * (unsigned __int8)(*(_BYTE *)a2 >> 4)))));
    sub_1008DCE0(v6, (int)v55, *(_BYTE *)(a2 + 2) & 0xF | 16 * (*(_BYTE *)(a2 + 1) & 0xF | 16 * (*(_BYTE *)a2 & 0xF)));
  }
  if ( a3 )
  {
    v11 = 8;
    v12 = v3 + 6;
    if ( v52 )
    {
      do
      {
        v13 = (unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 - ((v11 - 8) >> 3) + 7) >> ((v11 - 8) & 7)) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 - ((v11 - 8) >> 3) + 5) >> ((v11 - 8) & 7)) & 1)];
        *(_BYTE *)v3 = v54[v13];
        *(_BYTE *)(v12 - 5) = BYTE1(v54[v13]);
        *(_BYTE *)(v12 - 4) = BYTE2(v54[v13]);
        v14 = (unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 - ((v11 - 4) >> 3) + 7) >> ((v11 - 4) & 7)) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 - ((v11 - 4) >> 3) + 5) >> ((v11 - 4) & 7)) & 1)];
        v15 = v54[v14];
        v16 = &v54[v14];
        *(_BYTE *)(v12 - 2) = v15;
        *(_BYTE *)(v12 - 1) = *((_BYTE *)v16 + 1);
        *(_BYTE *)v12 = *((_BYTE *)v16 + 2);
        v17 = (unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 - (v11 >> 3) + 7) >> (v11 & 7)) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 - (v11 >> 3) + 5) >> (v11 & 7)) & 1)];
        v18 = v54[v17];
        v19 = &v54[v17];
        *(_BYTE *)(v12 + 2) = v18;
        *(_BYTE *)(v12 + 3) = *((_BYTE *)v19 + 1);
        *(_BYTE *)(v12 + 4) = *((_BYTE *)v19 + 2);
        v20 = a2 - ((v11 + 4) >> 3);
        v56 = ((_BYTE)v11++ + 4) & 7;
        v21 = (unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(v20 + 7) >> v56) & 1 | 2
                                                                                            * (((unsigned int)*(_BYTE *)(v20 + 5) >> v56) & 1)];
        v22 = v54[v21];
        v23 = &v54[v21];
        *(_BYTE *)(v12 + 6) = v22;
        *(_BYTE *)(v12 + 7) = *((_BYTE *)v23 + 1);
        *(_BYTE *)(v12 + 8) = *((_BYTE *)v23 + 2);
        v3 += 16;
        v12 += 16;
      }
      while ( v11 - 8 < 2 );
      v24 = 10;
      v25 = v3 + 6;
      do
      {
        v26 = (unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 - ((v24 - 8) >> 3) + 7) >> ((v24 - 8) & 7)) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 - ((v24 - 8) >> 3) + 5) >> ((v24 - 8) & 7)) & 1)];
        *(_BYTE *)v3 = v55[v26];
        *(_BYTE *)(v25 - 5) = BYTE1(v55[v26]);
        *(_BYTE *)(v25 - 4) = BYTE2(v55[v26]);
        v27 = (unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 - ((v24 - 4) >> 3) + 7) >> ((v24 - 4) & 7)) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 - ((v24 - 4) >> 3) + 5) >> ((v24 - 4) & 7)) & 1)];
        v28 = v55[v27];
        v29 = &v55[v27];
        *(_BYTE *)(v25 - 2) = v28;
        *(_BYTE *)(v25 - 1) = *((_BYTE *)v29 + 1);
        *(_BYTE *)v25 = *((_BYTE *)v29 + 2);
        v30 = (unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 - (v24 >> 3) + 7) >> (v24 & 7)) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 - (v24 >> 3) + 5) >> (v24 & 7)) & 1)];
        v31 = v55[v30];
        v32 = &v55[v30];
        *(_BYTE *)(v25 + 2) = v31;
        *(_BYTE *)(v25 + 3) = *((_BYTE *)v32 + 1);
        *(_BYTE *)(v25 + 4) = *((_BYTE *)v32 + 2);
        v33 = a2 - ((v24 + 4) >> 3);
        v57 = ((_BYTE)v24++ + 4) & 7;
        v34 = (unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(v33 + 7) >> v57) & 1 | 2
                                                                                            * (((unsigned int)*(_BYTE *)(v33 + 5) >> v57) & 1)];
        v35 = v55[v34];
        v36 = &v55[v34];
        *(_BYTE *)(v25 + 6) = v35;
        *(_BYTE *)(v25 + 7) = *((_BYTE *)v36 + 1);
        *(_BYTE *)(v25 + 8) = *((_BYTE *)v36 + 2);
        v3 += 16;
        v25 += 16;
      }
      while ( v24 - 8 < 4 );
      result = v51;
    }
    else
    {
      do
      {
        v38 = (unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 - ((v11 - 8) >> 3) + 7) >> ((v11 - 8) & 7)) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 - ((v11 - 8) >> 3) + 5) >> ((v11 - 8) & 7)) & 1)];
        *(_BYTE *)(v12 - 6) = v54[v38];
        *(_BYTE *)(v12 - 5) = BYTE1(v54[v38]);
        *(_BYTE *)(v12 - 4) = BYTE2(v54[v38]);
        v39 = (unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 - ((v11 - 4) >> 3) + 7) >> ((v11 - 4) & 7)) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 - ((v11 - 4) >> 3) + 5) >> ((v11 - 4) & 7)) & 1)];
        v40 = v54[v39];
        v41 = &v54[v39];
        *(_BYTE *)(v12 - 2) = v40;
        *(_BYTE *)(v12 - 1) = *((_BYTE *)v41 + 1);
        *(_BYTE *)v12 = *((_BYTE *)v41 + 2);
        v42 = (unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 - (v11 >> 3) + 7) >> (v11 & 7)) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 - (v11 >> 3) + 5) >> (v11 & 7)) & 1)];
        v43 = v55[v42];
        v44 = &v55[v42];
        *(_BYTE *)(v12 + 2) = v43;
        *(_BYTE *)(v12 + 3) = *((_BYTE *)v44 + 1);
        v45 = *((_BYTE *)v44 + 2);
        v46 = a2 - ((v11 + 4) >> 3);
        *(_BYTE *)(v12 + 4) = v45;
        v47 = (v11++ + 4) & 7;
        v12 += 16;
        v48 = (unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(v46 + 7) >> v47) & 1 | 2
                                                                                            * (((unsigned int)*(_BYTE *)(v46 + 5) >> v47) & 1)];
        v49 = v55[v48];
        v50 = &v55[v48];
        *(_BYTE *)(v12 - 10) = v49;
        *(_BYTE *)(v12 - 9) = *((_BYTE *)v50 + 1);
        *(_BYTE *)(v12 - 8) = *((_BYTE *)v50 + 2);
      }
      while ( v11 - 8 < 4 );
      result = v51;
    }
  }
  else if ( v52 )
  {
    *(_DWORD *)v3 = v54[(unsigned __int8)byte_1009C524[*(_BYTE *)(a2 + 7) & 1 | 2 * (*(_BYTE *)(a2 + 5) & 1)]];
    *(_DWORD *)(v3 + 4) = v54[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 7) >> 4) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 5) >> 4) & 1)]];
    *(_DWORD *)(v3 + 8) = v54[(unsigned __int8)byte_1009C524[*(_BYTE *)(a2 + 6) & 1 | 2 * (*(_BYTE *)(a2 + 4) & 1)]];
    *(_DWORD *)(v3 + 12) = v54[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 6) >> 4) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 4) >> 4) & 1)]];
    *(_DWORD *)(v3 + 16) = v54[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 7) >> 1) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 5) >> 1) & 1)]];
    *(_DWORD *)(v3 + 20) = v54[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 7) >> 5) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 5) >> 5) & 1)]];
    *(_DWORD *)(v3 + 24) = v54[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 6) >> 1) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 4) >> 1) & 1)]];
    *(_DWORD *)(v3 + 28) = v54[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 6) >> 5) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 4) >> 5) & 1)]];
    *(_DWORD *)(v3 + 32) = v55[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 7) >> 2) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 5) >> 2) & 1)]];
    *(_DWORD *)(v3 + 36) = v55[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 7) >> 6) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 5) >> 6) & 1)]];
    *(_DWORD *)(v3 + 40) = v55[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 6) >> 2) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 4) >> 2) & 1)]];
    *(_DWORD *)(v3 + 44) = v55[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 6) >> 6) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 4) >> 6) & 1)]];
    *(_DWORD *)(v3 + 48) = v55[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 7) >> 3) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 5) >> 3) & 1)]];
    *(_DWORD *)(v3 + 52) = v55[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 7) >> 7) | 2 * ((unsigned int)*(_BYTE *)(a2 + 5) >> 7)]];
    *(_DWORD *)(v3 + 56) = v55[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 6) >> 3) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 4) >> 3) & 1)]];
    result = v51;
    *(_DWORD *)(v3 + 60) = v55[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 6) >> 7) | 2 * ((unsigned int)*(_BYTE *)(a2 + 4) >> 7)]];
  }
  else
  {
    *(_DWORD *)v3 = v54[(unsigned __int8)byte_1009C524[*(_BYTE *)(a2 + 7) & 1 | 2 * (*(_BYTE *)(a2 + 5) & 1)]];
    *(_DWORD *)(v3 + 4) = v54[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 7) >> 4) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 5) >> 4) & 1)]];
    *(_DWORD *)(v3 + 8) = v55[(unsigned __int8)byte_1009C524[*(_BYTE *)(a2 + 6) & 1 | 2 * (*(_BYTE *)(a2 + 4) & 1)]];
    *(_DWORD *)(v3 + 12) = v55[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 6) >> 4) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 4) >> 4) & 1)]];
    *(_DWORD *)(v3 + 16) = v54[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 7) >> 1) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 5) >> 1) & 1)]];
    *(_DWORD *)(v3 + 20) = v54[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 7) >> 5) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 5) >> 5) & 1)]];
    *(_DWORD *)(v3 + 24) = v55[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 6) >> 1) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 4) >> 1) & 1)]];
    *(_DWORD *)(v3 + 28) = v55[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 6) >> 5) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 4) >> 5) & 1)]];
    *(_DWORD *)(v3 + 32) = v54[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 7) >> 2) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 5) >> 2) & 1)]];
    *(_DWORD *)(v3 + 36) = v54[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 7) >> 6) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 5) >> 6) & 1)]];
    *(_DWORD *)(v3 + 40) = v55[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 6) >> 2) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 4) >> 2) & 1)]];
    *(_DWORD *)(v3 + 44) = v55[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 6) >> 6) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 4) >> 6) & 1)]];
    *(_DWORD *)(v3 + 48) = v54[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 7) >> 3) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 5) >> 3) & 1)]];
    *(_DWORD *)(v3 + 52) = v54[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 7) >> 7) | 2 * ((unsigned int)*(_BYTE *)(a2 + 5) >> 7)]];
    *(_DWORD *)(v3 + 56) = v55[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 6) >> 3) & 1 | 2 * (((unsigned int)*(_BYTE *)(a2 + 4) >> 3) & 1)]];
    *(_DWORD *)(v3 + 60) = v55[(unsigned __int8)byte_1009C524[((unsigned int)*(_BYTE *)(a2 + 6) >> 7) | 2 * ((unsigned int)*(_BYTE *)(a2 + 4) >> 7)]];
    result = v51;
  }
  return result;
}
// 1008EAC0: using guessed type int var_20[4];
// 1008EAC0: using guessed type int var_10[4];

//----- (1008F500) --------------------------------------------------------
unsigned int sub_1008F500()
{
  unsigned int v0; // ecx@1
  unsigned int v1; // edx@3
  unsigned int v2; // ebp@3
  char *v3; // ecx@3
  unsigned int v4; // eax@5
  unsigned int v5; // ebx@6
  unsigned int v6; // ecx@7
  __int16 v7; // di@7
  unsigned int v8; // esi@7
  int v9; // eax@10
  int v10; // eax@12
  unsigned int v11; // eax@16
  unsigned int result; // eax@23
  unsigned int v13; // [sp+10h] [bp-1Ch]@1
  char *v14; // [sp+14h] [bp-18h]@5
  char *i; // [sp+18h] [bp-14h]@3
  char *v16; // [sp+1Ch] [bp-10h]@6
  unsigned int v17; // [sp+20h] [bp-Ch]@5
  unsigned int v18; // [sp+24h] [bp-8h]@3
  int v19; // [sp+28h] [bp-4h]@8

  v0 = 0;
  v13 = 0;
  while ( 1 )
  {
    v1 = 0;
    v2 = v0 != 0 ? 32 : 16;
    v3 = (char *)&unk_100AF480 + 512 * v0;
    v18 = 0;
    for ( i = v3; ; v3 = i )
    {
      v4 = 0;
      v17 = 0;
      v14 = v3;
      do
      {
        v5 = 0;
        v16 = v14;
        do
        {
          v6 = -1;
          v7 = 0;
          v8 = 0;
          if ( v2 )
          {
            v19 = dword_1009DE08[v4 + v1];
            do
            {
              if ( v13 )
                v9 = 8 * v8 | (v8 >> 2);
              else
                v9 = v8 | 16 * v8;
              v10 = v19 + v9;
              if ( v10 >= 0 )
              {
                if ( v10 > 255 )
                  v10 = 255;
              }
              else
              {
                v10 = 0;
              }
              v11 = abs(v10 - v5);
              if ( v11 < v6 )
              {
                v6 = v11;
                v7 = v8;
                if ( !v11 )
                  break;
              }
              ++v8;
            }
            while ( v8 < v2 );
            v4 = v17;
            v1 = v18;
          }
          *(_WORD *)v16 = v7 | ((_WORD)v6 << 8);
          ++v5;
          v16 += 2;
        }
        while ( v5 < 0x100 );
        v14 += 0x2000;
        v17 = ++v4;
      }
      while ( v4 < 4 );
      i += 1024;
      v1 += 4;
      v18 = v1;
      if ( v1 >= 0x20 )
        break;
    }
    result = v13 + 1;
    v13 = result;
    if ( result >= 2 )
      break;
    v0 = result;
  }
  return result;
}
// 1009DE08: using guessed type int dword_1009DE08[];

//----- (1008F630) --------------------------------------------------------
int __usercall sub_1008F630@<eax>(int a1@<edx>, int a2)
{
  int v2; // ecx@1
  _BYTE *v3; // ebx@1
  int v4; // eax@1
  int v5; // esi@1
  signed int v6; // ebp@1
  int v7; // edx@2
  int v8; // edx@6
  int v9; // edx@10
  int v10; // edx@14
  int v11; // edx@18
  signed int v12; // ecx@23
  signed int v13; // edi@23
  int v14; // esi@23
  int v15; // edx@23
  signed int v16; // ecx@23
  int v17; // ebp@25
  int v18; // edx@25
  int result; // eax@25
  int v20; // edx@25
  bool v21; // zf@27
  signed int v22; // [sp+10h] [bp-14h]@23
  int v23; // [sp+14h] [bp-10h]@23
  _BYTE *v24; // [sp+18h] [bp-Ch]@23
  signed int v25; // [sp+1Ch] [bp-8h]@23
  int v26; // [sp+20h] [bp-4h]@23
  _BYTE *v27; // [sp+28h] [bp+4h]@23

  v2 = *(_BYTE *)(a1 + 3);
  v3 = (_BYTE *)(a1 + 3);
  v4 = *(_BYTE *)(a1 + 3);
  v5 = a1 + 11;
  v6 = 3;
  do
  {
    v7 = *(_BYTE *)(v5 - 4);
    if ( v4 >= v7 )
      v4 = *(_BYTE *)(v5 - 4);
    if ( v2 <= v7 )
      v2 = *(_BYTE *)(v5 - 4);
    v8 = *(_BYTE *)v5;
    if ( v4 >= v8 )
      v4 = *(_BYTE *)v5;
    if ( v2 <= v8 )
      v2 = *(_BYTE *)v5;
    v9 = *(_BYTE *)(v5 + 4);
    if ( v4 >= v9 )
      v4 = *(_BYTE *)(v5 + 4);
    if ( v2 <= v9 )
      v2 = *(_BYTE *)(v5 + 4);
    v10 = *(_BYTE *)(v5 + 8);
    if ( v4 >= v10 )
      v4 = *(_BYTE *)(v5 + 8);
    if ( v2 <= v10 )
      v2 = *(_BYTE *)(v5 + 8);
    v11 = *(_BYTE *)(v5 + 12);
    if ( v4 >= v11 )
      v4 = *(_BYTE *)(v5 + 12);
    if ( v2 <= v11 )
      v2 = *(_BYTE *)(v5 + 12);
    v5 += 20;
    --v6;
  }
  while ( v6 );
  *(_BYTE *)a2 = v2;
  *(_BYTE *)(a2 + 1) = v4;
  v12 = v2 - v4;
  v27 = (_BYTE *)(a2 + 2);
  v13 = v12;
  v14 = 7 * v4 - (v12 >> 1);
  v15 = 2 * v12;
  v16 = 0;
  v26 = v14;
  v23 = v15;
  v22 = 0;
  v24 = v3;
  v25 = 16;
  while ( 1 )
  {
    v18 = 7 * *v3 - v14;
    v17 = 4 * v13;
    result = -((((v17 - v18) >> 31) & 4)
             + (((v13 + (v23 & ((v23 - (v18 - (v17 & ((v17 - v18) >> 31)))) >> 31))
                      - (v18
                       - (v17 & ((v17 - v18) >> 31)))) >> 31) & 1)
             + (((v23 - (v18 - (v17 & ((v17 - v18) >> 31)))) >> 31) & 2)) & 7;
    v20 = (result ^ (result < 2)) << v16;
    v16 += 3;
    v22 |= v20;
    if ( v16 >= 8 )
    {
      *v27 = v22;
      result = (int)(v27++ + 1);
      v22 >>= 8;
      v16 -= 8;
    }
    v3 = v24 + 4;
    v21 = v25-- == 1;
    v24 += 4;
    if ( v21 )
      break;
    v14 = v26;
  }
  return result;
}

//----- (1008F790) --------------------------------------------------------
bool __usercall sub_1008F790@<al>(int a1@<eax>, unsigned int a2@<ecx>, __int16 *a3, __int16 *a4)
{
  int v4; // edx@1
  unsigned int v5; // esi@1
  int v6; // eax@1
  int v7; // ecx@2
  int v8; // edi@2
  int v9; // ecx@2
  int v10; // ebx@2
  int v11; // ebp@2
  unsigned int v12; // esi@2
  int v13; // ecx@2
  int v14; // edi@2
  int v15; // ecx@2
  signed int v16; // edx@3
  int v17; // eax@3
  signed int v18; // esi@3
  int v19; // ebp@3
  signed int v20; // edi@3
  int v21; // ebx@3
  int v22; // edx@5
  float v23; // ST44_4@6
  double v24; // st7@6
  signed int v25; // eax@6
  signed int v26; // eax@7
  signed int v27; // eax@9
  double v28; // st5@9
  signed int v29; // eax@9
  signed int v30; // eax@10
  int v31; // eax@12
  signed int v32; // eax@12
  int v33; // ecx@13
  int v34; // ecx@14
  __int16 v35; // ax@15
  signed int v36; // eax@15
  signed int v37; // ebp@16
  signed int v38; // ebp@18
  signed int v39; // eax@18
  signed int v40; // eax@19
  int v41; // esi@21
  signed int v42; // eax@21
  signed int v43; // eax@22
  __int16 v44; // si@24
  bool result; // al@26
  int v46; // [sp+10h] [bp-38h]@1
  int v47; // [sp+10h] [bp-38h]@3
  int v48; // [sp+14h] [bp-34h]@1
  int v49; // [sp+14h] [bp-34h]@3
  int v50; // [sp+18h] [bp-30h]@1
  int v51; // [sp+18h] [bp-30h]@3
  int v52; // [sp+1Ch] [bp-2Ch]@1
  int v53; // [sp+1Ch] [bp-2Ch]@3
  int v54; // [sp+20h] [bp-28h]@1
  int v55; // [sp+20h] [bp-28h]@3
  int v56; // [sp+24h] [bp-24h]@1
  int v57; // [sp+28h] [bp-20h]@1
  int v58; // [sp+2Ch] [bp-1Ch]@1
  int v59; // [sp+30h] [bp-18h]@1
  int v60; // [sp+34h] [bp-14h]@1
  __int16 v61; // [sp+34h] [bp-14h]@6
  int v62; // [sp+38h] [bp-10h]@1
  __int16 v63; // [sp+38h] [bp-10h]@6
  int v64; // [sp+3Ch] [bp-Ch]@1
  signed int v65; // [sp+3Ch] [bp-Ch]@9
  int v66; // [sp+40h] [bp-8h]@1
  float v67; // [sp+40h] [bp-8h]@6
  __int16 v68; // [sp+40h] [bp-8h]@12
  __int16 v69; // [sp+40h] [bp-8h]@15
  signed int v70; // [sp+44h] [bp-4h]@1

  v4 = 0;
  v5 = a2;
  v46 = 0;
  v50 = 0;
  v54 = 0;
  v52 = 0;
  v48 = 0;
  v56 = 0;
  v66 = 0;
  v64 = 0;
  v62 = 0;
  v60 = 0;
  v59 = 0;
  v58 = 0;
  v57 = 0;
  v6 = a1 + 1;
  v70 = 8;
  do
  {
    v7 = v5 & 3;
    v8 = dword_100A4F38[v7];
    v4 += dword_100A4EB8[v7];
    v54 += v8 * *(_BYTE *)(v6 + 1);
    v50 += v8 * *(_BYTE *)v6;
    v9 = *(_BYTE *)(v6 - 1);
    v52 += v9;
    v56 += *(_BYTE *)(v6 + 1);
    v10 = *(_BYTE *)(v6 + 5);
    v11 = v8 * v9;
    v48 += *(_BYTE *)v6;
    v12 = v5 >> 2;
    v13 = v12 & 3;
    v14 = dword_100A4F38[v13];
    v66 += dword_100A4EB8[v13];
    v46 += v11;
    v60 += v14 * v10;
    v62 += v14 * *(_BYTE *)(v6 + 4);
    v15 = *(_BYTE *)(v6 + 3);
    v57 += v10;
    v59 += v15;
    v64 += v14 * v15;
    v58 += *(_BYTE *)(v6 + 4);
    v5 = v12 >> 2;
    v6 += 8;
    --v70;
  }
  while ( v70 );
  v47 = v64 + v46;
  v16 = v66 + v4;
  v17 = v60 + v54;
  v49 = 3 * (v58 + v48) - (v62 + v50);
  v18 = v16 >> 8;
  v19 = 3 * (v57 + v56) - (v60 + v54);
  v20 = v16 >> 16;
  v51 = v62 + v50;
  v55 = v60 + v54;
  v53 = 3 * (v59 + v52) - v47;
  v21 = (unsigned __int8)v16;
  if ( BYTE1(v16) && v20 && (v22 = (unsigned __int8)v16 * (unsigned __int8)v16, v20 * (unsigned __int8)v18 != v22) )
  {
    v63 = *a4;
    v61 = *a3;
    v23 = 0.364705890417099 / (double)(v20 * (unsigned __int8)v18 - v22);
    v24 = v23;
    v67 = 63.0 * v23 / 31.0;
    v25 = (signed int)((double)(v17 * (unsigned __int8)v18 - v19 * v21) * v23 + 0.5);
    if ( v25 < 31 )
      v26 = v25 <= 0 ? 0 : v25;
    else
      v26 = 31;
    v27 = v26 << 11;
    v65 = v27;
    *a3 = v27;
    v28 = v67;
    v29 = (signed int)((double)(v51 * (unsigned __int8)v18 - v49 * v21) * v67 + 0.5);
    if ( v29 < 63 )
      v30 = v29 <= 0 ? 0 : v29;
    else
      v30 = 63;
    v31 = v65 | 32 * v30;
    v68 = v31;
    *a3 = v31;
    v32 = (signed int)((double)(v47 * (unsigned __int8)v18 - v53 * v21) * v24 + 0.5);
    if ( v32 < 31 )
    {
      v34 = v32 < 0;
      LOBYTE(v34) = v32 <= 0;
      v33 = v32 & (v34 - 1);
    }
    else
    {
      LOWORD(v33) = 31;
    }
    v35 = v33 | v68;
    v69 = v35;
    *a3 = v35;
    v36 = (signed int)((double)(v19 * v20 - v55 * v21) * v24 + 0.5);
    if ( v36 < 31 )
      v37 = v36 <= 0 ? 0 : v36;
    else
      v37 = 31;
    v38 = v37 << 11;
    *a4 = v38;
    v39 = (signed int)(v28 * (double)(v49 * v20 - v51 * v21) + 0.5);
    if ( v39 < 63 )
      v40 = v39 <= 0 ? 0 : v39;
    else
      v40 = 63;
    v41 = v38 | 32 * v40;
    *a4 = v41;
    v42 = (signed int)(v24 * (double)(v53 * v20 - v47 * v21) + 0.5);
    if ( v42 < 31 )
      v43 = v42 <= 0 ? 0 : v42;
    else
      LOWORD(v43) = 31;
    v44 = v43 | v41;
    *a4 = v44;
    result = v63 != v44 || v61 != v69;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100A4EB8: using guessed type int dword_100A4EB8[];
// 100A4F38: using guessed type int dword_100A4F38[];

//----- (1008FB30) --------------------------------------------------------
int __usercall sub_1008FB30@<eax>(int a1@<eax>, int a2@<edx>, char a3)
{
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edi@1
  int v9; // ebx@1
  int v10; // ecx@1
  int v11; // ebp@3
  int v12; // ecx@3
  int v13; // eax@3
  int v14; // ecx@3
  int v15; // edi@3
  int v16; // ecx@3
  int v17; // esi@3
  char *v18; // edx@4
  int result; // eax@4
  int v20; // ebp@5
  int v21; // eax@5
  int v22; // ebx@5
  signed int v23; // ebx@6
  int v24; // ebp@8
  int v25; // eax@8
  int v26; // ebx@8
  signed int v27; // ebx@9
  int v28; // ebp@11
  int v29; // eax@11
  int v30; // ebx@11
  signed int v31; // ebx@12
  int v32; // ebp@14
  int v33; // eax@14
  int v34; // ebx@14
  signed int v35; // ebx@15
  int v36; // ecx@19
  int *v37; // eax@19
  int *v38; // edx@19
  int v39; // ebx@21
  signed int v40; // esi@22
  int v41; // ebx@24
  int v42; // edi@24
  int v43; // esi@24
  int v44; // ebx@24
  signed int v45; // esi@25
  int v46; // edi@27
  int v47; // ebp@27
  int v48; // esi@27
  int v49; // ebx@27
  signed int v50; // esi@28
  int v51; // edi@30
  int v52; // ebp@30
  int v53; // esi@30
  signed int v54; // esi@31
  int *v55; // ecx@33
  int v56; // esi@33
  signed int v57; // [sp+10h] [bp-9Ch]@1
  signed int v58; // [sp+10h] [bp-9Ch]@4
  int v59; // [sp+10h] [bp-9Ch]@19
  int v60; // [sp+14h] [bp-98h]@21
  signed int v61; // [sp+14h] [bp-98h]@24
  int v62; // [sp+14h] [bp-98h]@27
  int v63; // [sp+14h] [bp-98h]@30
  int v64; // [sp+18h] [bp-94h]@1
  char *v65; // [sp+18h] [bp-94h]@19
  int v66; // [sp+1Ch] [bp-90h]@19
  int v67; // [sp+20h] [bp-8Ch]@1
  signed int v68; // [sp+24h] [bp-88h]@19
  int v69; // [sp+28h] [bp-84h]@1
  int v70; // [sp+28h] [bp-84h]@19
  int v71; // [sp+2Ch] [bp-80h]@3
  int v72; // [sp+30h] [bp-7Ch]@3
  int v73; // [sp+34h] [bp-78h]@3
  int v74; // [sp+38h] [bp-74h]@3
  int v75; // [sp+3Ch] [bp-70h]@1
  int v76; // [sp+40h] [bp-6Ch]@1
  int v77; // [sp+44h] [bp-68h]@1
  int v78; // [sp+48h] [bp-64h]@1
  int v79; // [sp+4Ch] [bp-60h]@19
  int v80; // [sp+50h] [bp-5Ch]@19
  int v81; // [sp+54h] [bp-58h]@19
  int v82; // [sp+58h] [bp-54h]@19
  int v83; // [sp+5Ch] [bp-50h]@19
  int v84; // [sp+60h] [bp-4Ch]@19
  int v85; // [sp+64h] [bp-48h]@19
  int v86; // [sp+68h] [bp-44h]@19
  int v87; // [sp+6Ch] [bp-40h]@2
  char v88[2]; // [sp+72h] [bp-3Ah]@2
  char v89; // [sp+74h] [bp-38h]@19
  char v90[42]; // [sp+76h] [bp-36h]@2
  char v91; // [sp+A0h] [bp-Ch]@4

  v3 = *(_BYTE *)(a2 + 6);
  v4 = *(_BYTE *)a2;
  v67 = 0;
  v57 = 0;
  v5 = *(_BYTE *)(a2 + 1);
  v69 = v3;
  v78 = *(_BYTE *)(a2 + 2);
  v6 = v78 - v3;
  v7 = *(_BYTE *)(a2 + 5);
  v77 = v7;
  v75 = v5;
  v8 = v5 - v7;
  v64 = v4;
  v9 = v4 - *(_BYTE *)(a2 + 4);
  v76 = *(_BYTE *)(a2 + 4);
  v10 = a1 + 2;
  do
  {
    *(&v87 + v57) = v6 * *(_BYTE *)v10 + v8 * *(_BYTE *)(v10 - 1) + v9 * *(_BYTE *)(v10 - 2);
    *(int *)((char *)&v87 + v10 - a1 + 2) = v6 * *(_BYTE *)(v10 + 4)
                                          + v8 * *(_BYTE *)(v10 + 3)
                                          + v9 * *(_BYTE *)(v10 + 2);
    *(_DWORD *)(&v88[v10] - a1) = v6 * *(_BYTE *)(v10 + 8) + v8 * *(_BYTE *)(v10 + 7) + v9 * *(_BYTE *)(v10 + 6);
    *(_DWORD *)(&v90[v10] - a1) = v6 * *(_BYTE *)(v10 + 12) + v8 * *(_BYTE *)(v10 + 11) + v9 * *(_BYTE *)(v10 + 10);
    v10 += 16;
    v57 += 4;
  }
  while ( v57 < 16 );
  v11 = v6 * v78 + v8 * v75 + v9 * v64;
  v12 = v8 * *(_BYTE *)(a2 + 9);
  v72 = v6 * v69 + v8 * v77 + v9 * v76;
  v13 = v6 * *(_BYTE *)(a2 + 10) + v12 + v9 * *(_BYTE *)(a2 + 8);
  v14 = v6 * *(_BYTE *)(a2 + 14) + v8 * *(_BYTE *)(a2 + 13) + v9 * *(_BYTE *)(a2 + 12);
  v74 = v14;
  v15 = (v14 + v72) >> 1;
  v16 = (v13 + v14) >> 1;
  v17 = (v13 + v11) >> 1;
  v71 = v11;
  v73 = v13;
  if ( a3 )
  {
    v36 = 16 * v16;
    v59 = 16 * v17;
    v37 = &v79;
    v38 = &v83;
    v66 = 16 * v15;
    v70 = v36;
    v79 = 0;
    v80 = 0;
    v81 = 0;
    v82 = 0;
    v83 = 0;
    v84 = 0;
    v85 = 0;
    v86 = 0;
    v68 = 0;
    v65 = &v89;
    while ( 1 )
    {
      v39 = 0;
      v60 = 16 * *((_DWORD *)v65 - 2) + 3 * v38[1] + 5 * *v38;
      if ( v60 >= v36 )
      {
        v40 = v60 >= v59 ? 0 : 2;
      }
      else
      {
        LOBYTE(v39) = v60 >= v66;
        v40 = 2 * v39 + 1;
      }
      v61 = v40;
      v41 = *((_DWORD *)v65 - 2) - *(&v71 + v40);
      v42 = *((_DWORD *)v65 - 1);
      *v37 = v41;
      v43 = *v38 + 3 * v38[2] + 16 * v42 + 7 * v41 + 5 * v38[1];
      v44 = 0;
      if ( v43 >= v36 )
      {
        v45 = v43 >= v59 ? 0 : 2;
      }
      else
      {
        LOBYTE(v44) = v43 >= v66;
        v45 = 2 * v44 + 1;
      }
      v46 = v42 - *(&v71 + v45);
      v62 = 4 * v45 | v61;
      v47 = *(_DWORD *)v65;
      v37[1] = v46;
      v48 = v38[1] + 5 * v38[2] + 16 * v47 + 7 * v46 + 3 * v38[3];
      v49 = 0;
      if ( v48 >= v36 )
      {
        v50 = v48 >= v59 ? 0 : 2;
      }
      else
      {
        LOBYTE(v49) = v48 >= v66;
        v50 = 2 * v49 + 1;
      }
      v51 = v47 - *(&v71 + v50);
      v63 = 16 * v50 | v62;
      v52 = *((_DWORD *)v65 + 1);
      v37[2] = v51;
      v53 = v38[2] + 7 * v51 + 16 * v52 + 5 * v38[3];
      v54 = v53 >= v36 ? (v53 >= v59 ? 0 : 2) : 2 * (v53 >= v66) + 1;
      v65 += 16;
      v55 = v37;
      v37[3] = v52 - *(&v71 + v54);
      v37 = v38;
      v38 = v55;
      v56 = (v63 | (v54 << 6)) << v68;
      v68 += 8;
      v67 |= v56;
      if ( v68 >= 32 )
        break;
      v36 = v70;
    }
    result = v67;
  }
  else
  {
    v18 = &v91;
    v58 = 4;
    result = 0;
    do
    {
      v20 = *((_DWORD *)v18 + 2);
      v21 = 4 * result;
      v22 = 0;
      if ( v20 >= v16 )
      {
        v23 = v20 >= v17 ? 0 : 2;
      }
      else
      {
        LOBYTE(v22) = v20 >= v15;
        v23 = 2 * v22 + 1;
      }
      v24 = *((_DWORD *)v18 + 1);
      v25 = 4 * (v23 | v21);
      v26 = 0;
      if ( v24 >= v16 )
      {
        v27 = v24 >= v17 ? 0 : 2;
      }
      else
      {
        LOBYTE(v26) = v24 >= v15;
        v27 = 2 * v26 + 1;
      }
      v28 = *(_DWORD *)v18;
      v29 = 4 * (v27 | v25);
      v30 = 0;
      if ( *(_DWORD *)v18 >= v16 )
      {
        v31 = v28 >= v17 ? 0 : 2;
      }
      else
      {
        LOBYTE(v30) = v28 >= v15;
        v31 = 2 * v30 + 1;
      }
      v32 = *((_DWORD *)v18 - 1);
      v33 = 4 * (v31 | v29);
      v34 = 0;
      if ( v32 >= v16 )
      {
        v35 = v32 >= v17 ? 0 : 2;
      }
      else
      {
        LOBYTE(v34) = v32 >= v15;
        v35 = 2 * v34 + 1;
      }
      result = v35 | v33;
      v18 -= 16;
      --v58;
    }
    while ( v58 );
  }
  return result;
}
// 1008FB30: using guessed type char var_3A[2];
// 1008FB30: using guessed type char var_36[42];

//----- (100903E0) --------------------------------------------------------
int __cdecl sub_100903E0(int a1, int a2, int a3)
{
  signed int v3; // ebp@1
  int v4; // ebx@3
  int v5; // esi@4
  __int64 v6; // rax@4
  int v7; // ecx@4
  int result; // eax@7
  int v9; // [sp+10h] [bp-8h]@2
  signed int v10; // [sp+14h] [bp-4h]@2

  v3 = 0;
  do
  {
    v10 = 256;
    v9 = 0;
    if ( a3 > 0 )
    {
      do
      {
        v4 = 0;
        do
        {
          v5 = *(_BYTE *)(v9 + a2);
          v6 = *(_BYTE *)(v4 + a2) - v5;
          v7 = ((signed int)(8 * ((HIDWORD(v6) ^ v6) - HIDWORD(v6))) >> 8) + abs(((*(_BYTE *)(v4 + a2) + v5) >> 1) - v3);
          if ( v7 < v10 )
          {
            *(_BYTE *)(a1 + 2 * v3) = v4;
            *(_BYTE *)(a1 + 2 * v3 + 1) = v9;
            v10 = v7;
          }
          ++v4;
        }
        while ( v4 < a3 );
        result = v9 + 1;
        v9 = result;
      }
      while ( result < a3 );
    }
    ++v3;
  }
  while ( v3 < 256 );
  return result;
}

//----- (10090490) --------------------------------------------------------
int __cdecl sub_10090490(int a1, int a2, int a3)
{
  signed int v3; // ebp@1
  int v4; // ebx@3
  int v5; // edi@4
  int v6; // esi@4
  __int64 v7; // rax@4
  int v8; // ecx@4
  __int64 v9; // rax@4
  int v10; // ecx@4
  int result; // eax@7
  int v12; // [sp+10h] [bp-8h]@2
  signed int v13; // [sp+14h] [bp-4h]@2

  v3 = 0;
  do
  {
    v13 = 256;
    v12 = 0;
    if ( a3 > 0 )
    {
      do
      {
        v4 = 0;
        do
        {
          v5 = *(_BYTE *)(v4 + a2);
          v6 = *(_BYTE *)(v12 + a2);
          v7 = (v6 + 2 * v5) / 3 - v3;
          v8 = (HIDWORD(v7) ^ ((v6 + 2 * v5) / 3 - v3)) - HIDWORD(v7);
          v9 = v5 - v6;
          v10 = ((signed int)(8 * ((HIDWORD(v9) ^ v9) - HIDWORD(v9))) >> 8) + v8;
          if ( v10 < v13 )
          {
            *(_BYTE *)(a1 + 2 * v3) = v4;
            *(_BYTE *)(a1 + 2 * v3 + 1) = v12;
            v13 = v10;
          }
          ++v4;
        }
        while ( v4 < a3 );
        result = v12 + 1;
        v12 = result;
      }
      while ( result < a3 );
    }
    ++v3;
  }
  while ( v3 < 256 );
  return result;
}

//----- (10090550) --------------------------------------------------------
int sub_10090550()
{
  signed int v0; // eax@1
  signed int v1; // eax@3
  signed int v2; // edx@5
  int v3; // ecx@7

  v0 = 0;
  do
  {
    byte_100AF460[v0] = 8 * v0 | (v0 >> 2);
    ++v0;
  }
  while ( v0 < 32 );
  v1 = 0;
  do
  {
    byte_100AF420[v1] = 4 * v1 | (v1 >> 4);
    ++v1;
  }
  while ( v1 < 64 );
  v2 = 0;
  do
  {
    if ( v2 < 263 )
    {
      if ( v2 > 8 )
        v3 = v2 - 8;
      else
        v3 = 0;
    }
    else
    {
      v3 = 255;
    }
    byte_100AEB10[v2] = byte_100AF460[(31 * v3 + 128 + ((31 * v3 + 128) >> 8)) >> 8];
    byte_100AEA00[v2++] = byte_100AF420[(63 * v3 + 128 + ((63 * v3 + 128) >> 8)) >> 8];
  }
  while ( v2 < 272 );
  sub_10090490((int)byte_100AF220, (int)byte_100AF460, 32);
  sub_10090490((int)byte_100AF020, (int)byte_100AF420, 64);
  sub_100903E0((int)byte_100AEE20, (int)byte_100AF460, 32);
  return sub_100903E0((int)byte_100AEC20, (int)byte_100AF420, 64);
}

//----- (10090640) --------------------------------------------------------
int __cdecl sub_10090640(_BYTE *a1, _WORD *a2, _WORD *a3)
{
  _BYTE *v3; // ebp@1
  signed int v4; // edi@1
  signed int v5; // esi@2
  int v6; // ebx@2
  int v7; // eax@2
  signed int v8; // edx@2
  int v9; // ecx@3
  int v10; // edi@9
  int v11; // ebx@9
  int v12; // eax@9
  int v13; // ecx@10
  int v14; // edx@10
  int v15; // esi@10
  int v16; // edi@10
  int v17; // ebx@10
  int v18; // ecx@10
  int v19; // edx@10
  int v20; // esi@10
  int v21; // edi@10
  int v22; // ebx@10
  int v23; // ecx@10
  int v24; // edx@10
  int v25; // esi@10
  int v26; // edi@10
  int v27; // ebx@10
  int v28; // ecx@10
  int v29; // edx@10
  int v30; // esi@10
  float v31; // ST14_4@11
  float v32; // ST1C_4@11
  float v33; // ST20_4@11
  float v34; // ST24_4@11
  float v35; // ST18_4@11
  float v36; // ST14_4@11
  float v37; // ST1C_4@11
  float v38; // ST20_4@11
  float v39; // ST24_4@11
  float v40; // ST18_4@11
  float v41; // ST14_4@11
  float v42; // ST1C_4@11
  float v43; // ST20_4@11
  float v44; // ST24_4@11
  float v45; // ST18_4@11
  float v46; // ST14_4@11
  float v47; // ST1C_4@11
  float v48; // ST20_4@11
  float v49; // ST24_4@11
  long double v50; // st6@11
  double v51; // st5@11
  long double v52; // st4@11
  long double v53; // st2@11
  signed int v54; // ebp@16
  float v55; // ST24_4@17
  double v56; // st7@17
  unsigned int v57; // ebx@18
  int v58; // esi@18
  int v59; // edi@18
  int v60; // ecx@18
  int v61; // eax@19
  int v62; // edx@19
  int v63; // edx@23
  int v64; // edx@27
  int v65; // edx@31
  int result; // eax@36
  float v67; // [sp+14h] [bp-5Ch]@11
  signed int v68; // [sp+14h] [bp-5Ch]@18
  float v69; // [sp+18h] [bp-58h]@11
  signed int v70; // [sp+1Ch] [bp-54h]@16
  signed int v71; // [sp+20h] [bp-50h]@16
  signed int v72; // [sp+24h] [bp-4Ch]@9
  float v73; // [sp+24h] [bp-4Ch]@15
  signed int v74; // [sp+24h] [bp-4Ch]@16
  float v75; // [sp+28h] [bp-48h]@8
  float v76; // [sp+2Ch] [bp-44h]@10
  float v77; // [sp+30h] [bp-40h]@10
  float v78; // [sp+34h] [bp-3Ch]@11
  float v79; // [sp+38h] [bp-38h]@11
  float v80; // [sp+3Ch] [bp-34h]@11
  int v81; // [sp+40h] [bp-30h]@8
  int v82; // [sp+44h] [bp-2Ch]@11
  int v83; // [sp+48h] [bp-28h]@11
  int v84; // [sp+4Ch] [bp-24h]@8
  int v85; // [sp+50h] [bp-20h]@11
  int v86; // [sp+54h] [bp-1Ch]@11
  int v87; // [sp+58h] [bp-18h]@11
  int v88; // [sp+5Ch] [bp-14h]@11
  int v89; // [sp+60h] [bp-10h]@9
  int v90; // [sp+64h] [bp-Ch]@9
  int v91; // [sp+68h] [bp-8h]@9
  int v92; // [sp+6Ch] [bp-4h]@9

  v3 = a1;
  v4 = 0;
  do
  {
    v5 = *v3;
    v6 = *v3;
    v7 = *v3;
    v8 = 4;
    do
    {
      v9 = v3[v8];
      v7 += v9;
      if ( v6 >= v9 )
        v6 = v3[v8];
      if ( v5 <= v3[v8] )
        v5 = v3[v8];
      v8 += 4;
    }
    while ( v8 < 64 );
    *(_DWORD *)((char *)&v75 + v4) = (v7 + 8) >> 4;
    *(int *)((char *)&v84 + v4) = v6;
    *(int *)((char *)&v81 + v4) = v5;
    v4 += 4;
    ++v3;
  }
  while ( v4 < 12 );
  v10 = 0;
  v11 = 0;
  v89 = 0;
  v90 = 0;
  v91 = 0;
  v92 = 0;
  v12 = (int)(a1 + 1);
  v72 = 4;
  do
  {
    v13 = *(_BYTE *)(v12 + 1) - LODWORD(v77);
    v14 = *(_BYTE *)v12 - LODWORD(v76);
    v15 = *(_BYTE *)(v12 - 1) - LODWORD(v75);
    v16 = v13 * v13 + v10;
    v17 = v13 * v14 + v11;
    v89 += v13 * v15;
    v90 += v14 * v14;
    v91 += v14 * v15;
    v18 = *(_BYTE *)(v12 + 5) - LODWORD(v77);
    v19 = *(_BYTE *)(v12 + 4) - LODWORD(v76);
    v92 += v15 * v15;
    v20 = *(_BYTE *)(v12 + 3) - LODWORD(v75);
    v21 = v18 * v18 + v16;
    v22 = v18 * v19 + v17;
    v89 += v18 * v20;
    v90 += v19 * v19;
    v91 += v19 * v20;
    v23 = *(_BYTE *)(v12 + 9) - LODWORD(v77);
    v24 = *(_BYTE *)(v12 + 8) - LODWORD(v76);
    v92 += v20 * v20;
    v25 = *(_BYTE *)(v12 + 7) - LODWORD(v75);
    v26 = v23 * v23 + v21;
    v27 = v23 * v24 + v22;
    v89 += v23 * v25;
    v90 += v24 * v24;
    v91 += v24 * v25;
    v28 = *(_BYTE *)(v12 + 13) - LODWORD(v77);
    v29 = *(_BYTE *)(v12 + 12) - LODWORD(v76);
    v92 += v25 * v25;
    v30 = *(_BYTE *)(v12 + 11) - LODWORD(v75);
    v10 = v28 * v28 + v26;
    v11 = v28 * v29 + v27;
    v89 += v28 * v30;
    v90 += v29 * v29;
    v92 += v30 * v30;
    v91 += v29 * v30;
    v12 += 16;
    --v72;
  }
  while ( v72 );
  v87 = v10;
  v88 = v11;
  v75 = (double)v10 / 255.0;
  v76 = (double)v11 / 255.0;
  v77 = (double)v89 / 255.0;
  v78 = (double)v90 / 255.0;
  v79 = (double)v91 / 255.0;
  v80 = (double)v92 / 255.0;
  v31 = (double)(v83 - v86);
  v32 = (double)(v82 - v85);
  v33 = (double)(v81 - v84);
  v34 = v76 * v31 + v78 * v32 + v79 * v33;
  v35 = v31 * v77 + v32 * v79 + v80 * v33;
  v36 = v76 * v32 + v75 * v31 + v77 * v33;
  v37 = v34;
  v38 = v35;
  v39 = v34 * v78 + v76 * v36 + v35 * v79;
  v40 = v79 * v37 + v77 * v36 + v80 * v35;
  v41 = v76 * v37 + v75 * v36 + v77 * v38;
  v42 = v39;
  v43 = v40;
  v44 = v39 * v78 + v76 * v41 + v40 * v79;
  v45 = v79 * v42 + v77 * v41 + v80 * v40;
  v46 = v76 * v42 + v75 * v41 + v77 * v43;
  v47 = v44;
  v48 = v45;
  v49 = v44 * v78 + v76 * v46 + v45 * v79;
  v69 = v45 * v80 + v79 * v47 + v77 * v46;
  v67 = v77 * v48 + v47 * v76 + v75 * v46;
  v50 = fabs(v69);
  v51 = v49;
  v52 = fabs(v49);
  v53 = fabs(v67);
  if ( v53 > v52 )
    v52 = v53;
  if ( v52 > v50 )
    v50 = v52;
  v73 = v50;
  if ( v73 >= 4.0 )
  {
    v55 = 512.0 / v73;
    v71 = (signed int)(v67 * v55);
    v56 = v69 * v55;
    v74 = (signed int)(v51 * v55);
    v54 = (signed int)v56;
    v70 = (signed int)v56;
  }
  else
  {
    v54 = 58;
    v71 = 148;
    v74 = 300;
    v70 = 58;
  }
  v57 = (unsigned int)a2;
  v58 = 0x7FFFFFFF;
  v59 = -2147483647;
  v60 = (int)(a1 + 2);
  v68 = 4;
  do
  {
    v61 = v54 * *(_BYTE *)(v60 - 2);
    v62 = v71 * *(_BYTE *)v60 + v61 + v74 * *(_BYTE *)(v60 - 1);
    if ( v62 < v58 )
    {
      v58 = v71 * *(_BYTE *)v60 + v61 + v74 * *(_BYTE *)(v60 - 1);
      v69 = *(float *)(v60 - 2);
    }
    if ( v62 > v59 )
    {
      v57 = *(_DWORD *)(v60 - 2);
      v59 = v71 * *(_BYTE *)v60 + v61 + v74 * *(_BYTE *)(v60 - 1);
    }
    v63 = v70 * *(_BYTE *)(v60 + 2) + v71 * *(_BYTE *)(v60 + 4) + v74 * *(_BYTE *)(v60 + 3);
    if ( v63 < v58 )
    {
      v58 = v70 * *(_BYTE *)(v60 + 2) + v71 * *(_BYTE *)(v60 + 4) + v74 * *(_BYTE *)(v60 + 3);
      v69 = *(float *)(v60 + 2);
    }
    if ( v63 > v59 )
    {
      v57 = *(_DWORD *)(v60 + 2);
      v59 = v70 * *(_BYTE *)(v60 + 2) + v71 * *(_BYTE *)(v60 + 4) + v74 * *(_BYTE *)(v60 + 3);
    }
    v64 = v70 * *(_BYTE *)(v60 + 6) + v71 * *(_BYTE *)(v60 + 8) + v74 * *(_BYTE *)(v60 + 7);
    if ( v64 < v58 )
    {
      v58 = v70 * *(_BYTE *)(v60 + 6) + v71 * *(_BYTE *)(v60 + 8) + v74 * *(_BYTE *)(v60 + 7);
      v69 = *(float *)(v60 + 6);
    }
    if ( v64 > v59 )
    {
      v57 = *(_DWORD *)(v60 + 6);
      v59 = v70 * *(_BYTE *)(v60 + 6) + v71 * *(_BYTE *)(v60 + 8) + v74 * *(_BYTE *)(v60 + 7);
    }
    v54 = v70;
    v65 = v70 * *(_BYTE *)(v60 + 10) + v71 * *(_BYTE *)(v60 + 12) + v74 * *(_BYTE *)(v60 + 11);
    if ( v65 < v58 )
    {
      v58 = v70 * *(_BYTE *)(v60 + 10) + v71 * *(_BYTE *)(v60 + 12) + v74 * *(_BYTE *)(v60 + 11);
      v69 = *(float *)(v60 + 10);
    }
    if ( v65 > v59 )
    {
      v57 = *(_DWORD *)(v60 + 10);
      v59 = v70 * *(_BYTE *)(v60 + 10) + v71 * *(_BYTE *)(v60 + 12) + v74 * *(_BYTE *)(v60 + 11);
    }
    v60 += 16;
    --v68;
  }
  while ( v68 );
  *a2 = ((31 * (unsigned __int8)v57 + 128 + ((31 * (unsigned __int8)v57 + 128) >> 8)) >> 8)
      + (8 * (31 * (unsigned __int8)(v57 >> 16) + 128 + ((31 * (unsigned __int8)(v57 >> 16) + 128) >> 8)) & 0xF800)
      + (((63 * BYTE1(v57) + 128 + ((63 * BYTE1(v57) + 128) >> 8)) >> 3) & 0xFFE0);
  result = (31 * LOBYTE(v69) + 128 + ((31 * LOBYTE(v69) + 128) >> 8)) >> 8;
  *a3 = result
      + (8
       * (31 * (unsigned __int8)(LODWORD(v69) >> 16) + 128 + ((31 * (unsigned __int8)(LODWORD(v69) >> 16) + 128) >> 8)) & 0xF800)
      + (((63 * BYTE1(v69) + 128 + ((63 * BYTE1(v69) + 128) >> 8)) >> 3) & 0xFFE0);
  return result;
}

//----- (10090C80) --------------------------------------------------------
signed int __usercall sub_10090C80@<eax>(unsigned __int16 a1@<ax>, int a2@<ecx>, unsigned __int16 a3)
{
  int v3; // edi@1

  v3 = a2;
  *(_BYTE *)(a2 + 3) = 0;
  *(_BYTE *)(a2 + 2) = byte_100AF460[(unsigned int)a1 >> 11];
  *(_BYTE *)(a2 + 1) = byte_100AF420[((unsigned int)a1 >> 5) & 0x3F];
  *(_BYTE *)a2 = byte_100AF460[a1 & 0x1F];
  *(_BYTE *)(a2 + 7) = 0;
  *(_BYTE *)(a2 + 6) = byte_100AF460[(unsigned int)a3 >> 11];
  *(_BYTE *)(a2 + 5) = byte_100AF420[((unsigned int)a3 >> 5) & 0x3F];
  *(_BYTE *)(a2 + 4) = byte_100AF460[a3 & 0x1F];
  sub_10033380(v3 + 4, 85, v3, a2 + 8);
  return sub_10033380(v3 + 4, 170, v3, v3 + 12);
}

//----- (10090D20) --------------------------------------------------------
int __cdecl sub_10090D20(int a1, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // ecx@1
  unsigned int v4; // eax@1
  int v5; // esi@1
  signed int v6; // edi@1
  unsigned int v7; // edx@2
  unsigned int v8; // edx@6
  unsigned int v9; // edx@14
  unsigned int v10; // edx@18
  int v11; // esi@25
  bool v12; // al@27
  unsigned __int16 v13; // di@27
  unsigned __int16 v14; // bx@27
  int v15; // eax@31
  int v16; // ecx@31
  int v17; // edx@31
  unsigned __int16 v18; // ax@33
  int result; // eax@34
  int v20; // [sp+14h] [bp-18h]@24
  char v21; // [sp+18h] [bp-14h]@25

  v2 = a2;
  v3 = *(_DWORD *)a2;
  v4 = *(_DWORD *)a2;
  v5 = a2 + 12;
  v6 = 3;
  do
  {
    v7 = *(_DWORD *)(v5 - 8);
    if ( v4 >= v7 )
      v4 = *(_DWORD *)(v5 - 8);
    if ( v3 <= v7 )
      v3 = *(_DWORD *)(v5 - 8);
    v8 = *(_DWORD *)(v5 - 4);
    if ( v4 >= v8 )
      v4 = *(_DWORD *)(v5 - 4);
    if ( v3 <= v8 )
      v3 = *(_DWORD *)(v5 - 4);
    if ( v4 >= *(_DWORD *)v5 )
      v4 = *(_DWORD *)v5;
    if ( v3 <= *(_DWORD *)v5 )
      v3 = *(_DWORD *)v5;
    v9 = *(_DWORD *)(v5 + 4);
    if ( v4 >= v9 )
      v4 = *(_DWORD *)(v5 + 4);
    if ( v3 <= v9 )
      v3 = *(_DWORD *)(v5 + 4);
    v10 = *(_DWORD *)(v5 + 8);
    if ( v4 >= v10 )
      v4 = *(_DWORD *)(v5 + 8);
    if ( v3 <= v10 )
      v3 = *(_DWORD *)(v5 + 8);
    v5 += 20;
    --v6;
  }
  while ( v6 );
  if ( v4 == v3 )
  {
    v15 = *(_BYTE *)(a2 + 2);
    v16 = *(_BYTE *)(a2 + 1);
    v17 = *(_BYTE *)a2;
    v11 = -1431655766;
    v13 = (unsigned __int8)byte_100AF220[2 * v17] | (unsigned __int16)(32
                                                                     * ((unsigned __int8)byte_100AF020[2 * v16] | (unsigned __int16)((unsigned __int8)byte_100AF220[2 * v15] << 6)));
    v14 = (unsigned __int8)byte_100AF221[2 * v17] | (unsigned __int16)(32
                                                                     * ((unsigned __int8)byte_100AF021[2 * v16] | (unsigned __int16)((unsigned __int8)byte_100AF221[2 * v15] << 6)));
  }
  else
  {
    sub_10090640((_BYTE *)a2, &v20, &a2);
    if ( (_WORD)v20 == (_WORD)a2 )
    {
      v11 = 0;
    }
    else
    {
      sub_10090C80(v20, (int)&v21, a2);
      v11 = sub_1008FB30(v2, (int)&v21, 0);
    }
    v12 = sub_1008F790(v2, v11, (__int16 *)&v20, (__int16 *)&a2);
    v13 = v20;
    v14 = a2;
    if ( v12 )
    {
      if ( (_WORD)v20 == (_WORD)a2 )
      {
        v11 = 0;
      }
      else
      {
        sub_10090C80(v20, (int)&v21, a2);
        v11 = sub_1008FB30(v2, (int)&v21, 0);
      }
    }
  }
  if ( v13 < v14 )
  {
    v18 = v13;
    v13 = v14;
    v14 = v18;
    v11 ^= 0x55555555u;
  }
  result = a1;
  *(_WORD *)a1 = v13;
  *(_DWORD *)(a1 + 4) = v11;
  *(_WORD *)(a1 + 2) = v14;
  return result;
}

//----- (10090EE0) --------------------------------------------------------
void __usercall sub_10090EE0(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  FILE *v3; // eax@1
  char DstBuf; // [sp+0h] [bp-200h]@1

  sprintf_s(&DstBuf, 0x200u, "%s(%u): Failure: \"%s\"\n", a2, a3, a1);
  OutputDebugStringA(&DstBuf);
  v3 = _iob_func();
  fputs(&DstBuf, v3 + 2);
  if ( IsDebuggerPresent() )
    DebugBreak();
  if ( !byte_100AE9F8 )
    exit(1);
  RaiseException(0x100u, 0, 0, 0);
}
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (10090F60) --------------------------------------------------------
void __usercall sub_10090F60(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  FILE *v3; // eax@1
  char DstBuf; // [sp+0h] [bp-200h]@1

  sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", a2, a3, a1);
  OutputDebugStringA(&DstBuf);
  v3 = _iob_func();
  fputs(&DstBuf, v3 + 2);
  if ( IsDebuggerPresent() )
    DebugBreak();
}

//----- (10091080) --------------------------------------------------------
void sub_10091080()
{
  FILE *v0; // eax@1
  char DstBuf; // [sp+0h] [bp-200h]@1

  sprintf_s(
    &DstBuf,
    0x200u,
    "%s(%u): Failure: \"%s\"\n",
    "crn_threading_win32.cpp",
    198,
    "\"semaphore: ReleaseSemaphore() failed\"");
  OutputDebugStringA(&DstBuf);
  v0 = _iob_func();
  fputs(&DstBuf, v0 + 2);
  if ( IsDebuggerPresent() )
    DebugBreak();
  if ( !byte_100AE9F8 )
    exit(1);
  RaiseException(0x100u, 0, 0, 0);
}
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (10091130) --------------------------------------------------------
int __stdcall sub_10091130(int a1)
{
  FILE *v1; // eax@1
  char DstBuf; // [sp+0h] [bp-200h]@1

  sprintf_s(
    &DstBuf,
    0x200u,
    "%s(%u): Failure: \"%s\"\n",
    "crn_threading_win32.cpp",
    180,
    "\"semaphore: CreateSemaphore() failed\"");
  OutputDebugStringA(&DstBuf);
  v1 = _iob_func();
  fputs(&DstBuf, v1 + 2);
  if ( IsDebuggerPresent() )
    DebugBreak();
  if ( !byte_100AE9F8 )
    exit(1);
  RaiseException(0x100u, 0, 0, 0);
  return a1;
}
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (100911E0) --------------------------------------------------------
LONG __stdcall sub_100911E0(LPLONG Target)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // esi@3
  signed int v3; // edi@3
  LONG result; // eax@3

  v1 = 4096;
  if ( (unsigned int)dword_100AD974 <= 1 )
    v1 = 1;
  v2 = 0;
  v3 = 0;
  for ( result = InterlockedExchange(Target, 1); result; result = InterlockedExchange(Target, 1) )
  {
    _mm_pause();
    _mm_pause();
    _mm_pause();
    _mm_pause();
    _mm_pause();
    _mm_pause();
    _mm_pause();
    _mm_pause();
    if ( ++v2 >= v1 )
    {
      if ( v3 )
      {
        if ( v3 == 1 )
        {
          if ( (unsigned int)dword_100AD974 > 1 )
          {
            v2 = v1 >> 1;
            Sleep(1u);
            v3 = 2;
          }
          else
          {
            v2 = 0;
            Sleep(1u);
            v3 = 2;
          }
        }
        else if ( v3 == 2 )
        {
          v2 = (unsigned int)dword_100AD974 > 1 ? v1 : 0;
          Sleep(2u);
        }
      }
      else
      {
        v2 = 0;
        Sleep(0);
        v3 = 1;
      }
    }
  }
  return result;
}
// 100AD974: using guessed type int dword_100AD974;

//----- (10091370) --------------------------------------------------------
int __stdcall sub_10091370(int a1)
{
  DWORD v1; // eax@1
  PSLIST_HEADER v2; // esi@4
  PSINGLE_LIST_ENTRY v3; // eax@4
  struct _SINGLE_LIST_ENTRY *v4; // ebx@5
  struct _SINGLE_LIST_ENTRY *v5; // edi@5
  struct _SINGLE_LIST_ENTRY *v6; // ST3C_4@5
  FILE *v7; // eax@15
  struct _SINGLE_LIST_ENTRY *v9; // [sp+14h] [bp-214h]@5
  struct _SINGLE_LIST_ENTRY *v10; // [sp+18h] [bp-210h]@5
  struct _SINGLE_LIST_ENTRY *v11; // [sp+20h] [bp-208h]@5
  char DstBuf; // [sp+28h] [bp-200h]@15

  while ( 1 )
  {
    v1 = WaitForSingleObject(*(HANDLE *)(a1 + 72), 0xFFFFFFFF);
    if ( v1 == -1 )
      break;
    if ( v1 || *(_DWORD *)(a1 + 88) )
      goto LABEL_19;
    v2 = *(PSLIST_HEADER *)a1;
    v3 = InterlockedPopEntrySList(*(PSLIST_HEADER *)a1);
    if ( v3 )
    {
      v4 = v3[2].Next;
      v5 = v3[5].Next;
      v9 = v3[3].Next;
      v10 = v3[4].Next;
      v11 = v3[6].Next;
      v6 = v3[7].Next;
      if ( LOBYTE(v2[2].Alignment) )
      {
        InterlockedPushEntrySList(v2 + 1, v3);
      }
      else if ( (unsigned __int8)v3 & 7 )
      {
        sub_100927E0((int)"crnlib_free: bad ptr");
      }
      else
      {
        off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
      }
      if ( (unsigned __int8)v11 & 1 )
        ((void (__thiscall *)(struct _SINGLE_LIST_ENTRY *, struct _SINGLE_LIST_ENTRY *, struct _SINGLE_LIST_ENTRY *, struct _SINGLE_LIST_ENTRY *))v5->Next->Next)(
          v5,
          v4,
          v9,
          v10);
      else
        ((void (__cdecl *)(struct _SINGLE_LIST_ENTRY *, struct _SINGLE_LIST_ENTRY *, struct _SINGLE_LIST_ENTRY *))v5)(
          v4,
          v9,
          v10);
      if ( InterlockedIncrement((LPLONG)(a1 + 84)) == *(_DWORD *)(a1 + 80) )
        ReleaseSemaphore(*(HANDLE *)(a1 + 76), 1, 0);
    }
  }
  sprintf_s(
    &DstBuf,
    0x200u,
    "%s(%u): Failure: \"%s\"\n",
    "crn_threading_win32.cpp",
    214,
    "\"semaphore: WaitForSingleObject() failed\"");
  OutputDebugStringA(&DstBuf);
  v7 = _iob_func();
  fputs(&DstBuf, v7 + 2);
  if ( IsDebuggerPresent() )
    DebugBreak();
  if ( !byte_100AE9F8 )
    exit(1);
  RaiseException(0x100u, 0, 0, 0);
LABEL_19:
  endthreadex(0);
  return 0;
}
// 100991AC: using guessed type int __cdecl endthreadex(_DWORD);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (10091500) --------------------------------------------------------
void __stdcall sub_10091500(int a1)
{
  PSLIST_HEADER v1; // esi@1
  PSINGLE_LIST_ENTRY v2; // eax@1
  struct _SINGLE_LIST_ENTRY *v3; // ebx@2
  struct _SINGLE_LIST_ENTRY *v4; // edi@2
  struct _SINGLE_LIST_ENTRY *v5; // ST3C_4@2
  FILE *v6; // eax@14
  LONG v7; // [sp+Ch] [bp-21Ch]@12
  struct _SINGLE_LIST_ENTRY *v8; // [sp+14h] [bp-214h]@2
  struct _SINGLE_LIST_ENTRY *v9; // [sp+18h] [bp-210h]@2
  struct _SINGLE_LIST_ENTRY *v10; // [sp+20h] [bp-208h]@2
  char DstBuf; // [sp+28h] [bp-200h]@14

  while ( 1 )
  {
    v1 = *(PSLIST_HEADER *)a1;
    v2 = InterlockedPopEntrySList(*(PSLIST_HEADER *)a1);
    if ( !v2 )
      break;
    v3 = v2[2].Next;
    v4 = v2[5].Next;
    v8 = v2[3].Next;
    v9 = v2[4].Next;
    v10 = v2[6].Next;
    v5 = v2[7].Next;
    if ( LOBYTE(v1[2].Alignment) )
    {
      InterlockedPushEntrySList(v1 + 1, v2);
    }
    else if ( (unsigned __int8)v2 & 7 )
    {
      sub_100927E0((int)"crnlib_free: bad ptr");
    }
    else
    {
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    }
    if ( (unsigned __int8)v10 & 1 )
      ((void (__thiscall *)(struct _SINGLE_LIST_ENTRY *, struct _SINGLE_LIST_ENTRY *, struct _SINGLE_LIST_ENTRY *, struct _SINGLE_LIST_ENTRY *))v4->Next->Next)(
        v4,
        v3,
        v8,
        v9);
    else
      ((void (__cdecl *)(struct _SINGLE_LIST_ENTRY *, struct _SINGLE_LIST_ENTRY *, struct _SINGLE_LIST_ENTRY *))v4)(
        v3,
        v8,
        v9);
    if ( InterlockedIncrement((LPLONG)(a1 + 84)) == *(_DWORD *)(a1 + 80) )
      ReleaseSemaphore(*(HANDLE *)(a1 + 76), 1, 0);
  }
  v7 = InterlockedExchangeAdd((LPLONG)(a1 + 80), 0);
  while ( *(_DWORD *)(a1 + 84) != v7 )
  {
    if ( WaitForSingleObject(*(HANDLE *)(a1 + 76), 1u) == -1 )
    {
      sprintf_s(
        &DstBuf,
        0x200u,
        "%s(%u): Failure: \"%s\"\n",
        "crn_threading_win32.cpp",
        214,
        "\"semaphore: WaitForSingleObject() failed\"");
      OutputDebugStringA(&DstBuf);
      v6 = _iob_func();
      fputs(&DstBuf, v6 + 2);
      if ( IsDebuggerPresent() )
        DebugBreak();
      if ( !byte_100AE9F8 )
        exit(1);
      RaiseException(0x100u, 0, 0, 0);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (100916A0) --------------------------------------------------------
char __userpurge sub_100916A0@<al>(int a1@<eax>, int a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // ebx@1
  char result; // al@2
  int v7; // [sp+10h] [bp-18h]@1
  int v8; // [sp+14h] [bp-14h]@1
  int v9; // [sp+18h] [bp-10h]@1
  int v10; // [sp+1Ch] [bp-Ch]@1
  int v11; // [sp+20h] [bp-8h]@1

  v5 = a2;
  v7 = a3;
  v10 = a1;
  v8 = a4;
  v9 = a5;
  v11 = 1;
  InterlockedIncrement((LPLONG)(a2 + 80));
  if ( sub_100331D0(*(_DWORD *)v5, (int)&v7) )
  {
    if ( !ReleaseSemaphore(*(HANDLE *)(v5 + 72), 1, 0) )
      sub_10091080();
    result = 1;
  }
  else
  {
    InterlockedIncrement((LPLONG)(v5 + 84));
    result = 0;
  }
  return result;
}

//----- (10091720) --------------------------------------------------------
PSLIST_HEADER __usercall sub_10091720@<eax>(int a1@<edi>)
{
  unsigned int v1; // ebp@1
  HANDLE *v2; // esi@5
  DWORD i; // eax@7
  PSLIST_HEADER result; // eax@13

  v1 = 0;
  if ( *(_DWORD *)(a1 + 4) )
  {
    sub_10091500(a1);
    InterlockedExchange((LPLONG)(a1 + 88), 1);
    if ( !ReleaseSemaphore(*(HANDLE *)(a1 + 72), *(_DWORD *)(a1 + 4), 0) )
      sub_10091080();
    if ( *(_DWORD *)(a1 + 4) > 0u )
    {
      v2 = (HANDLE *)(a1 + 8);
      do
      {
        if ( *v2 )
        {
          for ( i = WaitForSingleObject(*v2, 0x7530u); i; i = WaitForSingleObject(*v2, 0x7530u) )
          {
            if ( i == 128 )
              break;
          }
          CloseHandle(*v2);
          *v2 = 0;
        }
        ++v1;
        ++v2;
      }
      while ( v1 < *(_DWORD *)(a1 + 4) );
    }
    *(_DWORD *)(a1 + 4) = 0;
    InterlockedExchange((LPLONG)(a1 + 88), 0);
  }
  result = *(PSLIST_HEADER *)a1;
  if ( *(_DWORD *)a1 )
    result = (PSLIST_HEADER)sub_10033100(*(PSLIST_HEADER *)a1);
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  return result;
}

//----- (100917D0) --------------------------------------------------------
char __usercall sub_100917D0@<al>(unsigned int a1@<eax>, int a2@<ecx>)
{
  unsigned int v2; // ebx@1
  int v3; // edi@1
  int v4; // eax@4
  unsigned int v5; // eax@5
  char result; // al@6

  v2 = a1;
  v3 = a2;
  if ( a1 >= 0x10 )
    v2 = 16;
  sub_10091720(a2);
  *(_DWORD *)(v3 + 4) = 0;
  if ( v2 )
  {
    while ( 1 )
    {
      *(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 4) + 8) = beginthreadex(0, 0x8000, sub_10091370, v3, 0, 0);
      v4 = *(_DWORD *)(v3 + 4);
      if ( !*(_DWORD *)(v3 + 4 * v4 + 8) )
        break;
      v5 = v4 + 1;
      *(_DWORD *)(v3 + 4) = v5;
      if ( v5 >= v2 )
        goto LABEL_6;
    }
    sub_10091720(v3);
    result = 0;
  }
  else
  {
LABEL_6:
    result = 1;
  }
  return result;
}
// 10099118: using guessed type int __cdecl beginthreadex(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10091840) --------------------------------------------------------
int __usercall sub_10091840@<eax>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // ebx@1
  int v3; // eax@3
  HANDLE v4; // eax@6
  HANDLE v5; // eax@8

  v1 = sub_10092A80(24);
  v2 = v1;
  if ( v1 )
  {
    *(_BYTE *)(v1 + 16) = 1;
    if ( v1 & 7 )
    {
      v3 = sub_10033300(v1);
    }
    else
    {
      InitializeSListHead((PSLIST_HEADER)v1);
      InitializeSListHead((PSLIST_HEADER)(v2 + 8));
      v3 = v2;
    }
  }
  else
  {
    v3 = 0;
  }
  *(_DWORD *)a1 = v3;
  *(_DWORD *)(a1 + 4) = 0;
  v4 = CreateSemaphoreA(0, 0, 0x7FFF, 0);
  *(_DWORD *)(a1 + 72) = v4;
  if ( !v4 )
    sub_10091130(a1 + 72);
  v5 = CreateSemaphoreA(0, 0, 1, 0);
  *(_DWORD *)(a1 + 76) = v5;
  if ( !v5 )
    sub_10091130(a1 + 76);
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  memset((void *)(a1 + 8), 0, 0x40u);
  return a1;
}

//----- (100918E0) --------------------------------------------------------
BOOL __stdcall sub_100918E0(int a1)
{
  PSLIST_HEADER v1; // ebx@1
  BOOL result; // eax@7

  sub_10091720(a1);
  v1 = *(PSLIST_HEADER *)a1;
  if ( *(_DWORD *)a1 )
  {
    sub_10033100(*(PSLIST_HEADER *)a1);
    if ( (unsigned __int8)v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
  if ( *(_DWORD *)(a1 + 76) )
  {
    CloseHandle(*(HANDLE *)(a1 + 76));
    *(_DWORD *)(a1 + 76) = 0;
  }
  result = *(_DWORD *)(a1 + 72);
  if ( result )
  {
    result = CloseHandle(*(HANDLE *)(a1 + 72));
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10091980) --------------------------------------------------------
int __thiscall sub_10091980(void *this, __int64 a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // edi@1
  int result; // eax@1
  signed int v5; // esi@6
  unsigned __int64 v6; // rax@8
  int v7; // kr00_4@8
  unsigned __int64 v8; // kr08_8@10
  unsigned int v9; // [sp+10h] [bp-418h]@1
  unsigned int v10; // [sp+14h] [bp-414h]@1
  void *v11; // [sp+1Ch] [bp-40Ch]@1
  int v12; // [sp+24h] [bp-404h]@6
  char v13; // [sp+28h] [bp-400h]@8

  v2 = HIDWORD(a2);
  v3 = a2;
  result = 0;
  v11 = this;
  v9 = 0;
  v10 = 0;
  if ( a2 )
  {
    while ( 1 )
    {
      if ( v2 || v3 > 0x400 )
      {
        v5 = 1024;
        v12 = 0;
      }
      else
      {
        v5 = v3;
        v12 = 0;
      }
      v6 = __PAIR__(v10, (*(int (__stdcall **)(char *, signed int))(*(_DWORD *)this + 12))(&v13, v5));
      v7 = v6 + v9;
      HIDWORD(v6) = (v6 + v9) >> 32;
      v9 += v6;
      v10 = HIDWORD(v6);
      if ( (_DWORD)v6 != v5 )
        break;
      if ( 0 != v12 )
        break;
      v8 = __PAIR__(v2, v3) - (unsigned int)v6;
      v2 = (__PAIR__(v2, v3) - (unsigned int)v6) >> 32;
      v3 = v8;
      if ( !v8 )
        break;
      this = v11;
    }
    result = v7;
  }
  return result;
}

//----- (10091A40) --------------------------------------------------------
bool sub_10091A40(int a1, ...)
{
  int v1; // ecx@0
  int v2; // ebx@1
  int v3; // esi@1
  int v4; // edi@1
  void *v5; // eax@1
  bool v6; // bl@3
  int v8; // [sp+10h] [bp-18h]@1
  void *v9; // [sp+14h] [bp-14h]@1
  int v10; // [sp+24h] [bp-4h]@1
  va_list va; // [sp+30h] [bp+8h]@1

  va_start(va, a1);
  v2 = v1;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  sub_10091F40((const char *)a1, (int)&v8, va);
  v3 = (int)v9;
  v4 = HIWORD(v8);
  v5 = v9;
  if ( !v9 )
    v5 = &unk_100996C3;
  v6 = (*(int (__thiscall **)(int, void *, _DWORD))(*(_DWORD *)v2 + 20))(v2, v5, HIWORD(v8)) == v4;
  v10 = -1;
  if ( v3 && *(_DWORD *)(v3 - 4) == ~*(_DWORD *)(v3 - 8) && v3 != 8 )
  {
    if ( ((_BYTE)v3 - 8) & 7 )
    {
      sub_100927E0((int)"crnlib_free: bad ptr");
      return v6;
    }
    off_100AD9F4(v3 - 8, 0, 0, 1, dword_100AE9F4);
  }
  return v6;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10091B60) --------------------------------------------------------
BOOL __userpurge sub_10091B60@<eax>(unsigned int a1@<eax>, int a2@<edi>, char a3)
{
  unsigned int v3; // edx@1
  unsigned int v4; // eax@3
  unsigned int v5; // eax@3
  unsigned int v6; // ebx@3
  signed int v7; // esi@6
  void *v8; // esi@9
  int v9; // eax@10
  const void *v10; // eax@12
  int v11; // ecx@15
  int v12; // eax@16

  v3 = *(_WORD *)a2;
  if ( v3 > a1 )
    a1 = *(_WORD *)a2;
  v4 = ((((a1 - 1) >> 16) | (a1 - 1)) >> 8) | ((a1 - 1) >> 16) | (a1 - 1);
  v5 = (((v4 >> 4) | v4) >> 2) | (v4 >> 4) | v4;
  v6 = 0xFFFF;
  if ( (v5 | (v5 >> 1)) + 1 <= 0xFFFF )
    v6 = (v5 | (v5 >> 1)) + 1;
  if ( v6 != v3 )
  {
    v7 = v6;
    if ( !v6 )
      v7 = 1;
    if ( (unsigned int)(v7 + 8) <= 0x7FFF0000 )
    {
      v9 = sub_10092A80(v7 + 8);
      *(_DWORD *)(v9 + 4) = v7;
      *(_DWORD *)v9 = ~v7;
      v8 = (void *)(v9 + 8);
    }
    else
    {
      sub_100927E0((int)"crnlib_new_array: Array too large!");
      v8 = 0;
    }
    if ( a3 )
    {
      v10 = *(const void **)(a2 + 4);
      if ( !v10 )
        v10 = &unk_100996C3;
      memcpy(v8, v10, *(_WORD *)(a2 + 2) + 1);
    }
    v11 = *(_DWORD *)(a2 + 4);
    if ( v11 )
    {
      v12 = v11 - 8;
      if ( *(_DWORD *)(v11 - 4) == ~*(_DWORD *)(v11 - 8) && v11 != 8 )
      {
        if ( v12 & 7 )
        {
          sub_100927E0((int)"crnlib_free: bad ptr");
          *(_DWORD *)(a2 + 4) = v8;
          *(_WORD *)a2 = v6;
          return (unsigned __int16)v6 >= v6;
        }
        off_100AD9F4(v12, 0, 0, 1, dword_100AE9F4);
      }
    }
    *(_DWORD *)(a2 + 4) = v8;
    *(_WORD *)a2 = v6;
  }
  return *(_WORD *)a2 >= v6;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10091CF0) --------------------------------------------------------
void __usercall sub_10091CF0(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // ecx@2

  v1 = *(_DWORD *)(a1 + 4);
  if ( v1 )
  {
    v2 = v1 - 8;
    if ( *(_DWORD *)(v1 - 4) == ~*(_DWORD *)(v1 - 8) && v1 != 8 )
    {
      if ( v2 & 7 )
      {
        sub_100927E0((int)"crnlib_free: bad ptr");
        *(_DWORD *)(a1 + 4) = 0;
        *(_DWORD *)a1 = 0;
        return;
      }
      off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)a1 = 0;
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10091D50) --------------------------------------------------------
void __userpurge sub_10091D50(int a1@<eax>, int a2)
{
  int v2; // ebp@1
  int v3; // edx@1
  int v4; // eax@1
  unsigned __int16 v5; // di@6
  unsigned __int16 v6; // cx@6
  unsigned int v7; // eax@6
  signed int v8; // edx@9
  _BYTE *v9; // eax@10
  signed int v10; // ebx@12
  unsigned int v11; // esi@14
  int v12; // edx@18
  unsigned int v13; // esi@19
  int v14; // eax@23
  int v15; // edx@23
  int v16; // eax@25
  int v17; // ecx@26
  int v18; // [sp+0h] [bp-18h]@6
  int v19; // [sp+4h] [bp-14h]@6
  int v20; // [sp+Ch] [bp-Ch]@1
  int (__thiscall *v21)(void *); // [sp+10h] [bp-8h]@1
  int v22; // [sp+14h] [bp-4h]@1
  unsigned int i; // [sp+1Ch] [bp+4h]@9

  v22 = -1;
  v21 = sub_100963F4;
  v20 = a1;
  v2 = a2;
  v3 = *(_WORD *)(a2 + 2);
  v4 = 0;
  if ( *(_WORD *)(a2 + 2) )
  {
    while ( *(_BYTE *)(*(_DWORD *)(a2 + 4) + v4) != 10 )
    {
      if ( ++v4 >= (unsigned int)*(_WORD *)(a2 + 2) )
        return;
    }
    if ( v4 >= 0 )
    {
      v5 = 0;
      v6 = 0;
      v18 = 0;
      v19 = 0;
      v7 = v3 + 3;
      v22 = 0;
      if ( (unsigned int)(v3 + 3) <= 0xFFFF && v7 > 0 )
      {
        sub_10091B60(v7, (int)&v18, 1);
        v6 = HIWORD(v18);
        v5 = v18;
      }
      v8 = -1;
      for ( i = 0; i < *(_WORD *)(v2 + 2); ++i )
      {
        v9 = *(_BYTE **)(v2 + 4);
        if ( !v9 )
          v9 = &unk_100996C3;
        v10 = v9[i];
        if ( v10 == 10 && v8 != 13 )
        {
          v11 = v6 + 2;
          if ( v11 <= 0xFFFF && v11 > v5 )
          {
            sub_10091B60(v6 + 2, (int)&v18, 1);
            v6 = HIWORD(v18);
            v5 = v18;
          }
          if ( v5 >= v11 )
          {
            v12 = v6++;
            *(_WORD *)(v19 + v12) = 13;
            HIWORD(v18) = v6;
          }
        }
        v13 = v6 + 2;
        if ( v13 <= 0xFFFF && v13 > v5 )
        {
          sub_10091B60(v6 + 2, (int)&v18, 1);
          v6 = HIWORD(v18);
          v5 = v18;
        }
        if ( v5 >= v13 )
        {
          v14 = v19;
          v15 = v6++;
          *(_BYTE *)(v19 + v15) = v10;
          *(_BYTE *)(v14 + v15 + 1) = 0;
          HIWORD(v18) = v6;
        }
        v8 = v10;
      }
      *(_WORD *)v2 = v5;
      *(_WORD *)(v2 + 2) = v6;
      v16 = *(_DWORD *)(v2 + 4);
      *(_DWORD *)(v2 + 4) = v19;
      v22 = -1;
      if ( v16 )
      {
        v17 = v16 - 8;
        if ( *(_DWORD *)(v16 - 4) == ~*(_DWORD *)(v16 - 8) && v16 != 8 )
        {
          if ( v17 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v17, 0, 0, 1, dword_100AE9F4);
        }
      }
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10091F40) --------------------------------------------------------
int __fastcall sub_10091F40(const char *a1, int a2, va_list ArgList)
{
  int v3; // esi@1
  int v4; // eax@1
  int v5; // ebp@1
  int result; // eax@2
  unsigned int v7; // ebx@3
  char DstBuf; // [sp+8h] [bp-1000h]@1

  v3 = a2;
  v4 = vsnprintf_s(&DstBuf, 0x1000u, 0xFFFFFFFF, a1, ArgList);
  v5 = v4;
  if ( v4 > 0 )
  {
    v7 = v4 + 1;
    if ( (unsigned int)(v4 + 1) <= 0xFFFF && v7 > *(_WORD *)v3 )
      sub_10091B60(v4 + 1, v3, 0);
    if ( *(_WORD *)v3 >= v7 )
    {
      memcpy(*(void **)(v3 + 4), &DstBuf, v5 + 1);
      *(_WORD *)(v3 + 2) = v5;
    }
    result = v3;
  }
  else
  {
    sub_10091CF0(v3);
    result = v3;
  }
  return result;
}

//----- (10091FD0) --------------------------------------------------------
int __userpurge sub_10091FD0@<eax>(int a1@<eax>, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  unsigned int v4; // eax@2
  bool v5; // cf@2
  bool v6; // zf@2
  int result; // eax@2
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@6
  const void *v10; // eax@10

  v2 = a1;
  v3 = a2;
  if ( v2 == a2 )
  {
    v4 = *(_WORD *)(v2 + 2);
    v5 = v4 < 0xFFFFFFFF;
    v6 = v4 == -1;
    result = v2;
    if ( !v5 && !v6 )
    {
      *(_BYTE *)(*(_DWORD *)(v2 + 4) - 1) = 0;
      *(_WORD *)(v2 + 2) = -1;
    }
  }
  else
  {
    v8 = *(_WORD *)(a2 + 2);
    if ( v8 <= 0xFFFFFFFF )
    {
      if ( !*(_WORD *)(a2 + 2) )
      {
        sub_10091CF0(v2);
        return v2;
      }
    }
    else
    {
      v8 = -1;
    }
    v9 = v8 + 1;
    if ( v8 + 1 <= 0xFFFF && v9 > *(_WORD *)v2 )
    {
      sub_10091B60(v8 + 1, v2, 0);
      v3 = a2;
    }
    if ( *(_WORD *)v2 >= v9 )
    {
      *(_WORD *)(v2 + 2) = v8;
      v10 = *(const void **)(v3 + 4);
      if ( !v10 )
        v10 = &unk_100996C3;
      memcpy(*(void **)(v2 + 4), v10, (unsigned __int16)v8);
      *(_BYTE *)(v8 + *(_DWORD *)(v2 + 4)) = 0;
    }
    result = v2;
  }
  return result;
}

//----- (10092080) --------------------------------------------------------
int __userpurge sub_10092080@<eax>(int a1@<eax>, void *a2)
{
  void *v2; // edx@1
  int v3; // esi@1
  unsigned int v4; // eax@1
  size_t v5; // ebx@1
  char *v6; // eax@4
  unsigned int v8; // ebp@10
  void *v9; // ST00_4@14

  v2 = a2;
  v3 = a1;
  v4 = strlen((const char *)a2);
  v5 = v4;
  if ( v4 > 0xFFFFFFFF || !v4 || v4 >= 0xFFFF )
  {
    sub_10091CF0(v3);
    return v3;
  }
  v6 = *(char **)(v3 + 4);
  if ( !v6 || a2 < v6 || a2 >= &v6[*(_WORD *)v3] )
  {
    v8 = v5 + 1;
    if ( v5 + 1 <= 0xFFFF && v8 > *(_WORD *)v3 )
    {
      sub_10091B60(v5 + 1, v3, 0);
      v2 = a2;
    }
    if ( *(_WORD *)v3 >= v8 )
    {
      v9 = *(void **)(v3 + 4);
      *(_WORD *)(v3 + 2) = v5;
      memcpy(v9, v2, (unsigned __int16)v5 + 1);
      return v3;
    }
    return v3;
  }
  if ( v6 != a2 )
    memmove(v6, a2, v5);
  *(_BYTE *)(v5 + *(_DWORD *)(v3 + 4)) = 0;
  *(_WORD *)(v3 + 2) = v5;
  return v3;
}

//----- (10092180) --------------------------------------------------------
signed int __usercall sub_10092180@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>)
{
  *(_DWORD *)(a2 + 8) = (a1 + 6 * a3) / 7u;
  *(_DWORD *)(a2 + 12) = (5 * a3 + 2 * a1) / 7u;
  *(_DWORD *)(a2 + 16) = (3 * a1 + 4 * a3) / 7u;
  *(_DWORD *)(a2 + 20) = (3 * a3 + 4 * a1) / 7u;
  *(_DWORD *)(a2 + 4) = a1;
  *(_DWORD *)(a2 + 24) = (5 * a1 + 2 * a3) / 7u;
  *(_DWORD *)a2 = a3;
  *(_DWORD *)(a2 + 28) = (a3 + 6 * a1) / 7u;
  return 8;
}

//----- (10092230) --------------------------------------------------------
signed int __usercall sub_10092230@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>)
{
  *(_DWORD *)(a1 + 8) = (a3 + 4 * a2) / 5u;
  *(_DWORD *)(a1 + 12) = (3 * a2 + 2 * a3) / 5u;
  *(_DWORD *)(a1 + 16) = (3 * a3 + 2 * a2) / 5u;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_DWORD *)(a1 + 20) = (a2 + 4 * a3) / 5u;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 255;
  return 6;
}

//----- (100923C0) --------------------------------------------------------
int __usercall sub_100923C0@<eax>(int a1@<eax>, char a2)
{
  unsigned int v2; // ecx@1
  unsigned int v3; // esi@1
  unsigned int v4; // edi@1

  v2 = *(_BYTE *)(a1 + 2);
  v3 = *(_BYTE *)(a1 + 1);
  v4 = *(_BYTE *)a1;
  if ( a2 )
  {
    v4 = (31 * v4 + 127) / 0xFF;
    v3 = (63 * v3 + 127) / 0xFF;
    v2 = (31 * v2 + 127) / 0xFF;
  }
  if ( v4 >= 0x1F )
    v4 = 31;
  if ( v3 >= 0x3F )
    v3 = 63;
  if ( v2 >= 0x1F )
    v2 = 31;
  return v2 | 32 * (v3 | (v4 << 6));
}

//----- (100924B0) --------------------------------------------------------
signed int __usercall sub_100924B0@<eax>(unsigned __int16 a1@<ax>, int a2@<ecx>, unsigned __int16 a3)
{
  unsigned __int8 v3; // bl@1
  unsigned __int8 v4; // dl@1
  unsigned int v5; // ST18_4@1
  unsigned int v6; // ebp@1
  unsigned int v7; // ST10_4@1
  int v8; // esi@1
  unsigned int v9; // edx@1
  unsigned int v10; // edx@1
  unsigned int v12; // [sp+20h] [bp+4h]@1

  v3 = 8 * (a1 & 0x1F) | ((unsigned __int8)(a1 & 0x1F) >> 2);
  v4 = 8 * ((unsigned int)a1 >> 11) | ((unsigned int)a1 >> 13);
  v5 = 4 * (((unsigned int)a1 >> 5) & 0x3F) | ((((unsigned int)a1 >> 5) & 0x3F) >> 4);
  v6 = 8 * (a3 & 0x1F) | ((a3 & 0x1Fu) >> 2);
  v7 = 4 * (((unsigned int)a3 >> 5) & 0x3F) | ((((unsigned int)a3 >> 5) & 0x3F) >> 4);
  *(_BYTE *)(a2 + 1) = v5;
  *(_BYTE *)a2 = v4;
  v12 = 8 * ((unsigned int)a3 >> 11) | ((unsigned int)a3 >> 13);
  *(_BYTE *)(a2 + 2) = v3;
  *(_BYTE *)(a2 + 3) = -1;
  *(_BYTE *)(a2 + 4) = v12;
  *(_BYTE *)(a2 + 5) = v7;
  *(_BYTE *)(a2 + 6) = v6;
  v8 = v4;
  v9 = (unsigned __int64)(1431655766i64 * ((unsigned __int8)v12 + 2 * v4)) >> 32;
  *(_BYTE *)(a2 + 7) = -1;
  *(_BYTE *)(a2 + 8) = v9 + (v9 >> 31);
  *(_BYTE *)(a2 + 9) = ((unsigned __int64)(1431655766i64 * ((unsigned __int8)v7 + 2 * (unsigned __int8)v5)) >> 32)
                     + ((unsigned int)((unsigned __int64)(1431655766i64 * ((unsigned __int8)v7 + 2 * (unsigned __int8)v5)) >> 32) >> 31);
  *(_BYTE *)(a2 + 10) = ((unsigned __int64)(1431655766i64 * ((unsigned __int8)v6 + 2 * v3)) >> 32)
                      + ((unsigned int)((unsigned __int64)(1431655766i64 * ((unsigned __int8)v6 + 2 * v3)) >> 32) >> 31);
  *(_BYTE *)(a2 + 11) = -1;
  *(_BYTE *)(a2 + 12) = ((unsigned __int64)(1431655766i64 * (v8 + 2 * (unsigned __int8)v12)) >> 32)
                      + ((unsigned int)((unsigned __int64)(1431655766i64 * (v8 + 2 * (unsigned __int8)v12)) >> 32) >> 31);
  v10 = (unsigned __int64)(1431655766i64 * ((unsigned __int8)v5 + 2 * (unsigned __int8)v7)) >> 32;
  *(_BYTE *)(a2 + 13) = v10 + (v10 >> 31);
  *(_BYTE *)(a2 + 14) = (char)(v3 + 2 * v6) / 3;
  *(_BYTE *)(a2 + 15) = -1;
  return 4;
}

//----- (10092630) --------------------------------------------------------
signed int __usercall sub_10092630@<eax>(int a1@<eax>, unsigned __int16 a2@<cx>, unsigned __int16 a3)
{
  unsigned int v3; // edx@1
  unsigned int v4; // edi@1
  unsigned __int8 v5; // cl@1
  unsigned int v6; // ST14_4@1
  unsigned int v7; // ST18_4@1
  unsigned int v8; // ST10_4@1

  v3 = (unsigned int)a2 >> 5;
  v4 = (unsigned int)a2 >> 11;
  v5 = 8 * (a2 & 0x1F) | ((unsigned __int8)(a2 & 0x1F) >> 2);
  v6 = 4 * (v3 & 0x3F) | ((v3 & 0x3F) >> 4);
  LOBYTE(v3) = 8 * v4 | (v4 >> 2);
  v7 = 8 * (a3 & 0x1F) | ((a3 & 0x1Fu) >> 2);
  v8 = 4 * (((unsigned int)a3 >> 5) & 0x3F) | ((((unsigned int)a3 >> 5) & 0x3F) >> 4);
  *(_BYTE *)(a1 + 1) = v6;
  *(_BYTE *)a1 = v3;
  *(_BYTE *)(a1 + 2) = v5;
  *(_BYTE *)(a1 + 3) = -1;
  *(_BYTE *)(a1 + 4) = 8 * ((unsigned int)a3 >> 11) | ((unsigned int)a3 >> 13);
  *(_BYTE *)(a1 + 5) = v8;
  *(_BYTE *)(a1 + 6) = v7;
  *(_BYTE *)(a1 + 7) = -1;
  *(_BYTE *)(a1 + 9) = ((unsigned __int8)v6 + (unsigned __int8)v8) >> 1;
  *(_BYTE *)(a1 + 8) = ((unsigned __int8)v3 + (unsigned __int8)(8 * ((unsigned int)a3 >> 11) | ((unsigned int)a3 >> 13))) >> 1;
  *(_BYTE *)(a1 + 10) = (v5 + (unsigned __int8)v7) >> 1;
  *(_WORD *)(a1 + 11) = 255;
  *(_WORD *)(a1 + 13) = 0;
  *(_BYTE *)(a1 + 15) = 0;
  return 3;
}

//----- (10092740) --------------------------------------------------------
int __usercall sub_10092740@<eax>(signed int a1@<eax>, signed int a2@<edx>, signed int a3@<ecx>)
{
  char v3; // al@5
  char v5; // [sp+4h] [bp-4h]@3
  char v6; // [sp+5h] [bp-3h]@5
  char v7; // [sp+6h] [bp-2h]@7
  char v8; // [sp+7h] [bp-1h]@7

  if ( a1 & 0xFFFFFF00 )
    LOBYTE(a1) = ~(a1 >> 31);
  v5 = a1;
  if ( a3 & 0xFFFFFF00 )
    LOBYTE(a3) = ~(a3 >> 31);
  v6 = a3;
  v3 = a2;
  if ( a2 & 0xFFFFFF00 )
    v3 = ~(a2 >> 31);
  v7 = v3;
  v8 = 0;
  return sub_100923C0((int)&v5, 0);
}

//----- (100927E0) --------------------------------------------------------
void __usercall sub_100927E0(int a1@<eax>)
{
  FILE *v1; // eax@1
  char DstBuf; // [sp+0h] [bp-200h]@1

  sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, a1);
  OutputDebugStringA(&DstBuf);
  v1 = _iob_func();
  fputs(&DstBuf, v1 + 2);
  if ( IsDebuggerPresent() )
    DebugBreak();
}

//----- (10092850) --------------------------------------------------------
size_t __cdecl sub_10092850(void *a1)
{
  size_t result; // eax@2

  if ( a1 )
    result = msize(a1);
  else
    result = 0;
  return result;
}

//----- (10092870) --------------------------------------------------------
void *__cdecl sub_10092870(void *a1, size_t a2, int a3, char a4)
{
  void *v4; // edi@1
  void *v5; // esi@2
  void *result; // eax@6
  void *v7; // eax@12
  int v8; // esi@12
  void *v9; // eax@15

  v4 = a1;
  if ( a1 )
  {
    if ( a2 )
    {
      v7 = expand(a1, a2);
      v8 = (int)v7;
      if ( v7 )
      {
        v4 = v7;
      }
      else if ( a4 )
      {
        v9 = realloc(a1, a2);
        v8 = (int)v9;
        if ( v9 )
          v4 = v9;
        else
          printf("WARNING: ::realloc() of size %u failed!\n", a2);
      }
      if ( a3 )
        *(_DWORD *)a3 = msize(v4);
      result = (void *)v8;
    }
    else
    {
      free(a1);
      result = 0;
      if ( a3 )
        *(_DWORD *)a3 = 0;
    }
  }
  else
  {
    v5 = malloc(a2);
    if ( !v5 )
      printf("WARNING: ::malloc() of size %u failed!\n", a2);
    if ( a3 )
    {
      if ( v5 )
      {
        *(_DWORD *)a3 = msize(v5);
        return v5;
      }
      *(_DWORD *)a3 = 0;
    }
    result = v5;
  }
  return result;
}

//----- (10092970) --------------------------------------------------------
void __usercall sub_10092970(int a1@<eax>)
{
  if ( a1 )
  {
    if ( a1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(a1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100929A0) --------------------------------------------------------
int __usercall sub_100929A0@<eax>(void *a1@<ecx>, unsigned int a2@<eax>, int *a3@<esi>, int a4)
{
  int result; // eax@2
  int v5; // [sp+0h] [bp-4h]@1

  v5 = (int)a1;
  if ( (unsigned __int8)a1 & 7 )
  {
    sub_100927E0((int)"crnlib_realloc: bad ptr");
    result = 0;
  }
  else if ( a2 <= 0x7FFF0000 )
  {
    if ( a2 && a2 < 4 )
      a2 = 4;
    v5 = a2;
    result = off_100AD9F4(a1, a2, &v5, a4, dword_100AE9F4);
    if ( a3 )
      *a3 = v5;
  }
  else
  {
    sub_100927E0((int)"crnlib_malloc: size too big");
    result = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10092A10) --------------------------------------------------------
int __usercall sub_10092A10@<eax>(int a1@<eax>, int *a2@<edi>)
{
  unsigned int v2; // esi@1
  int result; // eax@3
  unsigned int v4; // ecx@3
  int v5; // [sp+4h] [bp-4h]@3

  v2 = (a1 + 3) & 0xFFFFFFFC;
  if ( v2 )
  {
    if ( v2 > 0x7FFF0000 )
    {
      sub_100927E0((int)"crnlib_malloc: size too big");
      return 0;
    }
  }
  else
  {
    v2 = 4;
  }
  v5 = v2;
  result = off_100AD9F4(0, v2, &v5, 1, dword_100AE9F4);
  v4 = v5;
  if ( a2 )
    *a2 = v5;
  if ( !result || v4 < v2 )
  {
    sub_100927E0((int)"crnlib_malloc: out of memory");
    result = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10092A80) --------------------------------------------------------
int __usercall sub_10092A80@<eax>(int a1@<eax>)
{
  unsigned int v1; // esi@1
  int result; // eax@3
  int v3; // [sp+4h] [bp-4h]@3

  v1 = (a1 + 3) & 0xFFFFFFFC;
  if ( v1 )
  {
    if ( v1 > 0x7FFF0000 )
    {
      sub_100927E0((int)"crnlib_malloc: size too big");
      return 0;
    }
  }
  else
  {
    v1 = 4;
  }
  v3 = v1;
  result = off_100AD9F4(0, v1, &v3, 1, dword_100AE9F4);
  if ( !result || v3 < v1 )
  {
    sub_100927E0((int)"crnlib_malloc: out of memory");
    result = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10092B10) --------------------------------------------------------
const char *__usercall sub_10092B10@<eax>(int a1@<eax>)
{
  const char *result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = (const char *)&unk_1009FB54;
      break;
    case 1:
      result = "tent";
      break;
    case 2:
      result = "lanczos4";
      break;
    case 3:
      result = "mitchell";
      break;
    case 4:
      result = "kaiser";
      break;
    default:
      result = "?";
      break;
  }
  return result;
}

//----- (10092BE0) --------------------------------------------------------
void *__usercall sub_10092BE0@<eax>(float *a1@<ebx>, _DWORD *a2@<esi>, int a3, int a4, _DWORD *a5)
{
  int v5; // eax@5
  void *result; // eax@10
  void *v7; // [sp+8h] [bp-18h]@6
  int v8; // [sp+Ch] [bp-14h]@6
  int v9; // [sp+10h] [bp-10h]@6
  int v10; // [sp+1Ch] [bp-4h]@6

  *a5 = 0;
  if ( a2 )
    *a2 = 0;
  if ( a1 )
    *a1 = 0.0;
  LOBYTE(v5) = sub_100320A0(a3);
  if ( !(_BYTE)v5 )
    return 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( sub_10095B80(v5, a3, a4, (int)&v7, a2, a1) )
  {
    *a5 = v8;
    result = v7;
  }
  else
  {
    v10 = -1;
    if ( !v7 )
      return 0;
    if ( (unsigned __int8)v7 & 7 )
    {
      sub_100927E0((int)"crnlib_free: bad ptr");
      return 0;
    }
    off_100AD9F4(v7, 0, 0, 1, dword_100AE9F4);
    result = 0;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10092CD0) --------------------------------------------------------
unsigned int __thiscall sub_10092CD0(int this, int a2, int a3, int a4)
{
  int v4; // edi@1
  unsigned int result; // eax@1
  unsigned int v6; // ecx@1
  int v7; // eax@3
  unsigned int v8; // et2@4
  int v9; // eax@5
  int v10; // edx@5
  int v11; // esi@5
  int v12; // eax@5
  int v13; // eax@6
  int v14; // eax@8
  int v15; // ebx@8
  int v16; // edx@9
  int v17; // edi@9
  float v18; // ST20_4@10
  int v19; // eax@10
  float v20; // ecx@12
  float v21; // edx@12
  float v22; // ecx@12
  int v23; // edx@15
  int v24; // eax@15
  int v25; // ecx@15
  int v26; // edx@16
  int v27; // ebx@16
  float v28; // ST18_4@17
  int v29; // eax@17
  int v30; // edx@22
  int v31; // ebx@22
  int v32; // eax@23
  int v33; // edx@23
  int v34; // ebx@24
  unsigned int v35; // [sp+Ch] [bp-4Ch]@1
  int v36; // [sp+10h] [bp-48h]@5
  int v37; // [sp+14h] [bp-44h]@1
  int v38; // [sp+18h] [bp-40h]@8
  int v39; // [sp+18h] [bp-40h]@22
  int v40; // [sp+1Ch] [bp-3Ch]@2
  int v41; // [sp+20h] [bp-38h]@15
  int v42; // [sp+20h] [bp-38h]@22
  unsigned int v43; // [sp+24h] [bp-34h]@1
  float v44; // [sp+28h] [bp-30h]@9
  float v45; // [sp+2Ch] [bp-2Ch]@9
  float v46; // [sp+30h] [bp-28h]@9
  float i; // [sp+34h] [bp-24h]@9
  float v48; // [sp+38h] [bp-20h]@16
  float v49; // [sp+3Ch] [bp-1Ch]@16
  float j; // [sp+40h] [bp-18h]@16
  float v51; // [sp+48h] [bp-10h]@23

  v4 = this;
  result = *(_DWORD *)(this + 4);
  v6 = 0;
  v37 = v4;
  v35 = 0;
  v43 = result;
  if ( *(_DWORD *)(result + 12) )
  {
    v40 = *(_DWORD *)v4;
    while ( 1 )
    {
      v7 = *(_DWORD *)(v40 + 4);
      if ( v7 )
      {
        v8 = v6 % (v7 + 1);
        result = v6 / (v7 + 1);
        if ( v8 != a2 )
          goto LABEL_30;
      }
      v9 = *(_DWORD *)(v4 + 4);
      v10 = *(_DWORD *)(v9 + 24);
      v11 = *(_DWORD *)(v4 + 8);
      v12 = *(_DWORD *)v9;
      v36 = v11 + 8 * v10;
      if ( !v12 )
      {
        v30 = *(_DWORD *)(v4 + 4);
        v31 = *(_DWORD *)(v4 + 20) + 16 * v6 * *(_DWORD *)(v30 + 24);
        v42 = *(_DWORD *)(v30 + 4) + v6 * *(_DWORD *)(v30 + 16);
        v39 = *(_DWORD *)(v4 + 20) + 16 * v6 * *(_DWORD *)(v30 + 24);
        do
        {
          v32 = *(_DWORD *)(v11 + 4);
          v33 = v32 + 8 * *(_WORD *)v11;
          v51 = 0.0;
          if ( v32 != v33 )
          {
            do
            {
              v34 = *(_WORD *)(v32 + 4);
              v32 += 8;
              v51 = *(float *)(v42 + 4 * v34) * *(float *)(v32 - 8) + v51;
            }
            while ( v32 != v33 );
            v31 = v39;
          }
          result = v31;
          v31 += 16;
          v39 = v31;
          if ( (float *)result != &v51 )
          {
            *(float *)result = v51;
            *(_DWORD *)(result + 4) = 0;
            *(_DWORD *)(result + 8) = 0;
            *(_DWORD *)(result + 12) = 0;
          }
          v11 += 8;
        }
        while ( v11 != v36 );
        goto LABEL_29;
      }
      v13 = v12 - 1;
      if ( !v13 )
        break;
      result = v13 - 1;
      if ( !result )
      {
        v14 = *(_DWORD *)(v4 + 4);
        v15 = *(_DWORD *)(v14 + 4) + v6 * *(_DWORD *)(v14 + 16);
        v38 = *(_DWORD *)(v4 + 20) + 16 * v6 * *(_DWORD *)(v14 + 24);
        do
        {
          v16 = *(_DWORD *)(v11 + 4);
          v17 = v16 + 8 * *(_WORD *)v11;
          v44 = 0.0;
          v45 = 0.0;
          v46 = 0.0;
          for ( i = 0.0; v16 != v17; i = v18 * *(float *)(v19 + 12) + i )
          {
            v18 = *(float *)v16;
            v19 = v15 + 16 * *(_WORD *)(v16 + 4);
            v16 += 8;
            v44 = *(float *)v19 * v18 + v44;
            v45 = *(float *)(v19 + 4) * v18 + v45;
            v46 = *(float *)(v19 + 8) * v18 + v46;
          }
          result = v38;
          v38 += 16;
          if ( (float *)result != &v44 )
          {
            v20 = v45;
            *(float *)result = v44;
            v21 = v46;
            *(float *)(result + 4) = v20;
            v22 = i;
            *(float *)(result + 8) = v21;
            *(float *)(result + 12) = v22;
          }
          v11 += 8;
        }
        while ( v11 != v36 );
LABEL_29:
        v4 = v37;
        v6 = v35;
      }
LABEL_30:
      v35 = ++v6;
      if ( v6 >= *(_DWORD *)(v43 + 12) )
        return result;
    }
    v23 = *(_DWORD *)(v4 + 4);
    v24 = *(_DWORD *)(v23 + 4) + v6 * *(_DWORD *)(v23 + 16);
    v25 = *(_DWORD *)(v4 + 20) + 16 * v35 * *(_DWORD *)(v23 + 24);
    v41 = v24;
    do
    {
      v26 = *(_DWORD *)(v11 + 4);
      v27 = v26 + 8 * *(_WORD *)v11;
      v48 = 0.0;
      v49 = 0.0;
      for ( j = 0.0; v26 != v27; j = v28 * *(float *)(v29 + 8) + j )
      {
        v28 = *(float *)v26;
        v29 = v41 + 16 * *(_WORD *)(v26 + 4);
        v26 += 8;
        v48 = *(float *)v29 * v28 + v48;
        v49 = *(float *)(v29 + 4) * v28 + v49;
      }
      result = v25;
      v25 += 16;
      if ( (float *)result != &v48 )
      {
        *(float *)result = v48;
        *(float *)(result + 4) = v49;
        *(float *)(result + 8) = j;
        *(_DWORD *)(result + 12) = 0;
      }
      v11 += 8;
    }
    while ( v11 != v36 );
    goto LABEL_29;
  }
  return result;
}

//----- (10092F70) --------------------------------------------------------
void __usercall sub_10092F70(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // eax@2
  int v3; // eax@6
  int v4; // eax@11
  int v5; // eax@12
  int v6; // eax@16

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 )
  {
    v2 = *(_DWORD *)(v1 + 4);
    if ( v2 )
    {
      if ( v2 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) = 0;
    v3 = *(_DWORD *)(a1 + 8);
    if ( v3 )
    {
      if ( v3 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v3, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 8) = 0;
  }
  v4 = *(_DWORD *)(a1 + 12);
  if ( v4 )
  {
    v5 = *(_DWORD *)(v4 + 4);
    if ( v5 )
    {
      if ( v5 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) = 0;
    v6 = *(_DWORD *)(a1 + 12);
    if ( v6 )
    {
      if ( v6 & 7 )
      {
        sub_100927E0((int)"crnlib_free: bad ptr");
        *(_DWORD *)(a1 + 12) = 0;
        return;
      }
      off_100AD9F4(v6, 0, 0, 1, dword_100AE9F4);
    }
    *(_DWORD *)(a1 + 12) = 0;
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10093050) --------------------------------------------------------
void __stdcall sub_10093050(int a1)
{
  int v1; // eax@1

  sub_10092F70(a1);
  v1 = *(_DWORD *)(a1 + 20);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100930F0) --------------------------------------------------------
void __thiscall sub_100930F0(int this, int a2, int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // eax@1
  int v6; // ebx@3
  unsigned int v7; // ecx@3
  int v8; // eax@5
  int v9; // edx@7
  int v10; // eax@7
  int v11; // ecx@7
  void *v12; // ecx@8
  unsigned int v13; // edx@9
  int v14; // ecx@11
  int v15; // edi@11
  int v16; // ecx@11
  unsigned int v17; // esi@12
  float *v18; // edx@13
  double v19; // st7@13
  int v20; // eax@13
  unsigned int v21; // edx@18
  double v22; // st7@19
  char *v23; // eax@19
  int v24; // ecx@19
  double v25; // st6@20
  int v26; // eax@24
  int v27; // esi@24
  double v28; // st7@24
  int v29; // eax@24
  int v30; // esi@24
  int v31; // eax@25
  double v32; // st7@27
  double v33; // st6@27
  int v34; // edx@27
  int v35; // ecx@27
  double v36; // rt0@28
  double v37; // rt1@30
  double v38; // st6@30
  double v39; // st7@30
  double v40; // rt2@34
  double v41; // st7@52
  double v42; // st6@52
  int v43; // edx@52
  double v44; // rt1@54
  double v45; // st6@54
  double v46; // st7@54
  double v47; // rt2@58
  double v48; // rtt@68
  double v49; // st7@71
  double v50; // st6@71
  float *v51; // edx@71
  double v52; // rt0@72
  double v53; // rt1@74
  double v54; // st6@74
  double v55; // st7@74
  double v56; // rt2@78
  unsigned int v57; // [sp+10h] [bp-48h]@3
  int v58; // [sp+14h] [bp-44h]@1
  unsigned int v59; // [sp+18h] [bp-40h]@9
  float v60; // [sp+18h] [bp-40h]@24
  float v61; // [sp+18h] [bp-40h]@30
  float v62; // [sp+18h] [bp-40h]@36
  float v63; // [sp+18h] [bp-40h]@40
  float v64; // [sp+18h] [bp-40h]@45
  float v65; // [sp+18h] [bp-40h]@54
  float v66; // [sp+18h] [bp-40h]@60
  float v67; // [sp+18h] [bp-40h]@64
  float v68; // [sp+1Ch] [bp-3Ch]@11
  float v69; // [sp+1Ch] [bp-3Ch]@24
  float v70; // [sp+1Ch] [bp-3Ch]@74
  int v71; // [sp+20h] [bp-38h]@4
  int v72; // [sp+24h] [bp-34h]@10
  _WORD *v73; // [sp+28h] [bp-30h]@7
  float v74; // [sp+28h] [bp-30h]@29
  float v75; // [sp+28h] [bp-30h]@35
  float v76; // [sp+28h] [bp-30h]@39
  float v77; // [sp+28h] [bp-30h]@44
  float v78; // [sp+28h] [bp-30h]@53
  float v79; // [sp+28h] [bp-30h]@59
  float v80; // [sp+28h] [bp-30h]@63
  float v81; // [sp+28h] [bp-30h]@73
  void *v82; // [sp+2Ch] [bp-2Ch]@1
  int v83; // [sp+30h] [bp-28h]@1
  int v84; // [sp+34h] [bp-24h]@1
  float v85; // [sp+38h] [bp-20h]@14
  float v86; // [sp+3Ch] [bp-1Ch]@14
  float v87; // [sp+40h] [bp-18h]@14
  float v88; // [sp+44h] [bp-14h]@14
  float v89; // [sp+48h] [bp-10h]@20
  float v90; // [sp+4Ch] [bp-Ch]@20
  float v91; // [sp+50h] [bp-8h]@20
  float v92; // [sp+54h] [bp-4h]@20

  v4 = this;
  v5 = *(_DWORD *)(*(_DWORD *)(this + 4) + 24);
  v58 = this;
  v82 = 0;
  v83 = 0;
  v84 = 0;
  if ( v5 )
    sub_100943C0(v5, 0, (int)&v82, v5 == 1, 0x10u, 0);
  v6 = *(_DWORD *)(v4 + 4);
  v7 = 0;
  v57 = 0;
  if ( *(_DWORD *)(v6 + 28) > 0u )
  {
    v71 = *(_DWORD *)v4;
    while ( 1 )
    {
      v8 = *(_DWORD *)(v71 + 4);
      if ( v8 && v7 % (v8 + 1) != a2 )
        goto LABEL_81;
      v9 = *(_DWORD *)(v4 + 12);
      v10 = *(_WORD *)(v9 + 8 * v7);
      v11 = v9 + 8 * v7;
      v73 = (_WORD *)v11;
      if ( v10 == 1 )
      {
        v12 = (void *)(*(_DWORD *)(v4 + 20) + 16 * *(_DWORD *)(v6 + 24) * *(_WORD *)(*(_DWORD *)(v11 + 4) + 4));
      }
      else
      {
        v13 = 0;
        v59 = 0;
        if ( (unsigned __int16)v10 > 0u )
        {
          v72 = *(_DWORD *)(v4 + 20);
          do
          {
            v14 = *(_DWORD *)(v11 + 4);
            v15 = *(_DWORD *)(v6 + 24);
            v68 = *(float *)(v14 + 8 * v13);
            v16 = v72 + 16 * v15 * *(_WORD *)(v14 + 8 * v13 + 4);
            if ( v13 )
            {
              v21 = 0;
              if ( v15 )
              {
                v22 = v68;
                v23 = (char *)v82 + 8;
                v24 = v16 + 8;
                do
                {
                  ++v21;
                  v25 = *(float *)(v24 - 8) * v22;
                  v24 += 16;
                  v23 += 16;
                  v89 = v25;
                  v90 = *(float *)(v24 - 20) * v22;
                  v91 = v22 * *(float *)(v24 - 16);
                  v92 = *(float *)(v24 - 12) * v22;
                  *((float *)v23 - 6) = v89 + *((float *)v23 - 6);
                  *((float *)v23 - 5) = *((float *)v23 - 5) + v90;
                  *((float *)v23 - 4) = v91 + *((float *)v23 - 4);
                  *((float *)v23 - 3) = *((float *)v23 - 3) + v92;
                }
                while ( v21 < *(_DWORD *)(v6 + 24) );
              }
            }
            else
            {
              v17 = 0;
              if ( v15 )
              {
                v18 = (float *)v82;
                v19 = v68;
                v20 = v16 + 8;
                do
                {
                  v85 = *(float *)(v20 - 8) * v19;
                  v86 = *(float *)(v20 - 4) * v19;
                  v87 = *(float *)v20 * v19;
                  v88 = *(float *)(v20 + 4) * v19;
                  if ( v18 != &v85 )
                  {
                    *v18 = v85;
                    v18[1] = v86;
                    v18[2] = v87;
                    v18[3] = v88;
                  }
                  ++v17;
                  v20 += 16;
                  v18 += 4;
                }
                while ( v17 < *(_DWORD *)(v6 + 24) );
              }
            }
            v11 = (int)v73;
            v13 = v59 + 1;
            v59 = v13;
          }
          while ( v13 < *v73 );
          v4 = v58;
        }
        v12 = v82;
      }
      v26 = *(_DWORD *)(v4 + 4);
      v27 = *(_DWORD *)(v26 + 24);
      v60 = *(float *)(v26 + 40);
      v28 = *(float *)(v26 + 44);
      v29 = *(_DWORD *)v26;
      v30 = (int)v12 + 16 * v27;
      v69 = v28;
      if ( !v29 )
      {
        v49 = v60;
        v50 = v69;
        v51 = (float *)(*(_DWORD *)(*(_DWORD *)(v4 + 4) + 20) + v57 * *(_DWORD *)(*(_DWORD *)(v4 + 4) + 32));
        while ( 1 )
        {
          v81 = *(float *)v12;
          if ( v81 >= v49 )
          {
            v70 = v81 <= v50 ? v81 : (float)v50;
            v56 = v50;
            v54 = v49;
            v55 = v56;
          }
          else
          {
            v53 = v50;
            v54 = v49;
            v55 = v53;
            v70 = v54;
          }
          v12 = (char *)v12 + 16;
          *v51 = v70;
          ++v51;
          if ( v12 == (void *)v30 )
            break;
          v52 = v54;
          v50 = v55;
          v49 = v52;
        }
        goto LABEL_80;
      }
      v31 = v29 - 1;
      if ( !v31 )
        break;
      if ( v31 == 1 )
      {
        v32 = v60;
        v33 = v69;
        v34 = *(_DWORD *)(*(_DWORD *)(v4 + 4) + 20) + v57 * *(_DWORD *)(*(_DWORD *)(v4 + 4) + 32);
        v35 = (int)v12 + 8;
        while ( 1 )
        {
          v74 = *(float *)(v35 - 8);
          if ( v74 >= v32 )
          {
            v61 = v74 <= v33 ? v74 : (float)v33;
            v40 = v33;
            v38 = v32;
            v39 = v40;
          }
          else
          {
            v37 = v33;
            v38 = v32;
            v39 = v37;
            v61 = v38;
          }
          *(float *)v34 = v61;
          v75 = *(float *)(v35 - 4);
          if ( v75 >= v38 )
            v62 = v75 <= v39 ? v75 : (float)v39;
          else
            v62 = v38;
          *(float *)(v34 + 4) = v62;
          v76 = *(float *)v35;
          if ( v76 >= v38 )
            v63 = v76 <= v39 ? v76 : (float)v39;
          else
            v63 = v38;
          *(float *)(v34 + 8) = v63;
          v77 = *(float *)(v35 + 4);
          if ( v77 >= v38 )
            v64 = v77 <= v39 ? v77 : (float)v39;
          else
            v64 = v38;
          v35 += 16;
          *(float *)(v34 + 12) = v64;
          v34 += 16;
          if ( v35 - 8 == v30 )
            break;
          v36 = v38;
          v33 = v39;
          v32 = v36;
        }
LABEL_80:
        v4 = v58;
      }
LABEL_81:
      v7 = v57 + 1;
      v57 = v7;
      if ( v7 >= *(_DWORD *)(v6 + 28) )
        goto LABEL_82;
    }
    v41 = v60;
    v42 = v69;
    v43 = *(_DWORD *)(*(_DWORD *)(v4 + 4) + 20) + v57 * *(_DWORD *)(*(_DWORD *)(v4 + 4) + 32);
    do
    {
      v78 = *(float *)v12;
      if ( v78 >= v41 )
      {
        if ( v78 <= v42 )
          v65 = v78;
        else
          v65 = v42;
        v47 = v42;
        v45 = v41;
        v46 = v47;
      }
      else
      {
        v44 = v42;
        v45 = v41;
        v46 = v44;
        v65 = v45;
      }
      *(float *)v43 = v65;
      v79 = *((float *)v12 + 1);
      if ( v79 >= v45 )
      {
        if ( v79 <= v46 )
          v66 = v79;
        else
          v66 = v46;
      }
      else
      {
        v66 = v45;
      }
      *(float *)(v43 + 4) = v66;
      v80 = *((float *)v12 + 2);
      if ( v80 >= v45 )
      {
        if ( v80 <= v46 )
          v67 = v80;
        else
          v67 = v46;
      }
      else
      {
        v67 = v45;
      }
      v12 = (char *)v12 + 16;
      *(float *)(v43 + 8) = v67;
      v43 += 16;
      v48 = v45;
      v42 = v46;
      v41 = v48;
      *(float *)(v43 - 4) = v42;
    }
    while ( v12 != (void *)v30 );
    goto LABEL_80;
  }
LABEL_82:
  if ( v82 )
  {
    if ( (unsigned __int8)v82 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v82, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100935B0) --------------------------------------------------------
char __userpurge sub_100935B0@<al>(int a1@<eax>, int a2)
{
  int v2; // edi@1
  int v4; // eax@6
  char *v5; // esi@7
  void *v6; // eax@7
  void *v7; // eax@8
  unsigned int v8; // esi@10
  unsigned int v9; // edi@12
  int v10; // esi@13
  int v11; // eax@13
  int v12; // eax@16

  v2 = a1;
  sub_10092F70(a2);
  *(_DWORD *)(a2 + 4) = v2;
  if ( *(_DWORD *)v2 )
  {
    if ( (unsigned int)(*(_DWORD *)v2 - 1) > 1 )
      return 0;
    *(_DWORD *)(a2 + 16) = 16;
  }
  else
  {
    *(_DWORD *)(a2 + 16) = 4;
  }
  v4 = sub_1005A5B0(*(char **)(v2 + 48));
  if ( v4 < 0 )
    return 0;
  v5 = &aBox[40 * v4];
  v6 = sub_10066550(
         *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8),
         *(_DWORD *)(*(_DWORD *)(a2 + 4) + 24),
         *(_DWORD *)(*(_DWORD *)(a2 + 4) + 36),
         *(&off_10099948 + 10 * v4),
         flt_1009994C[10 * v4],
         *(float *)(v2 + 52),
         0.0);
  *(_DWORD *)(a2 + 8) = v6;
  if ( !v6 )
    return 0;
  v7 = sub_10066550(
         *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12),
         *(_DWORD *)(*(_DWORD *)(a2 + 4) + 28),
         *(_DWORD *)(*(_DWORD *)(a2 + 4) + 36),
         *((_DWORD *)v5 + 8),
         *((float *)v5 + 9),
         *(float *)(v2 + 56),
         0.0);
  *(_DWORD *)(a2 + 12) = v7;
  if ( !v7 || !sub_100413B0(a2 + 20, *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12) * *(_DWORD *)(*(_DWORD *)(a2 + 4) + 24)) )
    return 0;
  v8 = 0;
  do
    sub_100413F0(*(_DWORD *)a2, a2, (int)sub_10092CD0, v8++, 0);
  while ( v8 <= *(_DWORD *)(*(_DWORD *)a2 + 4) );
  sub_10091500(*(_DWORD *)a2);
  v9 = 0;
  do
  {
    v10 = *(_DWORD *)a2;
    v11 = sub_10092A80(16);
    if ( v11 )
    {
      *(_DWORD *)v11 = &off_100A4F34;
      *(_DWORD *)(v11 + 4) = a2;
      *(_DWORD *)(v11 + 8) = sub_100930F0;
      *(_DWORD *)(v11 + 12) = 1;
      sub_100916A0(v11, v10, v9, 0, 0);
    }
    ++v9;
  }
  while ( v9 <= *(_DWORD *)(*(_DWORD *)a2 + 4) );
  sub_10091500(*(_DWORD *)a2);
  v12 = *(_DWORD *)(a2 + 20);
  if ( v12 )
  {
    if ( v12 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v12, 0, 0, 1, dword_100AE9F4);
    *(_DWORD *)(a2 + 20) = 0;
    *(_DWORD *)(a2 + 24) = 0;
    *(_DWORD *)(a2 + 28) = 0;
  }
  sub_10092F70(a2);
  return 1;
}
// 1009994C: using guessed type float flt_1009994C[];
// 100A4F34: using guessed type int (__thiscall *off_100A4F34)(void *, int, int, int);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10093750) --------------------------------------------------------
void sub_10093750()
{
  if ( 0.0 == dbl_100BF5B8 )
  {
    QueryPerformanceFrequency(&Frequency);
    dbl_100BF5B8 = 1.0 / (double)(unsigned __int64)Frequency.QuadPart;
    QueryPerformanceCounter(&PerformanceCount);
  }
}
// 100BF5B8: using guessed type double dbl_100BF5B8;

//----- (100937C0) --------------------------------------------------------
double __usercall sub_100937C0@<st0>(int a1@<esi>)
{
  char v1; // dl@1
  double result; // st7@2
  DWORD v3; // ecx@3
  LONG v4; // eax@3
  LARGE_INTEGER v5; // [sp+0h] [bp-Ch]@3

  v1 = *(_BYTE *)(a1 + 16);
  if ( v1 & 1 )
  {
    v3 = *(_DWORD *)(a1 + 8);
    v4 = *(_DWORD *)(a1 + 12);
    v5.s.LowPart = *(_DWORD *)(a1 + 8);
    v5.s.HighPart = v4;
    if ( !(v1 & 2) )
    {
      QueryPerformanceCounter(&v5);
      v4 = v5.s.HighPart;
      v3 = v5.s.LowPart;
    }
    result = (double)(__PAIR__((unsigned int)v4, v3) - *(_QWORD *)a1) * dbl_100BF5B8;
  }
  else
  {
    result = 0.0;
  }
  return result;
}
// 100BF5B8: using guessed type double dbl_100BF5B8;

//----- (10093880) --------------------------------------------------------
int __stdcall sub_10093880(int a1, int a2, int a3)
{
  int v3; // ebp@1
  int result; // eax@1
  unsigned int v5; // ebx@1
  unsigned int v6; // edi@1
  bool v7; // zf@1
  int v8; // ebx@8
  unsigned int v9; // esi@8
  char v10; // dl@8
  unsigned int v11; // ecx@8
  unsigned int v12; // eax@9
  unsigned int v13; // kr04_4@12
  unsigned int v14; // ecx@12
  int v15; // eax@16
  int v16; // eax@16
  int v17; // [sp+14h] [bp-2Ch]@8
  unsigned __int64 v18; // [sp+18h] [bp-28h]@7
  int v19; // [sp+20h] [bp-20h]@6
  int v20; // [sp+24h] [bp-1Ch]@6
  unsigned int v21; // [sp+28h] [bp-18h]@6
  unsigned int v22; // [sp+2Ch] [bp-14h]@6
  unsigned int v23; // [sp+30h] [bp-10h]@6
  unsigned int v24; // [sp+34h] [bp-Ch]@6
  int v25; // [sp+38h] [bp-8h]@6
  int v26; // [sp+3Ch] [bp-4h]@6
  unsigned int v27; // [sp+44h] [bp+4h]@1

  v3 = a1;
  result = *(_DWORD *)a1;
  v5 = 0;
  v6 = 0;
  v7 = *(_BYTE *)(*(_DWORD *)a1 + 20) == 0;
  v27 = 0;
  if ( !v7 != -1 )
  {
    while ( 1 )
    {
      if ( v5 )
      {
        v21 = (a3 + 4 * a2) / 5u;
        v22 = (3 * a2 + 2 * a3) / 5u;
        v20 = a3;
        v23 = (3 * a3 + 2 * a2) / 5u;
        v19 = a2;
        v24 = (a2 + 4 * a3) / 5u;
        v25 = 0;
        v26 = 255;
      }
      else
      {
        sub_10092180(a3);
        v6 = 0;
      }
      v18 = 0i64;
      if ( *(_DWORD *)(v3 + 12) )
      {
        do
        {
          v8 = *(_BYTE *)(*(_DWORD *)(v3 + 8) + v6);
          v17 = *(_DWORD *)(*(_DWORD *)(v3 + 20) + 4 * v6);
          v9 = -1;
          v10 = 0;
          v11 = 0;
          do
          {
            v12 = v17 * (v8 - *(&v19 + v11)) * (v8 - *(&v19 + v11));
            if ( v12 < v9 )
            {
              v9 = v17 * (v8 - *(&v19 + v11)) * (v8 - *(&v19 + v11));
              v10 = v11;
              if ( !v12 )
                break;
            }
            ++v11;
          }
          while ( v11 < 8 );
          v13 = v18;
          LODWORD(v18) = v9 + v18;
          *(_BYTE *)(v6 + *(_DWORD *)(v3 + 32)) = v10;
          v14 = (__PAIR__(HIDWORD(v18), v9) + v13) >> 32;
          HIDWORD(v18) = (__PAIR__(HIDWORD(v18), v9) + v13) >> 32;
          if ( __PAIR__(v14, (unsigned int)v18) > *(_QWORD *)(*(_DWORD *)(v3 + 4) + 8) )
            break;
          ++v6;
        }
        while ( v6 < *(_DWORD *)(v3 + 12) );
        v5 = v27;
      }
      result = *(_DWORD *)(v3 + 4);
      if ( v18 < *(_QWORD *)(result + 8) )
      {
        *(_QWORD *)(result + 8) = v18;
        *(_BYTE *)(*(_DWORD *)(v3 + 4) + 16) = a2;
        *(_BYTE *)(*(_DWORD *)(v3 + 4) + 17) = a3;
        *(_BYTE *)(*(_DWORD *)(v3 + 4) + 18) = v5;
        v15 = *(_DWORD *)(v3 + 44);
        *(_DWORD *)(v3 + 44) = *(_DWORD *)(v3 + 32);
        *(_DWORD *)(v3 + 32) = v15;
        v16 = *(_DWORD *)(v3 + 48);
        *(_DWORD *)(v3 + 48) = *(_DWORD *)(v3 + 36);
        *(_DWORD *)(v3 + 36) = v16;
        result = *(_DWORD *)(v3 + 52);
        *(_DWORD *)(v3 + 52) = *(_DWORD *)(v3 + 40);
        *(_DWORD *)(v3 + 40) = result;
        if ( !v18 )
          break;
      }
      v27 = ++v5;
      if ( v5 >= (unsigned int)(*(_BYTE *)(*(_DWORD *)v3 + 20) != 0) + 1 )
        break;
      v6 = 0;
    }
  }
  return result;
}
// 10092180: using guessed type double __thiscall sub_10092180(_DWORD);

//----- (10093A30) --------------------------------------------------------
char __stdcall sub_10093A30(int a1, int a2, int a3)
{
  int v3; // ebp@1
  _BYTE **v4; // ebx@3
  int v5; // ecx@3
  unsigned int v6; // edx@3
  int v7; // eax@4
  int v8; // esi@4
  unsigned int v9; // ecx@5
  unsigned int v10; // eax@7
  unsigned int v11; // esi@11
  void *v12; // edx@12
  unsigned int v14; // eax@13
  unsigned int v15; // esi@19
  unsigned int v16; // eax@19
  unsigned int v17; // eax@25
  unsigned int v18; // edi@26
  unsigned int i; // esi@26
  unsigned int v20; // edi@33
  void *v21; // eax@34
  int v22; // edx@37
  int v23; // ecx@37
  int v24; // esi@37
  int v25; // eax@38
  bool v26; // sf@38
  int v27; // eax@38
  int v28; // eax@40
  int v29; // edi@43
  __int16 v30; // si@45
  unsigned int v31; // ebx@45
  int v32; // edx@45
  _DWORD *v33; // eax@50
  int v34; // eax@56
  unsigned __int8 v35; // cl@56
  unsigned __int8 v36; // dl@56
  unsigned int v37; // eax@57
  char v38; // cl@62
  unsigned int v39; // eax@62
  char v40; // cl@66
  unsigned int v41; // eax@66
  unsigned int v42; // eax@68
  char v43; // [sp+10h] [bp-10h]@4
  int v44; // [sp+10h] [bp-10h]@40
  int v45; // [sp+18h] [bp-8h]@37
  int v46; // [sp+1Ch] [bp-4h]@37
  unsigned int v47; // [sp+24h] [bp+4h]@3
  int v48; // [sp+24h] [bp+4h]@37
  int v49; // [sp+28h] [bp+8h]@26
  int v50; // [sp+28h] [bp+8h]@38
  int v51; // [sp+2Ch] [bp+Ch]@40

  v3 = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  if ( !*(_DWORD *)(a2 + 8) || !*(_DWORD *)(a2 + 4) )
    return 0;
  v4 = (_BYTE **)(a1 + 8);
  sub_10033010(a1 + 8, 0);
  sub_100366C0(a1 + 20, 0);
  memset((void *)(a1 + 56), 0xFFu, 0x400u);
  v5 = a2;
  v6 = 0;
  v47 = 0;
  if ( *(_DWORD *)(a2 + 8) )
  {
    do
    {
      v7 = *(_BYTE *)(*(_DWORD *)(v5 + 4) + 4 * v6 + *(_DWORD *)(v5 + 12));
      v8 = *(_DWORD *)(v3 + 4 * v7 + 56);
      v43 = *(_BYTE *)(*(_DWORD *)(v5 + 4) + 4 * v6 + *(_DWORD *)(v5 + 12));
      if ( v8 == -1 )
      {
        v8 = *(_DWORD *)(v3 + 12);
        *(_DWORD *)(v3 + 4 * v7 + 56) = v8;
        v9 = *(_DWORD *)(v3 + 12);
        if ( v9 >= *(_DWORD *)(v3 + 16) )
        {
          sub_100943C0(v9 + 1, 0, v3 + 8, 1, 1u, 0);
          LOBYTE(v7) = v43;
        }
        (*v4)[(*(_DWORD *)(v3 + 12))++] = v7;
        v10 = *(_DWORD *)(v3 + 24);
        if ( v10 >= *(_DWORD *)(v3 + 28) )
          sub_100943C0(v10 + 1, 0, v3 + 20, 1, 4u, 0);
        v6 = v47;
        *(_DWORD *)(*(_DWORD *)(v3 + 20) + 4 * (*(_DWORD *)(v3 + 24))++) = 0;
        v5 = a2;
      }
      ++*(_DWORD *)(*(_DWORD *)(v3 + 20) + 4 * v8);
      v47 = ++v6;
    }
    while ( v6 < *(_DWORD *)(v5 + 8) );
  }
  v11 = *(_DWORD *)(v3 + 12);
  if ( v11 == 1 )
  {
    *(_BYTE *)(a3 + 18) = 0;
    *(_DWORD *)(a3 + 8) = 0;
    *(_DWORD *)(a3 + 12) = 0;
    *(_BYTE *)(a3 + 16) = **v4;
    v12 = *(void **)a3;
    *(_BYTE *)(a3 + 17) = **v4;
    memset(v12, 0, *(_DWORD *)(v5 + 8));
    return 1;
  }
  v14 = *(_DWORD *)(v3 + 36);
  if ( v11 != v14 )
  {
    if ( v11 >= v14 )
    {
      if ( v11 > *(_DWORD *)(v3 + 40) )
        sub_100943C0(v11, 0, v3 + 32, v11 == v14 + 1, 1u, 0);
      memset((void *)(*(_DWORD *)(v3 + 36) + *(_DWORD *)(v3 + 32)), 0, v11 - *(_DWORD *)(v3 + 36));
    }
    *(_DWORD *)(v3 + 36) = v11;
  }
  v15 = *(_DWORD *)(v3 + 12);
  v16 = *(_DWORD *)(v3 + 48);
  if ( v15 != v16 )
  {
    if ( v15 >= v16 )
    {
      if ( v15 > *(_DWORD *)(v3 + 52) )
        sub_100943C0(v15, 0, v3 + 44, v15 == v16 + 1, 1u, 0);
      memset((void *)(*(_DWORD *)(v3 + 48) + *(_DWORD *)(v3 + 44)), 0, v15 - *(_DWORD *)(v3 + 48));
    }
    *(_DWORD *)(v3 + 48) = v15;
  }
  *(_DWORD *)(a3 + 8) = -1;
  *(_DWORD *)(a3 + 12) = -1;
  v17 = 0;
  if ( *(_DWORD *)(v3 + 12) != 1 )
  {
    do
    {
      v18 = v17 + 1;
      v49 = (*v4)[v17];
      for ( i = v17 + 1; i < *(_DWORD *)(v3 + 12); ++i )
        sub_10093880(v3, v49, (*v4)[i]);
      v17 = v18;
    }
    while ( v18 < *(_DWORD *)(v3 + 12) - 1 );
  }
  if ( *(_DWORD *)(*(_DWORD *)v3 + 16) < 3 || !*(_QWORD *)(*(_DWORD *)(v3 + 4) + 8) )
    goto LABEL_56;
  if ( *(_DWORD *)(v3 + 1080) != 128 )
    sub_1007C810(v3 + 1080, 0x80u);
  v20 = 0;
  if ( *(_DWORD *)(v3 + 1080) )
  {
    do
    {
      v21 = *(void **)(*(_DWORD *)(v3 + 1084) + 4 * v20);
      if ( v21 )
        memset(v21, 0, 0x40u);
      ++v20;
    }
    while ( v20 < *(_DWORD *)(v3 + 1080) );
  }
  v22 = 8 * (*(_DWORD *)(*(_DWORD *)v3 + 16) == 4) + 8;
  v23 = -v22;
  v24 = -v22;
  v45 = v22;
  v46 = -v22;
  v48 = -v22;
  if ( -v22 > v22 )
    goto LABEL_56;
  do
  {
    v25 = *(_BYTE *)(*(_DWORD *)(v3 + 4) + 16);
    v26 = v24 + v25 < 0;
    v27 = v24 + v25;
    v50 = v27;
    if ( v26 )
      goto LABEL_55;
    if ( v27 > 255 )
      break;
    v28 = v27 << 8;
    v44 = v28;
    v51 = v23;
    if ( v23 > v22 )
      goto LABEL_55;
    while ( 1 )
    {
      v29 = v23 + *(_BYTE *)(*(_DWORD *)(v3 + 4) + 17);
      if ( v29 < 0 )
        goto LABEL_53;
      if ( v29 > 255 )
        break;
      v30 = v29 + v28;
      v31 = (unsigned int)(v29 + v28) >> 9;
      v32 = *(_DWORD *)(*(_DWORD *)(v3 + 1084) + 4 * v31);
      if ( v32 )
      {
        if ( ((1 << (v30 & 0x1F)) & *(_DWORD *)(v32 + 4 * ((v30 & 0x1FFu) >> 5))) != 0 )
          goto LABEL_53;
        v31 = (unsigned int)(v29 + v28) >> 9;
      }
      if ( !*(_DWORD *)(*(_DWORD *)(v3 + 1084)
                      + 4 * ((v50 + ((v23 + (unsigned int)*(_BYTE *)(*(_DWORD *)(v3 + 4) + 17)) << 8)) >> 9))
        || ((1 << (v50 & 0x1F)) & *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 + 1084)
                                                        + 4 * ((unsigned int)(v50 + (v29 << 8)) >> 9))
                                            + 4
                                            * (((v50 + ((v23 + *(_BYTE *)(*(_DWORD *)(v3 + 4) + 17)) << 8)) & 0x1FFu) >> 5))) == 0 )
      {
        v33 = *(_DWORD **)(*(_DWORD *)(v3 + 1084) + 4 * v31);
        if ( !v33 )
        {
          v33 = sub_10036280();
          *(_DWORD *)(*(_DWORD *)(v3 + 1084) + 4 * v31) = v33;
        }
        v33[(v30 & 0x1FFu) >> 5] |= 1 << (v30 & 0x1F);
        sub_10093880(v3, v50, v29);
      }
LABEL_53:
      v22 = v45;
      v23 = v51 + 1;
      v51 = v23;
      if ( v23 > v45 )
        break;
      v28 = v44;
    }
    v24 = v48;
    v23 = v46;
LABEL_55:
    v48 = ++v24;
  }
  while ( v24 <= v22 );
LABEL_56:
  v34 = *(_DWORD *)(v3 + 4);
  v35 = *(_BYTE *)(v34 + 16);
  v36 = *(_BYTE *)(v34 + 17);
  if ( v35 == v36 )
  {
    v37 = 0;
    if ( *(_DWORD *)(v3 + 48) )
    {
      do
        *(_BYTE *)(v37++ + *(_DWORD *)(v3 + 44)) = 0;
      while ( v37 < *(_DWORD *)(v3 + 48) );
    }
  }
  else if ( *(_BYTE *)(v34 + 18) )
  {
    if ( v35 > v36 )
    {
      v38 = *(_BYTE *)(v34 + 16);
      *(_BYTE *)(v34 + 16) = *(_BYTE *)(v34 + 17);
      *(_BYTE *)(v34 + 17) = v38;
      v39 = 0;
      if ( *(_DWORD *)(v3 + 48) )
      {
        do
        {
          *(_BYTE *)(*(_DWORD *)(v3 + 44) + v39) = byte_1009F8C4[*(_BYTE *)(*(_DWORD *)(v3 + 44) + v39)];
          ++v39;
        }
        while ( v39 < *(_DWORD *)(v3 + 48) );
      }
    }
  }
  else if ( v35 <= v36 )
  {
    v40 = *(_BYTE *)(v34 + 16);
    *(_BYTE *)(v34 + 16) = *(_BYTE *)(v34 + 17);
    *(_BYTE *)(v34 + 17) = v40;
    v41 = 0;
    if ( *(_DWORD *)(v3 + 48) )
    {
      do
      {
        *(_BYTE *)(*(_DWORD *)(v3 + 44) + v41) = byte_1009F8CC[*(_BYTE *)(*(_DWORD *)(v3 + 44) + v41)];
        ++v41;
      }
      while ( v41 < *(_DWORD *)(v3 + 48) );
    }
  }
  v42 = 0;
  if ( *(_DWORD *)(*(_DWORD *)v3 + 8) )
  {
    do
    {
      *(_BYTE *)(v42 + **(_DWORD **)(v3 + 4)) = *(_BYTE *)(*(_DWORD *)(v3
                                                                     + 4
                                                                     * *(_BYTE *)(*(_DWORD *)(*(_DWORD *)v3 + 4)
                                                                                + *(_DWORD *)(*(_DWORD *)v3 + 12)
                                                                                + 4 * v42)
                                                                     + 56)
                                                         + *(_DWORD *)(v3 + 44));
      ++v42;
    }
    while ( v42 < *(_DWORD *)(*(_DWORD *)v3 + 8) );
  }
  return 1;
}

//----- (10093EF0) --------------------------------------------------------
int __stdcall sub_10093EF0(int a1)
{
  int v1; // ecx@1

  v1 = a1 + 8;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)v1 = 0;
  *(_DWORD *)(v1 + 4) = 0;
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 1080) = 0;
  *(_DWORD *)(a1 + 1084) = 0;
  sub_10032F10(a1 + 8, 0x10u);
  sub_10036310(a1 + 20, 0x10u);
  return a1;
}

//----- (10093FC0) --------------------------------------------------------
void __cdecl sub_10093FC0(int a1, void *a2)
{
  if ( a2 )
  {
    if ( (unsigned __int8)a2 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(a2, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10093FF0) --------------------------------------------------------
int __cdecl sub_10093FF0(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  if ( a2 )
    result = sub_10092A80(a2);
  return result;
}

//----- (10094000) --------------------------------------------------------
signed int __stdcall sub_10094000(int a1, int *a2, void *a3, unsigned int *a4, int a5, unsigned int a6)
{
  return sub_100547B0(a4, a5, a1, a2, a3, a6, &a6);
}

//----- (10094030) --------------------------------------------------------
signed int __stdcall sub_10094030(int a1, int *a2, int a3, int a4, int a5, _DWORD *a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13)
{
  int v14; // [sp+0h] [bp-30h]@1
  int v15; // [sp+4h] [bp-2Ch]@1
  int v16; // [sp+8h] [bp-28h]@1
  int v17; // [sp+Ch] [bp-24h]@1
  int v18; // [sp+10h] [bp-20h]@1
  int v19; // [sp+14h] [bp-1Ch]@1
  int v20; // [sp+18h] [bp-18h]@1
  int v21; // [sp+1Ch] [bp-14h]@1
  int v22; // [sp+20h] [bp-10h]@1
  int v23; // [sp+24h] [bp-Ch]@1
  int v24; // [sp+28h] [bp-8h]@1
  int v25; // [sp+2Ch] [bp-4h]@1

  v23 = 0;
  v24 = 0;
  v22 = -1;
  v21 = -1;
  v19 = -1;
  v15 = a8;
  v14 = a7;
  v16 = a9;
  v18 = a11;
  v17 = a10;
  v20 = a12;
  v25 = a13;
  return sub_10058500(a1, a2, a3, a4, &v14, a5, a6);
}

//----- (10094100) --------------------------------------------------------
void __cdecl sub_10094100(char *Format, va_list ArgList)
{
  int v2; // ecx@0
  struct _RTL_CRITICAL_SECTION *v3; // eax@1
  int v4; // edi@1
  struct _RTL_CRITICAL_SECTION *v5; // eax@2
  struct _RTL_CRITICAL_SECTION *v6; // esi@2
  char v7; // bl@8
  unsigned int v8; // esi@9
  const char *v9; // eax@13
  int v10; // edi@15
  int v11; // eax@26
  int v12; // esi@26
  void *v13; // eax@26
  int v14; // [sp+Ch] [bp-101Ch]@26
  char v15[4]; // [sp+10h] [bp-1018h]@26
  LPCRITICAL_SECTION lpCriticalSection; // [sp+14h] [bp-1014h]@8
  char DstBuf; // [sp+18h] [bp-1010h]@8
  int v18; // [sp+1024h] [bp-4h]@8

  v3 = ::lpCriticalSection;
  v4 = v2;
  if ( !::lpCriticalSection )
  {
    v5 = (struct _RTL_CRITICAL_SECTION *)sub_10092A80(48);
    v6 = v5;
    if ( v5 )
    {
      if ( !InitializeCriticalSectionAndSpinCount(v5, 0) )
        sub_10090EE0(
          (int)"mutex::mutex: InitializeCriticalSectionAndSpinCount failed",
          (int)"crn_threading_win32.cpp",
          51);
      v3 = v6;
    }
    else
    {
      v3 = 0;
    }
    ::lpCriticalSection = v3;
  }
  lpCriticalSection = v3;
  EnterCriticalSection(v3);
  v18 = 0;
  ++dword_100BF590[v4];
  vsprintf_s(&DstBuf, 0x1000u, Format, ArgList);
  v7 = 0;
  if ( dword_100C17A8 )
  {
    v8 = 0;
    if ( dword_100C17A8 )
    {
      do
      {
        if ( (unsigned __int8)(*((int (__cdecl **)(_DWORD, _DWORD, _DWORD))dword_100C17A4 + 2 * v8))(
                                v4,
                                &DstBuf,
                                *((_DWORD *)dword_100C17A4 + 2 * v8 + 1)) )
          v7 = 1;
        ++v8;
      }
      while ( v8 < dword_100C17A8 );
    }
  }
  v9 = 0;
  if ( byte_100AD3B7 )
  {
    if ( v4 )
    {
      v10 = v4 - 5;
      if ( v10 )
      {
        if ( v10 == 1 )
          v9 = "Error: ";
      }
      else
      {
        v9 = "Warning: ";
      }
    }
    else
    {
      v9 = "Debug: ";
    }
  }
  if ( !byte_100AE9F9 && !v7 )
  {
    if ( v9 )
      printf("%s", v9);
    printf("%s\n", &DstBuf);
  }
  byte_100AD3B7 = 1;
  if ( dword_100BF5AC )
  {
    v14 = 0;
    *(_DWORD *)v15 = 0;
    v11 = sub_10092080((int)&v14, &DstBuf);
    LOBYTE(v18) = 1;
    sub_10091D50(v11, (int)&v14);
    v12 = *(_DWORD *)v15;
    v13 = *(void **)v15;
    if ( !*(_DWORD *)v15 )
      v13 = &unk_100996C3;
    sub_10091A40((int)"%s\r\n", v13);
    (*(void (**)(void))(*(_DWORD *)dword_100BF5AC + 24))();
    LOBYTE(v18) = 0;
    if ( v12 && *(_DWORD *)(v12 - 4) == ~*(_DWORD *)(v12 - 8) && v12 != 8 )
    {
      if ( ((_BYTE)v12 - 8) & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v12 - 8, 0, 0, 1, dword_100AE9F4);
    }
  }
  v18 = -1;
  LeaveCriticalSection(lpCriticalSection);
}
// 100AD3B7: using guessed type char byte_100AD3B7;
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100AE9F9: using guessed type char byte_100AE9F9;
// 100BF590: using guessed type int dword_100BF590[];
// 100BF5AC: using guessed type int dword_100BF5AC;
// 100C17A8: using guessed type int dword_100C17A8;

//----- (10094320) --------------------------------------------------------
void sub_10094320(char *Format, ...)
{
  va_list va; // [sp+8h] [bp+8h]@1

  va_start(va, Format);
  sub_10094100(Format, va);
}

//----- (10094340) --------------------------------------------------------
void sub_10094340(char *Format, ...)
{
  va_list va; // [sp+8h] [bp+8h]@1

  va_start(va, Format);
  sub_10094100(Format, va);
}

//----- (10094360) --------------------------------------------------------
void sub_10094360(char *Format, ...)
{
  va_list va; // [sp+8h] [bp+8h]@1

  va_start(va, Format);
  sub_10094100(Format, va);
}

//----- (10094380) --------------------------------------------------------
void sub_10094380(char *Format, ...)
{
  va_list va; // [sp+8h] [bp+8h]@1

  va_start(va, Format);
  sub_10094100(Format, va);
}

//----- (100943A0) --------------------------------------------------------
void sub_100943A0(char *Format, ...)
{
  va_list va; // [sp+8h] [bp+8h]@1

  va_start(va, Format);
  sub_10094100(Format, va);
}

//----- (100943C0) --------------------------------------------------------
char __userpurge sub_100943C0@<al>(unsigned int a1@<eax>, void (__cdecl *a2)(int, _DWORD, _DWORD)@<ecx>, int a3, char a4, unsigned int a5, char a6)
{
  void (__cdecl *v6)(int, _DWORD, _DWORD); // esi@1
  char result; // al@2
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // ebx@7
  int v11; // eax@7
  int v12; // esi@8
  int v13; // edi@12
  int v14; // [sp+8h] [bp-108h]@3
  unsigned int v15; // [sp+Ch] [bp-104h]@8
  char DstBuf; // [sp+10h] [bp-100h]@10

  v6 = a2;
  if ( *(_DWORD *)(a3 + 8) >= a1 )
    return 1;
  v14 = a1;
  if ( a4 && (!a1 || (a1 - 1) & a1) )
  {
    v8 = ((((a1 - 1) >> 16) | (a1 - 1)) >> 8) | ((a1 - 1) >> 16) | (a1 - 1);
    v9 = (((v8 >> 4) | v8) >> 2) | (v8 >> 4) | v8;
    v14 = (v9 | (v9 >> 1)) + 1;
  }
  v10 = a5 * v14;
  v11 = a5 * v14;
  if ( a2 )
  {
    v13 = sub_10092A10(v11, (int *)&v15);
    if ( !v13 )
    {
      if ( a6 )
        return 0;
      sprintf_s(&DstBuf, 0x100u, "vector: crnlib_malloc() failed allocating %u bytes", v10);
      sub_10090EE0((int)"buf", (int)"crn_vector.cpp", 64);
    }
    v6(v13, *(_DWORD *)a3, *(_DWORD *)(a3 + 4));
    if ( *(_DWORD *)a3 )
      sub_10092970(*(_DWORD *)a3);
    *(_DWORD *)a3 = v13;
    goto LABEL_19;
  }
  v12 = sub_100929A0(*(void **)a3, v11, (int *)&v15, 1);
  if ( !v12 )
  {
    if ( !a6 )
    {
      sprintf_s(&DstBuf, 0x100u, "vector: crnlib_realloc() failed allocating %u bytes", v10);
      sub_10090EE0((int)"buf", (int)"crn_vector.cpp", 46);
      goto LABEL_11;
    }
    return 0;
  }
LABEL_11:
  *(_DWORD *)a3 = v12;
LABEL_19:
  if ( v15 <= v10 )
  {
    *(_DWORD *)(a3 + 8) = v14;
    result = 1;
  }
  else
  {
    *(_DWORD *)(a3 + 8) = v15 / a5;
    result = 1;
  }
  return result;
}

//----- (10094540) --------------------------------------------------------
char __cdecl sub_10094540(int a1, int a2)
{
  int v2; // ebx@1
  char v3; // dl@1
  char *v4; // esi@2
  char v5; // cl@3
  unsigned int v6; // ebp@6
  unsigned int v7; // edi@8
  int v8; // ebx@10
  int v9; // eax@11
  FILE *v10; // eax@13
  unsigned int v11; // ebx@18
  int v12; // edi@18
  unsigned int v13; // eax@19
  _BYTE *v14; // ecx@20
  unsigned int v15; // ebp@28
  int v16; // esi@29
  char *v17; // edi@29
  char *v18; // eax@31
  int v19; // ecx@31
  char result; // al@35
  bool v21; // zf@39
  int **v22; // ebx@39
  char *v23; // edi@42
  int v24; // esi@43
  int v25; // eax@43
  FILE *v26; // eax@45
  int v27; // ebp@47
  int v28; // eax@48
  FILE *v29; // eax@50
  int v30; // eax@54
  int v31; // eax@54
  int v32; // eax@54
  int v33; // eax@54
  int v34; // eax@54
  int v35; // eax@54
  int v36; // eax@54
  int v37; // eax@54
  int v38; // eax@54
  int v39; // ebx@54
  int v40; // ecx@55
  FILE *v41; // eax@57
  FILE *v42; // eax@61
  int *v43; // ebx@65
  int v44; // ecx@66
  FILE *v45; // eax@68
  FILE *v46; // eax@72
  int v47; // edx@76
  _DWORD *v48; // eax@79
  unsigned int v49; // ecx@79
  int v50; // esi@84
  int v51; // eax@85
  int v52; // ecx@85
  void *v53; // eax@85
  int v54; // eax@85
  int v55; // esi@87
  int *v56; // edi@87
  int v57; // eax@88
  FILE *v58; // eax@90
  FILE *v59; // eax@95
  char v60; // [sp+13h] [bp-19B1h]@1
  unsigned int v61; // [sp+14h] [bp-19B0h]@3
  void *v62; // [sp+14h] [bp-19B0h]@40
  int v63; // [sp+18h] [bp-19ACh]@2
  char *v64; // [sp+1Ch] [bp-19A8h]@2
  char *v65; // [sp+20h] [bp-19A4h]@4
  int v66; // [sp+24h] [bp-19A0h]@1
  void *v67; // [sp+28h] [bp-199Ch]@39
  int v68; // [sp+2Ch] [bp-1998h]@39
  int v69; // [sp+30h] [bp-1994h]@39
  unsigned int v70; // [sp+34h] [bp-1990h]@39
  char DstBuf; // [sp+38h] [bp-198Ch]@13
  CHAR v72; // [sp+238h] [bp-178Ch]@72
  CHAR v73; // [sp+438h] [bp-158Ch]@57
  CHAR v74; // [sp+638h] [bp-138Ch]@68
  CHAR OutputString; // [sp+838h] [bp-118Ch]@50
  CHAR v76; // [sp+A38h] [bp-F8Ch]@61
  char v77; // [sp+C38h] [bp-D8Ch]@1
  char v78; // [sp+C48h] [bp-D7Ch]@29
  char v79; // [sp+C50h] [bp-D74h]@2
  char v80; // [sp+C58h] [bp-D6Ch]@40
  int v81; // [sp+19C0h] [bp-4h]@1

  v2 = a1;
  `eh vector constructor iterator'(&v77, 0x24u, 96, (int)sub_100336F0, sub_100336C0);
  v81 = 0;
  v3 = 0;
  v60 = 0;
  v66 = 0;
  if ( *(_DWORD *)(a1 + 8) )
  {
    v4 = &v79;
    v63 = (int)&v79;
    v64 = (char *)(a1 + 32);
    while ( 1 )
    {
      v5 = 0;
      v61 = 0;
      if ( *(_DWORD *)(v2 + 20) )
        break;
LABEL_27:
      v64 += 64;
      v4 = (char *)(v63 + 576);
      ++v66;
      v63 += 576;
      if ( (unsigned int)v66 >= *(_DWORD *)(v2 + 8) )
        goto LABEL_28;
    }
    v65 = v64;
    while ( 1 )
    {
      v6 = 1;
      if ( *(_DWORD *)(v2 + 12) >> v5 >= 1u )
        v6 = *(_DWORD *)(v2 + 12) >> v5;
      v7 = *(_DWORD *)(v2 + 16) >> v5;
      if ( v7 < 1 )
        v7 = 1;
      v8 = *(_DWORD *)v65;
      if ( !*(_DWORD *)v65 )
        break;
      v9 = *(_DWORD *)v4;
      if ( *(_DWORD *)v4 )
      {
        if ( v9 & 7 )
        {
          sprintf_s(&DstBuf, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
          OutputDebugStringA(&DstBuf);
          v10 = _iob_func();
          fputs(&DstBuf, v10 + 2);
          if ( IsDebuggerPresent() )
            DebugBreak();
        }
        else
        {
          off_100AD9F4(v9, 0, 0, 1, dword_100AE9F4);
        }
        *(_DWORD *)v4 = 0;
        *((_DWORD *)v4 + 1) = 0;
        *((_DWORD *)v4 + 2) = 0;
      }
      *((_DWORD *)v4 - 5) = v7;
      *((_DWORD *)v4 - 1) = v8;
      *((_DWORD *)v4 - 6) = v6;
      *((_DWORD *)v4 - 4) = v6;
      *((_DWORD *)v4 - 3) = v6 * v7;
      *((_DWORD *)v4 - 2) = 15;
      if ( !v60 )
      {
        v11 = *((_DWORD *)v4 - 5);
        v12 = 0;
        if ( v11 )
        {
          while ( 1 )
          {
            v13 = 0;
            if ( v6 )
              break;
LABEL_23:
            if ( ++v12 >= v11 )
              goto LABEL_24;
          }
          v14 = (_BYTE *)(*((_DWORD *)v4 - 1) + 4 * v12 * *((_DWORD *)v4 - 4) + 3);
          while ( *v14 >= 0xFFu )
          {
            ++v13;
            v14 += 4;
            if ( v13 >= v6 )
              goto LABEL_23;
          }
          v60 = 1;
        }
        else
        {
LABEL_24:
          v60 = 0;
        }
      }
      v65 += 4;
      v4 += 36;
      ++v61;
      v2 = a1;
      if ( v61 >= *(_DWORD *)(a1 + 20) )
      {
        v3 = v60;
        goto LABEL_27;
      }
      v5 = v61;
    }
    v81 = -1;
    `eh vector destructor iterator'(&v77, 0x24u, 96, sub_100336C0);
    result = 0;
  }
  else
  {
LABEL_28:
    v15 = *(_DWORD *)(v2 + 8);
    if ( v15 )
    {
      v16 = *(_DWORD *)(v2 + 20);
      v17 = &v78;
      v63 = *(_DWORD *)(v2 + 8);
      do
      {
        if ( v16 )
        {
          v18 = v17;
          v19 = v16;
          do
          {
            if ( v3 )
              *(_DWORD *)v18 |= 8u;
            else
              *(_DWORD *)v18 &= 0xFFFFFFF7;
            v18 += 36;
            --v19;
          }
          while ( v19 );
        }
        v17 += 576;
        --v63;
      }
      while ( v63 );
    }
    v67 = 0;
    v68 = 0;
    v69 = 0;
    sub_10033720((int)&v67, v15);
    LOBYTE(v81) = 1;
    v21 = *(_DWORD *)(v2 + 8) == 0;
    v22 = (int **)v67;
    v70 = 0;
    if ( !v21 )
    {
      v64 = &v80;
      v62 = v67;
      do
      {
        v21 = *(_DWORD *)(a1 + 20) == 0;
        v65 = 0;
        if ( !v21 )
        {
          v23 = v64;
          do
          {
            v24 = 0;
            v63 = 28;
            v25 = off_100AD9F4(0, 28, &v63, 1, dword_100AE9F4);
            if ( v25 && (unsigned int)v63 >= 0x1C )
            {
              *(_DWORD *)v25 = 0;
              *(_DWORD *)(v25 + 4) = 0;
              *(_DWORD *)(v25 + 8) = 15;
              *(_DWORD *)(v25 + 12) = 0;
              *(_DWORD *)(v25 + 16) = 0;
              *(_DWORD *)(v25 + 20) = 0;
              *(_DWORD *)(v25 + 24) = 0;
              v27 = v25;
            }
            else
            {
              sprintf_s(
                &DstBuf,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_malloc: out of memory");
              OutputDebugStringA(&DstBuf);
              v26 = _iob_func();
              fputs(&DstBuf, v26 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
              v27 = 0;
            }
            v66 = 36;
            v28 = off_100AD9F4(0, 36, &v66, 1, dword_100AE9F4);
            if ( v28 && (unsigned int)v66 >= 0x24 )
            {
              *(_DWORD *)v28 = 0;
              *(_DWORD *)(v28 + 4) = 0;
              *(_DWORD *)(v28 + 8) = 0;
              *(_DWORD *)(v28 + 12) = 0;
              *(_DWORD *)(v28 + 20) = 0;
              *(_DWORD *)(v28 + 16) = 15;
              *(_DWORD *)(v28 + 24) = 0;
              *(_DWORD *)(v28 + 28) = 0;
              *(_DWORD *)(v28 + 32) = 0;
              v24 = v28;
            }
            else
            {
              sprintf_s(
                &OutputString,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_malloc: out of memory");
              OutputDebugStringA(&OutputString);
              v29 = _iob_func();
              fputs(&OutputString, v29 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            v30 = *(_DWORD *)v24;
            *(_DWORD *)v24 = *((_DWORD *)v23 - 8);
            *((_DWORD *)v23 - 8) = v30;
            v31 = *(_DWORD *)(v24 + 4);
            *(_DWORD *)(v24 + 4) = *((_DWORD *)v23 - 7);
            *((_DWORD *)v23 - 7) = v31;
            v32 = *(_DWORD *)(v24 + 8);
            *(_DWORD *)(v24 + 8) = *((_DWORD *)v23 - 6);
            *((_DWORD *)v23 - 6) = v32;
            v33 = *(_DWORD *)(v24 + 12);
            *(_DWORD *)(v24 + 12) = *((_DWORD *)v23 - 5);
            *((_DWORD *)v23 - 5) = v33;
            v34 = *(_DWORD *)(v24 + 16);
            *(_DWORD *)(v24 + 16) = *((_DWORD *)v23 - 4);
            *((_DWORD *)v23 - 4) = v34;
            v35 = *(_DWORD *)(v24 + 20);
            *(_DWORD *)(v24 + 20) = *((_DWORD *)v23 - 3);
            *((_DWORD *)v23 - 3) = v35;
            v36 = *(_DWORD *)(v24 + 24);
            *(_DWORD *)(v24 + 24) = *((_DWORD *)v23 - 2);
            *((_DWORD *)v23 - 2) = v36;
            v37 = *(_DWORD *)(v24 + 28);
            *(_DWORD *)(v24 + 28) = *((_DWORD *)v23 - 1);
            *((_DWORD *)v23 - 1) = v37;
            v38 = *(_DWORD *)(v24 + 32);
            *(_DWORD *)(v24 + 32) = *(_DWORD *)v23;
            *(_DWORD *)v23 = v38;
            v39 = *(_DWORD *)(v27 + 16);
            *(_DWORD *)v27 = 0;
            *(_DWORD *)(v27 + 4) = 0;
            *(_DWORD *)(v27 + 8) = 15;
            *(_DWORD *)(v27 + 12) = 0;
            *(_DWORD *)(v27 + 24) = 0;
            if ( v39 )
            {
              v40 = *(_DWORD *)(v39 + 24);
              if ( v40 )
              {
                if ( v40 & 7 )
                {
                  sprintf_s(
                    &v73,
                    0x200u,
                    "%s(%u): Assertion failed: \"%s\"\n",
                    "crn_mem.cpp",
                    216,
                    "crnlib_free: bad ptr");
                  OutputDebugStringA(&v73);
                  v41 = _iob_func();
                  fputs(&v73, v41 + 2);
                  if ( IsDebuggerPresent() )
                    DebugBreak();
                }
                else
                {
                  off_100AD9F4(v40, 0, 0, 1, dword_100AE9F4);
                }
              }
              if ( v39 & 7 )
              {
                sprintf_s(
                  &v76,
                  0x200u,
                  "%s(%u): Assertion failed: \"%s\"\n",
                  "crn_mem.cpp",
                  216,
                  "crnlib_free: bad ptr");
                OutputDebugStringA(&v76);
                v42 = _iob_func();
                fputs(&v76, v42 + 2);
                if ( IsDebuggerPresent() )
                  DebugBreak();
              }
              else
              {
                off_100AD9F4(v39, 0, 0, 1, dword_100AE9F4);
              }
              *(_DWORD *)(v27 + 16) = 0;
            }
            v43 = *(int **)(v27 + 20);
            if ( v43 )
            {
              v44 = *v43;
              if ( *v43 )
              {
                if ( v44 & 7 )
                {
                  sprintf_s(
                    &v74,
                    0x200u,
                    "%s(%u): Assertion failed: \"%s\"\n",
                    "crn_mem.cpp",
                    216,
                    "crnlib_free: bad ptr");
                  OutputDebugStringA(&v74);
                  v45 = _iob_func();
                  fputs(&v74, v45 + 2);
                  if ( IsDebuggerPresent() )
                    DebugBreak();
                }
                else
                {
                  off_100AD9F4(v44, 0, 0, 1, dword_100AE9F4);
                }
              }
              if ( (unsigned __int8)v43 & 7 )
              {
                sprintf_s(
                  &v72,
                  0x200u,
                  "%s(%u): Assertion failed: \"%s\"\n",
                  "crn_mem.cpp",
                  216,
                  "crnlib_free: bad ptr");
                OutputDebugStringA(&v72);
                v46 = _iob_func();
                fputs(&v72, v46 + 2);
                if ( IsDebuggerPresent() )
                  DebugBreak();
              }
              else
              {
                off_100AD9F4(v43, 0, 0, 1, dword_100AE9F4);
              }
              *(_DWORD *)(v27 + 20) = 0;
            }
            *(_DWORD *)(v27 + 16) = v24;
            *(_DWORD *)v27 = *(_DWORD *)v24;
            v47 = *(_DWORD *)(v24 + 4);
            *(_DWORD *)(v27 + 24) = 0;
            *(_DWORD *)(v27 + 4) = v47;
            if ( (*(_DWORD *)(v24 + 16) >> 4) & 1 )
              *(_DWORD *)(v27 + 12) = ((*(_DWORD *)(v24 + 16) >> 3) & 1) != 0 ? 1098414156 : 2021161036;
            else
              *(_DWORD *)(v27 + 12) = ((*(_DWORD *)(v24 + 16) >> 3) & 1) != 0 ? 1094862674 : 2017609554;
            v48 = v62;
            *(_DWORD *)(v27 + 8) = *(_DWORD *)(v24 + 16);
            v49 = *((_DWORD *)v62 + 1);
            if ( v49 >= *((_DWORD *)v62 + 2) )
            {
              sub_100943C0(v49 + 1, 0, (int)v62, 1, 4u, 0);
              v48 = v62;
            }
            *(_DWORD *)(*v48 + 4 * v48[1]++) = v27;
            v23 += 36;
            ++v65;
          }
          while ( (unsigned int)v65 < *(_DWORD *)(a1 + 20) );
          v22 = (int **)v67;
        }
        v62 = (char *)v62 + 12;
        v64 += 576;
        ++v70;
      }
      while ( v70 < *(_DWORD *)(a1 + 8) );
    }
    v50 = v68;
    if ( v68 )
    {
      sub_10087040(a2);
      v51 = **v22;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)v51;
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(v51 + 4);
      *(_DWORD *)(a2 + 16) = *(_DWORD *)(v51 + 8);
      v52 = v69;
      *(_DWORD *)(a2 + 20) = *(_DWORD *)(v51 + 12);
      v53 = *(void **)(a2 + 24);
      *(_DWORD *)(a2 + 24) = v22;
      v67 = v53;
      v54 = *(_DWORD *)(a2 + 28);
      v22 = (int **)v67;
      *(_DWORD *)(a2 + 28) = v50;
      v50 = v54;
      *(_DWORD *)(a2 + 32) = v52;
    }
    LOBYTE(v81) = 0;
    if ( v22 )
    {
      v55 = (int)&v22[3 * v50];
      v56 = (int *)v22;
      if ( v22 != (int **)v55 )
      {
        do
        {
          v57 = *v56;
          if ( *v56 )
          {
            if ( v57 & 7 )
            {
              sprintf_s(
                &DstBuf,
                0x200u,
                "%s(%u): Assertion failed: \"%s\"\n",
                "crn_mem.cpp",
                216,
                "crnlib_free: bad ptr");
              OutputDebugStringA(&DstBuf);
              v58 = _iob_func();
              fputs(&DstBuf, v58 + 2);
              if ( IsDebuggerPresent() )
                DebugBreak();
            }
            else
            {
              off_100AD9F4(v57, 0, 0, 1, dword_100AE9F4);
            }
          }
          v56 += 3;
        }
        while ( v56 != (int *)v55 );
      }
      if ( (unsigned __int8)v22 & 7 )
      {
        sprintf_s(&v72, 0x200u, "%s(%u): Assertion failed: \"%s\"\n", "crn_mem.cpp", 216, "crnlib_free: bad ptr");
        OutputDebugStringA(&v72);
        v59 = _iob_func();
        fputs(&v72, v59 + 2);
        if ( IsDebuggerPresent() )
          DebugBreak();
      }
      else
      {
        off_100AD9F4(v22, 0, 0, 1, dword_100AE9F4);
      }
    }
    v81 = -1;
    `eh vector destructor iterator'(&v77, 0x24u, 96, sub_100336C0);
    result = 1;
  }
  return result;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10094EB0) --------------------------------------------------------
int __cdecl sub_10094EB0(int a1)
{
  int v1; // eax@2
  int v3; // eax@5

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = sub_10092A80(3420);
      if ( v3 )
        return sub_10071220(v3);
    }
  }
  else
  {
    v1 = sub_10092A80(5304);
    if ( v1 )
      return sub_10075AA0(v1);
  }
  return 0;
}

//----- (10094F40) --------------------------------------------------------
char __cdecl sub_10094F40(int a1, int a2, _DWORD *a3, float *a4)
{
  int v4; // eax@11
  int v5; // ebx@11
  char result; // al@14
  double v7; // st7@17
  unsigned int v8; // ecx@17
  double v9; // st6@17
  double v10; // rt1@22
  double v11; // st6@22
  double v12; // st7@22
  int v13; // edi@22
  int v14; // esi@26
  int v15; // ecx@28
  bool v16; // c0@30
  bool v17; // c3@30
  float *v18; // edx@31
  float v19; // ST38_4@32
  float v20; // ST38_4@32
  int v21; // ecx@33
  bool v22; // c0@36
  bool v23; // c3@36
  bool v24; // c0@37
  bool v25; // c3@37
  float *v26; // ecx@37
  double v27; // st7@41
  int v28; // eax@41
  signed __int64 v29; // st7@45
  double v30; // st7@47
  double v31; // st6@48
  double v32; // st5@50
  double v33; // st7@50
  double v34; // st5@51
  double v35; // st7@51
  float v36; // ST28_4@53
  float v37; // ST28_4@53
  double v38; // st4@53
  float v39; // ST28_4@53
  float v40; // ST28_4@53
  int v41; // eax@55
  int v42; // ecx@55
  int v43; // ecx@55
  int v44; // ecx@55
  bool v45; // zf@55
  float v46; // ST28_4@58
  float v47; // ST28_4@58
  double v48; // rt0@60
  double v49; // rt1@61
  double v50; // st5@61
  float v51; // ST28_4@70
  float v52; // ST28_4@70
  int v53; // ecx@81
  int v54; // eax@87
  int v55; // eax@99
  int v56; // ecx@99
  int v57; // ecx@99
  int v58; // ecx@99
  float v59; // [sp+28h] [bp-614h]@38
  char v60; // [sp+2Fh] [bp-60Dh]@22
  int v61; // [sp+30h] [bp-60Ch]@22
  float v62; // [sp+34h] [bp-608h]@21
  float v63; // [sp+38h] [bp-604h]@38
  float v64; // [sp+3Ch] [bp-600h]@44
  float v65; // [sp+40h] [bp-5FCh]@22
  float v66; // [sp+44h] [bp-5F8h]@22
  char v67[4]; // [sp+48h] [bp-5F4h]@21
  int v68; // [sp+4Ch] [bp-5F0h]@22
  char v69; // [sp+50h] [bp-5ECh]@1
  int v70; // [sp+54h] [bp-5E8h]@11
  int v71; // [sp+68h] [bp-5D4h]@1
  int v72; // [sp+6Ch] [bp-5D0h]@3
  float v73; // [sp+1F0h] [bp-44Ch]@17
  char ArgList[4]; // [sp+1F4h] [bp-448h]@17
  float v75; // [sp+234h] [bp-408h]@30
  float v76; // [sp+238h] [bp-404h]@22
  float v77[256]; // [sp+23Ch] [bp-400h]@36

  qmemcpy(&v69, (const void *)a1, 0x1E4u);
  if ( v71 >= 3 && v71 <= 9 && v72 & 1 )
  {
    sub_10094380("Output pixel format is swizzled or not RGB, disabling perceptual color metrics");
    v72 &= 0xFFFFFFFE;
  }
  if ( a3 )
    *a3 = 0;
  if ( a4 )
    *a4 = 0.0;
  if ( *(_DWORD *)(a2 + 4) )
    *(_DWORD *)(a2 + 4) = 0;
  v4 = sub_10094EB0(v70);
  v5 = v4;
  if ( !v4 )
    return 0;
  if ( !(unsigned __int8)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v4 + 8))(v4, &v69) )
  {
    (**(void (__thiscall ***)(_DWORD, _DWORD))v5)(v5, 0);
    if ( v5 & 7 )
    {
LABEL_14:
      sub_100927E0((int)"crnlib_free: bad ptr");
      return 0;
    }
    off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
    return 0;
  }
  v7 = 0.0;
  v8 = *(_DWORD *)ArgList;
  v9 = v73;
  if ( v73 <= 0.0 || v71 == 1 )
  {
    v54 = v70;
    if ( v70 && (v70 != 1 || *(_DWORD *)ArgList >= 0xFFu) )
    {
LABEL_91:
      if ( v71 == 1 )
      {
        if ( v54 )
        {
          if ( v54 == 1 && v8 < 0xFF )
            sub_10094340("Clustered DDS compressor doesn't support DXT3");
        }
        else
        {
          sub_10094340("CRN format doesn't support DXT3");
        }
      }
      if ( (unsigned __int8)(*(int (__thiscall **)(int, char *, float *))(*(_DWORD *)v5 + 12))(v5, &v69, a4) )
      {
        v55 = (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 20))(v5);
        v56 = *(_DWORD *)a2;
        *(_DWORD *)a2 = *(_DWORD *)v55;
        *(_DWORD *)v55 = v56;
        v57 = *(_DWORD *)(a2 + 4);
        *(_DWORD *)(a2 + 4) = *(_DWORD *)(v55 + 4);
        *(_DWORD *)(v55 + 4) = v57;
        v58 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a2 + 8) = *(_DWORD *)(v55 + 8);
        *(_DWORD *)(v55 + 8) = v58;
        if ( a3 && v73 <= 0.0 )
          *a3 = *(_DWORD *)ArgList;
        sub_100337A0((void (__thiscall ***)(_DWORD, _DWORD))v5);
        result = 1;
      }
      else
      {
LABEL_98:
        sub_100337A0((void (__thiscall ***)(_DWORD, _DWORD))v5);
        result = 0;
      }
      return result;
    }
LABEL_90:
    sub_10094380("Compressing using quality level %i", *(_DWORD *)ArgList);
    v8 = *(_DWORD *)ArgList;
    v54 = v70;
    goto LABEL_91;
  }
  if ( !v70 && v72 & 0x40 )
    goto LABEL_90;
  *(_DWORD *)v67 = -1;
  v62 = 1.0e10;
  while ( 2 )
  {
    v10 = v9;
    v11 = v7;
    v12 = v10;
    v66 = v11;
    memset32(&v76, -1082130432, 0x100u);
    v68 = 0;
    v61 = 255;
    v65 = 0.0;
    v60 = 0;
    v13 = 0;
    while ( 1 )
    {
      if ( *(_DWORD *)(a1 + 28) & 0x80000000 )
      {
        sub_10094360("Quality level bracket: [%u, %u]", v13, v61);
        v12 = v73;
        v11 = 0.0;
      }
      v14 = (v13 + v61) / 2;
      if ( v65 != 0.0 && !v60 )
      {
        v15 = (v13 + v61) / 2;
        if ( v11 > *(&v76 + v14) )
        {
          do
          {
            if ( v15 <= 0 )
              break;
            v16 = v11 < *(&v75 + v15);
            v17 = v11 == *(&v75 + v15--);
          }
          while ( !v16 && !v17 );
        }
        v18 = &v76 + v15;
        if ( v11 <= *(&v76 + v15) )
        {
          v21 = v14 + 1;
          if ( v14 + 1 <= 255 )
          {
            if ( v11 > *(&v76 + v21) )
            {
              do
              {
                if ( v21 >= 255 )
                  break;
                v22 = v11 < v77[v21];
                v23 = v11 == v77[v21++];
              }
              while ( !v22 && !v23 );
            }
            v24 = v11 < *(&v76 + v21);
            v25 = v11 == *(&v76 + v21);
            v26 = &v76 + v21;
            if ( v24 || v25 )
            {
              v63 = *v18;
              v59 = *v26;
              if ( v59 > (double)v63 && v63 < v12 && v59 >= v12 )
              {
                v27 = (v12 - v63) * (double)(v61 - v13) / (v59 - v63);
                v28 = v13 + (signed int)v27;
                if ( v28 >= v13 && v28 <= v61 )
                  v14 = v13 + (signed int)v27;
              }
            }
          }
        }
        else
        {
          v19 = (double)v68;
          v20 = v19 + ((double)v61 - v19) * 0.3300000131130219;
          v14 = (signed int)v20;
        }
      }
      sub_10094380("Compressing to quality level %u", v14);
      v64 = 0.0;
      *(_DWORD *)ArgList = v14;
      if ( !(unsigned __int8)(*(int (__thiscall **)(int, char *, float *))(*(_DWORD *)v5 + 12))(v5, &v69, &v64) )
      {
        (**(void (__thiscall ***)(_DWORD, _DWORD))v5)(v5, 0);
        if ( v5 & 7 )
          goto LABEL_14;
        off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
        return 0;
      }
      *(double *)&v29 = v64;
      *(&v76 + v14) = v64;
      if ( v66 <= *(double *)&v29 )
        v66 = *(double *)&v29;
      sub_10094380("\nTried quality level %u, bpp: %3.3f", v14, (_DWORD)v29, (_DWORD)((unsigned __int64)v29 >> 32));
      v30 = v64;
      if ( *(_DWORD *)v67 < 0 )
        break;
      v31 = v73;
      if ( v73 >= v30 && v62 > v31 )
        break;
      v32 = v64;
      v33 = v62;
      if ( v64 > v31 )
      {
        v34 = v62;
        v35 = v64;
        if ( v62 <= v31 )
          goto LABEL_61;
        v32 = v64;
        v33 = v62;
      }
      v36 = v32 - v31;
      v37 = fabs(v36);
      v38 = v37;
      v39 = v33 - v31;
      v40 = fabs(v39);
      if ( v40 > v38 )
      {
        v30 = v32;
        break;
      }
LABEL_60:
      v48 = v32;
      v34 = v33;
      v35 = v48;
LABEL_61:
      v49 = v34;
      v50 = v35;
      v33 = v49;
      if ( v50 <= v31 )
      {
        v13 = v14 + 1;
        v68 = v14 + 1;
      }
      else
      {
        v61 = v14 - 1;
      }
      if ( ++LODWORD(v65) > 8u )
        v60 = 1;
      if ( v13 > v61 )
        goto LABEL_68;
      v12 = v31;
      v11 = 0.0;
    }
    v62 = v30;
    v41 = (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 20))(v5);
    v42 = *(_DWORD *)a2;
    *(_DWORD *)a2 = *(_DWORD *)v41;
    *(_DWORD *)v41 = v42;
    v43 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v41 + 4);
    *(_DWORD *)(v41 + 4) = v43;
    v44 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(v41 + 8);
    *(_DWORD *)(v41 + 8) = v44;
    v45 = (*(_DWORD *)(a1 + 28) & 0x80000000) == 0;
    *(_DWORD *)v67 = v14;
    if ( !v45 )
      sub_10094360("Choose new best quality level");
    v33 = v62;
    v31 = v73;
    if ( v73 < (double)v62 || (v46 = v33 - v31, v47 = fabs(v46), v47 >= 0.0049999999) )
    {
      v32 = v64;
      goto LABEL_60;
    }
LABEL_68:
    if ( v72 & 2 )
    {
      if ( v66 < v31 )
      {
        v51 = v33 - v31;
        v52 = fabs(v51);
        if ( v52 >= 0.0049999999 )
        {
          sub_10094380("Unable to achieve desired bitrate - disabling adaptive block sizes and retrying search.");
          v72 &= 0xFFFFFFFD;
          (**(void (__thiscall ***)(_DWORD, _DWORD))v5)(v5, 0);
          if ( v5 & 7 )
            sub_100927E0((int)"crnlib_free: bad ptr");
          else
            off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
          v5 = sub_10094EB0(v70);
          if ( (unsigned __int8)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v5 + 8))(v5, &v69) )
          {
            v9 = v73;
            v7 = 0.0;
            continue;
          }
          goto LABEL_98;
        }
      }
    }
    break;
  }
  (**(void (__thiscall ***)(_DWORD, _DWORD))v5)(v5, 0);
  if ( v5 & 7 )
    sub_100927E0((int)"crnlib_free: bad ptr");
  else
    off_100AD9F4(v5, 0, 0, 1, dword_100AE9F4);
  v53 = *(_DWORD *)v67;
  if ( *(_DWORD *)v67 < 0 )
    return 0;
  if ( a3 )
    *a3 = *(_DWORD *)v67;
  if ( a4 )
    *a4 = v62;
  sub_100943A0("Selected quality level %u bpp: %f", v53, v62);
  return 1;
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 10094F40: using guessed type float var_400[256];

//----- (10095650) --------------------------------------------------------
char __usercall sub_10095650@<al>(int a1@<eax>, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@1
  int v5; // eax@2
  int v6; // edi@9
  int v7; // ebx@9
  int v8; // eax@9
  int v9; // ebp@9
  int v10; // ebx@13
  int v11; // eax@14
  signed int v12; // edi@14
  int v13; // ebp@14
  int v14; // ecx@15
  unsigned int v15; // edi@21
  int v16; // ST04_4@21
  int v17; // ecx@28
  bool v18; // al@33
  __int64 v19; // rax@41
  int v20; // ebx@41
  __int64 v21; // rax@43
  int v22; // ebx@43
  int v23; // ebx@43
  bool v24; // sf@43
  unsigned __int8 v25; // of@43
  signed int v26; // eax@48
  int v27; // ecx@49
  const char *v28; // ecx@68
  bool v29; // zf@74
  bool v30; // al@74
  bool v31; // dl@76
  const char *v33; // eax@79
  bool v34; // cl@79
  bool v35; // dl@79
  bool v36; // cl@79
  int v37; // edx@79
  int v38; // ecx@79
  int v39; // edi@79
  double v40; // st7@83
  char v41; // [sp+1Bh] [bp-51h]@1
  int v42; // [sp+1Ch] [bp-50h]@14
  int v43; // [sp+20h] [bp-4Ch]@14
  int v44; // [sp+24h] [bp-48h]@41
  __int64 v45; // [sp+28h] [bp-44h]@9
  LARGE_INTEGER PerformanceCount; // [sp+30h] [bp-3Ch]@74
  float v47; // [sp+38h] [bp-34h]@76
  float v48; // [sp+3Ch] [bp-30h]@76
  char v49; // [sp+40h] [bp-2Ch]@76
  const char *v50; // [sp+4Ch] [bp-20h]@79
  bool v51; // [sp+50h] [bp-1Ch]@79
  bool v52; // [sp+51h] [bp-1Bh]@79
  bool v53; // [sp+52h] [bp-1Ah]@79
  float v54; // [sp+54h] [bp-18h]@79
  float v55; // [sp+58h] [bp-14h]@79
  bool v56; // [sp+5Ch] [bp-10h]@79
  int v57; // [sp+60h] [bp-Ch]@79
  int v58; // [sp+64h] [bp-8h]@79

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 4);
  v41 = 0;
  if ( !v4 )
  {
    if ( !*(_DWORD *)(a2 + 28) || *(_DWORD *)(*(_DWORD *)(a2 + 24) + 4) != 1 )
      goto LABEL_9;
LABEL_8:
    v41 = 1;
    goto LABEL_9;
  }
  v5 = v4 - 2;
  if ( !v5 )
    goto LABEL_8;
  if ( v5 == 1 && *(_DWORD *)(a2 + 28) )
    sub_10086E20(a2);
LABEL_9:
  v6 = *(_DWORD *)(v3 + 60);
  v7 = *(_DWORD *)(v3 + 52);
  v8 = *(_DWORD *)(v3 + 56);
  v9 = *(_DWORD *)(v3 + 64);
  LODWORD(v45) = *(_DWORD *)(v3 + 56);
  if ( v6 <= v7 || v9 <= v8 )
    goto LABEL_13;
  if ( *(_DWORD *)(a2 + 28) > 1u )
  {
    sub_10094340("Can't crop cubemap textures");
LABEL_13:
    v10 = a2;
    goto LABEL_14;
  }
  sub_10094380("Cropping input texture from window (%ux%u)-(%ux%u)", v7, v8, v6, v9);
  v15 = v6 - v7;
  v16 = v7;
  v10 = a2;
  if ( !sub_10088740(a2, v16, v45, v15, (char *)(v9 - v45)) )
    sub_10094340("Failed cropping window rect");
LABEL_14:
  v11 = *(_DWORD *)(v3 + 72);
  v12 = *(_DWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 12);
  v42 = *(_DWORD *)(v10 + 8);
  v43 = v13;
  if ( v11 )
  {
    v14 = *(_DWORD *)(v3 + 76);
    if ( v14 )
    {
      if ( (v12 > v11 || v13 > v14) && !*(_DWORD *)(v3 + 68) )
      {
        if ( *(_DWORD *)(v10 + 28) <= 1u )
        {
          if ( v11 < (unsigned int)v12 )
          {
            v12 = v11;
            v42 = v11;
          }
          if ( v14 < (unsigned int)v13 )
          {
            v13 = v14;
            v43 = v14;
          }
          sub_10094380("Clamping input texture to %ux%u", v12, v13);
          sub_10088740(v10, 0, 0, v12, (char *)v13);
        }
        else
        {
          sub_10094340("Can't crop cubemap textures");
        }
      }
    }
  }
  v17 = *(_DWORD *)(v3 + 40);
  if ( v17 )
  {
    v18 = v12 && !((v12 - 1) & v12) && v13 && !((v13 - 1) & v13);
    switch ( v17 )
    {
      case 1:
        v45 = (signed __int64)*(float *)(v3 + 44);
        v12 = v45;
        v45 = (signed __int64)*(float *)(v3 + 48);
        v13 = v45;
        break;
      case 2:
        v45 = (signed __int64)(*(float *)(v3 + 44) * (double)v42 + 0.5);
        v12 = v45;
        v45 = (signed __int64)(*(float *)(v3 + 48) * (double)v43 + 0.5);
        v13 = v45;
        break;
      case 3:
        if ( !v18 )
        {
          sub_1007AA80(&v42, &v43);
          goto LABEL_47;
        }
        break;
      case 4:
        if ( !v18 )
        {
          v42 = v12;
          LODWORD(v45) = v13;
          sub_1007AA80(&v42, (int *)&v45);
          v43 = v12;
          v44 = v13;
          sub_1007AAD0(&v43, (unsigned int *)&v44);
          v19 = v12 - v43;
          v20 = HIDWORD(v19) ^ (v12 - v43);
          LODWORD(v19) = v12;
          v12 = v42;
          if ( abs(v19 - v42) >= v20 - HIDWORD(v19) )
            v12 = v43;
          v21 = v13 - v44;
          v22 = HIDWORD(v21) ^ (v13 - v44);
          LODWORD(v21) = v13;
          v13 = v45;
          v23 = v22 - HIDWORD(v21);
          LODWORD(v21) = abs(v21 - v45);
          v25 = __OFSUB__((_DWORD)v21, v23);
          v24 = (signed int)v21 - v23 < 0;
          v10 = a2;
          if ( !(v24 ^ v25) )
            v13 = v44;
        }
        break;
      case 5:
        if ( !v18 )
        {
          sub_1007AAD0(&v42, (unsigned int *)&v43);
LABEL_47:
          v13 = v43;
          v12 = v42;
        }
        break;
      default:
        break;
    }
  }
  v26 = *(_DWORD *)(v3 + 72);
  if ( v26 )
  {
    v27 = *(_DWORD *)(v3 + 76);
    if ( v27 )
    {
      if ( v12 > v26 || v13 > v27 )
      {
        if ( *(_DWORD *)(v3 + 68) )
        {
          if ( v26 < (unsigned int)v12 )
            v12 = *(_DWORD *)(v3 + 72);
          if ( v27 < (unsigned int)v13 )
            v13 = *(_DWORD *)(v3 + 76);
        }
      }
    }
  }
  if ( v12 >= 1 )
  {
    if ( v12 > 4096 )
      v12 = 4096;
  }
  else
  {
    v12 = 1;
  }
  if ( v13 >= 1 )
  {
    if ( v13 > 4096 )
      v13 = 4096;
  }
  else
  {
    v13 = 1;
  }
  if ( v12 != *(_DWORD *)(v10 + 8) || v13 != *(_DWORD *)(v10 + 12) )
  {
    sub_10094380("Resampling input texture to %ux%u", v12, v13);
    switch ( *(_DWORD *)(v3 + 8) )
    {
      case 0:
        v28 = (const char *)&unk_1009FB54;
        break;
      case 1:
        v28 = "tent";
        break;
      case 2:
        v28 = "lanczos4";
        break;
      case 3:
        v28 = "mitchell";
        break;
      case 4:
        v28 = "kaiser";
        break;
      default:
        v28 = "?";
        break;
    }
    v29 = *(_DWORD *)(v3 + 12) == 0;
    PerformanceCount.s.LowPart = (DWORD)v28;
    v30 = !v29;
    v29 = *(_DWORD *)(v10 + 28) == 0;
    BYTE4(PerformanceCount.QuadPart) = *(_DWORD *)(v3 + 36) != 0;
    if ( !v29 )
      BYTE4(PerformanceCount.QuadPart) = 0;
    v29 = *(_DWORD *)(v3 + 32) == 0;
    BYTE5(PerformanceCount.QuadPart) = v30;
    v47 = 1.0;
    v31 = !v29;
    v48 = *(float *)(v3 + 16);
    v29 = *(_DWORD *)(a3 + 464) == 0;
    BYTE6(PerformanceCount.QuadPart) = v31;
    v49 = !v29;
    if ( !sub_10089610(a3, v10, v12, v13, (int)&PerformanceCount) )
    {
      sub_10094320("Failed resizing texture!");
      return 0;
    }
  }
  if ( v41 )
  {
    v33 = sub_10092B10(*(_DWORD *)(v3 + 8));
    v29 = *(_DWORD *)(v3 + 36) == 0;
    v54 = *(float *)(v3 + 20);
    v34 = !v29;
    v55 = *(float *)(v3 + 16);
    v29 = *(_DWORD *)(v3 + 32) == 0;
    v51 = v34;
    v35 = !v29;
    v29 = *(_DWORD *)(v3 + 12) == 0;
    v53 = v35;
    v36 = !v29;
    v29 = *(_DWORD *)(a3 + 464) == 0;
    v37 = *(_DWORD *)(v3 + 24);
    v52 = v36;
    v56 = !v29;
    v38 = *(_DWORD *)(v3 + 28);
    v50 = v33;
    v58 = v37;
    v57 = v38;
    sub_10094380("Generating mipmaps using filter \"%s\"", v33);
    v49 &= 0xFCu;
    v39 = 0;
    PerformanceCount.QuadPart = 0i64;
    v47 = 0.0;
    v48 = 0.0;
    if ( 0.0 == dbl_100BF5B8 )
      sub_10093750();
    QueryPerformanceCounter(&PerformanceCount);
    v49 = v49 & 0xFD | 1;
    if ( !sub_10088920(v10, (int)&v50) )
    {
      sub_10094320("Failed generating mipmaps!");
      return 0;
    }
    v40 = sub_100937C0((int)&PerformanceCount);
    if ( *(_DWORD *)(v10 + 28) )
      v39 = *(_DWORD *)(*(_DWORD *)(v10 + 24) + 4);
    sub_10094380(
      "Generated %u mipmap levels in %3.3fs",
      v39 - 1,
      LODWORD(v40),
      (_DWORD)(*(unsigned __int64 *)&v40 >> 32));
  }
  return 1;
}
// 100BF5B8: using guessed type double dbl_100BF5B8;

//----- (10095B80) --------------------------------------------------------
char __usercall sub_10095B80@<al>(int a1@<eax>, int a2@<ecx>, int a3, int a4, _DWORD *a5, float *a6)
{
  int v6; // eax@1
  const void *v7; // esi@1
  int v8; // eax@3
  char result; // al@10
  unsigned int v10; // ebx@13
  int v11; // edi@13
  int v12; // eax@14
  int v13; // edx@17
  _DWORD *v14; // ecx@17
  unsigned int v15; // esi@17
  unsigned int i; // eax@18
  char v17; // bl@23
  int v18; // [sp+0h] [bp-228h]@9
  int v19; // [sp+4h] [bp-224h]@9
  int v20; // [sp+8h] [bp-220h]@9
  int v21; // [sp+Ch] [bp-21Ch]@9
  int v22; // [sp+10h] [bp-218h]@9
  int v23; // [sp+14h] [bp-214h]@9
  int v24; // [sp+18h] [bp-210h]@9
  unsigned int v25; // [sp+1Ch] [bp-20Ch]@9
  int v26; // [sp+20h] [bp-208h]@9
  int v27; // [sp+24h] [bp-204h]@9
  int v28; // [sp+28h] [bp-200h]@9
  int v29; // [sp+2Ch] [bp-1FCh]@9
  char v30; // [sp+30h] [bp-1F8h]@13
  int v31; // [sp+44h] [bp-1E4h]@16
  int v32[115]; // [sp+50h] [bp-1D8h]@16
  int v33; // [sp+21Ch] [bp-Ch]@1
  int (__thiscall *v34)(void *); // [sp+220h] [bp-8h]@1
  int v35; // [sp+224h] [bp-4h]@1

  v35 = -1;
  v34 = sub_1009725A;
  v33 = a1;
  v6 = *(_DWORD *)(a4 + 4);
  v7 = (const void *)a2;
  if ( v6 )
  {
    if ( !v6 )
      v8 = *(_DWORD *)a4;
    *(_DWORD *)(a4 + 4) = 0;
  }
  if ( a6 )
    *a6 = 0.0;
  if ( a5 )
    *a5 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 15;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = -1;
  v28 = 0;
  v29 = 0;
  v35 = 0;
  if ( sub_10094540(a2, (int)&v18) )
  {
    if ( sub_10095650(a3, (int)&v18, (int)v7) )
    {
      v10 = v25;
      qmemcpy(&v30, v7, 0x1E4u);
      v11 = v24;
      if ( v25 )
        v12 = *(_DWORD *)(v24 + 4);
      else
        v12 = 0;
      v31 = v12;
      memset(v32, 0, 0x180u);
      if ( v25 > 0 )
      {
        v13 = 0;
        v14 = (_DWORD *)v24;
        v15 = v25;
        do
        {
          for ( i = 0; v10 && i < *(_DWORD *)(v11 + 4); ++i )
          {
            v32[v13 + i] = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*v14 + 4 * i) + 16) + 20);
            v10 = v25;
          }
          v14 += 3;
          v13 += 16;
          --v15;
        }
        while ( v15 );
      }
      v17 = sub_10094F40((int)&v30, a4, a5, a6);
      v35 = -1;
      sub_10087290((int)&v18);
      result = v17;
    }
    else
    {
      v35 = -1;
      sub_10087290((int)&v18);
      result = 0;
    }
  }
  else
  {
    sub_10094320("Failed creating DDS texture from crn_comp_params!");
    v35 = -1;
    sub_10087290((int)&v18);
    result = 0;
  }
  return result;
}
// 10095B80: using guessed type int var_1D8[115];

//----- (1009603F) --------------------------------------------------------
int sub_1009603F()
{
  dword_100C17B4 = IsProcessorFeaturePresent(0xAu);
  return 0;
}
// 100C17B4: using guessed type int dword_100C17B4;

//----- (10096050) --------------------------------------------------------
void __usercall sub_10096050(int a1@<ebp>)
{
  sub_1003F520(*(_DWORD *)(a1 + 4) + 16);
}

//----- (1009605D) --------------------------------------------------------
void __usercall sub_1009605D(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 44));
}

//----- (10096068) --------------------------------------------------------
void __usercall sub_10096068(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 56));
}

//----- (10096073) --------------------------------------------------------
void __usercall sub_10096073(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 76));
}

//----- (1009607E) --------------------------------------------------------
void __usercall sub_1009607E(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 100));
}

//----- (10096089) --------------------------------------------------------
void __usercall sub_10096089(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 140));
}

//----- (10096096) --------------------------------------------------------
void __usercall sub_10096096(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 152));
}

//----- (100960A4) --------------------------------------------------------
void __usercall sub_100960A4(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 164));
}

//----- (100960B1) --------------------------------------------------------
void __usercall sub_100960B1(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 176));
}

//----- (100960BE) --------------------------------------------------------
void __usercall sub_100960BE(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 208));
}

//----- (100960CB) --------------------------------------------------------
void __usercall sub_100960CB(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 220));
}

//----- (100960D8) --------------------------------------------------------
void __usercall sub_100960D8(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10032CF0);
}

//----- (100960E5) --------------------------------------------------------
void __usercall sub_100960E5(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10032CF0);
}

//----- (100960F2) --------------------------------------------------------
int __thiscall SEH_100328F0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096130) --------------------------------------------------------
void __usercall sub_10096130(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 + 8);
  JUMPOUT(&loc_10014DE0);
}

//----- (10096138) --------------------------------------------------------
int __cdecl sub_10096138(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 12));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096160) --------------------------------------------------------
int __cdecl sub_10096160(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 24));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096180) --------------------------------------------------------
void __usercall sub_10096180(int a1@<ebp>)
{
  **(_DWORD **)(a1 - 16) = &off_100A1D64;
}
// 100A1D64: using guessed type void *off_100A1D64;

//----- (10096188) --------------------------------------------------------
int __cdecl sub_10096188(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 12));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100961B0) --------------------------------------------------------
int __cdecl sub_100961B0(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 24));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100961D0) --------------------------------------------------------
int __cdecl sub_100961D0(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 24));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100961F0) --------------------------------------------------------
int __cdecl sub_100961F0(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 24));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096210) --------------------------------------------------------
int __cdecl sub_10096210(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 24));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096230) --------------------------------------------------------
void __usercall sub_10096230(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 8));
}

//----- (1009623B) --------------------------------------------------------
int __thiscall SEH_1004E640(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096250) --------------------------------------------------------
void __usercall sub_10096250(int a1@<ebp>)
{
  operator delete(*(void **)(*(_DWORD *)(a1 + 4) + 4));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10096258) --------------------------------------------------------
int __thiscall SEH_100415E0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096270) --------------------------------------------------------
void __usercall sub_10096270(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 20));
}

//----- (1009627B) --------------------------------------------------------
int __thiscall SEH_10093050(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096285) --------------------------------------------------------
void __usercall sub_10096285(int a1@<ebp>)
{
  sub_10037D80(*(int **)(a1 + 4));
}

//----- (1009628D) --------------------------------------------------------
int __thiscall sub_1009628D(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096297) --------------------------------------------------------
void __usercall sub_10096297(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 624));
}

//----- (100962A2) --------------------------------------------------------
int __thiscall SEH_100593B0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100962AC) --------------------------------------------------------
void __usercall sub_100962AC(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 40));
}

//----- (100962B7) --------------------------------------------------------
void __usercall sub_100962B7(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 52));
}

//----- (100962C2) --------------------------------------------------------
void __usercall sub_100962C2(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 64));
}

//----- (100962CD) --------------------------------------------------------
int __thiscall sub_100962CD(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100962D7) --------------------------------------------------------
void __usercall sub_100962D7(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 - 16) + 4));
}

//----- (100962E2) --------------------------------------------------------
void __usercall sub_100962E2(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 - 16) + 16));
}

//----- (100962ED) --------------------------------------------------------
int __thiscall SEH_1005C5A0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100962F7) --------------------------------------------------------
LONG __usercall sub_100962F7@<eax>(int a1@<ebp>)
{
  return InterlockedExchange(*(LPLONG *)(a1 - 124), 0);
}

//----- (100962FF) --------------------------------------------------------
void sub_100962FF()
{
  JUMPOUT(&loc_10036D70);
}

//----- (10096307) --------------------------------------------------------
int __thiscall SEH_1005DFC0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096311) --------------------------------------------------------
void __usercall sub_10096311(int a1@<ebp>)
{
  sub_1003F520(*(_DWORD *)(a1 + 4) + 16);
}

//----- (1009631E) --------------------------------------------------------
void __usercall sub_1009631E(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 44));
}

//----- (10096329) --------------------------------------------------------
void __usercall sub_10096329(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 56));
}

//----- (10096334) --------------------------------------------------------
void __usercall sub_10096334(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 76));
}

//----- (1009633F) --------------------------------------------------------
void __usercall sub_1009633F(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 100));
}

//----- (1009634A) --------------------------------------------------------
void __usercall sub_1009634A(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 140));
}

//----- (10096357) --------------------------------------------------------
void __usercall sub_10096357(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 152));
}

//----- (10096365) --------------------------------------------------------
void __usercall sub_10096365(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 164));
}

//----- (10096372) --------------------------------------------------------
void __usercall sub_10096372(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 176));
}

//----- (1009637F) --------------------------------------------------------
void __usercall sub_1009637F(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 208));
}

//----- (1009638C) --------------------------------------------------------
void __usercall sub_1009638C(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 220));
}

//----- (10096399) --------------------------------------------------------
void __usercall sub_10096399(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 244);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100963A6) --------------------------------------------------------
void __usercall sub_100963A6(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10032CF0);
}

//----- (100963B3) --------------------------------------------------------
void __usercall sub_100963B3(int a1@<ebp>)
{
  sub_1003F520(*(_DWORD *)(a1 + 4) + 304);
}

//----- (100963C2) --------------------------------------------------------
int __thiscall SEH_1007DB20(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100963CC) --------------------------------------------------------
HANDLE __usercall sub_100963CC@<eax>(int a1@<ebp>)
{
  HANDLE result; // eax@1
  HANDLE *v2; // esi@1

  v2 = (HANDLE *)(*(_DWORD *)(a1 + 4) + 72);
  result = *v2;
  if ( *v2 )
  {
    result = (HANDLE)CloseHandle(*v2);
    *v2 = 0;
  }
  return result;
}

//----- (100963D7) --------------------------------------------------------
void __usercall sub_100963D7(int a1@<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10091110);
}

//----- (100963E2) --------------------------------------------------------
int __thiscall SEH_100918E0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100963EC) --------------------------------------------------------
void __usercall sub_100963EC(int a1@<ebp>)
{
  int v1; // eax@1
  int v2; // ecx@2

  v1 = *(_DWORD *)(a1 - 24 + 4);
  if ( v1 )
  {
    v2 = v1 - 8;
    if ( *(_DWORD *)(v1 - 4) == ~*(_DWORD *)(v1 - 8) && v1 != 8 )
    {
      if ( v2 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100963F4) --------------------------------------------------------
int __thiscall sub_100963F4(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100963FE) --------------------------------------------------------
void __usercall sub_100963FE(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 1072));
}

//----- (10096409) --------------------------------------------------------
void __usercall sub_10096409(int a1@<ebp>)
{
  sub_1004E640(a1 - 1080);
}

//----- (10096416) --------------------------------------------------------
void __usercall sub_10096416(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 1124));
}

//----- (10096421) --------------------------------------------------------
void __usercall sub_10096421(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 1112));
}

//----- (1009642C) --------------------------------------------------------
void __usercall sub_1009642C(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1100));
}

//----- (10096437) --------------------------------------------------------
int __thiscall sub_10096437(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096441) --------------------------------------------------------
void __usercall sub_10096441(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 548));
}

//----- (1009644C) --------------------------------------------------------
int __thiscall SEH_1005C930(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096456) --------------------------------------------------------
void __usercall sub_10096456(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 192));
}

//----- (10096463) --------------------------------------------------------
int __usercall sub_10096463@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 + 4) + 212), 0xCu, 3, sub_10038C00);
}

//----- (1009647B) --------------------------------------------------------
void __usercall sub_1009647B(int a1@<ebp>)
{
  int *v1; // eax@2
  int **v2; // esi@1

  v2 = (int **)(*(_DWORD *)(a1 + 4) + 284);
  if ( *v2 )
  {
    sub_1004CE50(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 288), *v2);
    v1 = *v2;
    if ( *v2 )
    {
      if ( (unsigned __int8)v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10096489) --------------------------------------------------------
void __usercall sub_10096489(int a1@<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10041B90);
}

//----- (10096497) --------------------------------------------------------
void __usercall sub_10096497(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 308));
}

//----- (100964A4) --------------------------------------------------------
void __usercall sub_100964A4(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 320));
}

//----- (100964B1) --------------------------------------------------------
void __usercall sub_100964B1(int a1@<ebp>)
{
  sub_10041BD0(*(_DWORD *)(a1 + 4) + 332);
}

//----- (100964BF) --------------------------------------------------------
void __usercall sub_100964BF(int a1@<ebp>)
{
  sub_10041BD0(*(_DWORD *)(a1 + 4) + 344);
}

//----- (100964CD) --------------------------------------------------------
void __usercall sub_100964CD(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 356));
}

//----- (100964DB) --------------------------------------------------------
void __usercall sub_100964DB(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 368));
}

//----- (100964E9) --------------------------------------------------------
void __usercall sub_100964E9(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 380));
}

//----- (100964F6) --------------------------------------------------------
void __usercall sub_100964F6(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 392));
}

//----- (10096503) --------------------------------------------------------
void __usercall sub_10096503(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 404));
}

//----- (10096510) --------------------------------------------------------
void __usercall sub_10096510(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 416));
}

//----- (1009651D) --------------------------------------------------------
void __usercall sub_1009651D(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 428));
}

//----- (1009652A) --------------------------------------------------------
void __usercall sub_1009652A(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 440));
}

//----- (10096537) --------------------------------------------------------
void __usercall sub_10096537(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 452));
}

//----- (10096544) --------------------------------------------------------
void __usercall sub_10096544(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 464));
}

//----- (10096551) --------------------------------------------------------
void __usercall sub_10096551(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 476));
}

//----- (1009655E) --------------------------------------------------------
void __usercall sub_1009655E(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 488));
}

//----- (1009656B) --------------------------------------------------------
int __thiscall SEH_1005FC60(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096575) --------------------------------------------------------
void __usercall sub_10096575(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 192));
}

//----- (10096582) --------------------------------------------------------
int __thiscall SEH_10060150(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (1009658C) --------------------------------------------------------
int __usercall sub_1009658C@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 96), 0xCu, 2, sub_10038C00);
}

//----- (1009659F) --------------------------------------------------------
int __thiscall SEH_1006B380(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100965A9) --------------------------------------------------------
int __usercall sub_100965A9@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 40), 0xCu, 2, sub_10038C00);
}

//----- (100965BC) --------------------------------------------------------
int __thiscall SEH_1006E340(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100965C6) --------------------------------------------------------
void __usercall sub_100965C6(int a1@<ebp>)
{
  **(_DWORD **)(a1 - 16) = &off_100A4FF4;
}
// 100A4FF4: using guessed type int (__stdcall *off_100A4FF4)(char);

//----- (100965CE) --------------------------------------------------------
BOOL __usercall sub_100965CE@<eax>(int a1@<ebp>)
{
  return sub_100918E0(*(_DWORD *)(a1 - 16) + 4);
}

//----- (100965DB) --------------------------------------------------------
int __usercall sub_100965DB@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 - 16) + 100), 0x24u, 96, sub_100336C0);
}

//----- (100965F1) --------------------------------------------------------
void __usercall sub_100965F1(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 - 16) + 4068));
}

//----- (100965FE) --------------------------------------------------------
void __usercall sub_100965FE(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 - 16) + 4084));
}

//----- (1009660B) --------------------------------------------------------
int __usercall sub_1009660B@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 - 16) + 4096), 0xCu, 3, sub_10038C00);
}

//----- (10096623) --------------------------------------------------------
int __usercall sub_10096623@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 - 16) + 4132), 0xCu, 3, sub_10038C00);
}

//----- (1009663B) --------------------------------------------------------
void __usercall sub_1009663B(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 - 16) + 4172));
}

//----- (10096648) --------------------------------------------------------
void __usercall sub_10096648(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 - 16) + 4260));
}

//----- (10096656) --------------------------------------------------------
void __usercall sub_10096656(int a1@<ebp>)
{
  sub_1005FC60(*(_DWORD *)(a1 - 16) + 4272);
}

//----- (10096665) --------------------------------------------------------
void __usercall sub_10096665(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 - 16) + 4808));
}

//----- (10096673) --------------------------------------------------------
void __usercall sub_10096673(int a1@<ebp>)
{
  sub_1005C5A0((void *)(*(_DWORD *)(a1 - 16) + 4820));
}

//----- (10096681) --------------------------------------------------------
int __usercall sub_10096681@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 - 16) + 4856), 0xCu, 2, sub_10038C00);
}

//----- (10096699) --------------------------------------------------------
int __usercall sub_10096699@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 - 16) + 4880), 0x24u, 2, sub_1005C5A0);
}

//----- (100966B1) --------------------------------------------------------
int __usercall sub_100966B1@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 - 16) + 4952), 0xCu, 2, sub_10038C00);
}

//----- (100966C9) --------------------------------------------------------
int __usercall sub_100966C9@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 - 16) + 4976), 0x24u, 2, sub_1005C5A0);
}

//----- (100966E1) --------------------------------------------------------
int __usercall sub_100966E1@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 - 16) + 5048), 0xCu, 16, sub_10038C00);
}

//----- (100966F9) --------------------------------------------------------
void __usercall sub_100966F9(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 - 16) + 5240));
}

//----- (10096707) --------------------------------------------------------
void __usercall sub_10096707(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 - 16) + 5252));
}

//----- (10096715) --------------------------------------------------------
void __usercall sub_10096715(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 - 16) + 5264));
}

//----- (10096723) --------------------------------------------------------
void __usercall sub_10096723(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 - 16) + 5276));
}

//----- (10096731) --------------------------------------------------------
int __thiscall SEH_10075740(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (1009673B) --------------------------------------------------------
void __usercall sub_1009673B(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_100368B0);
}

//----- (10096743) --------------------------------------------------------
BOOL __usercall sub_10096743@<eax>(int a1@<ebp>)
{
  return sub_100918E0(*(_DWORD *)(a1 + 4) + 4);
}

//----- (10096750) --------------------------------------------------------
int __usercall sub_10096750@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 + 4) + 100), 0x24u, 96, sub_100336C0);
}

//----- (10096766) --------------------------------------------------------
void __usercall sub_10096766(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 4068));
}

//----- (10096773) --------------------------------------------------------
void __usercall sub_10096773(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 4084));
}

//----- (10096780) --------------------------------------------------------
int __usercall sub_10096780@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 + 4) + 4096), 0xCu, 3, sub_10038C00);
}

//----- (10096798) --------------------------------------------------------
int __usercall sub_10096798@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 + 4) + 4132), 0xCu, 3, sub_10038C00);
}

//----- (100967B0) --------------------------------------------------------
void __usercall sub_100967B0(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 4172));
}

//----- (100967BD) --------------------------------------------------------
void __usercall sub_100967BD(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 4260));
}

//----- (100967CB) --------------------------------------------------------
void __usercall sub_100967CB(int a1@<ebp>)
{
  sub_1005FC60(*(_DWORD *)(a1 + 4) + 4272);
}

//----- (100967DA) --------------------------------------------------------
void __usercall sub_100967DA(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 4808));
}

//----- (100967E8) --------------------------------------------------------
void __usercall sub_100967E8(int a1@<ebp>)
{
  sub_1005C5A0((void *)(*(_DWORD *)(a1 + 4) + 4820));
}

//----- (100967F6) --------------------------------------------------------
int __usercall sub_100967F6@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 + 4) + 4856), 0xCu, 2, sub_10038C00);
}

//----- (1009680E) --------------------------------------------------------
int __usercall sub_1009680E@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 + 4) + 4880), 0x24u, 2, sub_1005C5A0);
}

//----- (10096826) --------------------------------------------------------
int __usercall sub_10096826@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 + 4) + 4952), 0xCu, 2, sub_10038C00);
}

//----- (1009683E) --------------------------------------------------------
int __usercall sub_1009683E@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 + 4) + 4976), 0x24u, 2, sub_1005C5A0);
}

//----- (10096856) --------------------------------------------------------
int __thiscall SEH_10075AA0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096860) --------------------------------------------------------
BOOL __usercall sub_10096860@<eax>(int a1@<ebp>)
{
  return sub_100918E0(a1 - 9332);
}

//----- (1009686D) --------------------------------------------------------
void __usercall sub_1009686D(int a1@<ebp>)
{
  sub_10093050(a1 - 9424);
}

//----- (1009687A) --------------------------------------------------------
void __usercall sub_1009687A(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 9444));
}

//----- (10096885) --------------------------------------------------------
void __usercall sub_10096885(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 9456));
}

//----- (10096890) --------------------------------------------------------
int __thiscall SEH_1007B7A0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (1009689A) --------------------------------------------------------
int __usercall sub_1009689A@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 9284), 0xCu, 4, sub_10038C00);
}

//----- (100968B0) --------------------------------------------------------
int __thiscall SEH_1007BF30(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100968BA) --------------------------------------------------------
int sub_100968BA()
{
  return sub_1007C800();
}
// 1007C800: using guessed type int sub_1007C800(void);

//----- (100968C2) --------------------------------------------------------
int __thiscall SEH_1007C810(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100968CC) --------------------------------------------------------
void __usercall sub_100968CC(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 8));
}

//----- (100968D7) --------------------------------------------------------
void __usercall sub_100968D7(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 20));
}

//----- (100968E2) --------------------------------------------------------
void __usercall sub_100968E2(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 32));
}

//----- (100968ED) --------------------------------------------------------
void __usercall sub_100968ED(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 44));
}

//----- (100968F8) --------------------------------------------------------
int __usercall sub_100968F8@<eax>(int a1@<ebp>)
{
  int v1; // edi@1

  v1 = *(_DWORD *)(a1 + 4) + 1080;
  return sub_1007C800();
}
// 1007C800: using guessed type int sub_1007C800(void);

//----- (10096906) --------------------------------------------------------
int __thiscall SEH_10093EF0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096910) --------------------------------------------------------
void __usercall sub_10096910(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_100330B0);
}

//----- (10096918) --------------------------------------------------------
void __usercall sub_10096918(int a1@<ebp>)
{
  sub_10041BD0(*(_DWORD *)(a1 + 4) + 24);
}

//----- (10096923) --------------------------------------------------------
void __usercall sub_10096923(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_100330B0);
}

//----- (1009692E) --------------------------------------------------------
int __thiscall SEH_10087290(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096938) --------------------------------------------------------
void sub_10096938()
{
  JUMPOUT(&loc_100330B0);
}

//----- (10096940) --------------------------------------------------------
int __thiscall SEH_10091A40(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (1009694A) --------------------------------------------------------
void __usercall sub_1009694A(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 592));
}

//----- (10096955) --------------------------------------------------------
int sub_10096955()
{
  return sub_1007C800();
}
// 1007C800: using guessed type int sub_1007C800(void);

//----- (10096960) --------------------------------------------------------
int __thiscall SEH_10059BB0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (1009696A) --------------------------------------------------------
void __usercall sub_1009696A(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 652));
}

//----- (10096975) --------------------------------------------------------
void __usercall sub_10096975(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 588));
}

//----- (10096980) --------------------------------------------------------
void __usercall sub_10096980(int a1@<ebp>)
{
  sub_1005C5A0((void *)(a1 - 624));
}

//----- (1009698B) --------------------------------------------------------
int __thiscall sub_1009698B(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096995) --------------------------------------------------------
void __usercall sub_10096995(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 2188));
}

//----- (100969A0) --------------------------------------------------------
void __usercall sub_100969A0(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 2176));
}

//----- (100969AB) --------------------------------------------------------
int __thiscall SEH_10060390(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100969B5) --------------------------------------------------------
void __usercall sub_100969B5(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 2180));
}

//----- (100969C0) --------------------------------------------------------
void __usercall sub_100969C0(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 2192));
}

//----- (100969CB) --------------------------------------------------------
int __thiscall SEH_100609B0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100969D5) --------------------------------------------------------
void __usercall sub_100969D5(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 1212));
}

//----- (100969E0) --------------------------------------------------------
void __usercall sub_100969E0(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1192));
}

//----- (100969EB) --------------------------------------------------------
void __usercall sub_100969EB(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1096));
}

//----- (100969F6) --------------------------------------------------------
void __usercall sub_100969F6(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1084));
}

//----- (10096A01) --------------------------------------------------------
void __usercall sub_10096A01(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1072));
}

//----- (10096A0C) --------------------------------------------------------
void __usercall sub_10096A0C(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1060));
}

//----- (10096A17) --------------------------------------------------------
int sub_10096A17()
{
  return sub_1007C800();
}
// 1007C800: using guessed type int sub_1007C800(void);

//----- (10096A1F) --------------------------------------------------------
void __usercall sub_10096A1F(int a1@<ebp>)
{
  sub_10032BC0(a1 - 1104);
}

//----- (10096A2C) --------------------------------------------------------
int __thiscall SEH_10060F80(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096A36) --------------------------------------------------------
void __usercall sub_10096A36(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1352));
}

//----- (10096A41) --------------------------------------------------------
void __usercall sub_10096A41(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1340));
}

//----- (10096A4C) --------------------------------------------------------
void __usercall sub_10096A4C(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1328));
}

//----- (10096A57) --------------------------------------------------------
void __usercall sub_10096A57(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1316));
}

//----- (10096A62) --------------------------------------------------------
int sub_10096A62()
{
  return sub_1007C800();
}
// 1007C800: using guessed type int sub_1007C800(void);

//----- (10096A6D) --------------------------------------------------------
void __usercall sub_10096A6D(int a1@<ebp>)
{
  sub_10032BC0(a1 - 1360);
}

//----- (10096A7A) --------------------------------------------------------
int __thiscall sub_10096A7A(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096A84) --------------------------------------------------------
void __usercall sub_10096A84(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 1212));
}

//----- (10096A8F) --------------------------------------------------------
void __usercall sub_10096A8F(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1200));
}

//----- (10096A9A) --------------------------------------------------------
void __usercall sub_10096A9A(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1096));
}

//----- (10096AA5) --------------------------------------------------------
void __usercall sub_10096AA5(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1084));
}

//----- (10096AB0) --------------------------------------------------------
void __usercall sub_10096AB0(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1072));
}

//----- (10096ABB) --------------------------------------------------------
void __usercall sub_10096ABB(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1060));
}

//----- (10096AC6) --------------------------------------------------------
int sub_10096AC6()
{
  return sub_1007C800();
}
// 1007C800: using guessed type int sub_1007C800(void);

//----- (10096ACE) --------------------------------------------------------
void __usercall sub_10096ACE(int a1@<ebp>)
{
  sub_10032BC0(a1 - 1104);
}

//----- (10096ADB) --------------------------------------------------------
int __thiscall SEH_1006B870(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096AE5) --------------------------------------------------------
void __usercall sub_10096AE5(int a1@<ebp>)
{
  sub_1003EAE0(*(_DWORD *)(a1 + 4) + 1628);
}

//----- (10096AF4) --------------------------------------------------------
void __usercall sub_10096AF4(int a1@<ebp>)
{
  sub_100371F0((void *)(*(_DWORD *)(a1 + 4) + 1716));
}

//----- (10096B02) --------------------------------------------------------
int __usercall sub_10096B02@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 + 4) + 1744), 0x58u, 4, sub_10036FD0);
}

//----- (10096B0F) --------------------------------------------------------
int __usercall sub_10096B0F@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 + 4) + 2112), 0xCu, 256, sub_100371F0);
}

//----- (10096B2A) --------------------------------------------------------
int __thiscall SEH_1006BE80(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096B34) --------------------------------------------------------
void __usercall sub_10096B34(int a1@<ebp>)
{
  sub_10036E20(*(_DWORD *)(a1 + 4) + 1624);
}

//----- (10096B43) --------------------------------------------------------
void __usercall sub_10096B43(int a1@<ebp>)
{
  sub_100371F0((void *)(*(_DWORD *)(a1 + 4) + 1712));
}

//----- (10096B51) --------------------------------------------------------
void __usercall sub_10096B51(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10036FB0);
}

//----- (10096B5E) --------------------------------------------------------
int __usercall sub_10096B5E@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 + 4) + 2112), 0xCu, 256, sub_100371F0);
}

//----- (10096B79) --------------------------------------------------------
int __thiscall SEH_1006E990(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096B83) --------------------------------------------------------
void __usercall sub_10096B83(int a1@<ebp>)
{
  sub_10036E20(*(_DWORD *)(a1 + 4) + 1624);
}

//----- (10096B92) --------------------------------------------------------
void __usercall sub_10096B92(int a1@<ebp>)
{
  sub_100371F0((void *)(*(_DWORD *)(a1 + 4) + 1712));
}

//----- (10096BA0) --------------------------------------------------------
void __usercall sub_10096BA0(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10036FB0);
}

//----- (10096BAD) --------------------------------------------------------
int __thiscall SEH_1006EA70(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096BB7) --------------------------------------------------------
void __usercall sub_10096BB7(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_100368B0);
}

//----- (10096BBF) --------------------------------------------------------
void __usercall sub_10096BBF(int a1@<ebp>)
{
  sub_10087290(*(_DWORD *)(a1 + 4) + 4);
}

//----- (10096BCC) --------------------------------------------------------
void __usercall sub_10096BCC(int a1@<ebp>)
{
  sub_10087290(*(_DWORD *)(a1 + 4) + 52);
}

//----- (10096BD9) --------------------------------------------------------
void __usercall sub_10096BD9(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 100));
}

//----- (10096BE4) --------------------------------------------------------
int __thiscall SEH_10071220(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096BEE) --------------------------------------------------------
void __usercall sub_10096BEE(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 1048));
}

//----- (10096BF9) --------------------------------------------------------
int __thiscall SEH_10075CE0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096C03) --------------------------------------------------------
void __usercall sub_10096C03(int a1@<ebp>)
{
  LeaveCriticalSection(*(LPCRITICAL_SECTION *)(a1 - 4116));
}

//----- (10096C0E) --------------------------------------------------------
void sub_10096C0E()
{
  JUMPOUT(&loc_100330B0);
}

//----- (10096C19) --------------------------------------------------------
int __thiscall SEH_10094100(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096C28) --------------------------------------------------------
void __usercall sub_10096C28(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 - 1576) + 24));
}

//----- (10096C36) --------------------------------------------------------
int __thiscall SEH_10087610(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096C45) --------------------------------------------------------
void __usercall sub_10096C45(int a1@<ebp>)
{
  sub_10037D80(*(int **)(a1 - 16));
}

//----- (10096C4D) --------------------------------------------------------
int __thiscall SEH_10087B90(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096C57) --------------------------------------------------------
int __usercall sub_10096C57@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 3468), 0x24u, 96, sub_100336C0);
}

//----- (10096C6D) --------------------------------------------------------
void __usercall sub_10096C6D(int a1@<ebp>)
{
  sub_10041BD0(a1 - 6556);
}

//----- (10096C78) --------------------------------------------------------
int __thiscall SEH_10094540(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096C8C) --------------------------------------------------------
int __thiscall SEH_10094EB0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096C96) --------------------------------------------------------
void __usercall sub_10096C96(int a1@<ebp>)
{
  sub_10041960(a1 - 2928);
}

//----- (10096CA3) --------------------------------------------------------
int __usercall sub_10096CA3@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 2784), 0xCu, 12, sub_10038C00);
}

//----- (10096CB9) --------------------------------------------------------
int __thiscall SEH_100616D0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096CC3) --------------------------------------------------------
void __usercall sub_10096CC3(int a1@<ebp>)
{
  sub_100417D0(a1 - 1356);
}

//----- (10096CD0) --------------------------------------------------------
void __usercall sub_10096CD0(int a1@<ebp>)
{
  sub_100416A0(a1 - 1356);
}

//----- (10096CDD) --------------------------------------------------------
void __usercall sub_10096CDD(int a1@<ebp>)
{
  sub_10041700(a1 - 1188);
}

//----- (10096CEA) --------------------------------------------------------
void __usercall sub_10096CEA(int a1@<ebp>)
{
  sub_100417D0(a1 - 1356);
}

//----- (10096CF7) --------------------------------------------------------
void __usercall sub_10096CF7(int a1@<ebp>)
{
  sub_100417D0(a1 - 1356);
}

//----- (10096D04) --------------------------------------------------------
void __usercall sub_10096D04(int a1@<ebp>)
{
  sub_100417D0(a1 - 1356);
}

//----- (10096D11) --------------------------------------------------------
int __thiscall sub_10096D11(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096D1B) --------------------------------------------------------
void __usercall sub_10096D1B(int a1@<ebp>)
{
  sub_10041440(a1 - 2352);
}

//----- (10096D28) --------------------------------------------------------
void __usercall sub_10096D28(int a1@<ebp>)
{
  sub_10041BD0(a1 - 2472);
}

//----- (10096D33) --------------------------------------------------------
void __usercall sub_10096D33(int a1@<ebp>)
{
  sub_10041510(a1 - 2208);
}

//----- (10096D40) --------------------------------------------------------
int __thiscall SEH_100630D0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096D4A) --------------------------------------------------------
void __usercall sub_10096D4A(int a1@<ebp>)
{
  sub_1003EAE0(*(_DWORD *)(a1 + 4) + 1628);
}

//----- (10096D59) --------------------------------------------------------
void __usercall sub_10096D59(int a1@<ebp>)
{
  sub_100371F0((void *)(*(_DWORD *)(a1 + 4) + 1716));
}

//----- (10096D67) --------------------------------------------------------
void __usercall sub_10096D67(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10036FB0);
}

//----- (10096D74) --------------------------------------------------------
int __thiscall SEH_1006C0C0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096D7E) --------------------------------------------------------
void __usercall sub_10096D7E(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 92));
}

//----- (10096D86) --------------------------------------------------------
int __thiscall SEH_1006EC50(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096D90) --------------------------------------------------------
void __usercall sub_10096D90(int a1@<ebp>)
{
  sub_100336C0((void *)(a1 - 1284));
}

//----- (10096D9B) --------------------------------------------------------
void __usercall sub_10096D9B(int a1@<ebp>)
{
  sub_1003F520(a1 - 1364);
}

//----- (10096DA8) --------------------------------------------------------
int __thiscall SEH_1006F060(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096DB2) --------------------------------------------------------
int __usercall sub_10096DB2@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 3468), 0x24u, 96, sub_100336C0);
}

//----- (10096DC8) --------------------------------------------------------
void __usercall sub_10096DC8(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 6552));
}

//----- (10096DD3) --------------------------------------------------------
void __usercall sub_10096DD3(int a1@<ebp>)
{
  sub_10041BD0(a1 - 6588);
}

//----- (10096DDE) --------------------------------------------------------
int __thiscall sub_10096DDE(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096DE8) --------------------------------------------------------
void __usercall sub_10096DE8(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 16);
  JUMPOUT(&loc_100368B0);
}

//----- (10096DF0) --------------------------------------------------------
void __usercall sub_10096DF0(int a1@<ebp>)
{
  sub_10087290(*(_DWORD *)(a1 - 16) + 4);
}

//----- (10096DFD) --------------------------------------------------------
void __usercall sub_10096DFD(int a1@<ebp>)
{
  sub_10087290(*(_DWORD *)(a1 - 16) + 52);
}

//----- (10096E0A) --------------------------------------------------------
void __usercall sub_10096E0A(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 - 16) + 100));
}

//----- (10096E15) --------------------------------------------------------
BOOL __usercall sub_10096E15@<eax>(int a1@<ebp>)
{
  return sub_100918E0(*(_DWORD *)(a1 - 16) + 176);
}

//----- (10096E24) --------------------------------------------------------
int __thiscall SEH_10072060(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096E2E) --------------------------------------------------------
void __usercall sub_10096E2E(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 80));
}

//----- (10096E36) --------------------------------------------------------
void __usercall sub_10096E36(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 68));
}

//----- (10096E3E) --------------------------------------------------------
void __usercall sub_10096E3E(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 56));
}

//----- (10096E46) --------------------------------------------------------
void __usercall sub_10096E46(int a1@<ebp>)
{
  sub_10036930(a1 - 120);
}

//----- (10096E50) --------------------------------------------------------
int __thiscall SEH_10076260(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096E5A) --------------------------------------------------------
void __usercall sub_10096E5A(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 88));
}

//----- (10096E62) --------------------------------------------------------
void __usercall sub_10096E62(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 76));
}

//----- (10096E6A) --------------------------------------------------------
void __usercall sub_10096E6A(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 64));
}

//----- (10096E72) --------------------------------------------------------
void __usercall sub_10096E72(int a1@<ebp>)
{
  sub_10036930(a1 - 128);
}

//----- (10096E7C) --------------------------------------------------------
int __thiscall SEH_10076420(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096E86) --------------------------------------------------------
void __usercall sub_10096E86(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 716));
}

//----- (10096E91) --------------------------------------------------------
void __usercall sub_10096E91(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 748));
}

//----- (10096E9C) --------------------------------------------------------
void __usercall sub_10096E9C(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 728));
}

//----- (10096EA7) --------------------------------------------------------
void __usercall sub_10096EA7(int a1@<ebp>)
{
  sub_1005C5A0((void *)(a1 - 568));
}

//----- (10096EB2) --------------------------------------------------------
void __usercall sub_10096EB2(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 644));
}

//----- (10096EBD) --------------------------------------------------------
void __usercall sub_10096EBD(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 632));
}

//----- (10096EC8) --------------------------------------------------------
void __usercall sub_10096EC8(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 620));
}

//----- (10096ED3) --------------------------------------------------------
void __usercall sub_10096ED3(int a1@<ebp>)
{
  sub_10036930(a1 - 684);
}

//----- (10096EE0) --------------------------------------------------------
int __thiscall SEH_10076610(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096EEA) --------------------------------------------------------
void __usercall sub_10096EEA(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1720));
}

//----- (10096EF5) --------------------------------------------------------
void __usercall sub_10096EF5(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1744));
}

//----- (10096F00) --------------------------------------------------------
void __usercall sub_10096F00(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1764));
}

//----- (10096F0B) --------------------------------------------------------
void __usercall sub_10096F0B(int a1@<ebp>)
{
  sub_1005C5A0((void *)(a1 - 1592));
}

//----- (10096F16) --------------------------------------------------------
void __usercall sub_10096F16(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1668));
}

//----- (10096F21) --------------------------------------------------------
void __usercall sub_10096F21(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1656));
}

//----- (10096F2C) --------------------------------------------------------
void __usercall sub_10096F2C(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 1644));
}

//----- (10096F37) --------------------------------------------------------
void __usercall sub_10096F37(int a1@<ebp>)
{
  sub_10036930(a1 - 1708);
}

//----- (10096F44) --------------------------------------------------------
int __thiscall SEH_10076E80(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096F4E) --------------------------------------------------------
void __usercall sub_10096F4E(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 772));
}

//----- (10096F59) --------------------------------------------------------
int __usercall sub_10096F59@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 800), 0xCu, 2, sub_10038C00);
}

//----- (10096F6F) --------------------------------------------------------
void __usercall sub_10096F6F(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 816));
}

//----- (10096F7A) --------------------------------------------------------
int __usercall sub_10096F7A@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 604), 0x24u, 2, sub_1005C5A0);
}

//----- (10096F90) --------------------------------------------------------
void __usercall sub_10096F90(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 700));
}

//----- (10096F9B) --------------------------------------------------------
void __usercall sub_10096F9B(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 688));
}

//----- (10096FA6) --------------------------------------------------------
void __usercall sub_10096FA6(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 676));
}

//----- (10096FB1) --------------------------------------------------------
void __usercall sub_10096FB1(int a1@<ebp>)
{
  sub_10036930(a1 - 740);
}

//----- (10096FBE) --------------------------------------------------------
int __thiscall SEH_10077800(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096FCD) --------------------------------------------------------
int __thiscall SEH_10087C90(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10096FD7) --------------------------------------------------------
void __usercall sub_10096FD7(int a1@<ebp>)
{
  sub_100336C0((void *)(a1 - 4020));
}

//----- (10096FE2) --------------------------------------------------------
int __usercall sub_10096FE2@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 3616), 0x24u, 8, sub_100336C0);
}

//----- (10096FF8) --------------------------------------------------------
int __thiscall SEH_10063CB0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097002) --------------------------------------------------------
int __usercall sub_10097002@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 132), 0xCu, 2, sub_10038C00);
}

//----- (10097018) --------------------------------------------------------
int __usercall sub_10097018@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 108), 0xCu, 2, sub_10038C00);
}

//----- (1009702B) --------------------------------------------------------
void __usercall sub_1009702B(int a1@<ebp>)
{
  sub_100371F0((void *)(a1 - 144));
}

//----- (10097036) --------------------------------------------------------
int __thiscall SEH_1006C250(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097040) --------------------------------------------------------
void __usercall sub_10097040(int a1@<ebp>)
{
  sub_100336C0((void *)(a1 - 1652));
}

//----- (1009704B) --------------------------------------------------------
void __usercall sub_1009704B(int a1@<ebp>)
{
  sub_1003F520(a1 - 1616);
}

//----- (10097058) --------------------------------------------------------
int __thiscall SEH_1006C8E0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097062) --------------------------------------------------------
void __usercall sub_10097062(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 2172));
}

//----- (1009706D) --------------------------------------------------------
int __usercall sub_1009706D@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 2112), 0xCu, 4, sub_10038C00);
}

//----- (10097083) --------------------------------------------------------
void __usercall sub_10097083(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 2136));
}

//----- (1009708E) --------------------------------------------------------
int __thiscall SEH_10078240(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097098) --------------------------------------------------------
void __usercall sub_10097098(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 2172));
}

//----- (100970A3) --------------------------------------------------------
int __usercall sub_100970A3@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 2112), 0xCu, 4, sub_10038C00);
}

//----- (100970B9) --------------------------------------------------------
void __usercall sub_100970B9(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 2136));
}

//----- (100970C4) --------------------------------------------------------
int __thiscall SEH_10078C00(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100970CE) --------------------------------------------------------
int __usercall sub_100970CE@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 64), 0xCu, 4, sub_10038C00);
}

//----- (100970E1) --------------------------------------------------------
void __usercall sub_100970E1(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 76));
}

//----- (100970E9) --------------------------------------------------------
int __thiscall sub_100970E9(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100970F3) --------------------------------------------------------
int __usercall sub_100970F3@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 64), 0xCu, 4, sub_10038C00);
}

//----- (10097106) --------------------------------------------------------
void __usercall sub_10097106(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 76));
}

//----- (1009710E) --------------------------------------------------------
int __thiscall SEH_10079940(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097118) --------------------------------------------------------
void __usercall sub_10097118(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 1164));
}

//----- (10097123) --------------------------------------------------------
void __usercall sub_10097123(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1148));
}

//----- (1009712E) --------------------------------------------------------
int __thiscall SEH_10084890(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097138) --------------------------------------------------------
void __usercall sub_10097138(int a1@<ebp>)
{
  sub_100336C0((void *)(a1 - 1076));
}

//----- (10097143) --------------------------------------------------------
void __usercall sub_10097143(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 1088));
}

//----- (1009714E) --------------------------------------------------------
void __usercall sub_1009714E(int a1@<ebp>)
{
  sub_100336C0((void *)(a1 - 1112));
}

//----- (10097159) --------------------------------------------------------
int __thiscall SEH_10087F90(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097163) --------------------------------------------------------
void __usercall sub_10097163(int a1@<ebp>)
{
  sub_100336C0((void *)(a1 - 48));
}

//----- (1009716B) --------------------------------------------------------
void __usercall sub_1009716B(int a1@<ebp>)
{
  sub_10041BD0(a1 - 60);
}

//----- (10097173) --------------------------------------------------------
int __thiscall SEH_10088740(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (1009717D) --------------------------------------------------------
void __usercall sub_1009717D(int a1@<ebp>)
{
  sub_10041BD0(a1 - 4224);
}

//----- (10097188) --------------------------------------------------------
void __usercall sub_10097188(int a1@<ebp>)
{
  sub_100336C0((void *)(a1 - 4184));
}

//----- (10097193) --------------------------------------------------------
int __thiscall SEH_10088920(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (1009719D) --------------------------------------------------------
void __usercall sub_1009719D(int a1@<ebp>)
{
  sub_10041BD0(a1 - 4204);
}

//----- (100971A8) --------------------------------------------------------
void __usercall sub_100971A8(int a1@<ebp>)
{
  sub_100336C0((void *)(a1 - 4184));
}

//----- (100971B3) --------------------------------------------------------
int __thiscall sub_100971B3(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100971BD) --------------------------------------------------------
void __usercall sub_100971BD(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 264));
}

//----- (100971C8) --------------------------------------------------------
void __usercall sub_100971C8(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 224));
}

//----- (100971D3) --------------------------------------------------------
void __usercall sub_100971D3(int a1@<ebp>)
{
  sub_100336C0((void *)(a1 - 224));
}

//----- (100971DE) --------------------------------------------------------
int __thiscall sub_100971DE(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100971E8) --------------------------------------------------------
void __usercall sub_100971E8(int a1@<ebp>)
{
  sub_10032890(a1 - 1640);
}

//----- (100971F5) --------------------------------------------------------
void __usercall sub_100971F5(int a1@<ebp>)
{
  sub_100328F0(a1 - 1640);
}

//----- (10097202) --------------------------------------------------------
void __usercall sub_10097202(int a1@<ebp>)
{
  sub_10032BC0(a1 - 1304);
}

//----- (1009720F) --------------------------------------------------------
void __usercall sub_1009720F(int a1@<ebp>)
{
  sub_100328F0(a1 - 1640);
}

//----- (1009721C) --------------------------------------------------------
void __usercall sub_1009721C(int a1@<ebp>)
{
  sub_10032BC0(a1 - 1304);
}

//----- (10097229) --------------------------------------------------------
void __usercall sub_10097229(int a1@<ebp>)
{
  sub_100328F0(a1 - 1640);
}

//----- (10097236) --------------------------------------------------------
void __usercall sub_10097236(int a1@<ebp>)
{
  sub_10032BC0(a1 - 1304);
}

//----- (10097243) --------------------------------------------------------
int __thiscall SEH_100864E0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (1009724D) --------------------------------------------------------
void __usercall sub_1009724D(int a1@<ebp>)
{
  sub_10087290(a1 - 552);
}

//----- (1009725A) --------------------------------------------------------
int __thiscall sub_1009725A(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097264) --------------------------------------------------------
void __usercall sub_10097264(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 24));
}

//----- (1009726C) --------------------------------------------------------
int __thiscall SEH_10092BE0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097276) --------------------------------------------------------
void __usercall sub_10097276(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 468));
}

//----- (10097281) --------------------------------------------------------
void __usercall sub_10097281(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 456));
}

//----- (1009728C) --------------------------------------------------------
void __usercall sub_1009728C(int a1@<ebp>)
{
  sub_100328F0(a1 - 352);
}

//----- (10097299) --------------------------------------------------------
int __thiscall SEH_10065420(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100972A3) --------------------------------------------------------
void __usercall sub_100972A3(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 496));
}

//----- (100972AE) --------------------------------------------------------
void __usercall sub_100972AE(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 484));
}

//----- (100972B9) --------------------------------------------------------
void __usercall sub_100972B9(int a1@<ebp>)
{
  sub_100328F0(a1 - 352);
}

//----- (100972C6) --------------------------------------------------------
void __usercall sub_100972C6(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 516));
}

//----- (100972D1) --------------------------------------------------------
void sub_100972D1()
{
  JUMPOUT(&loc_10036D70);
}

//----- (100972DC) --------------------------------------------------------
int __thiscall SEH_1006FE20(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100972E6) --------------------------------------------------------
BOOL __usercall sub_100972E6@<eax>(int a1@<ebp>)
{
  return sub_100918E0(a1 - 112);
}

//----- (100972F0) --------------------------------------------------------
int __thiscall sub_100972F0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100972FA) --------------------------------------------------------
void __usercall sub_100972FA(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 84));
}

//----- (10097302) --------------------------------------------------------
void __usercall sub_10097302(int a1@<ebp>)
{
  sub_100336C0((void *)(a1 - 108));
}

//----- (1009730A) --------------------------------------------------------
int __thiscall sub_1009730A(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097314) --------------------------------------------------------
void __usercall sub_10097314(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 52));
}

//----- (1009731C) --------------------------------------------------------
int __usercall sub_1009731C@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 40), 0xCu, 2, sub_10038C00);
}

//----- (1009732F) --------------------------------------------------------
int __thiscall SEH_1008AC40(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097339) --------------------------------------------------------
void __usercall sub_10097339(int a1@<ebp>)
{
  sub_100336C0((void *)(a1 - 48));
}

//----- (10097341) --------------------------------------------------------
int __thiscall SEH_1008B0C0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (1009734B) --------------------------------------------------------
int __usercall sub_1009734B@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 144), 0xCu, 2, sub_10038C00);
}

//----- (10097361) --------------------------------------------------------
int __usercall sub_10097361@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 168), 0xCu, 2, sub_10038C00);
}

//----- (10097377) --------------------------------------------------------
void __usercall sub_10097377(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 80));
}

//----- (1009737F) --------------------------------------------------------
void __usercall sub_1009737F(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 68));
}

//----- (10097387) --------------------------------------------------------
void __usercall sub_10097387(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 56));
}

//----- (1009738F) --------------------------------------------------------
void __usercall sub_1009738F(int a1@<ebp>)
{
  sub_10036930(a1 - 120);
}

//----- (10097399) --------------------------------------------------------
int __thiscall SEH_1007A2D0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100973A3) --------------------------------------------------------
void __usercall sub_100973A3(int a1@<ebp>)
{
  sub_100336C0((void *)(a1 - 48));
}

//----- (100973AB) --------------------------------------------------------
int __thiscall SEH_1008B1D0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100973BA) --------------------------------------------------------
int __thiscall sub_100973BA(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100973C4) --------------------------------------------------------
void __usercall sub_100973C4(int a1@<ebp>)
{
  int v1; // eax@1
  int v2; // ecx@2

  *(_DWORD *)(a1 - 48) = &off_100A4DB0;
  v1 = *(_DWORD *)(a1 - 48 + 8);
  if ( v1 )
  {
    v2 = v1 - 8;
    if ( *(_DWORD *)(v1 - 4) == ~*(_DWORD *)(v1 - 8) && v1 != 8 )
    {
      if ( v2 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v2, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100A4DB0: using guessed type int (__stdcall *off_100A4DB0)(char);
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100973CC) --------------------------------------------------------
void __usercall sub_100973CC(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 32));
}

//----- (100973D4) --------------------------------------------------------
void __usercall sub_100973D4(int a1@<ebp>)
{
  sub_100323F0(a1 - 48);
}

//----- (100973DC) --------------------------------------------------------
void __usercall sub_100973DC(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 60));
}

//----- (100973E4) --------------------------------------------------------
int __thiscall SEH_10072420(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100973F0) --------------------------------------------------------
void __usercall sub_100973F0(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 40));
}

//----- (100973FB) --------------------------------------------------------
void __usercall sub_100973FB(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 52));
}

//----- (10097406) --------------------------------------------------------
int __thiscall SEH_10036930(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097410) --------------------------------------------------------
void __usercall sub_10097410(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 36));
}

//----- (1009741B) --------------------------------------------------------
int __usercall sub_1009741B@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 + 4) + 48), 0xCu, 2, sub_10038C00);
}

//----- (10097431) --------------------------------------------------------
void __usercall sub_10097431(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 80));
}

//----- (1009743C) --------------------------------------------------------
void __usercall sub_1009743C(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 92));
}

//----- (10097447) --------------------------------------------------------
void __usercall sub_10097447(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 116);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10097452) --------------------------------------------------------
void __usercall sub_10097452(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10032350);
}

//----- (1009745F) --------------------------------------------------------
int __thiscall SEH_10032D20(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097470) --------------------------------------------------------
int __cdecl sub_10097470(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 24));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097490) --------------------------------------------------------
void __usercall sub_10097490(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 16));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1009749C) --------------------------------------------------------
int __cdecl sub_1009749C(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 8));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100974C0) --------------------------------------------------------
void __usercall sub_100974C0(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 16));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (100974CC) --------------------------------------------------------
void __usercall sub_100974CC(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 16);
  JUMPOUT(&loc_10014DE0);
}

//----- (100974D4) --------------------------------------------------------
int __cdecl sub_100974D4(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 20));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100974F0) --------------------------------------------------------
void __usercall sub_100974F0(int a1@<ebp>)
{
  void *v1; // eax@1
  int v2; // esi@1

  v2 = *(_DWORD *)(a1 + 8);
  v1 = *(void **)(v2 + 12);
  *(_DWORD *)v2 = &off_100A200C;
  if ( v1 && v1 != *(void **)(v2 + 8) )
    operator delete[](v1);
  if ( *(_DWORD *)(v2 + 8) )
    operator delete[](*(void **)(v2 + 8));
  *(_DWORD *)v2 = &off_100A1FAC;
}
// 10099190: using guessed type void __cdecl operator delete[](void *);
// 100A1FAC: using guessed type void *off_100A1FAC;
// 100A200C: using guessed type int (*off_100A200C)();

//----- (100974F8) --------------------------------------------------------
int __cdecl sub_100974F8(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 16));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097520) --------------------------------------------------------
int __cdecl sub_10097520(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 24));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097540) --------------------------------------------------------
void __usercall sub_10097540(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 24));
}

//----- (10097548) --------------------------------------------------------
int __thiscall SEH_10049FB0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097560) --------------------------------------------------------
void __usercall sub_10097560(int a1@<ebp>)
{
  sub_10037D80(*(int **)(a1 + 4));
}

//----- (10097568) --------------------------------------------------------
int __thiscall SEH_1003F520(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097580) --------------------------------------------------------
void __usercall sub_10097580(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 24));
}

//----- (10097588) --------------------------------------------------------
int __thiscall SEH_1003F290(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100975A0) --------------------------------------------------------
void __usercall sub_100975A0(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 24));
}

//----- (100975AB) --------------------------------------------------------
int __thiscall sub_100975AB(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100975C0) --------------------------------------------------------
void __usercall sub_100975C0(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 24));
}

//----- (100975CB) --------------------------------------------------------
int __thiscall sub_100975CB(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100975E0) --------------------------------------------------------
void __usercall sub_100975E0(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 8));
}

//----- (100975EB) --------------------------------------------------------
void __usercall sub_100975EB(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 20));
}

//----- (100975F6) --------------------------------------------------------
void __usercall sub_100975F6(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 32));
}

//----- (10097601) --------------------------------------------------------
void __usercall sub_10097601(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 44));
}

//----- (1009760C) --------------------------------------------------------
int __thiscall SEH_10032BC0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097620) --------------------------------------------------------
void __usercall sub_10097620(int a1@<ebp>)
{
  sub_100328F0(*(_DWORD *)(a1 + 4));
}

//----- (1009762A) --------------------------------------------------------
void __usercall sub_1009762A(int a1@<ebp>)
{
  sub_10032BC0(*(_DWORD *)(a1 + 4) + 336);
}

//----- (10097639) --------------------------------------------------------
int __thiscall SEH_10032890(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097650) --------------------------------------------------------
void __usercall sub_10097650(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 16);
  JUMPOUT(&loc_10032270);
}

//----- (10097658) --------------------------------------------------------
int __thiscall SEH_100323F0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097670) --------------------------------------------------------
int __usercall sub_10097670@<eax>(int a1@<ebp>)
{
  int result; // eax@1

  result = a1 - 68;
  *(_DWORD *)(a1 - 68) = &off_100A4D74;
  return result;
}
// 100A4D74: using guessed type int (__stdcall *off_100A4D74)(char);

//----- (10097678) --------------------------------------------------------
void sub_10097678()
{
  JUMPOUT(&loc_1002A790);
}

//----- (10097683) --------------------------------------------------------
void sub_10097683()
{
  JUMPOUT(&loc_1002A790);
}

//----- (1009768B) --------------------------------------------------------
int __cdecl sub_1009768B(int a1, int a2)
{
  int v2; // ecx@1

  v2 = (a2 + 12) ^ *(_DWORD *)(a2 - 884);
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 4));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100976C0) --------------------------------------------------------
void __usercall sub_100976C0(int a1@<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 - 28) + 16;
  if ( *(_DWORD *)v1 )
    operator delete(*(void **)v1);
  *(_DWORD *)v1 = 0;
  *(_DWORD *)(v1 + 4) = 0;
  *(_DWORD *)(v1 + 8) = 0;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (100976F0) --------------------------------------------------------
void __usercall sub_100976F0(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 16));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (100976FC) --------------------------------------------------------
int __cdecl sub_100976FC(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 16));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097720) --------------------------------------------------------
void __usercall sub_10097720(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 16));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1009772C) --------------------------------------------------------
int __cdecl sub_1009772C(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 12));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097750) --------------------------------------------------------
void __usercall sub_10097750(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 20));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1009775C) --------------------------------------------------------
int __cdecl sub_1009775C(int a1, int a2)
{
  return _CxxFrameHandler3((a2 - 12) ^ *(_DWORD *)(a2 - 16));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097780) --------------------------------------------------------
void __usercall sub_10097780(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 40));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1009778C) --------------------------------------------------------
void __usercall sub_1009778C(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 40));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10097798) --------------------------------------------------------
void __usercall sub_10097798(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 40));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (100977A4) --------------------------------------------------------
void __usercall sub_100977A4(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 40));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (100977B0) --------------------------------------------------------
void __usercall sub_100977B0(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 44));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (100977BC) --------------------------------------------------------
int __cdecl sub_100977BC(int a1, int a2)
{
  return _CxxFrameHandler3((a2 - 76) ^ *(_DWORD *)(a2 - 80));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100977E0) --------------------------------------------------------
void __usercall sub_100977E0(int a1@<ebp>)
{
  AssetsFileTable::~AssetsFileTable((AssetsFileTable *)(a1 - 36));
}

//----- (100977E8) --------------------------------------------------------
int __cdecl sub_100977E8(int a1, int a2)
{
  return _CxxFrameHandler3((a2 - 76) ^ *(_DWORD *)(a2 - 80));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097810) --------------------------------------------------------
void __usercall sub_10097810(int a1@<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 + 8);
  JUMPOUT(&loc_100150D0);
}

//----- (10097818) --------------------------------------------------------
int __cdecl sub_10097818(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 12));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097840) --------------------------------------------------------
void sub_10097840()
{
  JUMPOUT(&loc_1000A800);
}

//----- (1009784B) --------------------------------------------------------
void sub_1009784B()
{
  JUMPOUT(&loc_1000A800);
}

//----- (10097856) --------------------------------------------------------
void sub_10097856()
{
  JUMPOUT(&loc_1000A800);
}

//----- (10097861) --------------------------------------------------------
int __cdecl sub_10097861(int a1, int a2)
{
  int v2; // ecx@1

  v2 = (a2 - 452) ^ *(_DWORD *)(a2 - 456);
  return _CxxFrameHandler3((a2 - 452 + 12) ^ *(_DWORD *)(a2 - 8));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097890) --------------------------------------------------------
void sub_10097890()
{
  JUMPOUT(&loc_1000A800);
}

//----- (1009789B) --------------------------------------------------------
void sub_1009789B()
{
  JUMPOUT(&loc_1000A800);
}

//----- (100978A6) --------------------------------------------------------
void sub_100978A6()
{
  JUMPOUT(&loc_1000A800);
}

//----- (100978B1) --------------------------------------------------------
void __usercall sub_100978B1(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 400));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (100978C0) --------------------------------------------------------
void __usercall sub_100978C0(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 400);
  JUMPOUT(&loc_10014DE0);
}

//----- (100978CB) --------------------------------------------------------
void sub_100978CB()
{
  JUMPOUT(&loc_1000A800);
}

//----- (100978D6) --------------------------------------------------------
void sub_100978D6()
{
  JUMPOUT(&loc_1000A800);
}

//----- (100978E1) --------------------------------------------------------
void sub_100978E1()
{
  JUMPOUT(&loc_1000A800);
}

//----- (100978EC) --------------------------------------------------------
void __usercall sub_100978EC(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 464));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (100978FB) --------------------------------------------------------
void __usercall sub_100978FB(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 464);
  JUMPOUT(&loc_10014DE0);
}

//----- (10097906) --------------------------------------------------------
int __cdecl sub_10097906(int a1, int a2)
{
  int v2; // ecx@1

  v2 = (a2 - 500) ^ *(_DWORD *)(a2 - 504);
  return _CxxFrameHandler3((a2 - 500 + 12) ^ *(_DWORD *)(a2 - 8));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097940) --------------------------------------------------------
void __usercall sub_10097940(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 24));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (1009794C) --------------------------------------------------------
int __cdecl sub_1009794C(int a1, int a2)
{
  return _CxxFrameHandler3((a2 - 44) ^ *(_DWORD *)(a2 - 48));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097970) --------------------------------------------------------
void __usercall sub_10097970(int a1@<ebp>)
{
  sub_100418A0(*(_DWORD *)(a1 + 4));
}

//----- (1009797A) --------------------------------------------------------
void __usercall sub_1009797A(int a1@<ebp>)
{
  int v1; // eax@2
  int *v2; // esi@1

  v2 = (int *)(*(_DWORD *)(a1 + 4) + 16);
  if ( *v2 )
  {
    sub_10040FD0(*v2, *(_DWORD *)(*(_DWORD *)(a1 + 4) + 20));
    v1 = *v2;
    if ( *v2 )
    {
      if ( v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10097985) --------------------------------------------------------
void __usercall sub_10097985(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10047BB0);
}

//----- (1009798D) --------------------------------------------------------
int __thiscall SEH_10041700(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100979A0) --------------------------------------------------------
void __usercall sub_100979A0(int a1@<ebp>)
{
  sub_10041640(*(_DWORD *)(a1 + 4));
}

//----- (100979AA) --------------------------------------------------------
void __usercall sub_100979AA(int a1@<ebp>)
{
  int v1; // eax@2
  int *v2; // esi@1

  v2 = (int *)(*(_DWORD *)(a1 + 4) + 16);
  if ( *v2 )
  {
    sub_1004CEF0(*v2, *(_DWORD *)(*(_DWORD *)(a1 + 4) + 20));
    v1 = *v2;
    if ( *v2 )
    {
      if ( v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100979B5) --------------------------------------------------------
void __usercall sub_100979B5(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10047BB0);
}

//----- (100979BD) --------------------------------------------------------
int __thiscall SEH_10041510(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100979D0) --------------------------------------------------------
void __usercall sub_100979D0(int a1@<ebp>)
{
  sub_1003F520(a1 - 40);
}

//----- (100979DA) --------------------------------------------------------
int __thiscall SEH_10040BA0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100979F0) --------------------------------------------------------
void __usercall sub_100979F0(int a1@<ebp>)
{
  sub_10037D80(*(int **)(a1 + 4));
}

//----- (100979F8) --------------------------------------------------------
void __usercall sub_100979F8(int a1@<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_100437D0);
}

//----- (10097A03) --------------------------------------------------------
void __usercall sub_10097A03(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 24));
}

//----- (10097A0E) --------------------------------------------------------
void __usercall sub_10097A0E(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 44));
}

//----- (10097A19) --------------------------------------------------------
void __usercall sub_10097A19(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 64));
}

//----- (10097A24) --------------------------------------------------------
int __thiscall SEH_1003EAE0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097A30) --------------------------------------------------------
void __usercall sub_10097A30(int a1@<ebp>)
{
  sub_100371F0((void *)(a1 - 24));
}

//----- (10097A38) --------------------------------------------------------
int __thiscall SEH_10038CE0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097A50) --------------------------------------------------------
void __usercall sub_10097A50(int a1@<ebp>)
{
  sub_10037D80(*(int **)(a1 - 16));
}

//----- (10097A58) --------------------------------------------------------
void __usercall sub_10097A58(int a1@<ebp>)
{
  int v1; // eax@2
  int *v2; // esi@1

  v2 = (int *)(*(_DWORD *)(a1 - 16) + 12);
  if ( *v2 )
  {
    sub_1004CF40(*(_DWORD *)(*(_DWORD *)(a1 - 16) + 16), *v2);
    v1 = *v2;
    if ( *v2 )
    {
      if ( v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10097A63) --------------------------------------------------------
void __usercall sub_10097A63(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 - 16) + 24));
}

//----- (10097A6E) --------------------------------------------------------
void __usercall sub_10097A6E(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 - 16) + 44));
}

//----- (10097A79) --------------------------------------------------------
void __usercall sub_10097A79(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 - 16) + 64));
}

//----- (10097A84) --------------------------------------------------------
int __thiscall SEH_10036FD0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097A90) --------------------------------------------------------
void __usercall sub_10097A90(int a1@<ebp>)
{
  sub_10037D80(*(int **)(a1 + 4));
}

//----- (10097A98) --------------------------------------------------------
void __usercall sub_10097A98(int a1@<ebp>)
{
  int v1; // eax@2
  int *v2; // esi@1

  v2 = (int *)(*(_DWORD *)(a1 + 4) + 12);
  if ( *v2 )
  {
    sub_1004CEA0(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 16), *v2);
    v1 = *v2;
    if ( *v2 )
    {
      if ( v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10097AA3) --------------------------------------------------------
void __usercall sub_10097AA3(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 + 4) + 24));
}

//----- (10097AAE) --------------------------------------------------------
void __usercall sub_10097AAE(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 44));
}

//----- (10097AB9) --------------------------------------------------------
void __usercall sub_10097AB9(int a1@<ebp>)
{
  sub_10038C00((void *)(*(_DWORD *)(a1 + 4) + 64));
}

//----- (10097AC4) --------------------------------------------------------
int __thiscall SEH_10036E20(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097AD0) --------------------------------------------------------
void __usercall sub_10097AD0(int a1@<ebp>)
{
  sub_100328F0(*(_DWORD *)(a1 + 4));
}

//----- (10097ADA) --------------------------------------------------------
void __usercall sub_10097ADA(int a1@<ebp>)
{
  sub_10032BC0(*(_DWORD *)(a1 + 4) + 336);
}

//----- (10097AE9) --------------------------------------------------------
void __usercall sub_10097AE9(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 - 16) + 36));
}

//----- (10097AF4) --------------------------------------------------------
int __thiscall SEH_10032780(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097B00) --------------------------------------------------------
void *__usercall sub_10097B00@<eax>(int a1@<ebp>)
{
  void *result; // eax@1
  int v2; // esi@1

  v2 = *(_DWORD *)(a1 - 16) + 4;
  result = *(void **)v2;
  if ( *(_DWORD *)v2 )
  {
    result = sub_1001CE80(result);
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
  }
  *(_BYTE *)(v2 + 12) = 0;
  return result;
}

//----- (10097B0B) --------------------------------------------------------
int __cdecl sub_10097B0B(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 20));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097B30) --------------------------------------------------------
void __usercall sub_10097B30(int a1@<ebp>)
{
  sub_10019D40(*(_DWORD *)(a1 - 16) + 36);
}

//----- (10097B3B) --------------------------------------------------------
int __cdecl sub_10097B3B(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 20));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097B60) --------------------------------------------------------
void __usercall sub_10097B60(int a1@<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 - 16);
  JUMPOUT(&loc_1000A800);
}

//----- (10097B6B) --------------------------------------------------------
void sub_10097B6B()
{
  JUMPOUT(&loc_1000A800);
}

//----- (10097B73) --------------------------------------------------------
int __cdecl sub_10097B73(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 36));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097B90) --------------------------------------------------------
void sub_10097B90()
{
  JUMPOUT(&loc_100437D0);
}

//----- (10097B98) --------------------------------------------------------
int __thiscall SEH_10048910(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097BB0) --------------------------------------------------------
void __usercall sub_10097BB0(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 652));
}

//----- (10097BBB) --------------------------------------------------------
void __usercall sub_10097BBB(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 584));
}

//----- (10097BC6) --------------------------------------------------------
int __thiscall SEH_10047DD0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097BD5) --------------------------------------------------------
int __thiscall SEH_1004ABA0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097BE0) --------------------------------------------------------
void sub_10097BE0()
{
  JUMPOUT(&loc_10043220);
}

//----- (10097BE8) --------------------------------------------------------
int __thiscall SEH_10047C10(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097C00) --------------------------------------------------------
void __usercall sub_10097C00(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 728));
}

//----- (10097C0B) --------------------------------------------------------
void __usercall sub_10097C0B(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 760));
}

//----- (10097C16) --------------------------------------------------------
int __thiscall SEH_10046830(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097C20) --------------------------------------------------------
void __usercall sub_10097C20(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 - 596 + 20);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10097C30) --------------------------------------------------------
int __thiscall SEH_10043320(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097C40) --------------------------------------------------------
void __usercall sub_10097C40(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 - 628 + 28);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10097C4B) --------------------------------------------------------
int __thiscall SEH_10042D20(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097C60) --------------------------------------------------------
void __usercall sub_10097C60(int a1@<ebp>)
{
  sub_10041A30(*(_DWORD *)(a1 + 4));
}

//----- (10097C6A) --------------------------------------------------------
void __usercall sub_10097C6A(int a1@<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10043DC0);
}

//----- (10097C75) --------------------------------------------------------
void __usercall sub_10097C75(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10047BB0);
}

//----- (10097C7D) --------------------------------------------------------
int __thiscall SEH_10041960(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097C90) --------------------------------------------------------
void __usercall sub_10097C90(int a1@<ebp>)
{
  sub_10041900(*(_DWORD *)(a1 + 4));
}

//----- (10097C9A) --------------------------------------------------------
void __usercall sub_10097C9A(int a1@<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_100437D0);
}

//----- (10097CA5) --------------------------------------------------------
void __usercall sub_10097CA5(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10047BB0);
}

//----- (10097CAD) --------------------------------------------------------
int __thiscall SEH_100417D0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097CC0) --------------------------------------------------------
void __usercall sub_10097CC0(int a1@<ebp>)
{
  sub_100417D0(*(_DWORD *)(a1 + 4));
}

//----- (10097CCA) --------------------------------------------------------
int __thiscall SEH_100416A0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097CE0) --------------------------------------------------------
void __usercall sub_10097CE0(int a1@<ebp>)
{
  sub_100415E0(*(_DWORD *)(a1 + 4));
}

//----- (10097CEA) --------------------------------------------------------
void __usercall sub_10097CEA(int a1@<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10042C20);
}

//----- (10097CF5) --------------------------------------------------------
void __usercall sub_10097CF5(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 4);
  JUMPOUT(&loc_10047BB0);
}

//----- (10097CFD) --------------------------------------------------------
int __thiscall SEH_10041440(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097D10) --------------------------------------------------------
void sub_10097D10()
{
  JUMPOUT(&loc_1003F6E0);
}

//----- (10097D1D) --------------------------------------------------------
int __thiscall sub_10097D1D(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097D3A) --------------------------------------------------------
int __thiscall SEH_1003E3D0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097D50) --------------------------------------------------------
void sub_10097D50()
{
  JUMPOUT(&loc_10042C20);
}

//----- (10097D58) --------------------------------------------------------
int __thiscall SEH_10046720(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097D70) --------------------------------------------------------
void __usercall sub_10097D70(int a1@<ebp>)
{
  int v1; // eax@2
  int v2; // esi@1

  v2 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)v2 )
  {
    sub_1003E530(*(_DWORD *)(v2 + 4), *(_DWORD *)v2);
    v1 = *(_DWORD *)v2;
    if ( *(_DWORD *)v2 )
    {
      if ( v1 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10097D78) --------------------------------------------------------
int __thiscall SEH_100388E0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097D90) --------------------------------------------------------
void __usercall sub_10097D90(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 - 80 + 36);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (10097D9D) --------------------------------------------------------
int __thiscall sub_10097D9D(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097DB5) --------------------------------------------------------
void __usercall sub_10097DB5(int a1@<ebp>)
{
  sub_10037D80((int *)(*(_DWORD *)(a1 - 16) + 24));
}

//----- (10097DC0) --------------------------------------------------------
int __thiscall SEH_100343F0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097DD0) --------------------------------------------------------
void __usercall sub_10097DD0(int a1@<ebp>)
{
  sub_1006E990(*(_DWORD *)(a1 + 4) + 8);
}

//----- (10097DDD) --------------------------------------------------------
void __usercall sub_10097DDD(int a1@<ebp>)
{
  sub_1006BE80(*(_DWORD *)(a1 + 4) + 5224);
}

//----- (10097DEC) --------------------------------------------------------
void __usercall sub_10097DEC(int a1@<ebp>)
{
  sub_1006BE80(*(_DWORD *)(a1 + 4) + 10440);
}

//----- (10097DFB) --------------------------------------------------------
int __thiscall SEH_10033BD0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097E10) --------------------------------------------------------
void __usercall sub_10097E10(int a1@<ebp>)
{
  sub_1001D0B0((void *)(*(_DWORD *)(a1 + 8) + 116));
}

//----- (10097E1B) --------------------------------------------------------
int __usercall sub_10097E1B@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 + 8) + 140), 0x18u, 2, sub_1001D0B0);
}

//----- (10097E33) --------------------------------------------------------
int __usercall sub_10097E33@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 + 8) + 188), 0x18u, 2, sub_1001D0B0);
}

//----- (10097E4B) --------------------------------------------------------
void __usercall sub_10097E4B(int a1@<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 + 8);
  JUMPOUT(&loc_100216C0);
}

//----- (10097E59) --------------------------------------------------------
void __usercall sub_10097E59(int a1@<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 + 8);
  JUMPOUT(&loc_100216C0);
}

//----- (10097E67) --------------------------------------------------------
void __usercall sub_10097E67(int a1@<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 + 8);
  JUMPOUT(&loc_100216C0);
}

//----- (10097E75) --------------------------------------------------------
int __cdecl sub_10097E75(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 12));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097E90) --------------------------------------------------------
void __usercall sub_10097E90(int a1@<ebp>)
{
  sub_1001D0B0((void *)(*(_DWORD *)(a1 + 8) + 116));
}

//----- (10097E9B) --------------------------------------------------------
int __usercall sub_10097E9B@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(*(_DWORD *)(a1 + 8) + 140), 0x18u, 2, sub_1001D0B0);
}

//----- (10097EB3) --------------------------------------------------------
int __cdecl sub_10097EB3(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 12));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097ED0) --------------------------------------------------------
void __usercall sub_10097ED0(int a1@<ebp>)
{
  sub_1001D0B0((void *)(a1 - 44));
}

//----- (10097ED8) --------------------------------------------------------
int __cdecl sub_10097ED8(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 52));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097F05) --------------------------------------------------------
int __cdecl sub_10097F05(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 24));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097F20) --------------------------------------------------------
void sub_10097F20()
{
  JUMPOUT(&loc_1000A800);
}

//----- (10097F28) --------------------------------------------------------
void sub_10097F28()
{
  JUMPOUT(&loc_1000A800);
}

//----- (10097F30) --------------------------------------------------------
void __usercall sub_10097F30(int a1@<ebp>)
{
  ClassDatabaseType::~ClassDatabaseType((ClassDatabaseType *)(a1 - 52));
}

//----- (10097F3D) --------------------------------------------------------
int __cdecl sub_10097F3D(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 76));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097F60) --------------------------------------------------------
int __cdecl sub_10097F60(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 24));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097F80) --------------------------------------------------------
void __usercall sub_10097F80(int a1@<ebp>)
{
  sub_10019D40(*(_DWORD *)(a1 + 8) + 36);
}

//----- (10097F8B) --------------------------------------------------------
int __cdecl sub_10097F8B(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 16));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097FB0) --------------------------------------------------------
void __usercall sub_10097FB0(int a1@<ebp>)
{
  sub_10019D40(*(_DWORD *)(a1 - 20) + 36);
}

//----- (10097FBB) --------------------------------------------------------
int __cdecl sub_10097FBB(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 24));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10097FF0) --------------------------------------------------------
void __usercall sub_10097FF0(int a1@<ebp>)
{
  operator delete(*(void **)(a1 - 20));
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (10097FFC) --------------------------------------------------------
int __cdecl sub_10097FFC(int a1, int a2)
{
  return _CxxFrameHandler3((a2 - 20) ^ *(_DWORD *)(a2 - 24));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10098020) --------------------------------------------------------
void sub_10098020()
{
  JUMPOUT(&loc_10043DC0);
}

//----- (10098028) --------------------------------------------------------
int __thiscall SEH_10049CF0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10098040) --------------------------------------------------------
void __usercall sub_10098040(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 1500));
}

//----- (1009804B) --------------------------------------------------------
void __usercall sub_1009804B(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 1488));
}

//----- (10098056) --------------------------------------------------------
int __thiscall SEH_10048A60(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10098060) --------------------------------------------------------
void __usercall sub_10098060(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 788));
}

//----- (1009806B) --------------------------------------------------------
void __usercall sub_1009806B(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 816));
}

//----- (10098076) --------------------------------------------------------
int __thiscall SEH_10044ED0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10098080) --------------------------------------------------------
void __usercall sub_10098080(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 652));
}

//----- (1009808B) --------------------------------------------------------
void __usercall sub_1009808B(int a1@<ebp>)
{
  sub_10037D80((int *)(a1 - 616));
}

//----- (10098096) --------------------------------------------------------
int __thiscall SEH_10043E90(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100980A0) --------------------------------------------------------
void __usercall sub_100980A0(int a1@<ebp>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 - 768 + 76);
  if ( v1 )
  {
    if ( v1 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(v1, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

//----- (100980AB) --------------------------------------------------------
int __thiscall SEH_100438D0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100980C0) --------------------------------------------------------
void sub_100980C0()
{
  JUMPOUT(&loc_10043E00);
}

//----- (100980D0) --------------------------------------------------------
int __thiscall sub_100980D0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100980E0) --------------------------------------------------------
void sub_100980E0()
{
  JUMPOUT(&loc_1003F6E0);
}

//----- (100980EB) --------------------------------------------------------
int __thiscall SEH_10041CA0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10098100) --------------------------------------------------------
void __usercall sub_10098100(int a1@<ebp>)
{
  sub_100388E0(a1 - 40);
}

//----- (1009810A) --------------------------------------------------------
int __thiscall SEH_1003CB20(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10098120) --------------------------------------------------------
void sub_10098120()
{
  JUMPOUT(&loc_10043E60);
}

//----- (10098130) --------------------------------------------------------
int __thiscall SEH_10039DA0(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10098140) --------------------------------------------------------
void __usercall sub_10098140(int a1@<ebp>)
{
  sub_10038C00((void *)(a1 - 1892));
}

//----- (1009814B) --------------------------------------------------------
int __usercall sub_1009814B@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 1880), 0xCu, 6, sub_10038C00);
}

//----- (10098161) --------------------------------------------------------
int __usercall sub_10098161@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 1672), 0x18u, 4, sub_10038C90);
}

//----- (10098177) --------------------------------------------------------
int __thiscall SEH_10037E90(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10098190) --------------------------------------------------------
void __usercall sub_10098190(int a1@<ebp>)
{
  sub_1006E990(*(_DWORD *)(a1 + 4) + 8);
}

//----- (1009819D) --------------------------------------------------------
void __usercall sub_1009819D(int a1@<ebp>)
{
  sub_1006BE80(*(_DWORD *)(a1 + 4) + 5224);
}

//----- (100981AC) --------------------------------------------------------
int __thiscall sub_100981AC(void *this)
{
  return _CxxFrameHandler3(this);
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100981C0) --------------------------------------------------------
void __usercall sub_100981C0(int a1@<ebp>)
{
  sub_1001D0B0((void *)(a1 - 1912));
}

//----- (100981CB) --------------------------------------------------------
void sub_100981CB()
{
  JUMPOUT(&loc_100216C0);
}

//----- (100981D6) --------------------------------------------------------
int __cdecl sub_100981D6(int a1, int a2)
{
  int v2; // ecx@1

  v2 = (a2 + 12) ^ *(_DWORD *)(a2 - 1924);
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 4));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10098200) --------------------------------------------------------
void __usercall sub_10098200(int a1@<ebp>)
{
  sub_1001D0B0((void *)(a1 - 48));
}

//----- (10098208) --------------------------------------------------------
int __cdecl sub_10098208(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 52));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10098230) --------------------------------------------------------
void __usercall sub_10098230(int a1@<ebp>)
{
  sub_1001D0B0((void *)(a1 - 508));
}

//----- (1009823B) --------------------------------------------------------
void sub_1009823B()
{
  JUMPOUT(&loc_100216C0);
}

//----- (10098246) --------------------------------------------------------
int __cdecl sub_10098246(int a1, int a2)
{
  int v2; // ecx@1

  v2 = (a2 + 12) ^ *(_DWORD *)(a2 - 516);
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 4));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10098270) --------------------------------------------------------
int __usercall sub_10098270@<eax>(int a1@<ebp>)
{
  return `eh vector destructor iterator'((void *)(a1 - 88), 0x18u, 2, sub_1001D0B0);
}

//----- (100982A0) --------------------------------------------------------
void __usercall sub_100982A0(int a1@<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 - 16) + 4;
  if ( *(_DWORD *)(*(_DWORD *)(a1 - 16) + 28) )
    operator delete(*(void **)(*(_DWORD *)(a1 - 16) + 28));
  *(_DWORD *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 28) = 0;
  *(_DWORD *)(v1 + 32) = 0;
}
// 10099194: using guessed type void __cdecl operator delete(void *);

//----- (100982AB) --------------------------------------------------------
int __cdecl sub_100982AB(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 16));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100982D0) --------------------------------------------------------
void __usercall sub_100982D0(int a1@<ebp>)
{
  sub_10019D40(*(_DWORD *)(a1 - 16) + 36);
}

//----- (100982DB) --------------------------------------------------------
void __usercall sub_100982DB(int a1@<ebp>)
{
  ClassDatabaseType::~ClassDatabaseType((ClassDatabaseType *)(a1 - 56));
}

//----- (100982ED) --------------------------------------------------------
int __cdecl sub_100982ED(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 60));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10098310) --------------------------------------------------------
void __usercall sub_10098310(int a1@<ebp>)
{
  if ( *(_DWORD *)(a1 - 32 + 12) )
    free(*(void **)(a1 - 32 + 12));
}

//----- (10098318) --------------------------------------------------------
int __cdecl sub_10098318(int a1, int a2)
{
  return _CxxFrameHandler3((a2 - 52) ^ *(_DWORD *)(a2 - 56));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10098340) --------------------------------------------------------
void sub_10098340()
{
  JUMPOUT(&loc_1000A800);
}

//----- (10098348) --------------------------------------------------------
void sub_10098348()
{
  JUMPOUT(&loc_1000A800);
}

//----- (10098350) --------------------------------------------------------
void __usercall sub_10098350(int a1@<ebp>)
{
  ClassDatabaseType::~ClassDatabaseType((ClassDatabaseType *)(a1 - 48));
}

//----- (10098362) --------------------------------------------------------
int __cdecl sub_10098362(int a1, int a2)
{
  return _CxxFrameHandler3((a2 - 116) ^ *(_DWORD *)(a2 - 120));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (10098385) --------------------------------------------------------
int __cdecl sub_10098385(int a1, int a2)
{
  return _CxxFrameHandler3((a2 + 12) ^ *(_DWORD *)(a2 - 12));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100983A0) --------------------------------------------------------
void sub_100983A0()
{
  JUMPOUT(&loc_100179C0);
}

//----- (100983A8) --------------------------------------------------------
int __cdecl sub_100983A8(int a1, int a2)
{
  return _CxxFrameHandler3((a2 - 124) ^ *(_DWORD *)(a2 - 128));
}
// 10095F5E: using guessed type int __thiscall _CxxFrameHandler3(_DWORD);

//----- (100983D0) --------------------------------------------------------
char sub_100983D0()
{
  char v1; // [sp+0h] [bp-24h]@1
  unsigned int v2; // [sp+14h] [bp-10h]@1

  GetSystemInfo((LPSYSTEM_INFO)&v1);
  dword_100AD974 = 1;
  if ( v2 >= 1 )
    dword_100AD974 = v2;
  byte_100AE9F8 = 1;
  sub_1001CC60();
  sub_10090550();
  sub_1008F500();
  return sub_1008C280();
}
// 100AD974: using guessed type int dword_100AD974;
// 100AE9F8: using guessed type char byte_100AE9F8;

//----- (10098420) --------------------------------------------------------
int sub_10098420()
{
  return atexit(sub_10098450);
}

//----- (10098430) --------------------------------------------------------
int sub_10098430()
{
  return atexit(sub_100984A0);
}

//----- (10098450) --------------------------------------------------------
void __cdecl sub_10098450()
{
  int v0; // eax@2

  if ( dword_100C17A0 )
  {
    v0 = dword_100C17A0 - 8;
    if ( *(_DWORD *)(dword_100C17A0 - 4) == ~*(_DWORD *)(dword_100C17A0 - 8) && dword_100C17A0 != 8 )
    {
      if ( v0 & 7 )
        sub_100927E0((int)"crnlib_free: bad ptr");
      else
        off_100AD9F4(v0, 0, 0, 1, dword_100AE9F4);
    }
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;
// 100C17A0: using guessed type int dword_100C17A0;

//----- (100984A0) --------------------------------------------------------
void __cdecl sub_100984A0()
{
  if ( dword_100C17A4 )
  {
    if ( (unsigned __int8)dword_100C17A4 & 7 )
      sub_100927E0((int)"crnlib_free: bad ptr");
    else
      off_100AD9F4(dword_100C17A4, 0, 0, 1, dword_100AE9F4);
  }
}
// 100AD9F4: using guessed type int (__cdecl *off_100AD9F4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100AE9F4: using guessed type int dword_100AE9F4;

// ALL OK, 1968 function(s) have been successfully decompiled
